[
    {
        "cve_id": "CVE-2019-14452",
        "func_name": "Sigil-Ebook/Sigil/Utility::UnZip",
        "description": "Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction.",
        "git_url": "https://github.com/Sigil-Ebook/Sigil/commit/0979ba8d10c96ebca330715bfd4494ea0e019a8f",
        "commit_title": "harden plugin unzipping to zip-slip attacks",
        "commit_text": "",
        "func_before": "bool Utility::UnZip(const QString &zippath, const QString &destpath)\n{\n    int res = 0;\n    QDir dir(destpath);\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());\n#endif\n\n    if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {\n        return false;\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                // Full file path in the temporary directory.\n                QString file_path = destpath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = destpath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        return false;\n    }\n\n    unzClose(zfile);\n    return true;\n}",
        "func": "bool Utility::UnZip(const QString &zippath, const QString &destpath)\n{\n    int res = 0;\n    QDir dir(destpath);\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(zippath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(zippath).toUtf8().constData());\n#endif\n\n    if ((zfile == NULL) || (!IsFileReadable(zippath)) || (!dir.exists())) {\n        return false;\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons against maliciously crafted zip archives\n\t        // we need the file path to always be inside the target folder \n\t        // and not outside, so we will remove all illegal backslashes\n\t        // and all relative upward paths segments \"/../\" from the zip's local \n\t        // file name/path before prepending the target folder to create \n\t        // the final path\n\n\t        QString original_path = qfile_name;\n\t        bool evil_or_corrupt_epub = false;\n\n\t        if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n\n\t        if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n\n\t        while(qfile_name.startsWith(\"/\")) { \n\t\t  qfile_name = qfile_name.remove(0,1);\n\t        }\n                \n\t        if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n\n\t        if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n\n\t        while(cp437_file_name.startsWith(\"/\")) { \n\t\t  cp437_file_name = cp437_file_name.remove(0,1);\n\t        }\n\n\t        if (evil_or_corrupt_epub) {\n\t\t    unzCloseCurrentFile(zfile);\n\t\t    unzClose(zfile);\n\t\t    // throw (UNZIPLoadParseError(QString(QObject::tr(\"Possible evil or corrupt zip file name: %1\")).arg(original_path).toStdString()));\n                    return false;\n\t        }\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                // Full file path in the temporary directory.\n                QString file_path = destpath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    return false;\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    return false;\n                }\n\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = destpath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        return false;\n    }\n\n    unzClose(zfile);\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,6 +36,44 @@\n \n             // If there is no file name then we can't do anything with it.\n             if (!qfile_name.isEmpty()) {\n+\n+\t        // for security reasons against maliciously crafted zip archives\n+\t        // we need the file path to always be inside the target folder \n+\t        // and not outside, so we will remove all illegal backslashes\n+\t        // and all relative upward paths segments \"/../\" from the zip's local \n+\t        // file name/path before prepending the target folder to create \n+\t        // the final path\n+\n+\t        QString original_path = qfile_name;\n+\t        bool evil_or_corrupt_epub = false;\n+\n+\t        if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n+\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n+\n+\t        if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n+\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n+\n+\t        while(qfile_name.startsWith(\"/\")) { \n+\t\t  qfile_name = qfile_name.remove(0,1);\n+\t        }\n+                \n+\t        if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n+\t        cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n+\n+\t        if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n+\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n+\n+\t        while(cp437_file_name.startsWith(\"/\")) { \n+\t\t  cp437_file_name = cp437_file_name.remove(0,1);\n+\t        }\n+\n+\t        if (evil_or_corrupt_epub) {\n+\t\t    unzCloseCurrentFile(zfile);\n+\t\t    unzClose(zfile);\n+\t\t    // throw (UNZIPLoadParseError(QString(QObject::tr(\"Possible evil or corrupt zip file name: %1\")).arg(original_path).toStdString()));\n+                    return false;\n+\t        }\n+\n                 // We use the dir object to create the path in the temporary directory.\n                 // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                 // Full file path in the temporary directory.",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t        // for security reasons against maliciously crafted zip archives",
                "\t        // we need the file path to always be inside the target folder ",
                "\t        // and not outside, so we will remove all illegal backslashes",
                "\t        // and all relative upward paths segments \"/../\" from the zip's local ",
                "\t        // file name/path before prepending the target folder to create ",
                "\t        // the final path",
                "",
                "\t        QString original_path = qfile_name;",
                "\t        bool evil_or_corrupt_epub = false;",
                "",
                "\t        if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; ",
                "\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");",
                "",
                "\t        if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;",
                "\t        qfile_name = qfile_name.replace(\"/../\",\"/\");",
                "",
                "\t        while(qfile_name.startsWith(\"/\")) { ",
                "\t\t  qfile_name = qfile_name.remove(0,1);",
                "\t        }",
                "                ",
                "\t        if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; ",
                "\t        cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");",
                "",
                "\t        if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;",
                "\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");",
                "",
                "\t        while(cp437_file_name.startsWith(\"/\")) { ",
                "\t\t  cp437_file_name = cp437_file_name.remove(0,1);",
                "\t        }",
                "",
                "\t        if (evil_or_corrupt_epub) {",
                "\t\t    unzCloseCurrentFile(zfile);",
                "\t\t    unzClose(zfile);",
                "\t\t    // throw (UNZIPLoadParseError(QString(QObject::tr(\"Possible evil or corrupt zip file name: %1\")).arg(original_path).toStdString()));",
                "                    return false;",
                "\t        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14452",
        "func_name": "Sigil-Ebook/Sigil/ImportEPUB::ExtractContainer",
        "description": "Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction.",
        "git_url": "https://github.com/Sigil-Ebook/Sigil/commit/04e2f280cc4a0766bedcc7b9eb56449ceecc2ad4",
        "commit_title": "further harden against malicious epubs and produce error message",
        "commit_text": "",
        "func_before": "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons we need the file path to always be inside the \n                // target folder and not outside, so we will remove all relative upward \n                // paths segments \"..\" from the file path before prepending the target \n                // folder to create the final target path\n\t        qfile_name = qfile_name.replace(\"../\",\"\");\n                cp437_file_name = cp437_file_name.replace(\"../\",\"\");\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}",
        "func": "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons against maliciously crafted zip archives\n                // we need the file path to always be inside the target folder \n                // and not outside, so we will remove all illegal backslashes\n                // and all relative upward paths segments \"/../\" from the zip's local \n                // file name/path before prepending the target folder to create \n                // the final path\n\n\t        QString original_path = qfile_name;\n\t        bool evil_or_corrupt_epub = false;\n\n                if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n\n                if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n\n                while(qfile_name.startsWith(\"/\")) { \n\t\t    qfile_name = qfile_name.remove(0,1);\n\t\t}\n\n                if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n                cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n\n                if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n\n                while(cp437_file_name.startsWith(\"/\")) { \n\t\t    cp437_file_name = cp437_file_name.remove(0,1);\n\t\t}\n\n                if (evil_or_corrupt_epub) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Possible evil or corrupt epub file name: %1\")).arg(original_path).toStdString()));\n                }\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,12 +36,41 @@\n             // If there is no file name then we can't do anything with it.\n             if (!qfile_name.isEmpty()) {\n \n-\t        // for security reasons we need the file path to always be inside the \n-                // target folder and not outside, so we will remove all relative upward \n-                // paths segments \"..\" from the file path before prepending the target \n-                // folder to create the final target path\n-\t        qfile_name = qfile_name.replace(\"../\",\"\");\n-                cp437_file_name = cp437_file_name.replace(\"../\",\"\");\n+\t        // for security reasons against maliciously crafted zip archives\n+                // we need the file path to always be inside the target folder \n+                // and not outside, so we will remove all illegal backslashes\n+                // and all relative upward paths segments \"/../\" from the zip's local \n+                // file name/path before prepending the target folder to create \n+                // the final path\n+\n+\t        QString original_path = qfile_name;\n+\t        bool evil_or_corrupt_epub = false;\n+\n+                if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n+\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");\n+\n+                if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n+\t        qfile_name = qfile_name.replace(\"/../\",\"/\");\n+\n+                while(qfile_name.startsWith(\"/\")) { \n+\t\t    qfile_name = qfile_name.remove(0,1);\n+\t\t}\n+\n+                if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; \n+                cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");\n+\n+                if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;\n+\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");\n+\n+                while(cp437_file_name.startsWith(\"/\")) { \n+\t\t    cp437_file_name = cp437_file_name.remove(0,1);\n+\t\t}\n+\n+                if (evil_or_corrupt_epub) {\n+                    unzCloseCurrentFile(zfile);\n+                    unzClose(zfile);\n+                    throw (EPUBLoadParseError(QString(QObject::tr(\"Possible evil or corrupt epub file name: %1\")).arg(original_path).toStdString()));\n+                }\n \n                 // We use the dir object to create the path in the temporary directory.\n                 // Unfortunately, we need a dir ojbect to do this as it's not a static function.",
        "diff_line_info": {
            "deleted_lines": [
                "\t        // for security reasons we need the file path to always be inside the ",
                "                // target folder and not outside, so we will remove all relative upward ",
                "                // paths segments \"..\" from the file path before prepending the target ",
                "                // folder to create the final target path",
                "\t        qfile_name = qfile_name.replace(\"../\",\"\");",
                "                cp437_file_name = cp437_file_name.replace(\"../\",\"\");"
            ],
            "added_lines": [
                "\t        // for security reasons against maliciously crafted zip archives",
                "                // we need the file path to always be inside the target folder ",
                "                // and not outside, so we will remove all illegal backslashes",
                "                // and all relative upward paths segments \"/../\" from the zip's local ",
                "                // file name/path before prepending the target folder to create ",
                "                // the final path",
                "",
                "\t        QString original_path = qfile_name;",
                "\t        bool evil_or_corrupt_epub = false;",
                "",
                "                if (qfile_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; ",
                "\t        qfile_name = \"/\" + qfile_name.replace(\"\\\\\",\"\");",
                "",
                "                if (qfile_name.contains(\"/../\")) evil_or_corrupt_epub = true;",
                "\t        qfile_name = qfile_name.replace(\"/../\",\"/\");",
                "",
                "                while(qfile_name.startsWith(\"/\")) { ",
                "\t\t    qfile_name = qfile_name.remove(0,1);",
                "\t\t}",
                "",
                "                if (cp437_file_name.contains(\"\\\\\")) evil_or_corrupt_epub = true; ",
                "                cp437_file_name = \"/\" + cp437_file_name.replace(\"\\\\\",\"\");",
                "",
                "                if (cp437_file_name.contains(\"/../\")) evil_or_corrupt_epub = true;",
                "\t        cp437_file_name = cp437_file_name.replace(\"/../\",\"/\");",
                "",
                "                while(cp437_file_name.startsWith(\"/\")) { ",
                "\t\t    cp437_file_name = cp437_file_name.remove(0,1);",
                "\t\t}",
                "",
                "                if (evil_or_corrupt_epub) {",
                "                    unzCloseCurrentFile(zfile);",
                "                    unzClose(zfile);",
                "                    throw (EPUBLoadParseError(QString(QObject::tr(\"Possible evil or corrupt epub file name: %1\")).arg(original_path).toStdString()));",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14452",
        "func_name": "Sigil-Ebook/Sigil/ImportEPUB::ExtractContainer",
        "description": "Sigil before 0.9.16 is vulnerable to a directory traversal, allowing attackers to write arbitrary files via a ../ (dot dot slash) in a ZIP archive entry that is mishandled during extraction.",
        "git_url": "https://github.com/Sigil-Ebook/Sigil/commit/369eebe936e4a8c83cc54662a3412ce8bef189e4",
        "commit_title": "do not allow zip files to have upward relative path sections",
        "commit_text": "",
        "func_before": "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}",
        "func": "void ImportEPUB::ExtractContainer()\n{\n    int res = 0;\n    if (!cp437) {\n        cp437 = new QCodePage437Codec();\n    }\n#ifdef Q_OS_WIN32\n    zlib_filefunc64_def ffunc;\n    fill_win32_filefunc64W(&ffunc);\n    unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc);\n#else\n    unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData());\n#endif\n\n    if (zfile == NULL) {\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot unzip EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    res = unzGoToFirstFile(zfile);\n\n    if (res == UNZ_OK) {\n        do {\n            // Get the name of the file in the archive.\n            char file_name[MAX_PATH] = {0};\n            unz_file_info64 file_info;\n            unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0);\n            QString qfile_name;\n            QString cp437_file_name;\n            qfile_name = QString::fromUtf8(file_name);\n            if (!(file_info.flag & (1<<11))) {\n                // General purpose bit 11 says the filename is utf-8 encoded. If not set then\n                // IBM 437 encoding might be used.\n                cp437_file_name = cp437->toUnicode(file_name);\n            }\n\n            // If there is no file name then we can't do anything with it.\n            if (!qfile_name.isEmpty()) {\n\n\t        // for security reasons we need the file path to always be inside the \n                // target folder and not outside, so we will remove all relative upward \n                // paths segments \"..\" from the file path before prepending the target \n                // folder to create the final target path\n\t        qfile_name = qfile_name.replace(\"../\",\"\");\n                cp437_file_name = cp437_file_name.replace(\"../\",\"\");\n\n                // We use the dir object to create the path in the temporary directory.\n                // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                QDir dir(m_ExtractedFolderPath);\n                // Full file path in the temporary directory.\n                QString file_path = m_ExtractedFolderPath + \"/\" + qfile_name;\n                QFileInfo qfile_info(file_path);\n\n                // Is this entry a directory?\n                if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) {\n                    dir.mkpath(qfile_name);\n                    continue;\n                } else {\n                    dir.mkpath(qfile_info.path());\n\t\t    // add it to the list of files found inside the zip\n\t\t    if (cp437_file_name.isEmpty()) {\n\t\t        m_ZipFilePaths << qfile_name;\n\t\t    } else {\n                        m_ZipFilePaths << cp437_file_name;\n\t\t    }\n                }\n\n                // Open the file entry in the archive for reading.\n                if (unzOpenCurrentFile(zfile) != UNZ_OK) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Open the file on disk to write the entry in the archive to.\n                QFile entry(file_path);\n\n                if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // Buffered reading and writing.\n                char buff[BUFF_SIZE] = {0};\n                int read = 0;\n\n                while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) {\n                    entry.write(buff, read);\n                }\n\n                entry.close();\n\n                // Read errors are marked by a negative read amount.\n                if (read < 0) {\n                    unzCloseCurrentFile(zfile);\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n\n                // The file was read but the CRC did not match.\n                // We don't check the read file size vs the uncompressed file size\n                // because if they're different there should be a CRC error.\n                if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) {\n                    unzClose(zfile);\n                    throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot extract file: %1\")).arg(qfile_name).toStdString()));\n                }\n                if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) {\n                    QString cp437_file_path = m_ExtractedFolderPath + \"/\" + cp437_file_name;\n                    QFile::copy(file_path, cp437_file_path);\n                }\n            }\n        } while ((res = unzGoToNextFile(zfile)) == UNZ_OK);\n    }\n\n    if (res != UNZ_END_OF_LIST_OF_FILE) {\n        unzClose(zfile);\n        throw (EPUBLoadParseError(QString(QObject::tr(\"Cannot open EPUB: %1\")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString()));\n    }\n\n    unzClose(zfile);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,14 @@\n \n             // If there is no file name then we can't do anything with it.\n             if (!qfile_name.isEmpty()) {\n+\n+\t        // for security reasons we need the file path to always be inside the \n+                // target folder and not outside, so we will remove all relative upward \n+                // paths segments \"..\" from the file path before prepending the target \n+                // folder to create the final target path\n+\t        qfile_name = qfile_name.replace(\"../\",\"\");\n+                cp437_file_name = cp437_file_name.replace(\"../\",\"\");\n+\n                 // We use the dir object to create the path in the temporary directory.\n                 // Unfortunately, we need a dir ojbect to do this as it's not a static function.\n                 QDir dir(m_ExtractedFolderPath);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t        // for security reasons we need the file path to always be inside the ",
                "                // target folder and not outside, so we will remove all relative upward ",
                "                // paths segments \"..\" from the file path before prepending the target ",
                "                // folder to create the final target path",
                "\t        qfile_name = qfile_name.replace(\"../\",\"\");",
                "                cp437_file_name = cp437_file_name.replace(\"../\",\"\");",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15518",
        "func_name": "swoole/swoole-src/swPort_http_static_handler",
        "description": "Swoole before 4.2.13 allows directory traversal in swPort_http_static_handler.",
        "git_url": "https://github.com/swoole/swoole-src/commit/32791110749d7b57ee3007af58411823bf6f5789",
        "commit_title": "fix directory traversal bug",
        "commit_text": "",
        "func_before": "static int swPort_http_static_handler(swServer *serv, swHttpRequest *request, swConnection *conn)\n{\n    char *url = request->buffer->str + request->url_offset;\n    char *params = memchr(url, '?', request->url_length);\n\n    struct\n    {\n        off_t offset;\n        size_t length;\n        char filename[PATH_MAX];\n    } buffer;\n\n    char *p = buffer.filename;\n\n    memcpy(p, serv->document_root, serv->document_root_len);\n    p += serv->document_root_len;\n    uint32_t n = params ? params - url : request->url_length;\n    memcpy(p, url, n);\n    p += n;\n    *p = 0;\n\n    struct stat file_stat;\n    if (lstat(buffer.filename, &file_stat) < 0)\n    {\n        return SW_FALSE;\n    }\n    if (file_stat.st_size == 0)\n    {\n        return SW_FALSE;\n    }\n    if ((file_stat.st_mode & S_IFMT) != S_IFREG)\n    {\n        return SW_FALSE;\n    }\n\n    char header_buffer[1024];\n    swSendData response;\n    response.info.fd = conn->session_id;\n\n    response.info.type = SW_EVENT_TCP;\n\n    p = request->buffer->str + request->url_offset + request->url_length + 10;\n    char *pe = request->buffer->str + request->header_length;\n\n    char *date_if_modified_since = NULL;\n    int length_if_modified_since = 0;\n\n    int state = 0;\n    for (; p < pe; p++)\n    {\n        switch(state)\n        {\n        case 0:\n            if (strncasecmp(p, SW_STRL(\"If-Modified-Since\")) == 0)\n            {\n                p += sizeof(\"If-Modified-Since\");\n                state = 1;\n            }\n            break;\n        case 1:\n            if (!isspace(*p))\n            {\n                date_if_modified_since = p;\n                state = 2;\n            }\n            break;\n        case 2:\n            if (strncasecmp(p, SW_STRL(\"\\r\\n\")) == 0)\n            {\n                length_if_modified_since = p - date_if_modified_since;\n                goto check_modify_date;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    char date_[64];\n    struct tm *tm1;\n\n    check_modify_date: tm1 = gmtime(&serv->gs->now);\n    strftime(date_, sizeof(date_), \"%a, %d %b %Y %H:%M:%S %Z\", tm1);\n\n    char date_last_modified[64];\n#ifdef __MACH__\n    time_t file_mtime = file_stat.st_mtimespec.tv_sec;\n#elif defined(_WIN32)\n\ttime_t file_mtime = file_stat.st_mtime;\n#else\n    time_t file_mtime = file_stat.st_mtim.tv_sec;\n#endif\n\n    struct tm *tm2 = gmtime(&file_mtime);\n    strftime(date_last_modified, sizeof(date_last_modified), \"%a, %d %b %Y %H:%M:%S %Z\", tm2);\n\n    if (state == 2)\n    {\n        struct tm tm3;\n        char date_tmp[64];\n        memcpy(date_tmp, date_if_modified_since, length_if_modified_since);\n        date_tmp[length_if_modified_since] = 0;\n\n        char *date_format = NULL;\n\n        if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_GMT, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC1123_DATE_GMT;\n        }\n        else if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_UTC, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC1123_DATE_UTC;\n        }\n        else if (strptime(date_tmp, SW_HTTP_RFC850_DATE, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC850_DATE;\n        }\n        else if (strptime(date_tmp, SW_HTTP_ASCTIME_DATE, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_ASCTIME_DATE;\n        }\n        if (date_format && mktime(&tm3) - (int) timezone >= file_mtime)\n        {\n            response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),\n                    \"HTTP/1.1 304 Not Modified\\r\\n\"\n                    \"%s\"\n                    \"Date: %s\\r\\n\"\n                    \"Last-Modified: %s\\r\\n\"\n                    \"Server: %s\\r\\n\\r\\n\",\n                    request->keep_alive ? \"Connection: keep-alive\\r\\n\" : \"\",\n                    date_,\n                    date_last_modified,\n                    SW_HTTP_SERVER_SOFTWARE\n            );\n            response.data = header_buffer;\n            swServer_master_send(serv, &response);\n            goto _finish;\n        }\n    }\n\n    response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"%s\"\n            \"Content-Length: %ld\\r\\n\"\n            \"Content-Type: %s\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"Last-Modified: %s\\r\\n\"\n            \"Server: %s\\r\\n\\r\\n\",\n            request->keep_alive ? \"Connection: keep-alive\\r\\n\" : \"\",\n            (long) file_stat.st_size,\n            swoole_get_mime_type(buffer.filename),\n            date_,\n            date_last_modified,\n            SW_HTTP_SERVER_SOFTWARE);\n\n    response.data = header_buffer;\n\n#ifdef HAVE_TCP_NOPUSH\n    if (conn->tcp_nopush == 0)\n    {\n        if (swSocket_tcp_nopush(conn->fd, 1) == -1)\n        {\n            swWarn(\"swSocket_tcp_nopush() failed. Error: %s[%d]\", strerror(errno), errno);\n        }\n        conn->tcp_nopush = 1;\n    }\n#endif\n    swServer_master_send(serv, &response);\n\n    buffer.offset = 0;\n    buffer.length = file_stat.st_size;\n\n    response.info.type = SW_EVENT_SENDFILE;\n    response.length = response.info.len = sizeof(swSendFile_request) + buffer.length + 1;\n    response.data = (void*) &buffer;\n\n    swServer_master_send(serv, &response);\n\n    _finish:\n    if (!request->keep_alive)\n    {\n        response.info.type = SW_EVENT_CLOSE;\n        response.length = 0;\n        response.data = NULL;\n        swServer_master_send(serv, &response);\n    }\n\n    return SW_TRUE;\n}",
        "func": "static int swPort_http_static_handler(swServer *serv, swHttpRequest *request, swConnection *conn)\n{\n    char *url = request->buffer->str + request->url_offset;\n    char *params = memchr(url, '?', request->url_length);\n\n    struct\n    {\n        off_t offset;\n        size_t length;\n        char filename[PATH_MAX];\n    } buffer;\n\n    char *p = buffer.filename;\n\n    memcpy(p, serv->document_root, serv->document_root_len);\n    p += serv->document_root_len;\n    uint32_t n = params ? params - url : request->url_length;\n    memcpy(p, url, n);\n    p += n;\n    *p = 0;\n\n    char real_path[PATH_MAX];\n    if (!realpath(buffer.filename, real_path))\n    {\n        return SW_FALSE;\n    }\n\n    if (real_path[serv->document_root_len] != '/')\n    {\n        return SW_FALSE;\n    }\n\n    if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)\n    {\n        return SW_FALSE;\n    }\n\n    struct stat file_stat;\n    if (lstat(buffer.filename, &file_stat) < 0)\n    {\n        return SW_FALSE;\n    }\n    if (file_stat.st_size == 0)\n    {\n        return SW_FALSE;\n    }\n    if ((file_stat.st_mode & S_IFMT) != S_IFREG)\n    {\n        return SW_FALSE;\n    }\n\n    char header_buffer[1024];\n    swSendData response;\n    response.info.fd = conn->session_id;\n\n    response.info.type = SW_EVENT_TCP;\n\n    p = request->buffer->str + request->url_offset + request->url_length + 10;\n    char *pe = request->buffer->str + request->header_length;\n\n    char *date_if_modified_since = NULL;\n    int length_if_modified_since = 0;\n\n    int state = 0;\n    for (; p < pe; p++)\n    {\n        switch(state)\n        {\n        case 0:\n            if (strncasecmp(p, SW_STRL(\"If-Modified-Since\")) == 0)\n            {\n                p += sizeof(\"If-Modified-Since\");\n                state = 1;\n            }\n            break;\n        case 1:\n            if (!isspace(*p))\n            {\n                date_if_modified_since = p;\n                state = 2;\n            }\n            break;\n        case 2:\n            if (strncasecmp(p, SW_STRL(\"\\r\\n\")) == 0)\n            {\n                length_if_modified_since = p - date_if_modified_since;\n                goto check_modify_date;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    char date_[64];\n    struct tm *tm1;\n\n    check_modify_date: tm1 = gmtime(&serv->gs->now);\n    strftime(date_, sizeof(date_), \"%a, %d %b %Y %H:%M:%S %Z\", tm1);\n\n    char date_last_modified[64];\n#ifdef __MACH__\n    time_t file_mtime = file_stat.st_mtimespec.tv_sec;\n#elif defined(_WIN32)\n\ttime_t file_mtime = file_stat.st_mtime;\n#else\n    time_t file_mtime = file_stat.st_mtim.tv_sec;\n#endif\n\n    struct tm *tm2 = gmtime(&file_mtime);\n    strftime(date_last_modified, sizeof(date_last_modified), \"%a, %d %b %Y %H:%M:%S %Z\", tm2);\n\n    if (state == 2)\n    {\n        struct tm tm3;\n        char date_tmp[64];\n        memcpy(date_tmp, date_if_modified_since, length_if_modified_since);\n        date_tmp[length_if_modified_since] = 0;\n\n        char *date_format = NULL;\n\n        if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_GMT, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC1123_DATE_GMT;\n        }\n        else if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_UTC, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC1123_DATE_UTC;\n        }\n        else if (strptime(date_tmp, SW_HTTP_RFC850_DATE, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC850_DATE;\n        }\n        else if (strptime(date_tmp, SW_HTTP_ASCTIME_DATE, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_ASCTIME_DATE;\n        }\n        if (date_format && mktime(&tm3) - (int) timezone >= file_mtime)\n        {\n            response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),\n                    \"HTTP/1.1 304 Not Modified\\r\\n\"\n                    \"%s\"\n                    \"Date: %s\\r\\n\"\n                    \"Last-Modified: %s\\r\\n\"\n                    \"Server: %s\\r\\n\\r\\n\",\n                    request->keep_alive ? \"Connection: keep-alive\\r\\n\" : \"\",\n                    date_,\n                    date_last_modified,\n                    SW_HTTP_SERVER_SOFTWARE\n            );\n            response.data = header_buffer;\n            swServer_master_send(serv, &response);\n            goto _finish;\n        }\n    }\n\n    response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"%s\"\n            \"Content-Length: %ld\\r\\n\"\n            \"Content-Type: %s\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"Last-Modified: %s\\r\\n\"\n            \"Server: %s\\r\\n\\r\\n\",\n            request->keep_alive ? \"Connection: keep-alive\\r\\n\" : \"\",\n            (long) file_stat.st_size,\n            swoole_get_mime_type(buffer.filename),\n            date_,\n            date_last_modified,\n            SW_HTTP_SERVER_SOFTWARE);\n\n    response.data = header_buffer;\n\n#ifdef HAVE_TCP_NOPUSH\n    if (conn->tcp_nopush == 0)\n    {\n        if (swSocket_tcp_nopush(conn->fd, 1) == -1)\n        {\n            swWarn(\"swSocket_tcp_nopush() failed. Error: %s[%d]\", strerror(errno), errno);\n        }\n        conn->tcp_nopush = 1;\n    }\n#endif\n    swServer_master_send(serv, &response);\n\n    buffer.offset = 0;\n    buffer.length = file_stat.st_size;\n\n    response.info.type = SW_EVENT_SENDFILE;\n    response.length = response.info.len = sizeof(swSendFile_request) + buffer.length + 1;\n    response.data = (void*) &buffer;\n\n    swServer_master_send(serv, &response);\n\n    _finish:\n    if (!request->keep_alive)\n    {\n        response.info.type = SW_EVENT_CLOSE;\n        response.length = 0;\n        response.data = NULL;\n        swServer_master_send(serv, &response);\n    }\n\n    return SW_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,22 @@\n     memcpy(p, url, n);\n     p += n;\n     *p = 0;\n+\n+    char real_path[PATH_MAX];\n+    if (!realpath(buffer.filename, real_path))\n+    {\n+        return SW_FALSE;\n+    }\n+\n+    if (real_path[serv->document_root_len] != '/')\n+    {\n+        return SW_FALSE;\n+    }\n+\n+    if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)\n+    {\n+        return SW_FALSE;\n+    }\n \n     struct stat file_stat;\n     if (lstat(buffer.filename, &file_stat) < 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    char real_path[PATH_MAX];",
                "    if (!realpath(buffer.filename, real_path))",
                "    {",
                "        return SW_FALSE;",
                "    }",
                "",
                "    if (real_path[serv->document_root_len] != '/')",
                "    {",
                "        return SW_FALSE;",
                "    }",
                "",
                "    if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)",
                "    {",
                "        return SW_FALSE;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15518",
        "func_name": "swoole/swoole-src/PHP_METHOD",
        "description": "Swoole before 4.2.13 allows directory traversal in swPort_http_static_handler.",
        "git_url": "https://github.com/swoole/swoole-src/commit/32791110749d7b57ee3007af58411823bf6f5789",
        "commit_title": "fix directory traversal bug",
        "commit_text": "",
        "func_before": "static PHP_METHOD(swoole_server, set)\n{\n    zval *zset = NULL;\n    zval *zobject = getThis();\n    HashTable *vht;\n\n    zval *v;\n\n    swServer *serv = (swServer *) swoole_get_object(zobject);\n    if (serv->gs->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is running. unable to execute function 'swoole_server_set'.\");\n        RETURN_FALSE;\n    }\n\n    ZEND_PARSE_PARAMETERS_START(1, 1)\n        Z_PARAM_ARRAY(zset)\n    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);\n\n    php_swoole_array_separate(zset);\n    vht = Z_ARRVAL_P(zset);\n\n    //chroot\n    if (php_swoole_array_get_value(vht, \"chroot\", v))\n    {\n        convert_to_string(v);\n        if (SwooleG.chroot)\n        {\n            sw_free(SwooleG.chroot);\n        }\n        SwooleG.chroot = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //user\n    if (php_swoole_array_get_value(vht, \"user\", v))\n    {\n        convert_to_string(v);\n        if (SwooleG.user)\n        {\n            sw_free(SwooleG.user);\n        }\n        SwooleG.user = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //group\n    if (php_swoole_array_get_value(vht, \"group\", v))\n    {\n        convert_to_string(v);\n        if (SwooleG.group)\n        {\n            sw_free(SwooleG.group);\n        }\n        SwooleG.group = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //daemonize\n    if (php_swoole_array_get_value(vht, \"daemonize\", v))\n    {\n        convert_to_boolean(v);\n        serv->daemonize = Z_BVAL_P(v);\n    }\n#ifdef SW_DEBUG\n    //debug\n    if (php_swoole_array_get_value(vht, \"debug_mode\", v))\n    {\n        convert_to_boolean(v);\n        if (Z_BVAL_P(v))\n        {\n            SwooleG.log_level = 0;\n        }\n    }\n#endif\n    if (php_swoole_array_get_value(vht, \"trace_flags\", v))\n    {\n        convert_to_long(v);\n        SwooleG.trace_flags = (uint32_t) MAX(0, Z_LVAL_P(v));\n    }\n    //pid file\n    if (php_swoole_array_get_value(vht, \"pid_file\", v))\n    {\n        convert_to_string(v);\n        if (serv->pid_file)\n        {\n            sw_free(serv->pid_file);\n        }\n        serv->pid_file = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //reactor thread num\n    if (php_swoole_array_get_value(vht, \"reactor_num\", v))\n    {\n        convert_to_long(v);\n        serv->reactor_num = (uint16_t) Z_LVAL_P(v);\n        if (serv->reactor_num <= 0)\n        {\n            serv->reactor_num = SwooleG.cpu_num;\n        }\n    }\n    //worker_num\n    if (php_swoole_array_get_value(vht, \"worker_num\", v))\n    {\n        convert_to_long(v);\n        serv->worker_num = (uint16_t) Z_LVAL_P(v);\n        if (serv->worker_num <= 0)\n        {\n            serv->worker_num = SwooleG.cpu_num;\n        }\n    }\n    //max wait time\n    if (php_swoole_array_get_value(vht, \"max_wait_time\", v))\n    {\n        convert_to_long(v);\n        serv->max_wait_time = (uint32_t) Z_LVAL_P(v);\n    }\n#ifdef SW_COROUTINE\n    if (php_swoole_array_get_value(vht, \"enable_coroutine\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_coroutine = SwooleG.enable_coroutine = Z_BVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"max_coro_num\", v) || php_swoole_array_get_value(vht, \"max_coroutine\", v))\n    {\n        zend_long max_num;\n        convert_to_long(v);\n        max_num = Z_LVAL_P(v);\n        PHPCoroutine::set_max_num(max_num <= 0 ? SW_DEFAULT_MAX_CORO_NUM : max_num);\n    }\n    if (php_swoole_array_get_value(vht, \"send_yield\", v))\n    {\n        convert_to_boolean(v);\n        serv->send_yield = Z_BVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"send_timeout\", v))\n    {\n        convert_to_double(v);\n        serv->send_timeout = Z_DVAL_P(v);\n    }\n#endif\n    //dispatch_mode\n    if (php_swoole_array_get_value(vht, \"dispatch_mode\", v))\n    {\n        convert_to_long(v);\n        serv->dispatch_mode = (uint8_t) Z_LVAL_P(v);\n    }\n    //dispatch function\n    if (php_swoole_array_get_value(vht, \"dispatch_func\", v))\n    {\n        swServer_dispatch_function c_dispatch_func = NULL;\n        while(1)\n        {\n            if (Z_TYPE_P(v) == IS_STRING)\n            {\n                c_dispatch_func = (swServer_dispatch_function) swoole_get_function(Z_STRVAL_P(v), Z_STRLEN_P(v));\n                if (c_dispatch_func)\n                {\n                    break;\n                }\n            }\n            char *func_name = NULL;\n            zend_fcall_info_cache *fci_cache = (zend_fcall_info_cache *) emalloc(sizeof(zend_fcall_info_cache));\n            if (!sw_zend_is_callable_ex(v, NULL, 0, &func_name, NULL, fci_cache, NULL))\n            {\n                swoole_php_fatal_error(E_ERROR, \"function '%s' is not callable\", func_name);\n                return;\n            }\n            efree(func_name);\n            sw_fci_cache_persist(fci_cache);\n            serv->private_data_3 = (void *) fci_cache;\n            c_dispatch_func = php_swoole_dispatch_func;\n            break;\n        }\n        if (c_dispatch_func)\n        {\n            serv->dispatch_mode = SW_DISPATCH_USERFUNC;\n            serv->dispatch_func = c_dispatch_func;\n        }\n    }\n    //log_file\n    if (php_swoole_array_get_value(vht, \"log_file\", v))\n    {\n        convert_to_string(v);\n        if (SwooleG.log_file)\n        {\n            sw_free(SwooleG.log_file);\n        }\n        SwooleG.log_file = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //log_level\n    if (php_swoole_array_get_value(vht, \"log_level\", v))\n    {\n        zend_long level;\n        convert_to_long(v);\n        level = Z_LVAL_P(v);\n        SwooleG.log_level = (uint32_t) (level < 0 ? UINT32_MAX : level);\n    }\n    /**\n     * for dispatch_mode = 1/3\n     */\n    if (php_swoole_array_get_value(vht, \"discard_timeout_request\", v))\n    {\n        convert_to_boolean(v);\n        serv->discard_timeout_request = (uint32_t) Z_BVAL_P(v);\n    }\n    //onConnect/onClose event\n    if (php_swoole_array_get_value(vht, \"enable_unsafe_event\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_unsafe_event = Z_BVAL_P(v);\n    }\n    //delay receive\n    if (php_swoole_array_get_value(vht, \"enable_delay_receive\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_delay_receive = Z_BVAL_P(v);\n    }\n    //task coroutine\n    if (php_swoole_array_get_value(vht, \"task_enable_coroutine\", v))\n    {\n        convert_to_boolean(v);\n        if (Z_BVAL_P(v))\n        {\n            if (!SwooleG.enable_coroutine)\n            {\n                swoole_php_fatal_error(E_ERROR, \"server->enable_coroutine must be true.\");\n                return;\n            }\n            serv->task_enable_coroutine = 1;\n        }\n        else\n        {\n            serv->task_enable_coroutine = 0;\n        }\n    }\n    //task_worker_num\n    if (php_swoole_array_get_value(vht, \"task_worker_num\", v))\n    {\n        convert_to_long(v);\n        serv->task_worker_num = (uint16_t) Z_LVAL_P(v);\n    }\n    //slowlog\n    if (php_swoole_array_get_value(vht, \"trace_event_worker\", v))\n    {\n        convert_to_boolean(v);\n        serv->trace_event_worker = Z_BVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"request_slowlog_timeout\", v))\n    {\n        convert_to_long(v);\n        serv->request_slowlog_timeout = (uint8_t) Z_LVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"request_slowlog_file\", v))\n    {\n        convert_to_string(v);\n        serv->request_slowlog_file = fopen(Z_STRVAL_P(v), \"a+\");\n        if (serv->request_slowlog_file == NULL)\n        {\n            swoole_php_fatal_error(E_ERROR, \"Unable to open request_slowlog_file[%s].\", Z_STRVAL_P(v));\n            return;\n        }\n        if (serv->request_slowlog_timeout == 0)\n        {\n            serv->request_slowlog_timeout = 1;\n        }\n    }\n    //task ipc mode, 1,2,3\n    if (php_swoole_array_get_value(vht, \"task_ipc_mode\", v))\n    {\n        convert_to_long(v);\n        serv->task_ipc_mode = (uint8_t) Z_LVAL_P(v);\n    }\n    /**\n     * Temporary file directory for task_worker\n     */\n    if (php_swoole_array_get_value(vht, \"task_tmpdir\", v))\n    {\n        convert_to_string(v);\n        if (php_swoole_create_dir(Z_STRVAL_P(v), Z_STRLEN_P(v)) < 0)\n        {\n            swoole_php_fatal_error(E_ERROR, \"Unable to create task_tmpdir[%s].\", Z_STRVAL_P(v));\n            return;\n        }\n        if (SwooleG.task_tmpdir)\n        {\n            sw_free(SwooleG.task_tmpdir);\n        }\n        SwooleG.task_tmpdir = (char*) sw_malloc(Z_STRLEN_P(v) + sizeof(SW_TASK_TMP_FILE) + 1);\n        SwooleG.task_tmpdir_len = sw_snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE, \"%s/swoole.task.XXXXXX\", Z_STRVAL_P(v)) + 1;\n    }\n    //task_max_request\n    if (php_swoole_array_get_value(vht, \"task_max_request\", v))\n    {\n        convert_to_long(v);\n        serv->task_max_request = (uint16_t) Z_LVAL_P(v);\n    }\n    //max_connection\n    if (php_swoole_array_get_value(vht, \"max_connection\", v) || php_swoole_array_get_value(vht, \"max_conn\", v))\n    {\n        convert_to_long(v);\n        serv->max_connection = (uint32_t) Z_LVAL_P(v);\n    }\n    //heartbeat_check_interval\n    if (php_swoole_array_get_value(vht, \"heartbeat_check_interval\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_check_interval = (uint16_t) Z_LVAL_P(v);\n    }\n    //heartbeat idle time\n    if (php_swoole_array_get_value(vht, \"heartbeat_idle_time\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_idle_time = (uint16_t) Z_LVAL_P(v);\n\n        if (serv->heartbeat_check_interval > serv->heartbeat_idle_time)\n        {\n            swoole_php_fatal_error(E_WARNING, \"heartbeat_idle_time must be greater than heartbeat_check_interval.\");\n            serv->heartbeat_check_interval = serv->heartbeat_idle_time / 2;\n        }\n    }\n    else if (serv->heartbeat_check_interval > 0)\n    {\n        serv->heartbeat_idle_time = serv->heartbeat_check_interval * 2;\n    }\n    //max_request\n    if (php_swoole_array_get_value(vht, \"max_request\", v))\n    {\n        convert_to_long(v);\n        serv->max_request = (uint32_t) Z_LVAL_P(v);\n    }\n    //reload async\n    if (php_swoole_array_get_value(vht, \"reload_async\", v))\n    {\n        convert_to_boolean(v);\n        serv->reload_async = Z_BVAL_P(v);\n    }\n    //cpu affinity\n    if (php_swoole_array_get_value(vht, \"open_cpu_affinity\", v))\n    {\n        convert_to_boolean(v);\n        serv->open_cpu_affinity = Z_BVAL_P(v);\n    }\n    //cpu affinity set\n    if (php_swoole_array_get_value(vht, \"cpu_affinity_ignore\", v))\n    {\n        int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(v));\n        if (ignore_num >= SW_CPU_NUM)\n        {\n            swoole_php_fatal_error(E_ERROR, \"cpu_affinity_ignore num must be less than cpu num (%d)\", SW_CPU_NUM);\n            RETURN_FALSE;\n        }\n        int available_num = SW_CPU_NUM - ignore_num;\n        int *available_cpu = (int *) sw_malloc(sizeof(int) * available_num);\n        int flag, i, available_i = 0;\n\n        zval *zval_core = NULL;\n        for (i = 0; i < SW_CPU_NUM; i++)\n        {\n            flag = 1;\n            SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(v), zval_core)\n                int core = (int) Z_LVAL_P(zval_core);\n                if (i == core)\n                {\n                    flag = 0;\n                    break;\n                }\n            SW_HASHTABLE_FOREACH_END();\n            if (flag)\n            {\n                available_cpu[available_i] = i;\n                available_i++;\n            }\n        }\n        serv->cpu_affinity_available_num = available_num;\n        serv->cpu_affinity_available = available_cpu;\n    }\n    //paser x-www-form-urlencoded form data\n    if (php_swoole_array_get_value(vht, \"http_parse_post\", v))\n    {\n        convert_to_boolean(v);\n        serv->http_parse_post = Z_BVAL_P(v);\n    }\n#ifdef SW_HAVE_ZLIB\n    //http content compression\n    if (php_swoole_array_get_value(vht, \"http_compression\", v))\n    {\n        convert_to_boolean(v);\n        serv->http_compression = Z_BVAL_P(v);\n        serv->http_compression_level = Z_BEST_SPEED;\n    }\n    if (php_swoole_array_get_value(vht, \"http_gzip_level\", v) || php_swoole_array_get_value(vht, \"http_compression_level\", v))\n    {\n        convert_to_long(v);\n        zend_long level = Z_LVAL_P(v);\n        if (level > UINT8_MAX)\n        {\n            level = UINT8_MAX;\n        }\n        else if (level < 0)\n        {\n            level = 0;\n        }\n        serv->http_compression_level = level;\n    }\n#endif\n    //temporary directory for HTTP uploaded file.\n    if (php_swoole_array_get_value(vht, \"upload_tmp_dir\", v))\n    {\n        convert_to_string(v);\n        if (php_swoole_create_dir(Z_STRVAL_P(v), Z_STRLEN_P(v)) < 0)\n        {\n            swoole_php_fatal_error(E_ERROR, \"Unable to create upload_tmp_dir[%s].\", Z_STRVAL_P(v));\n            return;\n        }\n        if (serv->upload_tmp_dir)\n        {\n            sw_free(serv->upload_tmp_dir);\n        }\n        serv->upload_tmp_dir = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    /**\n     * http static file handler\n     */\n    if (php_swoole_array_get_value(vht, \"enable_static_handler\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_static_handler = Z_BVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"document_root\", v))\n    {\n        convert_to_string(v);\n        if (serv->document_root)\n        {\n            sw_free(serv->document_root);\n        }\n        serv->document_root = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n        if (serv->document_root[Z_STRLEN_P(v) - 1] == '/')\n        {\n            serv->document_root[Z_STRLEN_P(v) - 1] = 0;\n            serv->document_root_len = Z_STRLEN_P(v) - 1;\n        }\n        else\n        {\n            serv->document_root_len = Z_STRLEN_P(v);\n        }\n    }\n    /**\n     * buffer input size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_input_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_input_size = (uint32_t) Z_LVAL_P(v);\n    }\n    /**\n     * buffer output size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_output_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_output_size = (uint32_t) Z_LVAL_P(v);\n    }\n    //message queue key\n    if (php_swoole_array_get_value(vht, \"message_queue_key\", v))\n    {\n        convert_to_long(v);\n        serv->message_queue_key = (uint64_t) Z_LVAL_P(v);\n    }\n\n    zval *retval = NULL;\n    zval *port_object = server_port_list.zobjects[0];\n\n    Z_TRY_ADDREF_P(port_object);\n    Z_TRY_ADDREF_P(zset);\n\n    sw_zend_call_method_with_1_params(&port_object, swoole_server_port_ce_ptr, NULL, \"set\", &retval, zset);\n\n    zval *zsetting = sw_zend_read_property_array(swoole_server_ce_ptr, getThis(), ZEND_STRL(\"setting\"), 1);\n    php_array_merge(Z_ARRVAL_P(zsetting), Z_ARRVAL_P(zset));\n    zval_ptr_dtor(zset);\n\n    RETURN_TRUE;\n}",
        "func": "static PHP_METHOD(swoole_server, set)\n{\n    zval *zset = NULL;\n    zval *zobject = getThis();\n    HashTable *vht;\n\n    zval *v;\n\n    swServer *serv = (swServer *) swoole_get_object(zobject);\n    if (serv->gs->start > 0)\n    {\n        swoole_php_fatal_error(E_WARNING, \"server is running. unable to execute function 'swoole_server_set'.\");\n        RETURN_FALSE;\n    }\n\n    ZEND_PARSE_PARAMETERS_START(1, 1)\n        Z_PARAM_ARRAY(zset)\n    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);\n\n    php_swoole_array_separate(zset);\n    vht = Z_ARRVAL_P(zset);\n\n    //chroot\n    if (php_swoole_array_get_value(vht, \"chroot\", v))\n    {\n        convert_to_string(v);\n        if (SwooleG.chroot)\n        {\n            sw_free(SwooleG.chroot);\n        }\n        SwooleG.chroot = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //user\n    if (php_swoole_array_get_value(vht, \"user\", v))\n    {\n        convert_to_string(v);\n        if (SwooleG.user)\n        {\n            sw_free(SwooleG.user);\n        }\n        SwooleG.user = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //group\n    if (php_swoole_array_get_value(vht, \"group\", v))\n    {\n        convert_to_string(v);\n        if (SwooleG.group)\n        {\n            sw_free(SwooleG.group);\n        }\n        SwooleG.group = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //daemonize\n    if (php_swoole_array_get_value(vht, \"daemonize\", v))\n    {\n        convert_to_boolean(v);\n        serv->daemonize = Z_BVAL_P(v);\n    }\n#ifdef SW_DEBUG\n    //debug\n    if (php_swoole_array_get_value(vht, \"debug_mode\", v))\n    {\n        convert_to_boolean(v);\n        if (Z_BVAL_P(v))\n        {\n            SwooleG.log_level = 0;\n        }\n    }\n#endif\n    if (php_swoole_array_get_value(vht, \"trace_flags\", v))\n    {\n        convert_to_long(v);\n        SwooleG.trace_flags = (uint32_t) MAX(0, Z_LVAL_P(v));\n    }\n    //pid file\n    if (php_swoole_array_get_value(vht, \"pid_file\", v))\n    {\n        convert_to_string(v);\n        if (serv->pid_file)\n        {\n            sw_free(serv->pid_file);\n        }\n        serv->pid_file = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //reactor thread num\n    if (php_swoole_array_get_value(vht, \"reactor_num\", v))\n    {\n        convert_to_long(v);\n        serv->reactor_num = (uint16_t) Z_LVAL_P(v);\n        if (serv->reactor_num <= 0)\n        {\n            serv->reactor_num = SwooleG.cpu_num;\n        }\n    }\n    //worker_num\n    if (php_swoole_array_get_value(vht, \"worker_num\", v))\n    {\n        convert_to_long(v);\n        serv->worker_num = (uint16_t) Z_LVAL_P(v);\n        if (serv->worker_num <= 0)\n        {\n            serv->worker_num = SwooleG.cpu_num;\n        }\n    }\n    //max wait time\n    if (php_swoole_array_get_value(vht, \"max_wait_time\", v))\n    {\n        convert_to_long(v);\n        serv->max_wait_time = (uint32_t) Z_LVAL_P(v);\n    }\n#ifdef SW_COROUTINE\n    if (php_swoole_array_get_value(vht, \"enable_coroutine\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_coroutine = SwooleG.enable_coroutine = Z_BVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"max_coro_num\", v) || php_swoole_array_get_value(vht, \"max_coroutine\", v))\n    {\n        zend_long max_num;\n        convert_to_long(v);\n        max_num = Z_LVAL_P(v);\n        PHPCoroutine::set_max_num(max_num <= 0 ? SW_DEFAULT_MAX_CORO_NUM : max_num);\n    }\n    if (php_swoole_array_get_value(vht, \"send_yield\", v))\n    {\n        convert_to_boolean(v);\n        serv->send_yield = Z_BVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"send_timeout\", v))\n    {\n        convert_to_double(v);\n        serv->send_timeout = Z_DVAL_P(v);\n    }\n#endif\n    //dispatch_mode\n    if (php_swoole_array_get_value(vht, \"dispatch_mode\", v))\n    {\n        convert_to_long(v);\n        serv->dispatch_mode = (uint8_t) Z_LVAL_P(v);\n    }\n    //dispatch function\n    if (php_swoole_array_get_value(vht, \"dispatch_func\", v))\n    {\n        swServer_dispatch_function c_dispatch_func = NULL;\n        while(1)\n        {\n            if (Z_TYPE_P(v) == IS_STRING)\n            {\n                c_dispatch_func = (swServer_dispatch_function) swoole_get_function(Z_STRVAL_P(v), Z_STRLEN_P(v));\n                if (c_dispatch_func)\n                {\n                    break;\n                }\n            }\n            char *func_name = NULL;\n            zend_fcall_info_cache *fci_cache = (zend_fcall_info_cache *) emalloc(sizeof(zend_fcall_info_cache));\n            if (!sw_zend_is_callable_ex(v, NULL, 0, &func_name, NULL, fci_cache, NULL))\n            {\n                swoole_php_fatal_error(E_ERROR, \"function '%s' is not callable\", func_name);\n                return;\n            }\n            efree(func_name);\n            sw_fci_cache_persist(fci_cache);\n            serv->private_data_3 = (void *) fci_cache;\n            c_dispatch_func = php_swoole_dispatch_func;\n            break;\n        }\n        if (c_dispatch_func)\n        {\n            serv->dispatch_mode = SW_DISPATCH_USERFUNC;\n            serv->dispatch_func = c_dispatch_func;\n        }\n    }\n    //log_file\n    if (php_swoole_array_get_value(vht, \"log_file\", v))\n    {\n        convert_to_string(v);\n        if (SwooleG.log_file)\n        {\n            sw_free(SwooleG.log_file);\n        }\n        SwooleG.log_file = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    //log_level\n    if (php_swoole_array_get_value(vht, \"log_level\", v))\n    {\n        zend_long level;\n        convert_to_long(v);\n        level = Z_LVAL_P(v);\n        SwooleG.log_level = (uint32_t) (level < 0 ? UINT32_MAX : level);\n    }\n    /**\n     * for dispatch_mode = 1/3\n     */\n    if (php_swoole_array_get_value(vht, \"discard_timeout_request\", v))\n    {\n        convert_to_boolean(v);\n        serv->discard_timeout_request = (uint32_t) Z_BVAL_P(v);\n    }\n    //onConnect/onClose event\n    if (php_swoole_array_get_value(vht, \"enable_unsafe_event\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_unsafe_event = Z_BVAL_P(v);\n    }\n    //delay receive\n    if (php_swoole_array_get_value(vht, \"enable_delay_receive\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_delay_receive = Z_BVAL_P(v);\n    }\n    //task coroutine\n    if (php_swoole_array_get_value(vht, \"task_enable_coroutine\", v))\n    {\n        convert_to_boolean(v);\n        if (Z_BVAL_P(v))\n        {\n            if (!SwooleG.enable_coroutine)\n            {\n                swoole_php_fatal_error(E_ERROR, \"server->enable_coroutine must be true.\");\n                return;\n            }\n            serv->task_enable_coroutine = 1;\n        }\n        else\n        {\n            serv->task_enable_coroutine = 0;\n        }\n    }\n    //task_worker_num\n    if (php_swoole_array_get_value(vht, \"task_worker_num\", v))\n    {\n        convert_to_long(v);\n        serv->task_worker_num = (uint16_t) Z_LVAL_P(v);\n    }\n    //slowlog\n    if (php_swoole_array_get_value(vht, \"trace_event_worker\", v))\n    {\n        convert_to_boolean(v);\n        serv->trace_event_worker = Z_BVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"request_slowlog_timeout\", v))\n    {\n        convert_to_long(v);\n        serv->request_slowlog_timeout = (uint8_t) Z_LVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"request_slowlog_file\", v))\n    {\n        convert_to_string(v);\n        serv->request_slowlog_file = fopen(Z_STRVAL_P(v), \"a+\");\n        if (serv->request_slowlog_file == NULL)\n        {\n            swoole_php_fatal_error(E_ERROR, \"Unable to open request_slowlog_file[%s].\", Z_STRVAL_P(v));\n            return;\n        }\n        if (serv->request_slowlog_timeout == 0)\n        {\n            serv->request_slowlog_timeout = 1;\n        }\n    }\n    //task ipc mode, 1,2,3\n    if (php_swoole_array_get_value(vht, \"task_ipc_mode\", v))\n    {\n        convert_to_long(v);\n        serv->task_ipc_mode = (uint8_t) Z_LVAL_P(v);\n    }\n    /**\n     * Temporary file directory for task_worker\n     */\n    if (php_swoole_array_get_value(vht, \"task_tmpdir\", v))\n    {\n        convert_to_string(v);\n        if (php_swoole_create_dir(Z_STRVAL_P(v), Z_STRLEN_P(v)) < 0)\n        {\n            swoole_php_fatal_error(E_ERROR, \"Unable to create task_tmpdir[%s].\", Z_STRVAL_P(v));\n            return;\n        }\n        if (SwooleG.task_tmpdir)\n        {\n            sw_free(SwooleG.task_tmpdir);\n        }\n        SwooleG.task_tmpdir = (char*) sw_malloc(Z_STRLEN_P(v) + sizeof(SW_TASK_TMP_FILE) + 1);\n        SwooleG.task_tmpdir_len = sw_snprintf(SwooleG.task_tmpdir, SW_TASK_TMPDIR_SIZE, \"%s/swoole.task.XXXXXX\", Z_STRVAL_P(v)) + 1;\n    }\n    //task_max_request\n    if (php_swoole_array_get_value(vht, \"task_max_request\", v))\n    {\n        convert_to_long(v);\n        serv->task_max_request = (uint16_t) Z_LVAL_P(v);\n    }\n    //max_connection\n    if (php_swoole_array_get_value(vht, \"max_connection\", v) || php_swoole_array_get_value(vht, \"max_conn\", v))\n    {\n        convert_to_long(v);\n        serv->max_connection = (uint32_t) Z_LVAL_P(v);\n    }\n    //heartbeat_check_interval\n    if (php_swoole_array_get_value(vht, \"heartbeat_check_interval\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_check_interval = (uint16_t) Z_LVAL_P(v);\n    }\n    //heartbeat idle time\n    if (php_swoole_array_get_value(vht, \"heartbeat_idle_time\", v))\n    {\n        convert_to_long(v);\n        serv->heartbeat_idle_time = (uint16_t) Z_LVAL_P(v);\n\n        if (serv->heartbeat_check_interval > serv->heartbeat_idle_time)\n        {\n            swoole_php_fatal_error(E_WARNING, \"heartbeat_idle_time must be greater than heartbeat_check_interval.\");\n            serv->heartbeat_check_interval = serv->heartbeat_idle_time / 2;\n        }\n    }\n    else if (serv->heartbeat_check_interval > 0)\n    {\n        serv->heartbeat_idle_time = serv->heartbeat_check_interval * 2;\n    }\n    //max_request\n    if (php_swoole_array_get_value(vht, \"max_request\", v))\n    {\n        convert_to_long(v);\n        serv->max_request = (uint32_t) Z_LVAL_P(v);\n    }\n    //reload async\n    if (php_swoole_array_get_value(vht, \"reload_async\", v))\n    {\n        convert_to_boolean(v);\n        serv->reload_async = Z_BVAL_P(v);\n    }\n    //cpu affinity\n    if (php_swoole_array_get_value(vht, \"open_cpu_affinity\", v))\n    {\n        convert_to_boolean(v);\n        serv->open_cpu_affinity = Z_BVAL_P(v);\n    }\n    //cpu affinity set\n    if (php_swoole_array_get_value(vht, \"cpu_affinity_ignore\", v))\n    {\n        int ignore_num = zend_hash_num_elements(Z_ARRVAL_P(v));\n        if (ignore_num >= SW_CPU_NUM)\n        {\n            swoole_php_fatal_error(E_ERROR, \"cpu_affinity_ignore num must be less than cpu num (%d)\", SW_CPU_NUM);\n            RETURN_FALSE;\n        }\n        int available_num = SW_CPU_NUM - ignore_num;\n        int *available_cpu = (int *) sw_malloc(sizeof(int) * available_num);\n        int flag, i, available_i = 0;\n\n        zval *zval_core = NULL;\n        for (i = 0; i < SW_CPU_NUM; i++)\n        {\n            flag = 1;\n            SW_HASHTABLE_FOREACH_START(Z_ARRVAL_P(v), zval_core)\n                int core = (int) Z_LVAL_P(zval_core);\n                if (i == core)\n                {\n                    flag = 0;\n                    break;\n                }\n            SW_HASHTABLE_FOREACH_END();\n            if (flag)\n            {\n                available_cpu[available_i] = i;\n                available_i++;\n            }\n        }\n        serv->cpu_affinity_available_num = available_num;\n        serv->cpu_affinity_available = available_cpu;\n    }\n    //paser x-www-form-urlencoded form data\n    if (php_swoole_array_get_value(vht, \"http_parse_post\", v))\n    {\n        convert_to_boolean(v);\n        serv->http_parse_post = Z_BVAL_P(v);\n    }\n#ifdef SW_HAVE_ZLIB\n    //http content compression\n    if (php_swoole_array_get_value(vht, \"http_compression\", v))\n    {\n        convert_to_boolean(v);\n        serv->http_compression = Z_BVAL_P(v);\n        serv->http_compression_level = Z_BEST_SPEED;\n    }\n    if (php_swoole_array_get_value(vht, \"http_gzip_level\", v) || php_swoole_array_get_value(vht, \"http_compression_level\", v))\n    {\n        convert_to_long(v);\n        zend_long level = Z_LVAL_P(v);\n        if (level > UINT8_MAX)\n        {\n            level = UINT8_MAX;\n        }\n        else if (level < 0)\n        {\n            level = 0;\n        }\n        serv->http_compression_level = level;\n    }\n#endif\n    //temporary directory for HTTP uploaded file.\n    if (php_swoole_array_get_value(vht, \"upload_tmp_dir\", v))\n    {\n        convert_to_string(v);\n        if (php_swoole_create_dir(Z_STRVAL_P(v), Z_STRLEN_P(v)) < 0)\n        {\n            swoole_php_fatal_error(E_ERROR, \"Unable to create upload_tmp_dir[%s].\", Z_STRVAL_P(v));\n            return;\n        }\n        if (serv->upload_tmp_dir)\n        {\n            sw_free(serv->upload_tmp_dir);\n        }\n        serv->upload_tmp_dir = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n    }\n    /**\n     * http static file handler\n     */\n    if (php_swoole_array_get_value(vht, \"enable_static_handler\", v))\n    {\n        convert_to_boolean(v);\n        serv->enable_static_handler = Z_BVAL_P(v);\n    }\n    if (php_swoole_array_get_value(vht, \"document_root\", v))\n    {\n        convert_to_string(v);\n\n        if (Z_STRLEN_P(v) >= PATH_MAX)\n        {\n            swoole_php_fatal_error(E_ERROR, \"The length of document_root must be less than %d.\", PATH_MAX);\n            return;\n        }\n\n        if (serv->document_root)\n        {\n            sw_free(serv->document_root);\n        }\n\n        serv->document_root = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n        if (serv->document_root[Z_STRLEN_P(v) - 1] == '/')\n        {\n            serv->document_root[Z_STRLEN_P(v) - 1] = 0;\n            serv->document_root_len = Z_STRLEN_P(v) - 1;\n        }\n        else\n        {\n            serv->document_root_len = Z_STRLEN_P(v);\n        }\n    }\n    /**\n     * buffer input size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_input_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_input_size = (uint32_t) Z_LVAL_P(v);\n    }\n    /**\n     * buffer output size\n     */\n    if (php_swoole_array_get_value(vht, \"buffer_output_size\", v))\n    {\n        convert_to_long(v);\n        serv->buffer_output_size = (uint32_t) Z_LVAL_P(v);\n    }\n    //message queue key\n    if (php_swoole_array_get_value(vht, \"message_queue_key\", v))\n    {\n        convert_to_long(v);\n        serv->message_queue_key = (uint64_t) Z_LVAL_P(v);\n    }\n\n    zval *retval = NULL;\n    zval *port_object = server_port_list.zobjects[0];\n\n    Z_TRY_ADDREF_P(port_object);\n    Z_TRY_ADDREF_P(zset);\n\n    sw_zend_call_method_with_1_params(&port_object, swoole_server_port_ce_ptr, NULL, \"set\", &retval, zset);\n\n    zval *zsetting = sw_zend_read_property_array(swoole_server_ce_ptr, getThis(), ZEND_STRL(\"setting\"), 1);\n    php_array_merge(Z_ARRVAL_P(zsetting), Z_ARRVAL_P(zset));\n    zval_ptr_dtor(zset);\n\n    RETURN_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -423,10 +423,18 @@\n     if (php_swoole_array_get_value(vht, \"document_root\", v))\n     {\n         convert_to_string(v);\n+\n+        if (Z_STRLEN_P(v) >= PATH_MAX)\n+        {\n+            swoole_php_fatal_error(E_ERROR, \"The length of document_root must be less than %d.\", PATH_MAX);\n+            return;\n+        }\n+\n         if (serv->document_root)\n         {\n             sw_free(serv->document_root);\n         }\n+\n         serv->document_root = sw_strndup(Z_STRVAL_P(v), Z_STRLEN_P(v));\n         if (serv->document_root[Z_STRLEN_P(v) - 1] == '/')\n         {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        if (Z_STRLEN_P(v) >= PATH_MAX)",
                "        {",
                "            swoole_php_fatal_error(E_ERROR, \"The length of document_root must be less than %d.\", PATH_MAX);",
                "            return;",
                "        }",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15518",
        "func_name": "swoole/swoole-src/swPort_http_static_handler",
        "description": "Swoole before 4.2.13 allows directory traversal in swPort_http_static_handler.",
        "git_url": "https://github.com/swoole/swoole-src/commit/a37b20878592951f4e8e7274b38bbb6e94af7e42",
        "commit_title": "fix bug",
        "commit_text": "",
        "func_before": "static int swPort_http_static_handler(swServer *serv, swHttpRequest *request, swConnection *conn)\n{\n    char *url = request->buffer->str + request->url_offset;\n    char *params = memchr(url, '?', request->url_length);\n\n    struct\n    {\n        off_t offset;\n        size_t length;\n        char filename[PATH_MAX];\n    } buffer;\n\n    char *p = buffer.filename;\n\n    memcpy(p, serv->document_root, serv->document_root_len);\n    p += serv->document_root_len;\n    uint32_t n = params ? params - url : request->url_length;\n    memcpy(p, url, n);\n    p += n;\n    *p = 0;\n\n    char real_path[PATH_MAX];\n    if (!realpath(buffer.filename, real_path))\n    {\n        return SW_FALSE;\n    }\n\n    if (real_path[serv->document_root_len] != '/')\n    {\n        return SW_FALSE;\n    }\n\n    if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)\n    {\n        return SW_FALSE;\n    }\n\n    struct stat file_stat;\n    if (lstat(buffer.filename, &file_stat) < 0)\n    {\n        return SW_FALSE;\n    }\n    if (file_stat.st_size == 0)\n    {\n        return SW_FALSE;\n    }\n    if ((file_stat.st_mode & S_IFMT) != S_IFREG)\n    {\n        return SW_FALSE;\n    }\n\n    char header_buffer[1024];\n    swSendData response;\n    response.info.fd = conn->session_id;\n\n    response.info.type = SW_EVENT_TCP;\n\n    p = request->buffer->str + request->url_offset + request->url_length + 10;\n    char *pe = request->buffer->str + request->header_length;\n\n    char *date_if_modified_since = NULL;\n    int length_if_modified_since = 0;\n\n    int state = 0;\n    for (; p < pe; p++)\n    {\n        switch(state)\n        {\n        case 0:\n            if (strncasecmp(p, SW_STRL(\"If-Modified-Since\")) == 0)\n            {\n                p += sizeof(\"If-Modified-Since\");\n                state = 1;\n            }\n            break;\n        case 1:\n            if (!isspace(*p))\n            {\n                date_if_modified_since = p;\n                state = 2;\n            }\n            break;\n        case 2:\n            if (strncasecmp(p, SW_STRL(\"\\r\\n\")) == 0)\n            {\n                length_if_modified_since = p - date_if_modified_since;\n                goto check_modify_date;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    char date_[64];\n    struct tm *tm1;\n\n    check_modify_date: tm1 = gmtime(&serv->gs->now);\n    strftime(date_, sizeof(date_), \"%a, %d %b %Y %H:%M:%S %Z\", tm1);\n\n    char date_last_modified[64];\n#ifdef __MACH__\n    time_t file_mtime = file_stat.st_mtimespec.tv_sec;\n#elif defined(_WIN32)\n\ttime_t file_mtime = file_stat.st_mtime;\n#else\n    time_t file_mtime = file_stat.st_mtim.tv_sec;\n#endif\n\n    struct tm *tm2 = gmtime(&file_mtime);\n    strftime(date_last_modified, sizeof(date_last_modified), \"%a, %d %b %Y %H:%M:%S %Z\", tm2);\n\n    if (state == 2)\n    {\n        struct tm tm3;\n        char date_tmp[64];\n        memcpy(date_tmp, date_if_modified_since, length_if_modified_since);\n        date_tmp[length_if_modified_since] = 0;\n\n        char *date_format = NULL;\n\n        if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_GMT, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC1123_DATE_GMT;\n        }\n        else if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_UTC, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC1123_DATE_UTC;\n        }\n        else if (strptime(date_tmp, SW_HTTP_RFC850_DATE, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC850_DATE;\n        }\n        else if (strptime(date_tmp, SW_HTTP_ASCTIME_DATE, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_ASCTIME_DATE;\n        }\n        if (date_format && mktime(&tm3) - (int) timezone >= file_mtime)\n        {\n            response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),\n                    \"HTTP/1.1 304 Not Modified\\r\\n\"\n                    \"%s\"\n                    \"Date: %s\\r\\n\"\n                    \"Last-Modified: %s\\r\\n\"\n                    \"Server: %s\\r\\n\\r\\n\",\n                    request->keep_alive ? \"Connection: keep-alive\\r\\n\" : \"\",\n                    date_,\n                    date_last_modified,\n                    SW_HTTP_SERVER_SOFTWARE\n            );\n            response.data = header_buffer;\n            swServer_master_send(serv, &response);\n            goto _finish;\n        }\n    }\n\n    response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"%s\"\n            \"Content-Length: %ld\\r\\n\"\n            \"Content-Type: %s\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"Last-Modified: %s\\r\\n\"\n            \"Server: %s\\r\\n\\r\\n\",\n            request->keep_alive ? \"Connection: keep-alive\\r\\n\" : \"\",\n            (long) file_stat.st_size,\n            swoole_get_mime_type(buffer.filename),\n            date_,\n            date_last_modified,\n            SW_HTTP_SERVER_SOFTWARE);\n\n    response.data = header_buffer;\n\n#ifdef HAVE_TCP_NOPUSH\n    if (conn->tcp_nopush == 0)\n    {\n        if (swSocket_tcp_nopush(conn->fd, 1) == -1)\n        {\n            swWarn(\"swSocket_tcp_nopush() failed. Error: %s[%d]\", strerror(errno), errno);\n        }\n        conn->tcp_nopush = 1;\n    }\n#endif\n    swServer_master_send(serv, &response);\n\n    buffer.offset = 0;\n    buffer.length = file_stat.st_size;\n\n    response.info.type = SW_EVENT_SENDFILE;\n    response.length = response.info.len = sizeof(swSendFile_request) + buffer.length + 1;\n    response.data = (void*) &buffer;\n\n    swServer_master_send(serv, &response);\n\n    _finish:\n    if (!request->keep_alive)\n    {\n        response.info.type = SW_EVENT_CLOSE;\n        response.length = 0;\n        response.data = NULL;\n        swServer_master_send(serv, &response);\n    }\n\n    return SW_TRUE;\n}",
        "func": "static int swPort_http_static_handler(swServer *serv, swHttpRequest *request, swConnection *conn)\n{\n    char *url = request->buffer->str + request->url_offset;\n    char *params = memchr(url, '?', request->url_length);\n\n    struct\n    {\n        off_t offset;\n        size_t length;\n        char filename[PATH_MAX];\n    } buffer;\n\n    char *p = buffer.filename;\n\n    memcpy(p, serv->document_root, serv->document_root_len);\n    p += serv->document_root_len;\n    size_t n = params ? params - url : request->url_length;\n\n    if (serv->document_root_len + n >= PATH_MAX)\n    {\n        return SW_FALSE;\n    }\n\n    memcpy(p, url, n);\n    p += n;\n    *p = '\\0';\n\n    char real_path[PATH_MAX];\n    if (!realpath(buffer.filename, real_path))\n    {\n        return SW_FALSE;\n    }\n\n    if (real_path[serv->document_root_len] != '/')\n    {\n        return SW_FALSE;\n    }\n\n    if (strncmp(real_path, serv->document_root, serv->document_root_len) != 0)\n    {\n        return SW_FALSE;\n    }\n\n    struct stat file_stat;\n    if (lstat(buffer.filename, &file_stat) < 0)\n    {\n        return SW_FALSE;\n    }\n    if (file_stat.st_size == 0)\n    {\n        return SW_FALSE;\n    }\n    if ((file_stat.st_mode & S_IFMT) != S_IFREG)\n    {\n        return SW_FALSE;\n    }\n\n    char header_buffer[1024];\n    swSendData response;\n    response.info.fd = conn->session_id;\n\n    response.info.type = SW_EVENT_TCP;\n\n    p = request->buffer->str + request->url_offset + request->url_length + 10;\n    char *pe = request->buffer->str + request->header_length;\n\n    char *date_if_modified_since = NULL;\n    int length_if_modified_since = 0;\n\n    int state = 0;\n    for (; p < pe; p++)\n    {\n        switch(state)\n        {\n        case 0:\n            if (strncasecmp(p, SW_STRL(\"If-Modified-Since\")) == 0)\n            {\n                p += sizeof(\"If-Modified-Since\");\n                state = 1;\n            }\n            break;\n        case 1:\n            if (!isspace(*p))\n            {\n                date_if_modified_since = p;\n                state = 2;\n            }\n            break;\n        case 2:\n            if (strncasecmp(p, SW_STRL(\"\\r\\n\")) == 0)\n            {\n                length_if_modified_since = p - date_if_modified_since;\n                goto check_modify_date;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    char date_[64];\n    struct tm *tm1;\n\n    check_modify_date: tm1 = gmtime(&serv->gs->now);\n    strftime(date_, sizeof(date_), \"%a, %d %b %Y %H:%M:%S %Z\", tm1);\n\n    char date_last_modified[64];\n#ifdef __MACH__\n    time_t file_mtime = file_stat.st_mtimespec.tv_sec;\n#elif defined(_WIN32)\n\ttime_t file_mtime = file_stat.st_mtime;\n#else\n    time_t file_mtime = file_stat.st_mtim.tv_sec;\n#endif\n\n    struct tm *tm2 = gmtime(&file_mtime);\n    strftime(date_last_modified, sizeof(date_last_modified), \"%a, %d %b %Y %H:%M:%S %Z\", tm2);\n\n    if (state == 2)\n    {\n        struct tm tm3;\n        char date_tmp[64];\n        memcpy(date_tmp, date_if_modified_since, length_if_modified_since);\n        date_tmp[length_if_modified_since] = 0;\n\n        char *date_format = NULL;\n\n        if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_GMT, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC1123_DATE_GMT;\n        }\n        else if (strptime(date_tmp, SW_HTTP_RFC1123_DATE_UTC, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC1123_DATE_UTC;\n        }\n        else if (strptime(date_tmp, SW_HTTP_RFC850_DATE, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_RFC850_DATE;\n        }\n        else if (strptime(date_tmp, SW_HTTP_ASCTIME_DATE, &tm3) != NULL)\n        {\n            date_format = SW_HTTP_ASCTIME_DATE;\n        }\n        if (date_format && mktime(&tm3) - (int) timezone >= file_mtime)\n        {\n            response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),\n                    \"HTTP/1.1 304 Not Modified\\r\\n\"\n                    \"%s\"\n                    \"Date: %s\\r\\n\"\n                    \"Last-Modified: %s\\r\\n\"\n                    \"Server: %s\\r\\n\\r\\n\",\n                    request->keep_alive ? \"Connection: keep-alive\\r\\n\" : \"\",\n                    date_,\n                    date_last_modified,\n                    SW_HTTP_SERVER_SOFTWARE\n            );\n            response.data = header_buffer;\n            swServer_master_send(serv, &response);\n            goto _finish;\n        }\n    }\n\n    response.length = response.info.len = sw_snprintf(header_buffer, sizeof(header_buffer),\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"%s\"\n            \"Content-Length: %ld\\r\\n\"\n            \"Content-Type: %s\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"Last-Modified: %s\\r\\n\"\n            \"Server: %s\\r\\n\\r\\n\",\n            request->keep_alive ? \"Connection: keep-alive\\r\\n\" : \"\",\n            (long) file_stat.st_size,\n            swoole_get_mime_type(buffer.filename),\n            date_,\n            date_last_modified,\n            SW_HTTP_SERVER_SOFTWARE);\n\n    response.data = header_buffer;\n\n#ifdef HAVE_TCP_NOPUSH\n    if (conn->tcp_nopush == 0)\n    {\n        if (swSocket_tcp_nopush(conn->fd, 1) == -1)\n        {\n            swWarn(\"swSocket_tcp_nopush() failed. Error: %s[%d]\", strerror(errno), errno);\n        }\n        conn->tcp_nopush = 1;\n    }\n#endif\n    swServer_master_send(serv, &response);\n\n    buffer.offset = 0;\n    buffer.length = file_stat.st_size;\n\n    response.info.type = SW_EVENT_SENDFILE;\n    response.length = response.info.len = sizeof(swSendFile_request) + buffer.length + 1;\n    response.data = (void*) &buffer;\n\n    swServer_master_send(serv, &response);\n\n    _finish:\n    if (!request->keep_alive)\n    {\n        response.info.type = SW_EVENT_CLOSE;\n        response.length = 0;\n        response.data = NULL;\n        swServer_master_send(serv, &response);\n    }\n\n    return SW_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,10 +14,16 @@\n \n     memcpy(p, serv->document_root, serv->document_root_len);\n     p += serv->document_root_len;\n-    uint32_t n = params ? params - url : request->url_length;\n+    size_t n = params ? params - url : request->url_length;\n+\n+    if (serv->document_root_len + n >= PATH_MAX)\n+    {\n+        return SW_FALSE;\n+    }\n+\n     memcpy(p, url, n);\n     p += n;\n-    *p = 0;\n+    *p = '\\0';\n \n     char real_path[PATH_MAX];\n     if (!realpath(buffer.filename, real_path))",
        "diff_line_info": {
            "deleted_lines": [
                "    uint32_t n = params ? params - url : request->url_length;",
                "    *p = 0;"
            ],
            "added_lines": [
                "    size_t n = params ? params - url : request->url_length;",
                "",
                "    if (serv->document_root_len + n >= PATH_MAX)",
                "    {",
                "        return SW_FALSE;",
                "    }",
                "",
                "    *p = '\\0';"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16680",
        "func_name": "GNOME/file-roller/sanitize_filename",
        "description": "An issue was discovered in GNOME file-roller before 3.29.91. It allows a single ./../ path traversal via a filename contained in a TAR archive, possibly overwriting a file during extraction.",
        "git_url": "https://github.com/GNOME/file-roller/commit/57268e51e59b61c9e3125eb0f65551c7084297e2",
        "commit_title": "Path traversal vulnerability",
        "commit_text": " Do not extract files with relative paths.  [bug #794337]",
        "func_before": "static const char *\nsanitize_filename (const char *file_name)\n{\n\tsize_t      prefix_len;\n\tchar const *p;\n\n\tif (file_name == NULL)\n\t\treturn NULL;\n\n\tprefix_len = 0;\n\tfor (p = file_name; *p; ) {\n\t\tif (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))\n\t\t\tprefix_len = p + 2 - file_name;\n\n\t\tdo {\n\t\t\tchar c = *p++;\n\t\t\tif (ISSLASH (c))\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (*p);\n\t}\n\n\tp = file_name + prefix_len;\n\twhile (ISSLASH (*p))\n\t\tp++;\n\n\treturn p;\n}",
        "func": "static const char *\nsanitize_filename (const char *file_name)\n{\n\tsize_t      prefix_len;\n\tchar const *p;\n\n\tif (file_name == NULL)\n\t\treturn NULL;\n\n\tprefix_len = 0;\n\tfor (p = file_name; *p; ) {\n\t\tif (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))\n\t\t\treturn NULL;\n\n\t\tdo {\n\t\t\tchar c = *p++;\n\t\t\tif (ISSLASH (c))\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (*p);\n\t}\n\n\tp = file_name + prefix_len;\n\twhile (ISSLASH (*p))\n\t\tp++;\n\n\treturn p;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \tprefix_len = 0;\n \tfor (p = file_name; *p; ) {\n \t\tif (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))\n-\t\t\tprefix_len = p + 2 - file_name;\n+\t\t\treturn NULL;\n \n \t\tdo {\n \t\t\tchar c = *p++;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tprefix_len = p + 2 - file_name;"
            ],
            "added_lines": [
                "\t\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16903",
        "func_name": "plutinosoft/Platinum/PLT_HttpServer::ServeFile",
        "description": "Platinum UPnP SDK 1.2.0 allows Directory Traversal in Core/PltHttpServer.cpp because it checks for /.. where it should be checking for ../ instead.",
        "git_url": "https://github.com/plutinosoft/Platinum/commit/788ea5b4e15e6b0efeffdcbc0db03bf4591ce79e",
        "commit_title": "Fix vulnerability around urls crafter as http://host/../secret.foo",
        "commit_text": "",
        "func_before": "NPT_Result \nPLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        \n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        \n        if (timestamp >= file_info.m_ModificationTime) {\n            // it's a match\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    \n    // open file\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // set Last-Modified and Cache-Control headers\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n        //response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=1800\", true);\n    }\n    \n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}",
        "func": "NPT_Result \nPLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        \n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        \n        if (timestamp >= file_info.m_ModificationTime) {\n            // it's a match\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    \n    // open file\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // set Last-Modified and Cache-Control headers\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n        //response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=1800\", true);\n    }\n    \n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n     NPT_FileInfo             file_info;\n     \n     // prevent hackers from accessing files outside of our root\n-    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n+    if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n         NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n         return NPT_ERROR_NO_SUCH_ITEM;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||"
            ],
            "added_lines": [
                "    if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23520",
        "func_name": "juce-framework/JUCE/TemporaryFile::deleteTemporaryFile",
        "description": "The package juce-framework/juce before 6.1.5 are vulnerable to Arbitrary File Write via Archive Extraction (Zip Slip) via the ZipFile::uncompressEntry function in juce_ZipFile.cpp. This vulnerability is triggered when the archive is extracted upon calling uncompressTo() on a ZipFile object.",
        "git_url": "https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f",
        "commit_title": "ZipFile:  Add path checks to uncompressEntry()",
        "commit_text": "",
        "func_before": "bool TemporaryFile::deleteTemporaryFile() const\n{\n    // Have a few attempts at deleting the file before giving up..\n    for (int i = 5; --i >= 0;)\n    {\n        if (temporaryFile.deleteFile())\n            return true;\n\n        Thread::sleep (50);\n    }\n\n    return false;\n}",
        "func": "bool TemporaryFile::deleteTemporaryFile() const\n{\n    // Have a few attempts at deleting the file before giving up..\n    for (int i = 5; --i >= 0;)\n    {\n        if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())\n            return true;\n\n        Thread::sleep (50);\n    }\n\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n     // Have a few attempts at deleting the file before giving up..\n     for (int i = 5; --i >= 0;)\n     {\n-        if (temporaryFile.deleteFile())\n+        if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())\n             return true;\n \n         Thread::sleep (50);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (temporaryFile.deleteFile())"
            ],
            "added_lines": [
                "        if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23520",
        "func_name": "juce-framework/JUCE/runTest",
        "description": "The package juce-framework/juce before 6.1.5 are vulnerable to Arbitrary File Write via Archive Extraction (Zip Slip) via the ZipFile::uncompressEntry function in juce_ZipFile.cpp. This vulnerability is triggered when the archive is extracted upon calling uncompressTo() on a ZipFile object.",
        "git_url": "https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f",
        "commit_title": "ZipFile:  Add path checks to uncompressEntry()",
        "commit_text": "",
        "func_before": "void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        ZipFile::Builder builder;\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        HashMap<String, MemoryBlock> blocks;\n\n        for (auto& entryName : entryNames)\n        {\n            auto& block = blocks.getReference (entryName);\n            MemoryOutputStream mo (block, false);\n            mo << entryName;\n            mo.flush();\n            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());\n        }\n\n        MemoryBlock data;\n        MemoryOutputStream mo (data, false);\n        builder.writeToStream (mo, nullptr);\n        MemoryInputStream mi (data, false);\n\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n    }",
        "func": "void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        auto data = createZipMemoryBlock (entryNames);\n        MemoryInputStream mi (data, false);\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n\n        beginTest (\"ZipSlip\");\n        runZipSlipTest();\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,24 +2,9 @@\n     {\n         beginTest (\"ZIP\");\n \n-        ZipFile::Builder builder;\n         StringArray entryNames { \"first\", \"second\", \"third\" };\n-        HashMap<String, MemoryBlock> blocks;\n-\n-        for (auto& entryName : entryNames)\n-        {\n-            auto& block = blocks.getReference (entryName);\n-            MemoryOutputStream mo (block, false);\n-            mo << entryName;\n-            mo.flush();\n-            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());\n-        }\n-\n-        MemoryBlock data;\n-        MemoryOutputStream mo (data, false);\n-        builder.writeToStream (mo, nullptr);\n+        auto data = createZipMemoryBlock (entryNames);\n         MemoryInputStream mi (data, false);\n-\n         ZipFile zip (mi);\n \n         expectEquals (zip.getNumEntries(), entryNames.size());\n@@ -30,4 +15,7 @@\n             std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n             expectEquals (input->readEntireStreamAsString(), entryName);\n         }\n+\n+        beginTest (\"ZipSlip\");\n+        runZipSlipTest();\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        ZipFile::Builder builder;",
                "        HashMap<String, MemoryBlock> blocks;",
                "",
                "        for (auto& entryName : entryNames)",
                "        {",
                "            auto& block = blocks.getReference (entryName);",
                "            MemoryOutputStream mo (block, false);",
                "            mo << entryName;",
                "            mo.flush();",
                "            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());",
                "        }",
                "",
                "        MemoryBlock data;",
                "        MemoryOutputStream mo (data, false);",
                "        builder.writeToStream (mo, nullptr);",
                ""
            ],
            "added_lines": [
                "        auto data = createZipMemoryBlock (entryNames);",
                "",
                "        beginTest (\"ZipSlip\");",
                "        runZipSlipTest();"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25298",
        "func_name": "sprinfall/webcc/RequestParser::OnHeadersEnd",
        "description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
        "commit_title": "fix static file serving security issue; fix url path encoding issue",
        "commit_text": "",
        "func_before": "bool RequestParser::OnHeadersEnd() {\n  bool matched = view_matcher_(request_->method(), request_->url().path(),\n                               &stream_);\n\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             request_->url().path().c_str());\n  }\n\n  return matched;\n}",
        "func": "bool RequestParser::OnHeadersEnd() {\n  // Decode the URL path before match.\n  std::string url_path = Url::DecodeUnsafe(request_->url().path());\n  bool matched = view_matcher_(request_->method(), url_path, &stream_);\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             url_path.c_str());\n  }\n  return matched;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,10 @@\n bool RequestParser::OnHeadersEnd() {\n-  bool matched = view_matcher_(request_->method(), request_->url().path(),\n-                               &stream_);\n-\n+  // Decode the URL path before match.\n+  std::string url_path = Url::DecodeUnsafe(request_->url().path());\n+  bool matched = view_matcher_(request_->method(), url_path, &stream_);\n   if (!matched) {\n     LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n-             request_->url().path().c_str());\n+             url_path.c_str());\n   }\n-\n   return matched;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  bool matched = view_matcher_(request_->method(), request_->url().path(),",
                "                               &stream_);",
                "",
                "             request_->url().path().c_str());",
                ""
            ],
            "added_lines": [
                "  // Decode the URL path before match.",
                "  std::string url_path = Url::DecodeUnsafe(request_->url().path());",
                "  bool matched = view_matcher_(request_->method(), url_path, &stream_);",
                "             url_path.c_str());"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25298",
        "func_name": "sprinfall/webcc/Server::Server",
        "description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
        "commit_title": "fix static file serving security issue; fix url path encoding issue",
        "commit_text": "",
        "func_before": "Server::Server(boost::asio::ip::tcp protocol, std::uint16_t port,\n               const fs::path& doc_root)\n    : protocol_(protocol),\n      port_(port),\n      doc_root_(doc_root),\n      acceptor_(io_context_),\n      signals_(io_context_) {\n  AddSignals();\n}",
        "func": "Server::Server(boost::asio::ip::tcp protocol, std::uint16_t port,\n               const fs::path& doc_root)\n    : protocol_(protocol),\n      port_(port),\n      doc_root_(doc_root),\n      acceptor_(io_context_),\n      signals_(io_context_) {\n  CheckDocRoot();\n  AddSignals();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,5 +5,6 @@\n       doc_root_(doc_root),\n       acceptor_(io_context_),\n       signals_(io_context_) {\n+  CheckDocRoot();\n   AddSignals();\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  CheckDocRoot();"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25298",
        "func_name": "sprinfall/webcc/Server::MatchViewOrStatic",
        "description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
        "commit_title": "fix static file serving security issue; fix url path encoding issue",
        "commit_text": "",
        "func_before": "bool Server::MatchViewOrStatic(const std::string& method,\n                               const std::string& url, bool* stream) {\n  if (Router::MatchView(method, url, stream)) {\n    return true;\n  }\n\n  // Try to match a static file.\n  if (method == methods::kGet && !doc_root_.empty()) {\n    fs::path path = doc_root_ / url;\n\n    fs::error_code ec;\n    if (!fs::is_directory(path, ec) && fs::exists(path, ec)) {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "func": "bool Server::MatchViewOrStatic(const std::string& method,\n                               const std::string& url_path, bool* stream) {\n  if (Router::MatchView(method, url_path, stream)) {\n    return true;\n  }\n\n  // Try to match a static file.\n  if (method == methods::kGet && !doc_root_.empty()) {\n    fs::path sub_path = utility::TranslatePath(url_path);\n    //LOG_INFO(\"Translated URL path: %s\", sub_path.u8string().c_str());\n    fs::path path = doc_root_ / sub_path;\n\n    fs::error_code ec;\n    if (!fs::is_directory(path, ec) && fs::exists(path, ec)) {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,14 @@\n bool Server::MatchViewOrStatic(const std::string& method,\n-                               const std::string& url, bool* stream) {\n-  if (Router::MatchView(method, url, stream)) {\n+                               const std::string& url_path, bool* stream) {\n+  if (Router::MatchView(method, url_path, stream)) {\n     return true;\n   }\n \n   // Try to match a static file.\n   if (method == methods::kGet && !doc_root_.empty()) {\n-    fs::path path = doc_root_ / url;\n+    fs::path sub_path = utility::TranslatePath(url_path);\n+    //LOG_INFO(\"Translated URL path: %s\", sub_path.u8string().c_str());\n+    fs::path path = doc_root_ / sub_path;\n \n     fs::error_code ec;\n     if (!fs::is_directory(path, ec) && fs::exists(path, ec)) {",
        "diff_line_info": {
            "deleted_lines": [
                "                               const std::string& url, bool* stream) {",
                "  if (Router::MatchView(method, url, stream)) {",
                "    fs::path path = doc_root_ / url;"
            ],
            "added_lines": [
                "                               const std::string& url_path, bool* stream) {",
                "  if (Router::MatchView(method, url_path, stream)) {",
                "    fs::path sub_path = utility::TranslatePath(url_path);",
                "    //LOG_INFO(\"Translated URL path: %s\", sub_path.u8string().c_str());",
                "    fs::path path = doc_root_ / sub_path;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25298",
        "func_name": "sprinfall/webcc/Server::ServeStatic",
        "description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
        "commit_title": "fix static file serving security issue; fix url path encoding issue",
        "commit_text": "",
        "func_before": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n\n  fs::path path = doc_root_ / request->url().path();\n\n  try {\n    // NOTE: FileBody might throw Error::kFileError.\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n\n    auto response = std::make_shared<Response>(Status::kOK);\n\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n\n    // NOTE: Gzip compression is not supported.\n    response->SetBody(body, true);\n\n    return response;\n\n  } catch (const Error& error) {\n    LOG_ERRO(\"File error: %s\", error.message().c_str());\n    return {};\n  }\n}",
        "func": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n\n  std::string url_path = Url::DecodeUnsafe(request->url().path());\n  fs::path sub_path = utility::TranslatePath(url_path);\n  fs::path path = doc_root_ / sub_path;\n\n  try {\n    // NOTE: FileBody might throw Error::kFileError.\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n\n    auto response = std::make_shared<Response>(Status::kOK);\n\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n\n    // NOTE: Gzip compression is not supported.\n    response->SetBody(body, true);\n\n    return response;\n\n  } catch (const Error& error) {\n    LOG_ERRO(\"File error: %s\", error.message().c_str());\n    return {};\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,9 @@\n     return {};\n   }\n \n-  fs::path path = doc_root_ / request->url().path();\n+  std::string url_path = Url::DecodeUnsafe(request->url().path());\n+  fs::path sub_path = utility::TranslatePath(url_path);\n+  fs::path path = doc_root_ / sub_path;\n \n   try {\n     // NOTE: FileBody might throw Error::kFileError.",
        "diff_line_info": {
            "deleted_lines": [
                "  fs::path path = doc_root_ / request->url().path();"
            ],
            "added_lines": [
                "  std::string url_path = Url::DecodeUnsafe(request->url().path());",
                "  fs::path sub_path = utility::TranslatePath(url_path);",
                "  fs::path path = doc_root_ / sub_path;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25298",
        "func_name": "sprinfall/webcc/Router::MatchView",
        "description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
        "commit_title": "fix static file serving security issue; fix url path encoding issue",
        "commit_text": "",
        "func_before": "bool Router::MatchView(const std::string& method, const std::string& url,\n                       bool* stream) {\n  assert(stream != nullptr);\n  *stream = false;\n\n  for (auto& route : routes_) {\n    if (std::find(route.methods.begin(), route.methods.end(), method) ==\n        route.methods.end()) {\n      continue;\n    }\n\n    if (route.url.empty()) {\n      std::smatch match;\n\n      if (std::regex_match(url, match, route.url_regex)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    } else {\n      if (boost::iequals(route.url, url)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    }\n  }\n\n  return false;\n}",
        "func": "bool Router::MatchView(const std::string& method, const std::string& url_path,\n                       bool* stream) {\n  assert(stream != nullptr);\n  *stream = false;\n\n  for (auto& route : routes_) {\n    if (std::find(route.methods.begin(), route.methods.end(), method) ==\n        route.methods.end()) {\n      continue;\n    }\n\n    if (route.url.empty()) {\n      std::smatch match;\n      if (std::regex_match(url_path, match, route.url_regex)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    } else {\n      if (boost::iequals(route.url, url_path)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    }\n  }\n\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-bool Router::MatchView(const std::string& method, const std::string& url,\n+bool Router::MatchView(const std::string& method, const std::string& url_path,\n                        bool* stream) {\n   assert(stream != nullptr);\n   *stream = false;\n@@ -11,13 +11,12 @@\n \n     if (route.url.empty()) {\n       std::smatch match;\n-\n-      if (std::regex_match(url, match, route.url_regex)) {\n+      if (std::regex_match(url_path, match, route.url_regex)) {\n         *stream = route.view->Stream(method);\n         return true;\n       }\n     } else {\n-      if (boost::iequals(route.url, url)) {\n+      if (boost::iequals(route.url, url_path)) {\n         *stream = route.view->Stream(method);\n         return true;\n       }",
        "diff_line_info": {
            "deleted_lines": [
                "bool Router::MatchView(const std::string& method, const std::string& url,",
                "",
                "      if (std::regex_match(url, match, route.url_regex)) {",
                "      if (boost::iequals(route.url, url)) {"
            ],
            "added_lines": [
                "bool Router::MatchView(const std::string& method, const std::string& url_path,",
                "      if (std::regex_match(url_path, match, route.url_regex)) {",
                "      if (boost::iequals(route.url, url_path)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25298",
        "func_name": "sprinfall/webcc/main",
        "description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
        "commit_title": "fix static file serving security issue; fix url path encoding issue",
        "commit_text": "",
        "func_before": "int main() {\n  WEBCC_LOG_INIT(\"\", webcc::LOG_CONSOLE);\n\n  webcc::ClientSession session;\n\n  webcc::ResponsePtr r;\n\n  try {\n    r = session.Send(webcc::RequestBuilder{}.\n                     Get(\"http://httpbin.org/get\").\n                     Query(\"name\", Utf16ToUtf8(L\"\"), true)\n                     ());\n\n    assert(r->status() == webcc::Status::kOK);\n\n  } catch (const webcc::Error& error) {\n    std::cerr << error << std::endl;\n    return 1;\n  }\n\n  return 0;\n}",
        "func": "int main() {\n  WEBCC_LOG_INIT(\"\", webcc::LOG_CONSOLE);\n\n  webcc::ClientSession session;\n\n  webcc::ResponsePtr r;\n\n  try {\n    r = session.Send(webcc::RequestBuilder{}.\n                     Get(\"http://httpbin.org/get\").\n                     Query(\"name\", webcc::Utf16To8(L\"\"), true)\n                     ());\n\n    assert(r->status() == webcc::Status::kOK);\n\n  } catch (const webcc::Error& error) {\n    std::cerr << error << std::endl;\n    return 1;\n  }\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n   try {\n     r = session.Send(webcc::RequestBuilder{}.\n                      Get(\"http://httpbin.org/get\").\n-                     Query(\"name\", Utf16ToUtf8(L\"\"), true)\n+                     Query(\"name\", webcc::Utf16To8(L\"\"), true)\n                      ());\n \n     assert(r->status() == webcc::Status::kOK);",
        "diff_line_info": {
            "deleted_lines": [
                "                     Query(\"name\", Utf16ToUtf8(L\"\"), true)"
            ],
            "added_lines": [
                "                     Query(\"name\", webcc::Utf16To8(L\"\"), true)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25298",
        "func_name": "sprinfall/webcc/UrlQuery::UrlQuery",
        "description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
        "commit_title": "fix static file serving security issue; fix url path encoding issue",
        "commit_text": "",
        "func_before": "UrlQuery::UrlQuery(const std::string& encoded_str) {\n  if (!encoded_str.empty()) {\n    // Split into key value pairs separated by '&'.\n    for (std::size_t i = 0; i != std::string::npos;) {\n      std::size_t j = encoded_str.find_first_of('&', i);\n\n      std::string kv;\n      if (j == std::string::npos) {\n        kv = encoded_str.substr(i);\n        i = std::string::npos;\n      } else {\n        kv = encoded_str.substr(i, j - i);\n        i = j + 1;\n      }\n\n      string_view key;\n      string_view value;\n      if (SplitKV(kv, '=', false, &key, &value)) {\n        parameters_.push_back({ DecodeUnsafe(key), DecodeUnsafe(value) });\n      }\n    }\n  }\n}",
        "func": "UrlQuery::UrlQuery(const std::string& encoded_str) {\n  if (!encoded_str.empty()) {\n    // Split into key value pairs separated by '&'.\n    for (std::size_t i = 0; i != std::string::npos;) {\n      std::size_t j = encoded_str.find_first_of('&', i);\n\n      std::string kv;\n      if (j == std::string::npos) {\n        kv = encoded_str.substr(i);\n        i = std::string::npos;\n      } else {\n        kv = encoded_str.substr(i, j - i);\n        i = j + 1;\n      }\n\n      string_view key;\n      string_view value;\n      if (SplitKV(kv, '=', false, &key, &value)) {\n        parameters_.push_back(\n            { Url::DecodeUnsafe(key), Url::DecodeUnsafe(value) });\n      }\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,8 @@\n       string_view key;\n       string_view value;\n       if (SplitKV(kv, '=', false, &key, &value)) {\n-        parameters_.push_back({ DecodeUnsafe(key), DecodeUnsafe(value) });\n+        parameters_.push_back(\n+            { Url::DecodeUnsafe(key), Url::DecodeUnsafe(value) });\n       }\n     }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "        parameters_.push_back({ DecodeUnsafe(key), DecodeUnsafe(value) });"
            ],
            "added_lines": [
                "        parameters_.push_back(",
                "            { Url::DecodeUnsafe(key), Url::DecodeUnsafe(value) });"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25298",
        "func_name": "sprinfall/webcc/FileBody::Dump",
        "description": "This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/sprinfall/webcc/commit/55a45fd5039061d5cc62e9f1b9d1f7e97a15143f",
        "commit_title": "fix static file serving security issue; fix url path encoding issue",
        "commit_text": "",
        "func_before": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n}",
        "func": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.u8string() << \">\" << std::endl;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,3 @@\n void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n-  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n+  os << prefix << \"<file: \" << path_.u8string() << \">\" << std::endl;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;"
            ],
            "added_lines": [
                "  os << prefix << \"<file: \" << path_.u8string() << \">\" << std::endl;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-21365",
        "func_name": "wkhtmltopdf/LoadPage::LoadPage",
        "description": "Directory traversal vulnerability in wkhtmltopdf through 0.12.5 allows remote attackers to read local files and disclose sensitive information via a crafted html file running with the default configurations.",
        "git_url": "https://github.com/wkhtmltopdf/wkhtmltopdf/commit/2a5f25077895fb075812c0f599326f079a59d6cf",
        "commit_title": "BREAKING CHANGE: block local filesystem access by default",
        "commit_text": " fixes #4536",
        "func_before": "LoadPage::LoadPage():\n\tjsdelay(200),\n\twindowStatus(\"\"),\n\tzoomFactor(1.0),\n\trepeatCustomHeaders(false),\n\tblockLocalFileAccess(false),\n\tstopSlowScripts(true),\n\tdebugJavascript(false),\n\tloadErrorHandling(abort),\n\tmediaLoadErrorHandling(ignore),\n\tcacheDir(\"\"),\n\tproxyHostNameLookup(false) {}",
        "func": "LoadPage::LoadPage():\n\tjsdelay(200),\n\twindowStatus(\"\"),\n\tzoomFactor(1.0),\n\trepeatCustomHeaders(false),\n\tblockLocalFileAccess(true),\n\tstopSlowScripts(true),\n\tdebugJavascript(false),\n\tloadErrorHandling(abort),\n\tmediaLoadErrorHandling(ignore),\n\tcacheDir(\"\"),\n\tproxyHostNameLookup(false) {}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \twindowStatus(\"\"),\n \tzoomFactor(1.0),\n \trepeatCustomHeaders(false),\n-\tblockLocalFileAccess(false),\n+\tblockLocalFileAccess(true),\n \tstopSlowScripts(true),\n \tdebugJavascript(false),\n \tloadErrorHandling(abort),",
        "diff_line_info": {
            "deleted_lines": [
                "\tblockLocalFileAccess(false),"
            ],
            "added_lines": [
                "\tblockLocalFileAccess(true),"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4668",
        "func_name": "GNOME/file-roller/extract_archive_thread",
        "description": "Directory traversal vulnerability in File Roller 3.6.x before 3.6.4, 3.8.x before 3.8.3, and 3.9.x before 3.9.3, when libarchive is used, allows remote attackers to create arbitrary files via a crafted archive that is not properly handled in a \"Keep directory structure\" action, related to fr-archive-libarchive.c and fr-window.c.",
        "git_url": "https://github.com/GNOME/file-roller/commit/b147281293a8307808475e102a14857055f81631",
        "commit_title": "libarchive: sanitize filenames before extracting",
        "commit_text": "",
        "func_before": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\tfile = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (fullpath, extract_data->base_dir, extract_data->junk_paths));\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar  *link_fullpath;\n\t\t\t\tGFile *link_file;\n\t\t\t\tchar  *oldname;\n\t\t\t\tchar  *newname;\n\t\t\t\tint    r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (link_fullpath, extract_data->base_dir, extract_data->junk_paths));\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "func": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\ta = archive_read_new ();\n\tarchive_read_support_filter_all (a);\n\tarchive_read_support_format_all (a);\n\tarchive_read_open (a, load_data, load_data_open, load_data_read, load_data_close);\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif (extract_data->skip_older || ! extract_data->overwrite) {\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_error_free (local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (g_file_make_directory_with_parents (parent, cancellable, &load_data->error)) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &offset)) == ARCHIVE_OK) {\n\t\t\t\t\tif (g_output_stream_write (ostream, buffer, buffer_size, cancellable, &load_data->error) == -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, buffer_size);\n\t\t\t\t}\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\t_g_file_set_attributes_from_entry (file, entry, extract_data, cancellable);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_error_free (local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = g_error_new_literal (FR_ERROR, FR_ERROR_COMMAND_ERROR, archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,7 @@\n \twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n \t\tconst char    *pathname;\n \t\tchar          *fullpath;\n+\t\tconst char    *relative_path;\n \t\tGFile         *file;\n \t\tGFile         *parent;\n \t\tGOutputStream *ostream;\n@@ -42,7 +43,12 @@\n \t\t}\n \n \t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n-\t\tfile = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (fullpath, extract_data->base_dir, extract_data->junk_paths));\n+\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n+\t\tif (relative_path == NULL) {\n+\t\t\tarchive_read_data_skip (a);\n+\t\t\tcontinue;\n+\t\t}\n+\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n \n \t\t/* honor the skip_older and overwrite options */\n \n@@ -126,14 +132,22 @@\n \n \t\t\tlinkname = archive_entry_hardlink (entry);\n \t\t\tif (linkname != NULL) {\n-\t\t\t\tchar  *link_fullpath;\n-\t\t\t\tGFile *link_file;\n-\t\t\t\tchar  *oldname;\n-\t\t\t\tchar  *newname;\n-\t\t\t\tint    r;\n+\t\t\t\tchar        *link_fullpath;\n+\t\t\t\tconst char  *relative_path;\n+\t\t\t\tGFile       *link_file;\n+\t\t\t\tchar        *oldname;\n+\t\t\t\tchar        *newname;\n+\t\t\t\tint          r;\n \n \t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n-\t\t\t\tlink_file = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (link_fullpath, extract_data->base_dir, extract_data->junk_paths));\n+\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n+\t\t\t\tif (relative_path == NULL) {\n+\t\t\t\t\tg_free (link_fullpath);\n+\t\t\t\t\tarchive_read_data_skip (a);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n \t\t\t\toldname = g_file_get_path (link_file);\n \t\t\t\tnewname = g_file_get_path (file);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfile = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (fullpath, extract_data->base_dir, extract_data->junk_paths));",
                "\t\t\t\tchar  *link_fullpath;",
                "\t\t\t\tGFile *link_file;",
                "\t\t\t\tchar  *oldname;",
                "\t\t\t\tchar  *newname;",
                "\t\t\t\tint    r;",
                "\t\t\t\tlink_file = g_file_get_child (extract_data->destination, _g_path_get_relative_basename (link_fullpath, extract_data->base_dir, extract_data->junk_paths));"
            ],
            "added_lines": [
                "\t\tconst char    *relative_path;",
                "\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);",
                "\t\tif (relative_path == NULL) {",
                "\t\t\tarchive_read_data_skip (a);",
                "\t\t\tcontinue;",
                "\t\t}",
                "\t\tfile = g_file_get_child (extract_data->destination, relative_path);",
                "\t\t\t\tchar        *link_fullpath;",
                "\t\t\t\tconst char  *relative_path;",
                "\t\t\t\tGFile       *link_file;",
                "\t\t\t\tchar        *oldname;",
                "\t\t\t\tchar        *newname;",
                "\t\t\t\tint          r;",
                "\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);",
                "\t\t\t\tif (relative_path == NULL) {",
                "\t\t\t\t\tg_free (link_fullpath);",
                "\t\t\t\t\tarchive_read_data_skip (a);",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4668",
        "func_name": "GNOME/file-roller/_fr_window_ask_overwrite_dialog",
        "description": "Directory traversal vulnerability in File Roller 3.6.x before 3.6.4, 3.8.x before 3.8.3, and 3.9.x before 3.9.3, when libarchive is used, allows remote attackers to create arbitrary files via a crafted archive that is not properly handled in a \"Keep directory structure\" action, related to fr-archive-libarchive.c and fr-window.c.",
        "git_url": "https://github.com/GNOME/file-roller/commit/b147281293a8307808475e102a14857055f81631",
        "commit_title": "libarchive: sanitize filenames before extracting",
        "commit_text": "",
        "func_before": "static void\n_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\n\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\tg_file_query_info_async (destination,\n\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t odata);\n\n\t\tg_object_unref (destination);\n\n\t\treturn;\n\t}\n\n\tif (odata->edata->file_list != NULL) {\n\t\t/* speed optimization: passing NULL when extracting all the\n\t\t * files is faster if the command supports the\n\t\t * propCanExtractAll property. */\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\n\tg_free (odata);\n}",
        "func": "static void\n_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tgboolean perform_extraction = TRUE;\n\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\n\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tif (base_name != NULL) {\n\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\t\tg_file_query_info_async (destination,\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t\t odata);\n\n\t\t\tg_object_unref (destination);\n\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tperform_extraction = FALSE;\n\t}\n\n\tif (odata->edata->file_list == NULL)\n\t\tperform_extraction = FALSE;\n\n\tif (perform_extraction) {\n\t\t/* speed optimization: passing NULL when extracting all the\n\t\t * files is faster if the command supports the\n\t\t * propCanExtractAll property. */\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\n\tg_free (odata);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,26 +1,35 @@\n static void\n _fr_window_ask_overwrite_dialog (OverwriteData *odata)\n {\n+\tgboolean perform_extraction = TRUE;\n+\n \tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n \t\tconst char *base_name;\n \t\tGFile      *destination;\n \n-\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n-\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n-\t\tg_file_query_info_async (destination,\n-\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n-\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n-\t\t\t\t\t G_PRIORITY_DEFAULT,\n-\t\t\t\t\t odata->window->priv->cancellable,\n-\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n-\t\t\t\t\t odata);\n+\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n+\t\tif (base_name != NULL) {\n+\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n+\t\t\tg_file_query_info_async (destination,\n+\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n+\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n+\t\t\t\t\t\t G_PRIORITY_DEFAULT,\n+\t\t\t\t\t\t odata->window->priv->cancellable,\n+\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n+\t\t\t\t\t\t odata);\n \n-\t\tg_object_unref (destination);\n+\t\t\tg_object_unref (destination);\n \n-\t\treturn;\n+\t\t\treturn;\n+\t\t}\n+\t\telse\n+\t\t\tperform_extraction = FALSE;\n \t}\n \n-\tif (odata->edata->file_list != NULL) {\n+\tif (odata->edata->file_list == NULL)\n+\t\tperform_extraction = FALSE;\n+\n+\tif (perform_extraction) {\n \t\t/* speed optimization: passing NULL when extracting all the\n \t\t * files is faster if the command supports the\n \t\t * propCanExtractAll property. */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);",
                "\t\tdestination = g_file_get_child (odata->edata->destination, base_name);",
                "\t\tg_file_query_info_async (destination,",
                "\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,",
                "\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,",
                "\t\t\t\t\t G_PRIORITY_DEFAULT,",
                "\t\t\t\t\t odata->window->priv->cancellable,",
                "\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,",
                "\t\t\t\t\t odata);",
                "\t\tg_object_unref (destination);",
                "\t\treturn;",
                "\tif (odata->edata->file_list != NULL) {"
            ],
            "added_lines": [
                "\tgboolean perform_extraction = TRUE;",
                "",
                "\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);",
                "\t\tif (base_name != NULL) {",
                "\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);",
                "\t\t\tg_file_query_info_async (destination,",
                "\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,",
                "\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,",
                "\t\t\t\t\t\t G_PRIORITY_DEFAULT,",
                "\t\t\t\t\t\t odata->window->priv->cancellable,",
                "\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,",
                "\t\t\t\t\t\t odata);",
                "\t\t\tg_object_unref (destination);",
                "\t\t\treturn;",
                "\t\t}",
                "\t\telse",
                "\t\t\tperform_extraction = FALSE;",
                "\tif (odata->edata->file_list == NULL)",
                "\t\tperform_extraction = FALSE;",
                "",
                "\tif (perform_extraction) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6652",
        "func_name": "chromium/NamedPipeDispatcher::CreateNamedPipe",
        "description": "Directory traversal vulnerability in sandbox/win/src/named_pipe_dispatcher.cc in Google Chrome before 33.0.1750.117 on Windows allows attackers to bypass intended named-pipe policy restrictions in the sandbox via vectors related to (1) lack of checks for .. (dot dot) sequences or (2) lack of use of the \\\\?\\ protection mechanism.",
        "git_url": "https://github.com/chromium/chromium/commit/172c77a9f7922fc9b58632abe62173c66fb6e10b",
        "commit_title": "Correctly test for canonicalized path in the CreateNamedPipe policy engine.",
        "commit_text": "  ",
        "func_before": "bool NamedPipeDispatcher::CreateNamedPipe(\n    IPCInfo* ipc, base::string16* name, DWORD open_mode, DWORD pipe_mode,\n    DWORD max_instances, DWORD out_buffer_size, DWORD in_buffer_size,\n    DWORD default_timeout) {\n  const wchar_t* pipe_name = name->c_str();\n  CountedParameterSet<NameBased> params;\n  params[NameBased::NAME] = ParamPickerMake(pipe_name);\n\n  EvalResult eval = policy_base_->EvalPolicy(IPC_CREATENAMEDPIPEW_TAG,\n                                             params.GetBase());\n\n  HANDLE pipe;\n  DWORD ret = NamedPipePolicy::CreateNamedPipeAction(eval, *ipc->client_info,\n                                                     *name, open_mode,\n                                                     pipe_mode, max_instances,\n                                                     out_buffer_size,\n                                                     in_buffer_size,\n                                                     default_timeout, &pipe);\n\n  ipc->return_info.win32_result = ret;\n  ipc->return_info.handle = pipe;\n  return true;\n}",
        "func": "bool NamedPipeDispatcher::CreateNamedPipe(\n    IPCInfo* ipc, base::string16* name, DWORD open_mode, DWORD pipe_mode,\n    DWORD max_instances, DWORD out_buffer_size, DWORD in_buffer_size,\n    DWORD default_timeout) {\n  ipc->return_info.win32_result = ERROR_ACCESS_DENIED;\n  ipc->return_info.handle = INVALID_HANDLE_VALUE;\n\n  std::vector<base::string16> paths;\n  std::vector<base::string16> innerpaths;\n  base::SplitString(*name, '/', &paths);\n\n  for (std::vector<base::string16>::const_iterator iter = paths.begin();\n       iter != paths.end(); ++iter) {\n    base::SplitString(*iter, '\\\\', &innerpaths);\n    for (std::vector<base::string16>::const_iterator iter2 = innerpaths.begin();\n          iter2 != innerpaths.end(); ++iter2) {\n      if (*iter2 == L\"..\")\n          return true;\n    }\n  }\n\n  const wchar_t* pipe_name = name->c_str();\n  CountedParameterSet<NameBased> params;\n  params[NameBased::NAME] = ParamPickerMake(pipe_name);\n\n  EvalResult eval = policy_base_->EvalPolicy(IPC_CREATENAMEDPIPEW_TAG,\n                                             params.GetBase());\n\n  // \"For file I/O, the \"\\\\?\\\" prefix to a path string tells the Windows APIs to\n  // disable all string parsing and to send the string that follows it straight\n  // to the file system.\"\n  // http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx\n  // This ensures even if there is a path traversal in the pipe name, and it is\n  // able to get past the checks above, it will still not be allowed to escape\n  // our whitelisted namespace.\n  if (name->compare(0, 4, L\"\\\\\\\\.\\\\\") == 0)\n    name->replace(0, 4, L\"\\\\\\\\\\?\\\\\");\n\n  HANDLE pipe;\n  DWORD ret = NamedPipePolicy::CreateNamedPipeAction(eval, *ipc->client_info,\n                                                     *name, open_mode,\n                                                     pipe_mode, max_instances,\n                                                     out_buffer_size,\n                                                     in_buffer_size,\n                                                     default_timeout, &pipe);\n\n  ipc->return_info.win32_result = ret;\n  ipc->return_info.handle = pipe;\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,39 @@\n     IPCInfo* ipc, base::string16* name, DWORD open_mode, DWORD pipe_mode,\n     DWORD max_instances, DWORD out_buffer_size, DWORD in_buffer_size,\n     DWORD default_timeout) {\n+  ipc->return_info.win32_result = ERROR_ACCESS_DENIED;\n+  ipc->return_info.handle = INVALID_HANDLE_VALUE;\n+\n+  std::vector<base::string16> paths;\n+  std::vector<base::string16> innerpaths;\n+  base::SplitString(*name, '/', &paths);\n+\n+  for (std::vector<base::string16>::const_iterator iter = paths.begin();\n+       iter != paths.end(); ++iter) {\n+    base::SplitString(*iter, '\\\\', &innerpaths);\n+    for (std::vector<base::string16>::const_iterator iter2 = innerpaths.begin();\n+          iter2 != innerpaths.end(); ++iter2) {\n+      if (*iter2 == L\"..\")\n+          return true;\n+    }\n+  }\n+\n   const wchar_t* pipe_name = name->c_str();\n   CountedParameterSet<NameBased> params;\n   params[NameBased::NAME] = ParamPickerMake(pipe_name);\n \n   EvalResult eval = policy_base_->EvalPolicy(IPC_CREATENAMEDPIPEW_TAG,\n                                              params.GetBase());\n+\n+  // \"For file I/O, the \"\\\\?\\\" prefix to a path string tells the Windows APIs to\n+  // disable all string parsing and to send the string that follows it straight\n+  // to the file system.\"\n+  // http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx\n+  // This ensures even if there is a path traversal in the pipe name, and it is\n+  // able to get past the checks above, it will still not be allowed to escape\n+  // our whitelisted namespace.\n+  if (name->compare(0, 4, L\"\\\\\\\\.\\\\\") == 0)\n+    name->replace(0, 4, L\"\\\\\\\\\\?\\\\\");\n \n   HANDLE pipe;\n   DWORD ret = NamedPipePolicy::CreateNamedPipeAction(eval, *ipc->client_info,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  ipc->return_info.win32_result = ERROR_ACCESS_DENIED;",
                "  ipc->return_info.handle = INVALID_HANDLE_VALUE;",
                "",
                "  std::vector<base::string16> paths;",
                "  std::vector<base::string16> innerpaths;",
                "  base::SplitString(*name, '/', &paths);",
                "",
                "  for (std::vector<base::string16>::const_iterator iter = paths.begin();",
                "       iter != paths.end(); ++iter) {",
                "    base::SplitString(*iter, '\\\\', &innerpaths);",
                "    for (std::vector<base::string16>::const_iterator iter2 = innerpaths.begin();",
                "          iter2 != innerpaths.end(); ++iter2) {",
                "      if (*iter2 == L\"..\")",
                "          return true;",
                "    }",
                "  }",
                "",
                "",
                "  // \"For file I/O, the \"\\\\?\\\" prefix to a path string tells the Windows APIs to",
                "  // disable all string parsing and to send the string that follows it straight",
                "  // to the file system.\"",
                "  // http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx",
                "  // This ensures even if there is a path traversal in the pipe name, and it is",
                "  // able to get past the checks above, it will still not be allowed to escape",
                "  // our whitelisted namespace.",
                "  if (name->compare(0, 4, L\"\\\\\\\\.\\\\\") == 0)",
                "    name->replace(0, 4, L\"\\\\\\\\\\?\\\\\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3602",
        "func_name": "radvd-project/radvd/set_interface_var",
        "description": "Directory traversal vulnerability in device-linux.c in the router advertisement daemon (radvd) before 1.8.2 allows local users to overwrite arbitrary files, and remote attackers to overwrite certain files, via a .. (dot dot) in an interface name.  NOTE: this can be leveraged with a symlink to overwrite arbitrary files.",
        "git_url": "https://github.com/radvd-project/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc",
        "commit_title": "set_interface_var() doesn't check interface name and blindly does",
        "commit_text": "fopen(path \"/\" ifname, \"w\") on it.  As \"ifname\" is an untrusted input, it should be checked for \"..\" and/or \"/\" in it.  Otherwise, an infected unprivileged daemon may overwrite contents of file named \"mtu\", \"hoplimit\", etc. in arbitrary location with arbitrary 32-bit value in decimal representation (\"%d\").  If an attacker has a local account or may create arbitrary symlinks with these names in any location (e.g. /tmp), any file may be overwritten with a decimal value.",
        "func_before": "int\nset_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}",
        "func": "int\nset_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\t/* No path traversal */\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,10 @@\n \tFILE *fp;\n \tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n \tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n+\t\treturn -1;\n+\n+\t/* No path traversal */\n+\tif (strstr(name, \"..\") || strchr(name, '/'))\n \t\treturn -1;\n \n \tif (access(spath, F_OK) != 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\treturn -1;",
                "",
                "\t/* No path traversal */",
                "\tif (strstr(name, \"..\") || strchr(name, '/'))"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15908",
        "func_name": "CauldronDevelopmentLLC/cbang/TarFileReader::extract",
        "description": "tar/TarFileReader.cpp in Cauldron cbang (aka C-Bang or C!) before 1.6.0 allows Directory Traversal during extraction from a TAR archive.",
        "git_url": "https://github.com/CauldronDevelopmentLLC/cbang/commit/1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7",
        "commit_title": "Don't allow extraction of tar files outside of the target directory, added tar tests",
        "commit_text": "",
        "func_before": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  return extract(*SystemUtilities::oopen(path));\n}",
        "func": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) {\n    path += \"/\" + getFilename();\n\n    // Check that path is under the target directory\n    string a = SystemUtilities::getCanonicalPath(_path);\n    string b = SystemUtilities::getCanonicalPath(path);\n    if (!String::startsWith(b, a))\n      THROW(\"Tar path points outside of the extraction directory: \" << path);\n  }\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  switch (getType()) {\n  case NORMAL_FILE: case CONTIGUOUS_FILE:\n    return extract(*SystemUtilities::oopen(path));\n  case DIRECTORY: SystemUtilities::ensureDirectory(path); break;\n  default: THROW(\"Unsupported tar file type \" << getType());\n  }\n\n  return getFilename();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,24 @@\n   if (!hasMore()) THROW(\"No more tar files\");\n \n   string path = _path;\n-  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n+  if (SystemUtilities::isDirectory(path)) {\n+    path += \"/\" + getFilename();\n+\n+    // Check that path is under the target directory\n+    string a = SystemUtilities::getCanonicalPath(_path);\n+    string b = SystemUtilities::getCanonicalPath(path);\n+    if (!String::startsWith(b, a))\n+      THROW(\"Tar path points outside of the extraction directory: \" << path);\n+  }\n \n   LOG_DEBUG(5, \"Extracting: \" << path);\n \n-  return extract(*SystemUtilities::oopen(path));\n+  switch (getType()) {\n+  case NORMAL_FILE: case CONTIGUOUS_FILE:\n+    return extract(*SystemUtilities::oopen(path));\n+  case DIRECTORY: SystemUtilities::ensureDirectory(path); break;\n+  default: THROW(\"Unsupported tar file type \" << getType());\n+  }\n+\n+  return getFilename();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();",
                "  return extract(*SystemUtilities::oopen(path));"
            ],
            "added_lines": [
                "  if (SystemUtilities::isDirectory(path)) {",
                "    path += \"/\" + getFilename();",
                "",
                "    // Check that path is under the target directory",
                "    string a = SystemUtilities::getCanonicalPath(_path);",
                "    string b = SystemUtilities::getCanonicalPath(path);",
                "    if (!String::startsWith(b, a))",
                "      THROW(\"Tar path points outside of the extraction directory: \" << path);",
                "  }",
                "  switch (getType()) {",
                "  case NORMAL_FILE: case CONTIGUOUS_FILE:",
                "    return extract(*SystemUtilities::oopen(path));",
                "  case DIRECTORY: SystemUtilities::ensureDirectory(path); break;",
                "  default: THROW(\"Unsupported tar file type \" << getType());",
                "  }",
                "",
                "  return getFilename();"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7448",
        "func_name": "yarolig/didiwiki/wiki_handle_http_request",
        "description": "Directory traversal vulnerability in wiki.c in didiwiki allows remote attackers to read arbitrary files via the page parameter to api/page/get.",
        "git_url": "https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea",
        "commit_title": "page_name_is_good function",
        "commit_text": "",
        "func_before": "void\nwiki_handle_http_request(HttpRequest *req)\n{\n  HttpResponse *res      = http_response_new(req);\n  char         *page     = http_request_get_path_info(req); \n  char         *command  = http_request_get_query_string(req); \n  char         *wikitext = \"\";\n\n  util_dehttpize(page); \t/* remove any encoding on the requested\n\t\t\t\t   page name.                           */\n\n  if (!strcmp(page, \"/\"))\n    {\n      if (access(\"WikiHome\", R_OK) != 0)\n\twiki_redirect(res, \"/WikiHome?create\");\n      page = \"/WikiHome\";\n    }\n\n  if (!strcmp(page, \"/styles.css\"))\n    {\n      /*  Return CSS page */\n      http_response_set_content_type(res, \"text/css\");\n      http_response_printf(res, \"%s\", CssData);\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"/favicon.ico\"))\n    {\n      /*  Return favicon */\n      http_response_set_content_type(res, \"image/ico\");\n      http_response_set_data(res, FaviconData, FaviconDataLen);\n      http_response_send(res);\n      exit(0);\n    }\n\n\n  page = page + 1; \t\t/* skip slash */\n\n  if (!strncmp(page, \"api/\", 4))\n    {\n      char *p;\n\n      page += 4; \n      for (p=page; *p != '\\0'; p++)\n\tif (*p=='?') { *p ='\\0'; break; }\n      \n      wiki_handle_rest_call(req, res, page); \n      exit(0);\n    }\n\n  /* A little safety. issue a malformed request for any paths,\n   * There shouldn't need to be any..\n   */\n  if (strchr(page, '/'))\n    {\n      http_response_set_status(res, 404, \"Not Found\");\n      http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"Changes\"))\n    {\n      wiki_show_changes_page(res);\n    }\n  else if (!strcmp(page, \"ChangesRss\"))\n    {\n      wiki_show_changes_page_rss(res);\n    }\n  else if (!strcmp(page, \"Search\"))\n    {\n      wiki_show_search_results_page(res, http_request_param_get(req, \"expr\"));\n    }\n  else if (!strcmp(page, \"Create\"))\n    {\n      if ( (wikitext = http_request_param_get(req, \"title\")) != NULL)\n\t{\n\t  /* create page and redirect */\n\t  wiki_redirect(res, http_request_param_get(req, \"title\"));\n\t}\n      else\n\t{\n\t   /* show create page form  */\n\t  wiki_show_create_page(res);\n\t}\n    }\n  else\n    {\n      /* TODO: dont blindly write wikitext data to disk */\n      if ( (wikitext = http_request_param_get(req, \"wikitext\")) != NULL)\n\t{\n\t  file_write(page, wikitext);\t      \n\t}\n\n      if (access(page, R_OK) == 0) \t/* page exists */\n\t{\n\t  wikitext = file_read(page);\n\t  \n\t  if (!strcmp(command, \"edit\"))\n\t    {\n\t      /* print edit page */\n\t      wiki_show_edit_page(res, wikitext, page);\n\t    }\n\t  else\n\t    {\n\t      wiki_show_page(res, wikitext, page);\n\t    }\n\t}\n      else\n\t{\n\t  if (!strcmp(command, \"create\"))\n\t    {\n\t      wiki_show_edit_page(res, NULL, page);\n\t    }\n\t  else\n\t    {\n\t      char buf[1024];\n\t      snprintf(buf, 1024, \"%s?create\", page);\n\t      wiki_redirect(res, buf);\n\t    }\n\t}\n    }\n\n}",
        "func": "void\nwiki_handle_http_request(HttpRequest *req)\n{\n  HttpResponse *res      = http_response_new(req);\n  char         *page     = http_request_get_path_info(req); \n  char         *command  = http_request_get_query_string(req); \n  char         *wikitext = \"\";\n\n  util_dehttpize(page); \t/* remove any encoding on the requested\n\t\t\t\t   page name.                           */\n\n  if (!strcmp(page, \"/\"))\n    {\n      if (access(\"WikiHome\", R_OK) != 0)\n\twiki_redirect(res, \"/WikiHome?create\");\n      page = \"/WikiHome\";\n    }\n\n  if (!strcmp(page, \"/styles.css\"))\n    {\n      /*  Return CSS page */\n      http_response_set_content_type(res, \"text/css\");\n      http_response_printf(res, \"%s\", CssData);\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"/favicon.ico\"))\n    {\n      /*  Return favicon */\n      http_response_set_content_type(res, \"image/ico\");\n      http_response_set_data(res, FaviconData, FaviconDataLen);\n      http_response_send(res);\n      exit(0);\n    }\n\n\n  page = page + 1; \t\t/* skip slash */\n\n  if (!strncmp(page, \"api/\", 4))\n    {\n      char *p;\n\n      page += 4; \n      for (p=page; *p != '\\0'; p++)\n\tif (*p=='?') { *p ='\\0'; break; }\n      \n      wiki_handle_rest_call(req, res, page); \n      exit(0);\n    }\n\n  /* A little safety. issue a malformed request for any paths,\n   * There shouldn't need to be any..\n   */\n  if (!page_name_is_good(page))\n    {\n      http_response_set_status(res, 404, \"Not Found\");\n      http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");\n      http_response_send(res);\n      exit(0);\n    }\n\n  if (!strcmp(page, \"Changes\"))\n    {\n      wiki_show_changes_page(res);\n    }\n  else if (!strcmp(page, \"ChangesRss\"))\n    {\n      wiki_show_changes_page_rss(res);\n    }\n  else if (!strcmp(page, \"Search\"))\n    {\n      wiki_show_search_results_page(res, http_request_param_get(req, \"expr\"));\n    }\n  else if (!strcmp(page, \"Create\"))\n    {\n      if ( (wikitext = http_request_param_get(req, \"title\")) != NULL)\n\t{\n\t  /* create page and redirect */\n\t  wiki_redirect(res, http_request_param_get(req, \"title\"));\n\t}\n      else\n\t{\n\t   /* show create page form  */\n\t  wiki_show_create_page(res);\n\t}\n    }\n  else\n    {\n      /* TODO: dont blindly write wikitext data to disk */\n      if ( (wikitext = http_request_param_get(req, \"wikitext\")) != NULL)\n\t{\n\t  file_write(page, wikitext);\t      \n\t}\n\n      if (access(page, R_OK) == 0) \t/* page exists */\n\t{\n\t  wikitext = file_read(page);\n\t  \n\t  if (!strcmp(command, \"edit\"))\n\t    {\n\t      /* print edit page */\n\t      wiki_show_edit_page(res, wikitext, page);\n\t    }\n\t  else\n\t    {\n\t      wiki_show_page(res, wikitext, page);\n\t    }\n\t}\n      else\n\t{\n\t  if (!strcmp(command, \"create\"))\n\t    {\n\t      wiki_show_edit_page(res, NULL, page);\n\t    }\n\t  else\n\t    {\n\t      char buf[1024];\n\t      snprintf(buf, 1024, \"%s?create\", page);\n\t      wiki_redirect(res, buf);\n\t    }\n\t}\n    }\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -52,7 +52,7 @@\n   /* A little safety. issue a malformed request for any paths,\n    * There shouldn't need to be any..\n    */\n-  if (strchr(page, '/'))\n+  if (!page_name_is_good(page))\n     {\n       http_response_set_status(res, 404, \"Not Found\");\n       http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");",
        "diff_line_info": {
            "deleted_lines": [
                "  if (strchr(page, '/'))"
            ],
            "added_lines": [
                "  if (!page_name_is_good(page))"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7448",
        "func_name": "yarolig/didiwiki/wiki_handle_rest_call",
        "description": "Directory traversal vulnerability in wiki.c in didiwiki allows remote attackers to read arbitrary files via the page parameter to api/page/get.",
        "git_url": "https://github.com/yarolig/didiwiki/commit/5e5c796617e1712905dc5462b94bd5e6c08d15ea",
        "commit_title": "page_name_is_good function",
        "commit_text": "",
        "func_before": "void\nwiki_handle_rest_call(HttpRequest  *req, \n\t\t      HttpResponse *res,\n\t\t      char         *func)\n{\n\n  if (func != NULL && *func != '\\0')\n    {\n      if (!strcmp(func, \"page/get\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && (access(page, R_OK) == 0)) \n\t    {\n\t      http_response_printf(res, \"%s\", file_read(page));\n\t      http_response_send(res);\n\t      return;\n\t    }  \n\t}\n      else if (!strcmp(func, \"page/set\"))\n\t{\n\t  char *wikitext = NULL, *page = NULL;\n\t  if( ( (wikitext = http_request_param_get(req, \"text\")) != NULL)\n\t      && ( (page = http_request_param_get(req, \"page\")) != NULL))\n\t    {\n\t      file_write(page, wikitext);\t      \n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;\n\t    }\n\t}\n      else if (!strcmp(func, \"page/delete\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && (unlink(page) > 0))\n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"page/exists\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && (access(page, R_OK) == 0)) \n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"pages\") || !strcmp(func, \"search\"))\n\t{\n\t  WikiPageList **pages = NULL;\n\t  int            n_pages, i;\n\t  char          *expr = http_request_param_get(req, \"expr\");\n\n\t  if (expr == NULL)\n\t    expr = http_request_get_query_string(req);\n\t  \n\t  pages = wiki_get_pages(&n_pages, expr);\n\n\t  if (pages)\n\t    {\n\t      for (i=0; i<n_pages; i++)\n\t\t{\n\t\t  struct tm   *pTm;\n\t\t  char   datebuf[64];\n\t\t  \n\t\t  pTm = localtime(&pages[i]->mtime);\n\t\t  strftime(datebuf, sizeof(datebuf), \"%Y-%m-%d %H:%M\", pTm);\n\t\t  http_response_printf(res, \"%s\\t%s\\n\", pages[i]->name, datebuf);\n\t\t}\n\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n    }\n\n  http_response_set_status(res, 500, \"Error\");\n  http_response_printf(res, \"<html><body>Failed</body></html>\\n\");\n  http_response_send(res);\n\n  return;  \n}",
        "func": "void\nwiki_handle_rest_call(HttpRequest  *req, \n\t\t      HttpResponse *res,\n\t\t      char         *func)\n{\n\n  if (func != NULL && *func != '\\0')\n    {\n      if (!strcmp(func, \"page/get\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n\t    {\n\t      http_response_printf(res, \"%s\", file_read(page));\n\t      http_response_send(res);\n\t      return;\n\t    }  \n\t}\n      else if (!strcmp(func, \"page/set\"))\n\t{\n\t  char *wikitext = NULL, *page = NULL;\n\t  if( ( (wikitext = http_request_param_get(req, \"text\")) != NULL)\n\t      && ( (page = http_request_param_get(req, \"page\")) != NULL))\n\t    {\n\t  if (page_name_is_good(page))\n\t    {\n\t      file_write(page, wikitext);\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;\n\t    }\n\t    }\n\t}\n      else if (!strcmp(func, \"page/delete\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && page_name_is_good(page) && (unlink(page) > 0))\n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"page/exists\"))\n\t{\n\t  char *page = http_request_param_get(req, \"page\");\n\n\t  if (page == NULL)\n\t    page = http_request_get_query_string(req);\n\n\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n\t    {\n\t      http_response_printf(res, \"success\");\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n      else if (!strcmp(func, \"pages\") || !strcmp(func, \"search\"))\n\t{\n\t  WikiPageList **pages = NULL;\n\t  int            n_pages, i;\n\t  char          *expr = http_request_param_get(req, \"expr\");\n\n\t  if (expr == NULL)\n\t    expr = http_request_get_query_string(req);\n\t  \n\t  pages = wiki_get_pages(&n_pages, expr);\n\n\t  if (pages)\n\t    {\n\t      for (i=0; i<n_pages; i++)\n\t\t{\n\t\t  struct tm   *pTm;\n\t\t  char   datebuf[64];\n\t\t  \n\t\t  pTm = localtime(&pages[i]->mtime);\n\t\t  strftime(datebuf, sizeof(datebuf), \"%Y-%m-%d %H:%M\", pTm);\n\t\t  http_response_printf(res, \"%s\\t%s\\n\", pages[i]->name, datebuf);\n\t\t}\n\n\t      http_response_send(res);\n\t      return;  \n\t    }\n\t}\n    }\n\n  http_response_set_status(res, 500, \"Error\");\n  http_response_printf(res, \"<html><body>Failed</body></html>\\n\");\n  http_response_send(res);\n\n  return;  \n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \t  if (page == NULL)\n \t    page = http_request_get_query_string(req);\n \n-\t  if (page && (access(page, R_OK) == 0)) \n+\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n \t    {\n \t      http_response_printf(res, \"%s\", file_read(page));\n \t      http_response_send(res);\n@@ -26,10 +26,13 @@\n \t  if( ( (wikitext = http_request_param_get(req, \"text\")) != NULL)\n \t      && ( (page = http_request_param_get(req, \"page\")) != NULL))\n \t    {\n-\t      file_write(page, wikitext);\t      \n+\t  if (page_name_is_good(page))\n+\t    {\n+\t      file_write(page, wikitext);\n \t      http_response_printf(res, \"success\");\n \t      http_response_send(res);\n \t      return;\n+\t    }\n \t    }\n \t}\n       else if (!strcmp(func, \"page/delete\"))\n@@ -39,7 +42,7 @@\n \t  if (page == NULL)\n \t    page = http_request_get_query_string(req);\n \n-\t  if (page && (unlink(page) > 0))\n+\t  if (page && page_name_is_good(page) && (unlink(page) > 0))\n \t    {\n \t      http_response_printf(res, \"success\");\n \t      http_response_send(res);\n@@ -53,7 +56,7 @@\n \t  if (page == NULL)\n \t    page = http_request_get_query_string(req);\n \n-\t  if (page && (access(page, R_OK) == 0)) \n+\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))\n \t    {\n \t      http_response_printf(res, \"success\");\n \t      http_response_send(res);",
        "diff_line_info": {
            "deleted_lines": [
                "\t  if (page && (access(page, R_OK) == 0)) ",
                "\t      file_write(page, wikitext);\t      ",
                "\t  if (page && (unlink(page) > 0))",
                "\t  if (page && (access(page, R_OK) == 0)) "
            ],
            "added_lines": [
                "\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))",
                "\t  if (page_name_is_good(page))",
                "\t    {",
                "\t      file_write(page, wikitext);",
                "\t    }",
                "\t  if (page && page_name_is_good(page) && (unlink(page) > 0))",
                "\t  if (page && page_name_is_good(page) && (access(page, R_OK) == 0))"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-7448",
        "func_name": "OpenedHand/didiwiki/page_name_is_good",
        "description": "Directory traversal vulnerability in wiki.c in didiwiki allows remote attackers to read arbitrary files via the page parameter to api/page/get.",
        "git_url": "https://github.com/OpenedHand/didiwiki/commit/57b0399f4dec1bea1542ab3afa89427f08463a9c",
        "commit_title": "fix build",
        "commit_text": "",
        "func_before": "int page_name_is_good(char* page_name)\n{\n/* We should give access only to subdirs of didiwiki root.\n   I guess that check for absense of '/' is enough.\n\n   TODO: Use realpath()\n*/\n    if (!page_name)\n        return FALSE;\n\n    if (!isalnum(page[0]))\n        return FALSE;\n\n    if (strstr(page, \"..\"))\n        return FALSE;\n\n    return TRUE;\n}",
        "func": "int page_name_is_good(char* page_name)\n{\n/* We should give access only to subdirs of didiwiki root.\n   I guess that check for absense of '/' is enough.\n\n   TODO: Use realpath()\n*/\n    if (!page_name)\n        return FALSE;\n\n    if (!isalnum(page_name[0]))\n        return FALSE;\n\n    if (strstr(page_name, \"..\"))\n        return FALSE;\n\n    return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,10 +8,10 @@\n     if (!page_name)\n         return FALSE;\n \n-    if (!isalnum(page[0]))\n+    if (!isalnum(page_name[0]))\n         return FALSE;\n \n-    if (strstr(page, \"..\"))\n+    if (strstr(page_name, \"..\"))\n         return FALSE;\n \n     return TRUE;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!isalnum(page[0]))",
                "    if (strstr(page, \"..\"))"
            ],
            "added_lines": [
                "    if (!isalnum(page_name[0]))",
                "    if (strstr(page_name, \"..\"))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1671",
        "func_name": "chromium/FileURLToFilePath",
        "description": "Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and \\ (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/30408ae67a9f6aea074b2883ba861613f52bd246",
        "commit_title": "FileURLToFilePath:  Don't unescape '/' and '\\\\'.",
        "commit_text": " GURL leaves these escaped, and unescaping them in paths changes the meaning of the path.  Added two values to the UnescapeRule enumeration: PATH_SEPARATORS and URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS.  In followup CLs, I intend to replace all uses of URL_SPECIAL_CHARS, in favor of one or both the two new values, and eventually remove the value, as it's easily to use in an unsafe manner.    ",
        "func_before": "bool FileURLToFilePath(const GURL& url, base::FilePath* file_path) {\n  *file_path = base::FilePath();\n  base::FilePath::StringType& file_path_str =\n      const_cast<base::FilePath::StringType&>(file_path->value());\n  file_path_str.clear();\n\n  if (!url.is_valid())\n    return false;\n\n#if defined(OS_WIN)\n  std::string path;\n  std::string host = url.host();\n  if (host.empty()) {\n    // URL contains no host, the path is the filename. In this case, the path\n    // will probably be preceeded with a slash, as in \"/C:/foo.txt\", so we\n    // trim out that here.\n    path = url.path();\n    size_t first_non_slash = path.find_first_not_of(\"/\\\\\");\n    if (first_non_slash != std::string::npos && first_non_slash > 0)\n      path.erase(0, first_non_slash);\n  } else {\n    // URL contains a host: this means it's UNC. We keep the preceeding slash\n    // on the path.\n    path = \"\\\\\\\\\";\n    path.append(host);\n    path.append(url.path());\n  }\n  std::replace(path.begin(), path.end(), '/', '\\\\');\n#else  // defined(OS_WIN)\n  // Firefox seems to ignore the \"host\" of a file url if there is one. That is,\n  // file://foo/bar.txt maps to /bar.txt.\n  // TODO(dhg): This should probably take into account UNCs which could\n  // include a hostname other than localhost or blank\n  std::string path = url.path();\n#endif  // !defined(OS_WIN)\n\n  if (path.empty())\n    return false;\n\n  // GURL stores strings as percent-encoded 8-bit, this will undo if possible.\n  path = UnescapeURLComponent(\n      path, UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);\n\n#if defined(OS_WIN)\n  if (base::IsStringUTF8(path)) {\n    file_path_str.assign(base::UTF8ToWide(path));\n    // We used to try too hard and see if |path| made up entirely of\n    // the 1st 256 characters in the Unicode was a zero-extended UTF-16.\n    // If so, we converted it to 'Latin-1' and checked if the result was UTF-8.\n    // If the check passed, we converted the result to UTF-8.\n    // Otherwise, we treated the result as the native OS encoding.\n    // However, that led to http://crbug.com/4619 and http://crbug.com/14153\n  } else {\n    // Not UTF-8, assume encoding is native codepage and we're done. We know we\n    // are giving the conversion function a nonempty string, and it may fail if\n    // the given string is not in the current encoding and give us an empty\n    // string back. We detect this and report failure.\n    file_path_str = base::SysNativeMBToWide(path);\n  }\n#else  // defined(OS_WIN)\n  // Collapse multiple path slashes into a single path slash.\n  std::string new_path;\n  do {\n    new_path = path;\n    base::ReplaceSubstringsAfterOffset(&new_path, 0, \"//\", \"/\");\n    path.swap(new_path);\n  } while (new_path != path);\n\n  file_path_str.assign(path);\n#endif  // !defined(OS_WIN)\n\n  return !file_path_str.empty();\n}",
        "func": "bool FileURLToFilePath(const GURL& url, base::FilePath* file_path) {\n  *file_path = base::FilePath();\n  base::FilePath::StringType& file_path_str =\n      const_cast<base::FilePath::StringType&>(file_path->value());\n  file_path_str.clear();\n\n  if (!url.is_valid())\n    return false;\n\n#if defined(OS_WIN)\n  std::string path;\n  std::string host = url.host();\n  if (host.empty()) {\n    // URL contains no host, the path is the filename. In this case, the path\n    // will probably be preceeded with a slash, as in \"/C:/foo.txt\", so we\n    // trim out that here.\n    path = url.path();\n    size_t first_non_slash = path.find_first_not_of(\"/\\\\\");\n    if (first_non_slash != std::string::npos && first_non_slash > 0)\n      path.erase(0, first_non_slash);\n  } else {\n    // URL contains a host: this means it's UNC. We keep the preceeding slash\n    // on the path.\n    path = \"\\\\\\\\\";\n    path.append(host);\n    path.append(url.path());\n  }\n  std::replace(path.begin(), path.end(), '/', '\\\\');\n#else  // defined(OS_WIN)\n  // Firefox seems to ignore the \"host\" of a file url if there is one. That is,\n  // file://foo/bar.txt maps to /bar.txt.\n  // TODO(dhg): This should probably take into account UNCs which could\n  // include a hostname other than localhost or blank\n  std::string path = url.path();\n#endif  // !defined(OS_WIN)\n\n  if (path.empty())\n    return false;\n\n  // GURL stores strings as percent-encoded 8-bit, this will undo if possible.\n  path = UnescapeURLComponent(\n      path, UnescapeRule::SPACES |\n                UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS);\n\n#if defined(OS_WIN)\n  if (base::IsStringUTF8(path)) {\n    file_path_str.assign(base::UTF8ToWide(path));\n    // We used to try too hard and see if |path| made up entirely of\n    // the 1st 256 characters in the Unicode was a zero-extended UTF-16.\n    // If so, we converted it to 'Latin-1' and checked if the result was UTF-8.\n    // If the check passed, we converted the result to UTF-8.\n    // Otherwise, we treated the result as the native OS encoding.\n    // However, that led to http://crbug.com/4619 and http://crbug.com/14153\n  } else {\n    // Not UTF-8, assume encoding is native codepage and we're done. We know we\n    // are giving the conversion function a nonempty string, and it may fail if\n    // the given string is not in the current encoding and give us an empty\n    // string back. We detect this and report failure.\n    file_path_str = base::SysNativeMBToWide(path);\n  }\n#else  // defined(OS_WIN)\n  // Collapse multiple path slashes into a single path slash.\n  std::string new_path;\n  do {\n    new_path = path;\n    base::ReplaceSubstringsAfterOffset(&new_path, 0, \"//\", \"/\");\n    path.swap(new_path);\n  } while (new_path != path);\n\n  file_path_str.assign(path);\n#endif  // !defined(OS_WIN)\n\n  return !file_path_str.empty();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,8 @@\n \n   // GURL stores strings as percent-encoded 8-bit, this will undo if possible.\n   path = UnescapeURLComponent(\n-      path, UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);\n+      path, UnescapeRule::SPACES |\n+                UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS);\n \n #if defined(OS_WIN)\n   if (base::IsStringUTF8(path)) {",
        "diff_line_info": {
            "deleted_lines": [
                "      path, UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);"
            ],
            "added_lines": [
                "      path, UnescapeRule::SPACES |",
                "                UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1671",
        "func_name": "chromium/UnescapeURLWithAdjustmentsImpl",
        "description": "Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and \\ (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/30408ae67a9f6aea074b2883ba861613f52bd246",
        "commit_title": "FileURLToFilePath:  Don't unescape '/' and '\\\\'.",
        "commit_text": " GURL leaves these escaped, and unescaping them in paths changes the meaning of the path.  Added two values to the UnescapeRule enumeration: PATH_SEPARATORS and URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS.  In followup CLs, I intend to replace all uses of URL_SPECIAL_CHARS, in favor of one or both the two new values, and eventually remove the value, as it's easily to use in an unsafe manner.    ",
        "func_before": "STR UnescapeURLWithAdjustmentsImpl(\n    const STR& escaped_text,\n    UnescapeRule::Type rules,\n    base::OffsetAdjuster::Adjustments* adjustments) {\n  if (adjustments)\n    adjustments->clear();\n  // Do not unescape anything, return the |escaped_text| text.\n  if (rules == UnescapeRule::NONE)\n    return escaped_text;\n\n  // The output of the unescaping is always smaller than the input, so we can\n  // reserve the input size to make sure we have enough buffer and don't have\n  // to allocate in the loop below.\n  STR result;\n  result.reserve(escaped_text.length());\n\n  // Locations of adjusted text.\n  for (size_t i = 0, max = escaped_text.size(); i < max; ++i) {\n    if (static_cast<unsigned char>(escaped_text[i]) >= 128) {\n      // Non ASCII character, append as is.\n      result.push_back(escaped_text[i]);\n      continue;\n    }\n\n    unsigned char first_byte;\n    if (UnescapeUnsignedCharAtIndex(escaped_text, i, &first_byte)) {\n      // Per http://tools.ietf.org/html/rfc3987#section-4.1, the following BiDi\n      // control characters are not allowed to appear unescaped in URLs:\n      //\n      // U+200E LEFT-TO-RIGHT MARK         (%E2%80%8E)\n      // U+200F RIGHT-TO-LEFT MARK         (%E2%80%8F)\n      // U+202A LEFT-TO-RIGHT EMBEDDING    (%E2%80%AA)\n      // U+202B RIGHT-TO-LEFT EMBEDDING    (%E2%80%AB)\n      // U+202C POP DIRECTIONAL FORMATTING (%E2%80%AC)\n      // U+202D LEFT-TO-RIGHT OVERRIDE     (%E2%80%AD)\n      // U+202E RIGHT-TO-LEFT OVERRIDE     (%E2%80%AE)\n      //\n      // Additionally, the Unicode Technical Report (TR9) as referenced by RFC\n      // 3987 above has since added some new BiDi control characters.\n      // http://www.unicode.org/reports/tr9\n      //\n      // U+061C ARABIC LETTER MARK         (%D8%9C)\n      // U+2066 LEFT-TO-RIGHT ISOLATE      (%E2%81%A6)\n      // U+2067 RIGHT-TO-LEFT ISOLATE      (%E2%81%A7)\n      // U+2068 FIRST STRONG ISOLATE       (%E2%81%A8)\n      // U+2069 POP DIRECTIONAL ISOLATE    (%E2%81%A9)\n      //\n      // The following spoofable characters are also banned, because they could\n      // be used to imitate parts of a web browser's UI.\n      //\n      // U+1F50F LOCK WITH INK PEN         (%F0%9F%94%8F)\n      // U+1F510 CLOSED LOCK WITH KEY      (%F0%9F%94%90)\n      // U+1F512 LOCK                      (%F0%9F%94%92)\n      // U+1F513 OPEN LOCK                 (%F0%9F%94%93)\n      //\n      // However, some schemes such as data: and file: need to parse the exact\n      // binary data when loading the URL. For that reason,\n      // SPOOFING_AND_CONTROL_CHARS allows unescaping BiDi control characters.\n      // DO NOT use SPOOFING_AND_CONTROL_CHARS if the parsed URL is going to be\n      // displayed in the UI.\n      if (!(rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)) {\n        if (HasArabicLanguageMarkAtIndex(escaped_text, first_byte, i)) {\n          // Keep Arabic Language Mark escaped.\n          result.append(escaped_text, i, 6);\n          i += 5;\n          continue;\n        }\n        if (HasThreeByteBidiControlCharAtIndex(escaped_text, first_byte, i)) {\n          // Keep BiDi control char escaped.\n          result.append(escaped_text, i, 9);\n          i += 8;\n          continue;\n        }\n        if (HasFourByteBannedCharAtIndex(escaped_text, first_byte, i)) {\n          // Keep banned char escaped.\n          result.append(escaped_text, i, 12);\n          i += 11;\n          continue;\n        }\n      }\n\n      if (first_byte >= 0x80 ||  // Unescape all high-bit characters.\n          // For 7-bit characters, the lookup table tells us all valid chars.\n          (kUrlUnescape[first_byte] ||\n           // ...and we allow some additional unescaping when flags are set.\n           (first_byte == ' ' && (rules & UnescapeRule::SPACES)) ||\n           // Allow any of the prohibited but non-control characters when\n           // we're doing \"special\" chars.\n           (first_byte > ' ' && (rules & UnescapeRule::URL_SPECIAL_CHARS)) ||\n           // Additionally allow non-display characters if requested.\n           (first_byte < ' ' &&\n            (rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {\n        // Use the unescaped version of the character.\n        if (adjustments)\n          adjustments->push_back(base::OffsetAdjuster::Adjustment(i, 3, 1));\n        result.push_back(first_byte);\n        i += 2;\n      } else {\n        // Keep escaped. Append a percent and we'll get the following two\n        // digits on the next loops through.\n        result.push_back('%');\n      }\n    } else if ((rules & UnescapeRule::REPLACE_PLUS_WITH_SPACE) &&\n               escaped_text[i] == '+') {\n      result.push_back(' ');\n    } else {\n      // Normal case for unescaped characters.\n      result.push_back(escaped_text[i]);\n    }\n  }\n\n  return result;\n}",
        "func": "STR UnescapeURLWithAdjustmentsImpl(\n    const STR& escaped_text,\n    UnescapeRule::Type rules,\n    base::OffsetAdjuster::Adjustments* adjustments) {\n  if (adjustments)\n    adjustments->clear();\n  // Do not unescape anything, return the |escaped_text| text.\n  if (rules == UnescapeRule::NONE)\n    return escaped_text;\n\n  // The output of the unescaping is always smaller than the input, so we can\n  // reserve the input size to make sure we have enough buffer and don't have\n  // to allocate in the loop below.\n  STR result;\n  result.reserve(escaped_text.length());\n\n  // Locations of adjusted text.\n  for (size_t i = 0, max = escaped_text.size(); i < max; ++i) {\n    if (static_cast<unsigned char>(escaped_text[i]) >= 128) {\n      // Non ASCII character, append as is.\n      result.push_back(escaped_text[i]);\n      continue;\n    }\n\n    unsigned char first_byte;\n    if (UnescapeUnsignedCharAtIndex(escaped_text, i, &first_byte)) {\n      // Per http://tools.ietf.org/html/rfc3987#section-4.1, the following BiDi\n      // control characters are not allowed to appear unescaped in URLs:\n      //\n      // U+200E LEFT-TO-RIGHT MARK         (%E2%80%8E)\n      // U+200F RIGHT-TO-LEFT MARK         (%E2%80%8F)\n      // U+202A LEFT-TO-RIGHT EMBEDDING    (%E2%80%AA)\n      // U+202B RIGHT-TO-LEFT EMBEDDING    (%E2%80%AB)\n      // U+202C POP DIRECTIONAL FORMATTING (%E2%80%AC)\n      // U+202D LEFT-TO-RIGHT OVERRIDE     (%E2%80%AD)\n      // U+202E RIGHT-TO-LEFT OVERRIDE     (%E2%80%AE)\n      //\n      // Additionally, the Unicode Technical Report (TR9) as referenced by RFC\n      // 3987 above has since added some new BiDi control characters.\n      // http://www.unicode.org/reports/tr9\n      //\n      // U+061C ARABIC LETTER MARK         (%D8%9C)\n      // U+2066 LEFT-TO-RIGHT ISOLATE      (%E2%81%A6)\n      // U+2067 RIGHT-TO-LEFT ISOLATE      (%E2%81%A7)\n      // U+2068 FIRST STRONG ISOLATE       (%E2%81%A8)\n      // U+2069 POP DIRECTIONAL ISOLATE    (%E2%81%A9)\n      //\n      // The following spoofable characters are also banned, because they could\n      // be used to imitate parts of a web browser's UI.\n      //\n      // U+1F50F LOCK WITH INK PEN         (%F0%9F%94%8F)\n      // U+1F510 CLOSED LOCK WITH KEY      (%F0%9F%94%90)\n      // U+1F512 LOCK                      (%F0%9F%94%92)\n      // U+1F513 OPEN LOCK                 (%F0%9F%94%93)\n      //\n      // However, some schemes such as data: and file: need to parse the exact\n      // binary data when loading the URL. For that reason,\n      // SPOOFING_AND_CONTROL_CHARS allows unescaping BiDi control characters.\n      // DO NOT use SPOOFING_AND_CONTROL_CHARS if the parsed URL is going to be\n      // displayed in the UI.\n      if (!(rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)) {\n        if (HasArabicLanguageMarkAtIndex(escaped_text, first_byte, i)) {\n          // Keep Arabic Language Mark escaped.\n          result.append(escaped_text, i, 6);\n          i += 5;\n          continue;\n        }\n        if (HasThreeByteBidiControlCharAtIndex(escaped_text, first_byte, i)) {\n          // Keep BiDi control char escaped.\n          result.append(escaped_text, i, 9);\n          i += 8;\n          continue;\n        }\n        if (HasFourByteBannedCharAtIndex(escaped_text, first_byte, i)) {\n          // Keep banned char escaped.\n          result.append(escaped_text, i, 12);\n          i += 11;\n          continue;\n        }\n      }\n\n      if (first_byte >= 0x80 ||  // Unescape all high-bit characters.\n          // For 7-bit characters, the lookup table tells us all valid chars.\n          (kUrlUnescape[first_byte] ||\n           // ...and we allow some additional unescaping when flags are set.\n           (first_byte == ' ' && (rules & UnescapeRule::SPACES)) ||\n           // Allow any of the prohibited but non-control characters when\n           // we're doing \"special\" chars.\n           ((first_byte == '/' || first_byte == '\\\\') &&\n            (rules & UnescapeRule::PATH_SEPARATORS)) ||\n           (first_byte > ' ' && first_byte != '/' && first_byte != '\\\\' &&\n            (rules & UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS)) ||\n           // Additionally allow non-display characters if requested.\n           (first_byte < ' ' &&\n            (rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {\n        // Use the unescaped version of the character.\n        if (adjustments)\n          adjustments->push_back(base::OffsetAdjuster::Adjustment(i, 3, 1));\n        result.push_back(first_byte);\n        i += 2;\n      } else {\n        // Keep escaped. Append a percent and we'll get the following two\n        // digits on the next loops through.\n        result.push_back('%');\n      }\n    } else if ((rules & UnescapeRule::REPLACE_PLUS_WITH_SPACE) &&\n               escaped_text[i] == '+') {\n      result.push_back(' ');\n    } else {\n      // Normal case for unescaped characters.\n      result.push_back(escaped_text[i]);\n    }\n  }\n\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -86,7 +86,10 @@\n            (first_byte == ' ' && (rules & UnescapeRule::SPACES)) ||\n            // Allow any of the prohibited but non-control characters when\n            // we're doing \"special\" chars.\n-           (first_byte > ' ' && (rules & UnescapeRule::URL_SPECIAL_CHARS)) ||\n+           ((first_byte == '/' || first_byte == '\\\\') &&\n+            (rules & UnescapeRule::PATH_SEPARATORS)) ||\n+           (first_byte > ' ' && first_byte != '/' && first_byte != '\\\\' &&\n+            (rules & UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS)) ||\n            // Additionally allow non-display characters if requested.\n            (first_byte < ' ' &&\n             (rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {",
        "diff_line_info": {
            "deleted_lines": [
                "           (first_byte > ' ' && (rules & UnescapeRule::URL_SPECIAL_CHARS)) ||"
            ],
            "added_lines": [
                "           ((first_byte == '/' || first_byte == '\\\\') &&",
                "            (rules & UnescapeRule::PATH_SEPARATORS)) ||",
                "           (first_byte > ' ' && first_byte != '/' && first_byte != '\\\\' &&",
                "            (rules & UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS)) ||"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9767",
        "func_name": "facebook/hhvm/extractFileTo",
        "description": "Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive.",
        "git_url": "https://github.com/facebook/hhvm/commit/65c95a01541dd2fbc9c978ac53bed235b5376686",
        "commit_title": "ZipArchive::extractTo bug 70350",
        "commit_text": " Summary:Don't allow upward directory traversal when extracting zip archive files.  Files in zip files with `..` or starting at main root `/` should be normalized to something where the file being extracted winds up within the directory or a subdirectory where the actual extraction is taking place.  http://git.php.net/?p=php-src.git;a=commit;h=f9c2bf73adb2ede0a486b0db466c264f2b27e0bb  Reviewed By: FBNeal  Differential Revision: D2798452  fb-gh-sync-id: 844549c93e011d1e991bb322bf85822246b04e30 shipit-source-id: 844549c93e011d1e991bb322bf85822246b04e30",
        "func_before": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n\n  return true;\n}",
        "func": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n\n  struct zip_stat zipStat;\n  // Verify the file to be extracted is actually in the zip file\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n\n  auto clean_file = file;\n  auto sep = std::string::npos;\n  // Normally would just use std::string::rfind here, but if we want to be\n  // consistent between Windows and Linux, even if techincally Linux won't use\n  // backslash for a separator, we are checking for both types.\n  int idx = file.length() - 1;\n  while (idx >= 0) {\n    if (FileUtil::isDirSeparator(file[idx])) {\n      sep = idx;\n      break;\n    }\n    idx--;\n  }\n  if (sep != std::string::npos) {\n    // make_relative_path so we do not try to put files or dirs in bad\n    // places. This securely \"cleans\" the file.\n    clean_file = make_relative_path(file);\n    std::string path = to + clean_file;\n    bool is_dir_only = true;\n    if (sep < file.length() - 1) { // not just a directory\n      auto clean_file_dir = HHVM_FN(dirname)(clean_file);\n      path = to + clean_file_dir.toCppString();\n      is_dir_only = false;\n    }\n\n    // Make sure the directory path to extract to exists or can be created\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n\n    // If we have a good directory to extract to above, we now check whether\n    // the \"file\" parameter passed in is a directory or actually a file.\n    if (is_dir_only) { // directory, like /usr/bin/\n      return true;\n    }\n    // otherwise file is actually a file, so we actually extract.\n  }\n\n  // We have ensured that clean_file will be added to a relative path by the\n  // time we get here.\n  to.append(clean_file);\n\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,22 +1,53 @@\n static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                           char* buf, size_t len) {\n-  auto sep = file.rfind('/');\n+\n+  struct zip_stat zipStat;\n+  // Verify the file to be extracted is actually in the zip file\n+  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n+    return false;\n+  }\n+\n+  auto clean_file = file;\n+  auto sep = std::string::npos;\n+  // Normally would just use std::string::rfind here, but if we want to be\n+  // consistent between Windows and Linux, even if techincally Linux won't use\n+  // backslash for a separator, we are checking for both types.\n+  int idx = file.length() - 1;\n+  while (idx >= 0) {\n+    if (FileUtil::isDirSeparator(file[idx])) {\n+      sep = idx;\n+      break;\n+    }\n+    idx--;\n+  }\n   if (sep != std::string::npos) {\n-    auto path = to + file.substr(0, sep);\n+    // make_relative_path so we do not try to put files or dirs in bad\n+    // places. This securely \"cleans\" the file.\n+    clean_file = make_relative_path(file);\n+    std::string path = to + clean_file;\n+    bool is_dir_only = true;\n+    if (sep < file.length() - 1) { // not just a directory\n+      auto clean_file_dir = HHVM_FN(dirname)(clean_file);\n+      path = to + clean_file_dir.toCppString();\n+      is_dir_only = false;\n+    }\n+\n+    // Make sure the directory path to extract to exists or can be created\n     if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n       return false;\n     }\n \n-    if (sep == file.length() - 1) {\n+    // If we have a good directory to extract to above, we now check whether\n+    // the \"file\" parameter passed in is a directory or actually a file.\n+    if (is_dir_only) { // directory, like /usr/bin/\n       return true;\n     }\n+    // otherwise file is actually a file, so we actually extract.\n   }\n \n-  to.append(file);\n-  struct zip_stat zipStat;\n-  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n-    return false;\n-  }\n+  // We have ensured that clean_file will be added to a relative path by the\n+  // time we get here.\n+  to.append(clean_file);\n \n   auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n   FAIL_IF_INVALID_PTR(zipFile);",
        "diff_line_info": {
            "deleted_lines": [
                "  auto sep = file.rfind('/');",
                "    auto path = to + file.substr(0, sep);",
                "    if (sep == file.length() - 1) {",
                "  to.append(file);",
                "  struct zip_stat zipStat;",
                "  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {",
                "    return false;",
                "  }"
            ],
            "added_lines": [
                "",
                "  struct zip_stat zipStat;",
                "  // Verify the file to be extracted is actually in the zip file",
                "  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {",
                "    return false;",
                "  }",
                "",
                "  auto clean_file = file;",
                "  auto sep = std::string::npos;",
                "  // Normally would just use std::string::rfind here, but if we want to be",
                "  // consistent between Windows and Linux, even if techincally Linux won't use",
                "  // backslash for a separator, we are checking for both types.",
                "  int idx = file.length() - 1;",
                "  while (idx >= 0) {",
                "    if (FileUtil::isDirSeparator(file[idx])) {",
                "      sep = idx;",
                "      break;",
                "    }",
                "    idx--;",
                "  }",
                "    // make_relative_path so we do not try to put files or dirs in bad",
                "    // places. This securely \"cleans\" the file.",
                "    clean_file = make_relative_path(file);",
                "    std::string path = to + clean_file;",
                "    bool is_dir_only = true;",
                "    if (sep < file.length() - 1) { // not just a directory",
                "      auto clean_file_dir = HHVM_FN(dirname)(clean_file);",
                "      path = to + clean_file_dir.toCppString();",
                "      is_dir_only = false;",
                "    }",
                "",
                "    // Make sure the directory path to extract to exists or can be created",
                "    // If we have a good directory to extract to above, we now check whether",
                "    // the \"file\" parameter passed in is a directory or actually a file.",
                "    if (is_dir_only) { // directory, like /usr/bin/",
                "    // otherwise file is actually a file, so we actually extract.",
                "  // We have ensured that clean_file will be added to a relative path by the",
                "  // time we get here.",
                "  to.append(clean_file);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9767",
        "func_name": "php/php-src/php_zip_parse_options",
        "description": "Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive.",
        "git_url": "https://github.com/php/php-src/commit/f9c2bf73adb2ede0a486b0db466c264f2b27e0bb",
        "commit_title": "Fixed bug #70350: ZipArchive::extractTo allows for directory traversal when creating directories",
        "commit_text": "",
        "func_before": "static int php_zip_parse_options(zval *options, long *remove_all_path, \n\tchar **remove_path, int *remove_path_len, char **add_path, int *add_path_len TSRMLS_DC) /* {{{ */\n{\n\tzval **option;\n\tif (zend_hash_find(HASH_OF(options), \"remove_all_path\", sizeof(\"remove_all_path\"), (void **)&option) == SUCCESS) {\n\t\tlong opt;\n\t\tif (Z_TYPE_PP(option) != IS_LONG) {\n\t\t\tzval tmp = **option;\n\t\t\tzval_copy_ctor(&tmp);\n\t\t\tconvert_to_long(&tmp);\n\t\t\topt = Z_LVAL(tmp);\n\t\t} else {\n\t\t\topt = Z_LVAL_PP(option);\n\t\t}\n\t\t*remove_all_path = opt;\n\t}\n\n\t/* If I add more options, it would make sense to create a nice static struct and loop over it. */\n\tif (zend_hash_find(HASH_OF(options), \"remove_path\", sizeof(\"remove_path\"), (void **)&option) == SUCCESS) {\n\t\tif (Z_TYPE_PP(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Empty string given as remove_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path string is too long (max: %i, %i given)\", \n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_PP(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*remove_path_len = Z_STRLEN_PP(option); \n\t\t*remove_path = Z_STRVAL_PP(option);\n\t}\n\n\tif (zend_hash_find(HASH_OF(options), \"add_path\", sizeof(\"add_path\"), (void **)&option) == SUCCESS) {\n\t\tif (Z_TYPE_PP(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Empty string given as the add_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\", \n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_PP(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*add_path_len = Z_STRLEN_PP(option); \n\t\t*add_path = Z_STRVAL_PP(option);\n\t}\n\treturn 1;\n}",
        "func": "static int php_zip_parse_options(zval *options, long *remove_all_path,\n\tchar **remove_path, int *remove_path_len, char **add_path, int *add_path_len TSRMLS_DC) /* {{{ */\n{\n\tzval **option;\n\tif (zend_hash_find(HASH_OF(options), \"remove_all_path\", sizeof(\"remove_all_path\"), (void **)&option) == SUCCESS) {\n\t\tlong opt;\n\t\tif (Z_TYPE_PP(option) != IS_LONG) {\n\t\t\tzval tmp = **option;\n\t\t\tzval_copy_ctor(&tmp);\n\t\t\tconvert_to_long(&tmp);\n\t\t\topt = Z_LVAL(tmp);\n\t\t} else {\n\t\t\topt = Z_LVAL_PP(option);\n\t\t}\n\t\t*remove_all_path = opt;\n\t}\n\n\t/* If I add more options, it would make sense to create a nice static struct and loop over it. */\n\tif (zend_hash_find(HASH_OF(options), \"remove_path\", sizeof(\"remove_path\"), (void **)&option) == SUCCESS) {\n\t\tif (Z_TYPE_PP(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Empty string given as remove_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path string is too long (max: %i, %i given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_PP(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*remove_path_len = Z_STRLEN_PP(option);\n\t\t*remove_path = Z_STRVAL_PP(option);\n\t}\n\n\tif (zend_hash_find(HASH_OF(options), \"add_path\", sizeof(\"add_path\"), (void **)&option) == SUCCESS) {\n\t\tif (Z_TYPE_PP(option) != IS_STRING) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path option expected to be a string\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Empty string given as the add_path option\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (Z_STRLEN_PP(option) >= MAXPATHLEN) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_PP(option));\n\t\t\treturn -1;\n\t\t}\n\t\t*add_path_len = Z_STRLEN_PP(option);\n\t\t*add_path = Z_STRVAL_PP(option);\n\t}\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int php_zip_parse_options(zval *options, long *remove_all_path, \n+static int php_zip_parse_options(zval *options, long *remove_all_path,\n \tchar **remove_path, int *remove_path_len, char **add_path, int *add_path_len TSRMLS_DC) /* {{{ */\n {\n \tzval **option;\n@@ -28,11 +28,11 @@\n \t\t}\n \n \t\tif (Z_STRLEN_PP(option) >= MAXPATHLEN) {\n-\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path string is too long (max: %i, %i given)\", \n+\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path string is too long (max: %i, %i given)\",\n \t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_PP(option));\n \t\t\treturn -1;\n \t\t}\n-\t\t*remove_path_len = Z_STRLEN_PP(option); \n+\t\t*remove_path_len = Z_STRLEN_PP(option);\n \t\t*remove_path = Z_STRVAL_PP(option);\n \t}\n \n@@ -48,11 +48,11 @@\n \t\t}\n \n \t\tif (Z_STRLEN_PP(option) >= MAXPATHLEN) {\n-\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\", \n+\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\",\n \t\t\t\t\t\tMAXPATHLEN - 1, Z_STRLEN_PP(option));\n \t\t\treturn -1;\n \t\t}\n-\t\t*add_path_len = Z_STRLEN_PP(option); \n+\t\t*add_path_len = Z_STRLEN_PP(option);\n \t\t*add_path = Z_STRVAL_PP(option);\n \t}\n \treturn 1;",
        "diff_line_info": {
            "deleted_lines": [
                "static int php_zip_parse_options(zval *options, long *remove_all_path, ",
                "\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path string is too long (max: %i, %i given)\", ",
                "\t\t*remove_path_len = Z_STRLEN_PP(option); ",
                "\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\", ",
                "\t\t*add_path_len = Z_STRLEN_PP(option); "
            ],
            "added_lines": [
                "static int php_zip_parse_options(zval *options, long *remove_all_path,",
                "\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"remove_path string is too long (max: %i, %i given)\",",
                "\t\t*remove_path_len = Z_STRLEN_PP(option);",
                "\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\",",
                "\t\t*add_path_len = Z_STRLEN_PP(option);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9767",
        "func_name": "php/php-src/php_zip_pcre",
        "description": "Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive.",
        "git_url": "https://github.com/php/php-src/commit/f9c2bf73adb2ede0a486b0db466c264f2b27e0bb",
        "commit_title": "Fixed bug #70350: ZipArchive::extractTo allows for directory traversal when creating directories",
        "commit_text": "",
        "func_before": "int php_zip_pcre(char *regexp, int regexp_len, char *path, int path_len, zval *return_value TSRMLS_DC) /* {{{ */\n{\n#ifdef ZTS\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n\tchar work_path[MAXPATHLEN];\n\tchar *result;\n#endif\n\tint files_cnt;\n\tchar **namelist;\n\n#ifdef ZTS \n\tif (!IS_ABSOLUTE_PATH(path, path_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\t\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*path)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_path, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, path);\n\t\tpath = work_path;\n\t} \n#endif\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(path)) {\n\t\treturn -1;\n\t}\n\n\tfiles_cnt = php_stream_scandir(path, &namelist, NULL, (void *) php_stream_dirent_alphasort);\n\n\tif (files_cnt > 0) {\n\t\tpcre       *re = NULL;\n\t\tpcre_extra *pcre_extra = NULL;\n\t\tint preg_options = 0, i;\n\n\t\tre = pcre_get_compiled_regex(regexp, &pcre_extra, &preg_options TSRMLS_CC);\n\t\tif (!re) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid expression\");\n\t\t\treturn -1;\t\n\t\t}\n\n\t\tarray_init(return_value);\n\n\t\t/* only the files, directories are ignored */\n\t\tfor (i = 0; i < files_cnt; i++) {\n\t\t\tstruct stat s;\n\t\t\tchar   fullpath[MAXPATHLEN];\n\t\t\tint    ovector[3];\n\t\t\tint    matches;\n\t\t\tint    namelist_len = strlen(namelist[i]);\n\n\t\t\t\n\t\t\tif ((namelist_len == 1 && namelist[i][0] == '.') ||\n\t\t\t\t(namelist_len == 2 && namelist[i][0] == '.' && namelist[i][1] == '.')) {\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((path_len + namelist_len + 1) >= MAXPATHLEN) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\", \n\t\t\t\t\t\tMAXPATHLEN - 1, (path_len + namelist_len + 1));\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsnprintf(fullpath, MAXPATHLEN, \"%s%c%s\", path, DEFAULT_SLASH, namelist[i]);\n\n\t\t\tif (0 != VCWD_STAT(fullpath, &s)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot read <%s>\", fullpath);\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR == (s.st_mode & S_IFMT)) {\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatches = pcre_exec(re, NULL, namelist[i], strlen(namelist[i]), 0, 0, ovector, 3);\n\t\t\t/* 0 means that the vector is too small to hold all the captured substring offsets */\n\t\t\tif (matches < 0) {\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tcontinue;\t\n\t\t\t}\n\n\t\t\tadd_next_index_string(return_value, fullpath, 1);\n\t\t\tefree(namelist[i]);\n\t\t}\n\t\tefree(namelist);\n\t}\n\treturn files_cnt;\n}",
        "func": "int php_zip_pcre(char *regexp, int regexp_len, char *path, int path_len, zval *return_value TSRMLS_DC) /* {{{ */\n{\n#ifdef ZTS\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n\tchar work_path[MAXPATHLEN];\n\tchar *result;\n#endif\n\tint files_cnt;\n\tchar **namelist;\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(path, path_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*path)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_path, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, path);\n\t\tpath = work_path;\n\t}\n#endif\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(path)) {\n\t\treturn -1;\n\t}\n\n\tfiles_cnt = php_stream_scandir(path, &namelist, NULL, (void *) php_stream_dirent_alphasort);\n\n\tif (files_cnt > 0) {\n\t\tpcre       *re = NULL;\n\t\tpcre_extra *pcre_extra = NULL;\n\t\tint preg_options = 0, i;\n\n\t\tre = pcre_get_compiled_regex(regexp, &pcre_extra, &preg_options TSRMLS_CC);\n\t\tif (!re) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid expression\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray_init(return_value);\n\n\t\t/* only the files, directories are ignored */\n\t\tfor (i = 0; i < files_cnt; i++) {\n\t\t\tstruct stat s;\n\t\t\tchar   fullpath[MAXPATHLEN];\n\t\t\tint    ovector[3];\n\t\t\tint    matches;\n\t\t\tint    namelist_len = strlen(namelist[i]);\n\n\n\t\t\tif ((namelist_len == 1 && namelist[i][0] == '.') ||\n\t\t\t\t(namelist_len == 2 && namelist[i][0] == '.' && namelist[i][1] == '.')) {\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((path_len + namelist_len + 1) >= MAXPATHLEN) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (path_len + namelist_len + 1));\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsnprintf(fullpath, MAXPATHLEN, \"%s%c%s\", path, DEFAULT_SLASH, namelist[i]);\n\n\t\t\tif (0 != VCWD_STAT(fullpath, &s)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot read <%s>\", fullpath);\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR == (s.st_mode & S_IFMT)) {\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatches = pcre_exec(re, NULL, namelist[i], strlen(namelist[i]), 0, 0, ovector, 3);\n\t\t\t/* 0 means that the vector is too small to hold all the captured substring offsets */\n\t\t\tif (matches < 0) {\n\t\t\t\tefree(namelist[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tadd_next_index_string(return_value, fullpath, 1);\n\t\t\tefree(namelist[i]);\n\t\t}\n\t\tefree(namelist);\n\t}\n\treturn files_cnt;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,9 +9,9 @@\n \tint files_cnt;\n \tchar **namelist;\n \n-#ifdef ZTS \n+#ifdef ZTS\n \tif (!IS_ABSOLUTE_PATH(path, path_len)) {\n-\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\t\n+\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n \t\tif (!result) {\n \t\t\tcwd[0] = '\\0';\n \t\t}\n@@ -24,7 +24,7 @@\n \n \t\tsnprintf(work_path, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, path);\n \t\tpath = work_path;\n-\t} \n+\t}\n #endif\n \n \tif (ZIP_OPENBASEDIR_CHECKPATH(path)) {\n@@ -41,7 +41,7 @@\n \t\tre = pcre_get_compiled_regex(regexp, &pcre_extra, &preg_options TSRMLS_CC);\n \t\tif (!re) {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid expression\");\n-\t\t\treturn -1;\t\n+\t\t\treturn -1;\n \t\t}\n \n \t\tarray_init(return_value);\n@@ -54,7 +54,7 @@\n \t\t\tint    matches;\n \t\t\tint    namelist_len = strlen(namelist[i]);\n \n-\t\t\t\n+\n \t\t\tif ((namelist_len == 1 && namelist[i][0] == '.') ||\n \t\t\t\t(namelist_len == 2 && namelist[i][0] == '.' && namelist[i][1] == '.')) {\n \t\t\t\tefree(namelist[i]);\n@@ -62,7 +62,7 @@\n \t\t\t}\n \n \t\t\tif ((path_len + namelist_len + 1) >= MAXPATHLEN) {\n-\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\", \n+\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\",\n \t\t\t\t\t\tMAXPATHLEN - 1, (path_len + namelist_len + 1));\n \t\t\t\tefree(namelist[i]);\n \t\t\t\tbreak;\n@@ -85,7 +85,7 @@\n \t\t\t/* 0 means that the vector is too small to hold all the captured substring offsets */\n \t\t\tif (matches < 0) {\n \t\t\t\tefree(namelist[i]);\n-\t\t\t\tcontinue;\t\n+\t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tadd_next_index_string(return_value, fullpath, 1);",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef ZTS ",
                "\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\t",
                "\t} ",
                "\t\t\treturn -1;\t",
                "\t\t\t",
                "\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\", ",
                "\t\t\t\tcontinue;\t"
            ],
            "added_lines": [
                "#ifdef ZTS",
                "\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);",
                "\t}",
                "\t\t\treturn -1;",
                "",
                "\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"add_path string too long (max: %i, %i given)\",",
                "\t\t\t\tcontinue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9767",
        "func_name": "php/php-src/php_zip_get_property_ptr_ptr",
        "description": "Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive.",
        "git_url": "https://github.com/php/php-src/commit/f9c2bf73adb2ede0a486b0db466c264f2b27e0bb",
        "commit_title": "Fixed bug #70350: ZipArchive::extractTo allows for directory traversal when creating directories",
        "commit_text": "",
        "func_before": "static zval **php_zip_get_property_ptr_ptr(zval *object, zval *member, const zend_literal *key TSRMLS_DC) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzval **retval = NULL;\n\n\tzip_prop_handler *hnd;\n\tzend_object_handlers *std_hnd;\n\tint ret;\n\n\tif (member->type != IS_STRING) {\n\t\ttmp_member = *member;\n\t\tzval_copy_ctor(&tmp_member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tkey = NULL;\n\t}\n\n\tret = FAILURE;\n\tobj = (ze_zip_object *)zend_objects_get_address(object TSRMLS_CC);\n\n\tif (obj->prop_handler != NULL) {\n\t\tif (key) {\n\t\t\tret = zend_hash_quick_find(obj->prop_handler, Z_STRVAL_P(member), Z_STRLEN_P(member)+1, key->hash_value, (void **) &hnd);\n\t\t} else {\t\n\t\t\tret = zend_hash_find(obj->prop_handler, Z_STRVAL_P(member), Z_STRLEN_P(member)+1, (void **) &hnd);\n\t\t}\n\t}\n\n\n\tif (ret == FAILURE) {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->get_property_ptr_ptr(object, member, key TSRMLS_CC);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\treturn retval;\n}",
        "func": "static zval **php_zip_get_property_ptr_ptr(zval *object, zval *member, const zend_literal *key TSRMLS_DC) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzval **retval = NULL;\n\n\tzip_prop_handler *hnd;\n\tzend_object_handlers *std_hnd;\n\tint ret;\n\n\tif (member->type != IS_STRING) {\n\t\ttmp_member = *member;\n\t\tzval_copy_ctor(&tmp_member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tkey = NULL;\n\t}\n\n\tret = FAILURE;\n\tobj = (ze_zip_object *)zend_objects_get_address(object TSRMLS_CC);\n\n\tif (obj->prop_handler != NULL) {\n\t\tif (key) {\n\t\t\tret = zend_hash_quick_find(obj->prop_handler, Z_STRVAL_P(member), Z_STRLEN_P(member)+1, key->hash_value, (void **) &hnd);\n\t\t} else {\n\t\t\tret = zend_hash_find(obj->prop_handler, Z_STRVAL_P(member), Z_STRLEN_P(member)+1, (void **) &hnd);\n\t\t}\n\t}\n\n\n\tif (ret == FAILURE) {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->get_property_ptr_ptr(object, member, key TSRMLS_CC);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n \tif (obj->prop_handler != NULL) {\n \t\tif (key) {\n \t\t\tret = zend_hash_quick_find(obj->prop_handler, Z_STRVAL_P(member), Z_STRLEN_P(member)+1, key->hash_value, (void **) &hnd);\n-\t\t} else {\t\n+\t\t} else {\n \t\t\tret = zend_hash_find(obj->prop_handler, Z_STRVAL_P(member), Z_STRLEN_P(member)+1, (void **) &hnd);\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t} else {\t"
            ],
            "added_lines": [
                "\t\t} else {"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9767",
        "func_name": "php/php-src/php_zip_add_from_pattern",
        "description": "Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive.",
        "git_url": "https://github.com/php/php-src/commit/f9c2bf73adb2ede0a486b0db466c264f2b27e0bb",
        "commit_title": "Fixed bug #70350: ZipArchive::extractTo allows for directory traversal when creating directories",
        "commit_text": "",
        "func_before": "static void php_zip_add_from_pattern(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tchar *pattern;\n\tchar *path = NULL;\n\tchar *remove_path = NULL;\n\tchar *add_path = NULL;\n\tint pattern_len, add_path_len = 0, remove_path_len = 0, path_len = 0;\n\tlong remove_all_path = 0;\n\tlong flags = 0;\n\tzval *options = NULL;\n\tint found;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\t/* 1 == glob, 2==pcre */\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|la\", \n\t\t\t\t\t&pattern, &pattern_len, &flags, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|sa\", \n\t\t\t\t\t&pattern, &pattern_len, &path, &path_len, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (pattern_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Empty string as pattern\");\n\t\tRETURN_FALSE;\n\t}\n\tif (options && (php_zip_parse_options(options, &remove_all_path, &remove_path, &remove_path_len,\n\t\t\t&add_path, &add_path_len TSRMLS_CC) < 0)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (remove_path && remove_path_len > 1 && (remove_path[strlen(remove_path) - 1] == '/' ||\n\t\tremove_path[strlen(remove_path) - 1] == '\\\\')) {\n\t\tremove_path[strlen(remove_path) - 1] = '\\0';\n\t}\n\n\tif (type == 1) {\n\t\tfound = php_zip_glob(pattern, pattern_len, flags, return_value TSRMLS_CC);\n\t} else {\n\t\tfound = php_zip_pcre(pattern, pattern_len, path, path_len, return_value TSRMLS_CC);\n\t}\n\n\tif (found > 0) {\n\t\tint i;\n\t\tzval **zval_file = NULL;\n\n\t\tfor (i = 0; i < found; i++) {\n\t\t\tchar *file, *file_stripped, *entry_name;\n\t\t\tsize_t entry_name_len, file_stripped_len;\n\t\t\tchar entry_name_buf[MAXPATHLEN];\n\t\t\tchar *basename = NULL;\n\n\t\t\tif (zend_hash_index_find(Z_ARRVAL_P(return_value), i, (void **) &zval_file) == SUCCESS) {\n\t\t\t\tfile = Z_STRVAL_PP(zval_file);\n\t\t\t\tif (remove_all_path) {\n\t\t\t\t\tphp_basename(Z_STRVAL_PP(zval_file), Z_STRLEN_PP(zval_file), NULL, 0,\n\t\t\t\t\t\t\t\t\t&basename, (size_t *)&file_stripped_len TSRMLS_CC);\n\t\t\t\t\tfile_stripped = basename;\n\t\t\t\t} else if (remove_path && strstr(Z_STRVAL_PP(zval_file), remove_path) != NULL) {\n\t\t\t\t\tfile_stripped = Z_STRVAL_PP(zval_file) + remove_path_len + 1;\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_PP(zval_file) - remove_path_len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tfile_stripped = Z_STRVAL_PP(zval_file);\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_PP(zval_file);\n\t\t\t\t}\n\n\t\t\t\tif (add_path) {\n\t\t\t\t\tif ((add_path_len + file_stripped_len) > MAXPATHLEN) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Entry name too long (max: %d, %ld given)\", \n\t\t\t\t\t\tMAXPATHLEN - 1, (add_path_len + file_stripped_len));\n\t\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s%s\", add_path, file_stripped);\n\t\t\t\t\tentry_name = entry_name_buf; \n\t\t\t\t\tentry_name_len = strlen(entry_name);\n\t\t\t\t} else {\n\t\t\t\t\tentry_name = Z_STRVAL_PP(zval_file);\n\t\t\t\t\tentry_name_len = Z_STRLEN_PP(zval_file);\n\t\t\t\t}\n\t\t\t\tif (basename) {\n\t\t\t\t\tefree(basename);\n\t\t\t\t\tbasename = NULL;\n\t\t\t\t}\n\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_PP(zval_file), Z_STRLEN_PP(zval_file), \n\t\t\t\t\tentry_name, entry_name_len, 0, 0 TSRMLS_CC) < 0) {\n\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
        "func": "static void php_zip_add_from_pattern(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tchar *pattern;\n\tchar *path = NULL;\n\tchar *remove_path = NULL;\n\tchar *add_path = NULL;\n\tint pattern_len, add_path_len = 0, remove_path_len = 0, path_len = 0;\n\tlong remove_all_path = 0;\n\tlong flags = 0;\n\tzval *options = NULL;\n\tint found;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\t/* 1 == glob, 2==pcre */\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|la\",\n\t\t\t\t\t&pattern, &pattern_len, &flags, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|sa\",\n\t\t\t\t\t&pattern, &pattern_len, &path, &path_len, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (pattern_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Empty string as pattern\");\n\t\tRETURN_FALSE;\n\t}\n\tif (options && (php_zip_parse_options(options, &remove_all_path, &remove_path, &remove_path_len,\n\t\t\t&add_path, &add_path_len TSRMLS_CC) < 0)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (remove_path && remove_path_len > 1 && (remove_path[strlen(remove_path) - 1] == '/' ||\n\t\tremove_path[strlen(remove_path) - 1] == '\\\\')) {\n\t\tremove_path[strlen(remove_path) - 1] = '\\0';\n\t}\n\n\tif (type == 1) {\n\t\tfound = php_zip_glob(pattern, pattern_len, flags, return_value TSRMLS_CC);\n\t} else {\n\t\tfound = php_zip_pcre(pattern, pattern_len, path, path_len, return_value TSRMLS_CC);\n\t}\n\n\tif (found > 0) {\n\t\tint i;\n\t\tzval **zval_file = NULL;\n\n\t\tfor (i = 0; i < found; i++) {\n\t\t\tchar *file, *file_stripped, *entry_name;\n\t\t\tsize_t entry_name_len, file_stripped_len;\n\t\t\tchar entry_name_buf[MAXPATHLEN];\n\t\t\tchar *basename = NULL;\n\n\t\t\tif (zend_hash_index_find(Z_ARRVAL_P(return_value), i, (void **) &zval_file) == SUCCESS) {\n\t\t\t\tfile = Z_STRVAL_PP(zval_file);\n\t\t\t\tif (remove_all_path) {\n\t\t\t\t\tphp_basename(Z_STRVAL_PP(zval_file), Z_STRLEN_PP(zval_file), NULL, 0,\n\t\t\t\t\t\t\t\t\t&basename, (size_t *)&file_stripped_len TSRMLS_CC);\n\t\t\t\t\tfile_stripped = basename;\n\t\t\t\t} else if (remove_path && strstr(Z_STRVAL_PP(zval_file), remove_path) != NULL) {\n\t\t\t\t\tfile_stripped = Z_STRVAL_PP(zval_file) + remove_path_len + 1;\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_PP(zval_file) - remove_path_len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tfile_stripped = Z_STRVAL_PP(zval_file);\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_PP(zval_file);\n\t\t\t\t}\n\n\t\t\t\tif (add_path) {\n\t\t\t\t\tif ((add_path_len + file_stripped_len) > MAXPATHLEN) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Entry name too long (max: %d, %ld given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (add_path_len + file_stripped_len));\n\t\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s%s\", add_path, file_stripped);\n\t\t\t\t\tentry_name = entry_name_buf;\n\t\t\t\t\tentry_name_len = strlen(entry_name);\n\t\t\t\t} else {\n\t\t\t\t\tentry_name = Z_STRVAL_PP(zval_file);\n\t\t\t\t\tentry_name_len = Z_STRLEN_PP(zval_file);\n\t\t\t\t}\n\t\t\t\tif (basename) {\n\t\t\t\t\tefree(basename);\n\t\t\t\t\tbasename = NULL;\n\t\t\t\t}\n\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_PP(zval_file), Z_STRLEN_PP(zval_file),\n\t\t\t\t\tentry_name, entry_name_len, 0, 0 TSRMLS_CC) < 0) {\n\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,12 +19,12 @@\n \tZIP_FROM_OBJECT(intern, this);\n \t/* 1 == glob, 2==pcre */\n \tif (type == 1) {\n-\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|la\", \n+\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|la\",\n \t\t\t\t\t&pattern, &pattern_len, &flags, &options) == FAILURE) {\n \t\t\treturn;\n \t\t}\n \t} else {\n-\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|sa\", \n+\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|sa\",\n \t\t\t\t\t&pattern, &pattern_len, &path, &path_len, &options) == FAILURE) {\n \t\t\treturn;\n \t\t}\n@@ -76,14 +76,14 @@\n \n \t\t\t\tif (add_path) {\n \t\t\t\t\tif ((add_path_len + file_stripped_len) > MAXPATHLEN) {\n-\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Entry name too long (max: %d, %ld given)\", \n+\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Entry name too long (max: %d, %ld given)\",\n \t\t\t\t\t\tMAXPATHLEN - 1, (add_path_len + file_stripped_len));\n \t\t\t\t\t\tzval_dtor(return_value);\n \t\t\t\t\t\tRETURN_FALSE;\n \t\t\t\t\t}\n \n \t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s%s\", add_path, file_stripped);\n-\t\t\t\t\tentry_name = entry_name_buf; \n+\t\t\t\t\tentry_name = entry_name_buf;\n \t\t\t\t\tentry_name_len = strlen(entry_name);\n \t\t\t\t} else {\n \t\t\t\t\tentry_name = Z_STRVAL_PP(zval_file);\n@@ -93,7 +93,7 @@\n \t\t\t\t\tefree(basename);\n \t\t\t\t\tbasename = NULL;\n \t\t\t\t}\n-\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_PP(zval_file), Z_STRLEN_PP(zval_file), \n+\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_PP(zval_file), Z_STRLEN_PP(zval_file),\n \t\t\t\t\tentry_name, entry_name_len, 0, 0 TSRMLS_CC) < 0) {\n \t\t\t\t\tzval_dtor(return_value);\n \t\t\t\t\tRETURN_FALSE;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|la\", ",
                "\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|sa\", ",
                "\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Entry name too long (max: %d, %ld given)\", ",
                "\t\t\t\t\tentry_name = entry_name_buf; ",
                "\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_PP(zval_file), Z_STRLEN_PP(zval_file), "
            ],
            "added_lines": [
                "\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|la\",",
                "\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|sa\",",
                "\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Entry name too long (max: %d, %ld given)\",",
                "\t\t\t\t\tentry_name = entry_name_buf;",
                "\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_PP(zval_file), Z_STRLEN_PP(zval_file),"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9767",
        "func_name": "php/php-src/php_zip_extract_file",
        "description": "Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive.",
        "git_url": "https://github.com/php/php-src/commit/f9c2bf73adb2ede0a486b0db466c264f2b27e0bb",
        "commit_title": "Fixed bug #70350: ZipArchive::extractTo allows for directory traversal when creating directories",
        "commit_text": "",
        "func_before": "static int php_zip_extract_file(struct zip * za, char *dest, char *file, int file_len TSRMLS_DC)\n{\n\tphp_stream_statbuf ssb;\n\tstruct zip_file *zf;\n\tstruct zip_stat sb;\n\tchar b[8192];\n\tint n, len, ret;\n\tphp_stream *stream;\n\tchar *fullpath;\n\tchar *file_dirname_fullpath;\n\tchar file_dirname[MAXPATHLEN];\n\tsize_t dir_len;\n\tchar *file_basename;\n\tsize_t file_basename_len;\n\tint is_dir_only = 0;\n\tchar *path_cleaned;\n\tsize_t path_cleaned_len;\n\tcwd_state new_state;\n\n\tnew_state.cwd = (char*)malloc(1);\n\tnew_state.cwd[0] = '\\0';\n\tnew_state.cwd_length = 0;\n\n\t/* Clean/normlize the path and then transform any path (absolute or relative)\n\t\t to a path relative to cwd (../../mydir/foo.txt > mydir/foo.txt)\n\t */\n\tvirtual_file_ex(&new_state, file, NULL, CWD_EXPAND TSRMLS_CC);\n\tpath_cleaned =  php_zip_make_relative_path(new_state.cwd, new_state.cwd_length);\n\tif(!path_cleaned) {\n\t\treturn 0;\n\t}\n\tpath_cleaned_len = strlen(path_cleaned);\n\n\tif (path_cleaned_len >= MAXPATHLEN || zip_stat(za, file, 0, &sb) != 0) {\n\t\treturn 0;\n\t}\n\n\t/* it is a directory only, see #40228 */\n\tif (path_cleaned_len > 1 && IS_SLASH(path_cleaned[path_cleaned_len - 1])) {\n\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file);\n\t\tis_dir_only = 1;\n\t} else {\n\t\tmemcpy(file_dirname, path_cleaned, path_cleaned_len);\n\t\tdir_len = php_dirname(file_dirname, path_cleaned_len);\n\n\t\tif (dir_len <= 0 || (dir_len == 1 && file_dirname[0] == '.')) {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s\", dest);\n\t\t} else {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file_dirname);\n\t\t}\n\n\t\tphp_basename(path_cleaned, path_cleaned_len, NULL, 0, &file_basename, (size_t *)&file_basename_len TSRMLS_CC);\n\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(file_dirname_fullpath)) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tefree(file_basename);\n\t\t\tfree(new_state.cwd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* let see if the path already exists */\n\tif (php_stream_stat_path_ex(file_dirname_fullpath, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\n#if defined(PHP_WIN32) && (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION == 1)\n\t\tchar *e;\n\t\te = file_dirname_fullpath;\n\t\twhile (*e) {\n\t\t\t   if (*e == '/') {\n\t\t\t\t\t   *e = DEFAULT_SLASH;\n\t\t\t   }\n\t\t\t   e++;\n\t\t}\n#endif\n\n\t\tret = php_stream_mkdir(file_dirname_fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE|REPORT_ERRORS, NULL);\n\t\tif (!ret) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tif (!is_dir_only) {\n\t\t\t\tefree(file_basename);\n\t\t\t\tfree(new_state.cwd);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* it is a standalone directory, job done */\n\tif (is_dir_only) {\n\t\tefree(file_dirname_fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn 1;\n\t}\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", file_dirname_fullpath, file_basename);\n\tif (!len) {\n\t\tefree(file_dirname_fullpath);\n\t\tefree(file_basename);\n\t\tfree(new_state.cwd);\n\t\treturn 0;\n\t} else if (len > MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Full extraction path exceed MAXPATHLEN (%i)\", MAXPATHLEN);\n\t\tefree(file_dirname_fullpath);\n\t\tefree(file_basename);\n\t\tfree(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\t/* check again the full path, not sure if it\n\t * is required, does a file can have a different\n\t * safemode status as its parent folder?\n\t */\n\tif (ZIP_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tefree(fullpath);\n\t\tefree(file_dirname_fullpath);\n\t\tefree(file_basename);\n\t\tfree(new_state.cwd);\n\t\treturn 0;\n\t}\n\n#if PHP_API_VERSION < 20100412\n\tstream = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS|ENFORCE_SAFE_MODE, NULL);\n#else\n\tstream = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n#endif\n\n\tif (stream == NULL) {\n\t\tn = -1;\n\t\tgoto done;\n\t}\n\n\tzf = zip_fopen(za, file, 0);\n\tif (zf == NULL) {\n\t\tn = -1;\n\t\tphp_stream_close(stream);\n\t\tgoto done;\n\t}\n\n\tn = 0;\n\n\twhile ((n=zip_fread(zf, b, sizeof(b))) > 0) {\n\t\tphp_stream_write(stream, b, n);\n\t}\n\n\tphp_stream_close(stream);\n\tn = zip_fclose(zf);\n\ndone:\n\tefree(fullpath);\n\tefree(file_basename);\n\tefree(file_dirname_fullpath);\n\tfree(new_state.cwd);\n\n\tif (n<0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
        "func": "static int php_zip_extract_file(struct zip * za, char *dest, char *file, int file_len TSRMLS_DC)\n{\n\tphp_stream_statbuf ssb;\n\tstruct zip_file *zf;\n\tstruct zip_stat sb;\n\tchar b[8192];\n\tint n, len, ret;\n\tphp_stream *stream;\n\tchar *fullpath;\n\tchar *file_dirname_fullpath;\n\tchar file_dirname[MAXPATHLEN];\n\tsize_t dir_len;\n\tchar *file_basename;\n\tsize_t file_basename_len;\n\tint is_dir_only = 0;\n\tchar *path_cleaned;\n\tsize_t path_cleaned_len;\n\tcwd_state new_state;\n\n\tnew_state.cwd = (char*)malloc(1);\n\tnew_state.cwd[0] = '\\0';\n\tnew_state.cwd_length = 0;\n\n\t/* Clean/normlize the path and then transform any path (absolute or relative)\n\t\t to a path relative to cwd (../../mydir/foo.txt > mydir/foo.txt)\n\t */\n\tvirtual_file_ex(&new_state, file, NULL, CWD_EXPAND TSRMLS_CC);\n\tpath_cleaned =  php_zip_make_relative_path(new_state.cwd, new_state.cwd_length);\n\tif(!path_cleaned) {\n\t\treturn 0;\n\t}\n\tpath_cleaned_len = strlen(path_cleaned);\n\n\tif (path_cleaned_len >= MAXPATHLEN || zip_stat(za, file, 0, &sb) != 0) {\n\t\treturn 0;\n\t}\n\n\t/* it is a directory only, see #40228 */\n\tif (path_cleaned_len > 1 && IS_SLASH(path_cleaned[path_cleaned_len - 1])) {\n\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, path_cleaned);\n\t\tis_dir_only = 1;\n\t} else {\n\t\tmemcpy(file_dirname, path_cleaned, path_cleaned_len);\n\t\tdir_len = php_dirname(file_dirname, path_cleaned_len);\n\n\t\tif (dir_len <= 0 || (dir_len == 1 && file_dirname[0] == '.')) {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s\", dest);\n\t\t} else {\n\t\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file_dirname);\n\t\t}\n\n\t\tphp_basename(path_cleaned, path_cleaned_len, NULL, 0, &file_basename, (size_t *)&file_basename_len TSRMLS_CC);\n\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(file_dirname_fullpath)) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tefree(file_basename);\n\t\t\tfree(new_state.cwd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* let see if the path already exists */\n\tif (php_stream_stat_path_ex(file_dirname_fullpath, PHP_STREAM_URL_STAT_QUIET, &ssb, NULL) < 0) {\n\n#if defined(PHP_WIN32) && (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION == 1)\n\t\tchar *e;\n\t\te = file_dirname_fullpath;\n\t\twhile (*e) {\n\t\t\t   if (*e == '/') {\n\t\t\t\t\t   *e = DEFAULT_SLASH;\n\t\t\t   }\n\t\t\t   e++;\n\t\t}\n#endif\n\n\t\tret = php_stream_mkdir(file_dirname_fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE|REPORT_ERRORS, NULL);\n\t\tif (!ret) {\n\t\t\tefree(file_dirname_fullpath);\n\t\t\tif (!is_dir_only) {\n\t\t\t\tefree(file_basename);\n\t\t\t\tfree(new_state.cwd);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* it is a standalone directory, job done */\n\tif (is_dir_only) {\n\t\tefree(file_dirname_fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn 1;\n\t}\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", file_dirname_fullpath, file_basename);\n\tif (!len) {\n\t\tefree(file_dirname_fullpath);\n\t\tefree(file_basename);\n\t\tfree(new_state.cwd);\n\t\treturn 0;\n\t} else if (len > MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Full extraction path exceed MAXPATHLEN (%i)\", MAXPATHLEN);\n\t\tefree(file_dirname_fullpath);\n\t\tefree(file_basename);\n\t\tfree(new_state.cwd);\n\t\treturn 0;\n\t}\n\n\t/* check again the full path, not sure if it\n\t * is required, does a file can have a different\n\t * safemode status as its parent folder?\n\t */\n\tif (ZIP_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tefree(fullpath);\n\t\tefree(file_dirname_fullpath);\n\t\tefree(file_basename);\n\t\tfree(new_state.cwd);\n\t\treturn 0;\n\t}\n\n#if PHP_API_VERSION < 20100412\n\tstream = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS|ENFORCE_SAFE_MODE, NULL);\n#else\n\tstream = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n#endif\n\n\tif (stream == NULL) {\n\t\tn = -1;\n\t\tgoto done;\n\t}\n\n\tzf = zip_fopen(za, file, 0);\n\tif (zf == NULL) {\n\t\tn = -1;\n\t\tphp_stream_close(stream);\n\t\tgoto done;\n\t}\n\n\tn = 0;\n\n\twhile ((n=zip_fread(zf, b, sizeof(b))) > 0) {\n\t\tphp_stream_write(stream, b, n);\n\t}\n\n\tphp_stream_close(stream);\n\tn = zip_fclose(zf);\n\ndone:\n\tefree(fullpath);\n\tefree(file_basename);\n\tefree(file_dirname_fullpath);\n\tfree(new_state.cwd);\n\n\tif (n<0) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,7 @@\n \n \t/* it is a directory only, see #40228 */\n \tif (path_cleaned_len > 1 && IS_SLASH(path_cleaned[path_cleaned_len - 1])) {\n-\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file);\n+\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, path_cleaned);\n \t\tis_dir_only = 1;\n \t} else {\n \t\tmemcpy(file_dirname, path_cleaned, path_cleaned_len);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, file);"
            ],
            "added_lines": [
                "\t\tlen = spprintf(&file_dirname_fullpath, 0, \"%s/%s\", dest, path_cleaned);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9767",
        "func_name": "php/php-src/php_zip_glob",
        "description": "Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive.",
        "git_url": "https://github.com/php/php-src/commit/f9c2bf73adb2ede0a486b0db466c264f2b27e0bb",
        "commit_title": "Fixed bug #70350: ZipArchive::extractTo allows for directory traversal when creating directories",
        "commit_text": "",
        "func_before": "int php_zip_glob(char *pattern, int pattern_len, long flags, zval *return_value TSRMLS_DC) /* {{{ */\n{\n#ifdef HAVE_GLOB\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n#ifdef ZTS\n\tchar work_pattern[MAXPATHLEN];\n\tchar *result;\n#endif\n\tglob_t globbuf;\n\tint n;\n\tint ret;\n\t\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\treturn -1;\n\t}\n\n\tif ((GLOB_AVAILABLE_FLAGS & flags) != flags) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"At least one of the passed flags is invalid or not supported on this platform\");\n\t\treturn -1;\n\t}\n\n#ifdef ZTS \n\tif (!IS_ABSOLUTE_PATH(pattern, pattern_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\t\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*pattern)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_pattern, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, pattern);\n\t\tpattern = work_pattern;\n\t} \n#endif\n\n\tglobbuf.gl_offs = 0;\n\tif (0 != (ret = glob(pattern, flags & GLOB_FLAGMASK, NULL, &globbuf))) {\n#ifdef GLOB_NOMATCH\n\t\tif (GLOB_NOMATCH == ret) {\n\t\t\t/* Some glob implementation simply return no data if no matches\n\t\t\t   were found, others return the GLOB_NOMATCH error code.\n\t\t\t   We don't want to treat GLOB_NOMATCH as an error condition\n\t\t\t   so that PHP glob() behaves the same on both types of \n\t\t\t   implementations and so that 'foreach (glob() as ...'\n\t\t\t   can be used for simple glob() calls without further error\n\t\t\t   checking.\n\t\t\t*/\n\t\t\tarray_init(return_value);\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\t/* now catch the FreeBSD style of \"no matches\" */\n\tif (!globbuf.gl_pathc || !globbuf.gl_pathv) {\n\t\tarray_init(return_value);\n\t\treturn 0;\n\t}\n\n\t/* we assume that any glob pattern will match files from one directory only\n\t   so checking the dirname of the first match should be sufficient */\n\tstrncpy(cwd, globbuf.gl_pathv[0], MAXPATHLEN);\n\tif (ZIP_OPENBASEDIR_CHECKPATH(cwd)) {\n\t\treturn -1;\n\t}\n\n\tarray_init(return_value);\n\tfor (n = 0; n < globbuf.gl_pathc; n++) {\n\t\t/* we need to do this everytime since GLOB_ONLYDIR does not guarantee that\n\t\t * all directories will be filtered. GNU libc documentation states the\n\t\t * following: \n\t\t * If the information about the type of the file is easily available \n\t\t * non-directories will be rejected but no extra work will be done to \n\t\t * determine the information for each file. I.e., the caller must still be \n\t\t * able to filter directories out. \n\t\t */\n\t\tif (flags & GLOB_ONLYDIR) {\n\t\t\tstruct stat s;\n\n\t\t\tif (0 != VCWD_STAT(globbuf.gl_pathv[n], &s)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR != (s.st_mode & S_IFMT)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tadd_next_index_string(return_value, globbuf.gl_pathv[n]+cwd_skip, 1);\n\t}\n\n\tglobfree(&globbuf);\n\treturn globbuf.gl_pathc;\n#else\n\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"Glob support is not available\");\n\treturn 0;\n#endif  /* HAVE_GLOB */\n}",
        "func": "int php_zip_glob(char *pattern, int pattern_len, long flags, zval *return_value TSRMLS_DC) /* {{{ */\n{\n#ifdef HAVE_GLOB\n\tchar cwd[MAXPATHLEN];\n\tint cwd_skip = 0;\n#ifdef ZTS\n\tchar work_pattern[MAXPATHLEN];\n\tchar *result;\n#endif\n\tglob_t globbuf;\n\tint n;\n\tint ret;\n\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\treturn -1;\n\t}\n\n\tif ((GLOB_AVAILABLE_FLAGS & flags) != flags) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"At least one of the passed flags is invalid or not supported on this platform\");\n\t\treturn -1;\n\t}\n\n#ifdef ZTS\n\tif (!IS_ABSOLUTE_PATH(pattern, pattern_len)) {\n\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n\t\tif (!result) {\n\t\t\tcwd[0] = '\\0';\n\t\t}\n#ifdef PHP_WIN32\n\t\tif (IS_SLASH(*pattern)) {\n\t\t\tcwd[2] = '\\0';\n\t\t}\n#endif\n\t\tcwd_skip = strlen(cwd)+1;\n\n\t\tsnprintf(work_pattern, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, pattern);\n\t\tpattern = work_pattern;\n\t}\n#endif\n\n\tglobbuf.gl_offs = 0;\n\tif (0 != (ret = glob(pattern, flags & GLOB_FLAGMASK, NULL, &globbuf))) {\n#ifdef GLOB_NOMATCH\n\t\tif (GLOB_NOMATCH == ret) {\n\t\t\t/* Some glob implementation simply return no data if no matches\n\t\t\t   were found, others return the GLOB_NOMATCH error code.\n\t\t\t   We don't want to treat GLOB_NOMATCH as an error condition\n\t\t\t   so that PHP glob() behaves the same on both types of\n\t\t\t   implementations and so that 'foreach (glob() as ...'\n\t\t\t   can be used for simple glob() calls without further error\n\t\t\t   checking.\n\t\t\t*/\n\t\t\tarray_init(return_value);\n\t\t\treturn 0;\n\t\t}\n#endif\n\t\treturn 0;\n\t}\n\n\t/* now catch the FreeBSD style of \"no matches\" */\n\tif (!globbuf.gl_pathc || !globbuf.gl_pathv) {\n\t\tarray_init(return_value);\n\t\treturn 0;\n\t}\n\n\t/* we assume that any glob pattern will match files from one directory only\n\t   so checking the dirname of the first match should be sufficient */\n\tstrncpy(cwd, globbuf.gl_pathv[0], MAXPATHLEN);\n\tif (ZIP_OPENBASEDIR_CHECKPATH(cwd)) {\n\t\treturn -1;\n\t}\n\n\tarray_init(return_value);\n\tfor (n = 0; n < globbuf.gl_pathc; n++) {\n\t\t/* we need to do this everytime since GLOB_ONLYDIR does not guarantee that\n\t\t * all directories will be filtered. GNU libc documentation states the\n\t\t * following:\n\t\t * If the information about the type of the file is easily available\n\t\t * non-directories will be rejected but no extra work will be done to\n\t\t * determine the information for each file. I.e., the caller must still be\n\t\t * able to filter directories out.\n\t\t */\n\t\tif (flags & GLOB_ONLYDIR) {\n\t\t\tstruct stat s;\n\n\t\t\tif (0 != VCWD_STAT(globbuf.gl_pathv[n], &s)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (S_IFDIR != (s.st_mode & S_IFMT)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tadd_next_index_string(return_value, globbuf.gl_pathv[n]+cwd_skip, 1);\n\t}\n\n\tglobfree(&globbuf);\n\treturn globbuf.gl_pathc;\n#else\n\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"Glob support is not available\");\n\treturn 0;\n#endif  /* HAVE_GLOB */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \tglob_t globbuf;\n \tint n;\n \tint ret;\n-\t\n+\n \tif (pattern_len >= MAXPATHLEN) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n \t\treturn -1;\n@@ -21,9 +21,9 @@\n \t\treturn -1;\n \t}\n \n-#ifdef ZTS \n+#ifdef ZTS\n \tif (!IS_ABSOLUTE_PATH(pattern, pattern_len)) {\n-\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\t\n+\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\n \t\tif (!result) {\n \t\t\tcwd[0] = '\\0';\n \t\t}\n@@ -36,7 +36,7 @@\n \n \t\tsnprintf(work_pattern, MAXPATHLEN, \"%s%c%s\", cwd, DEFAULT_SLASH, pattern);\n \t\tpattern = work_pattern;\n-\t} \n+\t}\n #endif\n \n \tglobbuf.gl_offs = 0;\n@@ -46,7 +46,7 @@\n \t\t\t/* Some glob implementation simply return no data if no matches\n \t\t\t   were found, others return the GLOB_NOMATCH error code.\n \t\t\t   We don't want to treat GLOB_NOMATCH as an error condition\n-\t\t\t   so that PHP glob() behaves the same on both types of \n+\t\t\t   so that PHP glob() behaves the same on both types of\n \t\t\t   implementations and so that 'foreach (glob() as ...'\n \t\t\t   can be used for simple glob() calls without further error\n \t\t\t   checking.\n@@ -75,11 +75,11 @@\n \tfor (n = 0; n < globbuf.gl_pathc; n++) {\n \t\t/* we need to do this everytime since GLOB_ONLYDIR does not guarantee that\n \t\t * all directories will be filtered. GNU libc documentation states the\n-\t\t * following: \n-\t\t * If the information about the type of the file is easily available \n-\t\t * non-directories will be rejected but no extra work will be done to \n-\t\t * determine the information for each file. I.e., the caller must still be \n-\t\t * able to filter directories out. \n+\t\t * following:\n+\t\t * If the information about the type of the file is easily available\n+\t\t * non-directories will be rejected but no extra work will be done to\n+\t\t * determine the information for each file. I.e., the caller must still be\n+\t\t * able to filter directories out.\n \t\t */\n \t\tif (flags & GLOB_ONLYDIR) {\n \t\t\tstruct stat s;",
        "diff_line_info": {
            "deleted_lines": [
                "\t",
                "#ifdef ZTS ",
                "\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);\t",
                "\t} ",
                "\t\t\t   so that PHP glob() behaves the same on both types of ",
                "\t\t * following: ",
                "\t\t * If the information about the type of the file is easily available ",
                "\t\t * non-directories will be rejected but no extra work will be done to ",
                "\t\t * determine the information for each file. I.e., the caller must still be ",
                "\t\t * able to filter directories out. "
            ],
            "added_lines": [
                "",
                "#ifdef ZTS",
                "\t\tresult = VCWD_GETCWD(cwd, MAXPATHLEN);",
                "\t}",
                "\t\t\t   so that PHP glob() behaves the same on both types of",
                "\t\t * following:",
                "\t\t * If the information about the type of the file is easily available",
                "\t\t * non-directories will be rejected but no extra work will be done to",
                "\t\t * determine the information for each file. I.e., the caller must still be",
                "\t\t * able to filter directories out."
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9767",
        "func_name": "php/php-src/php_zip_add_file",
        "description": "Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive.",
        "git_url": "https://github.com/php/php-src/commit/f9c2bf73adb2ede0a486b0db466c264f2b27e0bb",
        "commit_title": "Fixed bug #70350: ZipArchive::extractTo allows for directory traversal when creating directories",
        "commit_text": "",
        "func_before": "static int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len, \n\tchar *entry_name, size_t entry_name_len, long offset_start, long offset_len TSRMLS_DC) /* {{{ */\n{\n\tstruct zip_source *zs;\n\tint cur_idx;\n\tchar resolved_path[MAXPATHLEN];\n\tzval exists_flag;\n\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\treturn -1;\n\t}\n\n\tif (!expand_filepath(filename, resolved_path TSRMLS_CC)) {\n\t\treturn -1;\n\t}\n\n\tphp_stat(resolved_path, strlen(resolved_path), FS_EXISTS, &exists_flag TSRMLS_CC);\n\tif (!Z_BVAL(exists_flag)) {\n\t\treturn -1;\n\t}\n\n\tzs = zip_source_file(za, resolved_path, offset_start, offset_len);\n\tif (!zs) {\n\t\treturn -1;\n\t}\n\n\tcur_idx = zip_name_locate(za, (const char *)entry_name, 0);\n\t/* TODO: fix  _zip_replace */\n\tif (cur_idx<0) {\n\t\t/* reset the error */\n\t\tif (za->error.str) {\n\t\t\t_zip_error_fini(&za->error);\n\t\t}\n\t\t_zip_error_init(&za->error);\n\t} else {\n\t\tif (zip_delete(za, cur_idx) == -1) {\n\t\t\tzip_source_free(zs);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (zip_add(za, entry_name, zs) == -1) {\n\t\treturn -1;\n\t} else {\n\t\treturn 1;\n\t}\n}",
        "func": "static int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len,\n\tchar *entry_name, size_t entry_name_len, long offset_start, long offset_len TSRMLS_DC) /* {{{ */\n{\n\tstruct zip_source *zs;\n\tint cur_idx;\n\tchar resolved_path[MAXPATHLEN];\n\tzval exists_flag;\n\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\treturn -1;\n\t}\n\n\tif (!expand_filepath(filename, resolved_path TSRMLS_CC)) {\n\t\treturn -1;\n\t}\n\n\tphp_stat(resolved_path, strlen(resolved_path), FS_EXISTS, &exists_flag TSRMLS_CC);\n\tif (!Z_BVAL(exists_flag)) {\n\t\treturn -1;\n\t}\n\n\tzs = zip_source_file(za, resolved_path, offset_start, offset_len);\n\tif (!zs) {\n\t\treturn -1;\n\t}\n\n\tcur_idx = zip_name_locate(za, (const char *)entry_name, 0);\n\t/* TODO: fix  _zip_replace */\n\tif (cur_idx<0) {\n\t\t/* reset the error */\n\t\tif (za->error.str) {\n\t\t\t_zip_error_fini(&za->error);\n\t\t}\n\t\t_zip_error_init(&za->error);\n\t} else {\n\t\tif (zip_delete(za, cur_idx) == -1) {\n\t\t\tzip_source_free(zs);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (zip_add(za, entry_name, zs) == -1) {\n\t\treturn -1;\n\t} else {\n\t\treturn 1;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len, \n+static int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len,\n \tchar *entry_name, size_t entry_name_len, long offset_start, long offset_len TSRMLS_DC) /* {{{ */\n {\n \tstruct zip_source *zs;",
        "diff_line_info": {
            "deleted_lines": [
                "static int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len, "
            ],
            "added_lines": [
                "static int php_zip_add_file(struct zip *za, const char *filename, size_t filename_len,"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1191",
        "func_name": "madler/pigz/process",
        "description": "Multiple directory traversal vulnerabilities in pigz 2.3.1 allow remote attackers to write to arbitrary files via a (1) full pathname or (2) .. (dot dot) in an archive.",
        "git_url": "https://github.com/madler/pigz/commit/fdad1406b3ec809f4954ff7cdf9e99eb18c2458f",
        "commit_title": "When decompressing with -N or -NT, strip any path from header name.",
        "commit_text": " This uses the path of the compressed file combined with the name from the header as the name of the decompressed output file.  Any path information in the header name is stripped.  This avoids a possible vulnerability where absolute or descending paths are put in the gzip header.",
        "func_before": "local void process(char *path)\n{\n    int method = -1;                /* get_header() return value */\n    size_t len;                     /* length of base name (minus suffix) */\n    struct stat st;                 /* to get file type and mod time */\n    /* all compressed suffixes for decoding search, in length order */\n    static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",\n                           \".zip\", \".ZIP\", \".tgz\", NULL};\n\n    /* open input file with name in, descriptor ind -- set name and mtime */\n    if (path == NULL) {\n        strcpy(g.inf, \"<stdin>\");\n        g.ind = 0;\n        g.name = NULL;\n        g.mtime = g.headis & 2 ?\n                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;\n        len = 0;\n    }\n    else {\n        /* set input file name (already set if recursed here) */\n        if (path != g.inf) {\n            strncpy(g.inf, path, sizeof(g.inf));\n            if (g.inf[sizeof(g.inf) - 1])\n                bail(\"name too long: \", path);\n        }\n        len = strlen(g.inf);\n\n        /* try to stat input file -- if not there and decoding, look for that\n           name with compressed suffixes */\n        if (lstat(g.inf, &st)) {\n            if (errno == ENOENT && (g.list || g.decode)) {\n                char **try = sufs;\n                do {\n                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))\n                        break;\n                    strcpy(g.inf + len, *try++);\n                    errno = 0;\n                } while (lstat(g.inf, &st) && errno == ENOENT);\n            }\n#ifdef EOVERFLOW\n            if (errno == EOVERFLOW || errno == EFBIG)\n                bail(g.inf,\n                    \" too large -- not compiled with large file support\");\n#endif\n            if (errno) {\n                g.inf[len] = 0;\n                complain(\"%s does not exist -- skipping\", g.inf);\n                return;\n            }\n            len = strlen(g.inf);\n        }\n\n        /* only process regular files, but allow symbolic links if -f,\n           recurse into directory if -r */\n        if ((st.st_mode & S_IFMT) != S_IFREG &&\n            (st.st_mode & S_IFMT) != S_IFLNK &&\n            (st.st_mode & S_IFMT) != S_IFDIR) {\n            complain(\"%s is a special file or device -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {\n            complain(\"%s is a symbolic link -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {\n            complain(\"%s is a directory -- skipping\", g.inf);\n            return;\n        }\n\n        /* recurse into directory (assumes Unix) */\n        if ((st.st_mode & S_IFMT) == S_IFDIR) {\n            char *roll, *item, *cut, *base, *bigger;\n            size_t len, hold;\n            DIR *here;\n            struct dirent *next;\n\n            /* accumulate list of entries (need to do this, since readdir()\n               behavior not defined if directory modified between calls) */\n            here = opendir(g.inf);\n            if (here == NULL)\n                return;\n            hold = 512;\n            roll = MALLOC(hold);\n            if (roll == NULL)\n                bail(\"not enough memory\", \"\");\n            *roll = 0;\n            item = roll;\n            while ((next = readdir(here)) != NULL) {\n                if (next->d_name[0] == 0 ||\n                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||\n                     (next->d_name[1] == '.' && next->d_name[2] == 0))))\n                    continue;\n                len = strlen(next->d_name) + 1;\n                if (item + len + 1 > roll + hold) {\n                    do {                    /* make roll bigger */\n                        hold <<= 1;\n                    } while (item + len + 1 > roll + hold);\n                    bigger = REALLOC(roll, hold);\n                    if (bigger == NULL) {\n                        FREE(roll);\n                        bail(\"not enough memory\", \"\");\n                    }\n                    item = bigger + (item - roll);\n                    roll = bigger;\n                }\n                strcpy(item, next->d_name);\n                item += len;\n                *item = 0;\n            }\n            closedir(here);\n\n            /* run process() for each entry in the directory */\n            cut = base = g.inf + strlen(g.inf);\n            if (base > g.inf && base[-1] != (unsigned char)'/') {\n                if ((size_t)(base - g.inf) >= sizeof(g.inf))\n                    bail(\"path too long\", g.inf);\n                *base++ = '/';\n            }\n            item = roll;\n            while (*item) {\n                strncpy(base, item, sizeof(g.inf) - (base - g.inf));\n                if (g.inf[sizeof(g.inf) - 1]) {\n                    strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");\n                    bail(\"path too long: \", g.inf);\n                }\n                process(g.inf);\n                item += strlen(item) + 1;\n            }\n            *cut = 0;\n\n            /* release list of entries */\n            FREE(roll);\n            return;\n        }\n\n        /* don't compress .gz (or provided suffix) files, unless -f */\n        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&\n                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {\n            complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);\n            return;\n        }\n\n        /* create output file only if input file has compressed suffix */\n        if (g.decode == 1 && !g.pipeout && !g.list) {\n            int suf = compressed_suffix(g.inf);\n            if (suf == 0) {\n                complain(\"%s does not have compressed suffix -- skipping\",\n                         g.inf);\n                return;\n            }\n            len -= suf;\n        }\n\n        /* open input file */\n        g.ind = open(g.inf, O_RDONLY, 0);\n        if (g.ind < 0)\n            bail(\"read error on \", g.inf);\n\n        /* prepare gzip header information for compression */\n        g.name = g.headis & 1 ? justname(g.inf) : NULL;\n        g.mtime = g.headis & 2 ? st.st_mtime : 0;\n    }\n    SET_BINARY_MODE(g.ind);\n\n    /* if decoding or testing, try to read gzip header */\n    g.hname = NULL;\n    if (g.decode) {\n        in_init();\n        method = get_header(1);\n        if (method != 8 && method != 257 &&\n                /* gzip -cdf acts like cat on uncompressed input */\n                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&\n                  !g.list)) {\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            if (method != -1)\n                complain(method < 0 ? \"%s is not compressed -- skipping\" :\n                         \"%s has unknown compression method -- skipping\",\n                         g.inf);\n            return;\n        }\n\n        /* if requested, test input file (possibly a special list) */\n        if (g.decode == 2) {\n            if (method == 8)\n                infchk();\n            else {\n                unlzw();\n                if (g.list) {\n                    g.in_tot -= 3;\n                    show_info(method, 0, g.out_tot, 0);\n                }\n            }\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n    }\n\n    /* if requested, just list information about input file */\n    if (g.list) {\n        list_info();\n        RELEASE(g.hname);\n        if (g.ind != 0)\n            close(g.ind);\n        return;\n    }\n\n    /* create output file out, descriptor outd */\n    if (path == NULL || g.pipeout) {\n        /* write to stdout */\n        g.outf = MALLOC(strlen(\"<stdout>\") + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        strcpy(g.outf, \"<stdout>\");\n        g.outd = 1;\n        if (!g.decode && !g.force && isatty(g.outd))\n            bail(\"trying to write compressed data to a terminal\",\n                 \" (use -f to force)\");\n    }\n    else {\n        char *to, *repl;\n\n        /* use header name for output when decompressing with -N */\n        to = g.inf;\n        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n            to = g.hname;\n            len = strlen(g.hname);\n        }\n\n        /* replace .tgz with .tar when decoding */\n        repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";\n\n        /* create output file and open to write */\n        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        memcpy(g.outf, to, len);\n        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n        g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n                             (g.force ? 0 : O_EXCL), 0600);\n\n        /* if exists and not -f, give user a chance to overwrite */\n        if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {\n            int ch, reply;\n\n            fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);\n            fflush(stderr);\n            reply = -1;\n            do {\n                ch = getchar();\n                if (reply < 0 && ch != ' ' && ch != '\\t')\n                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;\n            } while (ch != EOF && ch != '\\n' && ch != '\\r');\n            if (reply == 1)\n                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,\n                              0600);\n        }\n\n        /* if exists and no overwrite, report and go on to next */\n        if (g.outd < 0 && errno == EEXIST) {\n            complain(\"%s exists -- skipping\", g.outf);\n            RELEASE(g.outf);\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n\n        /* if some other error, give up */\n        if (g.outd < 0)\n            bail(\"write error on \", g.outf);\n    }\n    SET_BINARY_MODE(g.outd);\n    RELEASE(g.hname);\n\n    /* process ind to outd */\n    if (g.verbosity > 1)\n        fprintf(stderr, \"%s to %s \", g.inf, g.outf);\n    if (g.decode) {\n        if (method == 8)\n            infchk();\n        else if (method == 257)\n            unlzw();\n        else\n            cat();\n    }\n#ifndef NOTHREAD\n    else if (g.procs > 1)\n        parallel_compress();\n#endif\n    else\n        single_compress(0);\n    if (g.verbosity > 1) {\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n\n    /* finish up, copy attributes, set times, delete original */\n    if (g.ind != 0)\n        close(g.ind);\n    if (g.outd != 1) {\n        if (close(g.outd))\n            bail(\"write error on \", g.outf);\n        g.outd = -1;            /* now prevent deletion on interrupt */\n        if (g.ind != 0) {\n            copymeta(g.inf, g.outf);\n            if (!g.keep)\n                unlink(g.inf);\n        }\n        if (g.decode && (g.headis & 2) != 0 && g.stamp)\n            touch(g.outf, g.stamp);\n    }\n    RELEASE(g.outf);\n}",
        "func": "local void process(char *path)\n{\n    int method = -1;                /* get_header() return value */\n    size_t len;                     /* length of base name (minus suffix) */\n    struct stat st;                 /* to get file type and mod time */\n    /* all compressed suffixes for decoding search, in length order */\n    static char *sufs[] = {\".z\", \"-z\", \"_z\", \".Z\", \".gz\", \"-gz\", \".zz\", \"-zz\",\n                           \".zip\", \".ZIP\", \".tgz\", NULL};\n\n    /* open input file with name in, descriptor ind -- set name and mtime */\n    if (path == NULL) {\n        strcpy(g.inf, \"<stdin>\");\n        g.ind = 0;\n        g.name = NULL;\n        g.mtime = g.headis & 2 ?\n                  (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;\n        len = 0;\n    }\n    else {\n        /* set input file name (already set if recursed here) */\n        if (path != g.inf) {\n            strncpy(g.inf, path, sizeof(g.inf));\n            if (g.inf[sizeof(g.inf) - 1])\n                bail(\"name too long: \", path);\n        }\n        len = strlen(g.inf);\n\n        /* try to stat input file -- if not there and decoding, look for that\n           name with compressed suffixes */\n        if (lstat(g.inf, &st)) {\n            if (errno == ENOENT && (g.list || g.decode)) {\n                char **try = sufs;\n                do {\n                    if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))\n                        break;\n                    strcpy(g.inf + len, *try++);\n                    errno = 0;\n                } while (lstat(g.inf, &st) && errno == ENOENT);\n            }\n#ifdef EOVERFLOW\n            if (errno == EOVERFLOW || errno == EFBIG)\n                bail(g.inf,\n                    \" too large -- not compiled with large file support\");\n#endif\n            if (errno) {\n                g.inf[len] = 0;\n                complain(\"%s does not exist -- skipping\", g.inf);\n                return;\n            }\n            len = strlen(g.inf);\n        }\n\n        /* only process regular files, but allow symbolic links if -f,\n           recurse into directory if -r */\n        if ((st.st_mode & S_IFMT) != S_IFREG &&\n            (st.st_mode & S_IFMT) != S_IFLNK &&\n            (st.st_mode & S_IFMT) != S_IFDIR) {\n            complain(\"%s is a special file or device -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {\n            complain(\"%s is a symbolic link -- skipping\", g.inf);\n            return;\n        }\n        if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {\n            complain(\"%s is a directory -- skipping\", g.inf);\n            return;\n        }\n\n        /* recurse into directory (assumes Unix) */\n        if ((st.st_mode & S_IFMT) == S_IFDIR) {\n            char *roll, *item, *cut, *base, *bigger;\n            size_t len, hold;\n            DIR *here;\n            struct dirent *next;\n\n            /* accumulate list of entries (need to do this, since readdir()\n               behavior not defined if directory modified between calls) */\n            here = opendir(g.inf);\n            if (here == NULL)\n                return;\n            hold = 512;\n            roll = MALLOC(hold);\n            if (roll == NULL)\n                bail(\"not enough memory\", \"\");\n            *roll = 0;\n            item = roll;\n            while ((next = readdir(here)) != NULL) {\n                if (next->d_name[0] == 0 ||\n                    (next->d_name[0] == '.' && (next->d_name[1] == 0 ||\n                     (next->d_name[1] == '.' && next->d_name[2] == 0))))\n                    continue;\n                len = strlen(next->d_name) + 1;\n                if (item + len + 1 > roll + hold) {\n                    do {                    /* make roll bigger */\n                        hold <<= 1;\n                    } while (item + len + 1 > roll + hold);\n                    bigger = REALLOC(roll, hold);\n                    if (bigger == NULL) {\n                        FREE(roll);\n                        bail(\"not enough memory\", \"\");\n                    }\n                    item = bigger + (item - roll);\n                    roll = bigger;\n                }\n                strcpy(item, next->d_name);\n                item += len;\n                *item = 0;\n            }\n            closedir(here);\n\n            /* run process() for each entry in the directory */\n            cut = base = g.inf + strlen(g.inf);\n            if (base > g.inf && base[-1] != (unsigned char)'/') {\n                if ((size_t)(base - g.inf) >= sizeof(g.inf))\n                    bail(\"path too long\", g.inf);\n                *base++ = '/';\n            }\n            item = roll;\n            while (*item) {\n                strncpy(base, item, sizeof(g.inf) - (base - g.inf));\n                if (g.inf[sizeof(g.inf) - 1]) {\n                    strcpy(g.inf + (sizeof(g.inf) - 4), \"...\");\n                    bail(\"path too long: \", g.inf);\n                }\n                process(g.inf);\n                item += strlen(item) + 1;\n            }\n            *cut = 0;\n\n            /* release list of entries */\n            FREE(roll);\n            return;\n        }\n\n        /* don't compress .gz (or provided suffix) files, unless -f */\n        if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&\n                strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {\n            complain(\"%s ends with %s -- skipping\", g.inf, g.sufx);\n            return;\n        }\n\n        /* create output file only if input file has compressed suffix */\n        if (g.decode == 1 && !g.pipeout && !g.list) {\n            int suf = compressed_suffix(g.inf);\n            if (suf == 0) {\n                complain(\"%s does not have compressed suffix -- skipping\",\n                         g.inf);\n                return;\n            }\n            len -= suf;\n        }\n\n        /* open input file */\n        g.ind = open(g.inf, O_RDONLY, 0);\n        if (g.ind < 0)\n            bail(\"read error on \", g.inf);\n\n        /* prepare gzip header information for compression */\n        g.name = g.headis & 1 ? justname(g.inf) : NULL;\n        g.mtime = g.headis & 2 ? st.st_mtime : 0;\n    }\n    SET_BINARY_MODE(g.ind);\n\n    /* if decoding or testing, try to read gzip header */\n    g.hname = NULL;\n    if (g.decode) {\n        in_init();\n        method = get_header(1);\n        if (method != 8 && method != 257 &&\n                /* gzip -cdf acts like cat on uncompressed input */\n                !(method == -2 && g.force && g.pipeout && g.decode != 2 &&\n                  !g.list)) {\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            if (method != -1)\n                complain(method < 0 ? \"%s is not compressed -- skipping\" :\n                         \"%s has unknown compression method -- skipping\",\n                         g.inf);\n            return;\n        }\n\n        /* if requested, test input file (possibly a special list) */\n        if (g.decode == 2) {\n            if (method == 8)\n                infchk();\n            else {\n                unlzw();\n                if (g.list) {\n                    g.in_tot -= 3;\n                    show_info(method, 0, g.out_tot, 0);\n                }\n            }\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n    }\n\n    /* if requested, just list information about input file */\n    if (g.list) {\n        list_info();\n        RELEASE(g.hname);\n        if (g.ind != 0)\n            close(g.ind);\n        return;\n    }\n\n    /* create output file out, descriptor outd */\n    if (path == NULL || g.pipeout) {\n        /* write to stdout */\n        g.outf = MALLOC(strlen(\"<stdout>\") + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        strcpy(g.outf, \"<stdout>\");\n        g.outd = 1;\n        if (!g.decode && !g.force && isatty(g.outd))\n            bail(\"trying to write compressed data to a terminal\",\n                 \" (use -f to force)\");\n    }\n    else {\n        char *to = g.inf, *sufx = \"\";\n        size_t pre = 0;\n\n        /* select parts of the output file name */\n        if (g.decode) {\n            /* for -dN or -dNT, use the path from the input file and the name\n               from the header, stripping any path in the header name */\n            if ((g.headis & 1) != 0 && g.hname != NULL) {\n                pre = justname(g.inf) - g.inf;\n                to = justname(g.hname);\n                len = strlen(to);\n            }\n            /* for -d or -dNn, replace abbreviated suffixes */\n            else if (strcmp(to + len, \".tgz\") == 0)\n                sufx = \".tar\";\n        }\n        else\n            /* add appropriate suffix when compressing */\n            sufx = g.sufx;\n\n        /* create output file and open to write */\n        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n        if (g.outf == NULL)\n            bail(\"not enough memory\", \"\");\n        memcpy(g.outf, g.inf, pre);\n        memcpy(g.outf + pre, to, len);\n        strcpy(g.outf + pre + len, sufx);\n        g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n                              (g.force ? 0 : O_EXCL), 0600);\n\n        /* if exists and not -f, give user a chance to overwrite */\n        if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {\n            int ch, reply;\n\n            fprintf(stderr, \"%s exists -- overwrite (y/n)? \", g.outf);\n            fflush(stderr);\n            reply = -1;\n            do {\n                ch = getchar();\n                if (reply < 0 && ch != ' ' && ch != '\\t')\n                    reply = ch == 'y' || ch == 'Y' ? 1 : 0;\n            } while (ch != EOF && ch != '\\n' && ch != '\\r');\n            if (reply == 1)\n                g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,\n                              0600);\n        }\n\n        /* if exists and no overwrite, report and go on to next */\n        if (g.outd < 0 && errno == EEXIST) {\n            complain(\"%s exists -- skipping\", g.outf);\n            RELEASE(g.outf);\n            RELEASE(g.hname);\n            if (g.ind != 0)\n                close(g.ind);\n            return;\n        }\n\n        /* if some other error, give up */\n        if (g.outd < 0)\n            bail(\"write error on \", g.outf);\n    }\n    SET_BINARY_MODE(g.outd);\n    RELEASE(g.hname);\n\n    /* process ind to outd */\n    if (g.verbosity > 1)\n        fprintf(stderr, \"%s to %s \", g.inf, g.outf);\n    if (g.decode) {\n        if (method == 8)\n            infchk();\n        else if (method == 257)\n            unlzw();\n        else\n            cat();\n    }\n#ifndef NOTHREAD\n    else if (g.procs > 1)\n        parallel_compress();\n#endif\n    else\n        single_compress(0);\n    if (g.verbosity > 1) {\n        putc('\\n', stderr);\n        fflush(stderr);\n    }\n\n    /* finish up, copy attributes, set times, delete original */\n    if (g.ind != 0)\n        close(g.ind);\n    if (g.outd != 1) {\n        if (close(g.outd))\n            bail(\"write error on \", g.outf);\n        g.outd = -1;            /* now prevent deletion on interrupt */\n        if (g.ind != 0) {\n            copymeta(g.inf, g.outf);\n            if (!g.keep)\n                unlink(g.inf);\n        }\n        if (g.decode && (g.headis & 2) != 0 && g.stamp)\n            touch(g.outf, g.stamp);\n    }\n    RELEASE(g.outf);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -221,26 +221,35 @@\n                  \" (use -f to force)\");\n     }\n     else {\n-        char *to, *repl;\n-\n-        /* use header name for output when decompressing with -N */\n-        to = g.inf;\n-        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {\n-            to = g.hname;\n-            len = strlen(g.hname);\n-        }\n-\n-        /* replace .tgz with .tar when decoding */\n-        repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";\n+        char *to = g.inf, *sufx = \"\";\n+        size_t pre = 0;\n+\n+        /* select parts of the output file name */\n+        if (g.decode) {\n+            /* for -dN or -dNT, use the path from the input file and the name\n+               from the header, stripping any path in the header name */\n+            if ((g.headis & 1) != 0 && g.hname != NULL) {\n+                pre = justname(g.inf) - g.inf;\n+                to = justname(g.hname);\n+                len = strlen(to);\n+            }\n+            /* for -d or -dNn, replace abbreviated suffixes */\n+            else if (strcmp(to + len, \".tgz\") == 0)\n+                sufx = \".tar\";\n+        }\n+        else\n+            /* add appropriate suffix when compressing */\n+            sufx = g.sufx;\n \n         /* create output file and open to write */\n-        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);\n+        g.outf = MALLOC(pre + len + strlen(sufx) + 1);\n         if (g.outf == NULL)\n             bail(\"not enough memory\", \"\");\n-        memcpy(g.outf, to, len);\n-        strcpy(g.outf + len, g.decode ? repl : g.sufx);\n+        memcpy(g.outf, g.inf, pre);\n+        memcpy(g.outf + pre, to, len);\n+        strcpy(g.outf + pre + len, sufx);\n         g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |\n-                             (g.force ? 0 : O_EXCL), 0600);\n+                              (g.force ? 0 : O_EXCL), 0600);\n \n         /* if exists and not -f, give user a chance to overwrite */\n         if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {",
        "diff_line_info": {
            "deleted_lines": [
                "        char *to, *repl;",
                "",
                "        /* use header name for output when decompressing with -N */",
                "        to = g.inf;",
                "        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {",
                "            to = g.hname;",
                "            len = strlen(g.hname);",
                "        }",
                "",
                "        /* replace .tgz with .tar when decoding */",
                "        repl = g.decode && strcmp(to + len, \".tgz\") ? \"\" : \".tar\";",
                "        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);",
                "        memcpy(g.outf, to, len);",
                "        strcpy(g.outf + len, g.decode ? repl : g.sufx);",
                "                             (g.force ? 0 : O_EXCL), 0600);"
            ],
            "added_lines": [
                "        char *to = g.inf, *sufx = \"\";",
                "        size_t pre = 0;",
                "",
                "        /* select parts of the output file name */",
                "        if (g.decode) {",
                "            /* for -dN or -dNT, use the path from the input file and the name",
                "               from the header, stripping any path in the header name */",
                "            if ((g.headis & 1) != 0 && g.hname != NULL) {",
                "                pre = justname(g.inf) - g.inf;",
                "                to = justname(g.hname);",
                "                len = strlen(to);",
                "            }",
                "            /* for -d or -dNn, replace abbreviated suffixes */",
                "            else if (strcmp(to + len, \".tgz\") == 0)",
                "                sufx = \".tar\";",
                "        }",
                "        else",
                "            /* add appropriate suffix when compressing */",
                "            sufx = g.sufx;",
                "        g.outf = MALLOC(pre + len + strlen(sufx) + 1);",
                "        memcpy(g.outf, g.inf, pre);",
                "        memcpy(g.outf + pre, to, len);",
                "        strcpy(g.outf + pre + len, sufx);",
                "                              (g.force ? 0 : O_EXCL), 0600);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2304",
        "func_name": "libarchive/cleanup_pathname",
        "description": "Absolute path traversal vulnerability in bsdcpio in libarchive 3.1.2 and earlier allows remote attackers to write to arbitrary files via a full pathname in an archive.",
        "git_url": "https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526",
        "commit_title": "Add ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS option",
        "commit_text": " This fixes a directory traversal in the cpio tool.",
        "func_before": "static int\ncleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/')\n\t\tseparator = *src++;\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}",
        "func": "static int\ncleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/') {\n\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t                  \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tseparator = *src++;\n\t}\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,8 +15,15 @@\n \tcleanup_pathname_win(a);\n #endif\n \t/* Skip leading '/'. */\n-\tif (*src == '/')\n+\tif (*src == '/') {\n+\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n+\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n+\t\t\t                  \"Path is absolute\");\n+\t\t\treturn (ARCHIVE_FAILED);\n+\t\t}\n+\n \t\tseparator = *src++;\n+\t}\n \n \t/* Scan the pathname one element at a time. */\n \tfor (;;) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (*src == '/')"
            ],
            "added_lines": [
                "\tif (*src == '/') {",
                "\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {",
                "\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
                "\t\t\t                  \"Path is absolute\");",
                "\t\t\treturn (ARCHIVE_FAILED);",
                "\t\t}",
                "",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2304",
        "func_name": "libarchive/main",
        "description": "Absolute path traversal vulnerability in bsdcpio in libarchive 3.1.2 and earlier allows remote attackers to write to arbitrary files via a full pathname in an archive.",
        "git_url": "https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526",
        "commit_title": "Add ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS option",
        "commit_text": " This fixes a directory traversal in the cpio tool.",
        "func_before": "int\nmain(int argc, char *argv[])\n{\n\tstatic char buff[16384];\n\tstruct cpio _cpio; /* Allocated on stack. */\n\tstruct cpio *cpio;\n\tconst char *errmsg;\n\tint uid, gid;\n\tint opt;\n\n\tcpio = &_cpio;\n\tmemset(cpio, 0, sizeof(*cpio));\n\tcpio->buff = buff;\n\tcpio->buff_size = sizeof(buff);\n\n#if defined(HAVE_SIGACTION) && defined(SIGPIPE)\n\t{ /* Ignore SIGPIPE signals. */\n\t\tstruct sigaction sa;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsa.sa_flags = 0;\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsigaction(SIGPIPE, &sa, NULL);\n\t}\n#endif\n\n\t/* Set lafe_progname before calling lafe_warnc. */\n\tlafe_setprogname(*argv, \"bsdcpio\");\n\n#if HAVE_SETLOCALE\n\tif (setlocale(LC_ALL, \"\") == NULL)\n\t\tlafe_warnc(0, \"Failed to set default locale\");\n#endif\n\n\tcpio->uid_override = -1;\n\tcpio->gid_override = -1;\n\tcpio->argv = argv;\n\tcpio->argc = argc;\n\tcpio->mode = '\\0';\n\tcpio->verbose = 0;\n\tcpio->compress = '\\0';\n\tcpio->extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_PERM;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_ACL;\n#if !defined(_WIN32) && !defined(__CYGWIN__)\n\tif (geteuid() == 0)\n\t\tcpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;\n#endif\n\tcpio->bytes_per_block = 512;\n\tcpio->filename = NULL;\n\n\tcpio->matching = archive_match_new();\n\tif (cpio->matching == NULL)\n\t\tlafe_errc(1, 0, \"Out of memory\");\n\n\twhile ((opt = cpio_getopt(cpio)) != -1) {\n\t\tswitch (opt) {\n\t\tcase '0': /* GNU convention: --null, -0 */\n\t\t\tcpio->option_null = 1;\n\t\t\tbreak;\n\t\tcase 'A': /* NetBSD/OpenBSD */\n\t\t\tcpio->option_append = 1;\n\t\t\tbreak;\n\t\tcase 'a': /* POSIX 1997 */\n\t\t\tcpio->option_atime_restore = 1;\n\t\t\tbreak;\n\t\tcase 'B': /* POSIX 1997 */\n\t\t\tcpio->bytes_per_block = 5120;\n\t\t\tbreak;\n\t\tcase OPTION_B64ENCODE:\n\t\t\tcpio->add_filter = opt;\n\t\t\tbreak;\n\t\tcase 'C': /* NetBSD/OpenBSD */\n\t\t\tcpio->bytes_per_block = atoi(cpio->argument);\n\t\t\tif (cpio->bytes_per_block <= 0)\n\t\t\t\tlafe_errc(1, 0, \"Invalid blocksize %s\", cpio->argument);\n\t\t\tbreak;\n\t\tcase 'c': /* POSIX 1997 */\n\t\t\tcpio->format = \"odc\";\n\t\t\tbreak;\n\t\tcase 'd': /* POSIX 1997 */\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_NO_AUTODIR;\n\t\t\tbreak;\n\t\tcase 'E': /* NetBSD/OpenBSD */\n\t\t\tif (archive_match_include_pattern_from_file(\n\t\t\t    cpio->matching, cpio->argument,\n\t\t\t    cpio->option_null) != ARCHIVE_OK)\n\t\t\t\tlafe_errc(1, 0, \"Error : %s\",\n\t\t\t\t    archive_error_string(cpio->matching));\n\t\t\tbreak;\n\t\tcase 'F': /* NetBSD/OpenBSD/GNU cpio */\n\t\t\tcpio->filename = cpio->argument;\n\t\t\tbreak;\n\t\tcase 'f': /* POSIX 1997 */\n\t\t\tif (archive_match_exclude_pattern(cpio->matching,\n\t\t\t    cpio->argument) != ARCHIVE_OK)\n\t\t\t\tlafe_errc(1, 0, \"Error : %s\",\n\t\t\t\t    archive_error_string(cpio->matching));\n\t\t\tbreak;\n\t\tcase OPTION_GRZIP:\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'H': /* GNU cpio (also --format) */\n\t\t\tcpio->format = cpio->argument;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tlong_help();\n\t\t\tbreak;\n\t\tcase 'I': /* NetBSD/OpenBSD */\n\t\t\tcpio->filename = cpio->argument;\n\t\t\tbreak;\n\t\tcase 'i': /* POSIX 1997 */\n\t\t\tif (cpio->mode != '\\0')\n\t\t\t\tlafe_errc(1, 0,\n\t\t\t\t    \"Cannot use both -i and -%c\", cpio->mode);\n\t\t\tcpio->mode = opt;\n\t\t\tbreak;\n\t\tcase 'J': /* GNU tar, others */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'j': /* GNU tar, others */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase OPTION_INSECURE:\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n\t\t\tbreak;\n\t\tcase 'L': /* GNU cpio */\n\t\t\tcpio->option_follow_links = 1;\n\t\t\tbreak;\n\t\tcase 'l': /* POSIX 1997 */\n\t\t\tcpio->option_link = 1;\n\t\t\tbreak;\n\t\tcase OPTION_LRZIP:\n\t\tcase OPTION_LZ4:\n\t\tcase OPTION_LZMA: /* GNU tar, others */\n\t\tcase OPTION_LZOP: /* GNU tar, others */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'm': /* POSIX 1997 */\n\t\t\tcpio->extract_flags |= ARCHIVE_EXTRACT_TIME;\n\t\t\tbreak;\n\t\tcase 'n': /* GNU cpio */\n\t\t\tcpio->option_numeric_uid_gid = 1;\n\t\t\tbreak;\n\t\tcase OPTION_NO_PRESERVE_OWNER: /* GNU cpio */\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_OWNER;\n\t\t\tbreak;\n\t\tcase 'O': /* GNU cpio */\n\t\t\tcpio->filename = cpio->argument;\n\t\t\tbreak;\n\t\tcase 'o': /* POSIX 1997 */\n\t\t\tif (cpio->mode != '\\0')\n\t\t\t\tlafe_errc(1, 0,\n\t\t\t\t    \"Cannot use both -o and -%c\", cpio->mode);\n\t\t\tcpio->mode = opt;\n\t\t\tbreak;\n\t\tcase 'p': /* POSIX 1997 */\n\t\t\tif (cpio->mode != '\\0')\n\t\t\t\tlafe_errc(1, 0,\n\t\t\t\t    \"Cannot use both -p and -%c\", cpio->mode);\n\t\t\tcpio->mode = opt;\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n\t\t\tbreak;\n\t\tcase OPTION_PASSPHRASE:\n\t\t\tcpio->passphrase = cpio->argument;\n\t\t\tbreak;\n\t\tcase OPTION_PRESERVE_OWNER:\n\t\t\tcpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;\n\t\t\tbreak;\n\t\tcase OPTION_QUIET: /* GNU cpio */\n\t\t\tcpio->quiet = 1;\n\t\t\tbreak;\n\t\tcase 'R': /* GNU cpio, also --owner */\n\t\t\t/* TODO: owner_parse should return uname/gname\n\t\t\t * also; use that to set [ug]name_override. */\n\t\t\terrmsg = owner_parse(cpio->argument, &uid, &gid);\n\t\t\tif (errmsg) {\n\t\t\t\tlafe_warnc(-1, \"%s\", errmsg);\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tif (uid != -1) {\n\t\t\t\tcpio->uid_override = uid;\n\t\t\t\tcpio->uname_override = NULL;\n\t\t\t}\n\t\t\tif (gid != -1) {\n\t\t\t\tcpio->gid_override = gid;\n\t\t\t\tcpio->gname_override = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r': /* POSIX 1997 */\n\t\t\tcpio->option_rename = 1;\n\t\t\tbreak;\n\t\tcase 't': /* POSIX 1997 */\n\t\t\tcpio->option_list = 1;\n\t\t\tbreak;\n\t\tcase 'u': /* POSIX 1997 */\n\t\t\tcpio->extract_flags\n\t\t\t    &= ~ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;\n\t\t\tbreak;\n\t\tcase OPTION_UUENCODE:\n\t\t\tcpio->add_filter = opt;\n\t\t\tbreak;\n\t\tcase 'v': /* POSIX 1997 */\n\t\t\tcpio->verbose++;\n\t\t\tbreak;\n\t\tcase 'V': /* GNU cpio */\n\t\t\tcpio->dot++;\n\t\t\tbreak;\n\t\tcase OPTION_VERSION: /* GNU convention */\n\t\t\tversion();\n\t\t\tbreak;\n#if 0\n\t        /*\n\t\t * cpio_getopt() handles -W specially, so it's not\n\t\t * available here.\n\t\t */\n\t\tcase 'W': /* Obscure, but useful GNU convention. */\n\t\t\tbreak;\n#endif\n\t\tcase 'y': /* tar convention */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'Z': /* tar convention */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'z': /* tar convention */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\t/*\n\t * Sanity-check args, error out on nonsensical combinations.\n\t */\n\t/* -t implies -i if no mode was specified. */\n\tif (cpio->option_list && cpio->mode == '\\0')\n\t\tcpio->mode = 'i';\n\t/* -t requires -i */\n\tif (cpio->option_list && cpio->mode != 'i')\n\t\tlafe_errc(1, 0, \"Option -t requires -i\");\n\t/* -n requires -it */\n\tif (cpio->option_numeric_uid_gid && !cpio->option_list)\n\t\tlafe_errc(1, 0, \"Option -n requires -it\");\n\t/* Can only specify format when writing */\n\tif (cpio->format != NULL && cpio->mode != 'o')\n\t\tlafe_errc(1, 0, \"Option --format requires -o\");\n\t/* -l requires -p */\n\tif (cpio->option_link && cpio->mode != 'p')\n\t\tlafe_errc(1, 0, \"Option -l requires -p\");\n\t/* -v overrides -V */\n\tif (cpio->dot && cpio->verbose)\n\t\tcpio->dot = 0;\n\t/* TODO: Flag other nonsensical combinations. */\n\n\tswitch (cpio->mode) {\n\tcase 'o':\n\t\t/* TODO: Implement old binary format in libarchive,\n\t\t   use that here. */\n\t\tif (cpio->format == NULL)\n\t\t\tcpio->format = \"odc\"; /* Default format */\n\n\t\tmode_out(cpio);\n\t\tbreak;\n\tcase 'i':\n\t\twhile (*cpio->argv != NULL) {\n\t\t\tif (archive_match_include_pattern(cpio->matching,\n\t\t\t    *cpio->argv) != ARCHIVE_OK)\n\t\t\t\tlafe_errc(1, 0, \"Error : %s\",\n\t\t\t\t    archive_error_string(cpio->matching));\n\t\t\t--cpio->argc;\n\t\t\t++cpio->argv;\n\t\t}\n\t\tif (cpio->option_list)\n\t\t\tmode_list(cpio);\n\t\telse\n\t\t\tmode_in(cpio);\n\t\tbreak;\n\tcase 'p':\n\t\tif (*cpio->argv == NULL || **cpio->argv == '\\0')\n\t\t\tlafe_errc(1, 0,\n\t\t\t    \"-p mode requires a target directory\");\n\t\tmode_pass(cpio, *cpio->argv);\n\t\tbreak;\n\tdefault:\n\t\tlafe_errc(1, 0,\n\t\t    \"Must specify at least one of -i, -o, or -p\");\n\t}\n\n\tarchive_match_free(cpio->matching);\n\tfree_cache(cpio->gname_cache);\n\tfree_cache(cpio->uname_cache);\n\tfree(cpio->destdir);\n\tpassphrase_free(cpio->ppbuff);\n\treturn (cpio->return_value);\n}",
        "func": "int\nmain(int argc, char *argv[])\n{\n\tstatic char buff[16384];\n\tstruct cpio _cpio; /* Allocated on stack. */\n\tstruct cpio *cpio;\n\tconst char *errmsg;\n\tint uid, gid;\n\tint opt;\n\n\tcpio = &_cpio;\n\tmemset(cpio, 0, sizeof(*cpio));\n\tcpio->buff = buff;\n\tcpio->buff_size = sizeof(buff);\n\n#if defined(HAVE_SIGACTION) && defined(SIGPIPE)\n\t{ /* Ignore SIGPIPE signals. */\n\t\tstruct sigaction sa;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsa.sa_flags = 0;\n\t\tsa.sa_handler = SIG_IGN;\n\t\tsigaction(SIGPIPE, &sa, NULL);\n\t}\n#endif\n\n\t/* Set lafe_progname before calling lafe_warnc. */\n\tlafe_setprogname(*argv, \"bsdcpio\");\n\n#if HAVE_SETLOCALE\n\tif (setlocale(LC_ALL, \"\") == NULL)\n\t\tlafe_warnc(0, \"Failed to set default locale\");\n#endif\n\n\tcpio->uid_override = -1;\n\tcpio->gid_override = -1;\n\tcpio->argv = argv;\n\tcpio->argc = argc;\n\tcpio->mode = '\\0';\n\tcpio->verbose = 0;\n\tcpio->compress = '\\0';\n\tcpio->extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_PERM;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;\n\tcpio->extract_flags |= ARCHIVE_EXTRACT_ACL;\n#if !defined(_WIN32) && !defined(__CYGWIN__)\n\tif (geteuid() == 0)\n\t\tcpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;\n#endif\n\tcpio->bytes_per_block = 512;\n\tcpio->filename = NULL;\n\n\tcpio->matching = archive_match_new();\n\tif (cpio->matching == NULL)\n\t\tlafe_errc(1, 0, \"Out of memory\");\n\n\twhile ((opt = cpio_getopt(cpio)) != -1) {\n\t\tswitch (opt) {\n\t\tcase '0': /* GNU convention: --null, -0 */\n\t\t\tcpio->option_null = 1;\n\t\t\tbreak;\n\t\tcase 'A': /* NetBSD/OpenBSD */\n\t\t\tcpio->option_append = 1;\n\t\t\tbreak;\n\t\tcase 'a': /* POSIX 1997 */\n\t\t\tcpio->option_atime_restore = 1;\n\t\t\tbreak;\n\t\tcase 'B': /* POSIX 1997 */\n\t\t\tcpio->bytes_per_block = 5120;\n\t\t\tbreak;\n\t\tcase OPTION_B64ENCODE:\n\t\t\tcpio->add_filter = opt;\n\t\t\tbreak;\n\t\tcase 'C': /* NetBSD/OpenBSD */\n\t\t\tcpio->bytes_per_block = atoi(cpio->argument);\n\t\t\tif (cpio->bytes_per_block <= 0)\n\t\t\t\tlafe_errc(1, 0, \"Invalid blocksize %s\", cpio->argument);\n\t\t\tbreak;\n\t\tcase 'c': /* POSIX 1997 */\n\t\t\tcpio->format = \"odc\";\n\t\t\tbreak;\n\t\tcase 'd': /* POSIX 1997 */\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_NO_AUTODIR;\n\t\t\tbreak;\n\t\tcase 'E': /* NetBSD/OpenBSD */\n\t\t\tif (archive_match_include_pattern_from_file(\n\t\t\t    cpio->matching, cpio->argument,\n\t\t\t    cpio->option_null) != ARCHIVE_OK)\n\t\t\t\tlafe_errc(1, 0, \"Error : %s\",\n\t\t\t\t    archive_error_string(cpio->matching));\n\t\t\tbreak;\n\t\tcase 'F': /* NetBSD/OpenBSD/GNU cpio */\n\t\t\tcpio->filename = cpio->argument;\n\t\t\tbreak;\n\t\tcase 'f': /* POSIX 1997 */\n\t\t\tif (archive_match_exclude_pattern(cpio->matching,\n\t\t\t    cpio->argument) != ARCHIVE_OK)\n\t\t\t\tlafe_errc(1, 0, \"Error : %s\",\n\t\t\t\t    archive_error_string(cpio->matching));\n\t\t\tbreak;\n\t\tcase OPTION_GRZIP:\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'H': /* GNU cpio (also --format) */\n\t\t\tcpio->format = cpio->argument;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tlong_help();\n\t\t\tbreak;\n\t\tcase 'I': /* NetBSD/OpenBSD */\n\t\t\tcpio->filename = cpio->argument;\n\t\t\tbreak;\n\t\tcase 'i': /* POSIX 1997 */\n\t\t\tif (cpio->mode != '\\0')\n\t\t\t\tlafe_errc(1, 0,\n\t\t\t\t    \"Cannot use both -i and -%c\", cpio->mode);\n\t\t\tcpio->mode = opt;\n\t\t\tbreak;\n\t\tcase 'J': /* GNU tar, others */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'j': /* GNU tar, others */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase OPTION_INSECURE:\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;\n\t\t\tbreak;\n\t\tcase 'L': /* GNU cpio */\n\t\t\tcpio->option_follow_links = 1;\n\t\t\tbreak;\n\t\tcase 'l': /* POSIX 1997 */\n\t\t\tcpio->option_link = 1;\n\t\t\tbreak;\n\t\tcase OPTION_LRZIP:\n\t\tcase OPTION_LZ4:\n\t\tcase OPTION_LZMA: /* GNU tar, others */\n\t\tcase OPTION_LZOP: /* GNU tar, others */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'm': /* POSIX 1997 */\n\t\t\tcpio->extract_flags |= ARCHIVE_EXTRACT_TIME;\n\t\t\tbreak;\n\t\tcase 'n': /* GNU cpio */\n\t\t\tcpio->option_numeric_uid_gid = 1;\n\t\t\tbreak;\n\t\tcase OPTION_NO_PRESERVE_OWNER: /* GNU cpio */\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_OWNER;\n\t\t\tbreak;\n\t\tcase 'O': /* GNU cpio */\n\t\t\tcpio->filename = cpio->argument;\n\t\t\tbreak;\n\t\tcase 'o': /* POSIX 1997 */\n\t\t\tif (cpio->mode != '\\0')\n\t\t\t\tlafe_errc(1, 0,\n\t\t\t\t    \"Cannot use both -o and -%c\", cpio->mode);\n\t\t\tcpio->mode = opt;\n\t\t\tbreak;\n\t\tcase 'p': /* POSIX 1997 */\n\t\t\tif (cpio->mode != '\\0')\n\t\t\t\tlafe_errc(1, 0,\n\t\t\t\t    \"Cannot use both -p and -%c\", cpio->mode);\n\t\t\tcpio->mode = opt;\n\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n\t\t\tbreak;\n\t\tcase OPTION_PASSPHRASE:\n\t\t\tcpio->passphrase = cpio->argument;\n\t\t\tbreak;\n\t\tcase OPTION_PRESERVE_OWNER:\n\t\t\tcpio->extract_flags |= ARCHIVE_EXTRACT_OWNER;\n\t\t\tbreak;\n\t\tcase OPTION_QUIET: /* GNU cpio */\n\t\t\tcpio->quiet = 1;\n\t\t\tbreak;\n\t\tcase 'R': /* GNU cpio, also --owner */\n\t\t\t/* TODO: owner_parse should return uname/gname\n\t\t\t * also; use that to set [ug]name_override. */\n\t\t\terrmsg = owner_parse(cpio->argument, &uid, &gid);\n\t\t\tif (errmsg) {\n\t\t\t\tlafe_warnc(-1, \"%s\", errmsg);\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tif (uid != -1) {\n\t\t\t\tcpio->uid_override = uid;\n\t\t\t\tcpio->uname_override = NULL;\n\t\t\t}\n\t\t\tif (gid != -1) {\n\t\t\t\tcpio->gid_override = gid;\n\t\t\t\tcpio->gname_override = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r': /* POSIX 1997 */\n\t\t\tcpio->option_rename = 1;\n\t\t\tbreak;\n\t\tcase 't': /* POSIX 1997 */\n\t\t\tcpio->option_list = 1;\n\t\t\tbreak;\n\t\tcase 'u': /* POSIX 1997 */\n\t\t\tcpio->extract_flags\n\t\t\t    &= ~ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;\n\t\t\tbreak;\n\t\tcase OPTION_UUENCODE:\n\t\t\tcpio->add_filter = opt;\n\t\t\tbreak;\n\t\tcase 'v': /* POSIX 1997 */\n\t\t\tcpio->verbose++;\n\t\t\tbreak;\n\t\tcase 'V': /* GNU cpio */\n\t\t\tcpio->dot++;\n\t\t\tbreak;\n\t\tcase OPTION_VERSION: /* GNU convention */\n\t\t\tversion();\n\t\t\tbreak;\n#if 0\n\t        /*\n\t\t * cpio_getopt() handles -W specially, so it's not\n\t\t * available here.\n\t\t */\n\t\tcase 'W': /* Obscure, but useful GNU convention. */\n\t\t\tbreak;\n#endif\n\t\tcase 'y': /* tar convention */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'Z': /* tar convention */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tcase 'z': /* tar convention */\n\t\t\tcpio->compress = opt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\t/*\n\t * Sanity-check args, error out on nonsensical combinations.\n\t */\n\t/* -t implies -i if no mode was specified. */\n\tif (cpio->option_list && cpio->mode == '\\0')\n\t\tcpio->mode = 'i';\n\t/* -t requires -i */\n\tif (cpio->option_list && cpio->mode != 'i')\n\t\tlafe_errc(1, 0, \"Option -t requires -i\");\n\t/* -n requires -it */\n\tif (cpio->option_numeric_uid_gid && !cpio->option_list)\n\t\tlafe_errc(1, 0, \"Option -n requires -it\");\n\t/* Can only specify format when writing */\n\tif (cpio->format != NULL && cpio->mode != 'o')\n\t\tlafe_errc(1, 0, \"Option --format requires -o\");\n\t/* -l requires -p */\n\tif (cpio->option_link && cpio->mode != 'p')\n\t\tlafe_errc(1, 0, \"Option -l requires -p\");\n\t/* -v overrides -V */\n\tif (cpio->dot && cpio->verbose)\n\t\tcpio->dot = 0;\n\t/* TODO: Flag other nonsensical combinations. */\n\n\tswitch (cpio->mode) {\n\tcase 'o':\n\t\t/* TODO: Implement old binary format in libarchive,\n\t\t   use that here. */\n\t\tif (cpio->format == NULL)\n\t\t\tcpio->format = \"odc\"; /* Default format */\n\n\t\tmode_out(cpio);\n\t\tbreak;\n\tcase 'i':\n\t\twhile (*cpio->argv != NULL) {\n\t\t\tif (archive_match_include_pattern(cpio->matching,\n\t\t\t    *cpio->argv) != ARCHIVE_OK)\n\t\t\t\tlafe_errc(1, 0, \"Error : %s\",\n\t\t\t\t    archive_error_string(cpio->matching));\n\t\t\t--cpio->argc;\n\t\t\t++cpio->argv;\n\t\t}\n\t\tif (cpio->option_list)\n\t\t\tmode_list(cpio);\n\t\telse\n\t\t\tmode_in(cpio);\n\t\tbreak;\n\tcase 'p':\n\t\tif (*cpio->argv == NULL || **cpio->argv == '\\0')\n\t\t\tlafe_errc(1, 0,\n\t\t\t    \"-p mode requires a target directory\");\n\t\tmode_pass(cpio, *cpio->argv);\n\t\tbreak;\n\tdefault:\n\t\tlafe_errc(1, 0,\n\t\t    \"Must specify at least one of -i, -o, or -p\");\n\t}\n\n\tarchive_match_free(cpio->matching);\n\tfree_cache(cpio->gname_cache);\n\tfree_cache(cpio->uname_cache);\n\tfree(cpio->destdir);\n\tpassphrase_free(cpio->ppbuff);\n\treturn (cpio->return_value);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,6 +42,7 @@\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n+\tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_PERM;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_FFLAGS;\n \tcpio->extract_flags |= ARCHIVE_EXTRACT_ACL;\n@@ -127,6 +128,7 @@\n \t\tcase OPTION_INSECURE:\n \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n \t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n+\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;\n \t\t\tbreak;\n \t\tcase 'L': /* GNU cpio */\n \t\t\tcpio->option_follow_links = 1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcpio->extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;",
                "\t\t\tcpio->extract_flags &= ~ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40153",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-1.c in Squashfs-Tools 4.5 stores the filename in the directory entry; this is then used by unsquashfs to create the new file during the unsquash. The filename is not validated for traversal outside of the destination directory, and thus allows writing to locations outside of the destination.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/79b5a555058eef4e1e7ff220c344d39f8cd09646",
        "commit_title": "Unsquashfs: fix write outside destination directory exploit",
        "commit_text": " An issue on Github (https://github.com/plougher/squashfs-tools/issues/72) shows how some specially crafted Squashfs filesystems containing invalid file names (with '/' and ..) can cause Unsquashfs to write files outside of the destination directory.  This commit fixes this exploit by checking all names for validity.  In doing so I have also added checks for '.' and for names that are shorter than they should be (names in the file system should not have '\\0' terminators). ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tlong long bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %lld not \"\n\t\t\t\"found!\\n\", start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tSQUASHFS_SWAP_DIR_HEADER(directory_table + bytes, &dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tSQUASHFS_SWAP_DIR_ENTRY(directory_table + bytes, dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tlong long bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %lld not \"\n\t\t\t\"found!\\n\", start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tSQUASHFS_SWAP_DIR_HEADER(directory_table + bytes, &dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tSQUASHFS_SWAP_DIR_ENTRY(directory_table + bytes, dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,6 +76,13 @@\n \t\t\tmemcpy(dire->name, directory_table + bytes,\n \t\t\t\tdire->size + 1);\n \t\t\tdire->name[dire->size + 1] = '\\0';\n+\n+\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n+\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n+\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n+\t\t\t\tgoto corrupted;\n+\t\t\t}\n+\n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\t/* check name for invalid characters (i.e /, ., ..) */",
                "\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {",
                "\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");",
                "\t\t\t\tgoto corrupted;",
                "\t\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40153",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-1.c in Squashfs-Tools 4.5 stores the filename in the directory entry; this is then used by unsquashfs to create the new file during the unsquash. The filename is not validated for traversal outside of the destination directory, and thus allows writing to locations outside of the destination.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/79b5a555058eef4e1e7ff220c344d39f8cd09646",
        "commit_title": "Unsquashfs: fix write outside destination directory exploit",
        "commit_text": " An issue on Github (https://github.com/plougher/squashfs-tools/issues/72) shows how some specially crafted Squashfs filesystems containing invalid file names (with '/' and ..) can cause Unsquashfs to write files outside of the destination directory.  This commit fixes this exploit by checking all names for validity.  In doing so I have also added checks for '.' and for names that are shorter than they should be (names in the file system should not have '\\0' terminators). ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %d not \"\n\t\t\t\"found!\\n\", block_start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tmemcpy(&sdirh, directory_table + bytes, sizeof(sdirh));\n\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tmemcpy(&dirh, directory_table + bytes, sizeof(dirh));\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tmemcpy(&sdire, directory_table + bytes,\n\t\t\t\t\tsizeof(sdire));\n\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tmemcpy(dire, directory_table + bytes,\n\t\t\t\t\tsizeof(*dire));\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %d not \"\n\t\t\t\"found!\\n\", block_start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tmemcpy(&sdirh, directory_table + bytes, sizeof(sdirh));\n\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tmemcpy(&dirh, directory_table + bytes, sizeof(dirh));\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tmemcpy(&sdire, directory_table + bytes,\n\t\t\t\t\tsizeof(sdire));\n\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tmemcpy(dire, directory_table + bytes,\n\t\t\t\t\tsizeof(*dire));\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -86,6 +86,13 @@\n \t\t\tmemcpy(dire->name, directory_table + bytes,\n \t\t\t\tdire->size + 1);\n \t\t\tdire->name[dire->size + 1] = '\\0';\n+\n+\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n+\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n+\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n+\t\t\t\tgoto corrupted;\n+\t\t\t}\n+\n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\t/* check name for invalid characters (i.e /, ., ..) */",
                "\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {",
                "\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");",
                "\t\t\t\tgoto corrupted;",
                "\t\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40153",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-1.c in Squashfs-Tools 4.5 stores the filename in the directory entry; this is then used by unsquashfs to create the new file during the unsquash. The filename is not validated for traversal outside of the destination directory, and thus allows writing to locations outside of the destination.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/79b5a555058eef4e1e7ff220c344d39f8cd09646",
        "commit_title": "Unsquashfs: fix write outside destination directory exploit",
        "commit_text": " An issue on Github (https://github.com/plougher/squashfs-tools/issues/72) shows how some specially crafted Squashfs filesystems containing invalid file names (with '/' and ..) can cause Unsquashfs to write files outside of the destination directory.  This commit fixes this exploit by checking all names for validity.  In doing so I have also added checks for '.' and for names that are shorter than they should be (names in the file system should not have '\\0' terminators). ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %d not \"\n\t\t\t\"found!\\n\", block_start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tmemcpy(&sdirh, directory_table + bytes, sizeof(sdirh));\n\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tmemcpy(&dirh, directory_table + bytes, sizeof(dirh));\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tmemcpy(&sdire, directory_table + bytes,\n\t\t\t\t\tsizeof(sdire));\n\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tmemcpy(dire, directory_table + bytes,\n\t\t\t\t\tsizeof(*dire));\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %d not \"\n\t\t\t\"found!\\n\", block_start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tmemcpy(&sdirh, directory_table + bytes, sizeof(sdirh));\n\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tmemcpy(&dirh, directory_table + bytes, sizeof(dirh));\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tmemcpy(&sdire, directory_table + bytes,\n\t\t\t\t\tsizeof(sdire));\n\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tmemcpy(dire, directory_table + bytes,\n\t\t\t\t\tsizeof(*dire));\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -87,6 +87,13 @@\n \t\t\tmemcpy(dire->name, directory_table + bytes,\n \t\t\t\tdire->size + 1);\n \t\t\tdire->name[dire->size + 1] = '\\0';\n+\n+\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n+\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n+\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n+\t\t\t\tgoto corrupted;\n+\t\t\t}\n+\n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\t/* check name for invalid characters (i.e /, ., ..) */",
                "\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {",
                "\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");",
                "\t\t\t\tgoto corrupted;",
                "\t\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40153",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-1.c in Squashfs-Tools 4.5 stores the filename in the directory entry; this is then used by unsquashfs to create the new file during the unsquash. The filename is not validated for traversal outside of the destination directory, and thus allows writing to locations outside of the destination.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/79b5a555058eef4e1e7ff220c344d39f8cd09646",
        "commit_title": "Unsquashfs: fix write outside destination directory exploit",
        "commit_text": " An issue on Github (https://github.com/plougher/squashfs-tools/issues/72) shows how some specially crafted Squashfs filesystems containing invalid file names (with '/' and ..) can cause Unsquashfs to write files outside of the destination directory.  This commit fixes this exploit by checking all names for validity.  In doing so I have also added checks for '.' and for names that are shorter than they should be (names in the file system should not have '\\0' terminators). ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\t\t\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %d not \"\n\t\t\t\"found!\\n\", block_start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tmemcpy(&sdirh, directory_table + bytes, sizeof(sdirh));\n\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tmemcpy(&dirh, directory_table + bytes, sizeof(dirh));\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tmemcpy(&sdire, directory_table + bytes,\n\t\t\t\t\tsizeof(sdire));\n\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tmemcpy(dire, directory_table + bytes,\n\t\t\t\t\tsizeof(*dire));\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\t\t\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %d not \"\n\t\t\t\"found!\\n\", block_start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tmemcpy(&sdirh, directory_table + bytes, sizeof(sdirh));\n\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tmemcpy(&dirh, directory_table + bytes, sizeof(dirh));\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tmemcpy(&sdire, directory_table + bytes,\n\t\t\t\t\tsizeof(sdire));\n\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tmemcpy(dire, directory_table + bytes,\n\t\t\t\t\tsizeof(*dire));\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -86,6 +86,13 @@\n \t\t\tmemcpy(dire->name, directory_table + bytes,\n \t\t\t\tdire->size + 1);\n \t\t\tdire->name[dire->size + 1] = '\\0';\n+\n+\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n+\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n+\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n+\t\t\t\tgoto corrupted;\n+\t\t\t}\n+\n \t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n \t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n \t\t\t\tdirh.start_block, dire->offset, dire->type);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\t/* check name for invalid characters (i.e /, ., ..) */",
                "\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {",
                "\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");",
                "\t\t\t\tgoto corrupted;",
                "\t\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -110,6 +110,12 @@\n \t\t}\n \t}\n \n+\t/* check directory for duplicate names and sorting */\n+\tif(check_directory(dir) == FALSE) {\n+\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n+\t\tgoto corrupted;\n+\t}\n+\n \treturn dir;\n \n corrupted:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/* check directory for duplicate names and sorting */",
                "\tif(check_directory(dir) == FALSE) {",
                "\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");",
                "\t\tgoto corrupted;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\tif(needs_sorting)\n\t\tsort_directory(dir);\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tif(needs_sorting)\n\t\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");\n\t\telse\n\t\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,6 +124,17 @@\n \t\t}\n \t}\n \n+\tif(needs_sorting)\n+\t\tsort_directory(dir);\n+\n+\t/* check directory for duplicate names and sorting */\n+\tif(check_directory(dir) == FALSE) {\n+\t\tif(needs_sorting)\n+\t\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");\n+\t\telse\n+\t\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n+\t\tgoto corrupted;\n+\t}\n \treturn dir;\n \n corrupted:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif(needs_sorting)",
                "\t\tsort_directory(dir);",
                "",
                "\t/* check directory for duplicate names and sorting */",
                "\tif(check_directory(dir) == FALSE) {",
                "\t\tif(needs_sorting)",
                "\t\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");",
                "\t\telse",
                "\t\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");",
                "\t\tgoto corrupted;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/read_super_2",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "int read_super_2(squashfs_operations **s_ops, void *s)\n{\n\t squashfs_super_block_3 *sBlk_3 = s;\n\n\tif(sBlk_3->s_magic != SQUASHFS_MAGIC || sBlk_3->s_major != 2 ||\n\t\t\t\t\t\t\tsBlk_3->s_minor > 1)\n\t\treturn -1;\n\n\tsBlk.s.s_magic = sBlk_3->s_magic;\n\tsBlk.s.inodes = sBlk_3->inodes;\n\tsBlk.s.mkfs_time = sBlk_3->mkfs_time;\n\tsBlk.s.block_size = sBlk_3->block_size;\n\tsBlk.s.fragments = sBlk_3->fragments;\n\tsBlk.s.block_log = sBlk_3->block_log;\n\tsBlk.s.flags = sBlk_3->flags;\n\tsBlk.s.s_major = sBlk_3->s_major;\n\tsBlk.s.s_minor = sBlk_3->s_minor;\n\tsBlk.s.root_inode = sBlk_3->root_inode;\n\tsBlk.s.bytes_used = sBlk_3->bytes_used_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start;\n\tsBlk.s.directory_table_start = sBlk_3->directory_table_start_2;\n\tsBlk.s.fragment_table_start = sBlk_3->fragment_table_start_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start_2;\n\tsBlk.no_uids = sBlk_3->no_uids;\n\tsBlk.no_guids = sBlk_3->no_guids;\n\tsBlk.uid_start = sBlk_3->uid_start_2;\n\tsBlk.guid_start = sBlk_3->guid_start_2;\n\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\n\t*s_ops = &ops;\n\n\t/*\n\t * 2.x filesystems use gzip compression.\n\t */\n\tcomp = lookup_compressor(\"gzip\");\n\treturn TRUE;\n}",
        "func": "int read_super_2(squashfs_operations **s_ops, void *s)\n{\n\t squashfs_super_block_3 *sBlk_3 = s;\n\n\tif(sBlk_3->s_magic != SQUASHFS_MAGIC || sBlk_3->s_major != 2 ||\n\t\t\t\t\t\t\tsBlk_3->s_minor > 1)\n\t\treturn -1;\n\n\tsBlk.s.s_magic = sBlk_3->s_magic;\n\tsBlk.s.inodes = sBlk_3->inodes;\n\tsBlk.s.mkfs_time = sBlk_3->mkfs_time;\n\tsBlk.s.block_size = sBlk_3->block_size;\n\tsBlk.s.fragments = sBlk_3->fragments;\n\tsBlk.s.block_log = sBlk_3->block_log;\n\tsBlk.s.flags = sBlk_3->flags;\n\tsBlk.s.s_major = sBlk_3->s_major;\n\tsBlk.s.s_minor = sBlk_3->s_minor;\n\tsBlk.s.root_inode = sBlk_3->root_inode;\n\tsBlk.s.bytes_used = sBlk_3->bytes_used_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start;\n\tsBlk.s.directory_table_start = sBlk_3->directory_table_start_2;\n\tsBlk.s.fragment_table_start = sBlk_3->fragment_table_start_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start_2;\n\tsBlk.no_uids = sBlk_3->no_uids;\n\tsBlk.no_guids = sBlk_3->no_guids;\n\tsBlk.uid_start = sBlk_3->uid_start_2;\n\tsBlk.guid_start = sBlk_3->guid_start_2;\n\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\n\t*s_ops = &ops;\n\n\t/*\n\t * 2.x filesystems use gzip compression.\n\t */\n\tcomp = lookup_compressor(\"gzip\");\n\n\tif(sBlk_3->s_minor == 0)\n\t\tneeds_sorting = TRUE;\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,5 +33,9 @@\n \t * 2.x filesystems use gzip compression.\n \t */\n \tcomp = lookup_compressor(\"gzip\");\n+\n+\tif(sBlk_3->s_minor == 0)\n+\t\tneeds_sorting = TRUE;\n+\n \treturn TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif(sBlk_3->s_minor == 0)",
                "\t\tneeds_sorting = TRUE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,6 +124,12 @@\n \t\t}\n \t}\n \n+\t/* check directory for duplicate names and sorting */\n+\tif(check_directory(dir) == FALSE) {\n+\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n+\t\tgoto corrupted;\n+\t}\n+\n \treturn dir;\n \n corrupted:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/* check directory for duplicate names and sorting */",
                "\tif(check_directory(dir) == FALSE) {",
                "\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");",
                "\t\tgoto corrupted;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\t\t\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\t\t\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names.  Need to sort directory first */\n\tsort_directory(dir);\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");\n\t\tgoto corrupted;\n\t}\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,6 +124,12 @@\n \t\t}\n \t}\n \n+\t/* check directory for duplicate names.  Need to sort directory first */\n+\tsort_directory(dir);\n+\tif(check_directory(dir) == FALSE) {\n+\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");\n+\t\tgoto corrupted;\n+\t}\n \treturn dir;\n \n corrupted:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/* check directory for duplicate names.  Need to sort directory first */",
                "\tsort_directory(dir);",
                "\tif(check_directory(dir) == FALSE) {",
                "\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");",
                "\t\tgoto corrupted;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-1000472",
        "func_name": "pocoproject/poco/ZipCommon::isValidPath",
        "description": "The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a \"file path injection vulnerability\".",
        "git_url": "https://github.com/pocoproject/poco/commit/f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d",
        "commit_title": "- fix Zip Decompress Parent Path Injection #1968 bug",
        "commit_text": "- add valid patch check test - add vulnearbility triggering zip archive and test - remove temporary test output files - if possible, redirect temporary file generation to temp directory or - delete temporary files after tests",
        "func_before": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\tif (path == \"..\")\n\t\treturn false;\n\tif (path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif (path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/..\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\") != std::string::npos)\n\t\treturn false;\n\treturn true;\n}",
        "func": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\n\tif (!Path(path).isRelative())\n\t\treturn false;\n\tif (path == \"..\")\n\t\treturn false;\n\tif ((path.size() >= 3) && path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif ((path.size() >= 3) && path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/../\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\\\\\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"/..\\\\\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\../\") != std::string::npos)\n\t\treturn false;\n\tif ((path.size() >= 2) && path.compare(0, 2, \"~/\") == 0)\n\t\treturn false;\n\tif (path.size() > 0 && (path[0] == '/' || path[0] == '\\\\'))\n\t\treturn false;\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,14 +1,25 @@\n bool ZipCommon::isValidPath(const std::string& path)\n {\n+\n+\tif (!Path(path).isRelative())\n+\t\treturn false;\n \tif (path == \"..\")\n \t\treturn false;\n-\tif (path.compare(0, 3, \"../\") == 0)\n+\tif ((path.size() >= 3) && path.compare(0, 3, \"../\") == 0)\n \t\treturn false;\n-\tif (path.compare(0, 3, \"..\\\\\") == 0)\n+\tif ((path.size() >= 3) && path.compare(0, 3, \"..\\\\\") == 0)\n \t\treturn false;\n-\tif (path.find(\"/..\") != std::string::npos)\n+\tif (path.find(\"/../\") != std::string::npos)\n \t\treturn false;\n-\tif (path.find(\"\\\\..\") != std::string::npos)\n+\tif (path.find(\"\\\\..\\\\\") != std::string::npos)\n+\t\treturn false;\n+\tif (path.find(\"/..\\\\\") != std::string::npos)\n+\t\treturn false;\n+\tif (path.find(\"\\\\../\") != std::string::npos)\n+\t\treturn false;\n+\tif ((path.size() >= 2) && path.compare(0, 2, \"~/\") == 0)\n+\t\treturn false;\n+\tif (path.size() > 0 && (path[0] == '/' || path[0] == '\\\\'))\n \t\treturn false;\n \treturn true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (path.compare(0, 3, \"../\") == 0)",
                "\tif (path.compare(0, 3, \"..\\\\\") == 0)",
                "\tif (path.find(\"/..\") != std::string::npos)",
                "\tif (path.find(\"\\\\..\") != std::string::npos)"
            ],
            "added_lines": [
                "",
                "\tif (!Path(path).isRelative())",
                "\t\treturn false;",
                "\tif ((path.size() >= 3) && path.compare(0, 3, \"../\") == 0)",
                "\tif ((path.size() >= 3) && path.compare(0, 3, \"..\\\\\") == 0)",
                "\tif (path.find(\"/../\") != std::string::npos)",
                "\tif (path.find(\"\\\\..\\\\\") != std::string::npos)",
                "\t\treturn false;",
                "\tif (path.find(\"/..\\\\\") != std::string::npos)",
                "\t\treturn false;",
                "\tif (path.find(\"\\\\../\") != std::string::npos)",
                "\t\treturn false;",
                "\tif ((path.size() >= 2) && path.compare(0, 2, \"~/\") == 0)",
                "\t\treturn false;",
                "\tif (path.size() > 0 && (path[0] == '/' || path[0] == '\\\\'))"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-1000472",
        "func_name": "pocoproject/poco/Decompress::handleZipEntry",
        "description": "The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a \"file path injection vulnerability\".",
        "git_url": "https://github.com/pocoproject/poco/commit/f5b2cf3dd6976ae53b2f3c9618b0087a0646cc7d",
        "commit_title": "- fix Zip Decompress Parent Path Injection #1968 bug",
        "commit_text": "- add valid patch check test - add vulnearbility triggering zip archive and test - remove temporary test output files - if possible, redirect temporary file generation to temp directory or - delete temporary files after tests",
        "func_before": "bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)\n{\n\tif (hdr.isDirectory())\n\t{\n\t\t// directory have 0 size, nth to read\n\t\tif (!_flattenDirs)\n\t\t{\n\t\t\tstd::string dirName = hdr.getFileName();\n\t\t\tif (!ZipCommon::isValidPath(dirName))\n\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName + \" containing parent directory reference\");\n\t\t\tPoco::Path dir(_outDir, dirName);\n\t\t\tdir.makeDirectory();\n\t\t\tPoco::File aFile(dir);\n\t\t\taFile.createDirectories();\n\t\t}\n\t\treturn true;\n\t}\n\ttry\n\t{\n\t\tstd::string fileName = hdr.getFileName();\n\t\tif (_flattenDirs)\n\t\t{\n\t\t\t// remove path info\n\t\t\tPoco::Path p(fileName);\n\t\t\tp.makeFile();\n\t\t\tfileName = p.getFileName();\n\t\t}\n\n\t\tif (!ZipCommon::isValidPath(fileName))\n\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");\n\n\t\tPoco::Path file(fileName);\n\t\tfile.makeFile();\n\t\tPoco::Path dest(_outDir, file);\n\t\tdest.makeFile();\n\t\tif (dest.depth() > 0)\n\t\t{\n\t\t\tPoco::File aFile(dest.parent());\n\t\t\taFile.createDirectories();\n\t\t}\n\t\tPoco::FileOutputStream out(dest.toString());\n\t\tZipInputStream inp(zipStream, hdr, false);\n\t\tPoco::StreamCopier::copyStream(inp, out);\n\t\tout.close();\n\t\tPoco::File aFile(dest.toString());\n\t\tif (!aFile.exists() || !aFile.isFile())\n\t\t{\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Failed to create output stream \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!inp.crcValid())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"CRC mismatch. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\t// cannot check against hdr.getUnCompressedSize if CRC and size are not set in hdr but in a ZipDataInfo\n\t\t// crc is typically enough to detect errors\n\t\tif (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Filesizes do not match. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tstd::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);\n\t\tEOk.notify(this, tmp);\n\t}\n\tcatch (Poco::Exception& e)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Exception: \" + e.displayText()));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Unknown Exception\"));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "func": "bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)\n{\n\tif (hdr.isDirectory())\n\t{\n\t\t// directory have 0 size, nth to read\n\t\tif (!_flattenDirs)\n\t\t{\n\t\t\tstd::string dirName = hdr.getFileName();\n\t\t\tif (!ZipCommon::isValidPath(dirName))\n\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName);\n\t\t\tPoco::Path dir(_outDir, dirName);\n\t\t\tdir.makeDirectory();\n\t\t\tPoco::File aFile(dir);\n\t\t\taFile.createDirectories();\n\t\t}\n\t\treturn true;\n\t}\n\ttry\n\t{\n\t\tstd::string fileName = hdr.getFileName();\n\t\tif (_flattenDirs)\n\t\t{\n\t\t\t// remove path info\n\t\t\tPoco::Path p(fileName);\n\t\t\tp.makeFile();\n\t\t\tfileName = p.getFileName();\n\t\t}\n\n\t\tif (!ZipCommon::isValidPath(fileName))\n\t\t\tthrow ZipException(\"Illegal entry name \" + fileName);\n\n\t\tPoco::Path file(fileName);\n\t\tfile.makeFile();\n\t\tPoco::Path dest(_outDir, file);\n\t\tdest.makeFile();\n\t\tif (dest.depth() > 0)\n\t\t{\n\t\t\tPoco::File aFile(dest.parent());\n\t\t\taFile.createDirectories();\n\t\t}\n\t\tPoco::FileOutputStream out(dest.toString());\n\t\tZipInputStream inp(zipStream, hdr, false);\n\t\tPoco::StreamCopier::copyStream(inp, out);\n\t\tout.close();\n\t\tPoco::File aFile(dest.toString());\n\t\tif (!aFile.exists() || !aFile.isFile())\n\t\t{\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Failed to create output stream \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!inp.crcValid())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"CRC mismatch. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\t// cannot check against hdr.getUnCompressedSize if CRC and size are not set in hdr but in a ZipDataInfo\n\t\t// crc is typically enough to detect errors\n\t\tif (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Filesizes do not match. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tstd::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);\n\t\tEOk.notify(this, tmp);\n\t}\n\tcatch (Poco::Exception& e)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Exception: \" + e.displayText()));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Unknown Exception\"));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \t\t{\n \t\t\tstd::string dirName = hdr.getFileName();\n \t\t\tif (!ZipCommon::isValidPath(dirName))\n-\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName + \" containing parent directory reference\");\n+\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName);\n \t\t\tPoco::Path dir(_outDir, dirName);\n \t\t\tdir.makeDirectory();\n \t\t\tPoco::File aFile(dir);\n@@ -27,7 +27,7 @@\n \t\t}\n \n \t\tif (!ZipCommon::isValidPath(fileName))\n-\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");\n+\t\t\tthrow ZipException(\"Illegal entry name \" + fileName);\n \n \t\tPoco::Path file(fileName);\n \t\tfile.makeFile();",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName + \" containing parent directory reference\");",
                "\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");"
            ],
            "added_lines": [
                "\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName);",
                "\t\t\tthrow ZipException(\"Illegal entry name \" + fileName);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-1000472",
        "func_name": "pocoproject/poco/ZipCommon::isValidPath",
        "description": "The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a \"file path injection vulnerability\".",
        "git_url": "https://github.com/pocoproject/poco/commit/bb7e5feece68ccfd8660caee93da25c5c39a4707",
        "commit_title": "merge zip entry absolute path vulnerability fix (#1968) from develop",
        "commit_text": "",
        "func_before": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\tif (path == \"..\")\n\t\treturn false;\n\tif (path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif (path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/..\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\") != std::string::npos)\n\t\treturn false;\n\treturn true;\n}",
        "func": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\ttry\n\t{\n\t\tif (Path(path, Path::PATH_UNIX).isAbsolute() || Path(path, Path::PATH_WINDOWS).isAbsolute())\n\t\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\treturn false;\n\t}\n\n\tif (path == \"..\")\n\t\treturn false;\n\tif ((path.size() >= 3) && path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif ((path.size() >= 3) && path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/../\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\\\\\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"/..\\\\\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\../\") != std::string::npos)\n\t\treturn false;\n\tif ((path.size() >= 2) && path.compare(0, 2, \"~/\") == 0)\n\t\treturn false;\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,14 +1,31 @@\n bool ZipCommon::isValidPath(const std::string& path)\n {\n+\ttry\n+\t{\n+\t\tif (Path(path, Path::PATH_UNIX).isAbsolute() || Path(path, Path::PATH_WINDOWS).isAbsolute())\n+\t\t\treturn false;\n+\t}\n+\tcatch (...)\n+\t{\n+\t\treturn false;\n+\t}\n+\n \tif (path == \"..\")\n \t\treturn false;\n-\tif (path.compare(0, 3, \"../\") == 0)\n+\tif ((path.size() >= 3) && path.compare(0, 3, \"../\") == 0)\n \t\treturn false;\n-\tif (path.compare(0, 3, \"..\\\\\") == 0)\n+\tif ((path.size() >= 3) && path.compare(0, 3, \"..\\\\\") == 0)\n \t\treturn false;\n-\tif (path.find(\"/..\") != std::string::npos)\n+\tif (path.find(\"/../\") != std::string::npos)\n \t\treturn false;\n-\tif (path.find(\"\\\\..\") != std::string::npos)\n+\tif (path.find(\"\\\\..\\\\\") != std::string::npos)\n \t\treturn false;\n+\tif (path.find(\"/..\\\\\") != std::string::npos)\n+\t\treturn false;\n+\tif (path.find(\"\\\\../\") != std::string::npos)\n+\t\treturn false;\n+\tif ((path.size() >= 2) && path.compare(0, 2, \"~/\") == 0)\n+\t\treturn false;\n+\n \treturn true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (path.compare(0, 3, \"../\") == 0)",
                "\tif (path.compare(0, 3, \"..\\\\\") == 0)",
                "\tif (path.find(\"/..\") != std::string::npos)",
                "\tif (path.find(\"\\\\..\") != std::string::npos)"
            ],
            "added_lines": [
                "\ttry",
                "\t{",
                "\t\tif (Path(path, Path::PATH_UNIX).isAbsolute() || Path(path, Path::PATH_WINDOWS).isAbsolute())",
                "\t\t\treturn false;",
                "\t}",
                "\tcatch (...)",
                "\t{",
                "\t\treturn false;",
                "\t}",
                "",
                "\tif ((path.size() >= 3) && path.compare(0, 3, \"../\") == 0)",
                "\tif ((path.size() >= 3) && path.compare(0, 3, \"..\\\\\") == 0)",
                "\tif (path.find(\"/../\") != std::string::npos)",
                "\tif (path.find(\"\\\\..\\\\\") != std::string::npos)",
                "\tif (path.find(\"/..\\\\\") != std::string::npos)",
                "\t\treturn false;",
                "\tif (path.find(\"\\\\../\") != std::string::npos)",
                "\t\treturn false;",
                "\tif ((path.size() >= 2) && path.compare(0, 2, \"~/\") == 0)",
                "\t\treturn false;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-1000472",
        "func_name": "pocoproject/poco/ZipStreamBuf::readFromDevice",
        "description": "The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a \"file path injection vulnerability\".",
        "git_url": "https://github.com/pocoproject/poco/commit/bb7e5feece68ccfd8660caee93da25c5c39a4707",
        "commit_title": "merge zip entry absolute path vulnerability fix (#1968) from develop",
        "commit_text": "",
        "func_before": "int ZipStreamBuf::readFromDevice(char* buffer, std::streamsize length)\n{\n\tif (!_ptrBuf) return 0; // directory entry\n\t_ptrBuf->read(buffer, length);\n\tint cnt = static_cast<int>(_ptrBuf->gcount());\n\tif (cnt > 0)\n\t{\n\t\t_crc32.update(buffer, cnt);\n\t}\n\telse\n\t{\n\t\tif (_crc32.checksum() != _expectedCrc32)\n\t\t{\n\t\t\tif (_checkCRC)\n\t\t\t\tthrow ZipException(\"CRC failure\");\n\t\t\telse\n\t\t\t{\n\t\t\t\t// the CRC value is written directly after the data block\n\t\t\t\t// parse it directly from the input stream\n\t\t\t\tZipDataInfo nfo(*_pIstr, false);\n\t\t\t\t// now push back the header to the stream, so that the ZipLocalFileHeader can read it\n\t\t\t\tPoco::Int32 size = static_cast<Poco::Int32>(nfo.getFullHeaderSize());\n\t\t\t\t_expectedCrc32 = nfo.getCRC32();\n\t\t\t\tconst char* rawHeader = nfo.getRawHeader();\n\t\t\t\t_pIstr->seekg(-size, std::ios::cur);\n\t\t\t\tif (!_pIstr->good()) throw Poco::IOException(\"Failed to seek on input stream\");\n\t\t\t\tif (!crcValid())\n\t\t\t\t\tthrow ZipException(\"CRC failure\");\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}",
        "func": "int ZipStreamBuf::readFromDevice(char* buffer, std::streamsize length)\n{\n\tif (!_ptrBuf) return 0; // directory entry\n\t_ptrBuf->read(buffer, length);\n\tint cnt = static_cast<int>(_ptrBuf->gcount());\n\tif (cnt > 0)\n\t{\n\t\t_crc32.update(buffer, cnt);\n\t}\n\telse\n\t{\n\t\tif (_crc32.checksum() != _expectedCrc32)\n\t\t{\n\t\t\tif (_checkCRC)\n\t\t\t\tthrow ZipException(\"CRC failure\");\n\t\t\telse\n\t\t\t{\n\t\t\t\t// the CRC value is written directly after the data block\n\t\t\t\t// parse it directly from the input stream\n\t\t\t\tZipDataInfo nfo(*_pIstr, false);\n\t\t\t\t// now push back the header to the stream, so that the ZipLocalFileHeader can read it\n\t\t\t\tPoco::Int32 size = static_cast<Poco::Int32>(nfo.getFullHeaderSize());\n\t\t\t\t_expectedCrc32 = nfo.getCRC32();\n\t\t\t\t_pIstr->seekg(-size, std::ios::cur);\n\t\t\t\tif (!_pIstr->good()) throw Poco::IOException(\"Failed to seek on input stream\");\n\t\t\t\tif (!crcValid())\n\t\t\t\t\tthrow ZipException(\"CRC failure\");\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,6 @@\n \t\t\t\t// now push back the header to the stream, so that the ZipLocalFileHeader can read it\n \t\t\t\tPoco::Int32 size = static_cast<Poco::Int32>(nfo.getFullHeaderSize());\n \t\t\t\t_expectedCrc32 = nfo.getCRC32();\n-\t\t\t\tconst char* rawHeader = nfo.getRawHeader();\n \t\t\t\t_pIstr->seekg(-size, std::ios::cur);\n \t\t\t\tif (!_pIstr->good()) throw Poco::IOException(\"Failed to seek on input stream\");\n \t\t\t\tif (!crcValid())",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tconst char* rawHeader = nfo.getRawHeader();"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-1000472",
        "func_name": "pocoproject/poco/Decompress::handleZipEntry",
        "description": "The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a \"file path injection vulnerability\".",
        "git_url": "https://github.com/pocoproject/poco/commit/bb7e5feece68ccfd8660caee93da25c5c39a4707",
        "commit_title": "merge zip entry absolute path vulnerability fix (#1968) from develop",
        "commit_text": "",
        "func_before": "bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)\n{\n\tif (hdr.isDirectory())\n\t{\n\t\t// directory have 0 size, nth to read\n\t\tif (!_flattenDirs)\n\t\t{\n\t\t\tstd::string dirName = hdr.getFileName();\n\t\t\tif (!ZipCommon::isValidPath(dirName))\n\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName + \" containing parent directory reference\");\n\t\t\tPoco::Path dir(_outDir, dirName);\n\t\t\tdir.makeDirectory();\n\t\t\tPoco::File aFile(dir);\n\t\t\taFile.createDirectories();\n\t\t}\n\t\treturn true;\n\t}\n\ttry\n\t{\n\t\tstd::string fileName = hdr.getFileName();\n\t\tif (_flattenDirs)\n\t\t{\n\t\t\t// remove path info\n\t\t\tPoco::Path p(fileName);\n\t\t\tp.makeFile();\n\t\t\tfileName = p.getFileName();\n\t\t}\n\n\t\tif (!ZipCommon::isValidPath(fileName))\n\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");\n\n\t\tPoco::Path file(fileName);\n\t\tfile.makeFile();\n\t\tPoco::Path dest(_outDir, file);\n\t\tdest.makeFile();\n\t\tif (dest.depth() > 0)\n\t\t{\n\t\t\tPoco::File aFile(dest.parent());\n\t\t\taFile.createDirectories();\n\t\t}\n\t\tPoco::FileOutputStream out(dest.toString());\n\t\tZipInputStream inp(zipStream, hdr, false);\n\t\tPoco::StreamCopier::copyStream(inp, out);\n\t\tout.close();\n\t\tPoco::File aFile(dest.toString());\n\t\tif (!aFile.exists() || !aFile.isFile())\n\t\t{\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Failed to create output stream \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!inp.crcValid())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"CRC mismatch. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\t// cannot check against hdr.getUnCompressedSize if CRC and size are not set in hdr but in a ZipDataInfo\n\t\t// crc is typically enough to detect errors\n\t\tif (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Filesizes do not match. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tstd::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);\n\t\tEOk.notify(this, tmp);\n\t}\n\tcatch (Poco::Exception& e)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Exception: \" + e.displayText()));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Unknown Exception\"));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "func": "bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr)\n{\n\tif (hdr.isDirectory())\n\t{\n\t\t// directory have 0 size, nth to read\n\t\tif (!_flattenDirs)\n\t\t{\n\t\t\tstd::string dirName = hdr.getFileName();\n\t\t\tif (!ZipCommon::isValidPath(dirName))\n\t\t\t\tthrow ZipException(\"Illegal entry name\", dirName);\n\t\t\tPoco::Path dir(_outDir, dirName);\n\t\t\tdir.makeDirectory();\n\t\t\tPoco::File aFile(dir);\n\t\t\taFile.createDirectories();\n\t\t}\n\t\treturn true;\n\t}\n\ttry\n\t{\n\t\tstd::string fileName = hdr.getFileName();\n\t\tif (_flattenDirs)\n\t\t{\n\t\t\t// remove path info\n\t\t\tPoco::Path p(fileName);\n\t\t\tp.makeFile();\n\t\t\tfileName = p.getFileName();\n\t\t}\n\n\t\tif (!ZipCommon::isValidPath(fileName))\n\t\t\tthrow ZipException(\"Illegal entry name\", fileName);\n\n\t\tPoco::Path file(fileName);\n\t\tfile.makeFile();\n\t\tPoco::Path dest(_outDir, file);\n\t\tdest.makeFile();\n\t\tif (dest.depth() > 0)\n\t\t{\n\t\t\tPoco::File aFile(dest.parent());\n\t\t\taFile.createDirectories();\n\t\t}\n\t\tPoco::FileOutputStream out(dest.toString());\n\t\tZipInputStream inp(zipStream, hdr, false);\n\t\tPoco::StreamCopier::copyStream(inp, out);\n\t\tout.close();\n\t\tPoco::File aFile(dest.toString());\n\t\tif (!aFile.exists() || !aFile.isFile())\n\t\t{\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Failed to create output stream \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!inp.crcValid())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"CRC mismatch. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\t// cannot check against hdr.getUnCompressedSize if CRC and size are not set in hdr but in a ZipDataInfo\n\t\t// crc is typically enough to detect errors\n\t\tif (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData())\n\t\t{\n\t\t\tif (!_keepIncompleteFiles)\n\t\t\t\taFile.remove();\n\t\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, \"Filesizes do not match. Corrupt file: \" + dest.toString());\n\t\t\tEError.notify(this, tmp);\n\t\t\treturn false;\n\t\t}\n\n\t\tstd::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file);\n\t\tEOk.notify(this, tmp);\n\t}\n\tcatch (Poco::Exception& e)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Exception: \" + e.displayText()));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\tcatch (...)\n\t{\n\t\tstd::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(\"Unknown Exception\"));\n\t\tEError.notify(this, tmp);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \t\t{\n \t\t\tstd::string dirName = hdr.getFileName();\n \t\t\tif (!ZipCommon::isValidPath(dirName))\n-\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName + \" containing parent directory reference\");\n+\t\t\t\tthrow ZipException(\"Illegal entry name\", dirName);\n \t\t\tPoco::Path dir(_outDir, dirName);\n \t\t\tdir.makeDirectory();\n \t\t\tPoco::File aFile(dir);\n@@ -27,7 +27,7 @@\n \t\t}\n \n \t\tif (!ZipCommon::isValidPath(fileName))\n-\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");\n+\t\t\tthrow ZipException(\"Illegal entry name\", fileName);\n \n \t\tPoco::Path file(fileName);\n \t\tfile.makeFile();",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tthrow ZipException(\"Illegal entry name \" + dirName + \" containing parent directory reference\");",
                "\t\t\tthrow ZipException(\"Illegal entry name \" + fileName + \" containing parent directory reference\");"
            ],
            "added_lines": [
                "\t\t\t\tthrow ZipException(\"Illegal entry name\", dirName);",
                "\t\t\tthrow ZipException(\"Illegal entry name\", fileName);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25087",
        "func_name": "RamseyK/httpserver/HTTPServer::handleRequest",
        "description": "A vulnerability was found in RamseyK httpserver. It has been rated as critical. This issue affects the function ResourceHost::getResource of the file src/ResourceHost.cpp of the component URI Handler. The manipulation of the argument uri leads to path traversal: '../filedir'. The attack may be initiated remotely. The name of the patch is 1a0de56e4dafff9c2f9c8f6b130a764f7a50df52. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216863.",
        "git_url": "https://github.com/RamseyK/httpserver/commit/1a0de56e4dafff9c2f9c8f6b130a764f7a50df52",
        "commit_title": "Deny any directory traversal paths.  README update",
        "commit_text": "",
        "func_before": "void HTTPServer::handleRequest(Client *cl, HTTPRequest* req) {\n\t// Parse the request\n\t// If there's an error, report it and send a server error in response\n\tif (!req->parse()) {\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] There was an error processing the request of type: \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tstd::cout << req->getParseError() << std::endl;\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), req->getParseError());\n\t\treturn;\n\t}\n\n\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) << \" \" << req->getRequestUri() << std::endl;\n\t/*std::cout << \"Headers:\" << std::endl;\n\tfor(int i = 0; i < req->getNumHeaders(); i++) {\n\t\tstd::cout << req->getHeaderStr(i) << std::endl;\n\t}\n\tstd::cout << std::endl;*/\n\n\t// Determine the appropriate vhost\n\tResourceHost* resHost = NULL;\n\tstd::string host = \"\";\n\n\t// Retrieve the host specified in the request (Required for HTTP/1.1 compliance)\n\tif (req->getVersion().compare(HTTP_VERSION_11) == 0) {\n\t\thost = req->getHeaderValue(\"Host\");\n\n\t\t// All vhosts have the port appended, so need to append it to the host if it doesnt exist\n\t\tif (host.find(\":\") == std::string::npos) {\n\t\t\thost.append(\":\" + std::to_string(listenPort));\n\t\t}\n\n\t\tstd::unordered_map<std::string, ResourceHost*>::const_iterator it = vhosts.find(host);\n\n\t\tif (it != vhosts.end())\n\t\t\tresHost = it->second;\n\t} else {\n\t\t// Temporary: HTTP/1.0 are given the first ResouceHost in the hostList\n\t\t// TODO: Allow admin to specify a 'default resource host'\n\t\tif (hostList.size() > 0)\n\t\t\tresHost = hostList[0];\n\t}\n\n\t// ResourceHost couldnt be determined or the Host specified by the client was invalid\n\tif (resHost == NULL) {\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), \"Invalid/No Host specified: \" + host);\n\t\treturn;\n\t}\n\n\t// Send the request to the correct handler function\n\tswitch (req->getMethod()) {\n\tcase Method(HEAD):\n\tcase Method(GET):\n\t\thandleGet(cl, req, resHost);\n\t\tbreak;\n\tcase Method(OPTIONS):\n\t\thandleOptions(cl, req);\n\t\tbreak;\n\tcase Method(TRACE):\n\t\thandleTrace(cl, req);\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] Could not handle or determine request of type \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_IMPLEMENTED));\n\t\tbreak;\n\t}\n}",
        "func": "void HTTPServer::handleRequest(Client *cl, HTTPRequest* req) {\n\t// Parse the request\n\t// If there's an error, report it and send a server error in response\n\tif (!req->parse()) {\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] There was an error processing the request of type: \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tstd::cout << req->getParseError() << std::endl;\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), req->getParseError());\n\t\treturn;\n\t}\n\n\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) << \" \" << req->getRequestUri() << std::endl;\n\t/*std::cout << \"Headers:\" << std::endl;\n\tfor(int i = 0; i < req->getNumHeaders(); i++) {\n\t\tstd::cout << \"\\t\" << req->getHeaderStr(i) << std::endl;\n\t}\n\tstd::cout << std::endl;*/\n\n\t// Determine the appropriate vhost\n\tResourceHost* resHost = NULL;\n\tstd::string host = \"\";\n\n\t// Retrieve the host specified in the request (Required for HTTP/1.1 compliance)\n\tif (req->getVersion().compare(HTTP_VERSION_11) == 0) {\n\t\thost = req->getHeaderValue(\"Host\");\n\n\t\t// All vhosts have the port appended, so need to append it to the host if it doesnt exist\n\t\tif (host.find(\":\") == std::string::npos) {\n\t\t\thost.append(\":\" + std::to_string(listenPort));\n\t\t}\n\n\t\tstd::unordered_map<std::string, ResourceHost*>::const_iterator it = vhosts.find(host);\n\n\t\tif (it != vhosts.end())\n\t\t\tresHost = it->second;\n\t} else {\n\t\t// Temporary: HTTP/1.0 are given the first ResouceHost in the hostList\n\t\t// TODO: Allow admin to specify a 'default resource host'\n\t\tif (hostList.size() > 0)\n\t\t\tresHost = hostList[0];\n\t}\n\n\t// ResourceHost couldnt be determined or the Host specified by the client was invalid\n\tif (resHost == NULL) {\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), \"Invalid/No Host specified: \" + host);\n\t\treturn;\n\t}\n\n\t// Send the request to the correct handler function\n\tswitch (req->getMethod()) {\n\tcase Method(HEAD):\n\tcase Method(GET):\n\t\thandleGet(cl, req, resHost);\n\t\tbreak;\n\tcase Method(OPTIONS):\n\t\thandleOptions(cl, req);\n\t\tbreak;\n\tcase Method(TRACE):\n\t\thandleTrace(cl, req);\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] Could not handle or determine request of type \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_IMPLEMENTED));\n\t\tbreak;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \tstd::cout << \"[\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) << \" \" << req->getRequestUri() << std::endl;\n \t/*std::cout << \"Headers:\" << std::endl;\n \tfor(int i = 0; i < req->getNumHeaders(); i++) {\n-\t\tstd::cout << req->getHeaderStr(i) << std::endl;\n+\t\tstd::cout << \"\\t\" << req->getHeaderStr(i) << std::endl;\n \t}\n \tstd::cout << std::endl;*/\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tstd::cout << req->getHeaderStr(i) << std::endl;"
            ],
            "added_lines": [
                "\t\tstd::cout << \"\\t\" << req->getHeaderStr(i) << std::endl;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25087",
        "func_name": "RamseyK/httpserver/ResourceHost::getResource",
        "description": "A vulnerability was found in RamseyK httpserver. It has been rated as critical. This issue affects the function ResourceHost::getResource of the file src/ResourceHost.cpp of the component URI Handler. The manipulation of the argument uri leads to path traversal: '../filedir'. The attack may be initiated remotely. The name of the patch is 1a0de56e4dafff9c2f9c8f6b130a764f7a50df52. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216863.",
        "git_url": "https://github.com/RamseyK/httpserver/commit/1a0de56e4dafff9c2f9c8f6b130a764f7a50df52",
        "commit_title": "Deny any directory traversal paths.  README update",
        "commit_text": "",
        "func_before": "Resource* ResourceHost::getResource(std::string uri) {\n\tif (uri.length() > 255 || uri.empty())\n\t\treturn NULL;\n\n\tstd::string path = baseDiskPath + uri;\n\tResource* res = NULL;\n\n\t// Gather info about the resource with stat: determine if it's a directory or file, check if its owned by group/user, modify times\n\tstruct stat sb;\n\tif (stat(path.c_str(), &sb) == -1)\n\t\treturn NULL; // File not found\n\n\t// Determine file type\n\tif (sb.st_mode & S_IFDIR) { // Directory\n\t\t// Read a directory list or index into memory from FS\n\t\tres = readDirectory(path, sb);\n\t} else if (sb.st_mode & S_IFREG) { // Regular file\n\t\t// Attempt to load the file into memory from the FS\n\t\tres = readFile(path, sb);\n\t} else { // Something else..device, socket, symlink\n\t\treturn NULL;\n\t}\n\n\treturn res;\n}",
        "func": "Resource* ResourceHost::getResource(std::string uri) {\n\tif (uri.length() > 255 || uri.empty())\n\t\treturn NULL;\n\n\tif (uri.find(\"../\") != std::string::npos)\n\t\treturn NULL;\n\n\tstd::string path = baseDiskPath + uri;\n\tResource* res = NULL;\n\n\t// Gather info about the resource with stat: determine if it's a directory or file, check if its owned by group/user, modify times\n\tstruct stat sb;\n\tif (stat(path.c_str(), &sb) == -1)\n\t\treturn NULL; // File not found\n\n\t// Determine file type\n\tif (sb.st_mode & S_IFDIR) { // Directory\n\t\t// Read a directory list or index into memory from FS\n\t\tres = readDirectory(path, sb);\n\t} else if (sb.st_mode & S_IFREG) { // Regular file\n\t\t// Attempt to load the file into memory from the FS\n\t\tres = readFile(path, sb);\n\t} else { // Something else..device, socket, symlink\n\t\treturn NULL;\n\t}\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n Resource* ResourceHost::getResource(std::string uri) {\n \tif (uri.length() > 255 || uri.empty())\n+\t\treturn NULL;\n+\n+\tif (uri.find(\"../\") != std::string::npos)\n \t\treturn NULL;\n \n \tstd::string path = baseDiskPath + uri;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\treturn NULL;",
                "",
                "\tif (uri.find(\"../\") != std::string::npos)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25882",
        "func_name": "onnx/check_tensor",
        "description": "Versions of the package onnx before 1.13.0 are vulnerable to Directory Traversal as the external_data field of the tensor proto can have a path to the file which is outside the model current directory or user-provided directory, for example \"../../../etc/passwd\"",
        "git_url": "https://github.com/onnx/onnx/commit/f369b0e859024095d721f1d1612da5a8fa38988d",
        "commit_title": "Do not allow to read tensor's external_data outside the model directory (#4400)",
        "commit_text": " * Not allow to read tensor external_data outside the model directory\r \r \r * Fix formatting errors\r \r \r * Disable segfaulty test\r \r \r * Fix cpp tests\r \r \r * Fix UB while removing ../\r \r \r * Fix clang-format\r \r \r * Check for symlinks only on POSIX systems\r \r \r * Add specific to Windows external_data test\r \r \r * Change specific Windows external_data test decorator tofix mypy\r \r \r * Remove unused pathlib\r \r \r",
        "func_before": "void check_tensor(const TensorProto& tensor, const CheckerContext& ctx) {\n  enforce_has_field(tensor, data_type);\n  if (tensor.data_type() == TensorProto::UNDEFINED) {\n    fail_check(\"setting data_type field (tensor name: \", tensor.name(), \") to UNDEFINED is not allowed\");\n  }\n\n  int num_value_fields = 0;\n\n  const char* value_field = nullptr;\n\n#define check_data_field(field)             \\\n  bool has_##field = tensor.field().size(); \\\n  if (has_##field) {                        \\\n    ++num_value_fields;                     \\\n    value_field = #field;                   \\\n  }\n\n  check_data_field(float_data);\n  check_data_field(int32_data);\n  check_data_field(string_data);\n  check_data_field(int64_data);\n  check_data_field(raw_data);\n  check_data_field(double_data);\n  check_data_field(uint64_data);\n\n#undef check_data_field\n\n  bool stored_externally = tensor.has_data_location() && tensor.data_location() == TensorProto::EXTERNAL;\n  if (stored_externally) {\n    if (num_value_fields != 0) {\n      fail_check(\n          \"Data of TensorProto ( tensor name: \",\n          tensor.name(),\n          \") is stored externally and should not have data field.\",\n          value_field);\n    }\n\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        std::string data_path = path_join(ctx.get_model_dir(), entry.value());\n        // use stat to check whether the file exists\n        struct stat buffer;\n        if (stat((data_path).c_str(), &buffer) != 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    return;\n  }\n  int64_t nelem = 1;\n  for (auto x : tensor.dims()) {\n    nelem *= x;\n  }\n  if (nelem == 0 && num_value_fields != 0) {\n    fail_check(\"TensorProto (tensor name: \", tensor.name(), \") is 0-element but contains data!\");\n  }\n  if (nelem != 0 && num_value_fields != 1) {\n    fail_check(\"TensorProto (tensor name: \", tensor.name(), \") should contain one and only one value field.\");\n  }\n  if (has_raw_data) {\n    if (tensor.data_type() == TensorProto::STRING) {\n      fail_check(\"STRING data (tensor name: \", tensor.name(), \") should not be stored in raw_data field\");\n    }\n    return;\n  } else {\n#define check_field(field)               \\\n  if (nelem != 0 && !has_##field) {      \\\n    fail_check(                          \\\n        \"values of data_type '\",         \\\n        tensor.data_type(),              \\\n        \"' should be stored in field '\", \\\n        #field,                          \\\n        \"' instead of '\",                \\\n        value_field,                     \\\n        \"'\");                            \\\n  }\n\n    switch (tensor.data_type()) {\n      case TensorProto::FLOAT:\n      case TensorProto::COMPLEX64:\n        check_field(float_data);\n        break;\n\n      case TensorProto::DOUBLE:\n      case TensorProto::COMPLEX128:\n        check_field(double_data);\n        break;\n\n      case TensorProto::INT32:\n      case TensorProto::UINT8:\n      case TensorProto::INT8:\n      case TensorProto::UINT16:\n      case TensorProto::INT16:\n      case TensorProto::BOOL:\n      case TensorProto::FLOAT16:\n      case TensorProto::BFLOAT16:\n        check_field(int32_data);\n        break;\n\n      case TensorProto::INT64:\n        check_field(int64_data);\n        break;\n\n      case TensorProto::UINT32:\n      case TensorProto::UINT64:\n        check_field(uint64_data);\n        break;\n\n      case TensorProto::STRING:\n        check_field(string_data);\n        break;\n\n      default:\n        fail_check(\"Unrecognized data_type (tensor name: \", tensor.name(), \"): \", tensor.data_type());\n    }\n  }\n\n#undef check_field\n}",
        "func": "void check_tensor(const TensorProto& tensor, const CheckerContext& ctx) {\n  enforce_has_field(tensor, data_type);\n  if (tensor.data_type() == TensorProto::UNDEFINED) {\n    fail_check(\"setting data_type field (tensor name: \", tensor.name(), \") to UNDEFINED is not allowed\");\n  }\n\n  int num_value_fields = 0;\n\n  const char* value_field = nullptr;\n\n#define check_data_field(field)             \\\n  bool has_##field = tensor.field().size(); \\\n  if (has_##field) {                        \\\n    ++num_value_fields;                     \\\n    value_field = #field;                   \\\n  }\n\n  check_data_field(float_data);\n  check_data_field(int32_data);\n  check_data_field(string_data);\n  check_data_field(int64_data);\n  check_data_field(raw_data);\n  check_data_field(double_data);\n  check_data_field(uint64_data);\n\n#undef check_data_field\n\n  bool stored_externally = tensor.has_data_location() && tensor.data_location() == TensorProto::EXTERNAL;\n  if (stored_externally) {\n    if (num_value_fields != 0) {\n      fail_check(\n          \"Data of TensorProto ( tensor name: \",\n          tensor.name(),\n          \") is stored externally and should not have data field.\",\n          value_field);\n    }\n\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        std::string relative_path = clean_relative_path(entry.value());\n        // Check that normalized relative path starts with \"../\" or \"..\\\" on windows.\n        if (relative_path.rfind(\"..\" + k_preferred_path_separator, 0) == 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be file inside the \",\n              ctx.get_model_dir(),\n              \", but the '\",\n              entry.value(),\n              \"' points outside the directory\");\n        }\n\n        std::string data_path = path_join(ctx.get_model_dir(), relative_path);\n        // use stat to check whether the file exists\n        struct stat buffer;\n        if (stat((data_path).c_str(), &buffer) != 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n#ifdef _WIN32\n#else // POSIX\n      //  Do not allow symlinks or directories.\n        if (!S_ISREG(buffer.st_mode)) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it is not regular file.\");\n        }\n#endif\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    return;\n  }\n  int64_t nelem = 1;\n  for (auto x : tensor.dims()) {\n    nelem *= x;\n  }\n  if (nelem == 0 && num_value_fields != 0) {\n    fail_check(\"TensorProto (tensor name: \", tensor.name(), \") is 0-element but contains data!\");\n  }\n  if (nelem != 0 && num_value_fields != 1) {\n    fail_check(\"TensorProto (tensor name: \", tensor.name(), \") should contain one and only one value field.\");\n  }\n  if (has_raw_data) {\n    if (tensor.data_type() == TensorProto::STRING) {\n      fail_check(\"STRING data (tensor name: \", tensor.name(), \") should not be stored in raw_data field\");\n    }\n    return;\n  } else {\n#define check_field(field)               \\\n  if (nelem != 0 && !has_##field) {      \\\n    fail_check(                          \\\n        \"values of data_type '\",         \\\n        tensor.data_type(),              \\\n        \"' should be stored in field '\", \\\n        #field,                          \\\n        \"' instead of '\",                \\\n        value_field,                     \\\n        \"'\");                            \\\n  }\n\n    switch (tensor.data_type()) {\n      case TensorProto::FLOAT:\n      case TensorProto::COMPLEX64:\n        check_field(float_data);\n        break;\n\n      case TensorProto::DOUBLE:\n      case TensorProto::COMPLEX128:\n        check_field(double_data);\n        break;\n\n      case TensorProto::INT32:\n      case TensorProto::UINT8:\n      case TensorProto::INT8:\n      case TensorProto::UINT16:\n      case TensorProto::INT16:\n      case TensorProto::BOOL:\n      case TensorProto::FLOAT16:\n      case TensorProto::BFLOAT16:\n        check_field(int32_data);\n        break;\n\n      case TensorProto::INT64:\n        check_field(int64_data);\n        break;\n\n      case TensorProto::UINT32:\n      case TensorProto::UINT64:\n        check_field(uint64_data);\n        break;\n\n      case TensorProto::STRING:\n        check_field(string_data);\n        break;\n\n      default:\n        fail_check(\"Unrecognized data_type (tensor name: \", tensor.name(), \"): \", tensor.data_type());\n    }\n  }\n\n#undef check_field\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,20 @@\n     for (const StringStringEntryProto& entry : tensor.external_data()) {\n       if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n         has_location = true;\n-        std::string data_path = path_join(ctx.get_model_dir(), entry.value());\n+        std::string relative_path = clean_relative_path(entry.value());\n+        // Check that normalized relative path starts with \"../\" or \"..\\\" on windows.\n+        if (relative_path.rfind(\"..\" + k_preferred_path_separator, 0) == 0) {\n+          fail_check(\n+              \"Data of TensorProto ( tensor name: \",\n+              tensor.name(),\n+              \") should be file inside the \",\n+              ctx.get_model_dir(),\n+              \", but the '\",\n+              entry.value(),\n+              \"' points outside the directory\");\n+        }\n+\n+        std::string data_path = path_join(ctx.get_model_dir(), relative_path);\n         // use stat to check whether the file exists\n         struct stat buffer;\n         if (stat((data_path).c_str(), &buffer) != 0) {\n@@ -50,6 +63,18 @@\n               data_path,\n               \", but it doesn't exist or is not accessible.\");\n         }\n+#ifdef _WIN32\n+#else // POSIX\n+      //  Do not allow symlinks or directories.\n+        if (!S_ISREG(buffer.st_mode)) {\n+          fail_check(\n+              \"Data of TensorProto ( tensor name: \",\n+              tensor.name(),\n+              \") should be stored in \",\n+              data_path,\n+              \", but it is not regular file.\");\n+        }\n+#endif\n       }\n     }\n     if (!has_location) {",
        "diff_line_info": {
            "deleted_lines": [
                "        std::string data_path = path_join(ctx.get_model_dir(), entry.value());"
            ],
            "added_lines": [
                "        std::string relative_path = clean_relative_path(entry.value());",
                "        // Check that normalized relative path starts with \"../\" or \"..\\\" on windows.",
                "        if (relative_path.rfind(\"..\" + k_preferred_path_separator, 0) == 0) {",
                "          fail_check(",
                "              \"Data of TensorProto ( tensor name: \",",
                "              tensor.name(),",
                "              \") should be file inside the \",",
                "              ctx.get_model_dir(),",
                "              \", but the '\",",
                "              entry.value(),",
                "              \"' points outside the directory\");",
                "        }",
                "",
                "        std::string data_path = path_join(ctx.get_model_dir(), relative_path);",
                "#ifdef _WIN32",
                "#else // POSIX",
                "      //  Do not allow symlinks or directories.",
                "        if (!S_ISREG(buffer.st_mode)) {",
                "          fail_check(",
                "              \"Data of TensorProto ( tensor name: \",",
                "              tensor.name(),",
                "              \") should be stored in \",",
                "              data_path,",
                "              \", but it is not regular file.\");",
                "        }",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26068",
        "func_name": "pistacheio/pistache/PathGroup::hasPath",
        "description": "This affects the package pistacheio/pistache before 0.0.3.20220425. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/pistacheio/pistache/commit/4ba6da096611d11849aa37ee342c032a306ee885",
        "commit_title": "fix(swagger/security): ensure that the requested file is in the UI directory",
        "commit_text": " The Rest::Swagger class didn't check if the file asked from the user was contained in the UI directory, thus allowing users to access arbitrary files in the filesystem.  Thanks to Kirill Efimov (@Kirill89) and the Snyk Security team for finding and reporting the vulnerability to the Pistache team.",
        "func_before": "bool PathGroup::hasPath(const std::string& name, Http::Method method) const\n        {\n            auto group = paths(name);\n            auto it    = std::find_if(std::begin(group), std::end(group),\n                                   [&](const Path& p) { return p.method == method; });\n            return it != std::end(group);\n        }",
        "func": "bool PathGroup::hasPath(const std::string& name, Http::Method method) const\n        {\n            auto group = paths(name);\n            auto it    = std::find_if(std::begin(group), std::end(group),\n                                      [&](const Path& p) { return p.method == method; });\n            return it != std::end(group);\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,6 @@\n         {\n             auto group = paths(name);\n             auto it    = std::find_if(std::begin(group), std::end(group),\n-                                   [&](const Path& p) { return p.method == method; });\n+                                      [&](const Path& p) { return p.method == method; });\n             return it != std::end(group);\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "                                   [&](const Path& p) { return p.method == method; });"
            ],
            "added_lines": [
                "                                      [&](const Path& p) { return p.method == method; });"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26068",
        "func_name": "pistacheio/pistache/Swagger::install",
        "description": "This affects the package pistacheio/pistache before 0.0.3.20220425. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/pistacheio/pistache/commit/4ba6da096611d11849aa37ee342c032a306ee885",
        "commit_title": "fix(swagger/security): ensure that the requested file is in the UI directory",
        "commit_text": " The Rest::Swagger class didn't check if the file asked from the user was contained in the UI directory, thus allowing users to access arbitrary files in the filesystem.  Thanks to Kirill Efimov (@Kirill89) and the Snyk Security team for finding and reporting the vulnerability to the Pistache team.",
        "func_before": "void Swagger::install(Rest::Router& router)\n    {\n\n        Route::Handler uiHandler = [=](const Rest::Request& req,\n                                       Http::ResponseWriter response) {\n            const auto& res = req.resource();\n\n            /*\n     * @Export might be useful for routing also. Make it public or merge it with\n     * the Fragment class\n     */\n\n            struct Path\n            {\n                explicit Path(const std::string& value)\n                    : value(value)\n                    , trailingSlashValue(value)\n                {\n                    if (trailingSlashValue.empty() || trailingSlashValue.back() != '/')\n                        trailingSlashValue += '/';\n                }\n\n                static bool hasTrailingSlash(const Rest::Request& req)\n                {\n                    auto res_ = req.resource();\n                    return res_.back() == '/';\n                }\n\n                std::string stripPrefix(const Rest::Request& req)\n                {\n                    auto res_ = req.resource();\n                    if (!res_.compare(0, value.size(), value))\n                    {\n                        return res_.substr(value.size());\n                    }\n                    return res_;\n                }\n\n                bool matches(const Rest::Request& req) const\n                {\n                    const auto& res_ = req.resource();\n                    if (value == res_)\n                        return true;\n\n                    if (res_ == trailingSlashValue)\n                        return true;\n\n                    return false;\n                }\n\n                bool isPrefix(const Rest::Request& req)\n                {\n                    const auto& res_ = req.resource();\n                    return !res_.compare(0, value.size(), value);\n                }\n\n                [[maybe_unused]] const std::string& withTrailingSlash() const\n                {\n                    return trailingSlashValue;\n                }\n\n                std::string join(const std::string& value) const\n                {\n                    std::string val;\n                    if (value[0] == '/')\n                        val = value.substr(1);\n                    else\n                        val = value;\n                    return trailingSlashValue + val;\n                }\n\n            private:\n                std::string value;\n                std::string trailingSlashValue;\n            };\n\n            Path ui(uiPath_);\n            Path uiDir(uiDirectory_);\n\n            if (ui.matches(req))\n            {\n                if (!Path::hasTrailingSlash(req))\n                {\n                    response.headers().add<Http::Header::Location>(uiPath_ + '/');\n\n                    response.send(Http::Code::Moved_Permanently);\n                }\n                else\n                {\n                    auto index = uiDir.join(\"index.html\");\n                    Http::serveFile(response, index);\n                }\n                return Route::Result::Ok;\n            }\n            else if (ui.isPrefix(req))\n            {\n                auto file = ui.stripPrefix(req);\n                auto path = uiDir.join(file);\n                Http::serveFile(response, path);\n                return Route::Result::Ok;\n            }\n\n            else if (res == apiPath_)\n            {\n                response.send(Http::Code::Ok, serializer_(description_),\n                              MIME(Application, Json));\n                return Route::Result::Ok;\n            }\n\n            return Route::Result::Failure;\n        };\n\n        router.addCustomHandler(uiHandler);\n    }",
        "func": "void Swagger::install(Rest::Router& router)\n    {\n\n        Route::Handler uiHandler = [=](const Rest::Request& req,\n                                       Http::ResponseWriter response) {\n            const auto& res = req.resource();\n\n            /*\n             * @Export might be useful for routing also. Make it public or merge it with\n             * the Fragment class\n             */\n\n            struct Path\n            {\n                explicit Path(const std::string& value)\n                    : value(value)\n                    , trailingSlashValue(value)\n                {\n                    if (trailingSlashValue.empty() || trailingSlashValue.back() != '/')\n                        trailingSlashValue += '/';\n                }\n\n                static bool hasTrailingSlash(const Rest::Request& req)\n                {\n                    auto res_ = req.resource();\n                    return res_.back() == '/';\n                }\n\n                std::string stripPrefix(const Rest::Request& req)\n                {\n                    auto res_ = req.resource();\n                    if (!res_.compare(0, value.size(), value))\n                    {\n                        return res_.substr(value.size());\n                    }\n                    return res_;\n                }\n\n                bool matches(const Rest::Request& req) const\n                {\n                    const auto& res_ = req.resource();\n                    if (value == res_)\n                        return true;\n\n                    if (res_ == trailingSlashValue)\n                        return true;\n\n                    return false;\n                }\n\n                bool isPrefix(const Rest::Request& req)\n                {\n                    const auto& res_ = req.resource();\n                    return !res_.compare(0, value.size(), value);\n                }\n\n                [[maybe_unused]] const std::string& withTrailingSlash() const\n                {\n                    return trailingSlashValue;\n                }\n\n                std::string join(const std::string& value) const\n                {\n                    std::string val;\n                    if (value[0] == '/')\n                        val = value.substr(1);\n                    else\n                        val = value;\n                    return trailingSlashValue + val;\n                }\n\n            private:\n                std::string value;\n                std::string trailingSlashValue;\n            };\n\n            Path ui(uiPath_);\n            Path uiDir(uiDirectory_);\n\n            if (ui.matches(req))\n            {\n                if (!Path::hasTrailingSlash(req))\n                {\n                    response.headers().add<Http::Header::Location>(uiPath_ + '/');\n\n                    response.send(Http::Code::Moved_Permanently);\n                }\n                else\n                {\n                    auto index = uiDir.join(\"index.html\");\n                    Http::serveFile(response, index);\n                }\n                return Route::Result::Ok;\n            }\n            else if (ui.isPrefix(req))\n            {\n                auto file = ui.stripPrefix(req);\n                auto path = std::filesystem::canonical(uiDir.join(file)).string();\n\n                // Check if the requested file is contained in the uiDirectory\n                // to prevent path traversal vulnerabilities.\n                // In C++20, use std::string::starts_with()\n                if (path.rfind(uiDirectory_, 0) == 0)\n                {\n                    Http::serveFile(response, path);\n                    return Route::Result::Ok;\n                }\n                else\n                {\n                    response.send(Http::Code::Not_Found);\n                    return Route::Result::Failure;\n                }\n            }\n\n            else if (res == apiPath_)\n            {\n                response.send(Http::Code::Ok, serializer_(description_),\n                              MIME(Application, Json));\n                return Route::Result::Ok;\n            }\n\n            return Route::Result::Failure;\n        };\n\n        router.addCustomHandler(uiHandler);\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,9 +6,9 @@\n             const auto& res = req.resource();\n \n             /*\n-     * @Export might be useful for routing also. Make it public or merge it with\n-     * the Fragment class\n-     */\n+             * @Export might be useful for routing also. Make it public or merge it with\n+             * the Fragment class\n+             */\n \n             struct Path\n             {\n@@ -95,9 +95,21 @@\n             else if (ui.isPrefix(req))\n             {\n                 auto file = ui.stripPrefix(req);\n-                auto path = uiDir.join(file);\n-                Http::serveFile(response, path);\n-                return Route::Result::Ok;\n+                auto path = std::filesystem::canonical(uiDir.join(file)).string();\n+\n+                // Check if the requested file is contained in the uiDirectory\n+                // to prevent path traversal vulnerabilities.\n+                // In C++20, use std::string::starts_with()\n+                if (path.rfind(uiDirectory_, 0) == 0)\n+                {\n+                    Http::serveFile(response, path);\n+                    return Route::Result::Ok;\n+                }\n+                else\n+                {\n+                    response.send(Http::Code::Not_Found);\n+                    return Route::Result::Failure;\n+                }\n             }\n \n             else if (res == apiPath_)",
        "diff_line_info": {
            "deleted_lines": [
                "     * @Export might be useful for routing also. Make it public or merge it with",
                "     * the Fragment class",
                "     */",
                "                auto path = uiDir.join(file);",
                "                Http::serveFile(response, path);",
                "                return Route::Result::Ok;"
            ],
            "added_lines": [
                "             * @Export might be useful for routing also. Make it public or merge it with",
                "             * the Fragment class",
                "             */",
                "                auto path = std::filesystem::canonical(uiDir.join(file)).string();",
                "",
                "                // Check if the requested file is contained in the uiDirectory",
                "                // to prevent path traversal vulnerabilities.",
                "                // In C++20, use std::string::starts_with()",
                "                if (path.rfind(uiDirectory_, 0) == 0)",
                "                {",
                "                    Http::serveFile(response, path);",
                "                    return Route::Result::Ok;",
                "                }",
                "                else",
                "                {",
                "                    response.send(Http::Code::Not_Found);",
                "                    return Route::Result::Failure;",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26068",
        "func_name": "pistacheio/pistache/PathGroup::path",
        "description": "This affects the package pistacheio/pistache before 0.0.3.20220425. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/pistacheio/pistache/commit/4ba6da096611d11849aa37ee342c032a306ee885",
        "commit_title": "fix(swagger/security): ensure that the requested file is in the UI directory",
        "commit_text": " The Rest::Swagger class didn't check if the file asked from the user was contained in the UI directory, thus allowing users to access arbitrary files in the filesystem.  Thanks to Kirill Efimov (@Kirill89) and the Snyk Security team for finding and reporting the vulnerability to the Pistache team.",
        "func_before": "std::optional<Path> PathGroup::path(const std::string& name,\n                                            Http::Method method) const\n        {\n            auto group = paths(name);\n            auto it    = std::find_if(std::begin(group), std::end(group),\n                                   [&](const Path& p) { return p.method == method; });\n\n            if (it != std::end(group))\n            {\n                return std::optional<Path>(*it);\n            }\n            return std::nullopt;\n        }",
        "func": "std::optional<Path> PathGroup::path(const std::string& name,\n                                            Http::Method method) const\n        {\n            auto group = paths(name);\n            auto it    = std::find_if(std::begin(group), std::end(group),\n                                      [&](const Path& p) { return p.method == method; });\n\n            if (it != std::end(group))\n            {\n                return std::optional<Path>(*it);\n            }\n            return std::nullopt;\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n         {\n             auto group = paths(name);\n             auto it    = std::find_if(std::begin(group), std::end(group),\n-                                   [&](const Path& p) { return p.method == method; });\n+                                      [&](const Path& p) { return p.method == method; });\n \n             if (it != std::end(group))\n             {",
        "diff_line_info": {
            "deleted_lines": [
                "                                   [&](const Path& p) { return p.method == method; });"
            ],
            "added_lines": [
                "                                      [&](const Path& p) { return p.method == method; });"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6321",
        "func_name": "tar/extract_archive",
        "description": "Directory traversal vulnerability in the safer_name_suffix function in GNU tar 1.14 through 1.29 might allow remote attackers to bypass an intended protection mechanism and write to arbitrary files via vectors related to improper sanitization of the file_name parameter, aka POINTYFEATHER.",
        "git_url": "http://git.savannah.gnu.org/cgit/tar.git/commit/?id=7340f67b9860ea0531c1450e5aa261c50f67165d",
        "commit_title": "* NEWS: Document this.",
        "commit_text": "* src/extract.c (extract_archive): Skip members whose names contain \"..\". ",
        "func_before": "void\nextract_archive (void)\n{\n  char typeflag;\n  tar_extractor_t fun;\n\n  fatal_exit_hook = extract_finish;\n\n  set_next_block_after (current_header);\n\n  if (!current_stat_info.file_name[0]\n      || (interactive_option\n\t  && !confirm (\"extract\", current_stat_info.file_name)))\n    {\n      skip_member ();\n      return;\n    }\n\n  /* Print the block from current_header and current_stat.  */\n  if (verbose_option)\n    print_header (&current_stat_info, current_header, -1);\n\n  /* Restore stats for all non-ancestor directories, unless\n     it is an incremental archive.\n     (see NOTICE in the comment to delay_set_stat above) */\n  if (!delay_directory_restore_option)\n    {\n      int dir = chdir_current;\n      apply_nonancestor_delayed_set_stat (current_stat_info.file_name, 0);\n      chdir_do (dir);\n    }\n\n  /* Take a safety backup of a previously existing file.  */\n\n  if (backup_option)\n    if (!maybe_backup_file (current_stat_info.file_name, 0))\n      {\n\tint e = errno;\n\tERROR ((0, e, _(\"%s: Was unable to backup this file\"),\n\t\tquotearg_colon (current_stat_info.file_name)));\n\tskip_member ();\n\treturn;\n      }\n\n  /* Extract the archive entry according to its type.  */\n  /* KLUDGE */\n  typeflag = sparse_member_p (&current_stat_info) ?\n                  GNUTYPE_SPARSE : current_header->header.typeflag;\n\n  if (prepare_to_extract (current_stat_info.file_name, typeflag, &fun))\n    {\n      if (fun && (*fun) (current_stat_info.file_name, typeflag)\n\t  && backup_option)\n\tundo_last_backup ();\n    }\n  else\n    skip_member ();\n\n}",
        "func": "void\nextract_archive (void)\n{\n  char typeflag;\n  tar_extractor_t fun;\n  bool skip_dotdot_name;\n\n  fatal_exit_hook = extract_finish;\n\n  set_next_block_after (current_header);\n\n  skip_dotdot_name = (!absolute_names_option\n\t\t      && contains_dot_dot (current_stat_info.orig_file_name));\n  if (skip_dotdot_name)\n    ERROR ((0, 0, _(\"%s: Member name contains '..'\"),\n\t    quotearg_colon (current_stat_info.orig_file_name)));\n\n  if (!current_stat_info.file_name[0]\n      || skip_dotdot_name\n      || (interactive_option\n\t  && !confirm (\"extract\", current_stat_info.file_name)))\n    {\n      skip_member ();\n      return;\n    }\n\n  /* Print the block from current_header and current_stat.  */\n  if (verbose_option)\n    print_header (&current_stat_info, current_header, -1);\n\n  /* Restore stats for all non-ancestor directories, unless\n     it is an incremental archive.\n     (see NOTICE in the comment to delay_set_stat above) */\n  if (!delay_directory_restore_option)\n    {\n      int dir = chdir_current;\n      apply_nonancestor_delayed_set_stat (current_stat_info.file_name, 0);\n      chdir_do (dir);\n    }\n\n  /* Take a safety backup of a previously existing file.  */\n\n  if (backup_option)\n    if (!maybe_backup_file (current_stat_info.file_name, 0))\n      {\n\tint e = errno;\n\tERROR ((0, e, _(\"%s: Was unable to backup this file\"),\n\t\tquotearg_colon (current_stat_info.file_name)));\n\tskip_member ();\n\treturn;\n      }\n\n  /* Extract the archive entry according to its type.  */\n  /* KLUDGE */\n  typeflag = sparse_member_p (&current_stat_info) ?\n                  GNUTYPE_SPARSE : current_header->header.typeflag;\n\n  if (prepare_to_extract (current_stat_info.file_name, typeflag, &fun))\n    {\n      if (fun && (*fun) (current_stat_info.file_name, typeflag)\n\t  && backup_option)\n\tundo_last_backup ();\n    }\n  else\n    skip_member ();\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,12 +3,20 @@\n {\n   char typeflag;\n   tar_extractor_t fun;\n+  bool skip_dotdot_name;\n \n   fatal_exit_hook = extract_finish;\n \n   set_next_block_after (current_header);\n \n+  skip_dotdot_name = (!absolute_names_option\n+\t\t      && contains_dot_dot (current_stat_info.orig_file_name));\n+  if (skip_dotdot_name)\n+    ERROR ((0, 0, _(\"%s: Member name contains '..'\"),\n+\t    quotearg_colon (current_stat_info.orig_file_name)));\n+\n   if (!current_stat_info.file_name[0]\n+      || skip_dotdot_name\n       || (interactive_option\n \t  && !confirm (\"extract\", current_stat_info.file_name)))\n     {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  bool skip_dotdot_name;",
                "  skip_dotdot_name = (!absolute_names_option",
                "\t\t      && contains_dot_dot (current_stat_info.orig_file_name));",
                "  if (skip_dotdot_name)",
                "    ERROR ((0, 0, _(\"%s: Member name contains '..'\"),",
                "\t    quotearg_colon (current_stat_info.orig_file_name)));",
                "",
                "      || skip_dotdot_name"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7116",
        "func_name": "qemu/v9fs_walk",
        "description": "Directory traversal vulnerability in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to access host files outside the export path via a .. (dot dot) in an unspecified string.",
        "git_url": "https://github.com/qemu/qemu/commit/56f101ecce0eafd09e2daf1c4eeb1377d6959261",
        "commit_title": "9pfs: handle walk of \"..\" in the root directory",
        "commit_text": " The 9P spec at http://man.cat-v.org/plan_9/5/intro says:  All directories must support walks to the directory .. (dot-dot) meaning parent directory, although by convention directories contain no explicit entry for .. or . (dot).  The parent of the root directory of a server's tree is itself.  This means that a client cannot walk further than the root directory exported by the server. In other words, if the client wants to walk \"/..\" or \"/foo/../..\", the server should answer like the request was to walk \"/\".  This patch just does that: - we cache the QID of the root directory at attach time - during the walk we compare the QID of each path component with the root   QID to detect if we're in a \"/..\" situation - if so, we skip the current component and go to the next one ",
        "func_before": "static void v9fs_walk(void *opaque)\n{\n    int name_idx;\n    V9fsQID *qids = NULL;\n    int i, err = 0;\n    V9fsPath dpath, path;\n    uint16_t nwnames;\n    struct stat stbuf;\n    size_t offset = 7;\n    int32_t fid, newfid;\n    V9fsString *wnames = NULL;\n    V9fsFidState *fidp;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n    offset += err;\n\n    trace_v9fs_walk(pdu->tag, pdu->id, fid, newfid, nwnames);\n\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        wnames = g_malloc0(sizeof(wnames[0]) * nwnames);\n        qids   = g_malloc0(sizeof(qids[0]) * nwnames);\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n    /*\n     * Both dpath and path initially poin to fidp.\n     * Needed to handle request with nwnames == 0\n     */\n    v9fs_path_copy(&dpath, &fidp->path);\n    v9fs_path_copy(&path, &fidp->path);\n    for (name_idx = 0; name_idx < nwnames; name_idx++) {\n        err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data, &path);\n        if (err < 0) {\n            goto out;\n        }\n        err = v9fs_co_lstat(pdu, &path, &stbuf);\n        if (err < 0) {\n            goto out;\n        }\n        stat_to_qid(&stbuf, &qids[name_idx]);\n        v9fs_path_copy(&dpath, &path);\n    }\n    if (fid == newfid) {\n        BUG_ON(fidp->fid_type != P9_FID_NONE);\n        v9fs_path_copy(&fidp->path, &path);\n    } else {\n        newfidp = alloc_fid(s, newfid);\n        if (newfidp == NULL) {\n            err = -EINVAL;\n            goto out;\n        }\n        newfidp->uid = fidp->uid;\n        v9fs_path_copy(&newfidp->path, &path);\n    }\n    err = v9fs_walk_marshal(pdu, nwnames, qids);\n    trace_v9fs_walk_return(pdu->tag, pdu->id, nwnames, qids);\nout:\n    put_fid(pdu, fidp);\n    if (newfidp) {\n        put_fid(pdu, newfidp);\n    }\n    v9fs_path_free(&dpath);\n    v9fs_path_free(&path);\nout_nofid:\n    pdu_complete(pdu, err);\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        for (name_idx = 0; name_idx < nwnames; name_idx++) {\n            v9fs_string_free(&wnames[name_idx]);\n        }\n        g_free(wnames);\n        g_free(qids);\n    }\n}",
        "func": "static void v9fs_walk(void *opaque)\n{\n    int name_idx;\n    V9fsQID *qids = NULL;\n    int i, err = 0;\n    V9fsPath dpath, path;\n    uint16_t nwnames;\n    struct stat stbuf;\n    size_t offset = 7;\n    int32_t fid, newfid;\n    V9fsString *wnames = NULL;\n    V9fsFidState *fidp;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    V9fsQID qid;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n    offset += err;\n\n    trace_v9fs_walk(pdu->tag, pdu->id, fid, newfid, nwnames);\n\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        wnames = g_malloc0(sizeof(wnames[0]) * nwnames);\n        qids   = g_malloc0(sizeof(qids[0]) * nwnames);\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        goto out;\n    }\n\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n    /*\n     * Both dpath and path initially poin to fidp.\n     * Needed to handle request with nwnames == 0\n     */\n    v9fs_path_copy(&dpath, &fidp->path);\n    v9fs_path_copy(&path, &fidp->path);\n    for (name_idx = 0; name_idx < nwnames; name_idx++) {\n        if (not_same_qid(&pdu->s->root_qid, &qid) ||\n            strcmp(\"..\", wnames[name_idx].data)) {\n            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,\n                                       &path);\n            if (err < 0) {\n                goto out;\n            }\n\n            err = v9fs_co_lstat(pdu, &path, &stbuf);\n            if (err < 0) {\n                goto out;\n            }\n            stat_to_qid(&stbuf, &qid);\n            v9fs_path_copy(&dpath, &path);\n        }\n        memcpy(&qids[name_idx], &qid, sizeof(qid));\n    }\n    if (fid == newfid) {\n        BUG_ON(fidp->fid_type != P9_FID_NONE);\n        v9fs_path_copy(&fidp->path, &path);\n    } else {\n        newfidp = alloc_fid(s, newfid);\n        if (newfidp == NULL) {\n            err = -EINVAL;\n            goto out;\n        }\n        newfidp->uid = fidp->uid;\n        v9fs_path_copy(&newfidp->path, &path);\n    }\n    err = v9fs_walk_marshal(pdu, nwnames, qids);\n    trace_v9fs_walk_return(pdu->tag, pdu->id, nwnames, qids);\nout:\n    put_fid(pdu, fidp);\n    if (newfidp) {\n        put_fid(pdu, newfidp);\n    }\n    v9fs_path_free(&dpath);\n    v9fs_path_free(&path);\nout_nofid:\n    pdu_complete(pdu, err);\n    if (nwnames && nwnames <= P9_MAXWELEM) {\n        for (name_idx = 0; name_idx < nwnames; name_idx++) {\n            v9fs_string_free(&wnames[name_idx]);\n        }\n        g_free(wnames);\n        g_free(qids);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n     V9fsFidState *newfidp = NULL;\n     V9fsPDU *pdu = opaque;\n     V9fsState *s = pdu->s;\n+    V9fsQID qid;\n \n     err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n     if (err < 0) {\n@@ -46,6 +47,12 @@\n         err = -ENOENT;\n         goto out_nofid;\n     }\n+\n+    err = fid_to_qid(pdu, fidp, &qid);\n+    if (err < 0) {\n+        goto out;\n+    }\n+\n     v9fs_path_init(&dpath);\n     v9fs_path_init(&path);\n     /*\n@@ -55,16 +62,22 @@\n     v9fs_path_copy(&dpath, &fidp->path);\n     v9fs_path_copy(&path, &fidp->path);\n     for (name_idx = 0; name_idx < nwnames; name_idx++) {\n-        err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data, &path);\n-        if (err < 0) {\n-            goto out;\n+        if (not_same_qid(&pdu->s->root_qid, &qid) ||\n+            strcmp(\"..\", wnames[name_idx].data)) {\n+            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,\n+                                       &path);\n+            if (err < 0) {\n+                goto out;\n+            }\n+\n+            err = v9fs_co_lstat(pdu, &path, &stbuf);\n+            if (err < 0) {\n+                goto out;\n+            }\n+            stat_to_qid(&stbuf, &qid);\n+            v9fs_path_copy(&dpath, &path);\n         }\n-        err = v9fs_co_lstat(pdu, &path, &stbuf);\n-        if (err < 0) {\n-            goto out;\n-        }\n-        stat_to_qid(&stbuf, &qids[name_idx]);\n-        v9fs_path_copy(&dpath, &path);\n+        memcpy(&qids[name_idx], &qid, sizeof(qid));\n     }\n     if (fid == newfid) {\n         BUG_ON(fidp->fid_type != P9_FID_NONE);",
        "diff_line_info": {
            "deleted_lines": [
                "        err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data, &path);",
                "        if (err < 0) {",
                "            goto out;",
                "        err = v9fs_co_lstat(pdu, &path, &stbuf);",
                "        if (err < 0) {",
                "            goto out;",
                "        }",
                "        stat_to_qid(&stbuf, &qids[name_idx]);",
                "        v9fs_path_copy(&dpath, &path);"
            ],
            "added_lines": [
                "    V9fsQID qid;",
                "",
                "    err = fid_to_qid(pdu, fidp, &qid);",
                "    if (err < 0) {",
                "        goto out;",
                "    }",
                "",
                "        if (not_same_qid(&pdu->s->root_qid, &qid) ||",
                "            strcmp(\"..\", wnames[name_idx].data)) {",
                "            err = v9fs_co_name_to_path(pdu, &dpath, wnames[name_idx].data,",
                "                                       &path);",
                "            if (err < 0) {",
                "                goto out;",
                "            }",
                "",
                "            err = v9fs_co_lstat(pdu, &path, &stbuf);",
                "            if (err < 0) {",
                "                goto out;",
                "            }",
                "            stat_to_qid(&stbuf, &qid);",
                "            v9fs_path_copy(&dpath, &path);",
                "        memcpy(&qids[name_idx], &qid, sizeof(qid));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7116",
        "func_name": "qemu/v9fs_attach",
        "description": "Directory traversal vulnerability in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to access host files outside the export path via a .. (dot dot) in an unspecified string.",
        "git_url": "https://github.com/qemu/qemu/commit/56f101ecce0eafd09e2daf1c4eeb1377d6959261",
        "commit_title": "9pfs: handle walk of \"..\" in the root directory",
        "commit_text": " The 9P spec at http://man.cat-v.org/plan_9/5/intro says:  All directories must support walks to the directory .. (dot-dot) meaning parent directory, although by convention directories contain no explicit entry for .. or . (dot).  The parent of the root directory of a server's tree is itself.  This means that a client cannot walk further than the root directory exported by the server. In other words, if the client wants to walk \"/..\" or \"/foo/../..\", the server should answer like the request was to walk \"/\".  This patch just does that: - we cache the QID of the root directory at attach time - during the walk we compare the QID of each path component with the root   QID to detect if we're in a \"/..\" situation - if so, we skip the current component and go to the next one ",
        "func_before": "static void v9fs_attach(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t fid, afid, n_uname;\n    V9fsString uname, aname;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsQID qid;\n    ssize_t err;\n\n    v9fs_string_init(&uname);\n    v9fs_string_init(&aname);\n    err = pdu_unmarshal(pdu, offset, \"ddssd\", &fid,\n                        &afid, &uname, &aname, &n_uname);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);\n\n    fidp = alloc_fid(s, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp->uid = n_uname;\n    err = v9fs_co_name_to_path(pdu, NULL, \"/\", &fidp->path);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_attach_return(pdu->tag, pdu->id,\n                             qid.type, qid.version, qid.path);\n    /*\n     * disable migration if we haven't done already.\n     * attach could get called multiple times for the same export.\n     */\n    if (!s->migration_blocker) {\n        s->root_fid = fid;\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'\",\n                   s->ctx.fs_root ? s->ctx.fs_root : \"NULL\", s->tag);\n        migrate_add_blocker(s->migration_blocker);\n    }\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&uname);\n    v9fs_string_free(&aname);\n}",
        "func": "static void v9fs_attach(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t fid, afid, n_uname;\n    V9fsString uname, aname;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsQID qid;\n    ssize_t err;\n\n    v9fs_string_init(&uname);\n    v9fs_string_init(&aname);\n    err = pdu_unmarshal(pdu, offset, \"ddssd\", &fid,\n                        &afid, &uname, &aname, &n_uname);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);\n\n    fidp = alloc_fid(s, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp->uid = n_uname;\n    err = v9fs_co_name_to_path(pdu, NULL, \"/\", &fidp->path);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err += offset;\n    memcpy(&s->root_qid, &qid, sizeof(qid));\n    trace_v9fs_attach_return(pdu->tag, pdu->id,\n                             qid.type, qid.version, qid.path);\n    /*\n     * disable migration if we haven't done already.\n     * attach could get called multiple times for the same export.\n     */\n    if (!s->migration_blocker) {\n        s->root_fid = fid;\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'\",\n                   s->ctx.fs_root ? s->ctx.fs_root : \"NULL\", s->tag);\n        migrate_add_blocker(s->migration_blocker);\n    }\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&uname);\n    v9fs_string_free(&aname);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,6 +42,7 @@\n         goto out;\n     }\n     err += offset;\n+    memcpy(&s->root_qid, &qid, sizeof(qid));\n     trace_v9fs_attach_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path);\n     /*",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    memcpy(&s->root_qid, &qid, sizeof(qid));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6833",
        "func_name": "php/php-src/phar_extract_file",
        "description": "Directory traversal vulnerability in the PharData class in PHP before 5.4.44, 5.5.x before 5.5.28, and 5.6.x before 5.6.12 allows remote attackers to write to arbitrary files via a .. (dot dot) in a ZIP archive entry that is mishandled during an extractTo call.",
        "git_url": "https://github.com/php/php-src/commit/dda81f0505217a95db065e6bf9cc2d81eb902417",
        "commit_title": "Fix bug #70019 - limit extracted files to given directory",
        "commit_text": "",
        "func_before": "static int phar_extract_file(zend_bool overwrite, phar_entry_info *entry, char *dest, int dest_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_statbuf ssb;\n\tint len;\n\tphp_stream *fp;\n\tchar *fullpath;\n\tconst char *slash;\n\tmode_t mode;\n\n\tif (entry->is_mounted) {\n\t\t/* silently ignore mounted entries */\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->filename_len >= sizeof(\".phar\")-1 && !memcmp(entry->filename, \".phar\", sizeof(\".phar\")-1)) {\n\t\treturn SUCCESS;\n\t}\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", dest, entry->filename);\n\n\tif (len >= MAXPATHLEN) {\n\t\tchar *tmp;\n\t\t/* truncate for error message */\n\t\tfullpath[50] = '\\0';\n\t\tif (entry->filename_len > 50) {\n\t\t\ttmp = estrndup(entry->filename, 50);\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, fullpath);\n\t\t\tefree(tmp);\n\t\t} else {\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", entry->filename, fullpath);\n\t\t}\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tif (!len) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tif (PHAR_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", openbasedir/safe mode restrictions in effect\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\t/* let see if the path already exists */\n\tif (!overwrite && SUCCESS == php_stream_stat_path(fullpath, &ssb)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", path already exists\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\t/* perform dirname */\n\tslash = zend_memrchr(entry->filename, '/', entry->filename_len);\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - entry->filename) + 1] = '\\0';\n\t} else {\n\t\tfullpath[dest_len] = '\\0';\n\t}\n\n\tif (FAILURE == php_stream_stat_path(fullpath, &ssb)) {\n\t\tif (entry->is_dir) {\n\t\t\tif (!php_stream_mkdir(fullpath, entry->flags & PHAR_ENT_PERM_MASK,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!php_stream_mkdir(fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - entry->filename) + 1] = '/';\n\t} else {\n\t\tfullpath[dest_len] = '/';\n\t}\n\n\t/* it is a standalone directory, job done */\n\tif (entry->is_dir) {\n\t\tefree(fullpath);\n\t\treturn SUCCESS;\n\t}\n\n#if PHP_API_VERSION < 20100412\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS|ENFORCE_SAFE_MODE, NULL);\n#else\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n#endif\n\n\tif (!fp) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not open for writing \\\"%s\\\"\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tif (!phar_get_efp(entry, 0 TSRMLS_CC)) {\n\t\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer: %s\", entry->filename, fullpath, *error);\n\t\t\t} else {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer\", entry->filename, fullpath);\n\t\t\t}\n\t\t\tefree(fullpath);\n\t\t\tphp_stream_close(fp);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (FAILURE == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to seek internal file pointer\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(entry, 0 TSRMLS_CC), fp, entry->uncompressed_filesize, NULL)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", copying contents failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tphp_stream_close(fp);\n\tmode = (mode_t) entry->flags & PHAR_ENT_PERM_MASK;\n\n\tif (FAILURE == VCWD_CHMOD(fullpath, mode)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", setting file permissions failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tefree(fullpath);\n\treturn SUCCESS;\n}",
        "func": "static int phar_extract_file(zend_bool overwrite, phar_entry_info *entry, char *dest, int dest_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_statbuf ssb;\n\tint len;\n\tphp_stream *fp;\n\tchar *fullpath;\n\tconst char *slash;\n\tmode_t mode;\n\tcwd_state new_state;\n\tchar *filename;\n\tsize_t filename_len;\n\n\tif (entry->is_mounted) {\n\t\t/* silently ignore mounted entries */\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->filename_len >= sizeof(\".phar\")-1 && !memcmp(entry->filename, \".phar\", sizeof(\".phar\")-1)) {\n\t\treturn SUCCESS;\n\t}\n\t/* strip .. from path and restrict it to be under dest directory */\n\tnew_state.cwd = (char*)malloc(2);\n\tnew_state.cwd[0] = DEFAULT_SLASH;\n\tnew_state.cwd[1] = '\\0';\n\tnew_state.cwd_length = 1;\n\tif (virtual_file_ex(&new_state, entry->filename, NULL, CWD_EXPAND TSRMLS_CC) != 0 ||\n\t\t\tnew_state.cwd_length <= 1) {\n\t\tif (EINVAL == errno && entry->filename_len > 50) {\n\t\t\tchar *tmp = estrndup(entry->filename, 50);\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, dest);\n\t\t\tefree(tmp);\n\t\t} else {\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n\t\t}\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\tfilename = new_state.cwd + 1;\n\tfilename_len = new_state.cwd_length - 1;\n#ifdef PHP_WIN32\n\t/* unixify the path back, otherwise non zip formats might be broken */\n\t{\n\t\tint cnt = filename_len;\n\n\t\tdo {\n\t\t\tif ('\\\\' == filename[cnt]) {\n\t\t\t\tfilename[cnt] = '/';\n\t\t\t}\n\t\t} while (cnt-- >= 0);\n\t}\n#endif\n\n\tlen = spprintf(&fullpath, 0, \"%s/%s\", dest, filename);\n\n\tif (len >= MAXPATHLEN) {\n\t\tchar *tmp;\n\t\t/* truncate for error message */\n\t\tfullpath[50] = '\\0';\n\t\tif (entry->filename_len > 50) {\n\t\t\ttmp = estrndup(entry->filename, 50);\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, fullpath);\n\t\t\tefree(tmp);\n\t\t} else {\n\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", entry->filename, fullpath);\n\t\t}\n\t\tefree(fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\tif (!len) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n\t\tefree(fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\tif (PHAR_OPENBASEDIR_CHECKPATH(fullpath)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", openbasedir/safe mode restrictions in effect\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\t/* let see if the path already exists */\n\tif (!overwrite && SUCCESS == php_stream_stat_path(fullpath, &ssb)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", path already exists\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tfree(new_state.cwd);\n\t\treturn FAILURE;\n\t}\n\n\t/* perform dirname */\n\tslash = zend_memrchr(filename, '/', filename_len);\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - filename) + 1] = '\\0';\n\t} else {\n\t\tfullpath[dest_len] = '\\0';\n\t}\n\n\tif (FAILURE == php_stream_stat_path(fullpath, &ssb)) {\n\t\tif (entry->is_dir) {\n\t\t\tif (!php_stream_mkdir(fullpath, entry->flags & PHAR_ENT_PERM_MASK,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\tfree(new_state.cwd);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!php_stream_mkdir(fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n\t\t\t\tefree(fullpath);\n\t\t\t\tfree(new_state.cwd);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (slash) {\n\t\tfullpath[dest_len + (slash - filename) + 1] = '/';\n\t} else {\n\t\tfullpath[dest_len] = '/';\n\t}\n\n\tfilename = NULL;\n\tfree(new_state.cwd);\n\t/* it is a standalone directory, job done */\n\tif (entry->is_dir) {\n\t\tefree(fullpath);\n\t\treturn SUCCESS;\n\t}\n\n#if PHP_API_VERSION < 20100412\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS|ENFORCE_SAFE_MODE, NULL);\n#else\n\tfp = php_stream_open_wrapper(fullpath, \"w+b\", REPORT_ERRORS, NULL);\n#endif\n\n\tif (!fp) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not open for writing \\\"%s\\\"\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tif (!phar_get_efp(entry, 0 TSRMLS_CC)) {\n\t\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer: %s\", entry->filename, fullpath, *error);\n\t\t\t} else {\n\t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to open internal file pointer\", entry->filename, fullpath);\n\t\t\t}\n\t\t\tefree(fullpath);\n\t\t\tphp_stream_close(fp);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (FAILURE == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", unable to seek internal file pointer\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(entry, 0 TSRMLS_CC), fp, entry->uncompressed_filesize, NULL)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", copying contents failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\tphp_stream_close(fp);\n\t\treturn FAILURE;\n\t}\n\n\tphp_stream_close(fp);\n\tmode = (mode_t) entry->flags & PHAR_ENT_PERM_MASK;\n\n\tif (FAILURE == VCWD_CHMOD(fullpath, mode)) {\n\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", setting file permissions failed\", entry->filename, fullpath);\n\t\tefree(fullpath);\n\t\treturn FAILURE;\n\t}\n\n\tefree(fullpath);\n\treturn SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,9 @@\n \tchar *fullpath;\n \tconst char *slash;\n \tmode_t mode;\n+\tcwd_state new_state;\n+\tchar *filename;\n+\tsize_t filename_len;\n \n \tif (entry->is_mounted) {\n \t\t/* silently ignore mounted entries */\n@@ -15,8 +18,39 @@\n \tif (entry->filename_len >= sizeof(\".phar\")-1 && !memcmp(entry->filename, \".phar\", sizeof(\".phar\")-1)) {\n \t\treturn SUCCESS;\n \t}\n+\t/* strip .. from path and restrict it to be under dest directory */\n+\tnew_state.cwd = (char*)malloc(2);\n+\tnew_state.cwd[0] = DEFAULT_SLASH;\n+\tnew_state.cwd[1] = '\\0';\n+\tnew_state.cwd_length = 1;\n+\tif (virtual_file_ex(&new_state, entry->filename, NULL, CWD_EXPAND TSRMLS_CC) != 0 ||\n+\t\t\tnew_state.cwd_length <= 1) {\n+\t\tif (EINVAL == errno && entry->filename_len > 50) {\n+\t\t\tchar *tmp = estrndup(entry->filename, 50);\n+\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, dest);\n+\t\t\tefree(tmp);\n+\t\t} else {\n+\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n+\t\t}\n+\t\tfree(new_state.cwd);\n+\t\treturn FAILURE;\n+\t}\n+\tfilename = new_state.cwd + 1;\n+\tfilename_len = new_state.cwd_length - 1;\n+#ifdef PHP_WIN32\n+\t/* unixify the path back, otherwise non zip formats might be broken */\n+\t{\n+\t\tint cnt = filename_len;\n \n-\tlen = spprintf(&fullpath, 0, \"%s/%s\", dest, entry->filename);\n+\t\tdo {\n+\t\t\tif ('\\\\' == filename[cnt]) {\n+\t\t\t\tfilename[cnt] = '/';\n+\t\t\t}\n+\t\t} while (cnt-- >= 0);\n+\t}\n+#endif\n+\n+\tlen = spprintf(&fullpath, 0, \"%s/%s\", dest, filename);\n \n \tif (len >= MAXPATHLEN) {\n \t\tchar *tmp;\n@@ -30,18 +64,21 @@\n \t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", entry->filename, fullpath);\n \t\t}\n \t\tefree(fullpath);\n+\t\tfree(new_state.cwd);\n \t\treturn FAILURE;\n \t}\n \n \tif (!len) {\n \t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);\n \t\tefree(fullpath);\n+\t\tfree(new_state.cwd);\n \t\treturn FAILURE;\n \t}\n \n \tif (PHAR_OPENBASEDIR_CHECKPATH(fullpath)) {\n \t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", openbasedir/safe mode restrictions in effect\", entry->filename, fullpath);\n \t\tefree(fullpath);\n+\t\tfree(new_state.cwd);\n \t\treturn FAILURE;\n \t}\n \n@@ -49,14 +86,15 @@\n \tif (!overwrite && SUCCESS == php_stream_stat_path(fullpath, &ssb)) {\n \t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\" to \\\"%s\\\", path already exists\", entry->filename, fullpath);\n \t\tefree(fullpath);\n+\t\tfree(new_state.cwd);\n \t\treturn FAILURE;\n \t}\n \n \t/* perform dirname */\n-\tslash = zend_memrchr(entry->filename, '/', entry->filename_len);\n+\tslash = zend_memrchr(filename, '/', filename_len);\n \n \tif (slash) {\n-\t\tfullpath[dest_len + (slash - entry->filename) + 1] = '\\0';\n+\t\tfullpath[dest_len + (slash - filename) + 1] = '\\0';\n \t} else {\n \t\tfullpath[dest_len] = '\\0';\n \t}\n@@ -66,23 +104,27 @@\n \t\t\tif (!php_stream_mkdir(fullpath, entry->flags & PHAR_ENT_PERM_MASK,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n \t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n \t\t\t\tefree(fullpath);\n+\t\t\t\tfree(new_state.cwd);\n \t\t\t\treturn FAILURE;\n \t\t\t}\n \t\t} else {\n \t\t\tif (!php_stream_mkdir(fullpath, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL)) {\n \t\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", could not create directory \\\"%s\\\"\", entry->filename, fullpath);\n \t\t\t\tefree(fullpath);\n+\t\t\t\tfree(new_state.cwd);\n \t\t\t\treturn FAILURE;\n \t\t\t}\n \t\t}\n \t}\n \n \tif (slash) {\n-\t\tfullpath[dest_len + (slash - entry->filename) + 1] = '/';\n+\t\tfullpath[dest_len + (slash - filename) + 1] = '/';\n \t} else {\n \t\tfullpath[dest_len] = '/';\n \t}\n \n+\tfilename = NULL;\n+\tfree(new_state.cwd);\n \t/* it is a standalone directory, job done */\n \tif (entry->is_dir) {\n \t\tefree(fullpath);",
        "diff_line_info": {
            "deleted_lines": [
                "\tlen = spprintf(&fullpath, 0, \"%s/%s\", dest, entry->filename);",
                "\tslash = zend_memrchr(entry->filename, '/', entry->filename_len);",
                "\t\tfullpath[dest_len + (slash - entry->filename) + 1] = '\\0';",
                "\t\tfullpath[dest_len + (slash - entry->filename) + 1] = '/';"
            ],
            "added_lines": [
                "\tcwd_state new_state;",
                "\tchar *filename;",
                "\tsize_t filename_len;",
                "\t/* strip .. from path and restrict it to be under dest directory */",
                "\tnew_state.cwd = (char*)malloc(2);",
                "\tnew_state.cwd[0] = DEFAULT_SLASH;",
                "\tnew_state.cwd[1] = '\\0';",
                "\tnew_state.cwd_length = 1;",
                "\tif (virtual_file_ex(&new_state, entry->filename, NULL, CWD_EXPAND TSRMLS_CC) != 0 ||",
                "\t\t\tnew_state.cwd_length <= 1) {",
                "\t\tif (EINVAL == errno && entry->filename_len > 50) {",
                "\t\t\tchar *tmp = estrndup(entry->filename, 50);",
                "\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s...\\\" to \\\"%s...\\\", extracted filename is too long for filesystem\", tmp, dest);",
                "\t\t\tefree(tmp);",
                "\t\t} else {",
                "\t\t\tspprintf(error, 4096, \"Cannot extract \\\"%s\\\", internal error\", entry->filename);",
                "\t\t}",
                "\t\tfree(new_state.cwd);",
                "\t\treturn FAILURE;",
                "\t}",
                "\tfilename = new_state.cwd + 1;",
                "\tfilename_len = new_state.cwd_length - 1;",
                "#ifdef PHP_WIN32",
                "\t/* unixify the path back, otherwise non zip formats might be broken */",
                "\t{",
                "\t\tint cnt = filename_len;",
                "\t\tdo {",
                "\t\t\tif ('\\\\' == filename[cnt]) {",
                "\t\t\t\tfilename[cnt] = '/';",
                "\t\t\t}",
                "\t\t} while (cnt-- >= 0);",
                "\t}",
                "#endif",
                "",
                "\tlen = spprintf(&fullpath, 0, \"%s/%s\", dest, filename);",
                "\t\tfree(new_state.cwd);",
                "\t\tfree(new_state.cwd);",
                "\t\tfree(new_state.cwd);",
                "\t\tfree(new_state.cwd);",
                "\tslash = zend_memrchr(filename, '/', filename_len);",
                "\t\tfullpath[dest_len + (slash - filename) + 1] = '\\0';",
                "\t\t\t\tfree(new_state.cwd);",
                "\t\t\t\tfree(new_state.cwd);",
                "\t\tfullpath[dest_len + (slash - filename) + 1] = '/';",
                "\tfilename = NULL;",
                "\tfree(new_state.cwd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-4877",
        "func_name": "wget/defaults",
        "description": "Absolute path traversal vulnerability in GNU Wget before 1.16, when recursion is enabled, allows remote FTP servers to write to arbitrary files, and consequently execute arbitrary code, via a LIST response that references the same filename within two entries, one of which indicates that the filename is for a symlink.",
        "git_url": "http://git.savannah.gnu.org/cgit/wget.git/commit/?id=18b0979357ed7dc4e11d4f2b1d7e0f5932d82aa7",
        "commit_title": "Wget was susceptible to a symlink attack which could create arbitrary",
        "commit_text": "files, directories or symbolic links and set their permissions when retrieving a directory recursively through FTP. This commit changes the default settings in Wget such that Wget no longer creates local symbolic links, but rather traverses them and retrieves the pointed-to file in such a retrieval.  The old behaviour can be attained by passing the --retr-symlinks=no option to the Wget invokation command. ",
        "func_before": "void\ndefaults (void)\n{\n  char *tmp;\n\n  /* Most of the default values are 0 (and 0.0, NULL, and false).\n     Just reset everything, and fill in the non-zero values.  Note\n     that initializing pointers to NULL this way is technically\n     illegal, but porting Wget to a machine where NULL is not all-zero\n     bit pattern will be the least of the implementors' worries.  */\n  xzero (opt);\n\n  opt.cookies = true;\n  opt.verbose = -1;\n  opt.ntry = 20;\n  opt.reclevel = 5;\n  opt.add_hostdir = true;\n  opt.netrc = true;\n  opt.ftp_glob = true;\n  opt.htmlify = true;\n  opt.http_keep_alive = true;\n  opt.use_proxy = true;\n  tmp = getenv (\"no_proxy\");\n  if (tmp)\n    opt.no_proxy = sepstring (tmp);\n  opt.prefer_family = prefer_none;\n  opt.allow_cache = true;\n\n  opt.read_timeout = 900;\n  opt.use_robots = true;\n\n  opt.remove_listing = true;\n\n  opt.dot_bytes = 1024;\n  opt.dot_spacing = 10;\n  opt.dots_in_line = 50;\n\n  opt.dns_cache = true;\n  opt.ftp_pasv = true;\n\n#ifdef HAVE_SSL\n  opt.check_cert = true;\n#endif\n\n  /* The default for file name restriction defaults to the OS type. */\n#if defined(WINDOWS) || defined(MSDOS) || defined(__CYGWIN__)\n  opt.restrict_files_os = restrict_windows;\n#else\n  opt.restrict_files_os = restrict_unix;\n#endif\n  opt.restrict_files_ctrl = true;\n  opt.restrict_files_nonascii = false;\n  opt.restrict_files_case = restrict_no_case_restriction;\n\n  opt.regex_type = regex_type_posix;\n\n  opt.max_redirect = 20;\n\n  opt.waitretry = 10;\n\n#ifdef ENABLE_IRI\n  opt.enable_iri = true;\n#else\n  opt.enable_iri = false;\n#endif\n  opt.locale = NULL;\n  opt.encoding_remote = NULL;\n\n  opt.useservertimestamps = true;\n  opt.show_all_dns_entries = false;\n\n  opt.warc_maxsize = 0; /* 1024 * 1024 * 1024; */\n#ifdef HAVE_LIBZ\n  opt.warc_compression_enabled = true;\n#else\n  opt.warc_compression_enabled = false;\n#endif\n  opt.warc_digests_enabled = true;\n  opt.warc_cdx_enabled = false;\n  opt.warc_cdx_dedup_filename = NULL;\n  opt.warc_tempdir = NULL;\n  opt.warc_keep_log = true;\n\n  /* Use a negative value to mark the absence of --start-pos option */\n  opt.start_pos = -1;\n  opt.show_progress = false;\n  opt.noscroll = false;\n}",
        "func": "void\ndefaults (void)\n{\n  char *tmp;\n\n  /* Most of the default values are 0 (and 0.0, NULL, and false).\n     Just reset everything, and fill in the non-zero values.  Note\n     that initializing pointers to NULL this way is technically\n     illegal, but porting Wget to a machine where NULL is not all-zero\n     bit pattern will be the least of the implementors' worries.  */\n  xzero (opt);\n\n  opt.cookies = true;\n  opt.verbose = -1;\n  opt.ntry = 20;\n  opt.reclevel = 5;\n  opt.add_hostdir = true;\n  opt.netrc = true;\n  opt.ftp_glob = true;\n  opt.htmlify = true;\n  opt.http_keep_alive = true;\n  opt.use_proxy = true;\n  tmp = getenv (\"no_proxy\");\n  if (tmp)\n    opt.no_proxy = sepstring (tmp);\n  opt.prefer_family = prefer_none;\n  opt.allow_cache = true;\n\n  opt.read_timeout = 900;\n  opt.use_robots = true;\n\n  opt.remove_listing = true;\n\n  opt.dot_bytes = 1024;\n  opt.dot_spacing = 10;\n  opt.dots_in_line = 50;\n\n  opt.dns_cache = true;\n  opt.ftp_pasv = true;\n  /* 2014-09-07  Darshit Shah  <darnir@gmail.com>\n   * opt.retr_symlinks is set to true by default. Creating symbolic links on the\n   * local filesystem pose a security threat by malicious FTP Servers that\n   * server a specially crafted .listing file akin to this:\n   *\n   * lrwxrwxrwx   1 root     root           33 Dec 25  2012 JoCxl6d8rFU -> /\n   * drwxrwxr-x  15 1024     106          4096 Aug 28 02:02 JoCxl6d8rFU\n   *\n   * A .listing file in this fashion makes Wget susceptiple to a symlink attack\n   * wherein the attacker is able to create arbitrary files, directories and\n   * symbolic links on the target system and even set permissions.\n   *\n   * Hence, by default Wget attempts to retrieve the pointed-to files and does\n   * not create the symbolic links locally.\n   */\n  opt.retr_symlinks = true;\n\n#ifdef HAVE_SSL\n  opt.check_cert = true;\n#endif\n\n  /* The default for file name restriction defaults to the OS type. */\n#if defined(WINDOWS) || defined(MSDOS) || defined(__CYGWIN__)\n  opt.restrict_files_os = restrict_windows;\n#else\n  opt.restrict_files_os = restrict_unix;\n#endif\n  opt.restrict_files_ctrl = true;\n  opt.restrict_files_nonascii = false;\n  opt.restrict_files_case = restrict_no_case_restriction;\n\n  opt.regex_type = regex_type_posix;\n\n  opt.max_redirect = 20;\n\n  opt.waitretry = 10;\n\n#ifdef ENABLE_IRI\n  opt.enable_iri = true;\n#else\n  opt.enable_iri = false;\n#endif\n  opt.locale = NULL;\n  opt.encoding_remote = NULL;\n\n  opt.useservertimestamps = true;\n  opt.show_all_dns_entries = false;\n\n  opt.warc_maxsize = 0; /* 1024 * 1024 * 1024; */\n#ifdef HAVE_LIBZ\n  opt.warc_compression_enabled = true;\n#else\n  opt.warc_compression_enabled = false;\n#endif\n  opt.warc_digests_enabled = true;\n  opt.warc_cdx_enabled = false;\n  opt.warc_cdx_dedup_filename = NULL;\n  opt.warc_tempdir = NULL;\n  opt.warc_keep_log = true;\n\n  /* Use a negative value to mark the absence of --start-pos option */\n  opt.start_pos = -1;\n  opt.show_progress = false;\n  opt.noscroll = false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,22 @@\n \n   opt.dns_cache = true;\n   opt.ftp_pasv = true;\n+  /* 2014-09-07  Darshit Shah  <darnir@gmail.com>\n+   * opt.retr_symlinks is set to true by default. Creating symbolic links on the\n+   * local filesystem pose a security threat by malicious FTP Servers that\n+   * server a specially crafted .listing file akin to this:\n+   *\n+   * lrwxrwxrwx   1 root     root           33 Dec 25  2012 JoCxl6d8rFU -> /\n+   * drwxrwxr-x  15 1024     106          4096 Aug 28 02:02 JoCxl6d8rFU\n+   *\n+   * A .listing file in this fashion makes Wget susceptiple to a symlink attack\n+   * wherein the attacker is able to create arbitrary files, directories and\n+   * symbolic links on the target system and even set permissions.\n+   *\n+   * Hence, by default Wget attempts to retrieve the pointed-to files and does\n+   * not create the symbolic links locally.\n+   */\n+  opt.retr_symlinks = true;\n \n #ifdef HAVE_SSL\n   opt.check_cert = true;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  /* 2014-09-07  Darshit Shah  <darnir@gmail.com>",
                "   * opt.retr_symlinks is set to true by default. Creating symbolic links on the",
                "   * local filesystem pose a security threat by malicious FTP Servers that",
                "   * server a specially crafted .listing file akin to this:",
                "   *",
                "   * lrwxrwxrwx   1 root     root           33 Dec 25  2012 JoCxl6d8rFU -> /",
                "   * drwxrwxr-x  15 1024     106          4096 Aug 28 02:02 JoCxl6d8rFU",
                "   *",
                "   * A .listing file in this fashion makes Wget susceptiple to a symlink attack",
                "   * wherein the attacker is able to create arbitrary files, directories and",
                "   * symbolic links on the target system and even set permissions.",
                "   *",
                "   * Hence, by default Wget attempts to retrieve the pointed-to files and does",
                "   * not create the symbolic links locally.",
                "   */",
                "  opt.retr_symlinks = true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8737",
        "func_name": "binutils-gdb/copy_archive",
        "description": "Multiple directory traversal vulnerabilities in GNU binutils 2.24 and earlier allow local users to delete arbitrary files via a .. (dot dot) or full path name in an archive to (1) strip or (2) objcopy or create arbitrary files via (3) a .. (dot dot) or full path name in an archive to ar.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=dd9b91de2149ee81d47f708e7b0bbf57da10ad42",
        "commit_title": "",
        "commit_text": "Prevent archive memebers with illegal pathnames from being extracted from an archive.  \tPR binutils/17552, binutils/17533 \t* bucomm.c (is_valid_archive_path): New function.  Returns false \tfor absolute pathnames and pathnames that include /../. \t* bucomm.h (is_valid_archive_path): Add prototype. \t* ar.c (extract_file): Use new function to check for valid \tpathnames when extracting files from an archive. \t* objcopy.c (copy_archive): Likewise. \t* doc/binutils.texi: Update documentation to mention the \tlimitation on pathname of archive members. ",
        "func_before": "static void\ncopy_archive (bfd *ibfd, bfd *obfd, const char *output_target,\n\t      bfd_boolean force_output_target,\n\t      const bfd_arch_info_type *input_arch)\n{\n  struct name_list\n    {\n      struct name_list *next;\n      const char *name;\n      bfd *obfd;\n    } *list, *l;\n  bfd **ptr = &obfd->archive_head;\n  bfd *this_element;\n  char *dir;\n  const char *filename;\n\n  /* Make a temp directory to hold the contents.  */\n  dir = make_tempdir (bfd_get_filename (obfd));\n  if (dir == NULL)\n      fatal (_(\"cannot create tempdir for archive copying (error: %s)\"),\n\t   strerror (errno));\n\n  if (strip_symbols == STRIP_ALL)\n    obfd->has_armap = FALSE;\n  else\n    obfd->has_armap = ibfd->has_armap;\n  obfd->is_thin_archive = ibfd->is_thin_archive;\n\n  if (deterministic)\n    obfd->flags |= BFD_DETERMINISTIC_OUTPUT;\n\n  list = NULL;\n\n  this_element = bfd_openr_next_archived_file (ibfd, NULL);\n\n  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))\n    {\n      status = 1;\n      bfd_nonfatal_message (NULL, obfd, NULL, NULL);\n      return;\n    }\n\n  while (!status && this_element != NULL)\n    {\n      char *output_name;\n      bfd *output_bfd;\n      bfd *last_element;\n      struct stat buf;\n      int stat_status = 0;\n      bfd_boolean del = TRUE;\n      bfd_boolean ok_object;\n\n      /* Create an output file for this member.  */\n      output_name = concat (dir, \"/\",\n\t\t\t    bfd_get_filename (this_element), (char *) 0);\n\n      /* If the file already exists, make another temp dir.  */\n      if (stat (output_name, &buf) >= 0)\n\t{\n\t  output_name = make_tempdir (output_name);\n\t  if (output_name == NULL)\n\t    fatal (_(\"cannot create tempdir for archive copying (error: %s)\"),\n\t\t   strerror (errno));\n\n\t  l = (struct name_list *) xmalloc (sizeof (struct name_list));\n\t  l->name = output_name;\n\t  l->next = list;\n\t  l->obfd = NULL;\n\t  list = l;\n\t  output_name = concat (output_name, \"/\",\n\t\t\t\tbfd_get_filename (this_element), (char *) 0);\n\t}\n\n      if (preserve_dates)\n\t{\n\t  stat_status = bfd_stat_arch_elt (this_element, &buf);\n\n\t  if (stat_status != 0)\n\t    non_fatal (_(\"internal stat error on %s\"),\n\t\t       bfd_get_filename (this_element));\n\t}\n\n      l = (struct name_list *) xmalloc (sizeof (struct name_list));\n      l->name = output_name;\n      l->next = list;\n      l->obfd = NULL;\n      list = l;\n\n      ok_object = bfd_check_format (this_element, bfd_object);\n      if (!ok_object)\n\tbfd_nonfatal_message (NULL, this_element, NULL,\n\t\t\t      _(\"Unable to recognise the format of file\"));\n\n      /* PR binutils/3110: Cope with archives\n\t containing multiple target types.  */\n      if (force_output_target || !ok_object)\n\toutput_bfd = bfd_openw (output_name, output_target);\n      else\n\toutput_bfd = bfd_openw (output_name, bfd_get_target (this_element));\n\n      if (output_bfd == NULL)\n\t{\n\t  bfd_nonfatal_message (output_name, NULL, NULL, NULL);\n\t  status = 1;\n\t  return;\n\t}\n\n      if (ok_object)\n\t{\n\t  del = !copy_object (this_element, output_bfd, input_arch);\n\n\t  if (del && bfd_get_arch (this_element) == bfd_arch_unknown)\n\t    /* Try again as an unknown object file.  */\n\t    ok_object = FALSE;\n\t  else if (!bfd_close (output_bfd))\n\t    {\n\t      bfd_nonfatal_message (output_name, NULL, NULL, NULL);\n\t      /* Error in new object file. Don't change archive.  */\n\t      status = 1;\n\t    }\n\t}\n\n      if (!ok_object)\n\t{\n\t  del = !copy_unknown_object (this_element, output_bfd);\n\t  if (!bfd_close_all_done (output_bfd))\n\t    {\n\t      bfd_nonfatal_message (output_name, NULL, NULL, NULL);\n\t      /* Error in new object file. Don't change archive.  */\n\t      status = 1;\n\t    }\n\t}\n\n      if (del)\n\t{\n\t  unlink (output_name);\n\t  status = 1;\n\t}\n      else\n\t{\n\t  if (preserve_dates && stat_status == 0)\n\t    set_times (output_name, &buf);\n\n\t  /* Open the newly output file and attach to our list.  */\n\t  output_bfd = bfd_openr (output_name, output_target);\n\n\t  l->obfd = output_bfd;\n\n\t  *ptr = output_bfd;\n\t  ptr = &output_bfd->archive_next;\n\n\t  last_element = this_element;\n\n\t  this_element = bfd_openr_next_archived_file (ibfd, last_element);\n\n\t  bfd_close (last_element);\n\t}\n    }\n  *ptr = NULL;\n\n  filename = bfd_get_filename (obfd);\n  if (!bfd_close (obfd))\n    {\n      status = 1;\n      bfd_nonfatal_message (filename, NULL, NULL, NULL);\n      return;\n    }\n\n  filename = bfd_get_filename (ibfd);\n  if (!bfd_close (ibfd))\n    {\n      status = 1;\n      bfd_nonfatal_message (filename, NULL, NULL, NULL);\n      return;\n    }\n\n  /* Delete all the files that we opened.  */\n  for (l = list; l != NULL; l = l->next)\n    {\n      if (l->obfd == NULL)\n\trmdir (l->name);\n      else\n\t{\n\t  bfd_close (l->obfd);\n\t  unlink (l->name);\n\t}\n    }\n  rmdir (dir);\n}",
        "func": "static void\ncopy_archive (bfd *ibfd, bfd *obfd, const char *output_target,\n\t      bfd_boolean force_output_target,\n\t      const bfd_arch_info_type *input_arch)\n{\n  struct name_list\n    {\n      struct name_list *next;\n      const char *name;\n      bfd *obfd;\n    } *list, *l;\n  bfd **ptr = &obfd->archive_head;\n  bfd *this_element;\n  char *dir;\n  const char *filename;\n\n  /* Make a temp directory to hold the contents.  */\n  dir = make_tempdir (bfd_get_filename (obfd));\n  if (dir == NULL)\n      fatal (_(\"cannot create tempdir for archive copying (error: %s)\"),\n\t   strerror (errno));\n\n  if (strip_symbols == STRIP_ALL)\n    obfd->has_armap = FALSE;\n  else\n    obfd->has_armap = ibfd->has_armap;\n  obfd->is_thin_archive = ibfd->is_thin_archive;\n\n  if (deterministic)\n    obfd->flags |= BFD_DETERMINISTIC_OUTPUT;\n\n  list = NULL;\n\n  this_element = bfd_openr_next_archived_file (ibfd, NULL);\n\n  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))\n    {\n      status = 1;\n      bfd_nonfatal_message (NULL, obfd, NULL, NULL);\n      return;\n    }\n\n  while (!status && this_element != NULL)\n    {\n      char *output_name;\n      bfd *output_bfd;\n      bfd *last_element;\n      struct stat buf;\n      int stat_status = 0;\n      bfd_boolean del = TRUE;\n      bfd_boolean ok_object;\n\n      /* PR binutils/17533: Do not allow directory traversal\n\t outside of the current directory tree by archive members.  */\n      if (! is_valid_archive_path (bfd_get_filename (this_element)))\n\tfatal (_(\"illegal pathname found in archive member: %s\"),\n\t       bfd_get_filename (this_element));\n\n      /* Create an output file for this member.  */\n      output_name = concat (dir, \"/\",\n\t\t\t    bfd_get_filename (this_element), (char *) 0);\n\n      /* If the file already exists, make another temp dir.  */\n      if (stat (output_name, &buf) >= 0)\n\t{\n\t  output_name = make_tempdir (output_name);\n\t  if (output_name == NULL)\n\t    fatal (_(\"cannot create tempdir for archive copying (error: %s)\"),\n\t\t   strerror (errno));\n\n\t  l = (struct name_list *) xmalloc (sizeof (struct name_list));\n\t  l->name = output_name;\n\t  l->next = list;\n\t  l->obfd = NULL;\n\t  list = l;\n\t  output_name = concat (output_name, \"/\",\n\t\t\t\tbfd_get_filename (this_element), (char *) 0);\n\t}\n\n      if (preserve_dates)\n\t{\n\t  stat_status = bfd_stat_arch_elt (this_element, &buf);\n\n\t  if (stat_status != 0)\n\t    non_fatal (_(\"internal stat error on %s\"),\n\t\t       bfd_get_filename (this_element));\n\t}\n\n      l = (struct name_list *) xmalloc (sizeof (struct name_list));\n      l->name = output_name;\n      l->next = list;\n      l->obfd = NULL;\n      list = l;\n\n      ok_object = bfd_check_format (this_element, bfd_object);\n      if (!ok_object)\n\tbfd_nonfatal_message (NULL, this_element, NULL,\n\t\t\t      _(\"Unable to recognise the format of file\"));\n\n      /* PR binutils/3110: Cope with archives\n\t containing multiple target types.  */\n      if (force_output_target || !ok_object)\n\toutput_bfd = bfd_openw (output_name, output_target);\n      else\n\toutput_bfd = bfd_openw (output_name, bfd_get_target (this_element));\n\n      if (output_bfd == NULL)\n\t{\n\t  bfd_nonfatal_message (output_name, NULL, NULL, NULL);\n\t  status = 1;\n\t  return;\n\t}\n\n      if (ok_object)\n\t{\n\t  del = !copy_object (this_element, output_bfd, input_arch);\n\n\t  if (del && bfd_get_arch (this_element) == bfd_arch_unknown)\n\t    /* Try again as an unknown object file.  */\n\t    ok_object = FALSE;\n\t  else if (!bfd_close (output_bfd))\n\t    {\n\t      bfd_nonfatal_message (output_name, NULL, NULL, NULL);\n\t      /* Error in new object file. Don't change archive.  */\n\t      status = 1;\n\t    }\n\t}\n\n      if (!ok_object)\n\t{\n\t  del = !copy_unknown_object (this_element, output_bfd);\n\t  if (!bfd_close_all_done (output_bfd))\n\t    {\n\t      bfd_nonfatal_message (output_name, NULL, NULL, NULL);\n\t      /* Error in new object file. Don't change archive.  */\n\t      status = 1;\n\t    }\n\t}\n\n      if (del)\n\t{\n\t  unlink (output_name);\n\t  status = 1;\n\t}\n      else\n\t{\n\t  if (preserve_dates && stat_status == 0)\n\t    set_times (output_name, &buf);\n\n\t  /* Open the newly output file and attach to our list.  */\n\t  output_bfd = bfd_openr (output_name, output_target);\n\n\t  l->obfd = output_bfd;\n\n\t  *ptr = output_bfd;\n\t  ptr = &output_bfd->archive_next;\n\n\t  last_element = this_element;\n\n\t  this_element = bfd_openr_next_archived_file (ibfd, last_element);\n\n\t  bfd_close (last_element);\n\t}\n    }\n  *ptr = NULL;\n\n  filename = bfd_get_filename (obfd);\n  if (!bfd_close (obfd))\n    {\n      status = 1;\n      bfd_nonfatal_message (filename, NULL, NULL, NULL);\n      return;\n    }\n\n  filename = bfd_get_filename (ibfd);\n  if (!bfd_close (ibfd))\n    {\n      status = 1;\n      bfd_nonfatal_message (filename, NULL, NULL, NULL);\n      return;\n    }\n\n  /* Delete all the files that we opened.  */\n  for (l = list; l != NULL; l = l->next)\n    {\n      if (l->obfd == NULL)\n\trmdir (l->name);\n      else\n\t{\n\t  bfd_close (l->obfd);\n\t  unlink (l->name);\n\t}\n    }\n  rmdir (dir);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,6 +49,12 @@\n       int stat_status = 0;\n       bfd_boolean del = TRUE;\n       bfd_boolean ok_object;\n+\n+      /* PR binutils/17533: Do not allow directory traversal\n+\t outside of the current directory tree by archive members.  */\n+      if (! is_valid_archive_path (bfd_get_filename (this_element)))\n+\tfatal (_(\"illegal pathname found in archive member: %s\"),\n+\t       bfd_get_filename (this_element));\n \n       /* Create an output file for this member.  */\n       output_name = concat (dir, \"/\",",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "      /* PR binutils/17533: Do not allow directory traversal",
                "\t outside of the current directory tree by archive members.  */",
                "      if (! is_valid_archive_path (bfd_get_filename (this_element)))",
                "\tfatal (_(\"illegal pathname found in archive member: %s\"),",
                "\t       bfd_get_filename (this_element));"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8737",
        "func_name": "binutils-gdb/extract_file",
        "description": "Multiple directory traversal vulnerabilities in GNU binutils 2.24 and earlier allow local users to delete arbitrary files via a .. (dot dot) or full path name in an archive to (1) strip or (2) objcopy or create arbitrary files via (3) a .. (dot dot) or full path name in an archive to ar.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=dd9b91de2149ee81d47f708e7b0bbf57da10ad42",
        "commit_title": "",
        "commit_text": "Prevent archive memebers with illegal pathnames from being extracted from an archive.  \tPR binutils/17552, binutils/17533 \t* bucomm.c (is_valid_archive_path): New function.  Returns false \tfor absolute pathnames and pathnames that include /../. \t* bucomm.h (is_valid_archive_path): Add prototype. \t* ar.c (extract_file): Use new function to check for valid \tpathnames when extracting files from an archive. \t* objcopy.c (copy_archive): Likewise. \t* doc/binutils.texi: Update documentation to mention the \tlimitation on pathname of archive members. ",
        "func_before": "void\nextract_file (bfd *abfd)\n{\n  FILE *ostream;\n  char *cbuf = (char *) xmalloc (BUFSIZE);\n  bfd_size_type nread, tocopy;\n  bfd_size_type ncopied = 0;\n  bfd_size_type size;\n  struct stat buf;\n\n  if (bfd_stat_arch_elt (abfd, &buf) != 0)\n    /* xgettext:c-format */\n    fatal (_(\"internal stat error on %s\"), bfd_get_filename (abfd));\n  size = buf.st_size;\n\n  if (verbose)\n    printf (\"x - %s\\n\", bfd_get_filename (abfd));\n\n  bfd_seek (abfd, (file_ptr) 0, SEEK_SET);\n\n  ostream = NULL;\n  if (size == 0)\n    {\n      /* Seems like an abstraction violation, eh?  Well it's OK! */\n      output_filename = bfd_get_filename (abfd);\n\n      ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);\n      if (ostream == NULL)\n\t{\n\t  perror (bfd_get_filename (abfd));\n\t  xexit (1);\n\t}\n\n      output_file = ostream;\n    }\n  else\n    while (ncopied < size)\n      {\n\ttocopy = size - ncopied;\n\tif (tocopy > BUFSIZE)\n\t  tocopy = BUFSIZE;\n\n\tnread = bfd_bread (cbuf, tocopy, abfd);\n\tif (nread != tocopy)\n\t  /* xgettext:c-format */\n\t  fatal (_(\"%s is not a valid archive\"),\n\t\t bfd_get_filename (bfd_my_archive (abfd)));\n\n\t/* See comment above; this saves disk arm motion */\n\tif (ostream == NULL)\n\t  {\n\t    /* Seems like an abstraction violation, eh?  Well it's OK! */\n\t    output_filename = bfd_get_filename (abfd);\n\n\t    ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);\n\t    if (ostream == NULL)\n\t      {\n\t\tperror (bfd_get_filename (abfd));\n\t\txexit (1);\n\t      }\n\n\t    output_file = ostream;\n\t  }\n\n\t/* fwrite in mingw32 may return int instead of bfd_size_type. Cast\n\t   the return value to bfd_size_type to avoid comparison between\n\t   signed and unsigned values.  */\n\tif ((bfd_size_type) fwrite (cbuf, 1, nread, ostream) != nread)\n\t  fatal (\"%s: %s\", output_filename, strerror (errno));\n\tncopied += tocopy;\n      }\n\n  if (ostream != NULL)\n    fclose (ostream);\n\n  output_file = NULL;\n  output_filename = NULL;\n\n  chmod (bfd_get_filename (abfd), buf.st_mode);\n\n  if (preserve_dates)\n    {\n      /* Set access time to modification time.  Only st_mtime is\n\t initialized by bfd_stat_arch_elt.  */\n      buf.st_atime = buf.st_mtime;\n      set_times (bfd_get_filename (abfd), &buf);\n    }\n\n  free (cbuf);\n}",
        "func": "void\nextract_file (bfd *abfd)\n{\n  FILE *ostream;\n  char *cbuf = (char *) xmalloc (BUFSIZE);\n  bfd_size_type nread, tocopy;\n  bfd_size_type ncopied = 0;\n  bfd_size_type size;\n  struct stat buf;\n\n  /* PR binutils/17533: Do not allow directory traversal\n     outside of the current directory tree.  */\n  if (! is_valid_archive_path (bfd_get_filename (abfd)))\n    {\n      non_fatal (_(\"illegal pathname found in archive member: %s\"),\n\t\t bfd_get_filename (abfd));\n      return;\n    }\n\n  if (bfd_stat_arch_elt (abfd, &buf) != 0)\n    /* xgettext:c-format */\n    fatal (_(\"internal stat error on %s\"), bfd_get_filename (abfd));\n  size = buf.st_size;\n\n  if (verbose)\n    printf (\"x - %s\\n\", bfd_get_filename (abfd));\n\n  bfd_seek (abfd, (file_ptr) 0, SEEK_SET);\n\n  ostream = NULL;\n  if (size == 0)\n    {\n      /* Seems like an abstraction violation, eh?  Well it's OK! */\n      output_filename = bfd_get_filename (abfd);\n\n      ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);\n      if (ostream == NULL)\n\t{\n\t  perror (bfd_get_filename (abfd));\n\t  xexit (1);\n\t}\n\n      output_file = ostream;\n    }\n  else\n    while (ncopied < size)\n      {\n\ttocopy = size - ncopied;\n\tif (tocopy > BUFSIZE)\n\t  tocopy = BUFSIZE;\n\n\tnread = bfd_bread (cbuf, tocopy, abfd);\n\tif (nread != tocopy)\n\t  /* xgettext:c-format */\n\t  fatal (_(\"%s is not a valid archive\"),\n\t\t bfd_get_filename (bfd_my_archive (abfd)));\n\n\t/* See comment above; this saves disk arm motion */\n\tif (ostream == NULL)\n\t  {\n\t    /* Seems like an abstraction violation, eh?  Well it's OK! */\n\t    output_filename = bfd_get_filename (abfd);\n\n\t    ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);\n\t    if (ostream == NULL)\n\t      {\n\t\tperror (bfd_get_filename (abfd));\n\t\txexit (1);\n\t      }\n\n\t    output_file = ostream;\n\t  }\n\n\t/* fwrite in mingw32 may return int instead of bfd_size_type. Cast\n\t   the return value to bfd_size_type to avoid comparison between\n\t   signed and unsigned values.  */\n\tif ((bfd_size_type) fwrite (cbuf, 1, nread, ostream) != nread)\n\t  fatal (\"%s: %s\", output_filename, strerror (errno));\n\tncopied += tocopy;\n      }\n\n  if (ostream != NULL)\n    fclose (ostream);\n\n  output_file = NULL;\n  output_filename = NULL;\n\n  chmod (bfd_get_filename (abfd), buf.st_mode);\n\n  if (preserve_dates)\n    {\n      /* Set access time to modification time.  Only st_mtime is\n\t initialized by bfd_stat_arch_elt.  */\n      buf.st_atime = buf.st_mtime;\n      set_times (bfd_get_filename (abfd), &buf);\n    }\n\n  free (cbuf);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,15 @@\n   bfd_size_type ncopied = 0;\n   bfd_size_type size;\n   struct stat buf;\n+\n+  /* PR binutils/17533: Do not allow directory traversal\n+     outside of the current directory tree.  */\n+  if (! is_valid_archive_path (bfd_get_filename (abfd)))\n+    {\n+      non_fatal (_(\"illegal pathname found in archive member: %s\"),\n+\t\t bfd_get_filename (abfd));\n+      return;\n+    }\n \n   if (bfd_stat_arch_elt (abfd, &buf) != 0)\n     /* xgettext:c-format */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  /* PR binutils/17533: Do not allow directory traversal",
                "     outside of the current directory tree.  */",
                "  if (! is_valid_archive_path (bfd_get_filename (abfd)))",
                "    {",
                "      non_fatal (_(\"illegal pathname found in archive member: %s\"),",
                "\t\t bfd_get_filename (abfd));",
                "      return;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10047",
        "func_name": "ImageMagick/GetMagickModulePath",
        "description": "Memory leak in the NewXMLTree function in magick/xml-tree.c in ImageMagick before 6.9.4-7 allows remote attackers to cause a denial of service (memory consumption) via a crafted XML file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/fc6080f1321fd21e86ef916195cc110b05d9effb",
        "commit_title": "Coder path traversal is not authorized, bug report provided by Masaaki Chida",
        "commit_text": "",
        "func_before": "static MagickBooleanType GetMagickModulePath(const char *filename,\n  MagickModuleType module_type,char *path,ExceptionInfo *exception)\n{\n  char\n    *module_path;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(path != (char *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MaxTextExtent);\n  module_path=(char *) NULL;\n  switch (module_type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for coder module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");\n#if defined(MAGICKCORE_CODER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_CODER_PATH);\n#endif\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for filter module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");\n#if defined(MAGICKCORE_FILTER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_FILTER_PATH);\n#endif\n      break;\n    }\n  }\n  if (module_path != (char *) NULL)\n    {\n      register char\n        *p,\n        *q;\n\n      for (p=module_path-1; p != (char *) NULL; )\n      {\n        (void) CopyMagickString(path,p+1,MaxTextExtent);\n        q=strchr(path,DirectoryListSeparator);\n        if (q != (char *) NULL)\n          *q='\\0';\n        q=path+strlen(path)-1;\n        if ((q >= path) && (*q != *DirectorySeparator))\n          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            module_path=DestroyString(module_path);\n            return(MagickTrue);\n          }\n        p=strchr(p+1,DirectoryListSeparator);\n      }\n      module_path=DestroyString(module_path);\n    }\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  else\n#if defined(MAGICKCORE_CODER_PATH)\n    {\n      const char\n        *directory;\n\n      /*\n        Search hard coded paths.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=MAGICKCORE_CODER_PATH;\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=MAGICKCORE_FILTER_PATH;\n          break;\n        }\n      }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s\",directory,filename);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    {\n      const char\n        *registery_key;\n\n      unsigned char\n        *key_value;\n\n      /*\n        Locate path via registry key.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          registery_key=\"CoderModulesPath\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          registery_key=\"FilterModulesPath\";\n          break;\n        }\n      }\n      key_value=NTRegistryKeyLookup(registery_key);\n      if (key_value == (unsigned char *) NULL)\n        {\n          ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n            \"RegistryKeyLookupFailed\",\"`%s'\",registery_key);\n          return(MagickFalse);\n        }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",(char *) key_value,\n        DirectorySeparator,filename);\n      key_value=(unsigned char *) RelinquishMagickMemory(key_value);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#endif\n#endif\n#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)\n# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined\n#endif\n#else\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"MAGICK_HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search MAGICK_HOME.\n        */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",home,\n          DirectorySeparator,filename);\n#else\n        const char\n          *directory;\n\n        switch (module_type)\n        {\n          case MagickImageCoderModule:\n          default:\n          {\n            directory=MAGICKCORE_CODER_RELATIVE_PATH;\n            break;\n          }\n          case MagickImageFilterModule:\n          {\n            directory=MAGICKCORE_FILTER_RELATIVE_PATH;\n            break;\n          }\n        }\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s\",home,\n          directory,filename);\n#endif\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  if (*GetClientPath() != '\\0')\n    {\n      /*\n        Search based on executable directory.\n      */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",GetClientPath(),\n        DirectorySeparator,filename);\n#else\n      char\n        prefix[MaxTextExtent];\n\n      const char\n        *directory;\n\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=\"coders\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=\"filters\";\n          break;\n        }\n      }\n      (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);\n      ChopPathComponents(prefix,1);\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s/%s\",prefix,\n        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);\n#endif\n      if (IsPathAccessible(path) != MagickFalse)\n        return(MagickTrue);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    /*\n      Search module path.\n    */\n    if ((NTGetModulePath(\"CORE_RL_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"CORE_DB_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"Magick.dll\",path) != MagickFalse))\n      {\n        (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n#endif\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"XDG_CONFIG_HOME\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"LOCALAPPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"APPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"USERPROFILE\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $XDG_CONFIG_HOME/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%sImageMagick%s%s\",\n          home,DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n    home=GetEnvironmentValue(\"HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $HOME/.config/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\n          \"%s%s.config%sImageMagick%s%s\",home,DirectorySeparator,\n          DirectorySeparator,DirectorySeparator,filename);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            home=DestroyString(home);\n            return(MagickTrue);\n          }\n        /*\n          Search $HOME/.magick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s.magick%s%s\",home,\n          DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  /*\n    Search current directory.\n  */\n  if (IsPathAccessible(path) != MagickFalse)\n    return(MagickTrue);\n  if (exception->severity < ConfigureError)\n    ThrowFileException(exception,ConfigureWarning,\"UnableToOpenModuleFile\",\n      path);\n#endif\n  return(MagickFalse);\n}",
        "func": "static MagickBooleanType GetMagickModulePath(const char *filename,\n  MagickModuleType module_type,char *path,ExceptionInfo *exception)\n{\n  char\n    *module_path;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(path != (char *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MaxTextExtent);\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  if (strstr(path,\"../\") != (char *) NULL)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",path);\n      return(MagickFalse);\n    }\n#endif\n  module_path=(char *) NULL;\n  switch (module_type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for coder module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");\n#if defined(MAGICKCORE_CODER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_CODER_PATH);\n#endif\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for filter module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");\n#if defined(MAGICKCORE_FILTER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_FILTER_PATH);\n#endif\n      break;\n    }\n  }\n  if (module_path != (char *) NULL)\n    {\n      register char\n        *p,\n        *q;\n\n      for (p=module_path-1; p != (char *) NULL; )\n      {\n        (void) CopyMagickString(path,p+1,MaxTextExtent);\n        q=strchr(path,DirectoryListSeparator);\n        if (q != (char *) NULL)\n          *q='\\0';\n        q=path+strlen(path)-1;\n        if ((q >= path) && (*q != *DirectorySeparator))\n          (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            module_path=DestroyString(module_path);\n            return(MagickTrue);\n          }\n        p=strchr(p+1,DirectoryListSeparator);\n      }\n      module_path=DestroyString(module_path);\n    }\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  else\n#if defined(MAGICKCORE_CODER_PATH)\n    {\n      const char\n        *directory;\n\n      /*\n        Search hard coded paths.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=MAGICKCORE_CODER_PATH;\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=MAGICKCORE_FILTER_PATH;\n          break;\n        }\n      }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s\",directory,filename);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    {\n      const char\n        *registery_key;\n\n      unsigned char\n        *key_value;\n\n      /*\n        Locate path via registry key.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          registery_key=\"CoderModulesPath\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          registery_key=\"FilterModulesPath\";\n          break;\n        }\n      }\n      key_value=NTRegistryKeyLookup(registery_key);\n      if (key_value == (unsigned char *) NULL)\n        {\n          ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n            \"RegistryKeyLookupFailed\",\"`%s'\",registery_key);\n          return(MagickFalse);\n        }\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",(char *) key_value,\n        DirectorySeparator,filename);\n      key_value=(unsigned char *) RelinquishMagickMemory(key_value);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#endif\n#endif\n#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)\n# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined\n#endif\n#else\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"MAGICK_HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search MAGICK_HOME.\n        */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",home,\n          DirectorySeparator,filename);\n#else\n        const char\n          *directory;\n\n        switch (module_type)\n        {\n          case MagickImageCoderModule:\n          default:\n          {\n            directory=MAGICKCORE_CODER_RELATIVE_PATH;\n            break;\n          }\n          case MagickImageFilterModule:\n          {\n            directory=MAGICKCORE_FILTER_RELATIVE_PATH;\n            break;\n          }\n        }\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s\",home,\n          directory,filename);\n#endif\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  if (*GetClientPath() != '\\0')\n    {\n      /*\n        Search based on executable directory.\n      */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",GetClientPath(),\n        DirectorySeparator,filename);\n#else\n      char\n        prefix[MaxTextExtent];\n\n      const char\n        *directory;\n\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=\"coders\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=\"filters\";\n          break;\n        }\n      }\n      (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);\n      ChopPathComponents(prefix,1);\n      (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s/%s\",prefix,\n        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);\n#endif\n      if (IsPathAccessible(path) != MagickFalse)\n        return(MagickTrue);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    /*\n      Search module path.\n    */\n    if ((NTGetModulePath(\"CORE_RL_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"CORE_DB_magick_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"Magick.dll\",path) != MagickFalse))\n      {\n        (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);\n        (void) ConcatenateMagickString(path,filename,MaxTextExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n#endif\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"XDG_CONFIG_HOME\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"LOCALAPPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"APPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"USERPROFILE\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $XDG_CONFIG_HOME/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%sImageMagick%s%s\",\n          home,DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n    home=GetEnvironmentValue(\"HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $HOME/.config/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\n          \"%s%s.config%sImageMagick%s%s\",home,DirectorySeparator,\n          DirectorySeparator,DirectorySeparator,filename);\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            home=DestroyString(home);\n            return(MagickTrue);\n          }\n        /*\n          Search $HOME/.magick.\n        */\n        (void) FormatLocaleString(path,MaxTextExtent,\"%s%s.magick%s%s\",home,\n          DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  /*\n    Search current directory.\n  */\n  if (IsPathAccessible(path) != MagickFalse)\n    return(MagickTrue);\n  if (exception->severity < ConfigureError)\n    ThrowFileException(exception,ConfigureWarning,\"UnableToOpenModuleFile\",\n      path);\n#endif\n  return(MagickFalse);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,15 @@\n   assert(path != (char *) NULL);\n   assert(exception != (ExceptionInfo *) NULL);\n   (void) CopyMagickString(path,filename,MaxTextExtent);\n+#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n+  if (strstr(path,\"../\") != (char *) NULL)\n+    {\n+      errno=EPERM;\n+      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n+        \"NotAuthorized\",\"`%s'\",path);\n+      return(MagickFalse);\n+    }\n+#endif\n   module_path=(char *) NULL;\n   switch (module_type)\n   {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#if defined(MAGICKCORE_INSTALLED_SUPPORT)",
                "  if (strstr(path,\"../\") != (char *) NULL)",
                "    {",
                "      errno=EPERM;",
                "      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,",
                "        \"NotAuthorized\",\"`%s'\",path);",
                "      return(MagickFalse);",
                "    }",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10047",
        "func_name": "ImageMagick/NewXMLTree",
        "description": "Memory leak in the NewXMLTree function in magick/xml-tree.c in ImageMagick before 6.9.4-7 allows remote attackers to cause a denial of service (memory consumption) via a crafted XML file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/fc6080f1321fd21e86ef916195cc110b05d9effb",
        "commit_title": "Coder path traversal is not authorized, bug report provided by Masaaki Chida",
        "commit_text": "",
        "func_before": "MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n{\n  char\n    **attribute,\n    **attributes,\n    *tag,\n    *utf8;\n\n  int\n    c,\n    terminal;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    ignore_depth,\n    length;\n\n  ssize_t\n    j,\n    l;\n\n  XMLTreeRoot\n    *root;\n\n  /*\n    Convert xml-string to UTF8.\n  */\n  if ((xml == (const char *) NULL) || (strlen(xml) == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return((XMLTreeInfo *) NULL);\n    }\n  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);\n  length=strlen(xml);\n  utf8=ConvertUTF16ToUTF8(xml,&length);\n  if (utf8 == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"UTF16 to UTF8 failed\");\n      return((XMLTreeInfo *) NULL);\n    }\n  terminal=utf8[length-1];\n  utf8[length-1]='\\0';\n  p=utf8;\n  while ((*p != '\\0') && (*p != '<'))\n    p++;\n  if (*p == '\\0')\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      utf8=DestroyString(utf8);\n      return((XMLTreeInfo *) NULL);\n    }\n  attribute=(char **) NULL;\n  l=0;\n  ignore_depth=0;\n  for (p++; ; p++)\n  {\n    attributes=(char **) sentinel;\n    tag=p;\n    c=(*p);\n    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||\n        (*p == ':') || (c < '\\0'))\n      {\n        /*\n          Tag.\n        */\n        if (root->node == (XMLTreeInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              OptionWarning,\"ParseError\",\"root tag missing\");\n            utf8=DestroyString(utf8);\n            return(&root->root);\n          }\n        p+=strcspn(p,XMLWhitespace \"/>\");\n        while (isspace((int) ((unsigned char) *p)) != 0)\n          *p++='\\0';\n        if (ignore_depth == 0)\n          {\n            if ((*p != '\\0') && (*p != '/') && (*p != '>'))\n              {\n                /*\n                  Find tag in default attributes list.\n                */\n                i=0;\n                while ((root->attributes[i] != (char **) NULL) &&\n                       (strcmp(root->attributes[i][0],tag) != 0))\n                  i++;\n                attribute=root->attributes[i];\n              }\n            for (l=0; (*p != '\\0') && (*p != '/') && (*p != '>'); l+=2)\n            {\n              /*\n                Attribute.\n              */\n              if (l == 0)\n                attributes=(char **) AcquireQuantumMemory(4,\n                  sizeof(*attributes));\n              else\n                attributes=(char **) ResizeQuantumMemory(attributes,\n                  (size_t) (l+4),sizeof(*attributes));\n              if (attributes == (char **) NULL)\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n              attributes[l+2]=(char *) NULL;\n              attributes[l+1]=(char *) NULL;\n              attributes[l]=p;\n              p+=strcspn(p,XMLWhitespace \"=/>\");\n              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))\n                attributes[l]=ConstantString(\"\");\n              else\n                {\n                  *p++='\\0';\n                  p+=strspn(p,XMLWhitespace \"=\");\n                  c=(*p);\n                  if ((c == '\"') || (c == '\\''))\n                    {\n                      /*\n                        Attributes value.\n                      */\n                      p++;\n                      attributes[l+1]=p;\n                      while ((*p != '\\0') && (*p != c))\n                        p++;\n                      if (*p != '\\0')\n                        *p++='\\0';\n                      else\n                        {\n                          attributes[l]=ConstantString(\"\");\n                          attributes[l+1]=ConstantString(\"\");\n                          (void) DestroyXMLTreeAttributes(attributes);\n                          (void) ThrowMagickException(exception,\n                            GetMagickModule(),OptionWarning,\"ParseError\",\n                            \"missing %c\",c);\n                          utf8=DestroyString(utf8);\n                          return(&root->root);\n                        }\n                      j=1;\n                      while ((attribute != (char **) NULL) &&\n                             (attribute[j] != (char *) NULL) &&\n                             (strcmp(attribute[j],attributes[l]) != 0))\n                        j+=3;\n                      attributes[l+1]=ParseEntities(attributes[l+1],\n                        root->entities,(attribute != (char **) NULL) &&\n                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :\n                        ' ');\n                    }\n                  attributes[l]=ConstantString(attributes[l]);\n                }\n              while (isspace((int) ((unsigned char) *p)) != 0)\n                p++;\n            }\n          }\n        else\n          {\n            while((*p != '\\0') && (*p != '/') && (*p != '>'))\n              p++;\n          }\n        if (*p == '/')\n          {\n            /*\n              Self closing tag.\n            */\n            *p++='\\0';\n            if (((*p != '\\0') && (*p != '>')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n              {\n                ParseOpenTag(root,tag,attributes);\n                (void) ParseCloseTag(root,tag,exception);\n              }\n          }\n        else\n          {\n            c=(*p);\n            if ((*p == '>') || ((*p == '\\0') && (terminal == '>')))\n              {\n                *p='\\0';\n                if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                  ParseOpenTag(root,tag,attributes);\n                else\n                  ignore_depth++;\n                *p=c;\n              }\n            else\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n      }\n    else\n      if (*p == '/')\n        {\n          /*\n            Close tag.\n          */\n          tag=p+1;\n          p+=strcspn(tag,XMLWhitespace \">\")+1;\n          c=(*p);\n          if ((c == '\\0') && (terminal != '>'))\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"ParseError\",\"missing >\");\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          *p='\\0';\n          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=\n              (XMLTreeInfo *) NULL)\n            {\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          if (ignore_depth > 0)\n            ignore_depth--;\n          *p=c;\n          if (isspace((int) ((unsigned char) *p)) != 0)\n            p+=strspn(p,XMLWhitespace);\n        }\n      else\n        if (strncmp(p,\"!--\",3) == 0)\n          {\n            /*\n              Comment.\n            */\n            p=strstr(p+3,\"--\");\n            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\\0')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"unclosed <!--\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n        else\n          if (strncmp(p,\"![CDATA[\",8) == 0)\n            {\n              /*\n                Cdata.\n              */\n              p=strstr(p,\"]]>\");\n              if (p != (char *) NULL)\n                {\n                  p+=2;\n                  if (ignore_depth == 0)\n                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unclosed <![CDATA[\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n            }\n          else\n            if (strncmp(p,\"!DOCTYPE\",8) == 0)\n              {\n                /*\n                  DTD.\n                */\n                for (l=0; (*p != '\\0') && (((l == 0) && (*p != '>')) ||\n                     ((l != 0) && ((*p != ']') ||\n                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));\n                  l=(ssize_t) ((*p == '[') ? 1 : l))\n                p+=strcspn(p+1,\"[]>\")+1;\n                if ((*p == '\\0') && (terminal != '>'))\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionWarning,\"ParseError\",\"unclosed <!DOCTYPE\");\n                    utf8=DestroyString(utf8);\n                    return(&root->root);\n                  }\n                if (l != 0)\n                  tag=strchr(tag,'[')+1;\n                if (l != 0)\n                  {\n                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),\n                      exception);\n                    if (status == MagickFalse)\n                      {\n                        utf8=DestroyString(utf8);\n                        return(&root->root);\n                      }\n                    p++;\n                  }\n              }\n            else\n              if (*p == '?')\n                {\n                  /*\n                    Processing instructions.\n                  */\n                  do\n                  {\n                    p=strchr(p,'?');\n                    if (p == (char *) NULL)\n                      break;\n                    p++;\n                  } while ((*p != '\\0') && (*p != '>'));\n                  if ((p == (char *) NULL) || ((*p == '\\0') &&\n                      (terminal != '>')))\n                    {\n                      (void) ThrowMagickException(exception,GetMagickModule(),\n                        OptionWarning,\"ParseError\",\"unclosed <?\");\n                      utf8=DestroyString(utf8);\n                      return(&root->root);\n                    }\n                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unexpected <\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n     if ((p == (char *) NULL) || (*p == '\\0'))\n       break;\n     *p++='\\0';\n     tag=p;\n     if ((*p != '\\0') && (*p != '<'))\n       {\n        /*\n          Tag character content.\n        */\n        while ((*p != '\\0') && (*p != '<'))\n          p++;\n        if (*p == '\\0')\n          break;\n        if (ignore_depth == 0)\n          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');\n      }\n    else\n      if (*p == '\\0')\n        break;\n  }\n  utf8=DestroyString(utf8);\n  if (root->node == (XMLTreeInfo *) NULL)\n    return(&root->root);\n  if (root->node->tag == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return(&root->root);\n    }\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n    \"ParseError\",\"unclosed tag: `%s'\",root->node->tag);\n  return(&root->root);\n}",
        "func": "MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n{\n  char\n    **attribute,\n    **attributes,\n    *tag,\n    *utf8;\n\n  int\n    c,\n    terminal;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    ignore_depth,\n    length;\n\n  ssize_t\n    j,\n    l;\n\n  XMLTreeRoot\n    *root;\n\n  /*\n    Convert xml-string to UTF8.\n  */\n  if ((xml == (const char *) NULL) || (strlen(xml) == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return((XMLTreeInfo *) NULL);\n    }\n  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);\n  length=strlen(xml);\n  utf8=ConvertUTF16ToUTF8(xml,&length);\n  if (utf8 == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"UTF16 to UTF8 failed\");\n      return((XMLTreeInfo *) NULL);\n    }\n  terminal=utf8[length-1];\n  utf8[length-1]='\\0';\n  p=utf8;\n  while ((*p != '\\0') && (*p != '<'))\n    p++;\n  if (*p == '\\0')\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      utf8=DestroyString(utf8);\n      return((XMLTreeInfo *) NULL);\n    }\n  attribute=(char **) NULL;\n  l=0;\n  ignore_depth=0;\n  for (p++; ; p++)\n  {\n    attributes=(char **) sentinel;\n    tag=p;\n    c=(*p);\n    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||\n        (*p == ':') || (c < '\\0'))\n      {\n        /*\n          Tag.\n        */\n        if (root->node == (XMLTreeInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              OptionWarning,\"ParseError\",\"root tag missing\");\n            utf8=DestroyString(utf8);\n            return(&root->root);\n          }\n        p+=strcspn(p,XMLWhitespace \"/>\");\n        while (isspace((int) ((unsigned char) *p)) != 0)\n          *p++='\\0';\n        if (ignore_depth == 0)\n          {\n            if ((*p != '\\0') && (*p != '/') && (*p != '>'))\n              {\n                /*\n                  Find tag in default attributes list.\n                */\n                i=0;\n                while ((root->attributes[i] != (char **) NULL) &&\n                       (strcmp(root->attributes[i][0],tag) != 0))\n                  i++;\n                attribute=root->attributes[i];\n              }\n            for (l=0; (*p != '\\0') && (*p != '/') && (*p != '>'); l+=2)\n            {\n              /*\n                Attribute.\n              */\n              if (l == 0)\n                attributes=(char **) AcquireQuantumMemory(4,\n                  sizeof(*attributes));\n              else\n                attributes=(char **) ResizeQuantumMemory(attributes,\n                  (size_t) (l+4),sizeof(*attributes));\n              if (attributes == (char **) NULL)\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n              attributes[l+2]=(char *) NULL;\n              attributes[l+1]=(char *) NULL;\n              attributes[l]=p;\n              p+=strcspn(p,XMLWhitespace \"=/>\");\n              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))\n                attributes[l]=ConstantString(\"\");\n              else\n                {\n                  *p++='\\0';\n                  p+=strspn(p,XMLWhitespace \"=\");\n                  c=(*p);\n                  if ((c == '\"') || (c == '\\''))\n                    {\n                      /*\n                        Attributes value.\n                      */\n                      p++;\n                      attributes[l+1]=p;\n                      while ((*p != '\\0') && (*p != c))\n                        p++;\n                      if (*p != '\\0')\n                        *p++='\\0';\n                      else\n                        {\n                          attributes[l]=ConstantString(\"\");\n                          attributes[l+1]=ConstantString(\"\");\n                          (void) DestroyXMLTreeAttributes(attributes);\n                          (void) ThrowMagickException(exception,\n                            GetMagickModule(),OptionWarning,\"ParseError\",\n                            \"missing %c\",c);\n                          utf8=DestroyString(utf8);\n                          return(&root->root);\n                        }\n                      j=1;\n                      while ((attribute != (char **) NULL) &&\n                             (attribute[j] != (char *) NULL) &&\n                             (strcmp(attribute[j],attributes[l]) != 0))\n                        j+=3;\n                      attributes[l+1]=ParseEntities(attributes[l+1],\n                        root->entities,(attribute != (char **) NULL) &&\n                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :\n                        ' ');\n                    }\n                  attributes[l]=ConstantString(attributes[l]);\n                }\n              while (isspace((int) ((unsigned char) *p)) != 0)\n                p++;\n            }\n          }\n        else\n          {\n            while((*p != '\\0') && (*p != '/') && (*p != '>'))\n              p++;\n          }\n        if (*p == '/')\n          {\n            /*\n              Self closing tag.\n            */\n            *p++='\\0';\n            if (((*p != '\\0') && (*p != '>')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n              {\n                ParseOpenTag(root,tag,attributes);\n                (void) ParseCloseTag(root,tag,exception);\n              }\n          }\n        else\n          {\n            c=(*p);\n            if ((*p == '>') || ((*p == '\\0') && (terminal == '>')))\n              {\n                *p='\\0';\n                if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                  ParseOpenTag(root,tag,attributes);\n                else\n                  {\n                    ignore_depth++;\n                    (void) DestroyXMLTreeAttributes(attributes);\n                  }\n                *p=c;\n              }\n            else\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n      }\n    else\n      if (*p == '/')\n        {\n          /*\n            Close tag.\n          */\n          tag=p+1;\n          p+=strcspn(tag,XMLWhitespace \">\")+1;\n          c=(*p);\n          if ((c == '\\0') && (terminal != '>'))\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"ParseError\",\"missing >\");\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          *p='\\0';\n          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=\n              (XMLTreeInfo *) NULL)\n            {\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          if (ignore_depth > 0)\n            ignore_depth--;\n          *p=c;\n          if (isspace((int) ((unsigned char) *p)) != 0)\n            p+=strspn(p,XMLWhitespace);\n        }\n      else\n        if (strncmp(p,\"!--\",3) == 0)\n          {\n            /*\n              Comment.\n            */\n            p=strstr(p+3,\"--\");\n            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\\0')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"unclosed <!--\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n        else\n          if (strncmp(p,\"![CDATA[\",8) == 0)\n            {\n              /*\n                Cdata.\n              */\n              p=strstr(p,\"]]>\");\n              if (p != (char *) NULL)\n                {\n                  p+=2;\n                  if (ignore_depth == 0)\n                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unclosed <![CDATA[\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n            }\n          else\n            if (strncmp(p,\"!DOCTYPE\",8) == 0)\n              {\n                /*\n                  DTD.\n                */\n                for (l=0; (*p != '\\0') && (((l == 0) && (*p != '>')) ||\n                     ((l != 0) && ((*p != ']') ||\n                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));\n                  l=(ssize_t) ((*p == '[') ? 1 : l))\n                p+=strcspn(p+1,\"[]>\")+1;\n                if ((*p == '\\0') && (terminal != '>'))\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionWarning,\"ParseError\",\"unclosed <!DOCTYPE\");\n                    utf8=DestroyString(utf8);\n                    return(&root->root);\n                  }\n                if (l != 0)\n                  tag=strchr(tag,'[')+1;\n                if (l != 0)\n                  {\n                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),\n                      exception);\n                    if (status == MagickFalse)\n                      {\n                        utf8=DestroyString(utf8);\n                        return(&root->root);\n                      }\n                    p++;\n                  }\n              }\n            else\n              if (*p == '?')\n                {\n                  /*\n                    Processing instructions.\n                  */\n                  do\n                  {\n                    p=strchr(p,'?');\n                    if (p == (char *) NULL)\n                      break;\n                    p++;\n                  } while ((*p != '\\0') && (*p != '>'));\n                  if ((p == (char *) NULL) || ((*p == '\\0') &&\n                      (terminal != '>')))\n                    {\n                      (void) ThrowMagickException(exception,GetMagickModule(),\n                        OptionWarning,\"ParseError\",\"unclosed <?\");\n                      utf8=DestroyString(utf8);\n                      return(&root->root);\n                    }\n                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unexpected <\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n     if ((p == (char *) NULL) || (*p == '\\0'))\n       break;\n     *p++='\\0';\n     tag=p;\n     if ((*p != '\\0') && (*p != '<'))\n       {\n        /*\n          Tag character content.\n        */\n        while ((*p != '\\0') && (*p != '<'))\n          p++;\n        if (*p == '\\0')\n          break;\n        if (ignore_depth == 0)\n          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');\n      }\n    else\n      if (*p == '\\0')\n        break;\n  }\n  utf8=DestroyString(utf8);\n  if (root->node == (XMLTreeInfo *) NULL)\n    return(&root->root);\n  if (root->node->tag == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return(&root->root);\n    }\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n    \"ParseError\",\"unclosed tag: `%s'\",root->node->tag);\n  return(&root->root);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -200,7 +200,10 @@\n                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                   ParseOpenTag(root,tag,attributes);\n                 else\n-                  ignore_depth++;\n+                  {\n+                    ignore_depth++;\n+                    (void) DestroyXMLTreeAttributes(attributes);\n+                  }\n                 *p=c;\n               }\n             else",
        "diff_line_info": {
            "deleted_lines": [
                "                  ignore_depth++;"
            ],
            "added_lines": [
                "                  {",
                "                    ignore_depth++;",
                "                    (void) DestroyXMLTreeAttributes(attributes);",
                "                  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8314",
        "func_name": "xbmc/CZipManager::GetZipList",
        "description": "Directory Traversal in Zip Extraction built-in function in Kodi 17.1 and earlier allows arbitrary file write on disk via a Zip file as subtitles.",
        "git_url": "https://github.com/xbmc/xbmc/commit/35cfe35608b15335ef21d798947fceab3f47c8d7",
        "commit_title": "[filesystem] ZipManager: skip path traversal",
        "commit_text": "",
        "func_before": "bool CZipManager::GetZipList(const CURL& url, std::vector<SZipEntry>& items)\n{\n  struct __stat64 m_StatData = {};\n\n  std::string strFile = url.GetHostName();\n\n  if (CFile::Stat(strFile,&m_StatData))\n  {\n    CLog::Log(LOGDEBUG,\"CZipManager::GetZipList: failed to stat file %s\", url.GetRedacted().c_str());\n    return false;\n  }\n\n  std::map<std::string, std::vector<SZipEntry> >::iterator it = mZipMap.find(strFile);\n  if (it != mZipMap.end()) // already listed, just return it if not changed, else release and reread\n  {\n    std::map<std::string,int64_t>::iterator it2=mZipDate.find(strFile);\n\n    if (m_StatData.st_mtime == it2->second)\n    {\n      items = it->second;\n      return true;\n    }\n    mZipMap.erase(it);\n    mZipDate.erase(it2);\n  }\n\n  CFile mFile;\n  if (!mFile.Open(strFile))\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: unable to open file %s!\",strFile.c_str());\n    return false;\n  }\n\n  unsigned int hdr;\n  if (mFile.Read(&hdr, 4)!=4 || (Endian_SwapLE32(hdr) != ZIP_LOCAL_HEADER &&\n                                 Endian_SwapLE32(hdr) != ZIP_DATA_RECORD_HEADER &&\n                                 Endian_SwapLE32(hdr) != ZIP_SPLIT_ARCHIVE_HEADER))\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: not a zip file!\");\n    mFile.Close();\n    return false;\n  }\n\n  if (Endian_SwapLE32(hdr) == ZIP_SPLIT_ARCHIVE_HEADER)\n    CLog::LogF(LOGWARNING, \"ZIP split archive header found. Trying to process as a single archive..\");\n\n  // push date for update detection\n  mZipDate.insert(make_pair(strFile,m_StatData.st_mtime));\n\n\n  // Look for end of central directory record\n  // Zipfile comment may be up to 65535 bytes\n  // End of central directory record is 22 bytes (ECDREC_SIZE)\n  // -> need to check the last 65557 bytes\n  int64_t fileSize = mFile.GetLength();\n  // Don't need to look in the last 18 bytes (ECDREC_SIZE-4)\n  // But as we need to do overlapping between blocks (3 bytes),\n  // we start the search at ECDREC_SIZE-1 from the end of file\n  if (fileSize < ECDREC_SIZE - 1)\n  {\n    CLog::Log(LOGERROR, \"ZipManager: Invalid zip file length: %\" PRId64\"\", fileSize);\n    return false;\n  }\n  int searchSize = (int) std::min(static_cast<int64_t>(65557), fileSize-ECDREC_SIZE+1);\n  int blockSize = (int) std::min(1024, searchSize);\n  int nbBlock = searchSize / blockSize;\n  int extraBlockSize = searchSize % blockSize;\n  // Signature is on 4 bytes\n  // It could be between 2 blocks, so we need to read 3 extra bytes\n  auto_buffer buffer(blockSize + 3);\n  bool found = false;\n\n  // Loop through blocks starting at the end of the file (minus ECDREC_SIZE-1)\n  for (int nb=1; !found && (nb <= nbBlock); nb++)\n  {\n    mFile.Seek(fileSize-ECDREC_SIZE+1-(blockSize*nb),SEEK_SET);\n    if (mFile.Read(buffer.get(), blockSize + 3) != blockSize + 3)\n      return false;\n    for (int i=blockSize-1; !found && (i >= 0); i--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(buffer.get()+i))) == ZIP_END_CENTRAL_HEADER )\n      {\n        // Set current position to start of end of central directory\n        mFile.Seek(fileSize-ECDREC_SIZE+1-(blockSize*nb)+i,SEEK_SET);\n        found = true;\n      }\n    }\n  }\n\n  // If not found, look in the last block left...\n  if ( !found && (extraBlockSize > 0) )\n  {\n    mFile.Seek(fileSize-ECDREC_SIZE+1-searchSize,SEEK_SET);\n    if (mFile.Read(buffer.get(), extraBlockSize + 3) != extraBlockSize + 3)\n      return false;\n    for (int i=extraBlockSize-1; !found && (i >= 0); i--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(buffer.get()+i))) == ZIP_END_CENTRAL_HEADER )\n      {\n        // Set current position to start of end of central directory\n        mFile.Seek(fileSize-ECDREC_SIZE+1-searchSize+i,SEEK_SET);\n        found = true;\n      }\n    }\n  }\n\n  buffer.clear();\n\n  if ( !found )\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: broken file %s!\",strFile.c_str());\n    mFile.Close();\n    return false;\n  }\n\n  unsigned int cdirOffset, cdirSize;\n  // Get size of the central directory\n  mFile.Seek(12,SEEK_CUR);\n  if (mFile.Read(&cdirSize, 4) != 4)\n    return false;\n  cdirSize = Endian_SwapLE32(cdirSize);\n  // Get Offset of start of central directory with respect to the starting disk number\n  if (mFile.Read(&cdirOffset, 4) != 4)\n    return false;\n  cdirOffset = Endian_SwapLE32(cdirOffset);\n\n  // Go to the start of central directory\n  mFile.Seek(cdirOffset,SEEK_SET);\n\n  char temp[CHDR_SIZE];\n  while (mFile.GetPosition() < cdirOffset + cdirSize)\n  {\n    SZipEntry ze;\n    if (mFile.Read(temp, CHDR_SIZE) != CHDR_SIZE)\n      return false;\n    readCHeader(temp, ze);\n    if (ze.header != ZIP_CENTRAL_HEADER)\n    {\n      CLog::Log(LOGDEBUG,\"ZipManager: broken file %s!\",strFile.c_str());\n      mFile.Close();\n      return false;\n    }\n\n    // Get the filename just after the central file header\n    auto_buffer bufName(ze.flength);\n    if (mFile.Read(bufName.get(), ze.flength) != ze.flength)\n      return false;\n    std::string strName(bufName.get(), bufName.size());\n    bufName.clear();\n    g_charsetConverter.unknownToUTF8(strName);\n    ZeroMemory(ze.name, 255);\n    strncpy(ze.name, strName.c_str(), strName.size()>254 ? 254 : strName.size());\n\n    // Jump after central file header extra field and file comment\n    mFile.Seek(ze.eclength + ze.clength,SEEK_CUR);\n\n    items.push_back(ze);\n  }\n\n  /* go through list and figure out file header lengths */\n  for(std::vector<SZipEntry>::iterator it = items.begin(); it != items.end(); ++it)\n  {\n    SZipEntry& ze = *it;\n    // Go to the local file header to get the extra field length\n    // !! local header extra field length != central file header extra field length !!\n    mFile.Seek(ze.lhdrOffset+28,SEEK_SET);\n    if (mFile.Read(&(ze.elength), 2) != 2)\n      return false;\n    ze.elength = Endian_SwapLE16(ze.elength);\n\n    // Compressed data offset = local header offset + size of local header + filename length + local file header extra field length\n    ze.offset = ze.lhdrOffset + LHDR_SIZE + ze.flength + ze.elength;\n\n  }\n\n  mZipMap.insert(make_pair(strFile,items));\n  mFile.Close();\n  return true;\n}",
        "func": "bool CZipManager::GetZipList(const CURL& url, std::vector<SZipEntry>& items)\n{\n  struct __stat64 m_StatData = {};\n\n  std::string strFile = url.GetHostName();\n\n  if (CFile::Stat(strFile,&m_StatData))\n  {\n    CLog::Log(LOGDEBUG,\"CZipManager::GetZipList: failed to stat file %s\", url.GetRedacted().c_str());\n    return false;\n  }\n\n  std::map<std::string, std::vector<SZipEntry> >::iterator it = mZipMap.find(strFile);\n  if (it != mZipMap.end()) // already listed, just return it if not changed, else release and reread\n  {\n    std::map<std::string,int64_t>::iterator it2=mZipDate.find(strFile);\n\n    if (m_StatData.st_mtime == it2->second)\n    {\n      items = it->second;\n      return true;\n    }\n    mZipMap.erase(it);\n    mZipDate.erase(it2);\n  }\n\n  CFile mFile;\n  if (!mFile.Open(strFile))\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: unable to open file %s!\",strFile.c_str());\n    return false;\n  }\n\n  unsigned int hdr;\n  if (mFile.Read(&hdr, 4)!=4 || (Endian_SwapLE32(hdr) != ZIP_LOCAL_HEADER &&\n                                 Endian_SwapLE32(hdr) != ZIP_DATA_RECORD_HEADER &&\n                                 Endian_SwapLE32(hdr) != ZIP_SPLIT_ARCHIVE_HEADER))\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: not a zip file!\");\n    mFile.Close();\n    return false;\n  }\n\n  if (Endian_SwapLE32(hdr) == ZIP_SPLIT_ARCHIVE_HEADER)\n    CLog::LogF(LOGWARNING, \"ZIP split archive header found. Trying to process as a single archive..\");\n\n  // push date for update detection\n  mZipDate.insert(make_pair(strFile,m_StatData.st_mtime));\n\n\n  // Look for end of central directory record\n  // Zipfile comment may be up to 65535 bytes\n  // End of central directory record is 22 bytes (ECDREC_SIZE)\n  // -> need to check the last 65557 bytes\n  int64_t fileSize = mFile.GetLength();\n  // Don't need to look in the last 18 bytes (ECDREC_SIZE-4)\n  // But as we need to do overlapping between blocks (3 bytes),\n  // we start the search at ECDREC_SIZE-1 from the end of file\n  if (fileSize < ECDREC_SIZE - 1)\n  {\n    CLog::Log(LOGERROR, \"ZipManager: Invalid zip file length: %\" PRId64\"\", fileSize);\n    return false;\n  }\n  int searchSize = (int) std::min(static_cast<int64_t>(65557), fileSize-ECDREC_SIZE+1);\n  int blockSize = (int) std::min(1024, searchSize);\n  int nbBlock = searchSize / blockSize;\n  int extraBlockSize = searchSize % blockSize;\n  // Signature is on 4 bytes\n  // It could be between 2 blocks, so we need to read 3 extra bytes\n  auto_buffer buffer(blockSize + 3);\n  bool found = false;\n\n  // Loop through blocks starting at the end of the file (minus ECDREC_SIZE-1)\n  for (int nb=1; !found && (nb <= nbBlock); nb++)\n  {\n    mFile.Seek(fileSize-ECDREC_SIZE+1-(blockSize*nb),SEEK_SET);\n    if (mFile.Read(buffer.get(), blockSize + 3) != blockSize + 3)\n      return false;\n    for (int i=blockSize-1; !found && (i >= 0); i--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(buffer.get()+i))) == ZIP_END_CENTRAL_HEADER )\n      {\n        // Set current position to start of end of central directory\n        mFile.Seek(fileSize-ECDREC_SIZE+1-(blockSize*nb)+i,SEEK_SET);\n        found = true;\n      }\n    }\n  }\n\n  // If not found, look in the last block left...\n  if ( !found && (extraBlockSize > 0) )\n  {\n    mFile.Seek(fileSize-ECDREC_SIZE+1-searchSize,SEEK_SET);\n    if (mFile.Read(buffer.get(), extraBlockSize + 3) != extraBlockSize + 3)\n      return false;\n    for (int i=extraBlockSize-1; !found && (i >= 0); i--)\n    {\n      if ( Endian_SwapLE32(*((unsigned int*)(buffer.get()+i))) == ZIP_END_CENTRAL_HEADER )\n      {\n        // Set current position to start of end of central directory\n        mFile.Seek(fileSize-ECDREC_SIZE+1-searchSize+i,SEEK_SET);\n        found = true;\n      }\n    }\n  }\n\n  buffer.clear();\n\n  if ( !found )\n  {\n    CLog::Log(LOGDEBUG,\"ZipManager: broken file %s!\",strFile.c_str());\n    mFile.Close();\n    return false;\n  }\n\n  unsigned int cdirOffset, cdirSize;\n  // Get size of the central directory\n  mFile.Seek(12,SEEK_CUR);\n  if (mFile.Read(&cdirSize, 4) != 4)\n    return false;\n  cdirSize = Endian_SwapLE32(cdirSize);\n  // Get Offset of start of central directory with respect to the starting disk number\n  if (mFile.Read(&cdirOffset, 4) != 4)\n    return false;\n  cdirOffset = Endian_SwapLE32(cdirOffset);\n\n  // Go to the start of central directory\n  mFile.Seek(cdirOffset,SEEK_SET);\n\n  char temp[CHDR_SIZE];\n  while (mFile.GetPosition() < cdirOffset + cdirSize)\n  {\n    SZipEntry ze;\n    if (mFile.Read(temp, CHDR_SIZE) != CHDR_SIZE)\n      return false;\n    readCHeader(temp, ze);\n    if (ze.header != ZIP_CENTRAL_HEADER)\n    {\n      CLog::Log(LOGDEBUG,\"ZipManager: broken file %s!\",strFile.c_str());\n      mFile.Close();\n      return false;\n    }\n\n    // Get the filename just after the central file header\n    auto_buffer bufName(ze.flength);\n    if (mFile.Read(bufName.get(), ze.flength) != ze.flength)\n      return false;\n    std::string strName(bufName.get(), bufName.size());\n    bufName.clear();\n    g_charsetConverter.unknownToUTF8(strName);\n    ZeroMemory(ze.name, 255);\n    strncpy(ze.name, strName.c_str(), strName.size()>254 ? 254 : strName.size());\n\n    // Jump after central file header extra field and file comment\n    mFile.Seek(ze.eclength + ze.clength,SEEK_CUR);\n\n    if (!std::regex_search(strName, PATH_TRAVERSAL))\n      items.push_back(ze);\n  }\n\n  /* go through list and figure out file header lengths */\n  for(std::vector<SZipEntry>::iterator it = items.begin(); it != items.end(); ++it)\n  {\n    SZipEntry& ze = *it;\n    // Go to the local file header to get the extra field length\n    // !! local header extra field length != central file header extra field length !!\n    mFile.Seek(ze.lhdrOffset+28,SEEK_SET);\n    if (mFile.Read(&(ze.elength), 2) != 2)\n      return false;\n    ze.elength = Endian_SwapLE16(ze.elength);\n\n    // Compressed data offset = local header offset + size of local header + filename length + local file header extra field length\n    ze.offset = ze.lhdrOffset + LHDR_SIZE + ze.flength + ze.elength;\n\n  }\n\n  mZipMap.insert(make_pair(strFile,items));\n  mFile.Close();\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -154,7 +154,8 @@\n     // Jump after central file header extra field and file comment\n     mFile.Seek(ze.eclength + ze.clength,SEEK_CUR);\n \n-    items.push_back(ze);\n+    if (!std::regex_search(strName, PATH_TRAVERSAL))\n+      items.push_back(ze);\n   }\n \n   /* go through list and figure out file header lengths */",
        "diff_line_info": {
            "deleted_lines": [
                "    items.push_back(ze);"
            ],
            "added_lines": [
                "    if (!std::regex_search(strName, PATH_TRAVERSAL))",
                "      items.push_back(ze);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14036",
        "func_name": "accountsservice/user_change_icon_file_authorized_cb",
        "description": "Directory Traversal with ../ sequences occurs in AccountsService before 0.6.50 because of an insufficient path check in user_change_icon_file_authorized_cb() in user.c.",
        "git_url": "https://cgit.freedesktop.org/accountsservice/commit/?id=f9abd359f71a5bce421b9ae23432f539a067847a",
        "commit_title": "The path prefix check can be circumvented by regular users by passing",
        "commit_text": "relative path component like so:  $ dbus-send --system --print-reply --dest=org.freedesktop.Accounts \\         /org/freedesktop/Accounts/User1000 \\         org.freedesktop.Accounts.User.SetIconFile \\         string:/usr/share/../../tmp/test  This results in a user controlled path being stored in the accountsservice. Clients of accountsservice may unwittingly trust this path.  To fix that situation this commit canonicalizes the input path before the prefix comparison.  Some small changes to patch by Ray Strode.  https://bugs.freedesktop.org/show_bug.cgi?id=107085 ",
        "func_before": "static void\nuser_change_icon_file_authorized_cb (Daemon                *daemon,\n                                     User                  *user,\n                                     GDBusMethodInvocation *context,\n                                     gpointer               data)\n\n{\n        g_autofree gchar *filename = NULL;\n        g_autoptr(GFile) file = NULL;\n        g_autoptr(GFileInfo) info = NULL;\n        guint32 mode;\n        GFileType type;\n        guint64 size;\n\n        filename = g_strdup (data);\n\n        if (filename == NULL ||\n            *filename == '\\0') {\n                g_autofree gchar *dest_path = NULL;\n                g_autoptr(GFile) dest = NULL;\n                g_autoptr(GError) error = NULL;\n\n                g_clear_pointer (&filename, g_free);\n\n                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);\n                dest = g_file_new_for_path (dest_path);\n\n                if (!g_file_delete (dest, NULL, &error) &&\n                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n                        throw_error (context, ERROR_FAILED, \"failed to remove user icon, %s\", error->message);\n                        return;\n                }\n                goto icon_saved;\n        }\n\n        file = g_file_new_for_path (filename);\n        info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE \",\"\n                                        G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                        G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                                  0, NULL, NULL);\n        mode = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n        type = g_file_info_get_file_type (info);\n        size = g_file_info_get_attribute_uint64 (info, G_FILE_ATTRIBUTE_STANDARD_SIZE);\n\n        if (type != G_FILE_TYPE_REGULAR) {\n                g_debug (\"not a regular file\");\n                throw_error (context, ERROR_FAILED, \"file '%s' is not a regular file\", filename);\n                return;\n        }\n\n        if (size > 1048576) {\n                g_debug (\"file too large\");\n                /* 1MB ought to be enough for everybody */\n                throw_error (context, ERROR_FAILED, \"file '%s' is too large to be used as an icon\", filename);\n                return;\n        }\n\n        if ((mode & S_IROTH) == 0 ||\n            (!g_str_has_prefix (filename, DATADIR) &&\n             !g_str_has_prefix (filename, ICONDIR))) {\n                g_autofree gchar *dest_path = NULL;\n                g_autoptr(GFile) dest = NULL;\n                const gchar *argv[3];\n                gint std_out;\n                g_autoptr(GError) error = NULL;\n                g_autoptr(GInputStream) input = NULL;\n                g_autoptr(GOutputStream) output = NULL;\n                gint uid;\n                gssize bytes;\n                struct passwd *pw;\n\n                if (!get_caller_uid (context, &uid)) {\n                        throw_error (context, ERROR_FAILED, \"failed to copy file, could not determine caller UID\");\n                        return;\n                }\n\n                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);\n                dest = g_file_new_for_path (dest_path);\n\n                output = G_OUTPUT_STREAM (g_file_replace (dest, NULL, FALSE, 0, NULL, &error));\n                if (!output) {\n                        throw_error (context, ERROR_FAILED, \"creating file '%s' failed: %s\", dest_path, error->message);\n                        return;\n                }\n\n                argv[0] = \"/bin/cat\";\n                argv[1] = filename;\n                argv[2] = NULL;\n\n                pw = getpwuid (uid);\n\n                if (!g_spawn_async_with_pipes (NULL, (gchar**)argv, NULL, 0, become_user, pw, NULL, NULL, &std_out, NULL, &error)) {\n                        throw_error (context, ERROR_FAILED, \"reading file '%s' failed: %s\", filename, error->message);\n                        return;\n                }\n\n                input = g_unix_input_stream_new (std_out, FALSE);\n\n                bytes = g_output_stream_splice (output, input, G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET, NULL, &error);\n                if (bytes < 0 || (gsize)bytes != size) {\n                        throw_error (context, ERROR_FAILED, \"copying file '%s' to '%s' failed: %s\", filename, dest_path, error ? error->message : \"unknown reason\");\n                        g_file_delete (dest, NULL, NULL);\n                        return;\n                }\n\n                g_free (filename);\n                filename = g_steal_pointer (&dest_path);\n        }\n\nicon_saved:\n        accounts_user_set_icon_file (ACCOUNTS_USER (user), filename);\n        g_clear_pointer (&filename, g_free);\n\n        save_extra_data (user);\n\n        accounts_user_complete_set_icon_file (ACCOUNTS_USER (user), context);\n}",
        "func": "static void\nuser_change_icon_file_authorized_cb (Daemon                *daemon,\n                                     User                  *user,\n                                     GDBusMethodInvocation *context,\n                                     gpointer               data)\n\n{\n        g_autofree gchar *filename = NULL;\n        g_autoptr(GFile) file = NULL;\n        g_autoptr(GFileInfo) info = NULL;\n        guint32 mode;\n        GFileType type;\n        guint64 size;\n\n        filename = g_strdup (data);\n\n        if (filename == NULL ||\n            *filename == '\\0') {\n                g_autofree gchar *dest_path = NULL;\n                g_autoptr(GFile) dest = NULL;\n                g_autoptr(GError) error = NULL;\n\n                g_clear_pointer (&filename, g_free);\n\n                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);\n                dest = g_file_new_for_path (dest_path);\n\n                if (!g_file_delete (dest, NULL, &error) &&\n                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n                        throw_error (context, ERROR_FAILED, \"failed to remove user icon, %s\", error->message);\n                        return;\n                }\n                goto icon_saved;\n        }\n\n        file = g_file_new_for_path (filename);\n        g_clear_pointer (&filename, g_free);\n\n        /* Canonicalize path so we can call g_str_has_prefix on it\n         * below without concern for ../ path components moving outside\n         * the prefix\n         */\n        filename = g_file_get_path (file);\n\n        info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE \",\"\n                                        G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                        G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                                  0, NULL, NULL);\n        mode = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n        type = g_file_info_get_file_type (info);\n        size = g_file_info_get_attribute_uint64 (info, G_FILE_ATTRIBUTE_STANDARD_SIZE);\n\n        if (type != G_FILE_TYPE_REGULAR) {\n                g_debug (\"not a regular file\");\n                throw_error (context, ERROR_FAILED, \"file '%s' is not a regular file\", filename);\n                return;\n        }\n\n        if (size > 1048576) {\n                g_debug (\"file too large\");\n                /* 1MB ought to be enough for everybody */\n                throw_error (context, ERROR_FAILED, \"file '%s' is too large to be used as an icon\", filename);\n                return;\n        }\n\n        if ((mode & S_IROTH) == 0 ||\n            (!g_str_has_prefix (filename, DATADIR) &&\n             !g_str_has_prefix (filename, ICONDIR))) {\n                g_autofree gchar *dest_path = NULL;\n                g_autoptr(GFile) dest = NULL;\n                const gchar *argv[3];\n                gint std_out;\n                g_autoptr(GError) error = NULL;\n                g_autoptr(GInputStream) input = NULL;\n                g_autoptr(GOutputStream) output = NULL;\n                gint uid;\n                gssize bytes;\n                struct passwd *pw;\n\n                if (!get_caller_uid (context, &uid)) {\n                        throw_error (context, ERROR_FAILED, \"failed to copy file, could not determine caller UID\");\n                        return;\n                }\n\n                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);\n                dest = g_file_new_for_path (dest_path);\n\n                output = G_OUTPUT_STREAM (g_file_replace (dest, NULL, FALSE, 0, NULL, &error));\n                if (!output) {\n                        throw_error (context, ERROR_FAILED, \"creating file '%s' failed: %s\", dest_path, error->message);\n                        return;\n                }\n\n                argv[0] = \"/bin/cat\";\n                argv[1] = filename;\n                argv[2] = NULL;\n\n                pw = getpwuid (uid);\n\n                if (!g_spawn_async_with_pipes (NULL, (gchar**)argv, NULL, 0, become_user, pw, NULL, NULL, &std_out, NULL, &error)) {\n                        throw_error (context, ERROR_FAILED, \"reading file '%s' failed: %s\", filename, error->message);\n                        return;\n                }\n\n                input = g_unix_input_stream_new (std_out, FALSE);\n\n                bytes = g_output_stream_splice (output, input, G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET, NULL, &error);\n                if (bytes < 0 || (gsize)bytes != size) {\n                        throw_error (context, ERROR_FAILED, \"copying file '%s' to '%s' failed: %s\", filename, dest_path, error ? error->message : \"unknown reason\");\n                        g_file_delete (dest, NULL, NULL);\n                        return;\n                }\n\n                g_free (filename);\n                filename = g_steal_pointer (&dest_path);\n        }\n\nicon_saved:\n        accounts_user_set_icon_file (ACCOUNTS_USER (user), filename);\n        g_clear_pointer (&filename, g_free);\n\n        save_extra_data (user);\n\n        accounts_user_complete_set_icon_file (ACCOUNTS_USER (user), context);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,6 +34,14 @@\n         }\n \n         file = g_file_new_for_path (filename);\n+        g_clear_pointer (&filename, g_free);\n+\n+        /* Canonicalize path so we can call g_str_has_prefix on it\n+         * below without concern for ../ path components moving outside\n+         * the prefix\n+         */\n+        filename = g_file_get_path (file);\n+\n         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        g_clear_pointer (&filename, g_free);",
                "",
                "        /* Canonicalize path so we can call g_str_has_prefix on it",
                "         * below without concern for ../ path components moving outside",
                "         * the prefix",
                "         */",
                "        filename = g_file_get_path (file);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14056",
        "func_name": "znc/CWebSock::GetSkinPath",
        "description": "ZNC before 1.7.1-rc1 is prone to a path traversal flaw via ../ in a web skin name to access files outside of the intended skins directories.",
        "git_url": "https://github.com/znc/znc/commit/a4a5aeeb17d32937d8c7d743dae9a4cc755ce773",
        "commit_title": "Don't let web skin name ../../../../ access files outside of usual skins directories.",
        "commit_text": " Thanks for Jeriko One <jeriko.one@gmx.us> for finding and reporting this.",
        "func_before": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n\n    return sRet + \"/\";\n}",
        "func": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkin;\n        }\n    }\n\n    return sRet + \"/\";\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,13 @@\n CString CWebSock::GetSkinPath(const CString& sSkinName) {\n-    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n+    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n+\n+    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;\n \n     if (!CFile::IsDir(sRet)) {\n-        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n+        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;\n \n         if (!CFile::IsDir(sRet)) {\n-            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n+            sRet = CString(_SKINDIR_) + \"/\" + sSkin;\n         }\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;",
                "        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;",
                "            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;"
            ],
            "added_lines": [
                "    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");",
                "",
                "    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;",
                "        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;",
                "            sRet = CString(_SKINDIR_) + \"/\" + sSkin;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14355",
        "func_name": "neomutt/imap_hcache_open",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/util.c mishandles \"..\" directory traversal in a mailbox name.",
        "git_url": "https://github.com/neomutt/neomutt/commit/57971dba06346b2d7179294f4528b8d4427a7c5d",
        "commit_title": "Selectively cache headers",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}",
        "func": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,12 @@\n     FREE(&mx.mbox);\n   }\n \n+  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n+    return NULL;\n+  size_t len = strlen(mbox);\n+  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n+    return NULL;\n+\n   mutt_account_tourl(&idata->conn->account, &url);\n   url.path = mbox;\n   url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))",
                "    return NULL;",
                "  size_t len = strlen(mbox);",
                "  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))",
                "    return NULL;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14362",
        "func_name": "neomutt/msg_cache_check",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c does not forbid characters that may have unsafe interaction with message-cache pathnames, as demonstrated by a '/' character.",
        "git_url": "https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e",
        "commit_title": "sanitise cache paths",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  /* keep hcache file if hcache == bcache */\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* if the id we get is known for a header: done (i.e. keep in cache) */\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n  /* message not found in context -> remove it from cache\n   * return the result of bcache, so we stop upon its first error\n   */\n  return mutt_bcache_del(bcache, id);\n}",
        "func": "static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  /* keep hcache file if hcache == bcache */\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* if the id we get is known for a header: done (i.e. keep in cache) */\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n  /* message not found in context -> remove it from cache\n   * return the result of bcache, so we stop upon its first error\n   */\n  return mutt_bcache_del(bcache, cache_id(id));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,5 +23,5 @@\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n-  return mutt_bcache_del(bcache, id);\n+  return mutt_bcache_del(bcache, cache_id(id));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return mutt_bcache_del(bcache, id);"
            ],
            "added_lines": [
                "  return mutt_bcache_del(bcache, cache_id(id));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14362",
        "func_name": "neomutt/pop_fetch_headers",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c does not forbid characters that may have unsafe interaction with message-cache pathnames, as demonstrated by a '/' character.",
        "git_url": "https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e",
        "commit_title": "sanitise cache paths",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "static int pop_fetch_headers(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n\n#ifdef USE_HCACHE\n  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n  time(&pop_data->check_time);\n  pop_data->clear_cache = false;\n\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->refno = -1;\n\n  const int old_count = ctx->msgcount;\n  int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);\n  const int new_count = ctx->msgcount;\n  ctx->msgcount = old_count;\n\n  if (pop_data->cmd_uidl == 2)\n  {\n    if (ret == 0)\n    {\n      pop_data->cmd_uidl = 1;\n\n      mutt_debug(1, \"set UIDL capability\\n\");\n    }\n\n    if (ret == -2 && pop_data->cmd_uidl == 2)\n    {\n      pop_data->cmd_uidl = 0;\n\n      mutt_debug(1, \"unset UIDL capability\\n\");\n      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n               _(\"Command UIDL is not supported by server.\"));\n    }\n  }\n\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);\n  }\n\n  if (ret == 0)\n  {\n    int i, deleted;\n    for (i = 0, deleted = 0; i < old_count; i++)\n    {\n      if (ctx->hdrs[i]->refno == -1)\n      {\n        ctx->hdrs[i]->deleted = true;\n        deleted++;\n      }\n    }\n    if (deleted > 0)\n    {\n      mutt_error(\n          ngettext(\"%d message has been lost. Try reopening the mailbox.\",\n                   \"%d messages have been lost. Try reopening the mailbox.\", deleted),\n          deleted);\n    }\n\n    bool hcached = false;\n    for (i = old_count; i < new_count; i++)\n    {\n      if (!ctx->quiet)\n        mutt_progress_update(&progress, i + 1 - old_count, -1);\n#ifdef USE_HCACHE\n      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n      if (data)\n      {\n        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);\n        int refno = ctx->hdrs[i]->refno;\n        int index = ctx->hdrs[i]->index;\n        /*\n         * - POP dynamically numbers headers and relies on h->refno\n         *   to map messages; so restore header and overwrite restored\n         *   refno with current refno, same for index\n         * - h->data needs to a separate pointer as it's driver-specific\n         *   data freed separately elsewhere\n         *   (the old h->data should point inside a malloc'd block from\n         *   hcache so there shouldn't be a memleak here)\n         */\n        struct Header *h = mutt_hcache_restore((unsigned char *) data);\n        mutt_hcache_free(hc, &data);\n        mutt_header_free(&ctx->hdrs[i]);\n        ctx->hdrs[i] = h;\n        ctx->hdrs[i]->refno = refno;\n        ctx->hdrs[i]->index = index;\n        ctx->hdrs[i]->data = uidl;\n        ret = 0;\n        hcached = true;\n      }\n      else\n#endif\n          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)\n        break;\n#ifdef USE_HCACHE\n      else\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n\n      /*\n       * faked support for flags works like this:\n       * - if 'hcached' is true, we have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: old\n       *          (if $mark_old is set which is maybe wrong as\n       *          $mark_old should be considered for syncing the\n       *          folder and not when opening it XXX)\n       * - if 'hcached' is false, we don't have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: new\n       */\n      const bool bcached =\n          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n      ctx->hdrs[i]->old = false;\n      ctx->hdrs[i]->read = false;\n      if (hcached)\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n        else if (MarkOld)\n          ctx->hdrs[i]->old = true;\n      }\n      else\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n      }\n\n      ctx->msgcount++;\n    }\n\n    if (i > old_count)\n      mx_update_context(ctx, i - old_count);\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n\n  if (ret < 0)\n  {\n    for (int i = ctx->msgcount; i < new_count; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    return ret;\n  }\n\n  /* after putting the result into our structures,\n   * clean up cache, i.e. wipe messages deleted outside\n   * the availability of our cache\n   */\n  if (MessageCacheClean)\n    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);\n\n  mutt_clear_error();\n  return (new_count - old_count);\n}",
        "func": "static int pop_fetch_headers(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n\n#ifdef USE_HCACHE\n  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n  time(&pop_data->check_time);\n  pop_data->clear_cache = false;\n\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->refno = -1;\n\n  const int old_count = ctx->msgcount;\n  int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);\n  const int new_count = ctx->msgcount;\n  ctx->msgcount = old_count;\n\n  if (pop_data->cmd_uidl == 2)\n  {\n    if (ret == 0)\n    {\n      pop_data->cmd_uidl = 1;\n\n      mutt_debug(1, \"set UIDL capability\\n\");\n    }\n\n    if (ret == -2 && pop_data->cmd_uidl == 2)\n    {\n      pop_data->cmd_uidl = 0;\n\n      mutt_debug(1, \"unset UIDL capability\\n\");\n      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n               _(\"Command UIDL is not supported by server.\"));\n    }\n  }\n\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);\n  }\n\n  if (ret == 0)\n  {\n    int i, deleted;\n    for (i = 0, deleted = 0; i < old_count; i++)\n    {\n      if (ctx->hdrs[i]->refno == -1)\n      {\n        ctx->hdrs[i]->deleted = true;\n        deleted++;\n      }\n    }\n    if (deleted > 0)\n    {\n      mutt_error(\n          ngettext(\"%d message has been lost. Try reopening the mailbox.\",\n                   \"%d messages have been lost. Try reopening the mailbox.\", deleted),\n          deleted);\n    }\n\n    bool hcached = false;\n    for (i = old_count; i < new_count; i++)\n    {\n      if (!ctx->quiet)\n        mutt_progress_update(&progress, i + 1 - old_count, -1);\n#ifdef USE_HCACHE\n      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n      if (data)\n      {\n        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);\n        int refno = ctx->hdrs[i]->refno;\n        int index = ctx->hdrs[i]->index;\n        /*\n         * - POP dynamically numbers headers and relies on h->refno\n         *   to map messages; so restore header and overwrite restored\n         *   refno with current refno, same for index\n         * - h->data needs to a separate pointer as it's driver-specific\n         *   data freed separately elsewhere\n         *   (the old h->data should point inside a malloc'd block from\n         *   hcache so there shouldn't be a memleak here)\n         */\n        struct Header *h = mutt_hcache_restore((unsigned char *) data);\n        mutt_hcache_free(hc, &data);\n        mutt_header_free(&ctx->hdrs[i]);\n        ctx->hdrs[i] = h;\n        ctx->hdrs[i]->refno = refno;\n        ctx->hdrs[i]->index = index;\n        ctx->hdrs[i]->data = uidl;\n        ret = 0;\n        hcached = true;\n      }\n      else\n#endif\n          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)\n        break;\n#ifdef USE_HCACHE\n      else\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n\n      /*\n       * faked support for flags works like this:\n       * - if 'hcached' is true, we have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: old\n       *          (if $mark_old is set which is maybe wrong as\n       *          $mark_old should be considered for syncing the\n       *          folder and not when opening it XXX)\n       * - if 'hcached' is false, we don't have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: new\n       */\n      const bool bcached =\n          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n      ctx->hdrs[i]->old = false;\n      ctx->hdrs[i]->read = false;\n      if (hcached)\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n        else if (MarkOld)\n          ctx->hdrs[i]->old = true;\n      }\n      else\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n      }\n\n      ctx->msgcount++;\n    }\n\n    if (i > old_count)\n      mx_update_context(ctx, i - old_count);\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n\n  if (ret < 0)\n  {\n    for (int i = ctx->msgcount; i < new_count; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    return ret;\n  }\n\n  /* after putting the result into our structures,\n   * clean up cache, i.e. wipe messages deleted outside\n   * the availability of our cache\n   */\n  if (MessageCacheClean)\n    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);\n\n  mutt_clear_error();\n  return (new_count - old_count);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -118,7 +118,7 @@\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n-          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n+          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)",
        "diff_line_info": {
            "deleted_lines": [
                "          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);"
            ],
            "added_lines": [
                "          (mutt_bcache_exists(pop_data->bcache, cache_id(ctx->hdrs[i]->data)) == 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14362",
        "func_name": "neomutt/pop_sync_mailbox",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c does not forbid characters that may have unsafe interaction with message-cache pathnames, as demonstrated by a '/' character.",
        "git_url": "https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e",
        "commit_title": "sanitise cache paths",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  pop_data->check_time = 0;\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    mutt_progress_init(&progress, _(\"Marking messages deleted...\"),\n                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n\n#ifdef USE_HCACHE\n    hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n    }\n\n#ifdef USE_HCACHE\n    mutt_hcache_close(hc);\n#endif\n\n    if (ret == 0)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(pop_data, buf, sizeof(buf));\n    }\n\n    if (ret == 0)\n    {\n      pop_data->clear_cache = true;\n      pop_clear_cache(pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n  }\n}",
        "func": "static int pop_sync_mailbox(struct Context *ctx, int *index_hint)\n{\n  int i, j, ret = 0;\n  char buf[LONG_STRING];\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n#ifdef USE_HCACHE\n  header_cache_t *hc = NULL;\n#endif\n\n  pop_data->check_time = 0;\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    mutt_progress_init(&progress, _(\"Marking messages deleted...\"),\n                       MUTT_PROGRESS_MSG, WriteInc, ctx->deleted);\n\n#ifdef USE_HCACHE\n    hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n    for (i = 0, j = 0, ret = 0; ret == 0 && i < ctx->msgcount; i++)\n    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n    }\n\n#ifdef USE_HCACHE\n    mutt_hcache_close(hc);\n#endif\n\n    if (ret == 0)\n    {\n      mutt_str_strfcpy(buf, \"QUIT\\r\\n\", sizeof(buf));\n      ret = pop_query(pop_data, buf, sizeof(buf));\n    }\n\n    if (ret == 0)\n    {\n      pop_data->clear_cache = true;\n      pop_clear_cache(pop_data);\n      pop_data->status = POP_DISCONNECTED;\n      return 0;\n    }\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,7 @@\n         ret = pop_query(pop_data, buf, sizeof(buf));\n         if (ret == 0)\n         {\n-          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n+          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n #ifdef USE_HCACHE\n           mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);"
            ],
            "added_lines": [
                "          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14362",
        "func_name": "neomutt/pop_fetch_message",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c does not forbid characters that may have unsafe interaction with message-cache pathnames, as demonstrated by a '/' character.",
        "git_url": "https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e",
        "commit_title": "sanitise cache paths",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)\n{\n  void *uidl = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  struct Progress progressbar;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct PopCache *cache = NULL;\n  struct Header *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n  if (msg->fp)\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      /* yes, so just return a pointer to the message */\n      msg->fp = fopen(cache->path, \"r\");\n      if (msg->fp)\n        return 0;\n\n      mutt_perror(cache->path);\n      return -1;\n    }\n    else\n    {\n      /* clear the previous entry */\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    /* verify that massage index is correct */\n    if (h->refno < 0)\n    {\n      mutt_error(\n          _(\"The message index is incorrect. Try reopening the mailbox.\"));\n      return -1;\n    }\n\n    mutt_progress_init(&progressbar, _(\"Fetching message...\"), MUTT_PROGRESS_SIZE,\n                       NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n    if (!msg->fp)\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp(path, sizeof(path));\n      msg->fp = mutt_file_fopen(path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(path);\n        return -1;\n      }\n    }\n\n    snprintf(buf, sizeof(buf), \"RETR %d\\r\\n\", h->refno);\n\n    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    mutt_file_fclose(&msg->fp);\n\n    /* if RETR failed (e.g. connection closed), be sure to remove either\n     * the file in bcache or from POP's own cache since the next iteration\n     * of the loop will re-attempt to put() the message */\n    if (!bcache)\n      unlink(path);\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error(_(\"Can't write message to temporary file!\"));\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit(pop_data->bcache, h->data);\n  else\n  {\n    cache->index = h->index;\n    cache->path = mutt_str_strdup(path);\n  }\n  rewind(msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_remove(ctx, h);\n  mutt_env_free(&h->env);\n  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add(ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftello(msg->fp) - h->content->offset;\n\n  /* This needs to be done in case this is a multipart message */\n  if (!WithCrypto)\n    h->security = crypt_query(h->content);\n\n  mutt_clear_error();\n  rewind(msg->fp);\n\n  return 0;\n}",
        "func": "static int pop_fetch_message(struct Context *ctx, struct Message *msg, int msgno)\n{\n  void *uidl = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  struct Progress progressbar;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct PopCache *cache = NULL;\n  struct Header *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n  if (msg->fp)\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    if (cache->index == h->index)\n    {\n      /* yes, so just return a pointer to the message */\n      msg->fp = fopen(cache->path, \"r\");\n      if (msg->fp)\n        return 0;\n\n      mutt_perror(cache->path);\n      return -1;\n    }\n    else\n    {\n      /* clear the previous entry */\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  while (true)\n  {\n    if (pop_reconnect(ctx) < 0)\n      return -1;\n\n    /* verify that massage index is correct */\n    if (h->refno < 0)\n    {\n      mutt_error(\n          _(\"The message index is incorrect. Try reopening the mailbox.\"));\n      return -1;\n    }\n\n    mutt_progress_init(&progressbar, _(\"Fetching message...\"), MUTT_PROGRESS_SIZE,\n                       NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n    if (!msg->fp)\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp(path, sizeof(path));\n      msg->fp = mutt_file_fopen(path, \"w+\");\n      if (!msg->fp)\n      {\n        mutt_perror(path);\n        return -1;\n      }\n    }\n\n    snprintf(buf, sizeof(buf), \"RETR %d\\r\\n\", h->refno);\n\n    const int ret = pop_fetch_data(pop_data, buf, &progressbar, fetch_message, msg->fp);\n    if (ret == 0)\n      break;\n\n    mutt_file_fclose(&msg->fp);\n\n    /* if RETR failed (e.g. connection closed), be sure to remove either\n     * the file in bcache or from POP's own cache since the next iteration\n     * of the loop will re-attempt to put() the message */\n    if (!bcache)\n      unlink(path);\n\n    if (ret == -2)\n    {\n      mutt_error(\"%s\", pop_data->err_msg);\n      return -1;\n    }\n\n    if (ret == -3)\n    {\n      mutt_error(_(\"Can't write message to temporary file!\"));\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n  else\n  {\n    cache->index = h->index;\n    cache->path = mutt_str_strdup(path);\n  }\n  rewind(msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_delete(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_remove(ctx, h);\n  mutt_env_free(&h->env);\n  h->env = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  if (ctx->subj_hash && h->env->real_subj)\n    mutt_hash_insert(ctx->subj_hash, h->env->real_subj, h);\n  mutt_label_hash_add(ctx, h);\n\n  h->data = uidl;\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    ctx->hdrs[msgno]->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftello(msg->fp) - h->content->offset;\n\n  /* This needs to be done in case this is a multipart message */\n  if (!WithCrypto)\n    h->security = crypt_query(h->content);\n\n  mutt_clear_error();\n  rewind(msg->fp);\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n   unsigned short bcache = 1;\n \n   /* see if we already have the message in body cache */\n-  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);\n+  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));\n   if (msg->fp)\n     return 0;\n \n@@ -57,7 +57,7 @@\n                        NetInc, h->content->length + h->content->offset - 1);\n \n     /* see if we can put in body cache; use our cache as fallback */\n-    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);\n+    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));\n     if (!msg->fp)\n     {\n       /* no */\n@@ -102,7 +102,7 @@\n    * portion of the headers, those required for the main display.\n    */\n   if (bcache)\n-    mutt_bcache_commit(pop_data->bcache, h->data);\n+    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));\n   else\n   {\n     cache->index = h->index;",
        "diff_line_info": {
            "deleted_lines": [
                "  msg->fp = mutt_bcache_get(pop_data->bcache, h->data);",
                "    msg->fp = mutt_bcache_put(pop_data->bcache, h->data);",
                "    mutt_bcache_commit(pop_data->bcache, h->data);"
            ],
            "added_lines": [
                "  msg->fp = mutt_bcache_get(pop_data->bcache, cache_id(h->data));",
                "    msg->fp = mutt_bcache_put(pop_data->bcache, cache_id(h->data));",
                "    mutt_bcache_commit(pop_data->bcache, cache_id(h->data));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14362",
        "func_name": "neomutt/nntp_hcache_namer",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c does not forbid characters that may have unsafe interaction with message-cache pathnames, as demonstrated by a '/' character.",
        "git_url": "https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e",
        "commit_title": "sanitise cache paths",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.hcache\", path);\n}",
        "func": "static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  int count = snprintf(dest, destlen, \"%s.hcache\", path);\n\n  /* Strip out any directories in the path */\n  char *first = strchr(dest, '/');\n  char *last = strrchr(dest, '/');\n  if (first && last && (last > first))\n  {\n    memmove(first, last, strlen(last) + 1);\n    count -= (last - first);\n  }\n\n  return count;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,15 @@\n static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n {\n-  return snprintf(dest, destlen, \"%s.hcache\", path);\n+  int count = snprintf(dest, destlen, \"%s.hcache\", path);\n+\n+  /* Strip out any directories in the path */\n+  char *first = strchr(dest, '/');\n+  char *last = strrchr(dest, '/');\n+  if (first && last && (last > first))\n+  {\n+    memmove(first, last, strlen(last) + 1);\n+    count -= (last - first);\n+  }\n+\n+  return count;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return snprintf(dest, destlen, \"%s.hcache\", path);"
            ],
            "added_lines": [
                "  int count = snprintf(dest, destlen, \"%s.hcache\", path);",
                "",
                "  /* Strip out any directories in the path */",
                "  char *first = strchr(dest, '/');",
                "  char *last = strrchr(dest, '/');",
                "  if (first && last && (last > first))",
                "  {",
                "    memmove(first, last, strlen(last) + 1);",
                "    count -= (last - first);",
                "  }",
                "",
                "  return count;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1002209",
        "func_name": "stachenov/quazip/JlCompress::extractDir",
        "description": "QuaZIP before 0.7.6 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in a Zip archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'.",
        "git_url": "https://github.com/stachenov/quazip/commit/5d2fc16a1976e5bf78d2927b012f67a2ae047a98",
        "commit_title": "Fixed the Zip Slip vulnerability in JlCompress",
        "commit_text": " When extracting a file with a dangerous path like \"../evil.exe\" from a ZIP archive with JlCompress::extractDir(), the target file would be created outside of the target directory, potentially even overwriting an existing file there.",
        "func_before": "QStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n\n    QDir directory(dir);\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        if (!extractFile(&zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n\n    return extracted;\n}",
        "func": "QStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n    QString cleanDir = QDir::cleanPath(dir);\n    QDir directory(cleanDir);\n    QString absCleanDir = directory.absolutePath();\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        QString absCleanPath = QDir::cleanPath(absFilePath);\n        if (!absCleanPath.startsWith(absCleanDir + \"/\"))\n            continue;\n        if (!extractFile(&zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n\n    return extracted;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,9 @@\n     if(!zip.open(QuaZip::mdUnzip)) {\n         return QStringList();\n     }\n-\n-    QDir directory(dir);\n+    QString cleanDir = QDir::cleanPath(dir);\n+    QDir directory(cleanDir);\n+    QString absCleanDir = directory.absolutePath();\n     QStringList extracted;\n     if (!zip.goToFirstFile()) {\n         return QStringList();\n@@ -12,6 +13,9 @@\n     do {\n         QString name = zip.getCurrentFileName();\n         QString absFilePath = directory.absoluteFilePath(name);\n+        QString absCleanPath = QDir::cleanPath(absFilePath);\n+        if (!absCleanPath.startsWith(absCleanDir + \"/\"))\n+            continue;\n         if (!extractFile(&zip, \"\", absFilePath)) {\n             removeFile(extracted);\n             return QStringList();",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "    QDir directory(dir);"
            ],
            "added_lines": [
                "    QString cleanDir = QDir::cleanPath(dir);",
                "    QDir directory(cleanDir);",
                "    QString absCleanDir = directory.absolutePath();",
                "        QString absCleanPath = QDir::cleanPath(absFilePath);",
                "        if (!absCleanPath.startsWith(absCleanDir + \"/\"))",
                "            continue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19666",
        "func_name": "ossec/ossec-hids/ReadExecConfig",
        "description": "The agent in OSSEC through 3.1.0 on Windows allows local users to gain NT AUTHORITY\\SYSTEM access via Directory Traversal by leveraging full access to the associated OSSEC server.",
        "git_url": "https://github.com/ossec/ossec-hids/commit/c72bb25d9114250d570dddb27ae0cfc0de30c45e",
        "commit_title": "Backport directory-traversal fix from Wazuh.",
        "commit_text": "",
        "func_before": "int ReadExecConfig()\n{\n    int i = 0, j = 0, dup_entry = 0;\n    FILE *fp;\n    FILE *process_file;\n    char buffer[OS_MAXSTR + 1];\n\n    /* Clean up */\n    for (i = 0; i <= exec_size + 1; i++) {\n        memset(exec_names[i], '\\0', OS_FLSIZE + 1);\n        memset(exec_cmd[i], '\\0', OS_FLSIZE + 1);\n        exec_timeout[i] = 0;\n    }\n    exec_size = 0;\n\n    /* Open file */\n    fp = fopen(DEFAULTARPATH, \"r\");\n    if (!fp) {\n        merror(FOPEN_ERROR, ARGV0, DEFAULTARPATH, errno, strerror(errno));\n        return (0);\n    }\n\n    /* Read config */\n    while (fgets(buffer, OS_MAXSTR, fp) != NULL) {\n        char *str_pt;\n        char *tmp_str;\n\n        str_pt = buffer;\n\n        /* Clean up the buffer */\n        tmp_str = strchr(buffer, ' ');\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n            continue;\n        }\n        *tmp_str = '\\0';\n        tmp_str++;\n\n        /* Search for ' ' and - */\n        if (*tmp_str == '-') {\n            tmp_str += 2;\n        } else {\n            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n            continue;\n        }\n\n        /* Set the name */\n        strncpy(exec_names[exec_size], str_pt, OS_FLSIZE);\n        exec_names[exec_size][OS_FLSIZE] = '\\0';\n\n        str_pt = tmp_str;\n\n        tmp_str = strchr(tmp_str, ' ');\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n            continue;\n        }\n        *tmp_str = '\\0';\n\n        /* Write the full command path */\n        snprintf(exec_cmd[exec_size], OS_FLSIZE,\n                 \"%s/%s\",\n                 AR_BINDIRPATH,\n                 str_pt);\n        process_file = fopen(exec_cmd[exec_size], \"r\");\n        if (!process_file) {\n            if (f_time_reading) {\n                verbose(\"%s: INFO: Active response command not present: '%s'. \"\n                        \"Not using it on this system.\",\n                        ARGV0, exec_cmd[exec_size]);\n            }\n\n            exec_cmd[exec_size][0] = '\\0';\n        } else {\n            fclose(process_file);\n        }\n\n        /* Search for ' ' and - */\n        tmp_str++;\n        if (*tmp_str == '-') {\n            tmp_str += 2;\n        } else {\n            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n            continue;\n        }\n\n        str_pt = tmp_str;\n        tmp_str = strchr(tmp_str, '\\n');\n        if (tmp_str) {\n            *tmp_str = '\\0';\n        }\n\n        /* Get the exec timeout */\n        exec_timeout[exec_size] = atoi(str_pt);\n\n        /* Check if name is duplicated */\n        dup_entry = 0;\n        for (j = 0; j < exec_size; j++) {\n            if (strcmp(exec_names[j], exec_names[exec_size]) == 0) {\n                if (exec_cmd[j][0] == '\\0') {\n                    strncpy(exec_cmd[j], exec_cmd[exec_size], OS_FLSIZE);\n                    exec_cmd[j][OS_FLSIZE] = '\\0';\n                    dup_entry = 1;\n                    break;\n                } else if (exec_cmd[exec_size][0] == '\\0') {\n                    dup_entry = 1;\n                }\n            }\n        }\n\n        if (dup_entry) {\n            exec_cmd[exec_size][0] = '\\0';\n            exec_names[exec_size][0] = '\\0';\n            exec_timeout[exec_size] = 0;\n        } else {\n            exec_size++;\n        }\n    }\n\n    fclose(fp);\n    f_time_reading = 0;\n\n    return (1);\n}",
        "func": "int ReadExecConfig()\n{\n    int i = 0, j = 0, dup_entry = 0;\n    FILE *fp;\n    FILE *process_file;\n    char buffer[OS_MAXSTR + 1];\n\n    /* Clean up */\n    for (i = 0; i <= exec_size + 1; i++) {\n        memset(exec_names[i], '\\0', OS_FLSIZE + 1);\n        memset(exec_cmd[i], '\\0', OS_FLSIZE + 1);\n        exec_timeout[i] = 0;\n    }\n    exec_size = 0;\n\n    /* Open file */\n    fp = fopen(DEFAULTARPATH, \"r\");\n    if (!fp) {\n        merror(FOPEN_ERROR, ARGV0, DEFAULTARPATH, errno, strerror(errno));\n        return (0);\n    }\n\n    /* Read config */\n    while (fgets(buffer, OS_MAXSTR, fp) != NULL) {\n        char *str_pt;\n        char *tmp_str;\n\n        str_pt = buffer;\n\n        /* Clean up the buffer */\n        tmp_str = strstr(buffer, \" - \");\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n            continue;\n        }\n        *tmp_str = '\\0';\n        tmp_str += 3;\n\n        /* Set the name */\n        strncpy(exec_names[exec_size], str_pt, OS_FLSIZE);\n        exec_names[exec_size][OS_FLSIZE] = '\\0';\n\n        str_pt = tmp_str;\n\n        /* Search for ' ' and - */\n        tmp_str = strstr(tmp_str, \" - \");\n        if (!tmp_str) {\n            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n            continue;\n        }\n        *tmp_str = '\\0';\n        tmp_str += 3;\n\n        // Directory traversal test\n\n        if (w_ref_parent_folder(str_pt)) {\n            merror(\"Active response command '%s' vulnerable to directory transversal attack. Ignoring.\", str_pt);\n             exec_cmd[exec_size][0] = '\\0';\n         } else {\n            /* Write the full command path */\n            snprintf(exec_cmd[exec_size], OS_FLSIZE,\n                     \"%s/%s\",\n                     AR_BINDIRPATH,\n                     str_pt);\n            process_file = fopen(exec_cmd[exec_size], \"r\");\n            if (!process_file) {\n                if (f_time_reading) {\n                    verbose(\"%s: INFO: Active response command not present: '%s'. \"\n                            \"Not using it on this system.\",\n                            ARGV0, exec_cmd[exec_size]);\n                }\n\n                exec_cmd[exec_size][0] = '\\0';\n            } else {\n                fclose(process_file);\n            }\n        }\n\n        str_pt = tmp_str;\n        tmp_str = strchr(tmp_str, '\\n');\n        if (tmp_str) {\n            *tmp_str = '\\0';\n        }\n\n        /* Get the exec timeout */\n        exec_timeout[exec_size] = atoi(str_pt);\n\n        /* Check if name is duplicated */\n        dup_entry = 0;\n        for (j = 0; j < exec_size; j++) {\n            if (strcmp(exec_names[j], exec_names[exec_size]) == 0) {\n                if (exec_cmd[j][0] == '\\0') {\n                    strncpy(exec_cmd[j], exec_cmd[exec_size], OS_FLSIZE);\n                    exec_cmd[j][OS_FLSIZE] = '\\0';\n                    dup_entry = 1;\n                    break;\n                } else if (exec_cmd[exec_size][0] == '\\0') {\n                    dup_entry = 1;\n                }\n            }\n        }\n\n        if (dup_entry) {\n            exec_cmd[exec_size][0] = '\\0';\n            exec_names[exec_size][0] = '\\0';\n            exec_timeout[exec_size] = 0;\n        } else {\n            exec_size++;\n        }\n    }\n\n    fclose(fp);\n    f_time_reading = 0;\n\n    return (1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,21 +28,13 @@\n         str_pt = buffer;\n \n         /* Clean up the buffer */\n-        tmp_str = strchr(buffer, ' ');\n+        tmp_str = strstr(buffer, \" - \");\n         if (!tmp_str) {\n             merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n             continue;\n         }\n         *tmp_str = '\\0';\n-        tmp_str++;\n-\n-        /* Search for ' ' and - */\n-        if (*tmp_str == '-') {\n-            tmp_str += 2;\n-        } else {\n-            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n-            continue;\n-        }\n+        tmp_str += 3;\n \n         /* Set the name */\n         strncpy(exec_names[exec_size], str_pt, OS_FLSIZE);\n@@ -50,38 +42,38 @@\n \n         str_pt = tmp_str;\n \n-        tmp_str = strchr(tmp_str, ' ');\n+        /* Search for ' ' and - */\n+        tmp_str = strstr(tmp_str, \" - \");\n         if (!tmp_str) {\n             merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n             continue;\n         }\n         *tmp_str = '\\0';\n+        tmp_str += 3;\n \n-        /* Write the full command path */\n-        snprintf(exec_cmd[exec_size], OS_FLSIZE,\n-                 \"%s/%s\",\n-                 AR_BINDIRPATH,\n-                 str_pt);\n-        process_file = fopen(exec_cmd[exec_size], \"r\");\n-        if (!process_file) {\n-            if (f_time_reading) {\n-                verbose(\"%s: INFO: Active response command not present: '%s'. \"\n-                        \"Not using it on this system.\",\n-                        ARGV0, exec_cmd[exec_size]);\n+        // Directory traversal test\n+\n+        if (w_ref_parent_folder(str_pt)) {\n+            merror(\"Active response command '%s' vulnerable to directory transversal attack. Ignoring.\", str_pt);\n+             exec_cmd[exec_size][0] = '\\0';\n+         } else {\n+            /* Write the full command path */\n+            snprintf(exec_cmd[exec_size], OS_FLSIZE,\n+                     \"%s/%s\",\n+                     AR_BINDIRPATH,\n+                     str_pt);\n+            process_file = fopen(exec_cmd[exec_size], \"r\");\n+            if (!process_file) {\n+                if (f_time_reading) {\n+                    verbose(\"%s: INFO: Active response command not present: '%s'. \"\n+                            \"Not using it on this system.\",\n+                            ARGV0, exec_cmd[exec_size]);\n+                }\n+\n+                exec_cmd[exec_size][0] = '\\0';\n+            } else {\n+                fclose(process_file);\n             }\n-\n-            exec_cmd[exec_size][0] = '\\0';\n-        } else {\n-            fclose(process_file);\n-        }\n-\n-        /* Search for ' ' and - */\n-        tmp_str++;\n-        if (*tmp_str == '-') {\n-            tmp_str += 2;\n-        } else {\n-            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);\n-            continue;\n         }\n \n         str_pt = tmp_str;",
        "diff_line_info": {
            "deleted_lines": [
                "        tmp_str = strchr(buffer, ' ');",
                "        tmp_str++;",
                "",
                "        /* Search for ' ' and - */",
                "        if (*tmp_str == '-') {",
                "            tmp_str += 2;",
                "        } else {",
                "            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);",
                "            continue;",
                "        }",
                "        tmp_str = strchr(tmp_str, ' ');",
                "        /* Write the full command path */",
                "        snprintf(exec_cmd[exec_size], OS_FLSIZE,",
                "                 \"%s/%s\",",
                "                 AR_BINDIRPATH,",
                "                 str_pt);",
                "        process_file = fopen(exec_cmd[exec_size], \"r\");",
                "        if (!process_file) {",
                "            if (f_time_reading) {",
                "                verbose(\"%s: INFO: Active response command not present: '%s'. \"",
                "                        \"Not using it on this system.\",",
                "                        ARGV0, exec_cmd[exec_size]);",
                "",
                "            exec_cmd[exec_size][0] = '\\0';",
                "        } else {",
                "            fclose(process_file);",
                "        }",
                "",
                "        /* Search for ' ' and - */",
                "        tmp_str++;",
                "        if (*tmp_str == '-') {",
                "            tmp_str += 2;",
                "        } else {",
                "            merror(EXEC_INV_CONF, ARGV0, DEFAULTARPATH);",
                "            continue;"
            ],
            "added_lines": [
                "        tmp_str = strstr(buffer, \" - \");",
                "        tmp_str += 3;",
                "        /* Search for ' ' and - */",
                "        tmp_str = strstr(tmp_str, \" - \");",
                "        tmp_str += 3;",
                "        // Directory traversal test",
                "",
                "        if (w_ref_parent_folder(str_pt)) {",
                "            merror(\"Active response command '%s' vulnerable to directory transversal attack. Ignoring.\", str_pt);",
                "             exec_cmd[exec_size][0] = '\\0';",
                "         } else {",
                "            /* Write the full command path */",
                "            snprintf(exec_cmd[exec_size], OS_FLSIZE,",
                "                     \"%s/%s\",",
                "                     AR_BINDIRPATH,",
                "                     str_pt);",
                "            process_file = fopen(exec_cmd[exec_size], \"r\");",
                "            if (!process_file) {",
                "                if (f_time_reading) {",
                "                    verbose(\"%s: INFO: Active response command not present: '%s'. \"",
                "                            \"Not using it on this system.\",",
                "                            ARGV0, exec_cmd[exec_size]);",
                "                }",
                "",
                "                exec_cmd[exec_size][0] = '\\0';",
                "            } else {",
                "                fclose(process_file);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-31272",
        "func_name": "SerenityOS/serenity/main",
        "description": "SerenityOS before commit 3844e8569689dd476064a0759d704bc64fb3ca2c contains a directory traversal vulnerability in tar/unzip that may lead to command execution or privilege escalation.",
        "git_url": "https://github.com/SerenityOS/serenity/commit/3844e8569689dd476064a0759d704bc64fb3ca2c",
        "commit_title": "Userland: Fix tar/unzip directory traversal vulnerability",
        "commit_text": " This change validates the filenames within a tar/zip archive during extraction. If the filename within a the archive is outside of the current working directory the file will be skipped and not extracted onto the host system.  Closes #3991 Closes #3992",
        "func_before": "int main(int argc, char** argv)\n{\n    const char* path;\n    int map_size_limit = 32 * MiB;\n\n    Core::ArgsParser args_parser;\n    args_parser.add_option(map_size_limit, \"Maximum chunk size to map\", \"map-size-limit\", 0, \"size\");\n    args_parser.add_positional_argument(path, \"File to unzip\", \"path\", Core::ArgsParser::Required::Yes);\n    args_parser.parse(argc, argv);\n\n    String zip_file_path { path };\n\n    struct stat st;\n    int rc = stat(zip_file_path.characters(), &st);\n    if (rc < 0) {\n        perror(\"stat\");\n        return 1;\n    }\n\n    // FIXME: Map file chunk-by-chunk once we have mmap() with offset.\n    //        This will require mapping some parts then unmapping them repeatedly,\n    //        but it would be significantly faster and less syscall heavy than seek()/read() at every read.\n    if (st.st_size >= map_size_limit) {\n        fprintf(stderr, \"unzip warning: Refusing to map file since it is larger than %s, pass '--map-size-limit %d' to get around this\\n\",\n            human_readable_size(map_size_limit).characters(),\n            round_up_to_power_of_two(st.st_size, 16));\n        return 1;\n    }\n\n    auto file_or_error = MappedFile ::map(zip_file_path);\n    if (file_or_error.is_error()) {\n        warnln(\"Failed to open {}: {}\", zip_file_path, file_or_error.error());\n        return 1;\n    }\n    auto& mapped_file = *file_or_error.value();\n\n    printf(\"Archive: %s\\n\", zip_file_path.characters());\n\n    off_t index = 0;\n    while (find_next_central_directory(st.st_size, mapped_file, index, index)) {\n        bool success = unpack_file_for_central_directory_index(index, mapped_file);\n        if (!success) {\n            printf(\"Could not find local file header for a file.\\n\");\n            return 4;\n        }\n    }\n\n    return 0;\n}",
        "func": "int main(int argc, char** argv)\n{\n    const char* path;\n    int map_size_limit = 32 * MiB;\n\n    Core::ArgsParser args_parser;\n    args_parser.add_option(map_size_limit, \"Maximum chunk size to map\", \"map-size-limit\", 0, \"size\");\n    args_parser.add_positional_argument(path, \"File to unzip\", \"path\", Core::ArgsParser::Required::Yes);\n    args_parser.parse(argc, argv);\n\n    StringBuilder target_path_raw;\n    // Currently unzip doesn't support extracting to a specified location. If that is implemented the target_path\n    // should be replaced with the target path from the command line arguements instead of \".\"\n    target_path_raw.append(realpath(\".\", nullptr));\n    target_path_raw.append(\"/\");\n    LexicalPath target_path(target_path_raw.to_string());\n    auto target_path_string = target_path.string();\n    if (unveil(target_path_string.characters(), \"rwc\") < 0) {\n        perror(\"unveil\");\n        return 1;\n    }\n\n    auto zip_path = realpath(path, nullptr);\n    if (unveil(zip_path, \"r\") < 0) {\n        perror(\"unveil\");\n        return 1;\n    }\n\n    if (unveil(nullptr, nullptr) < 0) {\n        perror(\"unveil\");\n        return 1;\n    }\n\n    String zip_file_path { path };\n\n    struct stat st;\n    int rc = stat(zip_file_path.characters(), &st);\n    if (rc < 0) {\n        perror(\"stat\");\n        return 1;\n    }\n\n    // FIXME: Map file chunk-by-chunk once we have mmap() with offset.\n    //        This will require mapping some parts then unmapping them repeatedly,\n    //        but it would be significantly faster and less syscall heavy than seek()/read() at every read.\n    if (st.st_size >= map_size_limit) {\n        fprintf(stderr, \"unzip warning: Refusing to map file since it is larger than %s, pass '--map-size-limit %d' to get around this\\n\",\n            human_readable_size(map_size_limit).characters(),\n            round_up_to_power_of_two(st.st_size, 16));\n        return 1;\n    }\n\n    auto file_or_error = MappedFile ::map(zip_file_path);\n    if (file_or_error.is_error()) {\n        warnln(\"Failed to open {}: {}\", zip_file_path, file_or_error.error());\n        return 1;\n    }\n    auto& mapped_file = *file_or_error.value();\n\n    printf(\"Archive: %s\\n\", zip_file_path.characters());\n\n    off_t index = 0;\n    while (find_next_central_directory(st.st_size, mapped_file, index, index)) {\n        bool success = unpack_file_for_central_directory_index(index, mapped_file, target_path_string);\n        if (!success) {\n            printf(\"Could not find local file header for a file.\\n\");\n            return 4;\n        }\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,29 @@\n     args_parser.add_option(map_size_limit, \"Maximum chunk size to map\", \"map-size-limit\", 0, \"size\");\n     args_parser.add_positional_argument(path, \"File to unzip\", \"path\", Core::ArgsParser::Required::Yes);\n     args_parser.parse(argc, argv);\n+\n+    StringBuilder target_path_raw;\n+    // Currently unzip doesn't support extracting to a specified location. If that is implemented the target_path\n+    // should be replaced with the target path from the command line arguements instead of \".\"\n+    target_path_raw.append(realpath(\".\", nullptr));\n+    target_path_raw.append(\"/\");\n+    LexicalPath target_path(target_path_raw.to_string());\n+    auto target_path_string = target_path.string();\n+    if (unveil(target_path_string.characters(), \"rwc\") < 0) {\n+        perror(\"unveil\");\n+        return 1;\n+    }\n+\n+    auto zip_path = realpath(path, nullptr);\n+    if (unveil(zip_path, \"r\") < 0) {\n+        perror(\"unveil\");\n+        return 1;\n+    }\n+\n+    if (unveil(nullptr, nullptr) < 0) {\n+        perror(\"unveil\");\n+        return 1;\n+    }\n \n     String zip_file_path { path };\n \n@@ -38,7 +61,7 @@\n \n     off_t index = 0;\n     while (find_next_central_directory(st.st_size, mapped_file, index, index)) {\n-        bool success = unpack_file_for_central_directory_index(index, mapped_file);\n+        bool success = unpack_file_for_central_directory_index(index, mapped_file, target_path_string);\n         if (!success) {\n             printf(\"Could not find local file header for a file.\\n\");\n             return 4;",
        "diff_line_info": {
            "deleted_lines": [
                "        bool success = unpack_file_for_central_directory_index(index, mapped_file);"
            ],
            "added_lines": [
                "",
                "    StringBuilder target_path_raw;",
                "    // Currently unzip doesn't support extracting to a specified location. If that is implemented the target_path",
                "    // should be replaced with the target path from the command line arguements instead of \".\"",
                "    target_path_raw.append(realpath(\".\", nullptr));",
                "    target_path_raw.append(\"/\");",
                "    LexicalPath target_path(target_path_raw.to_string());",
                "    auto target_path_string = target_path.string();",
                "    if (unveil(target_path_string.characters(), \"rwc\") < 0) {",
                "        perror(\"unveil\");",
                "        return 1;",
                "    }",
                "",
                "    auto zip_path = realpath(path, nullptr);",
                "    if (unveil(zip_path, \"r\") < 0) {",
                "        perror(\"unveil\");",
                "        return 1;",
                "    }",
                "",
                "    if (unveil(nullptr, nullptr) < 0) {",
                "        perror(\"unveil\");",
                "        return 1;",
                "    }",
                "        bool success = unpack_file_for_central_directory_index(index, mapped_file, target_path_string);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-31272",
        "func_name": "SerenityOS/serenity/unpack_file_for_central_directory_index",
        "description": "SerenityOS before commit 3844e8569689dd476064a0759d704bc64fb3ca2c contains a directory traversal vulnerability in tar/unzip that may lead to command execution or privilege escalation.",
        "git_url": "https://github.com/SerenityOS/serenity/commit/3844e8569689dd476064a0759d704bc64fb3ca2c",
        "commit_title": "Userland: Fix tar/unzip directory traversal vulnerability",
        "commit_text": " This change validates the filenames within a tar/zip archive during extraction. If the filename within a the archive is outside of the current working directory the file will be skipped and not extracted onto the host system.  Closes #3991 Closes #3992",
        "func_before": "static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file)\n{\n    enum CentralFileDirectoryHeaderOffsets {\n        CFDHCompressionMethodOffset = 10,\n        CFDHLocalFileHeaderIndexOffset = 42,\n    };\n    enum LocalFileHeaderOffsets {\n        LFHCompressionMethodOffset = 8,\n        LFHCompressedSizeOffset = 18,\n        LFHFileNameLengthOffset = 26,\n        LFHExtraFieldLengthOffset = 28,\n        LFHFileNameBaseOffset = 30,\n    };\n    enum CompressionMethod {\n        None = 0,\n        Shrunk = 1,\n        Factor1 = 2,\n        Factor2 = 3,\n        Factor3 = 4,\n        Factor4 = 5,\n        Implode = 6,\n        Deflate = 8,\n        EnhancedDeflate = 9,\n        PKWareDCLImplode = 10,\n        BZIP2 = 12,\n        LZMA = 14,\n        TERSE = 18,\n        LZ77 = 19,\n    };\n\n    u8 buffer[4];\n    if (!seek_and_read(buffer, file, central_directory_index + CFDHLocalFileHeaderIndexOffset, 4))\n        return false;\n    off_t local_file_header_index = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n\n    if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressionMethodOffset, 2))\n        return false;\n    auto compression_method = buffer[1] << 8 | buffer[0];\n    // FIXME: Remove once any decompression is supported.\n    VERIFY(compression_method == None);\n\n    if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressedSizeOffset, 4))\n        return false;\n    off_t compressed_file_size = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n\n    if (!seek_and_read(buffer, file, local_file_header_index + LFHFileNameLengthOffset, 2))\n        return false;\n    off_t file_name_length = buffer[1] << 8 | buffer[0];\n\n    if (!seek_and_read(buffer, file, local_file_header_index + LFHExtraFieldLengthOffset, 2))\n        return false;\n    off_t extra_field_length = buffer[1] << 8 | buffer[0];\n\n    char file_name[file_name_length + 1];\n    if (!seek_and_read((u8*)file_name, file, local_file_header_index + LFHFileNameBaseOffset, file_name_length))\n        return false;\n    file_name[file_name_length] = '\\0';\n\n    if (file_name[file_name_length - 1] == '/') {\n        if (mkdir(file_name, 0755) < 0) {\n            perror(\"mkdir\");\n            return false;\n        }\n    } else {\n        auto new_file = Core::File::construct(String { file_name });\n        if (!new_file->open(Core::IODevice::WriteOnly)) {\n            fprintf(stderr, \"Can't write file %s: %s\\n\", file_name, new_file->error_string());\n            return false;\n        }\n\n        printf(\" extracting: %s\\n\", file_name);\n        u8 raw_file_contents[compressed_file_size];\n        if (!seek_and_read(raw_file_contents, file, local_file_header_index + LFHFileNameBaseOffset + file_name_length + extra_field_length, compressed_file_size))\n            return false;\n\n        // FIXME: Try to uncompress data here. We're just ignoring it as no decompression methods are implemented yet.\n        if (!new_file->write(raw_file_contents, compressed_file_size)) {\n            fprintf(stderr, \"Can't write file contents in %s: %s\\n\", file_name, new_file->error_string());\n            return false;\n        }\n\n        if (!new_file->close()) {\n            fprintf(stderr, \"Can't close file %s: %s\\n\", file_name, new_file->error_string());\n            return false;\n        }\n    }\n\n    return true;\n}",
        "func": "static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file, const AK::String target_path)\n{\n    enum CentralFileDirectoryHeaderOffsets {\n        CFDHCompressionMethodOffset = 10,\n        CFDHLocalFileHeaderIndexOffset = 42,\n    };\n    enum LocalFileHeaderOffsets {\n        LFHCompressionMethodOffset = 8,\n        LFHCompressedSizeOffset = 18,\n        LFHFileNameLengthOffset = 26,\n        LFHExtraFieldLengthOffset = 28,\n        LFHFileNameBaseOffset = 30,\n    };\n    enum CompressionMethod {\n        None = 0,\n        Shrunk = 1,\n        Factor1 = 2,\n        Factor2 = 3,\n        Factor3 = 4,\n        Factor4 = 5,\n        Implode = 6,\n        Deflate = 8,\n        EnhancedDeflate = 9,\n        PKWareDCLImplode = 10,\n        BZIP2 = 12,\n        LZMA = 14,\n        TERSE = 18,\n        LZ77 = 19,\n    };\n\n    u8 buffer[4];\n    if (!seek_and_read(buffer, file, central_directory_index + CFDHLocalFileHeaderIndexOffset, 4))\n        return false;\n    off_t local_file_header_index = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n\n    if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressionMethodOffset, 2))\n        return false;\n    auto compression_method = buffer[1] << 8 | buffer[0];\n    // FIXME: Remove once any decompression is supported.\n    VERIFY(compression_method == None);\n\n    if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressedSizeOffset, 4))\n        return false;\n    off_t compressed_file_size = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n\n    if (!seek_and_read(buffer, file, local_file_header_index + LFHFileNameLengthOffset, 2))\n        return false;\n    off_t file_name_length = buffer[1] << 8 | buffer[0];\n\n    if (!seek_and_read(buffer, file, local_file_header_index + LFHExtraFieldLengthOffset, 2))\n        return false;\n    off_t extra_field_length = buffer[1] << 8 | buffer[0];\n\n    char file_name[file_name_length + 1];\n    if (!seek_and_read((u8*)file_name, file, local_file_header_index + LFHFileNameBaseOffset, file_name_length))\n        return false;\n    file_name[file_name_length] = '\\0';\n\n    // determine where the archive intends to write a file\n    StringBuilder destination_path_raw;\n    if (file_name[0] != '/') {\n        destination_path_raw.append(target_path);\n        destination_path_raw.append(\"/\");\n    }\n    destination_path_raw.append(file_name);\n    LexicalPath destination_path(destination_path_raw.to_string());\n    if (!(destination_path.string().starts_with(target_path))) {\n        fprintf(stderr, \"File %s path is outside of current working directory, skipping\\n\", file_name);\n        return false;\n    }\n\n    // Ignore zips containing target path.\n    // This will prevent mkdir from failing later when it probably shouldn't\n    if (destination_path.string() == target_path) {\n        return true;\n    }\n\n    if (file_name[file_name_length - 1] == '/') {\n        if (mkdir(file_name, 0755) < 0) {\n            perror(\"mkdir\");\n            return false;\n        }\n    } else {\n        auto new_file = Core::File::construct(String { file_name });\n        if (!new_file->open(Core::IODevice::WriteOnly)) {\n            fprintf(stderr, \"Can't write file %s: %s\\n\", file_name, new_file->error_string());\n            return false;\n        }\n\n        printf(\" extracting: %s\\n\", file_name);\n        u8 raw_file_contents[compressed_file_size];\n        if (!seek_and_read(raw_file_contents, file, local_file_header_index + LFHFileNameBaseOffset + file_name_length + extra_field_length, compressed_file_size))\n            return false;\n\n        // FIXME: Try to uncompress data here. We're just ignoring it as no decompression methods are implemented yet.\n        if (!new_file->write(raw_file_contents, compressed_file_size)) {\n            fprintf(stderr, \"Can't write file contents in %s: %s\\n\", file_name, new_file->error_string());\n            return false;\n        }\n\n        if (!new_file->close()) {\n            fprintf(stderr, \"Can't close file %s: %s\\n\", file_name, new_file->error_string());\n            return false;\n        }\n    }\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file)\n+static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file, const AK::String target_path)\n {\n     enum CentralFileDirectoryHeaderOffsets {\n         CFDHCompressionMethodOffset = 10,\n@@ -56,6 +56,25 @@\n         return false;\n     file_name[file_name_length] = '\\0';\n \n+    // determine where the archive intends to write a file\n+    StringBuilder destination_path_raw;\n+    if (file_name[0] != '/') {\n+        destination_path_raw.append(target_path);\n+        destination_path_raw.append(\"/\");\n+    }\n+    destination_path_raw.append(file_name);\n+    LexicalPath destination_path(destination_path_raw.to_string());\n+    if (!(destination_path.string().starts_with(target_path))) {\n+        fprintf(stderr, \"File %s path is outside of current working directory, skipping\\n\", file_name);\n+        return false;\n+    }\n+\n+    // Ignore zips containing target path.\n+    // This will prevent mkdir from failing later when it probably shouldn't\n+    if (destination_path.string() == target_path) {\n+        return true;\n+    }\n+\n     if (file_name[file_name_length - 1] == '/') {\n         if (mkdir(file_name, 0755) < 0) {\n             perror(\"mkdir\");",
        "diff_line_info": {
            "deleted_lines": [
                "static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file)"
            ],
            "added_lines": [
                "static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file, const AK::String target_path)",
                "    // determine where the archive intends to write a file",
                "    StringBuilder destination_path_raw;",
                "    if (file_name[0] != '/') {",
                "        destination_path_raw.append(target_path);",
                "        destination_path_raw.append(\"/\");",
                "    }",
                "    destination_path_raw.append(file_name);",
                "    LexicalPath destination_path(destination_path_raw.to_string());",
                "    if (!(destination_path.string().starts_with(target_path))) {",
                "        fprintf(stderr, \"File %s path is outside of current working directory, skipping\\n\", file_name);",
                "        return false;",
                "    }",
                "",
                "    // Ignore zips containing target path.",
                "    // This will prevent mkdir from failing later when it probably shouldn't",
                "    if (destination_path.string() == target_path) {",
                "        return true;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-31272",
        "func_name": "SerenityOS/serenity/main",
        "description": "SerenityOS before commit 3844e8569689dd476064a0759d704bc64fb3ca2c contains a directory traversal vulnerability in tar/unzip that may lead to command execution or privilege escalation.",
        "git_url": "https://github.com/SerenityOS/serenity/commit/3844e8569689dd476064a0759d704bc64fb3ca2c",
        "commit_title": "Userland: Fix tar/unzip directory traversal vulnerability",
        "commit_text": " This change validates the filenames within a tar/zip archive during extraction. If the filename within a the archive is outside of the current working directory the file will be skipped and not extracted onto the host system.  Closes #3991 Closes #3992",
        "func_before": "int main(int argc, char** argv)\n{\n    bool create = false;\n    bool extract = false;\n    bool list = false;\n    bool verbose = false;\n    bool gzip = false;\n    const char* archive_file = nullptr;\n    Vector<const char*> paths;\n\n    Core::ArgsParser args_parser;\n    args_parser.add_option(create, \"Create archive\", \"create\", 'c');\n    args_parser.add_option(extract, \"Extract archive\", \"extract\", 'x');\n    args_parser.add_option(list, \"List contents\", \"list\", 't');\n    args_parser.add_option(verbose, \"Print paths\", \"verbose\", 'v');\n    args_parser.add_option(gzip, \"compress or uncompress file using gzip\", \"gzip\", 'z');\n    args_parser.add_option(archive_file, \"Archive file\", \"file\", 'f', \"FILE\");\n    args_parser.add_positional_argument(paths, \"Paths\", \"PATHS\", Core::ArgsParser::Required::No);\n    args_parser.parse(argc, argv);\n\n    if (create + extract + list != 1) {\n        warnln(\"exactly one of -c, -x, and -t can be used\");\n        return 1;\n    }\n\n    if (list || extract) {\n        auto file = Core::File::standard_input();\n\n        if (archive_file) {\n            auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::ReadOnly);\n            if (maybe_file.is_error()) {\n                warnln(\"Core::File::open: {}\", maybe_file.error());\n                return 1;\n            }\n            file = maybe_file.value();\n        }\n\n        Core::InputFileStream file_stream(file);\n        Compress::GzipDecompressor gzip_stream(file_stream);\n\n        InputStream& file_input_stream = file_stream;\n        InputStream& gzip_input_stream = gzip_stream;\n        Tar::TarInputStream tar_stream((gzip) ? gzip_input_stream : file_input_stream);\n        if (!tar_stream.valid()) {\n            warnln(\"the provided file is not a well-formatted ustar file\");\n            return 1;\n        }\n        for (; !tar_stream.finished(); tar_stream.advance()) {\n            if (list || verbose)\n                outln(\"{}\", tar_stream.header().file_name());\n\n            if (extract) {\n                Tar::TarFileStream file_stream = tar_stream.file_contents();\n\n                const Tar::Header& header = tar_stream.header();\n                switch (header.type_flag()) {\n                case Tar::NormalFile:\n                case Tar::AlternateNormalFile: {\n                    int fd = open(String(header.file_name()).characters(), O_CREAT | O_WRONLY, header.mode());\n                    if (fd < 0) {\n                        perror(\"open\");\n                        return 1;\n                    }\n\n                    Array<u8, buffer_size> buffer;\n                    size_t nread;\n                    while ((nread = file_stream.read(buffer)) > 0) {\n                        if (write(fd, buffer.data(), nread) < 0) {\n                            perror(\"write\");\n                            return 1;\n                        }\n                    }\n                    close(fd);\n                    break;\n                }\n                case Tar::Directory: {\n                    if (mkdir(String(header.file_name()).characters(), header.mode())) {\n                        perror(\"mkdir\");\n                        return 1;\n                    }\n                    break;\n                }\n                default:\n                    // FIXME: Implement other file types\n                    VERIFY_NOT_REACHED();\n                }\n            }\n        }\n        file_stream.close();\n        return 0;\n    }\n\n    if (create) {\n        if (paths.size() == 0) {\n            warnln(\"you must provide at least one path to be archived\");\n            return 1;\n        }\n\n        auto file = Core::File::standard_output();\n\n        if (archive_file) {\n            auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::WriteOnly);\n            if (maybe_file.is_error()) {\n                warnln(\"Core::File::open: {}\", maybe_file.error());\n                return 1;\n            }\n            file = maybe_file.value();\n        }\n\n        Core::OutputFileStream file_stream(file);\n        Compress::GzipCompressor gzip_stream(file_stream);\n\n        OutputStream& file_output_stream = file_stream;\n        OutputStream& gzip_output_stream = gzip_stream;\n        Tar::TarOutputStream tar_stream((gzip) ? gzip_output_stream : file_output_stream);\n\n        auto add_file = [&](String path) {\n            auto file = Core::File::construct(path);\n            if (!file->open(Core::IODevice::ReadOnly)) {\n                warnln(\"Failed to open {}: {}\", path, file->error_string());\n                return;\n            }\n\n            struct stat statbuf;\n            if (lstat(path.characters(), &statbuf) < 0) {\n                warnln(\"Failed stating {}\", path);\n                return;\n            }\n            auto canonicalized_path = LexicalPath::canonicalized_path(path);\n            tar_stream.add_file(canonicalized_path, statbuf.st_mode, file->read_all());\n            if (verbose)\n                outln(\"{}\", canonicalized_path);\n        };\n\n        auto add_directory = [&](String path, auto handle_directory) -> void {\n            struct stat statbuf;\n            if (lstat(path.characters(), &statbuf) < 0) {\n                warnln(\"Failed stating {}\", path);\n                return;\n            }\n            auto canonicalized_path = LexicalPath::canonicalized_path(path);\n            tar_stream.add_directory(canonicalized_path, statbuf.st_mode);\n            if (verbose)\n                outln(\"{}\", canonicalized_path);\n\n            Core::DirIterator it(path, Core::DirIterator::Flags::SkipParentAndBaseDir);\n            while (it.has_next()) {\n                auto child_path = it.next_full_path();\n                if (!Core::File::is_directory(child_path)) {\n                    add_file(child_path);\n                } else {\n                    handle_directory(child_path, handle_directory);\n                }\n            }\n        };\n\n        for (const String& path : paths) {\n            if (Core::File::is_directory(path)) {\n                add_directory(path, add_directory);\n            } else {\n                add_file(path);\n            }\n        }\n\n        tar_stream.finish();\n\n        return 0;\n    }\n\n    return 0;\n}",
        "func": "int main(int argc, char** argv)\n{\n    bool create = false;\n    bool extract = false;\n    bool list = false;\n    bool verbose = false;\n    bool gzip = false;\n    const char* archive_file = nullptr;\n    Vector<const char*> paths;\n\n    Core::ArgsParser args_parser;\n    args_parser.add_option(create, \"Create archive\", \"create\", 'c');\n    args_parser.add_option(extract, \"Extract archive\", \"extract\", 'x');\n    args_parser.add_option(list, \"List contents\", \"list\", 't');\n    args_parser.add_option(verbose, \"Print paths\", \"verbose\", 'v');\n    args_parser.add_option(gzip, \"compress or uncompress file using gzip\", \"gzip\", 'z');\n    args_parser.add_option(archive_file, \"Archive file\", \"file\", 'f', \"FILE\");\n    args_parser.add_positional_argument(paths, \"Paths\", \"PATHS\", Core::ArgsParser::Required::No);\n    args_parser.parse(argc, argv);\n\n    // Currently tar doesn't support extracting to a specified location. If that is implemented the target path\n    // should be unveiled with rwc instead of the current directory.\n    StringBuilder target_path_raw;\n    target_path_raw.append(realpath(\".\", nullptr));\n    target_path_raw.append(\"/\");\n    LexicalPath target_path(target_path_raw.to_string());\n    auto target_path_string = target_path.string();\n    if (unveil(target_path_string.characters(), \"rwc\") < 0) {\n        perror(\"unveil\");\n        return 1;\n    }\n\n    if (create + extract + list != 1) {\n        warnln(\"exactly one of -c, -x, and -t can be used\");\n        return 1;\n    }\n\n    if (list || extract) {\n        auto file = Core::File::standard_input();\n\n        if (archive_file) {\n            // make sure we can read the archive path\n            auto archive_file_path = realpath(archive_file, nullptr);\n            if (unveil(archive_file_path, \"r\") < 0) {\n                perror(\"unveil\");\n                return 1;\n            }\n            if (unveil(nullptr, nullptr) < 0) {\n                perror(\"unveil\");\n                return 1;\n            }\n            auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::ReadOnly);\n            if (maybe_file.is_error()) {\n                warnln(\"Core::File::open: {}\", maybe_file.error());\n                return 1;\n            }\n            file = maybe_file.value();\n        }\n\n        Core::InputFileStream file_stream(file);\n        Compress::GzipDecompressor gzip_stream(file_stream);\n\n        InputStream& file_input_stream = file_stream;\n        InputStream& gzip_input_stream = gzip_stream;\n        Tar::TarInputStream tar_stream((gzip) ? gzip_input_stream : file_input_stream);\n        if (!tar_stream.valid()) {\n            warnln(\"the provided file is not a well-formatted ustar file\");\n            return 1;\n        }\n\n        for (; !tar_stream.finished(); tar_stream.advance()) {\n            auto file_name = tar_stream.header().file_name();\n\n            if (list || verbose)\n                outln(\"{}\", file_name);\n\n            if (extract) {\n                Tar::TarFileStream file_stream = tar_stream.file_contents();\n\n                const Tar::Header& header = tar_stream.header();\n\n                // determine where the archive intends to write a file\n                StringBuilder destination_path_raw;\n                if (file_name[0] != '/') {\n                    destination_path_raw.append(target_path_string);\n                    destination_path_raw.append(\"/\");\n                }\n                destination_path_raw.append(file_name);\n                LexicalPath destination_path(destination_path_raw.to_string());\n\n                if (!(destination_path.string().starts_with(target_path_string))) {\n                    fprintf(stderr, \"File %s path is outside of current working directory, skipping\\n\", file_name.to_string().characters());\n                    return false;\n                }\n\n                // Ignore tars containing target path.\n                // This will prevent mkdir from failing later when it probably shouldn't\n                if (destination_path.string() == target_path_string) {\n                    continue;\n                }\n\n                switch (header.type_flag()) {\n                case Tar::NormalFile:\n                case Tar::AlternateNormalFile: {\n                    int fd = open(String(header.file_name()).characters(), O_CREAT | O_WRONLY, header.mode());\n                    if (fd < 0) {\n                        perror(\"open\");\n                        return 1;\n                    }\n\n                    Array<u8, buffer_size> buffer;\n                    size_t nread;\n                    while ((nread = file_stream.read(buffer)) > 0) {\n                        if (write(fd, buffer.data(), nread) < 0) {\n                            perror(\"write\");\n                            return 1;\n                        }\n                    }\n                    close(fd);\n                    break;\n                }\n                case Tar::Directory: {\n                    if (mkdir(String(header.file_name()).characters(), header.mode())) {\n                        perror(\"mkdir\");\n                        return 1;\n                    }\n                    break;\n                }\n                default:\n                    // FIXME: Implement other file types\n                    VERIFY_NOT_REACHED();\n                }\n            }\n        }\n        file_stream.close();\n        return 0;\n    }\n\n    if (create) {\n        if (paths.size() == 0) {\n            warnln(\"you must provide at least one path to be archived\");\n            return 1;\n        }\n\n        auto file = Core::File::standard_output();\n\n        if (archive_file) {\n            auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::WriteOnly);\n            if (maybe_file.is_error()) {\n                warnln(\"Core::File::open: {}\", maybe_file.error());\n                return 1;\n            }\n            file = maybe_file.value();\n        }\n\n        Core::OutputFileStream file_stream(file);\n        Compress::GzipCompressor gzip_stream(file_stream);\n\n        OutputStream& file_output_stream = file_stream;\n        OutputStream& gzip_output_stream = gzip_stream;\n        Tar::TarOutputStream tar_stream((gzip) ? gzip_output_stream : file_output_stream);\n\n        auto add_file = [&](String path) {\n            auto file = Core::File::construct(path);\n            if (!file->open(Core::IODevice::ReadOnly)) {\n                warnln(\"Failed to open {}: {}\", path, file->error_string());\n                return;\n            }\n\n            struct stat statbuf;\n            if (lstat(path.characters(), &statbuf) < 0) {\n                warnln(\"Failed stating {}\", path);\n                return;\n            }\n            auto canonicalized_path = LexicalPath::canonicalized_path(path);\n            tar_stream.add_file(canonicalized_path, statbuf.st_mode, file->read_all());\n            if (verbose)\n                outln(\"{}\", canonicalized_path);\n        };\n\n        auto add_directory = [&](String path, auto handle_directory) -> void {\n            struct stat statbuf;\n            if (lstat(path.characters(), &statbuf) < 0) {\n                warnln(\"Failed stating {}\", path);\n                return;\n            }\n            auto canonicalized_path = LexicalPath::canonicalized_path(path);\n            tar_stream.add_directory(canonicalized_path, statbuf.st_mode);\n            if (verbose)\n                outln(\"{}\", canonicalized_path);\n\n            Core::DirIterator it(path, Core::DirIterator::Flags::SkipParentAndBaseDir);\n            while (it.has_next()) {\n                auto child_path = it.next_full_path();\n                if (!Core::File::is_directory(child_path)) {\n                    add_file(child_path);\n                } else {\n                    handle_directory(child_path, handle_directory);\n                }\n            }\n        };\n\n        for (const String& path : paths) {\n            if (Core::File::is_directory(path)) {\n                add_directory(path, add_directory);\n            } else {\n                add_file(path);\n            }\n        }\n\n        tar_stream.finish();\n\n        return 0;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,18 @@\n     args_parser.add_positional_argument(paths, \"Paths\", \"PATHS\", Core::ArgsParser::Required::No);\n     args_parser.parse(argc, argv);\n \n+    // Currently tar doesn't support extracting to a specified location. If that is implemented the target path\n+    // should be unveiled with rwc instead of the current directory.\n+    StringBuilder target_path_raw;\n+    target_path_raw.append(realpath(\".\", nullptr));\n+    target_path_raw.append(\"/\");\n+    LexicalPath target_path(target_path_raw.to_string());\n+    auto target_path_string = target_path.string();\n+    if (unveil(target_path_string.characters(), \"rwc\") < 0) {\n+        perror(\"unveil\");\n+        return 1;\n+    }\n+\n     if (create + extract + list != 1) {\n         warnln(\"exactly one of -c, -x, and -t can be used\");\n         return 1;\n@@ -27,6 +39,16 @@\n         auto file = Core::File::standard_input();\n \n         if (archive_file) {\n+            // make sure we can read the archive path\n+            auto archive_file_path = realpath(archive_file, nullptr);\n+            if (unveil(archive_file_path, \"r\") < 0) {\n+                perror(\"unveil\");\n+                return 1;\n+            }\n+            if (unveil(nullptr, nullptr) < 0) {\n+                perror(\"unveil\");\n+                return 1;\n+            }\n             auto maybe_file = Core::File::open(archive_file, Core::IODevice::OpenMode::ReadOnly);\n             if (maybe_file.is_error()) {\n                 warnln(\"Core::File::open: {}\", maybe_file.error());\n@@ -45,14 +67,38 @@\n             warnln(\"the provided file is not a well-formatted ustar file\");\n             return 1;\n         }\n+\n         for (; !tar_stream.finished(); tar_stream.advance()) {\n+            auto file_name = tar_stream.header().file_name();\n+\n             if (list || verbose)\n-                outln(\"{}\", tar_stream.header().file_name());\n+                outln(\"{}\", file_name);\n \n             if (extract) {\n                 Tar::TarFileStream file_stream = tar_stream.file_contents();\n \n                 const Tar::Header& header = tar_stream.header();\n+\n+                // determine where the archive intends to write a file\n+                StringBuilder destination_path_raw;\n+                if (file_name[0] != '/') {\n+                    destination_path_raw.append(target_path_string);\n+                    destination_path_raw.append(\"/\");\n+                }\n+                destination_path_raw.append(file_name);\n+                LexicalPath destination_path(destination_path_raw.to_string());\n+\n+                if (!(destination_path.string().starts_with(target_path_string))) {\n+                    fprintf(stderr, \"File %s path is outside of current working directory, skipping\\n\", file_name.to_string().characters());\n+                    return false;\n+                }\n+\n+                // Ignore tars containing target path.\n+                // This will prevent mkdir from failing later when it probably shouldn't\n+                if (destination_path.string() == target_path_string) {\n+                    continue;\n+                }\n+\n                 switch (header.type_flag()) {\n                 case Tar::NormalFile:\n                 case Tar::AlternateNormalFile: {",
        "diff_line_info": {
            "deleted_lines": [
                "                outln(\"{}\", tar_stream.header().file_name());"
            ],
            "added_lines": [
                "    // Currently tar doesn't support extracting to a specified location. If that is implemented the target path",
                "    // should be unveiled with rwc instead of the current directory.",
                "    StringBuilder target_path_raw;",
                "    target_path_raw.append(realpath(\".\", nullptr));",
                "    target_path_raw.append(\"/\");",
                "    LexicalPath target_path(target_path_raw.to_string());",
                "    auto target_path_string = target_path.string();",
                "    if (unveil(target_path_string.characters(), \"rwc\") < 0) {",
                "        perror(\"unveil\");",
                "        return 1;",
                "    }",
                "",
                "            // make sure we can read the archive path",
                "            auto archive_file_path = realpath(archive_file, nullptr);",
                "            if (unveil(archive_file_path, \"r\") < 0) {",
                "                perror(\"unveil\");",
                "                return 1;",
                "            }",
                "            if (unveil(nullptr, nullptr) < 0) {",
                "                perror(\"unveil\");",
                "                return 1;",
                "            }",
                "",
                "            auto file_name = tar_stream.header().file_name();",
                "",
                "                outln(\"{}\", file_name);",
                "",
                "                // determine where the archive intends to write a file",
                "                StringBuilder destination_path_raw;",
                "                if (file_name[0] != '/') {",
                "                    destination_path_raw.append(target_path_string);",
                "                    destination_path_raw.append(\"/\");",
                "                }",
                "                destination_path_raw.append(file_name);",
                "                LexicalPath destination_path(destination_path_raw.to_string());",
                "",
                "                if (!(destination_path.string().starts_with(target_path_string))) {",
                "                    fprintf(stderr, \"File %s path is outside of current working directory, skipping\\n\", file_name.to_string().characters());",
                "                    return false;",
                "                }",
                "",
                "                // Ignore tars containing target path.",
                "                // This will prevent mkdir from failing later when it probably shouldn't",
                "                if (destination_path.string() == target_path_string) {",
                "                    continue;",
                "                }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3976",
        "func_name": "mz-automation/libiec61850/mmsClient_handleFileOpenRequest",
        "description": "A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services. The manipulation of the argument filename leads to path traversal. Upgrading to version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213556.",
        "git_url": "https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f",
        "commit_title": "- fixed path traversal vulnerability in MMS file services (LIB61850-357)",
        "commit_text": "",
        "func_before": "void\nmmsClient_handleFileOpenRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId, ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n        case 0xa0: /* filename */\n\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasFileName = true;\n\n            break;\n\n        case 0x81: /* initial position */\n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasFileName) {\n\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n\n        if (frsm != NULL) {\n\n            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n\n            if (obtainFileCall) {\n\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n\n                obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n            }\n\n            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n\n            if (fileHandle != NULL) {\n\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n                frsm->obtainRequest = obtainFileCall;\n\n                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}",
        "func": "void\nmmsClient_handleFileOpenRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId, ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n        case 0xa0: /* filename */\n\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasFileName = true;\n\n            break;\n\n        case 0x81: /* initial position */\n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasFileName) {\n\n        if (mmsMsg_isFilenameSave(filename) == false) {\n            /* potential attack */\n\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT: client provided unsave filename -> rejected\\n\");\n\n             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        }\n        else {\n            MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n\n            if (frsm != NULL) {\n\n                MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n\n                if (obtainFileCall) {\n\n                    if (DEBUG_MMS_CLIENT)\n                        printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n\n                    obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n                }\n\n                FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n\n                if (fileHandle != NULL) {\n\n                    frsm->fileHandle = fileHandle;\n                    frsm->readPosition = filePosition;\n                    frsm->frsmId = getNextFrsmId(connection);\n                    frsm->obtainRequest = obtainFileCall;\n\n                    mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n                            invokeId, response, filename, frsm);\n                }\n                else\n                    mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n        }\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,38 +42,48 @@\n \n     if (hasFileName) {\n \n-        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n+        if (mmsMsg_isFilenameSave(filename) == false) {\n+            /* potential attack */\n \n-        if (frsm != NULL) {\n+            if (DEBUG_MMS_CLIENT)\n+                printf(\"MMS_CLIENT: client provided unsave filename -> rejected\\n\");\n \n-            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n+             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n+        }\n+        else {\n+            MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n \n-            if (obtainFileCall) {\n+            if (frsm != NULL) {\n \n-                if (DEBUG_MMS_CLIENT)\n-                    printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n+                MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n \n-                obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n-            }\n+                if (obtainFileCall) {\n \n-            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n+                    if (DEBUG_MMS_CLIENT)\n+                        printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n \n-            if (fileHandle != NULL) {\n+                    obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n+                }\n \n-                frsm->fileHandle = fileHandle;\n-                frsm->readPosition = filePosition;\n-                frsm->frsmId = getNextFrsmId(connection);\n-                frsm->obtainRequest = obtainFileCall;\n+                FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n \n-                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n-                        invokeId, response, filename, frsm);\n+                if (fileHandle != NULL) {\n+\n+                    frsm->fileHandle = fileHandle;\n+                    frsm->readPosition = filePosition;\n+                    frsm->frsmId = getNextFrsmId(connection);\n+                    frsm->obtainRequest = obtainFileCall;\n+\n+                    mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n+                            invokeId, response, filename, frsm);\n+                }\n+                else\n+                    mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n+\n             }\n             else\n-                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n-\n+                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n         }\n-        else\n-            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n     }\n     else\n         goto exit_invalid_parameter;",
        "diff_line_info": {
            "deleted_lines": [
                "        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);",
                "        if (frsm != NULL) {",
                "            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);",
                "            if (obtainFileCall) {",
                "                if (DEBUG_MMS_CLIENT)",
                "                    printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);",
                "                obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;",
                "            }",
                "            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);",
                "            if (fileHandle != NULL) {",
                "                frsm->fileHandle = fileHandle;",
                "                frsm->readPosition = filePosition;",
                "                frsm->frsmId = getNextFrsmId(connection);",
                "                frsm->obtainRequest = obtainFileCall;",
                "                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),",
                "                        invokeId, response, filename, frsm);",
                "                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);",
                "",
                "        else",
                "            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);"
            ],
            "added_lines": [
                "        if (mmsMsg_isFilenameSave(filename) == false) {",
                "            /* potential attack */",
                "            if (DEBUG_MMS_CLIENT)",
                "                printf(\"MMS_CLIENT: client provided unsave filename -> rejected\\n\");",
                "             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);",
                "        }",
                "        else {",
                "            MmsFileReadStateMachine* frsm = getFreeFrsm(connection);",
                "            if (frsm != NULL) {",
                "                MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);",
                "                if (obtainFileCall) {",
                "                    if (DEBUG_MMS_CLIENT)",
                "                        printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);",
                "                    obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;",
                "                }",
                "                FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);",
                "                if (fileHandle != NULL) {",
                "",
                "                    frsm->fileHandle = fileHandle;",
                "                    frsm->readPosition = filePosition;",
                "                    frsm->frsmId = getNextFrsmId(connection);",
                "                    frsm->obtainRequest = obtainFileCall;",
                "",
                "                    mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),",
                "                            invokeId, response, filename, frsm);",
                "                }",
                "                else",
                "                    mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);",
                "",
                "                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3976",
        "func_name": "mz-automation/libiec61850/createFileDirectoryResponse",
        "description": "A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services. The manipulation of the argument filename leads to path traversal. Upgrading to version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213556.",
        "git_url": "https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f",
        "commit_title": "- fixed path traversal vulnerability in MMS file services (LIB61850-357)",
        "commit_text": "",
        "func_before": "static void\ncreateFileDirectoryResponse(const char* basepath, uint32_t invokeId, ByteBuffer* response, int maxPduSize, char* directoryName, char* continueAfterFileName)\n{\n    int maxSize = maxPduSize - 3; /* reserve space for moreFollows */\n    uint8_t* buffer = response->buffer;\n\n    bool moreFollows = false;\n\n    int tempStartPos = 30; /* estimated header part with safety margin */\n    int tempCurPos = tempStartPos;\n    int tempEncoded = 0;\n\n    if (continueAfterFileName != NULL) {\n        if (strlen(continueAfterFileName) == 0)\n            continueAfterFileName = NULL;\n    }\n\n    tempCurPos = addFileEntriesToResponse(basepath, buffer, tempCurPos, maxSize, directoryName, &continueAfterFileName, &moreFollows);\n\n\tif (tempCurPos < 0) {\n\n       if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Error opening directory!\\n\");\n\n       mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n       return;\n    }\n\n    tempEncoded = tempCurPos - tempStartPos;\n\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize((uint32_t) invokeId) + 2;\n\n    uint32_t listOfDirectoryEntrySeqSize = tempEncoded;\n\n    uint32_t listOfDirectoryEntrySize = 1 + BerEncoder_determineLengthSize(tempEncoded) + tempEncoded;\n\n    uint32_t fileDirectoryResponseSize = 1 + BerEncoder_determineLengthSize(listOfDirectoryEntrySize)\n            + listOfDirectoryEntrySize;\n\n    if (moreFollows)\n        fileDirectoryResponseSize += 3; /* for moreFollows */\n\n    uint32_t confirmedResponsePDUSize = invokeIdSize + 2 + BerEncoder_determineLengthSize(fileDirectoryResponseSize)\n            + fileDirectoryResponseSize;\n\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    buffer[bufPos++] = 0xbf;\n    bufPos = BerEncoder_encodeTL(0x4d, fileDirectoryResponseSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0xa0, listOfDirectoryEntrySize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x30, listOfDirectoryEntrySeqSize, buffer, bufPos); /* SEQUENCE OF (DirectoryEntry) */\n\n    /* memmove is required instead of memcpy since memory areas overlap */\n    memmove(buffer + bufPos, buffer + tempStartPos, tempEncoded);\n\n    bufPos += tempEncoded;\n\n    if (moreFollows)\n        bufPos = BerEncoder_encodeBoolean(0x81, moreFollows, buffer, bufPos);\n\n    response->size = bufPos;\n}",
        "func": "static void\ncreateFileDirectoryResponse(const char* basepath, uint32_t invokeId, ByteBuffer* response, int maxPduSize, char* directoryName, char* continueAfterFileName)\n{\n    int maxSize = maxPduSize - 3; /* reserve space for moreFollows */\n    uint8_t* buffer = response->buffer;\n\n    bool moreFollows = false;\n\n    int tempStartPos = 30; /* estimated header part with safety margin */\n    int tempCurPos = tempStartPos;\n    int tempEncoded = 0;\n\n    if (continueAfterFileName != NULL) {\n        if (strlen(continueAfterFileName) == 0)\n            continueAfterFileName = NULL;\n    }\n\n    if ((directoryName && mmsMsg_isFilenameSave(directoryName) == false) || \n        (continueAfterFileName && mmsMsg_isFilenameSave(continueAfterFileName) == false))\n    {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n       mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n       return;\n    }\n\n    tempCurPos = addFileEntriesToResponse(basepath, buffer, tempCurPos, maxSize, directoryName, &continueAfterFileName, &moreFollows);\n\n\tif (tempCurPos < 0) {\n\n       if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Error opening directory!\\n\");\n\n       mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n       return;\n    }\n\n    tempEncoded = tempCurPos - tempStartPos;\n\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize((uint32_t) invokeId) + 2;\n\n    uint32_t listOfDirectoryEntrySeqSize = tempEncoded;\n\n    uint32_t listOfDirectoryEntrySize = 1 + BerEncoder_determineLengthSize(tempEncoded) + tempEncoded;\n\n    uint32_t fileDirectoryResponseSize = 1 + BerEncoder_determineLengthSize(listOfDirectoryEntrySize)\n            + listOfDirectoryEntrySize;\n\n    if (moreFollows)\n        fileDirectoryResponseSize += 3; /* for moreFollows */\n\n    uint32_t confirmedResponsePDUSize = invokeIdSize + 2 + BerEncoder_determineLengthSize(fileDirectoryResponseSize)\n            + fileDirectoryResponseSize;\n\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    buffer[bufPos++] = 0xbf;\n    bufPos = BerEncoder_encodeTL(0x4d, fileDirectoryResponseSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0xa0, listOfDirectoryEntrySize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x30, listOfDirectoryEntrySeqSize, buffer, bufPos); /* SEQUENCE OF (DirectoryEntry) */\n\n    /* memmove is required instead of memcpy since memory areas overlap */\n    memmove(buffer + bufPos, buffer + tempStartPos, tempEncoded);\n\n    bufPos += tempEncoded;\n\n    if (moreFollows)\n        bufPos = BerEncoder_encodeBoolean(0x81, moreFollows, buffer, bufPos);\n\n    response->size = bufPos;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,17 @@\n     if (continueAfterFileName != NULL) {\n         if (strlen(continueAfterFileName) == 0)\n             continueAfterFileName = NULL;\n+    }\n+\n+    if ((directoryName && mmsMsg_isFilenameSave(directoryName) == false) || \n+        (continueAfterFileName && mmsMsg_isFilenameSave(continueAfterFileName) == false))\n+    {\n+        if (DEBUG_MMS_SERVER)\n+            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n+\n+       mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n+\n+       return;\n     }\n \n     tempCurPos = addFileEntriesToResponse(basepath, buffer, tempCurPos, maxSize, directoryName, &continueAfterFileName, &moreFollows);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    }",
                "",
                "    if ((directoryName && mmsMsg_isFilenameSave(directoryName) == false) || ",
                "        (continueAfterFileName && mmsMsg_isFilenameSave(continueAfterFileName) == false))",
                "    {",
                "        if (DEBUG_MMS_SERVER)",
                "            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");",
                "",
                "       mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);",
                "",
                "       return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3976",
        "func_name": "mz-automation/libiec61850/mmsServer_handleFileDeleteRequest",
        "description": "A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services. The manipulation of the argument filename leads to path traversal. Upgrading to version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213556.",
        "git_url": "https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f",
        "commit_title": "- fixed path traversal vulnerability in MMS file services (LIB61850-357)",
        "commit_text": "",
        "func_before": "void\nmmsServer_handleFileDeleteRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (buffer[bufPos++] != 0x19)\n        goto exit_reject_invalid_pdu;\n\n    int length;\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos == -1)\n        goto exit_reject_invalid_pdu;\n\n    if (length > 255) {\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n        return;\n    }\n\n    char filename[256];\n\n    memcpy(filename, buffer + bufPos, length);\n    filename[length] = 0;\n\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_DELETE, filename, NULL);\n\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n\n    if (!getFileInfo(MmsServerConnection_getFilesystemBasepath(connection), filename, NULL, NULL)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  File (%s) not found\\n\", filename);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n\n    if (!deleteFile(MmsServerConnection_getFilesystemBasepath(connection), filename)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  Delete file (%s) failed\\n\", filename);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED);\n        return;\n    }\n\n    createNullResponseExtendedTag(invokeId, response, 0x4c);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}",
        "func": "void\nmmsServer_handleFileDeleteRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (buffer[bufPos++] != 0x19)\n        goto exit_reject_invalid_pdu;\n\n    int length;\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos == -1)\n        goto exit_reject_invalid_pdu;\n\n    if (length > 255) {\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n        return;\n    }\n\n    char filename[256];\n\n    memcpy(filename, buffer + bufPos, length);\n    filename[length] = 0;\n\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n\n    if (mmsMsg_isFilenameSave(filename) == false)\n    {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n        return;\n    }\n\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_DELETE, filename, NULL);\n\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n\n    if (!getFileInfo(MmsServerConnection_getFilesystemBasepath(connection), filename, NULL, NULL)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  File (%s) not found\\n\", filename);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n\n    if (!deleteFile(MmsServerConnection_getFilesystemBasepath(connection), filename)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  Delete file (%s) failed\\n\", filename);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED);\n        return;\n    }\n\n    createNullResponseExtendedTag(invokeId, response, 0x4c);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,16 @@\n \n     if (DEBUG_MMS_SERVER)\n         printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n+\n+    if (mmsMsg_isFilenameSave(filename) == false)\n+    {\n+        if (DEBUG_MMS_SERVER)\n+            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n+\n+        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n+\n+        return;\n+    }\n \n     if (connection->server->fileAccessHandler != NULL) {\n         MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (mmsMsg_isFilenameSave(filename) == false)",
                "    {",
                "        if (DEBUG_MMS_SERVER)",
                "            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");",
                "",
                "        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);",
                "",
                "        return;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3976",
        "func_name": "mz-automation/libiec61850/mmsServer_handleFileRenameRequest",
        "description": "A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services. The manipulation of the argument filename leads to path traversal. Upgrading to version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213556.",
        "git_url": "https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f",
        "commit_title": "- fixed path traversal vulnerability in MMS file services (LIB61850-357)",
        "commit_text": "",
        "func_before": "void\nmmsServer_handleFileRenameRequest(\n        MmsServerConnection connection,\n        uint8_t* buffer, int bufPos, int maxBufPos,\n        uint32_t invokeId,\n        ByteBuffer* response)\n{\n    char currentFileName[256] = \"\";\n    char newFileName[256] = \"\";\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n            return;\n        }\n\n        switch(tag) {\n        case 0xa0: /* currentFilename */\n            if (!mmsMsg_parseFileName(currentFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: currentFileName: (%s)\\n\", currentFileName);\n\n            break;\n\n        case 0xa1: /* newFilename */\n            if (!mmsMsg_parseFileName(newFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: newFileName: (%s)\\n\", newFileName);\n\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default: /* ignore unknown tag */\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: unknown tag: (%02x)\\n\", tag);\n\n            bufPos += length;\n            break;\n        }\n    }\n\n    if ((strlen(currentFileName) != 0) && (strlen(newFileName) != 0)) {\n\n        /* Call user to check if access is allowed */\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_RENAME, currentFileName, newFileName);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        if (renameFile(MmsServerConnection_getFilesystemBasepath(connection), currentFileName, newFileName)){\n            /* send positive response */\n            createNullResponseExtendedTag(invokeId, response, 0x4b);\n        }\n        else\n        {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: rename file failed!\\n\");\n\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n        }\n    }\n    else\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n\n}",
        "func": "void\nmmsServer_handleFileRenameRequest(\n        MmsServerConnection connection,\n        uint8_t* buffer, int bufPos, int maxBufPos,\n        uint32_t invokeId,\n        ByteBuffer* response)\n{\n    char currentFileName[256] = \"\";\n    char newFileName[256] = \"\";\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n            return;\n        }\n\n        switch(tag) {\n        case 0xa0: /* currentFilename */\n            if (!mmsMsg_parseFileName(currentFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: currentFileName: (%s)\\n\", currentFileName);\n\n            break;\n\n        case 0xa1: /* newFilename */\n            if (!mmsMsg_parseFileName(newFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: newFileName: (%s)\\n\", newFileName);\n\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default: /* ignore unknown tag */\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: unknown tag: (%02x)\\n\", tag);\n\n            bufPos += length;\n            break;\n        }\n    }\n\n    if ((strlen(currentFileName) != 0) && (strlen(newFileName) != 0)) {\n\n        if ((mmsMsg_isFilenameSave(currentFileName) == false) || (mmsMsg_isFilenameSave(newFileName) == false))\n        {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n            return;\n        }\n\n        /* Call user to check if access is allowed */\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_RENAME, currentFileName, newFileName);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        if (renameFile(MmsServerConnection_getFilesystemBasepath(connection), currentFileName, newFileName)){\n            /* send positive response */\n            createNullResponseExtendedTag(invokeId, response, 0x4b);\n        }\n        else\n        {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: rename file failed!\\n\");\n\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n        }\n    }\n    else\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,6 +50,16 @@\n \n     if ((strlen(currentFileName) != 0) && (strlen(newFileName) != 0)) {\n \n+        if ((mmsMsg_isFilenameSave(currentFileName) == false) || (mmsMsg_isFilenameSave(newFileName) == false))\n+        {\n+            if (DEBUG_MMS_SERVER)\n+                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n+\n+            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n+\n+            return;\n+        }\n+\n         /* Call user to check if access is allowed */\n         if (connection->server->fileAccessHandler != NULL) {\n             MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if ((mmsMsg_isFilenameSave(currentFileName) == false) || (mmsMsg_isFilenameSave(newFileName) == false))",
                "        {",
                "            if (DEBUG_MMS_SERVER)",
                "                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");",
                "",
                "            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);",
                "",
                "            return;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3976",
        "func_name": "mz-automation/libiec61850/mmsServer_handleObtainFileRequest",
        "description": "A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services. The manipulation of the argument filename leads to path traversal. Upgrading to version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213556.",
        "git_url": "https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f",
        "commit_title": "- fixed path traversal vulnerability in MMS file services (LIB61850-357)",
        "commit_text": "",
        "func_before": "void\nmmsServer_handleObtainFileRequest(\n        MmsServerConnection connection,\n        uint8_t* buffer, int bufPos, int maxBufPos,\n        uint32_t invokeId,\n        ByteBuffer* response)\n{\n    char sourceFilename[256];\n    bool hasSourceFileName = false;\n\n    char destinationFilename[256];\n    bool hasDestinationFilename = false;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n\n        case 0xa1: /* source filename */\n\n            if (!mmsMsg_parseFileName(sourceFilename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasSourceFileName = true;\n\n            break;\n\n        case 0xa2: /* destination filename */\n\n            if (!mmsMsg_parseFileName(destinationFilename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasDestinationFilename = true;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasSourceFileName && hasDestinationFilename) {\n\n        /* Call user to check if access is allowed */\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_OBTAIN, destinationFilename, sourceFilename);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        /* call callback to check if access is allowed -- DEPRECATED */\n        if (connection->server->obtainFileHandler)\n            if (connection->server->obtainFileHandler(connection->server->obtainFileHandlerParameter, connection, sourceFilename, destinationFilename) == false)\n                goto exit_access_denied;\n\n        /*  check if destination file already exists. If exists return error message */\n\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n        char extendedFileName[512];\n        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection), 512,\n                extendedFileName, destinationFilename);\n\n#else\n        char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n\n        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection),\n                sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256,\n                extendedFileName, destinationFilename);\n#endif\n\n        if (FileSystem_getFileInfo(extendedFileName, NULL, NULL)) {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: obtainFile - file already exists on server\\n\");\n            goto exit_file_already_exists;\n        }\n\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Start download file %s from client to local file %s...\\n\", sourceFilename, destinationFilename);\n\n        MmsObtainFileTask task = MmsServer_getObtainFileTask(connection->server);\n\n        if (task != NULL) {\n\n            FileHandle fileHandle = openFile(MmsServerConnection_getFilesystemBasepath(connection),\n                    destinationFilename, true);\n\n            task->connection = connection;\n            task->obtainFileRequestInvokeId = invokeId;\n\n            if (fileHandle == NULL) {\n                task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_DESTINATION;\n            }\n            else {\n                /* send file open request */\n                task->lastRequestInvokeId = MmsServerConnection_getNextRequestInvokeId(connection);\n                task->fileHandle = fileHandle;\n\n                StringUtils_copyStringMax(task->destinationFilename, 256, destinationFilename);\n\n                ByteBuffer* request = MmsServer_reserveTransmitBuffer(connection->server);\n\n                mmsClient_createFileOpenRequest(task->lastRequestInvokeId, request, sourceFilename, 0);\n\n                IsoConnection_sendMessage(task->connection->isoConnection, request);\n\n                MmsServer_releaseTransmitBuffer(connection->server);\n\n                task->nextTimeout = Hal_getTimeInMs() + 2000; /* timeout 2000 ms */\n\n                task->state = MMS_FILE_UPLOAD_STATE_FILE_OPEN_SENT;\n            }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n            Semaphore_post(task->taskLock);\n#endif\n        }\n        else\n            goto exit_unavailable;\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_access_denied:\n    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED, 1);\n    return;\n\nexit_file_already_exists:\n    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_DUPLICATE_FILENAME, 1);\n    return;\n\nexit_unavailable:\n    mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_ACCESS_TEMPORARILY_UNAVAILABLE);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}",
        "func": "void\nmmsServer_handleObtainFileRequest(\n        MmsServerConnection connection,\n        uint8_t* buffer, int bufPos, int maxBufPos,\n        uint32_t invokeId,\n        ByteBuffer* response)\n{\n    char sourceFilename[256];\n    bool hasSourceFileName = false;\n\n    char destinationFilename[256];\n    bool hasDestinationFilename = false;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n\n        case 0xa1: /* source filename */\n\n            if (!mmsMsg_parseFileName(sourceFilename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasSourceFileName = true;\n\n            break;\n\n        case 0xa2: /* destination filename */\n\n            if (!mmsMsg_parseFileName(destinationFilename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasDestinationFilename = true;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasSourceFileName && hasDestinationFilename) {\n\n        if (mmsMsg_isFilenameSave(destinationFilename) == false) {\n            /* potential attack */\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n            goto exit_invalid_parameter;\n        }\n\n        /* Call user to check if access is allowed */\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_OBTAIN, destinationFilename, sourceFilename);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        /* call callback to check if access is allowed -- DEPRECATED */\n        if (connection->server->obtainFileHandler)\n            if (connection->server->obtainFileHandler(connection->server->obtainFileHandlerParameter, connection, sourceFilename, destinationFilename) == false)\n                goto exit_access_denied;\n\n        /*  check if destination file already exists. If exists return error message */\n\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n        char extendedFileName[512];\n        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection), 512,\n                extendedFileName, destinationFilename);\n\n#else\n        char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n\n        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection),\n                sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256,\n                extendedFileName, destinationFilename);\n#endif\n\n        if (FileSystem_getFileInfo(extendedFileName, NULL, NULL)) {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: obtainFile - file already exists on server\\n\");\n            goto exit_file_already_exists;\n        }\n\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Start download file %s from client to local file %s...\\n\", sourceFilename, destinationFilename);\n\n        MmsObtainFileTask task = MmsServer_getObtainFileTask(connection->server);\n\n        if (task != NULL) {\n\n            FileHandle fileHandle = openFile(MmsServerConnection_getFilesystemBasepath(connection),\n                    destinationFilename, true);\n\n            task->connection = connection;\n            task->obtainFileRequestInvokeId = invokeId;\n\n            if (fileHandle == NULL) {\n                task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_DESTINATION;\n            }\n            else {\n                /* send file open request */\n                task->lastRequestInvokeId = MmsServerConnection_getNextRequestInvokeId(connection);\n                task->fileHandle = fileHandle;\n\n                StringUtils_copyStringMax(task->destinationFilename, 256, destinationFilename);\n\n                ByteBuffer* request = MmsServer_reserveTransmitBuffer(connection->server);\n\n                mmsClient_createFileOpenRequest(task->lastRequestInvokeId, request, sourceFilename, 0);\n\n                IsoConnection_sendMessage(task->connection->isoConnection, request);\n\n                MmsServer_releaseTransmitBuffer(connection->server);\n\n                task->nextTimeout = Hal_getTimeInMs() + 2000; /* timeout 2000 ms */\n\n                task->state = MMS_FILE_UPLOAD_STATE_FILE_OPEN_SENT;\n            }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n            Semaphore_post(task->taskLock);\n#endif\n        }\n        else\n            goto exit_unavailable;\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_access_denied:\n    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED, 1);\n    return;\n\nexit_file_already_exists:\n    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_DUPLICATE_FILENAME, 1);\n    return;\n\nexit_unavailable:\n    mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_ACCESS_TEMPORARILY_UNAVAILABLE);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,6 +49,15 @@\n     }\n \n     if (hasSourceFileName && hasDestinationFilename) {\n+\n+        if (mmsMsg_isFilenameSave(destinationFilename) == false) {\n+            /* potential attack */\n+\n+            if (DEBUG_MMS_SERVER)\n+                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n+\n+            goto exit_invalid_parameter;\n+        }\n \n         /* Call user to check if access is allowed */\n         if (connection->server->fileAccessHandler != NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        if (mmsMsg_isFilenameSave(destinationFilename) == false) {",
                "            /* potential attack */",
                "",
                "            if (DEBUG_MMS_SERVER)",
                "                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");",
                "",
                "            goto exit_invalid_parameter;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3976",
        "func_name": "mz-automation/libiec61850/mmsServer_handleFileOpenRequest",
        "description": "A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services. The manipulation of the argument filename leads to path traversal. Upgrading to version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213556.",
        "git_url": "https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f",
        "commit_title": "- fixed path traversal vulnerability in MMS file services (LIB61850-357)",
        "commit_text": "",
        "func_before": "void\nmmsServer_handleFileOpenRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n        case 0xa0: /* filename */\n\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasFileName = true;\n\n            break;\n\n        case 0x81: /* initial position */\n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasFileName) {\n\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_OPEN, filename, NULL);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n\n        if (frsm != NULL) {\n            FileHandle fileHandle = openFile(MmsServerConnection_getFilesystemBasepath(connection), filename, false);\n\n            if (fileHandle != NULL) {\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n\n                mmsMsg_createFileOpenResponse(MmsServerConnection_getFilesystemBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}",
        "func": "void\nmmsServer_handleFileOpenRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n        case 0xa0: /* filename */\n\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasFileName = true;\n\n            break;\n\n        case 0x81: /* initial position */\n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasFileName) {\n\n        if (mmsMsg_isFilenameSave(filename) == false) {\n            /* potential attack */\n\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n             return;\n        }\n\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_OPEN, filename, NULL);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n\n        if (frsm != NULL) {\n            FileHandle fileHandle = openFile(MmsServerConnection_getFilesystemBasepath(connection), filename, false);\n\n            if (fileHandle != NULL) {\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n\n                mmsMsg_createFileOpenResponse(MmsServerConnection_getFilesystemBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,6 +43,17 @@\n \n     if (hasFileName) {\n \n+        if (mmsMsg_isFilenameSave(filename) == false) {\n+            /* potential attack */\n+\n+            if (DEBUG_MMS_CLIENT)\n+                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n+\n+             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n+\n+             return;\n+        }\n+\n         if (connection->server->fileAccessHandler != NULL) {\n             MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                 connection, MMS_FILE_ACCESS_TYPE_OPEN, filename, NULL);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (mmsMsg_isFilenameSave(filename) == false) {",
                "            /* potential attack */",
                "",
                "            if (DEBUG_MMS_CLIENT)",
                "                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");",
                "",
                "             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);",
                "",
                "             return;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3976",
        "func_name": "mz-automation/libiec61850/mmsMsg_parseFileName",
        "description": "A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services. The manipulation of the argument filename leads to path traversal. Upgrading to version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213556.",
        "git_url": "https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f",
        "commit_title": "- fixed path traversal vulnerability in MMS file services (LIB61850-357)",
        "commit_text": "",
        "func_before": "bool\nmmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response)\n{\n    if (*bufPos == maxBufPos)\n        return false;\n\n    uint8_t tag = buffer[(*bufPos)++];\n\n    if (tag != 0x19) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    int length;\n\n    *bufPos = BerDecoder_decodeLength(buffer, &length, *bufPos, maxBufPos);\n\n    if (*bufPos < 0)  {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    if (length > 255) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n      return false;\n    }\n\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n\n    /* Check if path contains invalid characters (prevent escaping the virtual filestore by using \"..\")\n     * TODO this may be platform dependent. Also depending of the platform there might be other evil\n     * characters.\n     */\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n        return false;\n    }\n\n    return true;\n}",
        "func": "bool\nmmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response)\n{\n    if (*bufPos == maxBufPos)\n        return false;\n\n    uint8_t tag = buffer[(*bufPos)++];\n\n    if (tag != 0x19) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    int length;\n\n    *bufPos = BerDecoder_decodeLength(buffer, &length, *bufPos, maxBufPos);\n\n    if (*bufPos < 0)  {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    if (length > 255) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n      return false;\n    }\n\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n\n    /* Check if path contains invalid characters (prevent escaping the virtual filestore by using \"..\")\n     * TODO this may be platform dependent. Also depending of the platform there might be other evil\n     * characters.\n     */\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return false;\n    }\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,7 @@\n      * characters.\n      */\n     if (strstr(filename, \"..\") != NULL) {\n-        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n+        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n         return false;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);"
            ],
            "added_lines": [
                "        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28371",
        "func_name": "Stellarium/stellarium/StelScriptOutput::saveOutputAs",
        "description": "In Stellarium through 1.2, attackers can write to files that are typically unintended, such as ones with absolute pathnames or .. directory traversal.",
        "git_url": "https://github.com/Stellarium/stellarium/commit/eba61df3b38605befcb43687a4c0a159dbc0c5cb",
        "commit_title": "Fix a possible security issue",
        "commit_text": "- disallow overwriting config.ini",
        "func_before": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tconst QFileInfo outputInfo(outputFile);\n\tconst QDir dir=outputInfo.dir(); // will hold complete dirname\n\tconst QFileInfo newFileNameInfo(name);\n\n\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\n\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) // The last condition may include dangerous/malicious paths\n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}",
        "func": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tconst QFileInfo outputInfo(outputFile);\n\tconst QDir dir=outputInfo.dir(); // will hold complete dirname\n\tconst QFileInfo newFileNameInfo(name);\n\n\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\n\tif (name.contains(\"config.ini\"))\n\t{\n\t\tqWarning() << \"SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring.\";\n\t\treturn;\n\t}\n\n\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) // The last condition may include dangerous/malicious paths\n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,12 @@\n \tconst QFileInfo newFileNameInfo(name);\n \n \tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n+\n+\tif (name.contains(\"config.ini\"))\n+\t{\n+\t\tqWarning() << \"SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring.\";\n+\t\treturn;\n+\t}\n \n \tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) // The last condition may include dangerous/malicious paths\n \t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (name.contains(\"config.ini\"))",
                "\t{",
                "\t\tqWarning() << \"SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring.\";",
                "\t\treturn;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28371",
        "func_name": "Stellarium/stellarium/StelScriptMgr::runScript",
        "description": "In Stellarium through 1.2, attackers can write to files that are typically unintended, such as ones with absolute pathnames or .. directory traversal.",
        "git_url": "https://github.com/Stellarium/stellarium/commit/787a894897b7872ae96e6f5804a182210edd5c78",
        "commit_title": "Fix a possible security issue",
        "commit_text": "- Require manually set flag to run scripts from absolute pathname - Mostly applies to scripts given on the command line",
        "func_before": "bool StelScriptMgr::runScript(const QString& fileName, const QString& includePath)\n{\n\tQString preprocessedScript;\n\tprepareScript(preprocessedScript,fileName,includePath);\n\treturn runPreprocessedScript(preprocessedScript,fileName);\n}",
        "func": "bool StelScriptMgr::runScript(const QString& fileName, const QString& includePath)\n{\n\tQString preprocessedScript;\n\tif (prepareScript(preprocessedScript,fileName,includePath))\n\t\treturn runPreprocessedScript(preprocessedScript,fileName);\n\telse\n\t\treturn false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n bool StelScriptMgr::runScript(const QString& fileName, const QString& includePath)\n {\n \tQString preprocessedScript;\n-\tprepareScript(preprocessedScript,fileName,includePath);\n-\treturn runPreprocessedScript(preprocessedScript,fileName);\n+\tif (prepareScript(preprocessedScript,fileName,includePath))\n+\t\treturn runPreprocessedScript(preprocessedScript,fileName);\n+\telse\n+\t\treturn false;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tprepareScript(preprocessedScript,fileName,includePath);",
                "\treturn runPreprocessedScript(preprocessedScript,fileName);"
            ],
            "added_lines": [
                "\tif (prepareScript(preprocessedScript,fileName,includePath))",
                "\t\treturn runPreprocessedScript(preprocessedScript,fileName);",
                "\telse",
                "\t\treturn false;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28371",
        "func_name": "Stellarium/stellarium/StelScriptMgr::prepareScript",
        "description": "In Stellarium through 1.2, attackers can write to files that are typically unintended, such as ones with absolute pathnames or .. directory traversal.",
        "git_url": "https://github.com/Stellarium/stellarium/commit/787a894897b7872ae96e6f5804a182210edd5c78",
        "commit_title": "Fix a possible security issue",
        "commit_text": "- Require manually set flag to run scripts from absolute pathname - Mostly applies to scripts given on the command line",
        "func_before": "bool StelScriptMgr::prepareScript( QString &script, const QString &fileName, const QString &includePath)\n{\n\tQString absPath;\n\n\tif (QFileInfo(fileName).isAbsolute())\n\t\tabsPath = fileName;\n\telse\n\t\tabsPath = StelFileMgr::findFile(\"scripts/\" + fileName);\n\n\tif (absPath.isEmpty())\n\t{\n\t\tQString msg = QString(\"WARNING: could not find script file %1\").arg(QDir::toNativeSeparators(fileName));\n\t\temit scriptDebug(msg);\n\t\tqWarning() << msg;\n\t\treturn false;\n\t}\n\n\tQString scriptDir = QFileInfo(absPath).dir().path();\n\n\tQFile fic(absPath);\n\tif (!fic.open(QIODevice::ReadOnly))\n\t{\n\t\tQString msg = QString(\"WARNING: cannot open script: %1\").arg(QDir::toNativeSeparators(fileName));\n\t\temit scriptDebug(msg);\n\t\tqWarning() << msg;\n\t\treturn false;\n\t}\n\n\tif (!includePath.isEmpty())\n\t\tscriptDir = includePath;\n\n\tbool ok = false;\n\tif (fileName.endsWith(\".ssc\"))\n\t\tok = preprocessFile(absPath, fic, script, scriptDir);\n\tif (!ok)\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "func": "bool StelScriptMgr::prepareScript( QString &script, const QString &fileName, const QString &includePath)\n{\n\tQString absPath;\n\tconst bool okToRunScriptFromAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_absolute_path\", false).toBool();\n\n\tif (QFileInfo(fileName).isAbsolute())\n\t{\n\t\t// Absolute paths may bear a security risk. We need a flag to allow them!\n\t\tif (okToRunScriptFromAbsolutePath)\n\t\t\tabsPath = fileName;\n\t\telse\n\t\t{\n\t\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to run a script from absolute pathname.\";\n\t\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_absolute_path=true\";\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t\tabsPath = StelFileMgr::findFile(\"scripts/\" + fileName);\n\n\tif (absPath.isEmpty())\n\t{\n\t\tQString msg = QString(\"WARNING: could not find script file %1\").arg(QDir::toNativeSeparators(fileName));\n\t\temit scriptDebug(msg);\n\t\tqWarning() << msg;\n\t\treturn false;\n\t}\n\n\tQString scriptDir = QFileInfo(absPath).dir().path();\n\n\tQFile fic(absPath);\n\tif (!fic.open(QIODevice::ReadOnly))\n\t{\n\t\tQString msg = QString(\"WARNING: cannot open script: %1\").arg(QDir::toNativeSeparators(fileName));\n\t\temit scriptDebug(msg);\n\t\tqWarning() << msg;\n\t\treturn false;\n\t}\n\n\tif (!includePath.isEmpty())\n\t\tscriptDir = includePath;\n\n\tbool ok = false;\n\tif (fileName.endsWith(\".ssc\"))\n\t\tok = preprocessFile(absPath, fic, script, scriptDir);\n\tif (!ok)\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,20 @@\n bool StelScriptMgr::prepareScript( QString &script, const QString &fileName, const QString &includePath)\n {\n \tQString absPath;\n+\tconst bool okToRunScriptFromAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_absolute_path\", false).toBool();\n \n \tif (QFileInfo(fileName).isAbsolute())\n-\t\tabsPath = fileName;\n+\t{\n+\t\t// Absolute paths may bear a security risk. We need a flag to allow them!\n+\t\tif (okToRunScriptFromAbsolutePath)\n+\t\t\tabsPath = fileName;\n+\t\telse\n+\t\t{\n+\t\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to run a script from absolute pathname.\";\n+\t\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_absolute_path=true\";\n+\t\t\treturn false;\n+\t\t}\n+\t}\n \telse\n \t\tabsPath = StelFileMgr::findFile(\"scripts/\" + fileName);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tabsPath = fileName;"
            ],
            "added_lines": [
                "\tconst bool okToRunScriptFromAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_absolute_path\", false).toBool();",
                "\t{",
                "\t\t// Absolute paths may bear a security risk. We need a flag to allow them!",
                "\t\tif (okToRunScriptFromAbsolutePath)",
                "\t\t\tabsPath = fileName;",
                "\t\telse",
                "\t\t{",
                "\t\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to run a script from absolute pathname.\";",
                "\t\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_absolute_path=true\";",
                "\t\t\treturn false;",
                "\t\t}",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28371",
        "func_name": "Stellarium/stellarium/StelScriptOutput::saveOutputAs",
        "description": "In Stellarium through 1.2, attackers can write to files that are typically unintended, such as ones with absolute pathnames or .. directory traversal.",
        "git_url": "https://github.com/Stellarium/stellarium/commit/1261f74dc4aa6bbd01ab514343424097f8cf46b7",
        "commit_title": "Fix a possible security issue",
        "commit_text": "- script output might have been stored to paths elsewhere - Thanks to G.C. for reporting",
        "func_before": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tQFileInfo outputInfo(outputFile);\n\tQDir dir=outputInfo.dir(); // will hold complete dirname\n\tQFileInfo newFileNameInfo(name);\n\n\tbool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\n\tif (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}",
        "func": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tconst QFileInfo outputInfo(outputFile);\n\tconst QDir dir=outputInfo.dir(); // will hold complete dirname\n\tconst QFileInfo newFileNameInfo(name);\n\n\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\n\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) // The last condition may include dangerous/malicious paths\n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,15 @@\n void StelScriptOutput::saveOutputAs(const QString &name)\n {\n \tQFile asFile;\n-\tQFileInfo outputInfo(outputFile);\n-\tQDir dir=outputInfo.dir(); // will hold complete dirname\n-\tQFileInfo newFileNameInfo(name);\n+\tconst QFileInfo outputInfo(outputFile);\n+\tconst QDir dir=outputInfo.dir(); // will hold complete dirname\n+\tconst QFileInfo newFileNameInfo(name);\n \n-\tbool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n+\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n \n-\tif (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n+\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) // The last condition may include dangerous/malicious paths\n \t{\n-\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname.\";\n+\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.\";\n \t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n \t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n \t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";",
        "diff_line_info": {
            "deleted_lines": [
                "\tQFileInfo outputInfo(outputFile);",
                "\tQDir dir=outputInfo.dir(); // will hold complete dirname",
                "\tQFileInfo newFileNameInfo(name);",
                "\tbool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();",
                "\tif (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))",
                "\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname.\";"
            ],
            "added_lines": [
                "\tconst QFileInfo outputInfo(outputFile);",
                "\tconst QDir dir=outputInfo.dir(); // will hold complete dirname",
                "\tconst QFileInfo newFileNameInfo(name);",
                "\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();",
                "\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) // The last condition may include dangerous/malicious paths",
                "\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31483",
        "func_name": "CauldronDevelopmentLLC/cbang/TarFileReader::extract",
        "description": "tar/TarFileReader.cpp in Cauldron cbang before bastet-v8.1.17 has a directory traversal during extraction that allows the attacker to create or write to files outside the current directory via a crafted tar archive.",
        "git_url": "https://github.com/CauldronDevelopmentLLC/cbang/commit/ac8bbdd5bb93c01679a881f5962fed800bf29e58",
        "commit_title": "Path traversal bug in TarFileReader::extract() #115",
        "commit_text": "",
        "func_before": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) {\n    path += \"/\" + getFilename();\n\n    // Check that path is under the target directory\n    string a = SystemUtilities::getCanonicalPath(_path);\n    string b = SystemUtilities::getCanonicalPath(path);\n    if (!String::startsWith(b, a))\n      THROW(\"Tar path points outside of the extraction directory: \" << path);\n  }\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  switch (getType()) {\n  case REG_FILE: case NORMAL_FILE: case CONTIGUOUS_FILE:\n    return extract(*SystemUtilities::oopen(path, getMode()));\n\n  case DIRECTORY:\n    SystemUtilities::ensureDirectory(path);\n    didReadHeader = false;\n    break;\n\n  default: THROW(\"Unsupported tar file type \" << getType());\n  }\n\n  return getFilename();\n}",
        "func": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) {\n    path += \"/\" + getFilename();\n\n    // Check that path is under the target directory\n    string a = SystemUtilities::getCanonicalPath(_path);\n    string b = SystemUtilities::getCanonicalPath(path);\n    if (!String::startsWith(b, a + \"/\"))\n      THROW(\"Tar path points outside of the extraction directory: \" << path);\n  }\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  switch (getType()) {\n  case REG_FILE: case NORMAL_FILE: case CONTIGUOUS_FILE:\n    return extract(*SystemUtilities::oopen(path, getMode()));\n\n  case DIRECTORY:\n    SystemUtilities::ensureDirectory(path);\n    didReadHeader = false;\n    break;\n\n  default: THROW(\"Unsupported tar file type \" << getType());\n  }\n\n  return getFilename();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n     // Check that path is under the target directory\n     string a = SystemUtilities::getCanonicalPath(_path);\n     string b = SystemUtilities::getCanonicalPath(path);\n-    if (!String::startsWith(b, a))\n+    if (!String::startsWith(b, a + \"/\"))\n       THROW(\"Tar path points outside of the extraction directory: \" << path);\n   }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!String::startsWith(b, a))"
            ],
            "added_lines": [
                "    if (!String::startsWith(b, a + \"/\"))"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-29050",
        "func_name": "manticoresoftware/manticoresearch/MakeSnippets",
        "description": "SphinxSearch in Sphinx Technologies Sphinx through 3.1.1 allows directory traversal (in conjunction with CVE-2019-14511) because the mysql client can be used for CALL SNIPPETS and load_file operations on a full pathname (e.g., a file in the /etc directory). NOTE: this is unrelated to CMUSphinx.",
        "git_url": "https://github.com/manticoresoftware/manticoresearch/commit/6e597ff61e1e910559f6ed541ff32520085af6aa",
        "commit_title": "Fix random file reading by scattered snippets",
        "commit_text": " Issue was that load_files_scattered option just concatenated prefix with given name and then opened the file. So, if you provide something like '/etc/password' as file, or '../../../etc/passwd' even with non-zero prefix, it will unfortunately work. After this commit such behavior possible ONLY if user explicitly set `snippets_file_prefix` to empty string or '/'; another cases will not cause uncontroled reading. That fixes #866",
        "func_before": "bool MakeSnippets ( CSphString sIndex, CSphVector<ExcerptQueryChained_t> & dQueries, CSphString & sError, ThdDesc_t & tThd )\n{\n\tSnippetsRemote_t dRemoteSnippets ( dQueries );\n\tExcerptQuery_t &q = *dQueries.begin ();\n\n\t// Both load_files && load_files_scattered report the absent files as errors.\n\t// load_files_scattered without load_files just omits the absent files (returns empty strings).\n\tauto bScattered = !!( q.m_uFilesMode & 2 );\n\tauto bNeedAllFiles = !!( q.m_uFilesMode & 1 );\n\n\tauto pDist = GetDistr ( sIndex );\n\tif ( pDist )\n\t\tfor ( auto * pAgent : pDist->m_dAgents )\n\t\t{\n\t\t\tauto * pConn = new AgentConn_t;\n\t\t\tpConn->SetMultiAgent ( sIndex, pAgent );\n\t\t\tpConn->m_iMyConnectTimeout = pDist->m_iAgentConnectTimeout;\n\t\t\tpConn->m_iMyQueryTimeout = pDist->m_iAgentQueryTimeout;\n\t\t\tdRemoteSnippets.m_dAgents.Add ( pConn );\n\t\t}\n\n\tbool bRemote = !dRemoteSnippets.m_dAgents.IsEmpty ();\n\tif ( bRemote )\n\t{\n\t\tif ( pDist->m_dLocal.GetLength()!=1 )\n\t\t{\n\t\t\tsError.SetSprintf ( \"%s\", \"The distributed index for snippets must have exactly one local agent\" );\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !q.m_uFilesMode )\n\t\t{\n\t\t\tsError.SetSprintf ( \"%s\", \"The distributed index for snippets available only when using external files\" );\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( g_iDistThreads<=1 && bScattered )\n\t\t{\n\t\t\tsError.SetSprintf ( \"%s\", \"load_files_scattered works only together with dist_threads>1\" );\n\t\t\treturn false;\n\t\t}\n\t\tsIndex = *pDist->m_dLocal.begin();\n\t}\n\n\tServedDescRPtr_c pServed ( GetServed ( sIndex ) );\n\tif ( !pServed || !pServed->m_pIndex )\n\t{\n\t\tsError.SetSprintf ( \"unknown local index '%s' in search request\", sIndex.cstr() );\n\t\treturn false;\n\t}\n\n\tCSphIndex * pIndex = pServed->m_pIndex;\n\tassert ( pIndex );\n\n\tSnippetContext_t tCtx;\n\tif ( !tCtx.Setup ( pIndex, q, sError ) ) // same path for single - threaded snippets, bail out here on error\n\t\treturn false;\n\n\t///////////////////\n\t// do highlighting\n\t///////////////////\n\n\t// boring single threaded loop\n\tStringBuilder_c sErrors ( \"; \" );\n\tif ( g_iDistThreads<=1 || dQueries.GetLength()<2 )\n\t{\n\t\tfor ( auto & dQuery: dQueries )\n\t\t{\n\t\t\ttCtx.BuildExcerpt ( dQuery, pIndex );\n\t\t\tsErrors << dQuery.m_sError;\n\t\t}\n\t\tsErrors.MoveTo (sError);\n\t\treturn sError.IsEmpty ();\n\t}\n\n\t// not boring mt loop with (may be) scattered.\n\tARRAY_FOREACH ( i, dQueries )\n\t\tdQueries[i].m_iSeq = i;\n\n\t// collect file sizes; mark absent with EOF_ITEM\n\tfor ( auto & dQuery : dQueries )\n\t{\n\t\tassert ( dQuery.m_iNext == PROCESSED_ITEM );\n\t\tif ( dQuery.m_uFilesMode )\n\t\t{\n\t\t\tCSphString sFilename, sStatError;\n\t\t\tsFilename.SetSprintf ( \"%s%s\", g_sSnippetsFilePrefix.cstr(), dQuery.m_sSource.scstr() );\n\t\t\tauto iFileSize = sphGetFileSize (sFilename, &sStatError);\n\t\t\tif ( iFileSize<0 )\n\t\t\t{\n\t\t\t\tif ( !bScattered )\n\t\t\t\t{\n\t\t\t\t\tsError = sStatError;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdQuery.m_iNext = EOF_ITEM;\n\t\t\t} else\n\t\t\t\tdQuery.m_iSize = -iFileSize; // so that sort would put bigger ones first\n\t\t} else\n\t\t\tdQuery.m_iSize = -dQuery.m_sSource.Length();\n\t}\n\n\t// set correct data size for snippets\n\ttThd.SetThreadInfo ( R\"(snippet datasize=%.1Dk query=\"%s\")\",\n\t\t\t\t\t\t GetSnippetDataSize ( dQueries ), dQueries[0].m_sWords.scstr () );\n\n\t// tough jobs first\n\tif ( !bScattered )\n\t\tdQueries.Sort ( bind ( &ExcerptQueryChained_t::m_iSize ) );\n\n\t// build list of absent files (that's ok for scattered).\n\t// later all the list will be sent to remotes (and some of them have to answer)\n\tint iAbsentHead = EOF_ITEM;\n\tARRAY_FOREACH ( i, dQueries )\n\t\tif ( dQueries[i].m_iNext==EOF_ITEM )\n\t\t{\n\t\t\tdQueries[i].m_iNext = iAbsentHead;\n\t\t\tiAbsentHead = i;\n\t\t\tif ( bNeedAllFiles )\n\t\t\t\tdQueries[i].m_sError.SetSprintf ( \"absenthead: failed to stat %s: %s\",\n\t\t\t\t\tdQueries[i].m_sSource.cstr(), strerrorm(errno) );\n\t\t}\n\n\t// check if all files are available locally.\n\tif ( bScattered && iAbsentHead==EOF_ITEM )\n\t\tbRemote = false;\n\n\t// stuff for thread-pooling\n\tauto * pPool = sphThreadPoolCreate ( g_iDistThreads - 1, \"snippets\", sError );\n\tif ( !pPool )\n\t\tsphWarning ( \"failed to create thread_pool, single thread snippets used: %s\", sError.cstr () );\n\tCrashQuery_t tCrashQuery = SphCrashLogger_c::GetQuery (); // transfer query info for crash logger to new thread\n\tCSphAtomic iCurQuery;\n\tCSphVector<SnippetJob_t> dThreads ( Min ( 1, g_iDistThreads ) );\n\tSnippetJob_t * pJobLocal = nullptr;\n\n\t// one more boring case: multithreaded, but no remote agents.\n\tif ( !bRemote )\n\t{\n\t\t// do MT searching\n\t\tfor ( auto & t : dThreads )\n\t\t{\n\t\t\tt.m_iQueries = dQueries.GetLength ();\n\t\t\tt.m_pQueries = dQueries.Begin ();\n\t\t\tt.m_pCurQuery = &iCurQuery;\n\t\t\tt.m_pIndex = pIndex;\n\t\t\tt.m_tCrashQuery = tCrashQuery;\n\t\t\tif ( !pJobLocal )\n\t\t\t\tpJobLocal = &t;\n\t\t\telse if ( pPool )\n\t\t\t\tpPool->AddJob ( &t );\n\t\t}\n\t\tif ( pJobLocal )\n\t\t\tpJobLocal->Call();\n\t\tSafeDelete ( pPool );\n\n\t\t// back in query order\n\t\tif ( !bScattered )\n\t\t\tdQueries.Sort ( bind ( &ExcerptQueryChained_t::m_iSeq ) );\n\t\tdQueries.Apply ( [&] ( const ExcerptQuery_t &dQuery ) { sErrors << dQuery.m_sError; } );\n\t\tsErrors.MoveTo ( sError );\n\t\treturn sError.IsEmpty ();\n\t}\n\n\t// and finally most interesting remote case with possibly scattered.\n\n\tint iRemoteAgents = dRemoteSnippets.m_dAgents.GetLength();\n\tdRemoteSnippets.m_dTasks.Resize ( iRemoteAgents );\n\n\tif ( bScattered )\n\t{\n\t\t// on scattered case - just push the chain of absent files to all remotes\n\t\tassert ( iAbsentHead!=EOF_ITEM ); // otherwize why we have remotes?\n\t\tfor ( auto & dTask : dRemoteSnippets.m_dTasks )\n\t\t\tdTask.m_iHead = iAbsentHead;\n\t} else\n\t{\n\t\t// distribute queries among tasks by total task size\n\t\tARRAY_FOREACH ( i, dQueries )\n\t\t{\n\t\t\tauto & dHeadTask = *dRemoteSnippets.m_dTasks.begin();\n\t\t\tdHeadTask.m_iTotal -= dQueries[i].m_iSize; // -= since size stored as negative.\n\t\t\t// queries sheduled for local still have iNext==PROCESSED_ITEM\n\t\t\tdQueries[i].m_iNext = dHeadTask.m_iHead;\n\t\t\tdHeadTask.m_iHead = i;\n\t\t\tdRemoteSnippets.m_dTasks.Sort ( bind ( &SnippetChain_t::m_iTotal ) );\n\t\t}\n\t}\n\n\t// do MT searching\n\tfor ( auto &t : dThreads )\n\t{\n\t\tt.m_iQueries = dQueries.GetLength();\n\t\tt.m_pQueries = dQueries.Begin();\n\t\tt.m_pCurQuery = &iCurQuery;\n\t\tt.m_pIndex = pIndex;\n\t\tt.m_tCrashQuery = tCrashQuery;\n\t\tif ( !pJobLocal )\n\t\t\tpJobLocal = &t;\n\t\telse if ( pPool )\n\t\t\tpPool->AddJob ( &t );\n\t}\n\n\t// connect to remote agents and query them\n\tSnippetRequestBuilder_c tReqBuilder ( &dRemoteSnippets );\n\tSnippetReplyParser_c tParser ( &dRemoteSnippets );\n\tCSphRefcountedPtr<RemoteAgentsObserver_i> tReporter ( GetObserver() );\n\tScheduleDistrJobs ( dRemoteSnippets.m_dAgents, &tReqBuilder, &tParser, tReporter );\n\n\t// run local worker in current thread also\n\tif ( pJobLocal )\n\t\tpJobLocal->Call ();\n\n\t// wait local jobs to finish\n\tSafeDelete ( pPool );\n\n\t// wait remotes to finish also\n\ttReporter->Finish ();\n\n\tauto iSuccesses = ( int ) tReporter->GetSucceeded ();\n\tauto iAgentsDone = ( int ) tReporter->GetFinished ();\n\n\tif ( iSuccesses!=dRemoteSnippets.m_dAgents.GetLength() )\n\t{\n\t\tsphWarning ( \"Remote snippets: some of the agents didn't answered: %d queried, %d finished, %d succeeded\",\n\t\t\tdRemoteSnippets.m_dAgents.GetLength(), iAgentsDone,\tiSuccesses );\n\n\t\tif ( !bScattered )\n\t\t{\n\t\t\tint iFailed = 0;\n\t\t\t// inverse the success/failed state - so that the queries with negative m_iNext are treated as failed\n\t\t\tdQueries.Apply ( [&] ( ExcerptQueryChained_t &dQuery ) {\n\t\t\t\tif ( dQuery.m_iNext!=PROCESSED_ITEM )\n\t\t\t\t{\n\t\t\t\t\tdQuery.m_iNext = PROCESSED_ITEM;\n\t\t\t\t\t++iFailed;\n\t\t\t\t} else\n\t\t\t\t\tdQuery.m_iNext = 0;\n\t\t\t} );\n\n\t\t\t// failsafe - one more turn for failed queries on local agent\n\t\t\tif ( iFailed )\n\t\t\t{\n\t\t\t\tsphWarning ( \"Snippets: failsafe for %d failed items\", iFailed );\n\t\t\t\tauto & t = dThreads[0];\n\t\t\t\tt.m_pQueries = dQueries.Begin();\n\t\t\t\tiCurQuery = 0;\n\t\t\t\tt.Call();\n\t\t\t}\n\t\t}\n\t}\n\n\t// back in query order\n\tif ( !bScattered )\n\t\tdQueries.Sort ( bind ( &ExcerptQueryChained_t::m_iSeq ) );\n\n\tdQueries.Apply ( [&] ( const ExcerptQuery_t &dQuery ) { sErrors << dQuery.m_sError;});\n\tsErrors.MoveTo ( sError );\n\treturn sError.IsEmpty ();\n}",
        "func": "bool MakeSnippets ( CSphString sIndex, CSphVector<ExcerptQueryChained_t> & dQueries, CSphString & sError, ThdDesc_t & tThd )\n{\n\tSnippetsRemote_t dRemoteSnippets ( dQueries );\n\tExcerptQuery_t &q = *dQueries.begin ();\n\n\t// Both load_files && load_files_scattered report the absent files as errors.\n\t// load_files_scattered without load_files just omits the absent files (returns empty strings).\n\tauto bScattered = !!( q.m_uFilesMode & 2 );\n\tauto bNeedAllFiles = !!( q.m_uFilesMode & 1 );\n\n\tauto pDist = GetDistr ( sIndex );\n\tif ( pDist )\n\t\tfor ( auto * pAgent : pDist->m_dAgents )\n\t\t{\n\t\t\tauto * pConn = new AgentConn_t;\n\t\t\tpConn->SetMultiAgent ( sIndex, pAgent );\n\t\t\tpConn->m_iMyConnectTimeout = pDist->m_iAgentConnectTimeout;\n\t\t\tpConn->m_iMyQueryTimeout = pDist->m_iAgentQueryTimeout;\n\t\t\tdRemoteSnippets.m_dAgents.Add ( pConn );\n\t\t}\n\n\tbool bRemote = !dRemoteSnippets.m_dAgents.IsEmpty ();\n\tif ( bRemote )\n\t{\n\t\tif ( pDist->m_dLocal.GetLength()!=1 )\n\t\t{\n\t\t\tsError.SetSprintf ( \"%s\", \"The distributed index for snippets must have exactly one local agent\" );\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !q.m_uFilesMode )\n\t\t{\n\t\t\tsError.SetSprintf ( \"%s\", \"The distributed index for snippets available only when using external files\" );\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( g_iDistThreads<=1 && bScattered )\n\t\t{\n\t\t\tsError.SetSprintf ( \"%s\", \"load_files_scattered works only together with dist_threads>1\" );\n\t\t\treturn false;\n\t\t}\n\t\tsIndex = *pDist->m_dLocal.begin();\n\t}\n\n\tServedDescRPtr_c pServed ( GetServed ( sIndex ) );\n\tif ( !pServed || !pServed->m_pIndex )\n\t{\n\t\tsError.SetSprintf ( \"unknown local index '%s' in search request\", sIndex.cstr() );\n\t\treturn false;\n\t}\n\n\tCSphIndex * pIndex = pServed->m_pIndex;\n\tassert ( pIndex );\n\n\tSnippetContext_t tCtx;\n\tif ( !tCtx.Setup ( pIndex, q, sError ) ) // same path for single - threaded snippets, bail out here on error\n\t\treturn false;\n\n\t///////////////////\n\t// do highlighting\n\t///////////////////\n\n\t// boring single threaded loop\n\tStringBuilder_c sErrors ( \"; \" );\n\tif ( g_iDistThreads<=1 || dQueries.GetLength()<2 )\n\t{\n\t\tfor ( auto & dQuery: dQueries )\n\t\t{\n\t\t\ttCtx.BuildExcerpt ( dQuery, pIndex );\n\t\t\tsErrors << dQuery.m_sError;\n\t\t}\n\t\tsErrors.MoveTo (sError);\n\t\treturn sError.IsEmpty ();\n\t}\n\n\t// not boring mt loop with (may be) scattered.\n\tARRAY_FOREACH ( i, dQueries )\n\t\tdQueries[i].m_iSeq = i;\n\n\t// collect file sizes; mark absent with EOF_ITEM\n\tfor ( auto & dQuery : dQueries )\n\t{\n\t\tassert ( dQuery.m_iNext == PROCESSED_ITEM );\n\t\tif ( dQuery.m_uFilesMode )\n\t\t{\n\t\t\tCSphString sFilename, sStatError;\n\t\t\tsFilename.SetSprintf ( \"%s%s\", g_sSnippetsFilePrefix.cstr(), dQuery.m_sSource.scstr() );\n\t\t\tif ( !TestEscaping ( g_sSnippetsFilePrefix, sFilename ))\n\t\t\t{\n\t\t\t\tsError.SetSprintf( \"File '%s' escapes '%s' scope\",\n\t\t\t\t\tsFilename.scstr(), g_sSnippetsFilePrefix.scstr());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tauto iFileSize = sphGetFileSize (sFilename, &sStatError);\n\t\t\tif ( iFileSize<0 )\n\t\t\t{\n\t\t\t\tif ( !bScattered )\n\t\t\t\t{\n\t\t\t\t\tsError = sStatError;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdQuery.m_iNext = EOF_ITEM;\n\t\t\t} else\n\t\t\t\tdQuery.m_iSize = -iFileSize; // so that sort would put bigger ones first\n\t\t} else\n\t\t\tdQuery.m_iSize = -dQuery.m_sSource.Length();\n\t}\n\n\t// set correct data size for snippets\n\ttThd.SetThreadInfo ( R\"(snippet datasize=%.1Dk query=\"%s\")\",\n\t\t\t\t\t\t GetSnippetDataSize ( dQueries ), dQueries[0].m_sWords.scstr () );\n\n\t// tough jobs first\n\tif ( !bScattered )\n\t\tdQueries.Sort ( bind ( &ExcerptQueryChained_t::m_iSize ) );\n\n\t// build list of absent files (that's ok for scattered).\n\t// later all the list will be sent to remotes (and some of them have to answer)\n\tint iAbsentHead = EOF_ITEM;\n\tARRAY_FOREACH ( i, dQueries )\n\t\tif ( dQueries[i].m_iNext==EOF_ITEM )\n\t\t{\n\t\t\tdQueries[i].m_iNext = iAbsentHead;\n\t\t\tiAbsentHead = i;\n\t\t\tif ( bNeedAllFiles )\n\t\t\t\tdQueries[i].m_sError.SetSprintf ( \"absenthead: failed to stat %s: %s\",\n\t\t\t\t\tdQueries[i].m_sSource.cstr(), strerrorm(errno) );\n\t\t}\n\n\t// check if all files are available locally.\n\tif ( bScattered && iAbsentHead==EOF_ITEM )\n\t\tbRemote = false;\n\n\t// stuff for thread-pooling\n\tauto * pPool = sphThreadPoolCreate ( g_iDistThreads - 1, \"snippets\", sError );\n\tif ( !pPool )\n\t\tsphWarning ( \"failed to create thread_pool, single thread snippets used: %s\", sError.cstr () );\n\tCrashQuery_t tCrashQuery = SphCrashLogger_c::GetQuery (); // transfer query info for crash logger to new thread\n\tCSphAtomic iCurQuery;\n\tCSphVector<SnippetJob_t> dThreads ( Min ( 1, g_iDistThreads ) );\n\tSnippetJob_t * pJobLocal = nullptr;\n\n\t// one more boring case: multithreaded, but no remote agents.\n\tif ( !bRemote )\n\t{\n\t\t// do MT searching\n\t\tfor ( auto & t : dThreads )\n\t\t{\n\t\t\tt.m_iQueries = dQueries.GetLength ();\n\t\t\tt.m_pQueries = dQueries.Begin ();\n\t\t\tt.m_pCurQuery = &iCurQuery;\n\t\t\tt.m_pIndex = pIndex;\n\t\t\tt.m_tCrashQuery = tCrashQuery;\n\t\t\tif ( !pJobLocal )\n\t\t\t\tpJobLocal = &t;\n\t\t\telse if ( pPool )\n\t\t\t\tpPool->AddJob ( &t );\n\t\t}\n\t\tif ( pJobLocal )\n\t\t\tpJobLocal->Call();\n\t\tSafeDelete ( pPool );\n\n\t\t// back in query order\n\t\tif ( !bScattered )\n\t\t\tdQueries.Sort ( bind ( &ExcerptQueryChained_t::m_iSeq ) );\n\t\tdQueries.Apply ( [&] ( const ExcerptQuery_t &dQuery ) { sErrors << dQuery.m_sError; } );\n\t\tsErrors.MoveTo ( sError );\n\t\treturn sError.IsEmpty ();\n\t}\n\n\t// and finally most interesting remote case with possibly scattered.\n\n\tint iRemoteAgents = dRemoteSnippets.m_dAgents.GetLength();\n\tdRemoteSnippets.m_dTasks.Resize ( iRemoteAgents );\n\n\tif ( bScattered )\n\t{\n\t\t// on scattered case - just push the chain of absent files to all remotes\n\t\tassert ( iAbsentHead!=EOF_ITEM ); // otherwize why we have remotes?\n\t\tfor ( auto & dTask : dRemoteSnippets.m_dTasks )\n\t\t\tdTask.m_iHead = iAbsentHead;\n\t} else\n\t{\n\t\t// distribute queries among tasks by total task size\n\t\tARRAY_FOREACH ( i, dQueries )\n\t\t{\n\t\t\tauto & dHeadTask = *dRemoteSnippets.m_dTasks.begin();\n\t\t\tdHeadTask.m_iTotal -= dQueries[i].m_iSize; // -= since size stored as negative.\n\t\t\t// queries sheduled for local still have iNext==PROCESSED_ITEM\n\t\t\tdQueries[i].m_iNext = dHeadTask.m_iHead;\n\t\t\tdHeadTask.m_iHead = i;\n\t\t\tdRemoteSnippets.m_dTasks.Sort ( bind ( &SnippetChain_t::m_iTotal ) );\n\t\t}\n\t}\n\n\t// do MT searching\n\tfor ( auto &t : dThreads )\n\t{\n\t\tt.m_iQueries = dQueries.GetLength();\n\t\tt.m_pQueries = dQueries.Begin();\n\t\tt.m_pCurQuery = &iCurQuery;\n\t\tt.m_pIndex = pIndex;\n\t\tt.m_tCrashQuery = tCrashQuery;\n\t\tif ( !pJobLocal )\n\t\t\tpJobLocal = &t;\n\t\telse if ( pPool )\n\t\t\tpPool->AddJob ( &t );\n\t}\n\n\t// connect to remote agents and query them\n\tSnippetRequestBuilder_c tReqBuilder ( &dRemoteSnippets );\n\tSnippetReplyParser_c tParser ( &dRemoteSnippets );\n\tCSphRefcountedPtr<RemoteAgentsObserver_i> tReporter ( GetObserver() );\n\tScheduleDistrJobs ( dRemoteSnippets.m_dAgents, &tReqBuilder, &tParser, tReporter );\n\n\t// run local worker in current thread also\n\tif ( pJobLocal )\n\t\tpJobLocal->Call ();\n\n\t// wait local jobs to finish\n\tSafeDelete ( pPool );\n\n\t// wait remotes to finish also\n\ttReporter->Finish ();\n\n\tauto iSuccesses = ( int ) tReporter->GetSucceeded ();\n\tauto iAgentsDone = ( int ) tReporter->GetFinished ();\n\n\tif ( iSuccesses!=dRemoteSnippets.m_dAgents.GetLength() )\n\t{\n\t\tsphWarning ( \"Remote snippets: some of the agents didn't answered: %d queried, %d finished, %d succeeded\",\n\t\t\tdRemoteSnippets.m_dAgents.GetLength(), iAgentsDone,\tiSuccesses );\n\n\t\tif ( !bScattered )\n\t\t{\n\t\t\tint iFailed = 0;\n\t\t\t// inverse the success/failed state - so that the queries with negative m_iNext are treated as failed\n\t\t\tdQueries.Apply ( [&] ( ExcerptQueryChained_t &dQuery ) {\n\t\t\t\tif ( dQuery.m_iNext!=PROCESSED_ITEM )\n\t\t\t\t{\n\t\t\t\t\tdQuery.m_iNext = PROCESSED_ITEM;\n\t\t\t\t\t++iFailed;\n\t\t\t\t} else\n\t\t\t\t\tdQuery.m_iNext = 0;\n\t\t\t} );\n\n\t\t\t// failsafe - one more turn for failed queries on local agent\n\t\t\tif ( iFailed )\n\t\t\t{\n\t\t\t\tsphWarning ( \"Snippets: failsafe for %d failed items\", iFailed );\n\t\t\t\tauto & t = dThreads[0];\n\t\t\t\tt.m_pQueries = dQueries.Begin();\n\t\t\t\tiCurQuery = 0;\n\t\t\t\tt.Call();\n\t\t\t}\n\t\t}\n\t}\n\n\t// back in query order\n\tif ( !bScattered )\n\t\tdQueries.Sort ( bind ( &ExcerptQueryChained_t::m_iSeq ) );\n\n\tdQueries.Apply ( [&] ( const ExcerptQuery_t &dQuery ) { sErrors << dQuery.m_sError;});\n\tsErrors.MoveTo ( sError );\n\treturn sError.IsEmpty ();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,6 +85,12 @@\n \t\t{\n \t\t\tCSphString sFilename, sStatError;\n \t\t\tsFilename.SetSprintf ( \"%s%s\", g_sSnippetsFilePrefix.cstr(), dQuery.m_sSource.scstr() );\n+\t\t\tif ( !TestEscaping ( g_sSnippetsFilePrefix, sFilename ))\n+\t\t\t{\n+\t\t\t\tsError.SetSprintf( \"File '%s' escapes '%s' scope\",\n+\t\t\t\t\tsFilename.scstr(), g_sSnippetsFilePrefix.scstr());\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t\tauto iFileSize = sphGetFileSize (sFilename, &sStatError);\n \t\t\tif ( iFileSize<0 )\n \t\t\t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif ( !TestEscaping ( g_sSnippetsFilePrefix, sFilename ))",
                "\t\t\t{",
                "\t\t\t\tsError.SetSprintf( \"File '%s' escapes '%s' scope\",",
                "\t\t\t\t\tsFilename.scstr(), g_sSnippetsFilePrefix.scstr());",
                "\t\t\t\treturn false;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-29050",
        "func_name": "manticoresoftware/manticoresearch/SnippetContext_t::BuildExcerpt",
        "description": "SphinxSearch in Sphinx Technologies Sphinx through 3.1.1 allows directory traversal (in conjunction with CVE-2019-14511) because the mysql client can be used for CALL SNIPPETS and load_file operations on a full pathname (e.g., a file in the /etc directory). NOTE: this is unrelated to CMUSphinx.",
        "git_url": "https://github.com/manticoresoftware/manticoresearch/commit/6e597ff61e1e910559f6ed541ff32520085af6aa",
        "commit_title": "Fix random file reading by scattered snippets",
        "commit_text": " Issue was that load_files_scattered option just concatenated prefix with given name and then opened the file. So, if you provide something like '/etc/password' as file, or '../../../etc/passwd' even with non-zero prefix, it will unfortunately work. After this commit such behavior possible ONLY if user explicitly set `snippets_file_prefix` to empty string or '/'; another cases will not cause uncontroled reading. That fixes #866",
        "func_before": "void SnippetContext_t::BuildExcerpt ( ExcerptQuery_t & tOptions, const CSphIndex * pIndex ) const\n{\n\tauto pStripper = m_tStripper.Ptr ();\n\tCSphString &sError = tOptions.m_sError;\n\n\ttOptions.m_dSeparators.Resize ( 0 );\n\n\tif ( tOptions.m_sStripMode==\"retain\"\n\t\t&& !( tOptions.m_iLimit==0 && tOptions.m_iLimitPassages==0 && tOptions.m_iLimitWords==0 ) )\n\t{\n\t\tsError = \"html_strip_mode=retain requires that all limits are zero\";\n\t\treturn;\n\t}\n\n\tauto * pData = const_cast<char*> ( tOptions.m_sSource.cstr() );\n\tCSphFixedVector<char> pBuffer { 0 };\n\n\tif ( tOptions.m_uFilesMode )\n\t{\n\t\tCSphAutofile tFile;\n\t\tCSphString sFilename;\n\t\tsFilename.SetSprintf ( \"%s%s\", g_sSnippetsFilePrefix.cstr(), tOptions.m_sSource.scstr() );\n\t\tif ( !sFilename.IsEmpty () && tFile.Open ( sFilename.cstr(), SPH_O_READ, sError )<0 )\n\t\t\treturn;\n\t\telse if ( tOptions.m_sSource.IsEmpty() )\n\t\t{\n\t\t\tsError.SetSprintf ( \"snippet file name is empty\" );\n\t\t\treturn;\n\t\t}\n\n\t\t// will this ever trigger? time will tell; email me if it does!\n\t\tif ( tFile.GetSize()+1>=(SphOffset_t)INT_MAX )\n\t\t{\n\t\t\tsError.SetSprintf ( \"%s too big for snippet (over 2 GB)\", pData );\n\t\t\treturn;\n\t\t}\n\n\t\tauto iFileSize = (int)tFile.GetSize();\n\t\tif ( iFileSize<0 )\n\t\t\treturn;\n\n\t\tpBuffer.Reset ( iFileSize+1 );\n\t\tif ( !tFile.Read ( pBuffer.Begin(), iFileSize, sError ) )\n\t\t\treturn;\n\n\t\tpData = pBuffer.Begin();\n\t\tpData[iFileSize] = '\\0';\n\t}\n\n\t// strip if we have to\n\tif ( pStripper && ( tOptions.m_sStripMode==\"strip\" || tOptions.m_sStripMode==\"index\" ) )\n\t\tpStripper->Strip ( (BYTE*)pData );\n\n\tif ( tOptions.m_sStripMode!=\"retain\" )\n\t\tpStripper = NULL;\n\n\t// FIXME!!! check on real data (~100 Mb) as stripper changes len\n\tint iDataLen = pData ? strlen ( pData ) : 0;\n\n\tDoHighlighting ( tOptions, pIndex->GetSettings(), m_tExtQuery, m_eExtQuerySPZ, pData, iDataLen, m_pDict,\n\t\tm_pTokenizer, pStripper, m_pQueryTokenizer, tOptions.m_dRes, tOptions.m_dSeparators );\n}",
        "func": "void SnippetContext_t::BuildExcerpt ( ExcerptQuery_t & tOptions, const CSphIndex * pIndex ) const\n{\n\tauto pStripper = m_tStripper.Ptr ();\n\tCSphString &sError = tOptions.m_sError;\n\n\ttOptions.m_dSeparators.Resize ( 0 );\n\n\tif ( tOptions.m_sStripMode==\"retain\"\n\t\t&& !( tOptions.m_iLimit==0 && tOptions.m_iLimitPassages==0 && tOptions.m_iLimitWords==0 ) )\n\t{\n\t\tsError = \"html_strip_mode=retain requires that all limits are zero\";\n\t\treturn;\n\t}\n\n\tauto * pData = const_cast<char*> ( tOptions.m_sSource.cstr() );\n\tCSphFixedVector<char> pBuffer { 0 };\n\n\tif ( tOptions.m_uFilesMode )\n\t{\n\t\tCSphAutofile tFile;\n\t\tCSphString sFilename;\n\t\tsFilename.SetSprintf ( \"%s%s\", g_sSnippetsFilePrefix.cstr(), tOptions.m_sSource.scstr() );\n\t\tif ( !TestEscaping( g_sSnippetsFilePrefix, sFilename ))\n\t\t{\n\t\t\tsError.SetSprintf( \"File '%s' escapes '%s' scope\", sFilename.scstr(), g_sSnippetsFilePrefix.scstr());\n\t\t\treturn;\n\t\t}\n\t\tif ( !sFilename.IsEmpty () && tFile.Open ( sFilename.cstr(), SPH_O_READ, sError )<0 )\n\t\t\treturn;\n\t\telse if ( tOptions.m_sSource.IsEmpty() )\n\t\t{\n\t\t\tsError.SetSprintf ( \"snippet file name is empty\" );\n\t\t\treturn;\n\t\t}\n\n\t\t// will this ever trigger? time will tell; email me if it does!\n\t\tif ( tFile.GetSize()+1>=(SphOffset_t)INT_MAX )\n\t\t{\n\t\t\tsError.SetSprintf ( \"%s too big for snippet (over 2 GB)\", pData );\n\t\t\treturn;\n\t\t}\n\n\t\tauto iFileSize = (int)tFile.GetSize();\n\t\tif ( iFileSize<0 )\n\t\t\treturn;\n\n\t\tpBuffer.Reset ( iFileSize+1 );\n\t\tif ( !tFile.Read ( pBuffer.Begin(), iFileSize, sError ) )\n\t\t\treturn;\n\n\t\tpData = pBuffer.Begin();\n\t\tpData[iFileSize] = '\\0';\n\t}\n\n\t// strip if we have to\n\tif ( pStripper && ( tOptions.m_sStripMode==\"strip\" || tOptions.m_sStripMode==\"index\" ) )\n\t\tpStripper->Strip ( (BYTE*)pData );\n\n\tif ( tOptions.m_sStripMode!=\"retain\" )\n\t\tpStripper = NULL;\n\n\t// FIXME!!! check on real data (~100 Mb) as stripper changes len\n\tint iDataLen = pData ? strlen ( pData ) : 0;\n\n\tDoHighlighting ( tOptions, pIndex->GetSettings(), m_tExtQuery, m_eExtQuerySPZ, pData, iDataLen, m_pDict,\n\t\tm_pTokenizer, pStripper, m_pQueryTokenizer, tOptions.m_dRes, tOptions.m_dSeparators );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,11 @@\n \t\tCSphAutofile tFile;\n \t\tCSphString sFilename;\n \t\tsFilename.SetSprintf ( \"%s%s\", g_sSnippetsFilePrefix.cstr(), tOptions.m_sSource.scstr() );\n+\t\tif ( !TestEscaping( g_sSnippetsFilePrefix, sFilename ))\n+\t\t{\n+\t\t\tsError.SetSprintf( \"File '%s' escapes '%s' scope\", sFilename.scstr(), g_sSnippetsFilePrefix.scstr());\n+\t\t\treturn;\n+\t\t}\n \t\tif ( !sFilename.IsEmpty () && tFile.Open ( sFilename.cstr(), SPH_O_READ, sError )<0 )\n \t\t\treturn;\n \t\telse if ( tOptions.m_sSource.IsEmpty() )",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif ( !TestEscaping( g_sSnippetsFilePrefix, sFilename ))",
                "\t\t{",
                "\t\t\tsError.SetSprintf( \"File '%s' escapes '%s' scope\", sFilename.scstr(), g_sSnippetsFilePrefix.scstr());",
                "\t\t\treturn;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/escape",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/0a160214424d5ca708b8e2eaea061924d8fb0c38",
        "commit_title": "Fix vulnrabilities in mustache and static",
        "commit_text": "",
        "func_before": "void escape(const std::string& in, std::string& out)\n            {\n                out.reserve(out.size() + in.size());\n                for (auto it = in.begin(); it != in.end(); ++it)\n                {\n                    switch (*it)\n                    {\n                        case '&': out += \"&amp;\"; break;\n                        case '<': out += \"&lt;\"; break;\n                        case '>': out += \"&gt;\"; break;\n                        case '\"': out += \"&quot;\"; break;\n                        case '\\'': out += \"&#39;\"; break;\n                        case '/': out += \"&#x2F;\"; break;\n                        default: out += *it; break;\n                    }\n                }\n            }",
        "func": "void escape(const std::string& in, std::string& out)\n            {\n                out.reserve(out.size() + in.size());\n                for (auto it = in.begin(); it != in.end(); ++it)\n                {\n                    switch (*it)\n                    {\n                        case '&': out += \"&amp;\"; break;\n                        case '<': out += \"&lt;\"; break;\n                        case '>': out += \"&gt;\"; break;\n                        case '\"': out += \"&quot;\"; break;\n                        case '\\'': out += \"&#39;\"; break;\n                        case '/': out += \"&#x2F;\"; break;\n                        case '`': out += \"&#x60\"; break;\n                        case '=': out += \"&#x3D\"; break;\n                        default: out += *it; break;\n                    }\n                }\n            }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,8 @@\n                         case '\"': out += \"&quot;\"; break;\n                         case '\\'': out += \"&#39;\"; break;\n                         case '/': out += \"&#x2F;\"; break;\n+                        case '`': out += \"&#x60\"; break;\n+                        case '=': out += \"&#x3D\"; break;\n                         default: out += *it; break;\n                     }\n                 }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                        case '`': out += \"&#x60\"; break;",
                "                        case '=': out += \"&#x3D\"; break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/set_static_file_info",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/0a160214424d5ca708b8e2eaea061924d8fb0c38",
        "commit_title": "Fix vulnrabilities in mustache and static",
        "commit_text": "",
        "func_before": "void set_static_file_info(std::string path)\n        {\n            file_info.path = path;\n            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n#ifdef CROW_ENABLE_COMPRESSION\n            compressed = false;\n#endif\n            if (file_info.statResult == 0)\n            {\n                std::size_t last_dot = path.find_last_of(\".\");\n                std::string extension = path.substr(last_dot + 1);\n                std::string mimeType = \"\";\n                code = 200;\n                this->add_header(\"Content-length\", std::to_string(file_info.statbuf.st_size));\n\n                if (extension != \"\")\n                {\n                    mimeType = mime_types.at(extension);\n                    if (mimeType != \"\")\n                        this->add_header(\"Content-Type\", mimeType);\n                    else\n                        this->add_header(\"content-Type\", \"text/plain\");\n                }\n            }\n            else\n            {\n                code = 404;\n                this->end();\n            }\n        }",
        "func": "void set_static_file_info(std::string path)\n        {\n            path = utility::sanitize_filename(path); //TODO create a no_copy function instead\n            file_info.path = path;\n            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n#ifdef CROW_ENABLE_COMPRESSION\n            compressed = false;\n#endif\n            if (file_info.statResult == 0)\n            {\n                std::size_t last_dot = path.find_last_of(\".\");\n                std::string extension = path.substr(last_dot + 1);\n                std::string mimeType = \"\";\n                code = 200;\n                this->add_header(\"Content-length\", std::to_string(file_info.statbuf.st_size));\n\n                if (extension != \"\")\n                {\n                    mimeType = mime_types.at(extension);\n                    if (mimeType != \"\")\n                        this->add_header(\"Content-Type\", mimeType);\n                    else\n                        this->add_header(\"content-Type\", \"text/plain\");\n                }\n            }\n            else\n            {\n                code = 404;\n                this->end();\n            }\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n void set_static_file_info(std::string path)\n         {\n+            path = utility::sanitize_filename(path); //TODO create a no_copy function instead\n             file_info.path = path;\n             file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n #ifdef CROW_ENABLE_COMPRESSION",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            path = utility::sanitize_filename(path); //TODO create a no_copy function instead"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/load",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a",
        "commit_title": "Fixed another vulnerability in mustache file loading",
        "commit_text": "and made the file sanitizer a copy-less function",
        "func_before": "inline template_t load(const std::string& filename)\n        {\n            return compile(detail::get_loader_ref()(filename));\n        }",
        "func": "inline template_t load(const std::string& filename)\n        {\n            std::string filename_sanitized(filename);\n            utility::sanitize_filename(filename_sanitized);\n            return compile(detail::get_loader_ref()(filename_sanitized));\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,6 @@\n inline template_t load(const std::string& filename)\n         {\n-            return compile(detail::get_loader_ref()(filename));\n+            std::string filename_sanitized(filename);\n+            utility::sanitize_filename(filename_sanitized);\n+            return compile(detail::get_loader_ref()(filename_sanitized));\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "            return compile(detail::get_loader_ref()(filename));"
            ],
            "added_lines": [
                "            std::string filename_sanitized(filename);",
                "            utility::sanitize_filename(filename_sanitized);",
                "            return compile(detail::get_loader_ref()(filename_sanitized));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/sanitize_filename",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a",
        "commit_title": "Fixed another vulnerability in mustache file loading",
        "commit_text": "and made the file sanitizer a copy-less function",
        "func_before": "inline std::string sanitize_filename(std::string data, char replacement = '_')\n        {\n            unsigned char i = 0, length_limit;\n\n            length_limit = data.length() < 255 ? data.length() : 255;\n            data = data.substr(0, length_limit);\n\n            for (; i < length_limit; i++)\n            {\n                switch (data[i])\n                {\n                    case '/':\n                    case '?':\n                    case '<':\n                    case '>':\n                    case '\\\\':\n                    case ':':\n                    case '*':\n                    case '|':\n                    case '\\\"':\n\n                    case 0x00:\n                    case 0x01:\n                    case 0x02:\n                    case 0x03:\n                    case 0x04:\n                    case 0x05:\n                    case 0x06:\n                    case 0x07:\n                    case 0x08:\n                    case 0x09:\n                    case 0x0a:\n                    case 0x0b:\n                    case 0x0c:\n                    case 0x0d:\n                    case 0x0e:\n                    case 0x0f:\n                    case 0x10:\n                    case 0x11:\n                    case 0x12:\n                    case 0x13:\n                    case 0x14:\n                    case 0x15:\n                    case 0x16:\n                    case 0x17:\n                    case 0x18:\n                    case 0x19:\n                    case 0x1a:\n                    case 0x1b:\n                    case 0x1c:\n                    case 0x1d:\n                    case 0x1e:\n                    case 0x1f:\n\n                    case 0x80:\n                    case 0x81:\n                    case 0x82:\n                    case 0x83:\n                    case 0x84:\n                    case 0x85:\n                    case 0x86:\n                    case 0x87:\n                    case 0x88:\n                    case 0x89:\n                    case 0x8a:\n                    case 0x8b:\n                    case 0x8c:\n                    case 0x8d:\n                    case 0x8e:\n                    case 0x8f:\n                    case 0x90:\n                    case 0x91:\n                    case 0x92:\n                    case 0x93:\n                    case 0x94:\n                    case 0x95:\n                    case 0x96:\n                    case 0x97:\n                    case 0x98:\n                    case 0x99:\n                    case 0x9a:\n                    case 0x9b:\n                    case 0x9c:\n                    case 0x9d:\n                    case 0x9e:\n                    case 0x9f:\n\n                        data[i] = replacement;\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n            std::string str_replacement(1, replacement);\n\n            boost::ireplace_all(data, \"..\", str_replacement);\n\n            boost::ireplace_all(data, \"CON\", str_replacement);\n            boost::ireplace_all(data, \"PRN\", str_replacement);\n            boost::ireplace_all(data, \"AUX\", str_replacement);\n            boost::ireplace_all(data, \"NUL\", str_replacement);\n            boost::ireplace_all(data, \"COM1\", str_replacement);\n            boost::ireplace_all(data, \"COM2\", str_replacement);\n            boost::ireplace_all(data, \"COM3\", str_replacement);\n            boost::ireplace_all(data, \"COM4\", str_replacement);\n            boost::ireplace_all(data, \"COM5\", str_replacement);\n            boost::ireplace_all(data, \"COM6\", str_replacement);\n            boost::ireplace_all(data, \"COM7\", str_replacement);\n            boost::ireplace_all(data, \"COM8\", str_replacement);\n            boost::ireplace_all(data, \"COM9\", str_replacement);\n            boost::ireplace_all(data, \"LPT1\", str_replacement);\n            boost::ireplace_all(data, \"LPT2\", str_replacement);\n            boost::ireplace_all(data, \"LPT3\", str_replacement);\n            boost::ireplace_all(data, \"LPT4\", str_replacement);\n            boost::ireplace_all(data, \"LPT5\", str_replacement);\n            boost::ireplace_all(data, \"LPT6\", str_replacement);\n            boost::ireplace_all(data, \"LPT7\", str_replacement);\n            boost::ireplace_all(data, \"LPT8\", str_replacement);\n            boost::ireplace_all(data, \"LPT9\", str_replacement);\n\n            return data;\n        }",
        "func": "inline static void sanitize_filename(std::string& data, char replacement = '_')\n        {\n            unsigned char i = 0, length_limit;\n\n            length_limit = data.length() < 255 ? data.length() : 255;\n            data = data.substr(0, length_limit);\n\n            for (; i < length_limit; i++)\n            {\n                switch ((unsigned char)data[i])\n                {\n                    // WARNING While I can't see how using '\\' or '/' would cause a problem, it still warrants an investigation\n                    //case '/':\n                    case '?':\n                    case '<':\n                    case '>':\n                    //case '\\\\':\n                    case ':':\n                    case '*':\n                    case '|':\n                    case '\\\"':\n\n                    case 0x00:\n                    case 0x01:\n                    case 0x02:\n                    case 0x03:\n                    case 0x04:\n                    case 0x05:\n                    case 0x06:\n                    case 0x07:\n                    case 0x08:\n                    case 0x09:\n                    case 0x0a:\n                    case 0x0b:\n                    case 0x0c:\n                    case 0x0d:\n                    case 0x0e:\n                    case 0x0f:\n                    case 0x10:\n                    case 0x11:\n                    case 0x12:\n                    case 0x13:\n                    case 0x14:\n                    case 0x15:\n                    case 0x16:\n                    case 0x17:\n                    case 0x18:\n                    case 0x19:\n                    case 0x1a:\n                    case 0x1b:\n                    case 0x1c:\n                    case 0x1d:\n                    case 0x1e:\n                    case 0x1f:\n\n                    case 0x80:\n                    case 0x81:\n                    case 0x82:\n                    case 0x83:\n                    case 0x84:\n                    case 0x85:\n                    case 0x86:\n                    case 0x87:\n                    case 0x88:\n                    case 0x89:\n                    case 0x8a:\n                    case 0x8b:\n                    case 0x8c:\n                    case 0x8d:\n                    case 0x8e:\n                    case 0x8f:\n                    case 0x90:\n                    case 0x91:\n                    case 0x92:\n                    case 0x93:\n                    case 0x94:\n                    case 0x95:\n                    case 0x96:\n                    case 0x97:\n                    case 0x98:\n                    case 0x99:\n                    case 0x9a:\n                    case 0x9b:\n                    case 0x9c:\n                    case 0x9d:\n                    case 0x9e:\n                    case 0x9f:\n\n                        data[i] = replacement;\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n            std::string str_replacement(1, replacement);\n\n            boost::ireplace_all(data, \"..\", str_replacement);\n\n            boost::ireplace_all(data, \"CON\", str_replacement);\n            boost::ireplace_all(data, \"PRN\", str_replacement);\n            boost::ireplace_all(data, \"AUX\", str_replacement);\n            boost::ireplace_all(data, \"NUL\", str_replacement);\n            boost::ireplace_all(data, \"COM1\", str_replacement);\n            boost::ireplace_all(data, \"COM2\", str_replacement);\n            boost::ireplace_all(data, \"COM3\", str_replacement);\n            boost::ireplace_all(data, \"COM4\", str_replacement);\n            boost::ireplace_all(data, \"COM5\", str_replacement);\n            boost::ireplace_all(data, \"COM6\", str_replacement);\n            boost::ireplace_all(data, \"COM7\", str_replacement);\n            boost::ireplace_all(data, \"COM8\", str_replacement);\n            boost::ireplace_all(data, \"COM9\", str_replacement);\n            boost::ireplace_all(data, \"LPT1\", str_replacement);\n            boost::ireplace_all(data, \"LPT2\", str_replacement);\n            boost::ireplace_all(data, \"LPT3\", str_replacement);\n            boost::ireplace_all(data, \"LPT4\", str_replacement);\n            boost::ireplace_all(data, \"LPT5\", str_replacement);\n            boost::ireplace_all(data, \"LPT6\", str_replacement);\n            boost::ireplace_all(data, \"LPT7\", str_replacement);\n            boost::ireplace_all(data, \"LPT8\", str_replacement);\n            boost::ireplace_all(data, \"LPT9\", str_replacement);\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-inline std::string sanitize_filename(std::string data, char replacement = '_')\n+inline static void sanitize_filename(std::string& data, char replacement = '_')\n         {\n             unsigned char i = 0, length_limit;\n \n@@ -7,13 +7,14 @@\n \n             for (; i < length_limit; i++)\n             {\n-                switch (data[i])\n+                switch ((unsigned char)data[i])\n                 {\n-                    case '/':\n+                    // WARNING While I can't see how using '\\' or '/' would cause a problem, it still warrants an investigation\n+                    //case '/':\n                     case '?':\n                     case '<':\n                     case '>':\n-                    case '\\\\':\n+                    //case '\\\\':\n                     case ':':\n                     case '*':\n                     case '|':\n@@ -118,6 +119,4 @@\n             boost::ireplace_all(data, \"LPT7\", str_replacement);\n             boost::ireplace_all(data, \"LPT8\", str_replacement);\n             boost::ireplace_all(data, \"LPT9\", str_replacement);\n-\n-            return data;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "inline std::string sanitize_filename(std::string data, char replacement = '_')",
                "                switch (data[i])",
                "                    case '/':",
                "                    case '\\\\':",
                "",
                "            return data;"
            ],
            "added_lines": [
                "inline static void sanitize_filename(std::string& data, char replacement = '_')",
                "                switch ((unsigned char)data[i])",
                "                    // WARNING While I can't see how using '\\' or '/' would cause a problem, it still warrants an investigation",
                "                    //case '/':",
                "                    //case '\\\\':"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/set_static_file_info",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a",
        "commit_title": "Fixed another vulnerability in mustache file loading",
        "commit_text": "and made the file sanitizer a copy-less function",
        "func_before": "void set_static_file_info(std::string path)\n        {\n            path = utility::sanitize_filename(path); //TODO create a no_copy function instead\n            file_info.path = path;\n            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n#ifdef CROW_ENABLE_COMPRESSION\n            compressed = false;\n#endif\n            if (file_info.statResult == 0)\n            {\n                std::size_t last_dot = path.find_last_of(\".\");\n                std::string extension = path.substr(last_dot + 1);\n                std::string mimeType = \"\";\n                code = 200;\n                this->add_header(\"Content-length\", std::to_string(file_info.statbuf.st_size));\n\n                if (extension != \"\")\n                {\n                    mimeType = mime_types.at(extension);\n                    if (mimeType != \"\")\n                        this->add_header(\"Content-Type\", mimeType);\n                    else\n                        this->add_header(\"content-Type\", \"text/plain\");\n                }\n            }\n            else\n            {\n                code = 404;\n                this->end();\n            }\n        }",
        "func": "void set_static_file_info(std::string path)\n        {\n            utility::sanitize_filename(path);\n            file_info.path = path;\n            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n#ifdef CROW_ENABLE_COMPRESSION\n            compressed = false;\n#endif\n            if (file_info.statResult == 0)\n            {\n                std::size_t last_dot = path.find_last_of(\".\");\n                std::string extension = path.substr(last_dot + 1);\n                std::string mimeType = \"\";\n                code = 200;\n                this->add_header(\"Content-length\", std::to_string(file_info.statbuf.st_size));\n\n                if (extension != \"\")\n                {\n                    mimeType = mime_types.at(extension);\n                    if (mimeType != \"\")\n                        this->add_header(\"Content-Type\", mimeType);\n                    else\n                        this->add_header(\"content-Type\", \"text/plain\");\n                }\n            }\n            else\n            {\n                code = 404;\n                this->end();\n            }\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n void set_static_file_info(std::string path)\n         {\n-            path = utility::sanitize_filename(path); //TODO create a no_copy function instead\n+            utility::sanitize_filename(path);\n             file_info.path = path;\n             file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n #ifdef CROW_ENABLE_COMPRESSION",
        "diff_line_info": {
            "deleted_lines": [
                "            path = utility::sanitize_filename(path); //TODO create a no_copy function instead"
            ],
            "added_lines": [
                "            utility::sanitize_filename(path);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21682",
        "func_name": "flatpak/flatpak_context_merge",
        "description": "Flatpak is a Linux application sandboxing and distribution framework. A path traversal vulnerability affects versions of Flatpak prior to 1.12.3 and 1.10.6. flatpak-builder applies `finish-args` last in the build. At this point the build directory will have the full access that is specified in the manifest, so running `flatpak build` against it will gain those permissions. Normally this will not be done, so this is not problem. However, if `--mirror-screenshots-url` is specified, then flatpak-builder will launch `flatpak build --nofilesystem=host appstream-utils mirror-screenshots` after finalization, which can lead to issues even with the `--nofilesystem=host` protection. In normal use, the only issue is that these empty directories can be created wherever the user has write permissions. However, a malicious application could replace the `appstream-util` binary and potentially do something more hostile. This has been resolved in Flatpak 1.12.3 and 1.10.6 by changing the behaviour of `--nofilesystem=home` and `--nofilesystem=host`.",
        "git_url": "https://github.com/flatpak/flatpak/commit/445bddeee657fdc8d2a0a1f0de12975400d4fc1a",
        "commit_title": "Make --nofilesystem=host/home remove access to subdirs of those",
        "commit_text": " Previously --nofilesystem=host only removed specifically access to the `host` permissions, and not necessarily other filesystems (like `home` or `/some/path`). This isn't very useful to limit access because you don't know what other filesystems the app may have access too.  We change this to mean that `--nofilesystem=host` removes *all* filesystem access from the parent layer, and `--nofilesystem=home` removes all file access to the homedir and paths inside it.  The available layers are, in order:   * app permissions  * overrides  * commandline args  This allows you to start from scratch with the filesystem permissions in the overrides or the commandline. This is a small change in behaviour, but not a lot of things use --nofilesystem, and the ones that do probably expects this behaviour.",
        "func_before": "void\nflatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}",
        "func": "void\nflatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  gboolean no_home = FALSE;\n  gboolean no_host = FALSE;\n\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n\n  /* We first handle all negative home and host as they override other\n     keys than themselves from the parent */\n  if (g_hash_table_lookup_extended (other->filesystems,\n                                    \"host\",\n                                    NULL, &value))\n    {\n      FlatpakFilesystemMode host_mode = GPOINTER_TO_INT (value);\n      if (host_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n        no_host = TRUE;\n    }\n\n  if (g_hash_table_lookup_extended (other->filesystems,\n                                    \"home\",\n                                    NULL, &value))\n    {\n      FlatpakFilesystemMode home_mode = GPOINTER_TO_INT (value);\n      if (home_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n        no_home = TRUE;\n    }\n\n  if (no_host)\n    {\n      g_hash_table_remove_all (context->filesystems);\n    }\n  else if (no_home)\n    {\n      g_hash_table_iter_init (&iter, context->filesystems);\n      while (g_hash_table_iter_next (&iter, &key, &value))\n        {\n          if (flatpak_filesystem_key_in_home ((const char *)key))\n            g_hash_table_iter_remove (&iter);\n        }\n    }\n\n  /* Then set the new ones, which includes propagating the nohost and nohome ones. */\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n {\n   GHashTableIter iter;\n   gpointer key, value;\n+  gboolean no_home = FALSE;\n+  gboolean no_host = FALSE;\n \n   context->shares &= ~other->shares_valid;\n   context->shares |= other->shares;\n@@ -26,6 +28,41 @@\n   while (g_hash_table_iter_next (&iter, &key, &value))\n     g_hash_table_insert (context->persistent, g_strdup (key), value);\n \n+  /* We first handle all negative home and host as they override other\n+     keys than themselves from the parent */\n+  if (g_hash_table_lookup_extended (other->filesystems,\n+                                    \"host\",\n+                                    NULL, &value))\n+    {\n+      FlatpakFilesystemMode host_mode = GPOINTER_TO_INT (value);\n+      if (host_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n+        no_host = TRUE;\n+    }\n+\n+  if (g_hash_table_lookup_extended (other->filesystems,\n+                                    \"home\",\n+                                    NULL, &value))\n+    {\n+      FlatpakFilesystemMode home_mode = GPOINTER_TO_INT (value);\n+      if (home_mode == FLATPAK_FILESYSTEM_MODE_NONE)\n+        no_home = TRUE;\n+    }\n+\n+  if (no_host)\n+    {\n+      g_hash_table_remove_all (context->filesystems);\n+    }\n+  else if (no_home)\n+    {\n+      g_hash_table_iter_init (&iter, context->filesystems);\n+      while (g_hash_table_iter_next (&iter, &key, &value))\n+        {\n+          if (flatpak_filesystem_key_in_home ((const char *)key))\n+            g_hash_table_iter_remove (&iter);\n+        }\n+    }\n+\n+  /* Then set the new ones, which includes propagating the nohost and nohome ones. */\n   g_hash_table_iter_init (&iter, other->filesystems);\n   while (g_hash_table_iter_next (&iter, &key, &value))\n     g_hash_table_insert (context->filesystems, g_strdup (key), value);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  gboolean no_home = FALSE;",
                "  gboolean no_host = FALSE;",
                "  /* We first handle all negative home and host as they override other",
                "     keys than themselves from the parent */",
                "  if (g_hash_table_lookup_extended (other->filesystems,",
                "                                    \"host\",",
                "                                    NULL, &value))",
                "    {",
                "      FlatpakFilesystemMode host_mode = GPOINTER_TO_INT (value);",
                "      if (host_mode == FLATPAK_FILESYSTEM_MODE_NONE)",
                "        no_host = TRUE;",
                "    }",
                "",
                "  if (g_hash_table_lookup_extended (other->filesystems,",
                "                                    \"home\",",
                "                                    NULL, &value))",
                "    {",
                "      FlatpakFilesystemMode home_mode = GPOINTER_TO_INT (value);",
                "      if (home_mode == FLATPAK_FILESYSTEM_MODE_NONE)",
                "        no_home = TRUE;",
                "    }",
                "",
                "  if (no_host)",
                "    {",
                "      g_hash_table_remove_all (context->filesystems);",
                "    }",
                "  else if (no_home)",
                "    {",
                "      g_hash_table_iter_init (&iter, context->filesystems);",
                "      while (g_hash_table_iter_next (&iter, &key, &value))",
                "        {",
                "          if (flatpak_filesystem_key_in_home ((const char *)key))",
                "            g_hash_table_iter_remove (&iter);",
                "        }",
                "    }",
                "",
                "  /* Then set the new ones, which includes propagating the nohost and nohome ones. */"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-19858",
        "func_name": "plutinosoft/Platinum/PLT_HttpServer::ServeFile",
        "description": "Platinum Upnp SDK through 1.2.0 has a directory traversal vulnerability. The attack could remote attack victim by sending http://ip:port/../privacy.avi URL to compromise a victim's privacy.",
        "git_url": "https://github.com/plutinosoft/Platinum/commit/9a4ceaccb1585ec35c45fd8e2585538fff6a865e",
        "commit_title": "Fix vulnerability around urls crafter as http://host/../secret.foo (#24)",
        "commit_text": "",
        "func_before": "NPT_Result \nPLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        \n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        \n        if (timestamp >= file_info.m_ModificationTime) {\n            // it's a match\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    \n    // open file\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // set Last-Modified and Cache-Control headers\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n        //response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=1800\", true);\n    }\n    \n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}",
        "func": "NPT_Result \nPLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        \n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        \n        if (timestamp >= file_info.m_ModificationTime) {\n            // it's a match\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    \n    // open file\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // set Last-Modified and Cache-Control headers\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n        //response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=1800\", true);\n    }\n    \n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n     NPT_FileInfo             file_info;\n     \n     // prevent hackers from accessing files outside of our root\n-    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n+    if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n         NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n         return NPT_ERROR_NO_SUCH_ITEM;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||"
            ],
            "added_lines": [
                "    if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-49294",
        "func_name": "asterisk/action_getconfig",
        "description": "Asterisk is an open source private branch exchange and telephony toolkit. In Asterisk prior to versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, it is possible to read any arbitrary file even when the `live_dangerously` is not enabled. This allows arbitrary files to be read. Asterisk versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, contain a fix for this issue.",
        "git_url": "https://github.com/asterisk/asterisk/commit/424be345639d75c6cb7d0bd2da5f0f407dbd0bd5",
        "commit_title": "manager.c: Prevent path traversal with GetConfig.",
        "commit_text": " When using AMI GetConfig, it was possible to access files outside of the Asterisk configuration directory by using filenames with \"..\" and \"./\" even while live_dangerously was not enabled. This change resolves the full path and ensures we are still in the configuration directory before attempting to access the file.",
        "func_before": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
        "func": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tint ret = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tret = restrictedFile(fn);\n\tif (ret == 1) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t} else if (ret == -1) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n \tconst char *category_name;\n \tint catcount = 0;\n \tint lineno = 0;\n+\tint ret = 0;\n \tstruct ast_category *cur_category = NULL;\n \tstruct ast_variable *v;\n \tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n@@ -16,8 +17,12 @@\n \t\treturn 0;\n \t}\n \n-\tif (restrictedFile(fn)) {\n+\tret = restrictedFile(fn);\n+\tif (ret == 1) {\n \t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n+\t\treturn 0;\n+\t} else if (ret == -1) {\n+\t\tastman_send_error(s, m, \"Config file not found\");\n \t\treturn 0;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (restrictedFile(fn)) {"
            ],
            "added_lines": [
                "\tint ret = 0;",
                "\tret = restrictedFile(fn);",
                "\tif (ret == 1) {",
                "\t\treturn 0;",
                "\t} else if (ret == -1) {",
                "\t\tastman_send_error(s, m, \"Config file not found\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-49294",
        "func_name": "asterisk/restrictedFile",
        "description": "Asterisk is an open source private branch exchange and telephony toolkit. In Asterisk prior to versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, it is possible to read any arbitrary file even when the `live_dangerously` is not enabled. This allows arbitrary files to be read. Asterisk versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, contain a fix for this issue.",
        "git_url": "https://github.com/asterisk/asterisk/commit/424be345639d75c6cb7d0bd2da5f0f407dbd0bd5",
        "commit_title": "manager.c: Prevent path traversal with GetConfig.",
        "commit_text": " When using AMI GetConfig, it was possible to access files outside of the Asterisk configuration directory by using filenames with \"..\" and \"./\" even while live_dangerously was not enabled. This change resolves the full path and ensures we are still in the configuration directory before attempting to access the file.",
        "func_before": "static int restrictedFile(const char *filename)\n{\n\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&\n\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int restrictedFile(const char *filename)\n{\n\tchar *stripped_filename;\n\tRAII_VAR(char *, path, NULL, ast_free);\n\tRAII_VAR(char *, real_path, NULL, ast_free);\n\n\tif (live_dangerously) {\n\t\treturn 0;\n\t}\n\n\tstripped_filename = ast_strip(ast_strdupa(filename));\n\n\t/* If the file path starts with '/', don't prepend ast_config_AST_CONFIG_DIR */\n\tif (stripped_filename[0] == '/') {\n\t\treal_path = realpath(stripped_filename, NULL);\n\t} else {\n\t\tif (ast_asprintf(&path, \"%s/%s\", ast_config_AST_CONFIG_DIR, stripped_filename) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\treal_path = realpath(path, NULL);\n\t}\n\n\tif (!real_path) {\n\t\treturn -1;\n\t}\n\n\tif (!ast_begins_with(real_path, ast_config_AST_CONFIG_DIR)) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,32 @@\n static int restrictedFile(const char *filename)\n {\n-\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&\n-\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n+\tchar *stripped_filename;\n+\tRAII_VAR(char *, path, NULL, ast_free);\n+\tRAII_VAR(char *, real_path, NULL, ast_free);\n+\n+\tif (live_dangerously) {\n+\t\treturn 0;\n+\t}\n+\n+\tstripped_filename = ast_strip(ast_strdupa(filename));\n+\n+\t/* If the file path starts with '/', don't prepend ast_config_AST_CONFIG_DIR */\n+\tif (stripped_filename[0] == '/') {\n+\t\treal_path = realpath(stripped_filename, NULL);\n+\t} else {\n+\t\tif (ast_asprintf(&path, \"%s/%s\", ast_config_AST_CONFIG_DIR, stripped_filename) == -1) {\n+\t\t\treturn -1;\n+\t\t}\n+\t\treal_path = realpath(path, NULL);\n+\t}\n+\n+\tif (!real_path) {\n+\t\treturn -1;\n+\t}\n+\n+\tif (!ast_begins_with(real_path, ast_config_AST_CONFIG_DIR)) {\n \t\treturn 1;\n \t}\n+\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&",
                "\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {"
            ],
            "added_lines": [
                "\tchar *stripped_filename;",
                "\tRAII_VAR(char *, path, NULL, ast_free);",
                "\tRAII_VAR(char *, real_path, NULL, ast_free);",
                "",
                "\tif (live_dangerously) {",
                "\t\treturn 0;",
                "\t}",
                "",
                "\tstripped_filename = ast_strip(ast_strdupa(filename));",
                "",
                "\t/* If the file path starts with '/', don't prepend ast_config_AST_CONFIG_DIR */",
                "\tif (stripped_filename[0] == '/') {",
                "\t\treal_path = realpath(stripped_filename, NULL);",
                "\t} else {",
                "\t\tif (ast_asprintf(&path, \"%s/%s\", ast_config_AST_CONFIG_DIR, stripped_filename) == -1) {",
                "\t\t\treturn -1;",
                "\t\t}",
                "\t\treal_path = realpath(path, NULL);",
                "\t}",
                "",
                "\tif (!real_path) {",
                "\t\treturn -1;",
                "\t}",
                "",
                "\tif (!ast_begins_with(real_path, ast_config_AST_CONFIG_DIR)) {",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-50254",
        "func_name": "linuxdeepin/deepin-reader/deepin_reader::DocumentFactory::getDocument",
        "description": "Deepin Linux's default document reader `deepin-reader` software suffers from a serious vulnerability in versions prior to 6.0.7 due to a design flaw that leads to remote command execution via crafted docx document. This is a file overwrite vulnerability. Remote code execution (RCE) can be achieved by overwriting files like .bash_rc, .bash_login, etc. RCE will be triggered when the user opens the terminal. Version 6.0.7 contains a patch for the issue.",
        "git_url": "https://github.com/linuxdeepin/deepin-reader/commit/c192fd20a2fe4003e0581c3164489a89e06420c6",
        "commit_title": "fix: deal with docx document format",
        "commit_text": " deal with docx document format  Bug: https://pms.uniontech.com/bug-view-232871.html Log: deal with docx document format",
        "func_before": "deepin_reader::Document *deepin_reader::DocumentFactory::getDocument(const int &fileType,\n                                                                     const QString &filePath,\n                                                                     const QString &convertedFileDir,\n                                                                     const QString &password,\n                                                                     QProcess **pprocess,\n                                                                     deepin_reader::Document::Error &error)\n{\n    deepin_reader::Document *document = nullptr;\n\n    qDebug() << \": \" << filePath;\n    if (Dr::PDF == fileType) {\n        qDebug() << \": PDF\";\n        document = deepin_reader::PDFDocument::loadDocument(filePath, password, error);\n    } else if (Dr::DJVU == fileType) {\n        qDebug() << \": DJVU\";\n        document = deepin_reader::DjVuDocument::loadDocument(filePath, error);\n    } else if (Dr::DOCX == fileType) {\n        qDebug() << \": DOCX\";\n        if (nullptr == pprocess) {\n            error = deepin_reader::Document::ConvertFailed;\n            return nullptr;\n        }\n        QString targetDoc = convertedFileDir + \"/temp.docx\";\n        QString tmpHtmlFilePath = convertedFileDir + \"/word/temp.html\";\n        QString realFilePath = convertedFileDir + \"/temp.pdf\";\n\n        QFile file(filePath);\n        if (!file.copy(targetDoc)) {\n            qInfo() << QString(\"copy %1 failed.\").arg(filePath);\n            error = deepin_reader::Document::ConvertFailed;\n            return nullptr;\n        }\n\n        //\n        QProcess decompressor;\n        *pprocess = &decompressor;\n        decompressor.setWorkingDirectory(convertedFileDir);\n        qDebug() << \"...\" << targetDoc;\n        QString unzipCommand = \"unzip \" + targetDoc;\n        qDebug() << \": \" << unzipCommand;\n        decompressor.start(unzipCommand);\n        if (!decompressor.waitForStarted()) {\n            qInfo() << \"start unzip failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        if (!decompressor.waitForFinished()) {\n            qInfo() << \"unzip failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        if (!QDir(convertedFileDir + \"/word\").exists()) {\n            qInfo() << \"unzip failed! \" << (convertedFileDir + \"/word\") << \"is not exists!\";\n            error = deepin_reader::Document::ConvertFailed;\n            if (!(QProcess::CrashExit == decompressor.exitStatus() && 9 == decompressor.exitCode())) {\n                *pprocess = nullptr;\n            }\n            return nullptr;\n        }\n        qDebug() << \"\";\n\n        // docx -> html\n        QProcess converter;\n        *pprocess = &converter;\n        converter.setWorkingDirectory(convertedFileDir + \"/word\");\n        qDebug() << \"docxhtml...\" << tmpHtmlFilePath;\n        QString pandocCommand = \"pandoc \" +  targetDoc + \" -o \" + tmpHtmlFilePath;\n        qDebug() << \": \" << pandocCommand;\n        converter.start(pandocCommand);\n        if (!converter.waitForStarted()) {\n            qInfo() << \"start pandoc failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        if (!converter.waitForFinished()) {\n            qInfo() << \"pandoc failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        QFile tmpHtmlFile(tmpHtmlFilePath);\n        if (!tmpHtmlFile.exists()) {\n            qInfo() <<  \"pandoc failed! \" << tmpHtmlFilePath << \" doesn't exist\";\n            error = deepin_reader::Document::ConvertFailed;\n            // docsheet*pprocess\n            if (!(QProcess::CrashExit == converter.exitStatus() && 9 == converter.exitCode())) {\n                *pprocess = nullptr;\n            }\n            return nullptr;\n        }\n        qDebug() << \"docxhtml\";\n\n        // html -> pdf\n        QProcess converter2;\n        *pprocess = &converter2;\n        converter2.setWorkingDirectory(convertedFileDir + \"/word\");\n        qDebug() << \"htmlpdf...\" << realFilePath;\n        QString htmltopdfCommand = \"/usr/lib/deepin-reader/htmltopdf \" +  tmpHtmlFilePath + \" \" + realFilePath;\n        qDebug() << \": \" << htmltopdfCommand;\n        converter2.start(htmltopdfCommand);\n        if (!converter2.waitForStarted()) {\n            qInfo() << \"start htmltopdf failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        if (!converter2.waitForFinished()) {\n            qInfo() << \"htmltopdf failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n\n        QFile realFile(realFilePath);\n        if (!realFile.exists()) {\n            qInfo() <<  \"htmltopdf failed! \" << realFilePath << \" doesn't exist\";\n            error = deepin_reader::Document::ConvertFailed;\n            if (!(QProcess::CrashExit == converter.exitStatus() && 9 == converter.exitCode())) {\n                *pprocess = nullptr;\n            }\n            return nullptr;\n        }\n        qDebug() << \"htmlpdf\";\n\n        *pprocess = nullptr;\n        document = deepin_reader::PDFDocument::loadDocument(realFilePath, password, error);\n    }\n\n    return document;\n}",
        "func": "deepin_reader::Document *deepin_reader::DocumentFactory::getDocument(const int &fileType,\n                                                                     const QString &filePath,\n                                                                     const QString &convertedFileDir,\n                                                                     const QString &password,\n                                                                     QProcess **pprocess,\n                                                                     deepin_reader::Document::Error &error)\n{\n    deepin_reader::Document *document = nullptr;\n\n    qDebug() << \": \" << filePath;\n    if (Dr::PDF == fileType) {\n        qDebug() << \": PDF\";\n        document = deepin_reader::PDFDocument::loadDocument(filePath, password, error);\n    } else if (Dr::DJVU == fileType) {\n        qDebug() << \": DJVU\";\n        document = deepin_reader::DjVuDocument::loadDocument(filePath, error);\n    } else if (Dr::DOCX == fileType) {\n        qDebug() << \": DOCX\";\n        if (nullptr == pprocess) {\n            error = deepin_reader::Document::ConvertFailed;\n            return nullptr;\n        }\n        QString targetDoc = convertedFileDir + \"/temp.docx\";\n        QString tmpHtmlFilePath = convertedFileDir + \"/word/temp.html\";\n        QString realFilePath = convertedFileDir + \"/temp.pdf\";\n\n        QFile file(filePath);\n        if (!file.copy(targetDoc)) {\n            qInfo() << QString(\"copy %1 failed.\").arg(filePath);\n            error = deepin_reader::Document::ConvertFailed;\n            return nullptr;\n        }\n\n        //\n        QProcess decompressor;\n        *pprocess = &decompressor;\n        decompressor.setWorkingDirectory(convertedFileDir);\n        qDebug() << \"...\" << targetDoc;\n        QString unzipCommand = \"unzip \" + targetDoc;\n        qDebug() << \": \" << unzipCommand;\n        decompressor.start(unzipCommand);\n        if (!decompressor.waitForStarted()) {\n            qInfo() << \"start unzip failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        if (!decompressor.waitForFinished()) {\n            qInfo() << \"unzip failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        if (!QDir(convertedFileDir + \"/word\").exists()) {\n            qInfo() << \"unzip failed! \" << (convertedFileDir + \"/word\") << \"is not exists!\";\n            error = deepin_reader::Document::ConvertFailed;\n            if (!(QProcess::CrashExit == decompressor.exitStatus() && 9 == decompressor.exitCode())) {\n                *pprocess = nullptr;\n            }\n            return nullptr;\n        }\n        qDebug() << \"\";\n        QTemporaryFile tmpFile(convertedFileDir + \"/word/\" + QCoreApplication::applicationName() + \"_XXXXXX.html\");\n        if( tmpFile.open()) { //fix 232871\n             tmpHtmlFilePath = tmpFile.fileName(); // returns the unique file name\n         }\n        // docx -> html\n        QProcess converter;\n        *pprocess = &converter;\n        converter.setWorkingDirectory(convertedFileDir + \"/word\");\n        qDebug() << \"docxhtml...\" << tmpHtmlFilePath;\n        QString pandocCommand = \"pandoc \" +  targetDoc + \" -o \" + tmpHtmlFilePath;\n        qDebug() << \": \" << pandocCommand;\n        converter.start(pandocCommand);\n        if (!converter.waitForStarted()) {\n            qInfo() << \"start pandoc failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        if (!converter.waitForFinished()) {\n            qInfo() << \"pandoc failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        QFile tmpHtmlFile(tmpHtmlFilePath);\n        if (!tmpHtmlFile.exists()) {\n            qInfo() <<  \"pandoc failed! \" << tmpHtmlFilePath << \" doesn't exist\";\n            error = deepin_reader::Document::ConvertFailed;\n            // docsheet*pprocess\n            if (!(QProcess::CrashExit == converter.exitStatus() && 9 == converter.exitCode())) {\n                *pprocess = nullptr;\n            }\n            return nullptr;\n        }\n        qDebug() << \"docxhtml\";\n\n        // html -> pdf\n        QProcess converter2;\n        *pprocess = &converter2;\n        converter2.setWorkingDirectory(convertedFileDir + \"/word\");\n        qDebug() << \"htmlpdf...\" << realFilePath;\n        QString htmltopdfCommand = \"/usr/lib/deepin-reader/htmltopdf \" +  tmpHtmlFilePath + \" \" + realFilePath;\n        qDebug() << \": \" << htmltopdfCommand;\n        converter2.start(htmltopdfCommand);\n        if (!converter2.waitForStarted()) {\n            qInfo() << \"start htmltopdf failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n        if (!converter2.waitForFinished()) {\n            qInfo() << \"htmltopdf failed\";\n            error = deepin_reader::Document::ConvertFailed;\n            *pprocess = nullptr;\n            return nullptr;\n        }\n\n        QFile realFile(realFilePath);\n        if (!realFile.exists()) {\n            qInfo() <<  \"htmltopdf failed! \" << realFilePath << \" doesn't exist\";\n            error = deepin_reader::Document::ConvertFailed;\n            if (!(QProcess::CrashExit == converter.exitStatus() && 9 == converter.exitCode())) {\n                *pprocess = nullptr;\n            }\n            return nullptr;\n        }\n        qDebug() << \"htmlpdf\";\n\n        *pprocess = nullptr;\n        document = deepin_reader::PDFDocument::loadDocument(realFilePath, password, error);\n    }\n\n    return document;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,7 +60,10 @@\n             return nullptr;\n         }\n         qDebug() << \"\";\n-\n+        QTemporaryFile tmpFile(convertedFileDir + \"/word/\" + QCoreApplication::applicationName() + \"_XXXXXX.html\");\n+        if( tmpFile.open()) { //fix 232871\n+             tmpHtmlFilePath = tmpFile.fileName(); // returns the unique file name\n+         }\n         // docx -> html\n         QProcess converter;\n         *pprocess = &converter;",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "        QTemporaryFile tmpFile(convertedFileDir + \"/word/\" + QCoreApplication::applicationName() + \"_XXXXXX.html\");",
                "        if( tmpFile.open()) { //fix 232871",
                "             tmpHtmlFilePath = tmpFile.fileName(); // returns the unique file name",
                "         }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-50255",
        "func_name": "linuxdeepin/deepin-compressor/LibzipPlugin::extractEntry",
        "description": "Deepin-Compressor is the default archive manager of Deepin Linux OS. Prior to 5.12.21, there's a path traversal vulnerability in deepin-compressor that can be exploited to achieve Remote Command Execution on the target system upon opening crafted archives. Users are advised to update to version 5.12.21 which addresses the issue. There are no known workarounds for this vulnerability.\n",
        "git_url": "https://github.com/linuxdeepin/deepin-compressor/commit/82f668c78c133873f5094cfab6e4eabc0b70e4b6",
        "commit_title": "fix: Zip Path Traversal",
        "commit_text": " Zip Path Traversal  Bug: https://pms.uniontech.com/bug-view-232873.html  Log: Zip Path Traversal",
        "func_before": "ErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)\n{\n    zip_stat_t statBuffer;\n    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {\n        return ET_FileReadError;\n    }\n\n    strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // \n    if(strFileName.contains(QLatin1Char('\\\\')))\n        strFileName = strFileName.replace(QLatin1Char('\\\\'), QDir::separator());\n    QString strOriginName = strFileName;\n\n    // \n//    QStringList listPath = strFileName.split(QDir::separator());\n//    listPath.removeLast();\n//    for (int i = 0; i < listPath.count(); ++i) {\n//        if (NAME_MAX < QString(listPath[i]).toLocal8Bit().length()) {\n//            emit signalCurFileName(strFileName); // \n//            return ET_LongNameError;\n//        }\n//    }\n\n    QString strFilePath;\n    QString strTempFileName = strFileName;\n    int iIndex = strFileName.lastIndexOf(QDir::separator());\n\n    if (iIndex >= 0) {\n        strFilePath = strFileName.left(iIndex);   // bug114527 left\n        strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);\n    }\n\n    QString tempFilePathName;\n    if(!m_bDlnfs) {\n        QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);\n        if(sDir.length() > 0) {\n           strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;\n           if(strFileName.endsWith(QDir::separator())) {\n               strFileName = sDir;\n           } else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {\n               strFileName = sDir + strTempFileName;\n           }\n           if(!m_mapLongDirName.isEmpty()) {\n               bHandleLongName = true;\n           }\n        }\n        if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {\n            QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);\n\n            // ,\n            tempFilePathName = strFilePath + QDir::separator() + strTemp;   // \n            if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {\n                return ET_LongNameError;\n            }\n            bHandleLongName = true;\n            QString sSuffix = QFileInfo(strTempFileName).completeSuffix();\n            if(10 < sSuffix.length()){\n                sSuffix = QFileInfo(strTempFileName).suffix();\n                if(10 < sSuffix.length()) {\n                    sSuffix = sSuffix.right(10);\n                }\n            }\n            strTempFileName = strTemp + QString(\"(%1)\").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + \".\" + sSuffix;\n\n            strFileName = strTempFileName;\n            if (iIndex >= 0) {\n                strFileName = strFilePath + QDir::separator() + strTempFileName;\n            }\n\n        }\n    }\n\n    // \n    if (!options.strDestination.isEmpty()) {\n        if(bHandleLongName) {\n            int nCnt = options.strDestination.count(QDir::separator());\n            int nIndex = 0;\n            for(int i = 0; i < nCnt; i++){\n                nIndex = strFileName.indexOf(QDir::separator(), nIndex);\n                nIndex++;\n            }\n            strFileName = strFileName.remove(0, nIndex);\n        } else {\n            strFileName = strFileName.remove(0, options.strDestination.size());\n        }\n    }\n\n\n    if (bHandleLongName) {\n        emit signalCurFileName(strOriginName); // \n    } else {\n        emit signalCurFileName(strFileName); // \n    }\n\n    bool bIsDirectory = strFileName.endsWith(QDir::separator());    // \n\n    // \n    if (QDir().exists(options.strTargetPath) == false)\n        QDir().mkpath(options.strTargetPath);\n\n    // \n    QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;\n\n    QFile file(strDestFileName);\n\n    // Store parent mtime.\n    QString parentDir;\n    if (strFileName.endsWith(QDir::separator())) {\n        QDir pDir = QFileInfo(strDestFileName).dir();\n        pDir.cdUp();\n        parentDir = pDir.path();\n    } else {\n        parentDir = QFileInfo(strDestFileName).path();\n    }\n    // For top-level items, don't restore parent dir mtime.\n    const bool restoreParentMtime = (parentDir != options.strTargetPath);\n\n    time_t parent_mtime;\n    if (restoreParentMtime) {\n        parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;\n    }\n\n    // \n    zip_uint8_t opsys;\n    zip_uint32_t attributes;\n    if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {\n        emit error((\"Failed to read metadata for entry: %1\"));\n    }\n\n    // \n    mode_t value = mode_t();\n    switch (opsys) {\n    case ZIP_OPSYS_UNIX:\n        value = attributes >> 16;\n        break;\n    default:    // TODO: non-UNIX.\n        break;\n    }\n    bool isLink = false;\n    if(S_ISLNK(value)) {\n        isLink = true;\n    }\n    QFileDevice::Permissions per = getPermissions(value);\n\n    if (bIsDirectory && !isLink) {     // \n        if (PATH_MAX < QString(strFileName).toLocal8Bit().length())\n            return ET_LongNameError;\n\n        QDir dir;\n        dir.mkpath(strDestFileName);\n\n        // \n        per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;\n    } else if(isLink) { //\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        char buf[READBYTES] = {0};\n        const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n        if (readBytes > 0) {\n            QString strBuf = QString(buf).toLocal8Bit();\n            if (QFile::link(strBuf, strDestFileName)) {\n                qInfo() << \"Symlink's created:\" << buf << strFileName;\n            } else {\n                qInfo() << \"Can't create symlink\" << buf << strFileName;\n            }\n        }\n        file.close();\n        zip_fclose(zipFile);\n    } else {        // \n\n        // \n        if (file.exists()) {\n            if (m_bSkipAll) {       // \n                m_mapLongName[tempFilePathName]++;   // \n                return ET_NoError;\n            } else {\n                if (!m_bOverwriteAll) {     // \n\n                    OverwriteQuery query(strDestFileName);\n\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit signalCancel();\n                        return ET_UserCancelOpertion;\n                    } else if (query.responseSkip()) {\n                        m_mapLongName[tempFilePathName]++;   // \n                        return ET_NoError;\n                    } else if (query.responseSkipAll()) {\n                        m_bSkipAll = true;\n                        m_mapLongName[tempFilePathName]++;   // \n                        return ET_NoError;\n                    }  else if (query.responseOverwriteAll()) {\n                        m_bOverwriteAll = true;\n                    }\n                }\n            }\n        }\n\n        if (bHandleLongName) {\n            m_setLongName << strFileName;\n        }\n\n        // \n        if (file.exists() && !file.isWritable()) {\n            file.remove();\n            file.setFileName(strDestFileName);\n            file.setPermissions(QFileDevice::WriteUser);\n        }\n\n        // \n        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)\n            QDir().mkpath(QFileInfo(strDestFileName).path());\n\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        // \n        if (nullptr == zipFile) {\n            int iErr = zip_error_code_zip(zip_get_error(archive));\n            if (ZIP_ER_WRONGPASSWD == iErr) {//\n\n                // \n                bool bCheckFinished = false;\n                int iCodecIndex = 0;\n                while (nullptr == zipFile && false == bCheckFinished) {\n                    if (m_listCodecs.length() == iCodecIndex) {\n                        bCheckFinished = true;\n                        if (file.exists()) {\n                            file.remove();\n                        }\n\n                        return ET_WrongPassword;\n                    } else {\n                        // 115645 10605.12.0.2zip\n                        zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());\n                        iCodecIndex++;\n                        zip_error_clear(archive);\n                        zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n                        iErr = zip_error_code_zip(zip_get_error(archive));\n                        if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {//\n                            bCheckFinished = true;\n                        }\n                    }\n                }\n            } else if (ZIP_ER_NOPASSWD == iErr) {   // \n                return ET_NeedPassword;\n            } else {\n                return ET_FileOpenError;\n            }\n        }\n\n        // \n        if (file.open(QIODevice::WriteOnly) == false) {\n            zip_fclose(zipFile);\n\n            QList<QString> entryNameList = strDestFileName.split('/');\n            foreach (auto &tmp, entryNameList) {\n                // \n                if (NAME_MAX < tmp.toLocal8Bit().length()) {\n                    return ET_LongNameError;\n                }\n            }\n\n            emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n            return ET_FileWriteError;\n        }\n\n        // \n        QDataStream out(&file);\n        zip_int64_t sum = 0;\n        char buf[READBYTES];\n        int writeSize = 0;\n        double dScale = 1;\n        // \n        if (!options.bExistList) {\n            dScale = double(statBuffer.comp_size) / statBuffer.size;\n        }\n        while (sum != zip_int64_t(statBuffer.size)) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                break;\n            }\n\n            if (m_bPause) { //\n                sleep(1);\n                continue;\n            }\n\n            const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n\n            if (readBytes < 0) {\n                file.close();\n                zip_fclose(zipFile);\n                emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                return ET_FileWriteError;\n            }\n\n            if (out.writeRawData(buf, int(readBytes)) != readBytes) {\n                file.close();\n                zip_fclose(zipFile);\n\n                if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {  // readBytes\n                    return ET_InsufficientDiskSpace;\n                } else {\n                    emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                    return ET_FileWriteError;\n                }\n            }\n\n            sum += readBytes;\n            writeSize += readBytes;\n\n            // \n            qExtractSize += readBytes * dScale;\n            emit signalprogress((double(qExtractSize)) * m_dScaleSize);\n        }\n\n        file.close();\n        zip_fclose(zipFile);\n    }\n    if(!isLink) {\n        // /\n        file.setPermissions(per);\n\n        // Set mtime for entry.\n        utimbuf times;\n        times.modtime = statBuffer.mtime;\n        utime(strDestFileName.toUtf8().constData(), &times);\n\n        if (restoreParentMtime) {\n            // Restore mtime for parent dir.\n            times.modtime = parent_mtime;\n            utime(parentDir.toUtf8().constData(), &times);\n        }\n    }\n    m_mapLongName[tempFilePathName]++;   // \n    return ET_NoError;\n}",
        "func": "ErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)\n{\n    zip_stat_t statBuffer;\n    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {\n        return ET_FileReadError;\n    }\n\n    strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // \n    //fix 232873\n    if(strFileName.indexOf(\"../\") != -1) {\n        qInfo() << \"skipped ../ path component(s) in \" << strFileName;\n        strFileName = strFileName.replace(\"../\", \"\");\n    }\n    if(strFileName.contains(QLatin1Char('\\\\')))\n        strFileName = strFileName.replace(QLatin1Char('\\\\'), QDir::separator());\n    QString strOriginName = strFileName;\n\n    // \n//    QStringList listPath = strFileName.split(QDir::separator());\n//    listPath.removeLast();\n//    for (int i = 0; i < listPath.count(); ++i) {\n//        if (NAME_MAX < QString(listPath[i]).toLocal8Bit().length()) {\n//            emit signalCurFileName(strFileName); // \n//            return ET_LongNameError;\n//        }\n//    }\n\n    QString strFilePath;\n    QString strTempFileName = strFileName;\n    int iIndex = strFileName.lastIndexOf(QDir::separator());\n\n    if (iIndex >= 0) {\n        strFilePath = strFileName.left(iIndex);   // bug114527 left\n        strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);\n    }\n\n    QString tempFilePathName;\n    if(!m_bDlnfs) {\n        QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);\n        if(sDir.length() > 0) {\n           strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;\n           if(strFileName.endsWith(QDir::separator())) {\n               strFileName = sDir;\n           } else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {\n               strFileName = sDir + strTempFileName;\n           }\n           if(!m_mapLongDirName.isEmpty()) {\n               bHandleLongName = true;\n           }\n        }\n        if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {\n            QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);\n\n            // ,\n            tempFilePathName = strFilePath + QDir::separator() + strTemp;   // \n            if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {\n                return ET_LongNameError;\n            }\n            bHandleLongName = true;\n            QString sSuffix = QFileInfo(strTempFileName).completeSuffix();\n            if(10 < sSuffix.length()){\n                sSuffix = QFileInfo(strTempFileName).suffix();\n                if(10 < sSuffix.length()) {\n                    sSuffix = sSuffix.right(10);\n                }\n            }\n            strTempFileName = strTemp + QString(\"(%1)\").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + \".\" + sSuffix;\n\n            strFileName = strTempFileName;\n            if (iIndex >= 0) {\n                strFileName = strFilePath + QDir::separator() + strTempFileName;\n            }\n\n        }\n    }\n\n    // \n    if (!options.strDestination.isEmpty()) {\n        if(bHandleLongName) {\n            int nCnt = options.strDestination.count(QDir::separator());\n            int nIndex = 0;\n            for(int i = 0; i < nCnt; i++){\n                nIndex = strFileName.indexOf(QDir::separator(), nIndex);\n                nIndex++;\n            }\n            strFileName = strFileName.remove(0, nIndex);\n        } else {\n            strFileName = strFileName.remove(0, options.strDestination.size());\n        }\n    }\n\n\n    if (bHandleLongName) {\n        emit signalCurFileName(strOriginName); // \n    } else {\n        emit signalCurFileName(strFileName); // \n    }\n\n    bool bIsDirectory = strFileName.endsWith(QDir::separator());    // \n\n    // \n    if (QDir().exists(options.strTargetPath) == false)\n        QDir().mkpath(options.strTargetPath);\n\n    // \n    QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;\n\n    QFile file(strDestFileName);\n\n    // Store parent mtime.\n    QString parentDir;\n    if (strFileName.endsWith(QDir::separator())) {\n        QDir pDir = QFileInfo(strDestFileName).dir();\n        pDir.cdUp();\n        parentDir = pDir.path();\n    } else {\n        parentDir = QFileInfo(strDestFileName).path();\n    }\n    // For top-level items, don't restore parent dir mtime.\n    const bool restoreParentMtime = (parentDir != options.strTargetPath);\n\n    time_t parent_mtime;\n    if (restoreParentMtime) {\n        parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;\n    }\n\n    // \n    zip_uint8_t opsys;\n    zip_uint32_t attributes;\n    if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {\n        emit error((\"Failed to read metadata for entry: %1\"));\n    }\n\n    // \n    mode_t value = mode_t();\n    switch (opsys) {\n    case ZIP_OPSYS_UNIX:\n        value = attributes >> 16;\n        break;\n    default:    // TODO: non-UNIX.\n        break;\n    }\n    bool isLink = false;\n    if(S_ISLNK(value)) {\n        isLink = true;\n    }\n    QFileDevice::Permissions per = getPermissions(value);\n\n    if (bIsDirectory && !isLink) {     // \n        if (PATH_MAX < QString(strFileName).toLocal8Bit().length())\n            return ET_LongNameError;\n\n        QDir dir;\n        dir.mkpath(strDestFileName);\n\n        // \n        per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;\n    } else if(isLink) { //\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        char buf[READBYTES] = {0};\n        const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n        if (readBytes > 0) {\n            QString strBuf = QString(buf).toLocal8Bit();\n            if (QFile::link(strBuf, strDestFileName)) {\n                qInfo() << \"Symlink's created:\" << buf << strFileName;\n            } else {\n                qInfo() << \"Can't create symlink\" << buf << strFileName;\n            }\n        }\n        file.close();\n        zip_fclose(zipFile);\n    } else {        // \n\n        // \n        if (file.exists()) {\n            if (m_bSkipAll) {       // \n                m_mapLongName[tempFilePathName]++;   // \n                return ET_NoError;\n            } else {\n                if (!m_bOverwriteAll) {     // \n\n                    OverwriteQuery query(strDestFileName);\n\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit signalCancel();\n                        return ET_UserCancelOpertion;\n                    } else if (query.responseSkip()) {\n                        m_mapLongName[tempFilePathName]++;   // \n                        return ET_NoError;\n                    } else if (query.responseSkipAll()) {\n                        m_bSkipAll = true;\n                        m_mapLongName[tempFilePathName]++;   // \n                        return ET_NoError;\n                    }  else if (query.responseOverwriteAll()) {\n                        m_bOverwriteAll = true;\n                    }\n                }\n            }\n        }\n\n        if (bHandleLongName) {\n            m_setLongName << strFileName;\n        }\n\n        // \n        if (file.exists() && !file.isWritable()) {\n            file.remove();\n            file.setFileName(strDestFileName);\n            file.setPermissions(QFileDevice::WriteUser);\n        }\n\n        // \n        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)\n            QDir().mkpath(QFileInfo(strDestFileName).path());\n\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        // \n        if (nullptr == zipFile) {\n            int iErr = zip_error_code_zip(zip_get_error(archive));\n            if (ZIP_ER_WRONGPASSWD == iErr) {//\n\n                // \n                bool bCheckFinished = false;\n                int iCodecIndex = 0;\n                while (nullptr == zipFile && false == bCheckFinished) {\n                    if (m_listCodecs.length() == iCodecIndex) {\n                        bCheckFinished = true;\n                        if (file.exists()) {\n                            file.remove();\n                        }\n\n                        return ET_WrongPassword;\n                    } else {\n                        // 115645 10605.12.0.2zip\n                        zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());\n                        iCodecIndex++;\n                        zip_error_clear(archive);\n                        zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n                        iErr = zip_error_code_zip(zip_get_error(archive));\n                        if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {//\n                            bCheckFinished = true;\n                        }\n                    }\n                }\n            } else if (ZIP_ER_NOPASSWD == iErr) {   // \n                return ET_NeedPassword;\n            } else {\n                return ET_FileOpenError;\n            }\n        }\n\n        // \n        if (file.open(QIODevice::WriteOnly) == false) {\n            zip_fclose(zipFile);\n\n            QList<QString> entryNameList = strDestFileName.split('/');\n            foreach (auto &tmp, entryNameList) {\n                // \n                if (NAME_MAX < tmp.toLocal8Bit().length()) {\n                    return ET_LongNameError;\n                }\n            }\n\n            emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n            return ET_FileWriteError;\n        }\n\n        // \n        QDataStream out(&file);\n        zip_int64_t sum = 0;\n        char buf[READBYTES];\n        int writeSize = 0;\n        double dScale = 1;\n        // \n        if (!options.bExistList) {\n            dScale = double(statBuffer.comp_size) / statBuffer.size;\n        }\n        while (sum != zip_int64_t(statBuffer.size)) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                break;\n            }\n\n            if (m_bPause) { //\n                sleep(1);\n                continue;\n            }\n\n            const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n\n            if (readBytes < 0) {\n                file.close();\n                zip_fclose(zipFile);\n                emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                return ET_FileWriteError;\n            }\n\n            if (out.writeRawData(buf, int(readBytes)) != readBytes) {\n                file.close();\n                zip_fclose(zipFile);\n\n                if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {  // readBytes\n                    return ET_InsufficientDiskSpace;\n                } else {\n                    emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                    return ET_FileWriteError;\n                }\n            }\n\n            sum += readBytes;\n            writeSize += readBytes;\n\n            // \n            qExtractSize += readBytes * dScale;\n            emit signalprogress((double(qExtractSize)) * m_dScaleSize);\n        }\n\n        file.close();\n        zip_fclose(zipFile);\n    }\n    if(!isLink) {\n        // /\n        file.setPermissions(per);\n\n        // Set mtime for entry.\n        utimbuf times;\n        times.modtime = statBuffer.mtime;\n        utime(strDestFileName.toUtf8().constData(), &times);\n\n        if (restoreParentMtime) {\n            // Restore mtime for parent dir.\n            times.modtime = parent_mtime;\n            utime(parentDir.toUtf8().constData(), &times);\n        }\n    }\n    m_mapLongName[tempFilePathName]++;   // \n    return ET_NoError;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,11 @@\n     }\n \n     strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // \n+    //fix 232873\n+    if(strFileName.indexOf(\"../\") != -1) {\n+        qInfo() << \"skipped ../ path component(s) in \" << strFileName;\n+        strFileName = strFileName.replace(\"../\", \"\");\n+    }\n     if(strFileName.contains(QLatin1Char('\\\\')))\n         strFileName = strFileName.replace(QLatin1Char('\\\\'), QDir::separator());\n     QString strOriginName = strFileName;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    //fix 232873",
                "    if(strFileName.indexOf(\"../\") != -1) {",
                "        qInfo() << \"skipped ../ path component(s) in \" << strFileName;",
                "        strFileName = strFileName.replace(\"../\", \"\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_tls_destroy",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "void FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  free(tls);\n}",
        "func": "void FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  trust_ary_free(&tls->trust);\n  free(tls);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,5 +7,6 @@\n   fio_tls_destroy_context(tls);\n   alpn_list_free(&tls->alpn);\n   cert_ary_free(&tls->sni);\n+  trust_ary_free(&tls->trust);\n   free(tls);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  trust_ary_free(&tls->trust);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fiobj_send_free",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}",
        "func": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (uintptr_t)(((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,6 @@\n                                                               FIOBJ o) {\n   fio_str_info_s s = fiobj_obj2cstr(o);\n   return fio_write2(uuid, .data.buffer = (void *)(o),\n-                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n+                    .offset = (uintptr_t)(((intptr_t)s.data) - ((intptr_t)(o))),\n                     .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),"
            ],
            "added_lines": [
                "                    .offset = (uintptr_t)(((intptr_t)s.data) - ((intptr_t)(o))),"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/http_sendfile2",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "int http_sendfile2(http_s *h, const char *prefix, size_t prefix_len,\n                   const char *encoded, size_t encoded_len) {\n  if (HTTP_INVALID_HANDLE(h))\n    return -1;\n  struct stat file_data = {.st_size = 0};\n  static uint64_t accept_enc_hash = 0;\n  if (!accept_enc_hash)\n    accept_enc_hash = fiobj_hash_string(\"accept-encoding\", 15);\n  static uint64_t range_hash = 0;\n  if (!range_hash)\n    range_hash = fiobj_hash_string(\"range\", 5);\n\n  /* create filename string */\n  FIOBJ filename = fiobj_str_tmp();\n  if (prefix && prefix_len) {\n    /* start with prefix path */\n    if (encoded && prefix[prefix_len - 1] == '/' && encoded[0] == '/')\n      --prefix_len;\n    fiobj_str_capa_assert(filename, prefix_len + encoded_len + 4);\n    fiobj_str_write(filename, prefix, prefix_len);\n  }\n  {\n    /* decode filename in cases where it's URL encoded */\n    fio_str_info_s tmp = fiobj_obj2cstr(filename);\n    if (encoded) {\n      char *pos = (char *)encoded;\n      const char *end = encoded + encoded_len;\n      while (pos < end) {\n        /* test for path manipulations while decoding */\n        if (*pos == '/' && (pos[1] == '/' ||\n                            (((uintptr_t)end - (uintptr_t)pos >= 4) &&\n                             pos[1] == '.' && pos[2] == '.' && pos[3] == '/')))\n          return -1;\n        if (*pos == '%') {\n          // decode hex value\n          // this is a percent encoded value.\n          if (hex2byte((uint8_t *)tmp.data + tmp.len, (uint8_t *)pos + 1))\n            return -1;\n          tmp.len++;\n          pos += 3;\n        } else\n          tmp.data[tmp.len++] = *(pos++);\n      }\n      tmp.data[tmp.len] = 0;\n      fiobj_str_resize(filename, tmp.len);\n    }\n    if (tmp.data[tmp.len - 1] == '/')\n      fiobj_str_write(filename, \"index.html\", 10);\n  }\n  /* test for file existance  */\n\n  int file = -1;\n  uint8_t is_gz = 0;\n\n  fio_str_info_s s = fiobj_obj2cstr(filename);\n  {\n    FIOBJ tmp = fiobj_hash_get2(h->headers, accept_enc_hash);\n    if (!tmp)\n      goto no_gzip_support;\n    fio_str_info_s ac_str = fiobj_obj2cstr(tmp);\n    if (!ac_str.data || !strstr(ac_str.data, \"gzip\"))\n      goto no_gzip_support;\n    if (s.data[s.len - 3] != '.' || s.data[s.len - 2] != 'g' ||\n        s.data[s.len - 1] != 'z') {\n      fiobj_str_write(filename, \".gz\", 3);\n      s = fiobj_obj2cstr(filename);\n      if (!stat(s.data, &file_data) &&\n          (S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode))) {\n        is_gz = 1;\n        goto found_file;\n      }\n      fiobj_str_resize(filename, s.len - 3);\n    }\n  }\nno_gzip_support:\n  if (stat(s.data, &file_data) ||\n      !(S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode)))\n    return -1;\nfound_file:\n  /* set last-modified */\n  {\n    FIOBJ tmp = fiobj_str_buf(32);\n    fiobj_str_resize(\n        tmp, http_time2str(fiobj_obj2cstr(tmp).data, file_data.st_mtime));\n    http_set_header(h, HTTP_HEADER_LAST_MODIFIED, tmp);\n  }\n  /* set cache-control */\n  http_set_header(h, HTTP_HEADER_CACHE_CONTROL, fiobj_dup(HTTP_HVALUE_MAX_AGE));\n  /* set & test etag */\n  uint64_t etag = (uint64_t)file_data.st_size;\n  etag ^= (uint64_t)file_data.st_mtime;\n  etag = fiobj_hash_string(&etag, sizeof(uint64_t));\n  FIOBJ etag_str = fiobj_str_buf(32);\n  fiobj_str_resize(etag_str,\n                   fio_base64_encode(fiobj_obj2cstr(etag_str).data,\n                                     (void *)&etag, sizeof(uint64_t)));\n  /* set */\n  http_set_header(h, HTTP_HEADER_ETAG, etag_str);\n  /* test */\n  {\n    static uint64_t none_match_hash = 0;\n    if (!none_match_hash)\n      none_match_hash = fiobj_hash_string(\"if-none-match\", 13);\n    FIOBJ tmp2 = fiobj_hash_get2(h->headers, none_match_hash);\n    if (tmp2 && fiobj_iseq(tmp2, etag_str)) {\n      h->status = 304;\n      http_finish(h);\n      return 0;\n    }\n  }\n  /* handle range requests */\n  int64_t offset = 0;\n  int64_t length = file_data.st_size;\n  {\n    static uint64_t ifrange_hash = 0;\n    if (!ifrange_hash)\n      ifrange_hash = fiobj_hash_string(\"if-range\", 8);\n    FIOBJ tmp = fiobj_hash_get2(h->headers, ifrange_hash);\n    if (tmp && fiobj_iseq(tmp, etag_str)) {\n      fiobj_hash_delete2(h->headers, range_hash);\n    } else {\n      tmp = fiobj_hash_get2(h->headers, range_hash);\n      if (tmp) {\n        /* range ahead... */\n        if (FIOBJ_TYPE_IS(tmp, FIOBJ_T_ARRAY))\n          tmp = fiobj_ary_index(tmp, 0);\n        fio_str_info_s range = fiobj_obj2cstr(tmp);\n        if (!range.data || memcmp(\"bytes=\", range.data, 6))\n          goto open_file;\n        char *pos = range.data + 6;\n        int64_t start_at = 0, end_at = 0;\n        start_at = fio_atol(&pos);\n        if (start_at >= file_data.st_size)\n          goto open_file;\n        if (start_at >= 0) {\n          pos++;\n          end_at = fio_atol(&pos);\n          if (end_at <= 0)\n            goto open_file;\n        }\n        /* we ignore multimple ranges, only responding with the first range. */\n        if (start_at < 0) {\n          if (0 - start_at < file_data.st_size) {\n            offset = file_data.st_size - start_at;\n            length = 0 - start_at;\n          }\n        } else if (end_at) {\n          offset = start_at;\n          length = end_at - start_at + 1;\n          if (length + start_at > file_data.st_size || length <= 0)\n            length = length - start_at;\n        } else {\n          offset = start_at;\n          length = length - start_at;\n        }\n        h->status = 206;\n\n        {\n          FIOBJ cranges = fiobj_str_buf(1);\n          fiobj_str_printf(cranges, \"bytes %lu-%lu/%lu\",\n                           (unsigned long)start_at,\n                           (unsigned long)(start_at + length - 1),\n                           (unsigned long)file_data.st_size);\n          http_set_header(h, HTTP_HEADER_CONTENT_RANGE, cranges);\n        }\n        http_set_header(h, HTTP_HEADER_ACCEPT_RANGES,\n                        fiobj_dup(HTTP_HVALUE_BYTES));\n      }\n    }\n  }\n  /* test for an OPTIONS request or invalid methods */\n  s = fiobj_obj2cstr(h->method);\n  switch (s.len) {\n  case 7:\n    if (!strncasecmp(\"options\", s.data, 7)) {\n      http_set_header2(h, (fio_str_info_s){.data = (char *)\"allow\", .len = 5},\n                       (fio_str_info_s){.data = (char *)\"GET, HEAD\", .len = 9});\n      h->status = 200;\n      http_finish(h);\n      return 0;\n    }\n    break;\n  case 3:\n    if (!strncasecmp(\"get\", s.data, 3))\n      goto open_file;\n    break;\n  case 4:\n    if (!strncasecmp(\"head\", s.data, 4)) {\n      http_set_header(h, HTTP_HEADER_CONTENT_LENGTH, fiobj_num_new(length));\n      http_finish(h);\n      return 0;\n    }\n    break;\n  }\n  http_send_error(h, 403);\n  return 0;\nopen_file:\n  s = fiobj_obj2cstr(filename);\n  file = open(s.data, O_RDONLY);\n  if (file == -1) {\n    FIO_LOG_ERROR(\"(HTTP) couldn't open file %s!\\n\", s.data);\n    perror(\"     \");\n    http_send_error(h, 500);\n    return 0;\n  }\n  {\n    FIOBJ tmp = 0;\n    uintptr_t pos = 0;\n    if (is_gz) {\n      http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,\n                      fiobj_dup(HTTP_HVALUE_GZIP));\n\n      pos = s.len - 4;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos - 3);\n\n    } else {\n      pos = s.len - 1;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos);\n    }\n    if (tmp)\n      http_set_header(h, HTTP_HEADER_CONTENT_TYPE, tmp);\n  }\n  http_sendfile(h, file, length, offset);\n  return 0;\n}",
        "func": "int http_sendfile2(http_s *h, const char *prefix, size_t prefix_len,\n                   const char *encoded, size_t encoded_len) {\n  if (HTTP_INVALID_HANDLE(h))\n    return -1;\n  struct stat file_data = {.st_size = 0};\n  static uint64_t accept_enc_hash = 0;\n  if (!accept_enc_hash)\n    accept_enc_hash = fiobj_hash_string(\"accept-encoding\", 15);\n  static uint64_t range_hash = 0;\n  if (!range_hash)\n    range_hash = fiobj_hash_string(\"range\", 5);\n\n  /* create filename string */\n  FIOBJ filename = fiobj_str_tmp();\n  if (prefix && prefix_len) {\n    /* start with prefix path */\n    if (encoded && prefix[prefix_len - 1] == '/' && encoded[0] == '/')\n      --prefix_len;\n    fiobj_str_capa_assert(filename, prefix_len + encoded_len + 4);\n    fiobj_str_write(filename, prefix, prefix_len);\n  }\n  {\n    /* decode filename in cases where it's URL encoded */\n    fio_str_info_s tmp = fiobj_obj2cstr(filename);\n    if (encoded) {\n      char *pos = (char *)encoded;\n      const char *end = encoded + encoded_len;\n      while (pos < end) {\n        if (*pos == '%') {\n          // decode hex value (this is a percent encoded value).\n          if (hex2byte((uint8_t *)tmp.data + tmp.len, (uint8_t *)pos + 1))\n            return -1;\n          tmp.len++;\n          pos += 3;\n        } else\n          tmp.data[tmp.len++] = *(pos++);\n      }\n      tmp.data[tmp.len] = 0;\n      fiobj_str_resize(filename, tmp.len);\n      /* test for path manipulations after decoding */\n      if (http_test_encoded_path(tmp.data + prefix_len, tmp.len - prefix_len))\n        return -1;\n    }\n    if (tmp.data[tmp.len - 1] == '/')\n      fiobj_str_write(filename, \"index.html\", 10);\n  }\n  /* test for file existance  */\n\n  int file = -1;\n  uint8_t is_gz = 0;\n\n  fio_str_info_s s = fiobj_obj2cstr(filename);\n  {\n    FIOBJ tmp = fiobj_hash_get2(h->headers, accept_enc_hash);\n    if (!tmp)\n      goto no_gzip_support;\n    fio_str_info_s ac_str = fiobj_obj2cstr(tmp);\n    if (!ac_str.data || !strstr(ac_str.data, \"gzip\"))\n      goto no_gzip_support;\n    if (s.data[s.len - 3] != '.' || s.data[s.len - 2] != 'g' ||\n        s.data[s.len - 1] != 'z') {\n      fiobj_str_write(filename, \".gz\", 3);\n      s = fiobj_obj2cstr(filename);\n      if (!stat(s.data, &file_data) &&\n          (S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode))) {\n        is_gz = 1;\n        goto found_file;\n      }\n      fiobj_str_resize(filename, s.len - 3);\n    }\n  }\nno_gzip_support:\n  if (stat(s.data, &file_data) ||\n      !(S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode)))\n    return -1;\nfound_file:\n  /* set last-modified */\n  {\n    FIOBJ tmp = fiobj_str_buf(32);\n    fiobj_str_resize(\n        tmp, http_time2str(fiobj_obj2cstr(tmp).data, file_data.st_mtime));\n    http_set_header(h, HTTP_HEADER_LAST_MODIFIED, tmp);\n  }\n  /* set cache-control */\n  http_set_header(h, HTTP_HEADER_CACHE_CONTROL, fiobj_dup(HTTP_HVALUE_MAX_AGE));\n  /* set & test etag */\n  uint64_t etag = (uint64_t)file_data.st_size;\n  etag ^= (uint64_t)file_data.st_mtime;\n  etag = fiobj_hash_string(&etag, sizeof(uint64_t));\n  FIOBJ etag_str = fiobj_str_buf(32);\n  fiobj_str_resize(etag_str,\n                   fio_base64_encode(fiobj_obj2cstr(etag_str).data,\n                                     (void *)&etag, sizeof(uint64_t)));\n  /* set */\n  http_set_header(h, HTTP_HEADER_ETAG, etag_str);\n  /* test */\n  {\n    static uint64_t none_match_hash = 0;\n    if (!none_match_hash)\n      none_match_hash = fiobj_hash_string(\"if-none-match\", 13);\n    FIOBJ tmp2 = fiobj_hash_get2(h->headers, none_match_hash);\n    if (tmp2 && fiobj_iseq(tmp2, etag_str)) {\n      h->status = 304;\n      http_finish(h);\n      return 0;\n    }\n  }\n  /* handle range requests */\n  int64_t offset = 0;\n  int64_t length = file_data.st_size;\n  {\n    static uint64_t ifrange_hash = 0;\n    if (!ifrange_hash)\n      ifrange_hash = fiobj_hash_string(\"if-range\", 8);\n    FIOBJ tmp = fiobj_hash_get2(h->headers, ifrange_hash);\n    if (tmp && fiobj_iseq(tmp, etag_str)) {\n      fiobj_hash_delete2(h->headers, range_hash);\n    } else {\n      tmp = fiobj_hash_get2(h->headers, range_hash);\n      if (tmp) {\n        /* range ahead... */\n        if (FIOBJ_TYPE_IS(tmp, FIOBJ_T_ARRAY))\n          tmp = fiobj_ary_index(tmp, 0);\n        fio_str_info_s range = fiobj_obj2cstr(tmp);\n        if (!range.data || memcmp(\"bytes=\", range.data, 6))\n          goto open_file;\n        char *pos = range.data + 6;\n        int64_t start_at = 0, end_at = 0;\n        start_at = fio_atol(&pos);\n        if (start_at >= file_data.st_size)\n          goto open_file;\n        if (start_at >= 0) {\n          pos++;\n          end_at = fio_atol(&pos);\n          if (end_at <= 0)\n            goto open_file;\n        }\n        /* we ignore multimple ranges, only responding with the first range. */\n        if (start_at < 0) {\n          if (0 - start_at < file_data.st_size) {\n            offset = file_data.st_size - start_at;\n            length = 0 - start_at;\n          }\n        } else if (end_at) {\n          offset = start_at;\n          length = end_at - start_at + 1;\n          if (length + start_at > file_data.st_size || length <= 0)\n            length = length - start_at;\n        } else {\n          offset = start_at;\n          length = length - start_at;\n        }\n        h->status = 206;\n\n        {\n          FIOBJ cranges = fiobj_str_buf(1);\n          fiobj_str_printf(cranges, \"bytes %lu-%lu/%lu\",\n                           (unsigned long)start_at,\n                           (unsigned long)(start_at + length - 1),\n                           (unsigned long)file_data.st_size);\n          http_set_header(h, HTTP_HEADER_CONTENT_RANGE, cranges);\n        }\n        http_set_header(h, HTTP_HEADER_ACCEPT_RANGES,\n                        fiobj_dup(HTTP_HVALUE_BYTES));\n      }\n    }\n  }\n  /* test for an OPTIONS request or invalid methods */\n  s = fiobj_obj2cstr(h->method);\n  switch (s.len) {\n  case 7:\n    if (!strncasecmp(\"options\", s.data, 7)) {\n      http_set_header2(h, (fio_str_info_s){.data = (char *)\"allow\", .len = 5},\n                       (fio_str_info_s){.data = (char *)\"GET, HEAD\", .len = 9});\n      h->status = 200;\n      http_finish(h);\n      return 0;\n    }\n    break;\n  case 3:\n    if (!strncasecmp(\"get\", s.data, 3))\n      goto open_file;\n    break;\n  case 4:\n    if (!strncasecmp(\"head\", s.data, 4)) {\n      http_set_header(h, HTTP_HEADER_CONTENT_LENGTH, fiobj_num_new(length));\n      http_finish(h);\n      return 0;\n    }\n    break;\n  }\n  http_send_error(h, 403);\n  return 0;\nopen_file:\n  s = fiobj_obj2cstr(filename);\n  file = open(s.data, O_RDONLY);\n  if (file == -1) {\n    FIO_LOG_ERROR(\"(HTTP) couldn't open file %s!\\n\", s.data);\n    perror(\"     \");\n    http_send_error(h, 500);\n    return 0;\n  }\n  {\n    FIOBJ tmp = 0;\n    uintptr_t pos = 0;\n    if (is_gz) {\n      http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,\n                      fiobj_dup(HTTP_HVALUE_GZIP));\n\n      pos = s.len - 4;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos - 3);\n\n    } else {\n      pos = s.len - 1;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos);\n    }\n    if (tmp)\n      http_set_header(h, HTTP_HEADER_CONTENT_TYPE, tmp);\n  }\n  http_sendfile(h, file, length, offset);\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,14 +26,8 @@\n       char *pos = (char *)encoded;\n       const char *end = encoded + encoded_len;\n       while (pos < end) {\n-        /* test for path manipulations while decoding */\n-        if (*pos == '/' && (pos[1] == '/' ||\n-                            (((uintptr_t)end - (uintptr_t)pos >= 4) &&\n-                             pos[1] == '.' && pos[2] == '.' && pos[3] == '/')))\n-          return -1;\n         if (*pos == '%') {\n-          // decode hex value\n-          // this is a percent encoded value.\n+          // decode hex value (this is a percent encoded value).\n           if (hex2byte((uint8_t *)tmp.data + tmp.len, (uint8_t *)pos + 1))\n             return -1;\n           tmp.len++;\n@@ -43,6 +37,9 @@\n       }\n       tmp.data[tmp.len] = 0;\n       fiobj_str_resize(filename, tmp.len);\n+      /* test for path manipulations after decoding */\n+      if (http_test_encoded_path(tmp.data + prefix_len, tmp.len - prefix_len))\n+        return -1;\n     }\n     if (tmp.data[tmp.len - 1] == '/')\n       fiobj_str_write(filename, \"index.html\", 10);",
        "diff_line_info": {
            "deleted_lines": [
                "        /* test for path manipulations while decoding */",
                "        if (*pos == '/' && (pos[1] == '/' ||",
                "                            (((uintptr_t)end - (uintptr_t)pos >= 4) &&",
                "                             pos[1] == '.' && pos[2] == '.' && pos[3] == '/')))",
                "          return -1;",
                "          // decode hex value",
                "          // this is a percent encoded value."
            ],
            "added_lines": [
                "          // decode hex value (this is a percent encoded value).",
                "      /* test for path manipulations after decoding */",
                "      if (http_test_encoded_path(tmp.data + prefix_len, tmp.len - prefix_len))",
                "        return -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_cli_set_arg",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void fio_cli_set_arg(cstr_s arg, char const *value, char const *line,\n                            fio_cli_parser_data_s *parser) {\n  /* handle unnamed argument */\n  if (!line || !arg.len) {\n    if (!value) {\n      goto print_help;\n    }\n    if (!strcmp(value, \"-?\") || !strcasecmp(value, \"-h\") ||\n        !strcasecmp(value, \"-help\") || !strcasecmp(value, \"--help\")) {\n      goto print_help;\n    }\n    cstr_s n = {.len = ++parser->unnamed_count};\n    fio_cli_hash_insert(&fio_values, n.len, n, value, NULL);\n    if (parser->unnamed_max >= 0 &&\n        parser->unnamed_count > parser->unnamed_max) {\n      arg.len = 0;\n      goto error;\n    }\n    return;\n  }\n\n  /* validate data types */\n  char const *type = fio_cli_get_line_type(parser, line);\n  switch ((size_t)type) {\n  case FIO_CLI_BOOL__TYPE_I:\n    if (value && value != parser->argv[parser->pos + 1]) {\n      goto error;\n    }\n    value = \"1\";\n    break;\n  case FIO_CLI_INT__TYPE_I:\n    if (value) {\n      char const *tmp = value;\n      fio_atol((char **)&tmp);\n      if (*tmp) {\n        goto error;\n      }\n    }\n    /* fallthrough */\n  case FIO_CLI_STRING__TYPE_I:\n    if (!value)\n      goto error;\n    if (!value[0])\n      goto finish;\n    break;\n  }\n\n  /* add values using all aliases possible */\n  {\n    cstr_s n = {.data = line};\n    while (n.data[0] == '-') {\n      while (n.data[n.len] && n.data[n.len] != ' ' && n.data[n.len] != ',') {\n        ++n.len;\n      }\n      fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);\n      while (n.data[n.len] && (n.data[n.len] == ' ' || n.data[n.len] == ',')) {\n        ++n.len;\n      }\n      n.data += n.len;\n      n.len = 0;\n    }\n  }\n\nfinish:\n\n  /* handle additional argv progress (if value is on separate argv) */\n  if (value && parser->pos < parser->argc &&\n      value == parser->argv[parser->pos + 1])\n    ++parser->pos;\n  return;\n\nerror: /* handle errors*/\n  /* TODO! */\n  fprintf(stderr, \"\\n\\r\\x1B[31mError:\\x1B[0m unknown argument %.*s %s %s\\n\\n\",\n          (int)arg.len, arg.data, arg.len ? \"with value\" : \"\",\n          value ? (value[0] ? value : \"(empty)\") : \"(null)\");\nprint_help:\n  fprintf(stderr, \"\\n%s\\n\",\n          parser->description ? parser->description\n                              : \"This application accepts any of the following \"\n                                \"possible arguments:\");\n  /* print out each line's arguments */\n  char const **pos = parser->names;\n  while (*pos) {\n    switch ((intptr_t)*pos) {\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:  /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      ++pos;\n      continue;\n    }\n    type = (char *)FIO_CLI_STRING__TYPE_I;\n    switch ((intptr_t)pos[1]) {\n    case FIO_CLI_PRINT__TYPE_I:\n      fprintf(stderr, \"%s\\n\", pos[0]);\n      pos += 2;\n      continue;\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      fprintf(stderr, \"\\n\\x1B[4m%s\\x1B[0m\\n\", pos[0]);\n      pos += 2;\n      continue;\n\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n      type = pos[1];\n    }\n    /* print line @ pos, starting with main argument name */\n    int alias_count = 0;\n    int first_len = 0;\n    size_t tmp = 0;\n    char const *const p = *pos;\n    while (p[tmp] == '-') {\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        if (!alias_count)\n          ++first_len;\n        ++tmp;\n      }\n      ++alias_count;\n      while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n        ++tmp;\n      }\n    }\n    switch ((size_t)type) {\n    case FIO_CLI_STRING__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    case FIO_CLI_BOOL__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m   \\t%s\\n\", first_len, p, p + tmp);\n      break;\n    case FIO_CLI_INT__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    }\n    /* print aliase information */\n    tmp = first_len;\n    while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n      ++tmp;\n    }\n    while (p[tmp] == '-') {\n      const size_t start = tmp;\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        ++tmp;\n      }\n      int padding = first_len - (tmp - start);\n      if (padding < 0)\n        padding = 0;\n      switch ((size_t)type) {\n      case FIO_CLI_STRING__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t\\x1B[2msame as \"\n                \"%.*s\\x1B[0m\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_BOOL__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t\\x1B[2msame as %.*s\\x1B[0m\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_INT__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t\\x1B[2msame as \"\n                \"%.*s\\x1B[0m\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      }\n    }\n\n    ++pos;\n  }\n  fprintf(stderr, \"\\nUse any of the following input formats:\\n\"\n                  \"\\t-arg <value>\\t-arg=<value>\\t-arg<value>\\n\"\n                  \"\\n\"\n                  \"Use the -h, -help or -? to get this information again.\\n\"\n                  \"\\n\");\n  fio_cli_end();\n  exit(0);\n}",
        "func": "static void fio_cli_set_arg(cstr_s arg, char const *value, char const *line,\n                            fio_cli_parser_data_s *parser) {\n  /* handle unnamed argument */\n  if (!line || !arg.len) {\n    if (!value) {\n      goto print_help;\n    }\n    if (!strcmp(value, \"-?\") || !strcasecmp(value, \"-h\") ||\n        !strcasecmp(value, \"-help\") || !strcasecmp(value, \"--help\")) {\n      goto print_help;\n    }\n    cstr_s n = {.len = ++parser->unnamed_count};\n    fio_cli_hash_insert(&fio_values, n.len, n, value, NULL);\n    if (parser->unnamed_max >= 0 &&\n        parser->unnamed_count > parser->unnamed_max) {\n      arg.len = 0;\n      goto error;\n    }\n    return;\n  }\n\n  /* validate data types */\n  char const *type = fio_cli_get_line_type(parser, line);\n  switch ((size_t)type) {\n  case FIO_CLI_BOOL__TYPE_I:\n    if (value && value != parser->argv[parser->pos + 1]) {\n      goto error;\n    }\n    value = \"1\";\n    break;\n  case FIO_CLI_INT__TYPE_I:\n    if (value) {\n      char const *tmp = value;\n      fio_atol((char **)&tmp);\n      if (*tmp) {\n        goto error;\n      }\n    }\n    /* fallthrough */\n  case FIO_CLI_STRING__TYPE_I:\n    if (!value)\n      goto error;\n    if (!value[0])\n      goto finish;\n    break;\n  }\n\n  /* add values using all aliases possible */\n  {\n    cstr_s n = {.data = line};\n    while (n.data[0] == '-') {\n      while (n.data[n.len] && n.data[n.len] != ' ' && n.data[n.len] != ',') {\n        ++n.len;\n      }\n      fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);\n      while (n.data[n.len] && (n.data[n.len] == ' ' || n.data[n.len] == ',')) {\n        ++n.len;\n      }\n      n.data += n.len;\n      n.len = 0;\n    }\n  }\n\nfinish:\n\n  /* handle additional argv progress (if value is on separate argv) */\n  if (value && parser->pos < parser->argc &&\n      value == parser->argv[parser->pos + 1])\n    ++parser->pos;\n  return;\n\nerror: /* handle errors*/\n  /* TODO! */\n  fprintf(stderr, \"\\n\\r\\x1B[31mError:\\x1B[0m unknown argument %.*s %s %s\\n\\n\",\n          (int)arg.len, arg.data, arg.len ? \"with value\" : \"\",\n          value ? (value[0] ? value : \"(empty)\") : \"(null)\");\nprint_help:\n  fprintf(stderr, \"\\n%s\\n\",\n          parser->description ? parser->description\n                              : \"This application accepts any of the following \"\n                                \"possible arguments:\");\n  /* print out each line's arguments */\n  char const **pos = parser->names;\n  while (*pos) {\n    switch ((intptr_t)*pos) {\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:  /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      ++pos;\n      continue;\n    }\n    type = (char *)FIO_CLI_STRING__TYPE_I;\n    switch ((intptr_t)pos[1]) {\n    case FIO_CLI_PRINT__TYPE_I:\n      fprintf(stderr, \"%s\\n\", pos[0]);\n      pos += 2;\n      continue;\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      fprintf(stderr, \"\\n\\x1B[4m%s\\x1B[0m\\n\", pos[0]);\n      pos += 2;\n      continue;\n\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n      type = pos[1];\n    }\n    /* print line @ pos, starting with main argument name */\n    int alias_count = 0;\n    int first_len = 0;\n    size_t tmp = 0;\n    char const *const p = *pos;\n    while (p[tmp] == '-') {\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        if (!alias_count)\n          ++first_len;\n        ++tmp;\n      }\n      ++alias_count;\n      while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n        ++tmp;\n      }\n    }\n    switch ((size_t)type) {\n    case FIO_CLI_STRING__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    case FIO_CLI_BOOL__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m   \\t%s\\n\", first_len, p, p + tmp);\n      break;\n    case FIO_CLI_INT__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    }\n    /* print aliase information */\n    tmp = first_len;\n    while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n      ++tmp;\n    }\n    while (p[tmp] == '-') {\n      const size_t start = tmp;\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        ++tmp;\n      }\n      int padding = first_len - (tmp - start);\n      if (padding < 0)\n        padding = 0;\n      switch ((size_t)type) {\n      case FIO_CLI_STRING__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t(same as \"\n                \"\\x1B[1m%.*s\\x1B[0m)\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_BOOL__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t(same as \\x1B[1m%.*s\\x1B[0m)\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_INT__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t(same as \"\n                \"\\x1B[1m%.*s\\x1B[0m)\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      }\n    }\n\n    ++pos;\n  }\n  fprintf(stderr, \"\\nUse any of the following input formats:\\n\"\n                  \"\\t-arg <value>\\t-arg=<value>\\t-arg<value>\\n\"\n                  \"\\n\"\n                  \"Use the -h, -help or -? to get this information again.\\n\"\n                  \"\\n\");\n  fio_cli_end();\n  exit(0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -152,19 +152,19 @@\n       switch ((size_t)type) {\n       case FIO_CLI_STRING__TYPE_I:\n         fprintf(stderr,\n-                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t\\x1B[2msame as \"\n-                \"%.*s\\x1B[0m\\n\",\n+                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t(same as \"\n+                \"\\x1B[1m%.*s\\x1B[0m)\\n\",\n                 (int)(tmp - start), p + start, padding, \"\", first_len, p);\n         break;\n       case FIO_CLI_BOOL__TYPE_I:\n         fprintf(stderr,\n-                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t\\x1B[2msame as %.*s\\x1B[0m\\n\",\n+                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t(same as \\x1B[1m%.*s\\x1B[0m)\\n\",\n                 (int)(tmp - start), p + start, padding, \"\", first_len, p);\n         break;\n       case FIO_CLI_INT__TYPE_I:\n         fprintf(stderr,\n-                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t\\x1B[2msame as \"\n-                \"%.*s\\x1B[0m\\n\",\n+                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t(same as \"\n+                \"\\x1B[1m%.*s\\x1B[0m)\\n\",\n                 (int)(tmp - start), p + start, padding, \"\", first_len, p);\n         break;\n       }",
        "diff_line_info": {
            "deleted_lines": [
                "                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t\\x1B[2msame as \"",
                "                \"%.*s\\x1B[0m\\n\",",
                "                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t\\x1B[2msame as %.*s\\x1B[0m\\n\",",
                "                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t\\x1B[2msame as \"",
                "                \"%.*s\\x1B[0m\\n\","
            ],
            "added_lines": [
                "                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t(same as \"",
                "                \"\\x1B[1m%.*s\\x1B[0m)\\n\",",
                "                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t(same as \\x1B[1m%.*s\\x1B[0m)\\n\",",
                "                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t(same as \"",
                "                \"\\x1B[1m%.*s\\x1B[0m)\\n\","
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_signal_handler_reset",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "void fio_signal_handler_reset(void) {\n  struct sigaction old;\n  if (!fio_old_sig_int.sa_handler)\n    return;\n  memset(&old, 0, sizeof(old));\n  sigaction(SIGINT, &fio_old_sig_int, &old);\n  sigaction(SIGTERM, &fio_old_sig_term, &old);\n  sigaction(SIGPIPE, &fio_old_sig_pipe, &old);\n  if (fio_old_sig_chld.sa_handler)\n    sigaction(SIGCHLD, &fio_old_sig_chld, &old);\n#if !FIO_DISABLE_HOT_RESTART\n  sigaction(SIGUSR1, &fio_old_sig_usr1, &old);\n  memset(&fio_old_sig_usr1, 0, sizeof(fio_old_sig_usr1));\n#endif\n  memset(&fio_old_sig_int, 0, sizeof(fio_old_sig_int));\n  memset(&fio_old_sig_term, 0, sizeof(fio_old_sig_term));\n  memset(&fio_old_sig_pipe, 0, sizeof(fio_old_sig_pipe));\n  memset(&fio_old_sig_chld, 0, sizeof(fio_old_sig_chld));\n}",
        "func": "void fio_signal_handler_reset(void) {\n  struct sigaction old;\n  if (fio_signal_set_flag)\n    return;\n  fio_unlock(&fio_signal_set_flag);\n  memset(&old, 0, sizeof(old));\n  sigaction(SIGINT, &fio_old_sig_int, &old);\n  sigaction(SIGTERM, &fio_old_sig_term, &old);\n  sigaction(SIGPIPE, &fio_old_sig_pipe, &old);\n  if (fio_old_sig_chld.sa_handler)\n    sigaction(SIGCHLD, &fio_old_sig_chld, &old);\n#if !FIO_DISABLE_HOT_RESTART\n  sigaction(SIGUSR1, &fio_old_sig_usr1, &old);\n  memset(&fio_old_sig_usr1, 0, sizeof(fio_old_sig_usr1));\n#endif\n  memset(&fio_old_sig_int, 0, sizeof(fio_old_sig_int));\n  memset(&fio_old_sig_term, 0, sizeof(fio_old_sig_term));\n  memset(&fio_old_sig_pipe, 0, sizeof(fio_old_sig_pipe));\n  memset(&fio_old_sig_chld, 0, sizeof(fio_old_sig_chld));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,8 @@\n void fio_signal_handler_reset(void) {\n   struct sigaction old;\n-  if (!fio_old_sig_int.sa_handler)\n+  if (fio_signal_set_flag)\n     return;\n+  fio_unlock(&fio_signal_set_flag);\n   memset(&old, 0, sizeof(old));\n   sigaction(SIGINT, &fio_old_sig_int, &old);\n   sigaction(SIGTERM, &fio_old_sig_term, &old);",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!fio_old_sig_int.sa_handler)"
            ],
            "added_lines": [
                "  if (fio_signal_set_flag)",
                "  fio_unlock(&fio_signal_set_flag);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_signal_handler_setup",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void fio_signal_handler_setup(void) {\n  /* setup signal handling */\n  struct sigaction act;\n  if (fio_old_sig_int.sa_handler)\n    return;\n\n  memset(&act, 0, sizeof(act));\n\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}",
        "func": "static void fio_signal_handler_setup(void) {\n  /* setup signal handling */\n  struct sigaction act;\n  if (fio_trylock(&fio_signal_set_flag))\n    return;\n\n  memset(&act, 0, sizeof(act));\n\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static void fio_signal_handler_setup(void) {\n   /* setup signal handling */\n   struct sigaction act;\n-  if (fio_old_sig_int.sa_handler)\n+  if (fio_trylock(&fio_signal_set_flag))\n     return;\n \n   memset(&act, 0, sizeof(act));",
        "diff_line_info": {
            "deleted_lines": [
                "  if (fio_old_sig_int.sa_handler)"
            ],
            "added_lines": [
                "  if (fio_trylock(&fio_signal_set_flag))"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_flush",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "ssize_t fio_flush(intptr_t uuid) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  errno = 0;\n  ssize_t flushed = 0;\n  int tmp;\n  /* start critical section */\n  if (fio_trylock(&uuid_data(uuid).sock_lock))\n    goto would_block;\n\n  if (!uuid_data(uuid).packet)\n    goto flush_rw_hook;\n\n  const fio_packet_s *old_packet = uuid_data(uuid).packet;\n  const size_t old_sent = uuid_data(uuid).sent;\n\n  tmp = uuid_data(uuid).packet->write_func(fio_uuid2fd(uuid),\n                                           uuid_data(uuid).packet);\n  if (tmp <= 0) {\n    goto test_errno;\n  }\n\n  if (uuid_data(uuid).packet_count >= 1024 &&\n      uuid_data(uuid).packet == old_packet &&\n      uuid_data(uuid).sent >= old_sent &&\n      (uuid_data(uuid).sent - old_sent) < 32768) {\n    /* Slowloris attack assumed */\n    goto attacked;\n  }\n\n  /* end critical section */\n  fio_unlock(&uuid_data(uuid).sock_lock);\n\n  /* test for fio_close marker */\n  if (!uuid_data(uuid).packet && uuid_data(uuid).close)\n    goto closed;\n\n  /* return state */\n  return uuid_data(uuid).open && uuid_data(uuid).packet != NULL;\n\nwould_block:\n  errno = EWOULDBLOCK;\n  return -1;\n\nclosed:\n  fio_force_close(uuid);\n  return -1;\n\nflush_rw_hook:\n  flushed = uuid_data(uuid).rw_hooks->flush(uuid, uuid_data(uuid).rw_udata);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  if (!flushed)\n    return 0;\n  if (flushed < 0) {\n    goto test_errno;\n  }\n  touchfd(fio_uuid2fd(uuid));\n  return 1;\n\ntest_errno:\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  switch (errno) {\n  case EWOULDBLOCK: /* fallthrough */\n#if EWOULDBLOCK != EAGAIN\n  case EAGAIN: /* fallthrough */\n#endif\n  case ENOTCONN:      /* fallthrough */\n  case EINPROGRESS:   /* fallthrough */\n  case ENOSPC:        /* fallthrough */\n  case EADDRNOTAVAIL: /* fallthrough */\n  case EINTR:\n    return 1;\n  case EFAULT:\n    FIO_LOG_ERROR(\"fio_flush EFAULT - possible memory address error sent to \"\n                  \"Unix socket.\");\n    /* fallthrough */\n  case EPIPE:  /* fallthrough */\n  case EIO:    /* fallthrough */\n  case EINVAL: /* fallthrough */\n  case EBADF:\n    uuid_data(uuid).close = 1;\n    fio_force_close(uuid);\n    return -1;\n  }\n  fprintf(stderr, \"UUID error: %p (%d)\\n\", (void *)uuid, errno);\n  perror(\"No errno handler\");\n  return 0;\n\ninvalid:\n  /* bad UUID */\n  errno = EBADF;\n  return -1;\n\nattacked:\n  /* don't close, just detach from facil.io and mark uuid as invalid */\n  FIO_LOG_WARNING(\"(facil.io) possible Slowloris attack from %.*s\",\n                  (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  fio_clear_fd(fio_uuid2fd(uuid), 0);\n  return -1;\n}",
        "func": "ssize_t fio_flush(intptr_t uuid) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  errno = 0;\n  ssize_t flushed = 0;\n  int tmp;\n  /* start critical section */\n  if (fio_trylock(&uuid_data(uuid).sock_lock))\n    goto would_block;\n\n  if (!uuid_data(uuid).packet)\n    goto flush_rw_hook;\n\n  const fio_packet_s *old_packet = uuid_data(uuid).packet;\n  const size_t old_sent = uuid_data(uuid).sent;\n\n  tmp = uuid_data(uuid).packet->write_func(fio_uuid2fd(uuid),\n                                           uuid_data(uuid).packet);\n  if (tmp <= 0) {\n    goto test_errno;\n  }\n\n  if (uuid_data(uuid).packet_count >= FIO_SLOWLORIS_LIMIT &&\n      uuid_data(uuid).packet == old_packet &&\n      uuid_data(uuid).sent >= old_sent &&\n      (uuid_data(uuid).sent - old_sent) < 32768) {\n    /* Slowloris attack assumed */\n    goto attacked;\n  }\n\n  /* end critical section */\n  fio_unlock(&uuid_data(uuid).sock_lock);\n\n  /* test for fio_close marker */\n  if (!uuid_data(uuid).packet && uuid_data(uuid).close)\n    goto closed;\n\n  /* return state */\n  return uuid_data(uuid).open && uuid_data(uuid).packet != NULL;\n\nwould_block:\n  errno = EWOULDBLOCK;\n  return -1;\n\nclosed:\n  fio_force_close(uuid);\n  return -1;\n\nflush_rw_hook:\n  flushed = uuid_data(uuid).rw_hooks->flush(uuid, uuid_data(uuid).rw_udata);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  if (!flushed)\n    return 0;\n  if (flushed < 0) {\n    goto test_errno;\n  }\n  touchfd(fio_uuid2fd(uuid));\n  return 1;\n\ntest_errno:\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  switch (errno) {\n  case EWOULDBLOCK: /* fallthrough */\n#if EWOULDBLOCK != EAGAIN\n  case EAGAIN: /* fallthrough */\n#endif\n  case ENOTCONN:      /* fallthrough */\n  case EINPROGRESS:   /* fallthrough */\n  case ENOSPC:        /* fallthrough */\n  case EADDRNOTAVAIL: /* fallthrough */\n  case EINTR:\n    return 1;\n  case EFAULT:\n    FIO_LOG_ERROR(\"fio_flush EFAULT - possible memory address error sent to \"\n                  \"Unix socket.\");\n    /* fallthrough */\n  case EPIPE:  /* fallthrough */\n  case EIO:    /* fallthrough */\n  case EINVAL: /* fallthrough */\n  case EBADF:\n    uuid_data(uuid).close = 1;\n    fio_force_close(uuid);\n    return -1;\n  }\n  fprintf(stderr, \"UUID error: %p (%d)\\n\", (void *)uuid, errno);\n  perror(\"No errno handler\");\n  return 0;\n\ninvalid:\n  /* bad UUID */\n  errno = EBADF;\n  return -1;\n\nattacked:\n  /* don't close, just detach from facil.io and mark uuid as invalid */\n  FIO_LOG_WARNING(\"(facil.io) possible Slowloris attack from %.*s\",\n                  (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  fio_clear_fd(fio_uuid2fd(uuid), 0);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n     goto test_errno;\n   }\n \n-  if (uuid_data(uuid).packet_count >= 1024 &&\n+  if (uuid_data(uuid).packet_count >= FIO_SLOWLORIS_LIMIT &&\n       uuid_data(uuid).packet == old_packet &&\n       uuid_data(uuid).sent >= old_sent &&\n       (uuid_data(uuid).sent - old_sent) < 32768) {",
        "diff_line_info": {
            "deleted_lines": [
                "  if (uuid_data(uuid).packet_count >= 1024 &&"
            ],
            "added_lines": [
                "  if (uuid_data(uuid).packet_count >= FIO_SLOWLORIS_LIMIT &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_cluster_signal_children",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    fio_stop();\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}",
        "func": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    kill(getpid(), SIGINT);\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static void fio_cluster_signal_children(void) {\n   if (fio_parent_pid() != getpid()) {\n-    fio_stop();\n+    kill(getpid(), SIGINT);\n     return;\n   }\n   fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,",
        "diff_line_info": {
            "deleted_lines": [
                "    fio_stop();"
            ],
            "added_lines": [
                "    kill(getpid(), SIGINT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_timer_calc_due",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval > 1000) {\n    now.tv_sec += interval / 1000;\n    interval -= interval / 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec > 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}",
        "func": "static struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval >= 1000) {\n    unsigned long long secs = interval / 1000;\n    now.tv_sec += secs;\n    interval -= secs * 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec >= 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,12 @@\n static struct timespec fio_timer_calc_due(size_t interval) {\n   struct timespec now = fio_last_tick();\n-  if (interval > 1000) {\n-    now.tv_sec += interval / 1000;\n-    interval -= interval / 1000;\n+  if (interval >= 1000) {\n+    unsigned long long secs = interval / 1000;\n+    now.tv_sec += secs;\n+    interval -= secs * 1000;\n   }\n   now.tv_nsec += (interval * 1000000UL);\n-  if (now.tv_nsec > 1000000000L) {\n+  if (now.tv_nsec >= 1000000000L) {\n     now.tv_nsec -= 1000000000L;\n     now.tv_sec += 1;\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (interval > 1000) {",
                "    now.tv_sec += interval / 1000;",
                "    interval -= interval / 1000;",
                "  if (now.tv_nsec > 1000000000L) {"
            ],
            "added_lines": [
                "  if (interval >= 1000) {",
                "    unsigned long long secs = interval / 1000;",
                "    now.tv_sec += secs;",
                "    interval -= secs * 1000;",
                "  if (now.tv_nsec >= 1000000000L) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_worker_cleanup",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void fio_worker_cleanup(void) {\n  /* switch to winding down */\n  if (fio_data->is_worker)\n    FIO_LOG_INFO(\"(%d) detected exit signal.\", (int)getpid());\n  else\n    FIO_LOG_INFO(\"Server Detected exit signal.\");\n  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol) {\n      fio_defer_push_task(deferred_on_shutdown, (void *)fd2uuid(i), NULL);\n    }\n  }\n  fio_defer_push_task(fio_cycle_unwind, NULL, NULL);\n  fio_defer_perform();\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol || fd_data(i).open) {\n      fio_force_close(fd2uuid(i));\n    }\n  }\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_ON_FINISH);\n  fio_defer_perform();\n  if (!fio_data->is_worker) {\n    fio_cluster_signal_children();\n    while (wait(NULL) != -1)\n      ;\n  }\n  fio_defer_perform();\n  fio_signal_handler_reset();\n  if (fio_data->parent == getpid()) {\n    FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");\n  } else {\n    FIO_LOG_INFO(\"(%d) cleanup complete.\", (int)getpid());\n  }\n}",
        "func": "static void fio_worker_cleanup(void) {\n  /* switch to winding down */\n  if (fio_data->is_worker)\n    FIO_LOG_INFO(\"(%d) detected exit signal.\", (int)getpid());\n  else\n    FIO_LOG_INFO(\"Server Detected exit signal.\");\n  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol) {\n      fio_defer_push_task(deferred_on_shutdown, (void *)fd2uuid(i), NULL);\n    }\n  }\n  fio_defer_push_task(fio_cycle_unwind, NULL, NULL);\n  fio_defer_perform();\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol || fd_data(i).open) {\n      fio_force_close(fd2uuid(i));\n    }\n  }\n  fio_timer_clear_all();\n  fio_defer_perform();\n  if (!fio_data->is_worker) {\n    kill(0, SIGINT);\n    while (wait(NULL) != -1)\n      ;\n  }\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_ON_FINISH);\n  fio_defer_perform();\n  fio_signal_handler_reset();\n  if (fio_data->parent == getpid()) {\n    FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");\n  } else {\n    FIO_LOG_INFO(\"(%d) cleanup complete.\", (int)getpid());\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,14 +17,15 @@\n       fio_force_close(fd2uuid(i));\n     }\n   }\n-  fio_defer_perform();\n-  fio_state_callback_force(FIO_CALL_ON_FINISH);\n+  fio_timer_clear_all();\n   fio_defer_perform();\n   if (!fio_data->is_worker) {\n-    fio_cluster_signal_children();\n+    kill(0, SIGINT);\n     while (wait(NULL) != -1)\n       ;\n   }\n+  fio_defer_perform();\n+  fio_state_callback_force(FIO_CALL_ON_FINISH);\n   fio_defer_perform();\n   fio_signal_handler_reset();\n   if (fio_data->parent == getpid()) {",
        "diff_line_info": {
            "deleted_lines": [
                "  fio_defer_perform();",
                "  fio_state_callback_force(FIO_CALL_ON_FINISH);",
                "    fio_cluster_signal_children();"
            ],
            "added_lines": [
                "  fio_timer_clear_all();",
                "    kill(0, SIGINT);",
                "  fio_defer_perform();",
                "  fio_state_callback_force(FIO_CALL_ON_FINISH);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_cluster_listen_on_close",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      fio_stop();\n  }\n  (void)uuid;\n}",
        "func": "static void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      kill(0, SIGINT);\n  }\n  (void)uuid;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n                   (int)getpid());\n #endif\n     if (fio_data->active)\n-      fio_stop();\n+      kill(0, SIGINT);\n   }\n   (void)uuid;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      fio_stop();"
            ],
            "added_lines": [
                "      kill(0, SIGINT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_cluster_client_handler",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void fio_cluster_client_handler(struct cluster_pr_s *pr) {\n  /* what to do? */\n  switch ((fio_cluster_message_type_e)pr->type) {\n  case FIO_CLUSTER_MSG_FORWARD: /* fallthrough */\n  case FIO_CLUSTER_MSG_JSON:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  case FIO_CLUSTER_MSG_SHUTDOWN:\n    fio_stop();\n  case FIO_CLUSTER_MSG_ERROR:         /* fallthrough */\n  case FIO_CLUSTER_MSG_PING:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT_JSON:     /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_SUB:    /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB:  /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_SUB:   /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: /* fallthrough */\n\n  default:\n    break;\n  }\n}",
        "func": "static void fio_cluster_client_handler(struct cluster_pr_s *pr) {\n  /* what to do? */\n  switch ((fio_cluster_message_type_e)pr->type) {\n  case FIO_CLUSTER_MSG_FORWARD: /* fallthrough */\n  case FIO_CLUSTER_MSG_JSON:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  case FIO_CLUSTER_MSG_SHUTDOWN:\n    fio_stop();\n    kill(getpid(), SIGINT);\n  case FIO_CLUSTER_MSG_ERROR:         /* fallthrough */\n  case FIO_CLUSTER_MSG_PING:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT_JSON:     /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_SUB:    /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB:  /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_SUB:   /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: /* fallthrough */\n\n  default:\n    break;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n     break;\n   case FIO_CLUSTER_MSG_SHUTDOWN:\n     fio_stop();\n+    kill(getpid(), SIGINT);\n   case FIO_CLUSTER_MSG_ERROR:         /* fallthrough */\n   case FIO_CLUSTER_MSG_PING:          /* fallthrough */\n   case FIO_CLUSTER_MSG_ROOT:          /* fallthrough */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    kill(getpid(), SIGINT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_lib_destroy",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void __attribute__((destructor)) fio_lib_destroy(void) {\n  uint8_t add_eol = fio_is_master();\n  fio_data->active = 0;\n  fio_on_fork();\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_AT_EXIT);\n  fio_state_callback_clear_all();\n  fio_defer_perform();\n  fio_poll_close();\n  fio_timer_clear_all();\n  fio_free(fio_data);\n  /* memory library destruction must be last */\n  fio_mem_destroy();\n  FIO_LOG_DEBUG(\"(%d) facil.io resources released, exit complete.\",\n                (int)getpid());\n  if (add_eol)\n    fprintf(stderr, \"\\n\"); /* add EOL to logs (logging adds EOL before text */\n}",
        "func": "static void __attribute__((destructor)) fio_lib_destroy(void) {\n  uint8_t add_eol = fio_is_master();\n  fio_data->active = 0;\n  fio_on_fork();\n  fio_defer_perform();\n  fio_timer_clear_all();\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_AT_EXIT);\n  fio_state_callback_clear_all();\n  fio_defer_perform();\n  fio_poll_close();\n  fio_free(fio_data);\n  /* memory library destruction must be last */\n  fio_mem_destroy();\n  FIO_LOG_DEBUG(\"(%d) facil.io resources released, exit complete.\",\n                (int)getpid());\n  if (add_eol)\n    fprintf(stderr, \"\\n\"); /* add EOL to logs (logging adds EOL before text */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,11 +3,12 @@\n   fio_data->active = 0;\n   fio_on_fork();\n   fio_defer_perform();\n+  fio_timer_clear_all();\n+  fio_defer_perform();\n   fio_state_callback_force(FIO_CALL_AT_EXIT);\n   fio_state_callback_clear_all();\n   fio_defer_perform();\n   fio_poll_close();\n-  fio_timer_clear_all();\n   fio_free(fio_data);\n   /* memory library destruction must be last */\n   fio_mem_destroy();",
        "diff_line_info": {
            "deleted_lines": [
                "  fio_timer_clear_all();"
            ],
            "added_lines": [
                "  fio_timer_clear_all();",
                "  fio_defer_perform();"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/sig_int_handler",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void sig_int_handler(int sig) {\n  struct sigaction *old = NULL;\n  switch (sig) {\n#if !FIO_DISABLE_HOT_RESTART\n  case SIGUSR1:\n    fio_signal_children_flag = 1;\n    old = &fio_old_sig_usr1;\n    break;\n#endif\n    /* fallthrough */\n  case SIGINT:\n    if (!old)\n      old = &fio_old_sig_int;\n    /* fallthrough */\n  case SIGTERM:\n    if (!old)\n      old = &fio_old_sig_term;\n    fio_stop();\n    break;\n  case SIGPIPE:\n    if (!old)\n      old = &fio_old_sig_pipe;\n  /* fallthrough */\n  default:\n    break;\n  }\n  /* propagate signale handling to previous existing handler (if any) */\n  if (old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n    old->sa_handler(sig);\n}",
        "func": "static void sig_int_handler(int sig) {\n  struct sigaction *old = NULL;\n  switch (sig) {\n#if !FIO_DISABLE_HOT_RESTART\n  case SIGUSR1:\n    fio_signal_children_flag = 1;\n    old = &fio_old_sig_usr1;\n    break;\n#endif\n    /* fallthrough */\n  case SIGINT:\n    if (!old)\n      old = &fio_old_sig_int;\n    /* fallthrough */\n  case SIGTERM:\n    if (!old)\n      old = &fio_old_sig_term;\n    fio_stop();\n    break;\n  case SIGPIPE:\n    if (!old)\n      old = &fio_old_sig_pipe;\n  /* fallthrough */\n  default:\n    break;\n  }\n  /* propagate signale handling to previous existing handler (if any) */\n  if (old && old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n    old->sa_handler(sig);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,6 @@\n     break;\n   }\n   /* propagate signale handling to previous existing handler (if any) */\n-  if (old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n+  if (old && old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n     old->sa_handler(sig);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)"
            ],
            "added_lines": [
                "  if (old && old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fiobj_mustache_find_obj_absolute",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static inline VALUE fiobj_mustache_find_obj_absolute(VALUE udata,\n                                                     const char *name,\n                                                     uint32_t name_len) {\n  VALUE tmp;\n  if (!RB_TYPE_P(udata, T_HASH)) {\n    if (name_len == 1 && name[0] == '.')\n      return udata;\n    /* search by method */\n    ID name_id = rb_intern2(name, name_len);\n    if (rb_respond_to(udata, name_id)) {\n      return IodineCaller.call(udata, name_id);\n    }\n    return Qnil;\n  }\n  /* search by Symbol */\n  ID name_id = rb_intern2(name, name_len);\n  VALUE key = ID2SYM(name_id);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by String */\n  key = rb_sym2str(key);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by method */\n  tmp = Qnil;\n  if (rb_respond_to(udata, name_id)) {\n    tmp = IodineCaller.call(udata, name_id);\n  }\n\n  return tmp;\n}",
        "func": "static inline VALUE fiobj_mustache_find_obj_absolute(VALUE udata,\n                                                     const char *name,\n                                                     uint32_t name_len) {\n  VALUE tmp;\n  if (!RB_TYPE_P(udata, T_HASH)) {\n    if (name_len == 1 && name[0] == '.')\n      return udata;\n    /* search by method */\n    ID name_id = rb_intern2(name, name_len);\n    if (rb_respond_to(udata, name_id)) {\n      return IodineCaller.call(udata, name_id);\n    }\n    return Qnil;\n  }\n  /* search by Symbol */\n  ID name_id = rb_intern2(name, name_len);\n  VALUE key = ID2SYM(name_id);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by String */\n  key = rb_sym2str(key);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  rb_str_free(key);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by method */\n  tmp = Qnil;\n  if (rb_respond_to(udata, name_id)) {\n    tmp = IodineCaller.call(udata, name_id);\n  }\n\n  return tmp;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,7 @@\n   /* search by String */\n   key = rb_sym2str(key);\n   tmp = rb_hash_lookup2(udata, key, Qundef);\n+  rb_str_free(key);\n   if (tmp != Qundef)\n     return tmp;\n   /* search by method */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  rb_str_free(key);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/iodine_mustache_new",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static VALUE iodine_mustache_new(int argc, VALUE *argv, VALUE self) {\n  VALUE filename = Qnil, template = Qnil;\n  if (argc == 1 && RB_TYPE_P(argv[0], T_HASH)) {\n    /* named arguments */\n    filename = rb_hash_aref(argv[0], filename_id);\n    template = rb_hash_aref(argv[0], template_id);\n  } else {\n    /* regular arguments */\n    if (argc == 0 || argc > 2)\n      rb_raise(rb_eArgError, \"expecting 1..2 arguments or named arguments.\");\n    filename = argv[0];\n    if (argc > 1) {\n      template = argv[1];\n    }\n  }\n  if (filename == Qnil && template == Qnil)\n    rb_raise(rb_eArgError, \"need either template contents or file name.\");\n\n  if (template != Qnil)\n    Check_Type(template, T_STRING);\n  if (filename != Qnil)\n    Check_Type(filename, T_STRING);\n\n  fio_str_s str = FIO_STR_INIT;\n\n  mustache_s **m = NULL;\n  TypedData_Get_Struct(self, mustache_s *, &iodine_mustache_data_type, m);\n  if (!m) {\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache allocation error.\");\n  }\n\n  mustache_error_en err;\n  *m = mustache_load(.filename =\n                         (filename == Qnil ? NULL : RSTRING_PTR(filename)),\n                     .filename_len =\n                         (filename == Qnil ? 0 : RSTRING_LEN(filename)),\n                     .data = (template == Qnil ? NULL : RSTRING_PTR(template)),\n                     .data_len = (template == Qnil ? 0 : RSTRING_LEN(template)),\n                     .err = &err);\n\n  if (!*m)\n    goto error;\n  return self;\nerror:\n  switch (err) {\n  case MUSTACHE_OK:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template ok, unknown error.\");\n    break;\n  case MUSTACHE_ERR_TOO_DEEP:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache element nesting too deep.\");\n    break;\n  case MUSTACHE_ERR_CLOSURE_MISMATCH:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache template error, closure mismatch.\");\n    break;\n  case MUSTACHE_ERR_FILE_NOT_FOUND:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template not found.\");\n    break;\n  case MUSTACHE_ERR_FILE_TOO_BIG:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template too big.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template name too long.\");\n    break;\n  case MUSTACHE_ERR_EMPTY_TEMPLATE:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template is empty.\");\n    break;\n  case MUSTACHE_ERR_UNKNOWN:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache unknown error.\");\n    break;\n  case MUSTACHE_ERR_USER_ERROR:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache internal error.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_SHORT:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template file name too long.\");\n\n    break;\n  case MUSTACHE_ERR_DELIMITER_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache new delimiter is too long.\");\n\n    break;\n  case MUSTACHE_ERR_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache section name in template is too long.\");\n  default:\n    break;\n  }\n  return self;\n}",
        "func": "static VALUE iodine_mustache_new(int argc, VALUE *argv, VALUE self) {\n  VALUE filename = Qnil, template = Qnil;\n  if (argc == 1 && RB_TYPE_P(argv[0], T_HASH)) {\n    /* named arguments */\n    filename = rb_hash_aref(argv[0], filename_id);\n    template = rb_hash_aref(argv[0], template_id);\n  } else {\n    /* regular arguments */\n    if (argc == 0 || argc > 2)\n      rb_raise(rb_eArgError, \"expecting 1..2 arguments or named arguments.\");\n    filename = argv[0];\n    if (argc > 1) {\n      template = argv[1];\n    }\n  }\n  if (filename == Qnil && template == Qnil)\n    rb_raise(rb_eArgError, \"need either template contents or file name.\");\n\n  if (template != Qnil)\n    Check_Type(template, T_STRING);\n  if (filename != Qnil)\n    Check_Type(filename, T_STRING);\n\n  mustache_s **m = NULL;\n  TypedData_Get_Struct(self, mustache_s *, &iodine_mustache_data_type, m);\n  if (!m) {\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache allocation error.\");\n  }\n\n  mustache_error_en err;\n  *m = mustache_load(.filename =\n                         (filename == Qnil ? NULL : RSTRING_PTR(filename)),\n                     .filename_len =\n                         (filename == Qnil ? 0 : RSTRING_LEN(filename)),\n                     .data = (template == Qnil ? NULL : RSTRING_PTR(template)),\n                     .data_len = (template == Qnil ? 0 : RSTRING_LEN(template)),\n                     .err = &err);\n\n  if (!*m)\n    goto error;\n  return self;\nerror:\n  switch (err) {\n  case MUSTACHE_OK:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template ok, unknown error.\");\n    break;\n  case MUSTACHE_ERR_TOO_DEEP:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache element nesting too deep.\");\n    break;\n  case MUSTACHE_ERR_CLOSURE_MISMATCH:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache template error, closure mismatch.\");\n    break;\n  case MUSTACHE_ERR_FILE_NOT_FOUND:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template not found.\");\n    break;\n  case MUSTACHE_ERR_FILE_TOO_BIG:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template too big.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template name too long.\");\n    break;\n  case MUSTACHE_ERR_EMPTY_TEMPLATE:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template is empty.\");\n    break;\n  case MUSTACHE_ERR_UNKNOWN:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache unknown error.\");\n    break;\n  case MUSTACHE_ERR_USER_ERROR:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache internal error.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_SHORT:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template file name too long.\");\n\n    break;\n  case MUSTACHE_ERR_DELIMITER_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache new delimiter is too long.\");\n\n    break;\n  case MUSTACHE_ERR_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache section name in template is too long.\");\n  default:\n    break;\n  }\n  return self;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,8 +20,6 @@\n     Check_Type(template, T_STRING);\n   if (filename != Qnil)\n     Check_Type(filename, T_STRING);\n-\n-  fio_str_s str = FIO_STR_INIT;\n \n   mustache_s **m = NULL;\n   TypedData_Get_Struct(self, mustache_s *, &iodine_mustache_data_type, m);",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "  fio_str_s str = FIO_STR_INIT;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/http1_on_response",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static int http1_on_response(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_response_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.status_str && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}",
        "func": "static int http1_on_response(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_response_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.status_str && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return fio_is_closed(p->p.uuid);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,5 @@\n   if (p->request.status_str && !p->stop)\n     http_finish(&p->request);\n   h1_reset(p);\n-  return !p->close && fio_is_closed(p->p.uuid);\n+  return fio_is_closed(p->p.uuid);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return !p->close && fio_is_closed(p->p.uuid);"
            ],
            "added_lines": [
                "  return fio_is_closed(p->p.uuid);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/http1_on_ready",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  /* resume slow clients from suspension */\n  http1pr_s *p = (http1pr_s *)protocol;\n  if ((p->stop & 4)) {\n    p->stop ^= 4;\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}",
        "func": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  /* resume slow clients from suspension */\n  http1pr_s *p = (http1pr_s *)protocol;\n  if (p->stop & 4) {\n    p->stop ^= 4; /* flip back the bit, so it's zero */\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,8 @@\n static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n   /* resume slow clients from suspension */\n   http1pr_s *p = (http1pr_s *)protocol;\n-  if ((p->stop & 4)) {\n-    p->stop ^= 4;\n+  if (p->stop & 4) {\n+    p->stop ^= 4; /* flip back the bit, so it's zero */\n     fio_force_event(uuid, FIO_EVENT_ON_DATA);\n   }\n   (void)protocol;",
        "diff_line_info": {
            "deleted_lines": [
                "  if ((p->stop & 4)) {",
                "    p->stop ^= 4;"
            ],
            "added_lines": [
                "  if (p->stop & 4) {",
                "    p->stop ^= 4; /* flip back the bit, so it's zero */"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/http1_on_request",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}",
        "func": "static int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return fio_is_closed(p->p.uuid);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,5 @@\n   if (p->request.method && !p->stop)\n     http_finish(&p->request);\n   h1_reset(p);\n-  return !p->close && fio_is_closed(p->p.uuid);\n+  return fio_is_closed(p->p.uuid);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return !p->close && fio_is_closed(p->p.uuid);"
            ],
            "added_lines": [
                "  return fio_is_closed(p->p.uuid);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/http1_consume_data",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static inline void http1_consume_data(intptr_t uuid, http1pr_s *p) {\n  if (fio_pending(uuid) > 4) {\n    goto throttle;\n  }\n  ssize_t i = 0;\n  size_t org_len = p->buf_len;\n  int pipeline_limit = 8;\n  if (!p->buf_len)\n    return;\n  do {\n    i = http1_fio_parser(.parser = &p->parser,\n                         .buffer = p->buf + (org_len - p->buf_len),\n                         .length = p->buf_len, .on_request = http1_on_request,\n                         .on_response = http1_on_response,\n                         .on_method = http1_on_method,\n                         .on_status = http1_on_status, .on_path = http1_on_path,\n                         .on_query = http1_on_query,\n                         .on_http_version = http1_on_http_version,\n                         .on_header = http1_on_header,\n                         .on_body_chunk = http1_on_body_chunk,\n                         .on_error = http1_on_error);\n    p->buf_len -= i;\n    --pipeline_limit;\n  } while (i && p->buf_len && pipeline_limit && !p->stop);\n\n  if (p->buf_len && org_len != p->buf_len) {\n    memmove(p->buf, p->buf + (org_len - p->buf_len), p->buf_len);\n  }\n\n  if (p->buf_len == HTTP_MAX_HEADER_LENGTH) {\n    /* no room to read... parser not consuming data */\n    if (p->request.method)\n      http_send_error(&p->request, 413);\n    else {\n      p->request.method = fiobj_str_tmp();\n      http_send_error(&p->request, 413);\n    }\n  }\n\n  if (!pipeline_limit) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return;\n\nthrottle:\n  /* throttle busy clients (slowloris) */\n  fio_suspend(uuid);\n  p->stop |= 4;\n  FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n}",
        "func": "static inline void http1_consume_data(intptr_t uuid, http1pr_s *p) {\n  if (fio_pending(uuid) > 4) {\n    goto throttle;\n  }\n  ssize_t i = 0;\n  size_t org_len = p->buf_len;\n  int pipeline_limit = 8;\n  if (!p->buf_len)\n    return;\n  do {\n    i = http1_fio_parser(.parser = &p->parser,\n                         .buffer = p->buf + (org_len - p->buf_len),\n                         .length = p->buf_len, .on_request = http1_on_request,\n                         .on_response = http1_on_response,\n                         .on_method = http1_on_method,\n                         .on_status = http1_on_status, .on_path = http1_on_path,\n                         .on_query = http1_on_query,\n                         .on_http_version = http1_on_http_version,\n                         .on_header = http1_on_header,\n                         .on_body_chunk = http1_on_body_chunk,\n                         .on_error = http1_on_error);\n    p->buf_len -= i;\n    --pipeline_limit;\n  } while (i && p->buf_len && pipeline_limit && !p->stop);\n\n  if (p->buf_len && org_len != p->buf_len) {\n    memmove(p->buf, p->buf + (org_len - p->buf_len), p->buf_len);\n  }\n\n  if (p->buf_len == HTTP_MAX_HEADER_LENGTH) {\n    /* no room to read... parser not consuming data */\n    if (p->request.method)\n      http_send_error(&p->request, 413);\n    else {\n      p->request.method = fiobj_str_tmp();\n      http_send_error(&p->request, 413);\n    }\n  }\n\n  if (!pipeline_limit) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return;\n\nthrottle:\n  /* throttle busy clients (slowloris) */\n  p->stop |= 4;\n  fio_suspend(uuid);\n  FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,8 +44,8 @@\n \n throttle:\n   /* throttle busy clients (slowloris) */\n+  p->stop |= 4;\n   fio_suspend(uuid);\n-  p->stop |= 4;\n   FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                 (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  p->stop |= 4;"
            ],
            "added_lines": [
                "  p->stop |= 4;"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/http1_on_error",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static int http1_on_error(http1_parser_s *parser) {\n  FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",\n                parser->state.next - parser2http(parser)->buf,\n                parser2http(parser)->buf_len);\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}",
        "func": "static int http1_on_error(http1_parser_s *parser) {\n  if (parser2http(parser)->close)\n    return -1;\n  FIO_LOG_DEBUG(\"HTTP parser error.\");\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static int http1_on_error(http1_parser_s *parser) {\n-  FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",\n-                parser->state.next - parser2http(parser)->buf,\n-                parser2http(parser)->buf_len);\n+  if (parser2http(parser)->close)\n+    return -1;\n+  FIO_LOG_DEBUG(\"HTTP parser error.\");\n   fio_close(parser2http(parser)->p.uuid);\n   return -1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",",
                "                parser->state.next - parser2http(parser)->buf,",
                "                parser2http(parser)->buf_len);"
            ],
            "added_lines": [
                "  if (parser2http(parser)->close)",
                "    return -1;",
                "  FIO_LOG_DEBUG(\"HTTP parser error.\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/http1_on_data_first_time",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "static void http1_on_data_first_time(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  ssize_t i;\n\n  i = fio_read(uuid, p->buf + p->buf_len, HTTP_MAX_HEADER_LENGTH - p->buf_len);\n\n  if (i <= 0)\n    return;\n  p->buf_len += i;\n\n  /* ensure future reads skip this first time HTTP/2.0 test */\n  p->p.protocol.on_data = http1_on_data;\n  /* Test fot HTTP/2.0 pre-knowledge */\n  if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n    FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n    fio_close(uuid);\n    return;\n  }\n\n  /* Finish handling the same way as the normal `on_data` */\n  http1_consume_data(uuid, p);\n}",
        "func": "static void http1_on_data_first_time(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  ssize_t i;\n\n  i = fio_read(uuid, p->buf + p->buf_len, HTTP_MAX_HEADER_LENGTH - p->buf_len);\n\n  if (i <= 0)\n    return;\n  p->buf_len += i;\n\n  /* ensure future reads skip this first time HTTP/2.0 test */\n  p->p.protocol.on_data = http1_on_data;\n  if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n    FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n    fio_close(uuid);\n    return;\n  }\n\n  /* Finish handling the same way as the normal `on_data` */\n  http1_consume_data(uuid, p);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,6 @@\n \n   /* ensure future reads skip this first time HTTP/2.0 test */\n   p->p.protocol.on_data = http1_on_data;\n-  /* Test fot HTTP/2.0 pre-knowledge */\n   if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n     FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n     fio_close(uuid);",
        "diff_line_info": {
            "deleted_lines": [
                "  /* Test fot HTTP/2.0 pre-knowledge */"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_tls_destroy",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "void FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  free(tls);\n}",
        "func": "void FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  trust_ary_free(&tls->trust);\n  free(tls);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,5 +7,6 @@\n   fio_tls_destroy_context(tls);\n   alpn_list_free(&tls->alpn);\n   cert_ary_free(&tls->sni);\n+  trust_ary_free(&tls->trust);\n   free(tls);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  trust_ary_free(&tls->trust);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_throttle_thread",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "FIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n  const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),\n                              .tv_sec = (nano_sec / 1000000000)};\n  nanosleep(&tm, NULL);\n}",
        "func": "FIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n  const struct timespec tm = {.tv_nsec = (long)(nano_sec % 1000000000),\n                              .tv_sec = (time_t)(nano_sec / 1000000000)};\n  nanosleep(&tm, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n FIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n-  const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),\n-                              .tv_sec = (nano_sec / 1000000000)};\n+  const struct timespec tm = {.tv_nsec = (long)(nano_sec % 1000000000),\n+                              .tv_sec = (time_t)(nano_sec / 1000000000)};\n   nanosleep(&tm, NULL);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),",
                "                              .tv_sec = (nano_sec / 1000000000)};"
            ],
            "added_lines": [
                "  const struct timespec tm = {.tv_nsec = (long)(nano_sec % 1000000000),",
                "                              .tv_sec = (time_t)(nano_sec / 1000000000)};"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-22050",
        "func_name": "boazsegev/iodine/fio_sendfile",
        "description": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n",
        "git_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889",
        "commit_title": "update to facil.io 0.7.3",
        "commit_text": "",
        "func_before": "inline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,\n                                     off_t offset, size_t length) {\n  return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,\n                    .offset = offset);\n}",
        "func": "inline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,\n                                     off_t offset, size_t length) {\n  return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,\n                    .offset = (uintptr_t)offset);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n inline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,\n                                      off_t offset, size_t length) {\n   return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,\n-                    .offset = offset);\n+                    .offset = (uintptr_t)offset);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                    .offset = offset);"
            ],
            "added_lines": [
                "                    .offset = (uintptr_t)offset);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52076",
        "func_name": "mate-desktop/atril/extract_epub_from_container",
        "description": "Atril Document Viewer is the default document reader of the MATE desktop environment for Linux. A path traversal and arbitrary file write vulnerability exists in versions of Atril prior to 1.26.2. This vulnerability is capable of writing arbitrary files anywhere on the filesystem to which the user opening a crafted document has access. The only limitation is that this vulnerability cannot be exploited to overwrite existing files, but that doesn't stop an attacker from achieving Remote Command Execution on the target system. Version 1.26.2 of Atril contains a patch for this vulnerability.",
        "git_url": "https://github.com/mate-desktop/atril/commit/e70b21c815418a1e6ebedf6d8d31b8477c03ba50",
        "commit_title": "epub: Prevent path traversal when extracting files",
        "commit_text": " Test each file's resolved path against the temporary directory before extracting.",
        "func_before": "static gboolean\nextract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n\n    gboolean result = FALSE;\n\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n            goto out;\n        }\n\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\n\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}",
        "func": "static gboolean\nextract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GFile *tmp_gfile = NULL;\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n\n    gboolean result = FALSE;\n\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n\n    tmp_gfile = g_file_new_for_path (epub_document->tmp_archive_dir);\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document, tmp_gfile, &err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n            goto out;\n        }\n\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\n\nout:\n    g_clear_object (&tmp_gfile);\n    unzClose(epub_document->epubDocument);\n    return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n                              EpubDocument *epub_document,\n                              GError ** error)\n {\n+    GFile *tmp_gfile = NULL;\n     GError *err = NULL;\n     epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n \n@@ -64,9 +65,10 @@\n         goto out;\n     }\n \n+    tmp_gfile = g_file_new_for_path (epub_document->tmp_archive_dir);\n     while ( TRUE )\n     {\n-        if ( extract_one_file(epub_document,&err) == FALSE )\n+        if ( extract_one_file(epub_document, tmp_gfile, &err) == FALSE )\n         {\n             if (err) {\n                 g_propagate_error (error, err);\n@@ -87,6 +89,7 @@\n     }\n \n out:\n+    g_clear_object (&tmp_gfile);\n     unzClose(epub_document->epubDocument);\n     return result;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        if ( extract_one_file(epub_document,&err) == FALSE )"
            ],
            "added_lines": [
                "    GFile *tmp_gfile = NULL;",
                "    tmp_gfile = g_file_new_for_path (epub_document->tmp_archive_dir);",
                "        if ( extract_one_file(epub_document, tmp_gfile, &err) == FALSE )",
                "    g_clear_object (&tmp_gfile);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52076",
        "func_name": "mate-desktop/atril/check_mime_type",
        "description": "Atril Document Viewer is the default document reader of the MATE desktop environment for Linux. A path traversal and arbitrary file write vulnerability exists in versions of Atril prior to 1.26.2. This vulnerability is capable of writing arbitrary files anywhere on the filesystem to which the user opening a crafted document has access. The only limitation is that this vulnerability cannot be exploited to overwrite existing files, but that doesn't stop an attacker from achieving Remote Command Execution on the target system. Version 1.26.2 of Atril contains a patch for this vulnerability.",
        "git_url": "https://github.com/mate-desktop/atril/commit/e70b21c815418a1e6ebedf6d8d31b8477c03ba50",
        "commit_title": "epub: Prevent path traversal when extracting files",
        "commit_text": " Test each file's resolved path against the temporary directory before extracting.",
        "func_before": "static gboolean\ncheck_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n\t}\n\n        /* fallback for malformed epub files */\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n\n                /*We didn't find a match*/\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n\n                return FALSE;\n            }\n        }\n    }\n\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n\n    return FALSE;\n}",
        "func": "static gboolean\ncheck_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n        }\n\n        /* fallback for malformed epub files */\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n\n                /*We didn't find a match*/\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n\n                return FALSE;\n            }\n        }\n    }\n\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n         for (i = 0; i < g_strv_length (mimetypes); i++) {\n            if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                 return TRUE;\n-\t}\n+        }\n \n         /* fallback for malformed epub files */\n         if (strcmp (mimeFromFile, \"application/zip\") == 0)",
        "diff_line_info": {
            "deleted_lines": [
                "\t}"
            ],
            "added_lines": [
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52076",
        "func_name": "mate-desktop/atril/extract_one_file",
        "description": "Atril Document Viewer is the default document reader of the MATE desktop environment for Linux. A path traversal and arbitrary file write vulnerability exists in versions of Atril prior to 1.26.2. This vulnerability is capable of writing arbitrary files anywhere on the filesystem to which the user opening a crafted document has access. The only limitation is that this vulnerability cannot be exploited to overwrite existing files, but that doesn't stop an attacker from achieving Remote Command Execution on the target system. Version 1.26.2 of Atril contains a patch for this vulnerability.",
        "git_url": "https://github.com/mate-desktop/atril/commit/e70b21c815418a1e6ebedf6d8d31b8477c03ba50",
        "commit_title": "epub: Prevent path traversal when extracting files",
        "commit_text": " Test each file's resolved path against the temporary directory before extracting.",
        "func_before": "static gboolean\nextract_one_file(EpubDocument* epub_document,GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n\n    gboolean result = TRUE;\n\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n\n    if ( directory != NULL )\n        directory++;\n\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n\n    /*if we encounter a directory, make a directory inside our temporary folder.*/\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        /*Since a substring can't be longer than the parent string, allocating space equal to the parent's size should suffice*/\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        /* Add the name of the directory and subdirectories,if any to a buffer and then create it */\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n\n    outfile = g_file_new_for_path(gfilepath->str);\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outfile) ;\n    g_object_unref(outstream) ;\n\nout:\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}",
        "func": "static gboolean\nextract_one_file(EpubDocument* epub_document, GFile *tmp_gfile, GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n\n    gboolean result = TRUE;\n\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n\n    if ( directory != NULL )\n        directory++;\n\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n\n    outfile = g_file_new_for_path (gfilepath->str);\n    g_autofree gchar *rpath = g_file_get_relative_path (tmp_gfile, outfile);\n\n    if (rpath == NULL)\n    {\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"epub file is invalid or corrupt\"));\n        g_critical (\"Invalid filename in Epub container - '%s'\", (gchar *) currentfilename);\n        result = FALSE;\n        goto out;\n    }\n\n    /*if we encounter a directory, make a directory inside our temporary folder.*/\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        /*Since a substring can't be longer than the parent string, allocating space equal to the parent's size should suffice*/\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        /* Add the name of the directory and subdirectories,if any to a buffer and then create it */\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outstream);\n\nout:\n    g_object_unref(outfile);\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static gboolean\n-extract_one_file(EpubDocument* epub_document,GError ** error)\n+extract_one_file(EpubDocument* epub_document, GFile *tmp_gfile, GError ** error)\n {\n     GFile * outfile ;\n     gsize writesize = 0;\n@@ -25,6 +25,20 @@\n \n     gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n     g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n+\n+    outfile = g_file_new_for_path (gfilepath->str);\n+    g_autofree gchar *rpath = g_file_get_relative_path (tmp_gfile, outfile);\n+\n+    if (rpath == NULL)\n+    {\n+        g_set_error_literal (error,\n+                             EV_DOCUMENT_ERROR,\n+                             EV_DOCUMENT_ERROR_INVALID,\n+                             _(\"epub file is invalid or corrupt\"));\n+        g_critical (\"Invalid filename in Epub container - '%s'\", (gchar *) currentfilename);\n+        result = FALSE;\n+        goto out;\n+    }\n \n     /*if we encounter a directory, make a directory inside our temporary folder.*/\n     if (directory != NULL && *directory == '\\0')\n@@ -53,7 +67,6 @@\n         g_string_free(dir_create,TRUE);\n     }\n \n-    outfile = g_file_new_for_path(gfilepath->str);\n     outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n     gpointer buffer = g_malloc0(512);\n     while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n@@ -66,10 +79,10 @@\n     }\n     g_free(buffer);\n     g_output_stream_close((GOutputStream*)outstream,NULL,error);\n-    g_object_unref(outfile) ;\n-    g_object_unref(outstream) ;\n+    g_object_unref(outstream);\n \n out:\n+    g_object_unref(outfile);\n     unzCloseCurrentFile (epub_document->epubDocument) ;\n     g_string_free(gfilepath,TRUE);\n     g_free(currentfilename);",
        "diff_line_info": {
            "deleted_lines": [
                "extract_one_file(EpubDocument* epub_document,GError ** error)",
                "    outfile = g_file_new_for_path(gfilepath->str);",
                "    g_object_unref(outfile) ;",
                "    g_object_unref(outstream) ;"
            ],
            "added_lines": [
                "extract_one_file(EpubDocument* epub_document, GFile *tmp_gfile, GError ** error)",
                "",
                "    outfile = g_file_new_for_path (gfilepath->str);",
                "    g_autofree gchar *rpath = g_file_get_relative_path (tmp_gfile, outfile);",
                "",
                "    if (rpath == NULL)",
                "    {",
                "        g_set_error_literal (error,",
                "                             EV_DOCUMENT_ERROR,",
                "                             EV_DOCUMENT_ERROR_INVALID,",
                "                             _(\"epub file is invalid or corrupt\"));",
                "        g_critical (\"Invalid filename in Epub container - '%s'\", (gchar *) currentfilename);",
                "        result = FALSE;",
                "        goto out;",
                "    }",
                "    g_object_unref(outstream);",
                "    g_object_unref(outfile);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52138",
        "func_name": "mate-desktop/engrampa/fr_command_cpio_get_capabilities",
        "description": "Engrampa is an archive manager for the MATE environment. Engrampa is found to be vulnerable to a Path Traversal vulnerability that can be leveraged to achieve full Remote Command Execution (RCE) on the target. While handling CPIO archives, the Engrampa Archive manager follows symlink, cpio by default will follow stored symlinks while extracting and the Archiver will not check the symlink location, which leads to arbitrary file writes to unintended locations. When the victim extracts the archive, the attacker can craft a malicious cpio or ISO archive to achieve RCE on the target system. This vulnerability was fixed in commit 63d5dfa.\n",
        "git_url": "https://github.com/mate-desktop/engrampa/commit/63d5dfa9005c6b16d0f0ccd888cc859fca78f970",
        "commit_title": "Use unar instead of cpio for CPIO archives",
        "commit_text": "",
        "func_before": "static FrCommandCaps\nfr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\n\treturn capabilities;\n}",
        "func": "static FrCommandCaps\nfr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n/*\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;*/\n\n\treturn capabilities;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,8 @@\n \tFrCommandCaps capabilities;\n \n \tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n-\tif (is_program_available (CPIO_PATH, check_command))\n-\t\tcapabilities |= FR_COMMAND_CAN_READ;\n+/*\tif (is_program_available (CPIO_PATH, check_command))\n+\t\tcapabilities |= FR_COMMAND_CAN_READ;*/\n \n \treturn capabilities;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (is_program_available (CPIO_PATH, check_command))",
                "\t\tcapabilities |= FR_COMMAND_CAN_READ;"
            ],
            "added_lines": [
                "/*\tif (is_program_available (CPIO_PATH, check_command))",
                "\t\tcapabilities |= FR_COMMAND_CAN_READ;*/"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/libreport/create_dump_dir_from_problem_data",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
        "commit_title": "dd: harden functions against directory traversal issues",
        "commit_text": " Test correctness of all accessed dump dir files in all dd* functions. Before this commit, the callers were allowed to pass strings like \"../../etc/shadow\" in the filename argument of all dd* functions.  Related: #1214457 ",
        "func_before": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);\n\n    if (!type)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    uid_t uid = (uid_t)-1L;\n    char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);\n\n    if (uid_str)\n    {\n        char *endptr;\n        errno = 0;\n        long val = strtol(uid_str, &endptr, 10);\n\n        if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), uid_str);\n            return NULL;\n        }\n\n        uid = (uid_t)val;\n    }\n\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *problem_id = xasprintf(\"%s-%s.%ld-%lu\"NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", base_dir_name, problem_id, uid);\n\n    struct dump_dir *dd;\n    if (base_dir_name)\n        dd = try_dd_create(base_dir_name, problem_id, uid);\n    else\n    {\n        /* Try /var/run/abrt */\n        dd = try_dd_create(LOCALSTATEDIR\"/run/abrt\", problem_id, uid);\n        /* Try $HOME/tmp */\n        if (!dd)\n        {\n            char *home = getenv(\"HOME\");\n            if (home && home[0])\n            {\n                home = concat_path_file(home, \"tmp\");\n                /*mkdir(home, 0777); - do we want this? */\n                dd = try_dd_create(home, problem_id, uid);\n                free(home);\n            }\n        }\n//TODO: try user's home dir obtained by getpwuid(getuid())?\n        /* Try system temporary directory */\n        if (!dd)\n            dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);\n    }\n\n    if (!dd) /* try_dd_create() already emitted the error message */\n        goto ret;\n\n    GHashTableIter iter;\n    char *name;\n    struct problem_item *value;\n    g_hash_table_iter_init(&iter, problem_data);\n    while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n    {\n        if (value->flags & CD_FLAG_BIN)\n        {\n            char *dest = concat_path_file(dd->dd_dirname, name);\n            log_info(\"copying '%s' to '%s'\", value->content, dest);\n            off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);\n            if (copied < 0)\n                error_msg(\"Can't copy %s to %s\", value->content, dest);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)copied);\n            free(dest);\n\n            continue;\n        }\n\n        /* only files should contain '/' and those are handled earlier */\n        if (name[0] == '.' || strchr(name, '/'))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        dd_save_text(dd, name, value->content);\n    }\n\n    /* need to create basic files AFTER we save the pd to dump_dir\n     * otherwise we can't skip already created files like in case when\n     * reporting from anaconda where we can't read /etc/{system,redhat}-release\n     * and os_release is taken from anaconda\n     */\n    dd_create_basic_files(dd, uid, NULL);\n\n    problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';\n    char* new_path = concat_path_file(base_dir_name, problem_id);\n    log_info(\"Renaming from '%s' to '%s'\", dd->dd_dirname, new_path);\n    dd_rename(dd, new_path);\n\n ret:\n    free(problem_id);\n    return dd;\n}",
        "func": "struct dump_dir *create_dump_dir_from_problem_data(problem_data_t *problem_data, const char *base_dir_name)\n{\n    INITIALIZE_LIBREPORT();\n\n    char *type = problem_data_get_content_or_NULL(problem_data, FILENAME_ANALYZER);\n\n    if (!type)\n    {\n        error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    if (!str_is_correct_filename(type))\n    {\n        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);\n        return NULL;\n    }\n\n    uid_t uid = (uid_t)-1L;\n    char *uid_str = problem_data_get_content_or_NULL(problem_data, FILENAME_UID);\n\n    if (uid_str)\n    {\n        char *endptr;\n        errno = 0;\n        long val = strtol(uid_str, &endptr, 10);\n\n        if (errno != 0 || endptr == uid_str || *endptr != '\\0' || INT_MAX < val)\n        {\n            error_msg(_(\"uid value is not valid: '%s'\"), uid_str);\n            return NULL;\n        }\n\n        uid = (uid_t)val;\n    }\n\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) < 0)\n    {\n        perror_msg(\"gettimeofday()\");\n        return NULL;\n    }\n\n    char *problem_id = xasprintf(\"%s-%s.%ld-%lu\"NEW_PD_SUFFIX, type, iso_date_string(&(tv.tv_sec)), (long)tv.tv_usec, (long)getpid());\n\n    log_info(\"Saving to %s/%s with uid %d\", base_dir_name, problem_id, uid);\n\n    struct dump_dir *dd;\n    if (base_dir_name)\n        dd = try_dd_create(base_dir_name, problem_id, uid);\n    else\n    {\n        /* Try /var/run/abrt */\n        dd = try_dd_create(LOCALSTATEDIR\"/run/abrt\", problem_id, uid);\n        /* Try $HOME/tmp */\n        if (!dd)\n        {\n            char *home = getenv(\"HOME\");\n            if (home && home[0])\n            {\n                home = concat_path_file(home, \"tmp\");\n                /*mkdir(home, 0777); - do we want this? */\n                dd = try_dd_create(home, problem_id, uid);\n                free(home);\n            }\n        }\n//TODO: try user's home dir obtained by getpwuid(getuid())?\n        /* Try system temporary directory */\n        if (!dd)\n            dd = try_dd_create(LARGE_DATA_TMP_DIR, problem_id, uid);\n    }\n\n    if (!dd) /* try_dd_create() already emitted the error message */\n        goto ret;\n\n    GHashTableIter iter;\n    char *name;\n    struct problem_item *value;\n    g_hash_table_iter_init(&iter, problem_data);\n    while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n    {\n        if (!str_is_correct_filename(name))\n        {\n            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n            continue;\n        }\n\n        if (value->flags & CD_FLAG_BIN)\n        {\n            char *dest = concat_path_file(dd->dd_dirname, name);\n            log_info(\"copying '%s' to '%s'\", value->content, dest);\n            off_t copied = copy_file(value->content, dest, DEFAULT_DUMP_DIR_MODE | S_IROTH);\n            if (copied < 0)\n                error_msg(\"Can't copy %s to %s\", value->content, dest);\n            else\n                log_info(\"copied %li bytes\", (unsigned long)copied);\n            free(dest);\n\n            continue;\n        }\n\n        dd_save_text(dd, name, value->content);\n    }\n\n    /* need to create basic files AFTER we save the pd to dump_dir\n     * otherwise we can't skip already created files like in case when\n     * reporting from anaconda where we can't read /etc/{system,redhat}-release\n     * and os_release is taken from anaconda\n     */\n    dd_create_basic_files(dd, uid, NULL);\n\n    problem_id[strlen(problem_id) - strlen(NEW_PD_SUFFIX)] = '\\0';\n    char* new_path = concat_path_file(base_dir_name, problem_id);\n    log_info(\"Renaming from '%s' to '%s'\", dd->dd_dirname, new_path);\n    dd_rename(dd, new_path);\n\n ret:\n    free(problem_id);\n    return dd;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,12 @@\n     if (!type)\n     {\n         error_msg(_(\"Missing required item: '%s'\"), FILENAME_ANALYZER);\n+        return NULL;\n+    }\n+\n+    if (!str_is_correct_filename(type))\n+    {\n+        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);\n         return NULL;\n     }\n \n@@ -73,6 +79,12 @@\n     g_hash_table_iter_init(&iter, problem_data);\n     while (g_hash_table_iter_next(&iter, (void**)&name, (void**)&value))\n     {\n+        if (!str_is_correct_filename(name))\n+        {\n+            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n+            continue;\n+        }\n+\n         if (value->flags & CD_FLAG_BIN)\n         {\n             char *dest = concat_path_file(dd->dd_dirname, name);\n@@ -84,13 +96,6 @@\n                 log_info(\"copied %li bytes\", (unsigned long)copied);\n             free(dest);\n \n-            continue;\n-        }\n-\n-        /* only files should contain '/' and those are handled earlier */\n-        if (name[0] == '.' || strchr(name, '/'))\n-        {\n-            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);\n             continue;\n         }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "            continue;",
                "        }",
                "",
                "        /* only files should contain '/' and those are handled earlier */",
                "        if (name[0] == '.' || strchr(name, '/'))",
                "        {",
                "            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);"
            ],
            "added_lines": [
                "        return NULL;",
                "    }",
                "",
                "    if (!str_is_correct_filename(type))",
                "    {",
                "        error_msg(_(\"'%s' is not correct file name\"), FILENAME_ANALYZER);",
                "        if (!str_is_correct_filename(name))",
                "        {",
                "            error_msg(\"Problem data field name contains disallowed chars: '%s'\", name);",
                "            continue;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/libreport/dd_load_text_ext",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
        "commit_title": "dd: harden functions against directory traversal issues",
        "commit_text": " Test correctness of all accessed dump dir files in all dd* functions. Before this commit, the callers were allowed to pass strings like \"../../etc/shadow\" in the filename argument of all dd* functions.  Related: #1214457 ",
        "func_before": "char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)\n{\n//    if (!dd->locked)\n//        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    /* Compat with old abrt dumps. Remove in abrt-2.1 */\n    if (strcmp(name, \"release\") == 0)\n        name = FILENAME_OS_RELEASE;\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    char *ret = load_text_file(full_path, flags);\n    free(full_path);\n\n    return ret;\n}",
        "func": "char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)\n{\n//    if (!dd->locked)\n//        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n    {\n        error_msg(\"Cannot load text. '%s' is not a valid file name\", name);\n        if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))\n            xfunc_die();\n    }\n\n    /* Compat with old abrt dumps. Remove in abrt-2.1 */\n    if (strcmp(name, \"release\") == 0)\n        name = FILENAME_OS_RELEASE;\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    char *ret = load_text_file(full_path, flags);\n    free(full_path);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,13 @@\n {\n //    if (!dd->locked)\n //        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n+\n+    if (!str_is_correct_filename(name))\n+    {\n+        error_msg(\"Cannot load text. '%s' is not a valid file name\", name);\n+        if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))\n+            xfunc_die();\n+    }\n \n     /* Compat with old abrt dumps. Remove in abrt-2.1 */\n     if (strcmp(name, \"release\") == 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (!str_is_correct_filename(name))",
                "    {",
                "        error_msg(\"Cannot load text. '%s' is not a valid file name\", name);",
                "        if (!(flags & DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE))",
                "            xfunc_die();",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/libreport/dd_get_item_size",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
        "commit_title": "dd: harden functions against directory traversal issues",
        "commit_text": " Test correctness of all accessed dump dir files in all dd* functions. Before this commit, the callers were allowed to pass strings like \"../../etc/shadow\" in the filename argument of all dd* functions.  Related: #1214457 ",
        "func_before": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}",
        "func": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);\n\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n long dd_get_item_size(struct dump_dir *dd, const char *name)\n {\n+    if (!str_is_correct_filename(name))\n+        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);\n+\n     long size = -1;\n     char *iname = concat_path_file(dd->dd_dirname, name);\n     struct stat statbuf;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!str_is_correct_filename(name))",
                "        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/libreport/dd_exist",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
        "commit_title": "dd: harden functions against directory traversal issues",
        "commit_text": " Test correctness of all accessed dump dir files in all dd* functions. Before this commit, the callers were allowed to pass strings like \"../../etc/shadow\" in the filename argument of all dd* functions.  Related: #1214457 ",
        "func_before": "int dd_exist(const struct dump_dir *dd, const char *path)\n{\n    char *full_path = concat_path_file(dd->dd_dirname, path);\n    int ret = exist_file_dir(full_path);\n    free(full_path);\n    return ret;\n}",
        "func": "int dd_exist(const struct dump_dir *dd, const char *path)\n{\n    if (!str_is_correct_filename(path))\n        error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);\n\n    char *full_path = concat_path_file(dd->dd_dirname, path);\n    int ret = exist_file_dir(full_path);\n    free(full_path);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n int dd_exist(const struct dump_dir *dd, const char *path)\n {\n+    if (!str_is_correct_filename(path))\n+        error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);\n+\n     char *full_path = concat_path_file(dd->dd_dirname, path);\n     int ret = exist_file_dir(full_path);\n     free(full_path);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!str_is_correct_filename(path))",
                "        error_msg_and_die(\"Cannot test existence. '%s' is not a valid file name\", path);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/libreport/dd_save_text",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
        "commit_title": "dd: harden functions against directory traversal issues",
        "commit_text": " Test correctness of all accessed dump dir files in all dd* functions. Before this commit, the callers were allowed to pass strings like \"../../etc/shadow\" in the filename argument of all dd* functions.  Related: #1214457 ",
        "func_before": "void dd_save_text(struct dump_dir *dd, const char *name, const char *data)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}",
        "func": "void dd_save_text(struct dump_dir *dd, const char *name, const char *data)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n     if (!dd->locked)\n         error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n \n+    if (!str_is_correct_filename(name))\n+        error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);\n+\n     char *full_path = concat_path_file(dd->dd_dirname, name);\n     save_binary_file(full_path, data, strlen(data), dd->dd_uid, dd->dd_gid, dd->mode);\n     free(full_path);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!str_is_correct_filename(name))",
                "        error_msg_and_die(\"Cannot save text. '%s' is not a valid file name\", name);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/libreport/dd_save_binary",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
        "commit_title": "dd: harden functions against directory traversal issues",
        "commit_text": " Test correctness of all accessed dump dir files in all dd* functions. Before this commit, the callers were allowed to pass strings like \"../../etc/shadow\" in the filename argument of all dd* functions.  Related: #1214457 ",
        "func_before": "void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}",
        "func": "void dd_save_binary(struct dump_dir* dd, const char* name, const char* data, unsigned size)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);\n    free(full_path);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n     if (!dd->locked)\n         error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n \n+    if (!str_is_correct_filename(name))\n+        error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);\n+\n     char *full_path = concat_path_file(dd->dd_dirname, name);\n     save_binary_file(full_path, data, size, dd->dd_uid, dd->dd_gid, dd->mode);\n     free(full_path);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!str_is_correct_filename(name))",
                "        error_msg_and_die(\"Cannot save binary. '%s' is not a valid file name\", name);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/libreport/dd_delete_item",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/libreport/commit/239c4f7d1f47265526b39ad70106767d00805277",
        "commit_title": "dd: harden functions against directory traversal issues",
        "commit_text": " Test correctness of all accessed dump dir files in all dd* functions. Before this commit, the callers were allowed to pass strings like \"../../etc/shadow\" in the filename argument of all dd* functions.  Related: #1214457 ",
        "func_before": "int dd_delete_item(struct dump_dir *dd, const char *name)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    char *path = concat_path_file(dd->dd_dirname, name);\n    int res = unlink(path);\n\n    if (res < 0)\n    {\n        if (errno == ENOENT)\n            errno = res = 0;\n        else\n            perror_msg(\"Can't delete file '%s'\", path);\n    }\n\n    free(path);\n    return res;\n}",
        "func": "int dd_delete_item(struct dump_dir *dd, const char *name)\n{\n    if (!dd->locked)\n        error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);\n\n    char *path = concat_path_file(dd->dd_dirname, name);\n    int res = unlink(path);\n\n    if (res < 0)\n    {\n        if (errno == ENOENT)\n            errno = res = 0;\n        else\n            perror_msg(\"Can't delete file '%s'\", path);\n    }\n\n    free(path);\n    return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,9 @@\n {\n     if (!dd->locked)\n         error_msg_and_die(\"dump_dir is not opened\"); /* bug */\n+\n+    if (!str_is_correct_filename(name))\n+        error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);\n \n     char *path = concat_path_file(dd->dd_dirname, name);\n     int res = unlink(path);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (!str_is_correct_filename(name))",
                "        error_msg_and_die(\"Cannot delete item. '%s' is not a valid file name\", name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/handle_method_call",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/abrt/commit/7a47f57975be0d285a2f20758e4572dca6d9cdd3",
        "commit_title": "dbus: validate parameters of all calls",
        "commit_text": " SetElement and DeleteElement were missing check for valid dump directory path.  FindProblemByElementInTimeRange was not reporting invalid element names.  Related: #1214451 ",
        "func_before": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
        "func": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!allowed_problem_dir(problem_id))\n        {\n            return_InvalidProblemDir_error(invocation, problem_id);\n            return;\n        }\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name\", element);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -256,6 +256,12 @@\n \n         g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n \n+        if (!allowed_problem_dir(problem_id))\n+        {\n+            return_InvalidProblemDir_error(invocation, problem_id);\n+            return;\n+        }\n+\n         if (!str_is_correct_filename(element))\n         {\n             log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n@@ -314,6 +320,12 @@\n         const char *element;\n \n         g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n+\n+        if (!allowed_problem_dir(problem_id))\n+        {\n+            return_InvalidProblemDir_error(invocation, problem_id);\n+            return;\n+        }\n \n         if (!str_is_correct_filename(element))\n         {\n@@ -432,6 +444,18 @@\n         g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n         g_variant_get_child(parameters, 4, \"b\", &all);\n \n+        if (!str_is_correct_filename(element))\n+        {\n+            log_notice(\"'%s' is not a valid element name\", element);\n+            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n+            g_dbus_method_invocation_return_dbus_error(invocation,\n+                                              \"org.freedesktop.problems.InvalidElement\",\n+                                              error);\n+\n+            free(error);\n+            return;\n+        }\n+\n         if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n             caller_uid = 0;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (!allowed_problem_dir(problem_id))",
                "        {",
                "            return_InvalidProblemDir_error(invocation, problem_id);",
                "            return;",
                "        }",
                "",
                "",
                "        if (!allowed_problem_dir(problem_id))",
                "        {",
                "            return_InvalidProblemDir_error(invocation, problem_id);",
                "            return;",
                "        }",
                "        if (!str_is_correct_filename(element))",
                "        {",
                "            log_notice(\"'%s' is not a valid element name\", element);",
                "            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);",
                "            g_dbus_method_invocation_return_dbus_error(invocation,",
                "                                              \"org.freedesktop.problems.InvalidElement\",",
                "                                              error);",
                "",
                "            free(error);",
                "            return;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/key_value_ok",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/abrt/commit/c796c76341ee846cfb897ed645bac211d7d0a932",
        "commit_title": "daemon: use libreport's function checking file name",
        "commit_text": " Move the functions to libreport because we need the same functionality there too.  Related: #1214451 ",
        "func_before": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
        "func": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n      || strcmp(key, FILENAME_TYPE) == 0\n     )\n     {\n-        if (!is_correct_filename(value))\n+        if (!str_is_correct_filename(value))\n         {\n             error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                       key, value);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!is_correct_filename(value))"
            ],
            "added_lines": [
                "        if (!str_is_correct_filename(value))"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3151",
        "func_name": "abrt/handle_method_call",
        "description": "Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.",
        "git_url": "https://github.com/abrt/abrt/commit/f3c2a6af3455b2882e28570e8a04f1c2d4500d5b",
        "commit_title": "dbus: report invalid element names",
        "commit_text": " Return D-Bus error in case of invalid problem element name.  Related: #1214451 ",
        "func_before": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (element == NULL || element[0] == '\\0' || strlen(element) > 64)\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
        "func": "static void handle_method_call(GDBusConnection *connection,\n                        const gchar *caller,\n                        const gchar *object_path,\n                        const gchar *interface_name,\n                        const gchar *method_name,\n                        GVariant    *parameters,\n                        GDBusMethodInvocation *invocation,\n                        gpointer    user_data)\n{\n    reset_timeout();\n\n    uid_t caller_uid;\n    GVariant *response;\n\n    caller_uid = get_caller_uid(connection, invocation, caller);\n\n    log_notice(\"caller_uid:%ld method:'%s'\", (long)caller_uid, method_name);\n\n    if (caller_uid == (uid_t) -1)\n        return;\n\n    if (g_strcmp0(method_name, \"NewProblem\") == 0)\n    {\n        char *error = NULL;\n        char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error);\n        if (!problem_id)\n        {\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            free(error);\n            return;\n        }\n        /* else */\n        response = g_variant_new(\"(s)\", problem_id);\n        g_dbus_method_invocation_return_value(invocation, response);\n        free(problem_id);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetProblems\") == 0)\n    {\n        GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        //I was told that g_dbus_method frees the response\n        //g_variant_unref(response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetAllProblems\") == 0)\n    {\n        /*\n        - so, we have UID,\n        - if it's 0, then we don't have to check anything and just return all directories\n        - if uid != 0 then we want to ask for authorization\n        */\n        if (caller_uid != 0)\n        {\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n                caller_uid = 0;\n        }\n\n        GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetForeignProblems\") == 0)\n    {\n        GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"ChownProblemDir\") == 0)\n    {\n        const gchar *problem_dir;\n        g_variant_get(parameters, \"(&s)\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid);\n        if (ddstat < 0)\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"requested directory does not exist '%s'\", problem_dir);\n            }\n            else\n            {\n                perror_msg(\"can't get stat of '%s'\", problem_dir);\n            }\n\n            return_InvalidProblemDir_error(invocation, problem_dir);\n\n            close(dir_fd);\n            return;\n        }\n\n        if (ddstat & DD_STAT_OWNED_BY_UID)\n        {   //caller seems to be in group with access to this dir, so no action needed\n            log_notice(\"caller has access to the requested directory %s\", problem_dir);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n            close(dir_fd);\n            return;\n        }\n\n        if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 &&\n                polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n        {\n            log_notice(\"not authorized\");\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.AuthFailure\",\n                                              _(\"Not Authorized\"));\n            close(dir_fd);\n            return;\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int chown_res = dd_chown(dd, caller_uid);\n        if (chown_res != 0)\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.ChownError\",\n                                              _(\"Chowning directory failed. Check system logs for more details.\"));\n        else\n            g_dbus_method_invocation_return_value(invocation, NULL);\n\n        dd_close(dd);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"GetInfo\") == 0)\n    {\n        /* Parameter tuple is (sas) */\n\n\t/* Get 1st param - problem dir name */\n        const gchar *problem_dir;\n        g_variant_get_child(parameters, 0, \"&s\", &problem_dir);\n        log_notice(\"problem_dir:'%s'\", problem_dir);\n\n        if (!allowed_problem_dir(problem_dir))\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        int dir_fd = dd_openfd(problem_dir);\n        if (dir_fd < 0)\n        {\n            perror_msg(\"can't open problem directory '%s'\", problem_dir);\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n        if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n        {\n            if (errno == ENOTDIR)\n            {\n                log_notice(\"Requested directory does not exist '%s'\", problem_dir);\n                return_InvalidProblemDir_error(invocation, problem_dir);\n                close(dir_fd);\n                return;\n            }\n\n            if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n            {\n                log_notice(\"not authorized\");\n                g_dbus_method_invocation_return_dbus_error(invocation,\n                                                  \"org.freedesktop.problems.AuthFailure\",\n                                                  _(\"Not Authorized\"));\n                close(dir_fd);\n                return;\n            }\n        }\n\n        struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES);\n        if (!dd)\n        {\n            return_InvalidProblemDir_error(invocation, problem_dir);\n            return;\n        }\n\n\t/* Get 2nd param - vector of element names */\n        GVariant *array = g_variant_get_child_value(parameters, 1);\n        GList *elements = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        GVariantBuilder *builder = NULL;\n        for (GList *l = elements; l; l = l->next)\n        {\n            const char *element_name = (const char*)l->data;\n            char *value = dd_load_text_ext(dd, element_name, 0\n                                                | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE\n                                                | DD_FAIL_QUIETLY_ENOENT\n                                                | DD_FAIL_QUIETLY_EACCES);\n            log_notice(\"element '%s' %s\", element_name, value ? \"fetched\" : \"not found\");\n            if (value)\n            {\n                if (!builder)\n                    builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY);\n\n                /* g_variant_builder_add makes a copy. No need to xstrdup here */\n                g_variant_builder_add(builder, \"{ss}\", element_name, value);\n                free(value);\n            }\n        }\n        list_free_with_free(elements);\n        dd_close(dd);\n        /* It is OK to call g_variant_new(\"(a{ss})\", NULL) because */\n        /* G_VARIANT_TYPE_TUPLE allows NULL value */\n        GVariant *response = g_variant_new(\"(a{ss})\", builder);\n\n        if (builder)\n            g_variant_builder_unref(builder);\n\n        log_info(\"GetInfo: returning value for '%s'\", problem_dir);\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"SetElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n        const char *value;\n\n        g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        /* Is it good idea to make it static? Is it possible to change the max size while a single run? */\n        const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024);\n        const long item_size = dd_get_item_size(dd, element);\n        if (item_size < 0)\n        {\n            log_notice(\"Can't get size of '%s/%s'\", problem_id, element);\n            char *error = xasprintf(_(\"Can't get size of '%s'\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      error);\n            return;\n        }\n\n        const double requested_size = (double)strlen(value) - item_size;\n        /* Don't want to check the size limit in case of reducing of size */\n        if (requested_size > 0\n            && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location)))\n        {\n            log_notice(\"No problem space left in '%s' (requested Bytes %f)\", problem_id, requested_size);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                                      \"org.freedesktop.problems.Failure\",\n                                                      _(\"No problem space left\"));\n        }\n        else\n        {\n            dd_save_text(dd, element, value);\n            g_dbus_method_invocation_return_value(invocation, NULL);\n        }\n\n        dd_close(dd);\n\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteElement\") == 0)\n    {\n        const char *problem_id;\n        const char *element;\n\n        g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n\n        if (!str_is_correct_filename(element))\n        {\n            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                              \"org.freedesktop.problems.InvalidElement\",\n                                              error);\n\n            free(error);\n            return;\n        }\n\n        struct dump_dir *dd = open_directory_for_modification_of_element(\n                                    invocation, caller_uid, problem_id, element);\n        if (!dd)\n            /* Already logged from open_directory_for_modification_of_element() */\n            return;\n\n        const int res = dd_delete_item(dd, element);\n        dd_close(dd);\n\n        if (res != 0)\n        {\n            log_notice(\"Can't delete the element '%s' from the problem directory '%s'\", element, problem_id);\n            char *error = xasprintf(_(\"Can't delete the element '%s' from the problem directory '%s'\"), element, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                          \"org.freedesktop.problems.Failure\",\n                                          error);\n            free(error);\n            return;\n        }\n\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"DeleteProblem\") == 0)\n    {\n        /* Dbus parameters are always tuples.\n         * In this case, it's (as) - a tuple of one element (array of strings).\n         * Need to fetch the array:\n         */\n        GVariant *array = g_variant_get_child_value(parameters, 0);\n        GList *problem_dirs = string_list_from_variant(array);\n        g_variant_unref(array);\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n            log_notice(\"dir_name:'%s'\", dir_name);\n            if (!allowed_problem_dir(dir_name))\n            {\n                return_InvalidProblemDir_error(invocation, dir_name);\n                goto ret;\n            }\n        }\n\n        for (GList *l = problem_dirs; l; l = l->next)\n        {\n            const char *dir_name = (const char*)l->data;\n\n            int dir_fd = dd_openfd(dir_name);\n            if (dir_fd < 0)\n            {\n                perror_msg(\"can't open problem directory '%s'\", dir_name);\n                return_InvalidProblemDir_error(invocation, dir_name);\n                return;\n            }\n\n            if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid))\n            {\n                if (errno == ENOTDIR)\n                {\n                    log_notice(\"Requested directory does not exist '%s'\", dir_name);\n                    close(dir_fd);\n                    continue;\n                }\n\n                if (polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") != PolkitYes)\n                { // if user didn't provide correct credentials, just move to the next dir\n                    close(dir_fd);\n                    continue;\n                }\n            }\n\n            struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name, /*flags:*/ 0);\n            if (dd)\n            {\n                if (dd_delete(dd) != 0)\n                {\n                    error_msg(\"Failed to delete problem directory '%s'\", dir_name);\n                    dd_close(dd);\n                }\n            }\n        }\n\n        g_dbus_method_invocation_return_value(invocation, NULL);\n ret:\n        list_free_with_free(problem_dirs);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"FindProblemByElementInTimeRange\") == 0)\n    {\n        const gchar *element;\n        const gchar *value;\n        glong timestamp_from;\n        glong timestamp_to;\n        gboolean all;\n\n        g_variant_get_child(parameters, 0, \"&s\", &element);\n        g_variant_get_child(parameters, 1, \"&s\", &value);\n        g_variant_get_child(parameters, 2, \"x\", &timestamp_from);\n        g_variant_get_child(parameters, 3, \"x\", &timestamp_to);\n        g_variant_get_child(parameters, 4, \"b\", &all);\n\n        if (all && polkit_check_authorization_dname(caller, \"org.freedesktop.problems.getall\") == PolkitYes)\n            caller_uid = 0;\n\n        GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from,\n                                                        timestamp_to);\n        response = variant_from_string_list(dirs);\n        list_free_with_free(dirs);\n\n        g_dbus_method_invocation_return_value(invocation, response);\n        return;\n    }\n\n    if (g_strcmp0(method_name, \"Quit\") == 0)\n    {\n        g_dbus_method_invocation_return_value(invocation, NULL);\n        g_main_loop_quit(loop);\n        return;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -256,7 +256,7 @@\n \n         g_variant_get(parameters, \"(&s&s&s)\", &problem_id, &element, &value);\n \n-        if (element == NULL || element[0] == '\\0' || strlen(element) > 64)\n+        if (!str_is_correct_filename(element))\n         {\n             log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n             char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n@@ -314,6 +314,18 @@\n         const char *element;\n \n         g_variant_get(parameters, \"(&s&s)\", &problem_id, &element);\n+\n+        if (!str_is_correct_filename(element))\n+        {\n+            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);\n+            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);\n+            g_dbus_method_invocation_return_dbus_error(invocation,\n+                                              \"org.freedesktop.problems.InvalidElement\",\n+                                              error);\n+\n+            free(error);\n+            return;\n+        }\n \n         struct dump_dir *dd = open_directory_for_modification_of_element(\n                                     invocation, caller_uid, problem_id, element);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (element == NULL || element[0] == '\\0' || strlen(element) > 64)"
            ],
            "added_lines": [
                "        if (!str_is_correct_filename(element))",
                "",
                "        if (!str_is_correct_filename(element))",
                "        {",
                "            log_notice(\"'%s' is not a valid element name of '%s'\", element, problem_id);",
                "            char *error = xasprintf(_(\"'%s' is not a valid element name\"), element);",
                "            g_dbus_method_invocation_return_dbus_error(invocation,",
                "                                              \"org.freedesktop.problems.InvalidElement\",",
                "                                              error);",
                "",
                "            free(error);",
                "            return;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45866",
        "func_name": "PierreLvx/qpress/decompress_directory",
        "description": "qpress before PierreLvx/qpress 20220819 and before version 11.3, as used in Percona XtraBackup and other products, allows directory traversal via ../ in a .qp file.",
        "git_url": "https://github.com/PierreLvx/qpress/commit/02a79a793f56e86e2014a606647b158b246811e3",
        "commit_title": "Fix qpress directory traversal vulnerability",
        "commit_text": " A bad actor user can prepare the payload as:  ``` mkdir -p AAAAAAAAA/secure_file_priv_dir touch AAAAAAAAA/secure_file_priv_dir/evil.so qpress -r AAAAAAAAA payload.qp Then edit the payload.qp in a hex editor or sed to replace AAAAAAAAA with ../../../ (example: sed -i 's/AAAAAAAAA/..\\/..\\/..\\//' payload.qp) ```  Fix bug by checking the directory and reject the command if find the attempt to traversal  Test: see example above and try to reproduce it. Before fix you can observe traversal. After fix - the error message(File path contains directory traversal which is not allowed.) shown, no traversal observe.  All new code of the whole pull request, including one or several files that are either new files or modified ones, are contributed under the BSD-new license.  I am contributing on behalf of my employer Amazon Web Services, Inc.",
        "func_before": "void decompress_directory(string extract_dir, bool std_out)\n{\n    char c;\n    string curdir;\n    size_t r = 0;\n    unsigned int chunk_size;\n\n    curdir = string(extract_dir);\n\n    for(;;)\n    {\n        r = aread(&c, 1);\n        if (r == 0)\n            return;\n\n        if(c == 'D')\n        {\n\t\t\t// read directory name, append it to current path and create the directory\n            chunk_size = fread32();\n            try_aread(tmp, chunk_size + 1);\n            curdir = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n            if(!std_out)\n            {\n#ifdef WINDOWS\n                CreateDirectory(curdir.c_str(), 0);\n#else\n                mkdir(curdir.c_str(), 509);\n#endif\n            }\n        }\n        else if(c == 'U')\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\n        else if(c == 'F')\n        {\n            chunk_size = fread32(); // read length of file name\n            try_aread(tmp, chunk_size + 1); // read file name\n            string buf2 = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n            if(!std_out)\n            {\n                if(exists(buf2) && !force_flag)\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\n                else\n                    decompress_file(buf2);\n            }\n            else\n                decompress_file(\"<stdout>\");\n        }\n        else\n            abort(\"Source file is corrupted - try the -R flag to recover\");\n    }\n}",
        "func": "void decompress_directory(string extract_dir, bool std_out)\n{\n    char c;\n    string curdir;\n    size_t r = 0;\n    unsigned int chunk_size;\n\n    curdir = string(extract_dir);\n\n    for(;;)\n    {\n        r = aread(&c, 1);\n        if (r == 0)\n            return;\n\n        if(c == 'D')\n        {\n\t\t\t// read directory name, append it to current path and create the directory\n            chunk_size = fread32();\n\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\n            {\n                abort(\"File path string is bigger than buffer size\");\n            }\n            try_aread(tmp, chunk_size + 1);\n            curdir = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n\t \t\tNeed to check if we try to decompress file or directory outside working directory\n\t \t\t*/\n\t        if(true == check_if_path_has_dir_traversal(tmp)) \n            {\n\t            abort(\"Directory path contains directory traversal which is not allowed.\");\n\t        }\n\t        /* End of RDS security fix*/\n            if(!std_out)\n            {\n#ifdef WINDOWS\n                CreateDirectory(curdir.c_str(), 0);\n#else\n                mkdir(curdir.c_str(), 509);\n#endif\n            }\n        }\n        else if(c == 'U')\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\n        else if(c == 'F')\n        {\n            chunk_size = fread32(); // read length of file name\n            if(NAME_BUFFER_SIZE < chunk_size + 1)\n\t             {\n\t                 abort(\"File path string is bigger than buffer size\");\n\t             }\n\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\n\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n\t \t\t   Need to check if we try to decompress file or directory outside working directory\n\t \t\t*/\n\t         if(true == check_if_path_has_dir_traversal(tmp)) \n\t         {\n\t             abort(\"File path contains directory traversal which is not allowed.\");\n\t         }\n\t         /* End of RDS security fix*/\n            string buf2 = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n            if(!std_out)\n            {\n                if(exists(buf2) && !force_flag)\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\n                else\n                    decompress_file(buf2);\n            }\n            else\n                decompress_file(\"<stdout>\");\n        }\n        else\n            abort(\"Source file is corrupted - try the -R flag to recover\");\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,9 +17,21 @@\n         {\n \t\t\t// read directory name, append it to current path and create the directory\n             chunk_size = fread32();\n+\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\n+            {\n+                abort(\"File path string is bigger than buffer size\");\n+            }\n             try_aread(tmp, chunk_size + 1);\n             curdir = curdir + DELIM_STR + tmp;\n             PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n+\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n+\t \t\tNeed to check if we try to decompress file or directory outside working directory\n+\t \t\t*/\n+\t        if(true == check_if_path_has_dir_traversal(tmp)) \n+            {\n+\t            abort(\"Directory path contains directory traversal which is not allowed.\");\n+\t        }\n+\t        /* End of RDS security fix*/\n             if(!std_out)\n             {\n #ifdef WINDOWS\n@@ -34,7 +46,19 @@\n         else if(c == 'F')\n         {\n             chunk_size = fread32(); // read length of file name\n-            try_aread(tmp, chunk_size + 1); // read file name\n+            if(NAME_BUFFER_SIZE < chunk_size + 1)\n+\t             {\n+\t                 abort(\"File path string is bigger than buffer size\");\n+\t             }\n+\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\n+\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n+\t \t\t   Need to check if we try to decompress file or directory outside working directory\n+\t \t\t*/\n+\t         if(true == check_if_path_has_dir_traversal(tmp)) \n+\t         {\n+\t             abort(\"File path contains directory traversal which is not allowed.\");\n+\t         }\n+\t         /* End of RDS security fix*/\n             string buf2 = curdir + DELIM_STR + tmp;\n             PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n             if(!std_out)",
        "diff_line_info": {
            "deleted_lines": [
                "            try_aread(tmp, chunk_size + 1); // read file name"
            ],
            "added_lines": [
                "\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)",
                "            {",
                "                abort(\"File path string is bigger than buffer size\");",
                "            }",
                "\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231",
                "\t \t\tNeed to check if we try to decompress file or directory outside working directory",
                "\t \t\t*/",
                "\t        if(true == check_if_path_has_dir_traversal(tmp)) ",
                "            {",
                "\t            abort(\"Directory path contains directory traversal which is not allowed.\");",
                "\t        }",
                "\t        /* End of RDS security fix*/",
                "            if(NAME_BUFFER_SIZE < chunk_size + 1)",
                "\t             {",
                "\t                 abort(\"File path string is bigger than buffer size\");",
                "\t             }",
                "\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'",
                "\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231",
                "\t \t\t   Need to check if we try to decompress file or directory outside working directory",
                "\t \t\t*/",
                "\t         if(true == check_if_path_has_dir_traversal(tmp)) ",
                "\t         {",
                "\t             abort(\"File path contains directory traversal which is not allowed.\");",
                "\t         }",
                "\t         /* End of RDS security fix*/"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45866",
        "func_name": "EvgeniyPatlan/qpress/decompress_directory",
        "description": "qpress before PierreLvx/qpress 20220819 and before version 11.3, as used in Percona XtraBackup and other products, allows directory traversal via ../ in a .qp file.",
        "git_url": "https://github.com/EvgeniyPatlan/qpress/commit/ddb312090ebd5794e81bc6fb1dfb4e79eda48761",
        "commit_title": "Fix qpress directory traversal vulnerability (#6)",
        "commit_text": " A bad actor user can prepare the payload as:\r \r ```\r mkdir -p AAAAAAAAA/secure_file_priv_dir\r touch AAAAAAAAA/secure_file_priv_dir/evil.so\r qpress -r AAAAAAAAA payload.qp\r Then edit the payload.qp in a hex editor or sed to replace AAAAAAAAA with ../../../\r (example: sed -i 's/AAAAAAAAA/..\\/..\\/..\\//' payload.qp)\r ```\r \r Fix bug by checking the directory and reject the command if find the attempt to traversal\r \r Test: see example above and try to reproduce it. Before fix you can observe\r traversal. After fix - the error message(File path contains directory traversal\r which is not allowed.) shown, no traversal observe.\r \r All new code of the whole pull request, including one or several files\r that are either new files or modified ones, are contributed under the BSD-new\r license.  I am contributing on behalf of my employer Amazon Web Services,\r Inc.\r \r Co-authored-by: Mikhail Chalov <mcchalov@amazon.com>",
        "func_before": "void decompress_directory(string extract_dir, bool std_out)\n{\n    char c;\n    string curdir;\n    size_t r = 0;\n    unsigned int chunk_size;\n\n    curdir = string(extract_dir);\n\n    for(;;)\n    {\n        r = aread(&c, 1);\n        if (r == 0)\n            return;\n\n        if(c == 'D')\n        {\n\t\t\t// read directory name, append it to current path and create the directory\n            chunk_size = fread32();\n            try_aread(tmp, chunk_size + 1);\n            curdir = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n            if(!std_out)\n            {\n#ifdef WINDOWS\n                CreateDirectory(curdir.c_str(), 0);\n#else\n                mkdir(curdir.c_str(), 509);\n#endif\n            }\n        }\n        else if(c == 'U')\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\n        else if(c == 'F')\n        {\n            chunk_size = fread32(); // read length of file name\n            try_aread(tmp, chunk_size + 1); // read file name\n            string buf2 = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n            if(!std_out)\n            {\n                if(exists(buf2) && !force_flag)\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\n                else\n                    decompress_file(buf2);\n            }\n            else\n                decompress_file(\"<stdout>\");\n        }\n        else\n            abort(\"Source file is corrupted - try the -R flag to recover\");\n    }\n}",
        "func": "void decompress_directory(string extract_dir, bool std_out)\n{\n    char c;\n    string curdir;\n    size_t r = 0;\n    unsigned int chunk_size;\n\n    curdir = string(extract_dir);\n\n    for(;;)\n    {\n        r = aread(&c, 1);\n        if (r == 0)\n            return;\n\n        if(c == 'D')\n        {\n\t\t\t// read directory name, append it to current path and create the directory\n            chunk_size = fread32();\n\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\n            {\n                abort(\"File path string is bigger than buffer size\");\n            }\n            try_aread(tmp, chunk_size + 1);\n            curdir = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n\t \t\tNeed to check if we try to decompress file or directory outside working directory\n\t \t\t*/\n\t        if(true == check_if_path_has_dir_traversal(tmp)) \n            {\n\t            abort(\"Directory path contains directory traversal which is not allowed.\");\n\t        }\n\t        /* End of RDS security fix*/\n            if(!std_out)\n            {\n#ifdef WINDOWS\n                CreateDirectory(curdir.c_str(), 0);\n#else\n                mkdir(curdir.c_str(), 509);\n#endif\n            }\n        }\n        else if(c == 'U')\n            curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR)); // remove last sub dir from current path\n        else if(c == 'F')\n        {\n            chunk_size = fread32(); // read length of file name\n            if(NAME_BUFFER_SIZE < chunk_size + 1)\n\t             {\n\t                 abort(\"File path string is bigger than buffer size\");\n\t             }\n\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\n\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n\t \t\t   Need to check if we try to decompress file or directory outside working directory\n\t \t\t*/\n\t         if(true == check_if_path_has_dir_traversal(tmp)) \n\t         {\n\t             abort(\"File path contains directory traversal which is not allowed.\");\n\t         }\n\t         /* End of RDS security fix*/\n            string buf2 = curdir + DELIM_STR + tmp;\n            PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n            if(!std_out)\n            {\n                if(exists(buf2) && !force_flag)\n                    abort(\"Destination file '%s' already exists - aborted\", buf2.c_str());\n                else\n                    decompress_file(buf2);\n            }\n            else\n                decompress_file(\"<stdout>\");\n        }\n        else\n            abort(\"Source file is corrupted - try the -R flag to recover\");\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,9 +17,21 @@\n         {\n \t\t\t// read directory name, append it to current path and create the directory\n             chunk_size = fread32();\n+\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)\n+            {\n+                abort(\"File path string is bigger than buffer size\");\n+            }\n             try_aread(tmp, chunk_size + 1);\n             curdir = curdir + DELIM_STR + tmp;\n             PRINT(FILES_PROCESSED, \"%s%s%s\\n\", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR);\n+\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n+\t \t\tNeed to check if we try to decompress file or directory outside working directory\n+\t \t\t*/\n+\t        if(true == check_if_path_has_dir_traversal(tmp)) \n+            {\n+\t            abort(\"Directory path contains directory traversal which is not allowed.\");\n+\t        }\n+\t        /* End of RDS security fix*/\n             if(!std_out)\n             {\n #ifdef WINDOWS\n@@ -34,7 +46,19 @@\n         else if(c == 'F')\n         {\n             chunk_size = fread32(); // read length of file name\n-            try_aread(tmp, chunk_size + 1); // read file name\n+            if(NAME_BUFFER_SIZE < chunk_size + 1)\n+\t             {\n+\t                 abort(\"File path string is bigger than buffer size\");\n+\t             }\n+\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'\n+\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231\n+\t \t\t   Need to check if we try to decompress file or directory outside working directory\n+\t \t\t*/\n+\t         if(true == check_if_path_has_dir_traversal(tmp)) \n+\t         {\n+\t             abort(\"File path contains directory traversal which is not allowed.\");\n+\t         }\n+\t         /* End of RDS security fix*/\n             string buf2 = curdir + DELIM_STR + tmp;\n             PRINT(FILES_PROCESSED, \"%s    %s\\n\", BLANK_LINE, tmp);\n             if(!std_out)",
        "diff_line_info": {
            "deleted_lines": [
                "            try_aread(tmp, chunk_size + 1); // read file name"
            ],
            "added_lines": [
                "\t\t\tif(NAME_BUFFER_SIZE < chunk_size + 1)",
                "            {",
                "                abort(\"File path string is bigger than buffer size\");",
                "            }",
                "\t\t\t/* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231",
                "\t \t\tNeed to check if we try to decompress file or directory outside working directory",
                "\t \t\t*/",
                "\t        if(true == check_if_path_has_dir_traversal(tmp)) ",
                "            {",
                "\t            abort(\"Directory path contains directory traversal which is not allowed.\");",
                "\t        }",
                "\t        /* End of RDS security fix*/",
                "            if(NAME_BUFFER_SIZE < chunk_size + 1)",
                "\t             {",
                "\t                 abort(\"File path string is bigger than buffer size\");",
                "\t             }",
                "\t             try_aread(tmp, chunk_size + 1); // read file name to 'tmp' with size 'chunk_size + 1'",
                "\t         /* RDS security fix: https://rds-jira.amazon.com/browse/MMCP-231",
                "\t \t\t   Need to check if we try to decompress file or directory outside working directory",
                "\t \t\t*/",
                "\t         if(true == check_if_path_has_dir_traversal(tmp)) ",
                "\t         {",
                "\t             abort(\"File path contains directory traversal which is not allowed.\");",
                "\t         }",
                "\t         /* End of RDS security fix*/"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45866",
        "func_name": "percona/percona-xtrabackup/qlz_decompress",
        "description": "qpress before PierreLvx/qpress 20220819 and before version 11.3, as used in Percona XtraBackup and other products, allows directory traversal via ../ in a .qp file.",
        "git_url": "https://github.com/percona/percona-xtrabackup/commit/dac3d82f559efbf06d116c066d30e688fe3fb323",
        "commit_title": "Quicklz decompression memory corruption issue fix",
        "commit_text": " There is a memory corruption issue inside the quicklz.c source file that ships with Percona XtraBackup. Specifically the problem happens on copying user-supplied binary data over heap allocated memory buffers of user-controlled size. This allows corruption of heap data structures and potential arbitrary code execution.  The code in question is inside the qlz_decompress function of quicklz.c file:  ``` size_t qlz_decompress(const char *source, void *destination, qlz_state_decompress *state) {         size_t dsiz = qlz_size_decompressed(source);          if (state->stream_counter + qlz_size_decompressed(source) - 1 >= QLZ_STREAMING_BUFFER)         {                 if((*source & 1) == 1)                 {                         reset_table_decompress(state);                         dsiz = qlz_decompress_core((const unsigned char *)source, (unsigned char *)destination, dsiz, state, (const unsigned char *)destination);                 }                 else                 {                         memcpy(destination, source + qlz_size_header(source), dsiz);                 }                 state->stream_counter = 0;                 reset_table_decompress(state);         }         else         {                 unsigned char *dst = state->stream_buffer + state->stream_counter;                 if((*source & 1) == 1)                 {                         dsiz = qlz_decompress_core((const unsigned char *)source, dst, dsiz, state, (const unsigned char *)state->stream_buffer);                 }                 else                 {                         memcpy(dst, source + qlz_size_header(source), dsiz);                         reset_table_decompress(state);                 }                 memcpy(destination, dst, dsiz);                 state->stream_counter += dsiz;         }         return dsiz; } ```  Note the first memcpy invocation: that does copy data from user-provided compressed file into a heap-allocated buffer for which size is also controlled by the user via the compressed file header. This allows heap corruption with user-controlled data. Potentially this means arbitrary code execution for the processes that utilize the vulnerable function - one example is xbstream with decompress flag.  Steps to reproduce:   - Create a compressed file, e.g. with qpress from some file larger than 65535    bytes.  - Edit compressed file so that the four bytes at offset 8 are changed to be    less than 0x10000, for example set to 0x1000 instead.  - Edit the file so that the byte at offset 50 is an even value to pass the    test: if((*source & 1) == 1)  - Replace the bytes of actual file with some recognizable pattern, e.g. 0x41    0x42 0x43 0x44  - Add the file to an xbstream file: xbstream -c Demo.qp > Demo.xbstream  - Now try to extract with decompression using xbstream under a debugger, e.g.    gdb and observe the corruption: xbstream decompress -x < Demo.xbstream  ``` head -c 100000 </dev/urandom > payload.bin  qpress payload.bin payload.qp  ls -l payload.qp -rw-r--r-- 1 me me 100107 Feb 17 18:08 payload.qp  printf '\\x00\\x01\\x00' | dd of=payload.qp bs=1 seek=8 count=3 conv=notrunc  printf '\\x10' | dd of=payload.qp bs=1 seek=49 count=1 conv=notrunc  python -c 'import sys; sys.stdout.write(\"A\"*100040)' | dd of=payload.qp bs=1 seek=50 count=100040 conv=notrunc  xbstream-80 -c payload.qp > corrupted.xbstream  $ xbstream-80 --decompress -x < corrupted.xbstream Segmentation fault ```  Fix by prevent XtraBackup read/write outside array bounds ``` We noticed that quicklz already has a mechanism to check if the data was corrupted and prevent reading and writing outside array bounds. Programm should be compiled against QLZ_MEMORY_SAFE flag. So we uncommented the flag and add the error message.  All new code of the whole pull request, including one or several files that are either new files or modified ones, are contributed under the BSD-new license. I am contributing on behalf of my employer Amazon Web Services, Inc.",
        "func_before": "size_t qlz_decompress(const char *source, void *destination, qlz_state_decompress *state)\n{\n\tsize_t dsiz = qlz_size_decompressed(source);\n\n#if QLZ_STREAMING_BUFFER > 0\n\tif (state->stream_counter + qlz_size_decompressed(source) - 1 >= QLZ_STREAMING_BUFFER) \n#endif\n\t{\n\t\tif((*source & 1) == 1)\n\t\t{\n\t\t\treset_table_decompress(state);\n\t\t\tdsiz = qlz_decompress_core((const unsigned char *)source, (unsigned char *)destination, dsiz, state, (const unsigned char *)destination);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(destination, source + qlz_size_header(source), dsiz);\n\t\t}\n\t\tstate->stream_counter = 0;\n\t\treset_table_decompress(state);\n\t}\n#if QLZ_STREAMING_BUFFER > 0\n\telse\n\t{\n\t\tunsigned char *dst = state->stream_buffer + state->stream_counter;\n\t\tif((*source & 1) == 1)\n\t\t{\n\t\t\tdsiz = qlz_decompress_core((const unsigned char *)source, dst, dsiz, state, (const unsigned char *)state->stream_buffer);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(dst, source + qlz_size_header(source), dsiz);\n\t\t\treset_table_decompress(state);\n\t\t}\n\t\tmemcpy(destination, dst, dsiz);\n\t\tstate->stream_counter += dsiz;\n\t}\n#endif\n\treturn dsiz;\n}",
        "func": "size_t qlz_decompress(const char *source, void *destination, qlz_state_decompress *state)\n{\n\tsize_t dsiz = qlz_size_decompressed(source);\n\n#if QLZ_STREAMING_BUFFER > 0\n\tif (state->stream_counter + qlz_size_decompressed(source) - 1 >= QLZ_STREAMING_BUFFER) \n#endif\n\t{\n\t\tif((*source & 1) == 1)\n\t\t{\n\t\t\treset_table_decompress(state);\n\t\t\tdsiz = qlz_decompress_core((const unsigned char *)source, (unsigned char *)destination, dsiz, state, (const unsigned char *)destination);\n\t\t\tif(0 == dsiz)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"Error: compressed file was corrupted - header data size and actual data size mismatch - cant decompress \\n\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(destination, source + qlz_size_header(source), dsiz);\n\t\t}\n\t\tstate->stream_counter = 0;\n\t\treset_table_decompress(state);\n\t}\n#if QLZ_STREAMING_BUFFER > 0\n\telse\n\t{\n\t\tunsigned char *dst = state->stream_buffer + state->stream_counter;\n\t\tif((*source & 1) == 1)\n\t\t{\n\t\t\tdsiz = qlz_decompress_core((const unsigned char *)source, dst, dsiz, state, (const unsigned char *)state->stream_buffer);\n\t\t\tif(0 == dsiz)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"Error: compressed file was corrupted - header data size and actual data size mismatch - cant decompress \\n\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(dst, source + qlz_size_header(source), dsiz);\n\t\t\treset_table_decompress(state);\n\t\t}\n\t\tmemcpy(destination, dst, dsiz);\n\t\tstate->stream_counter += dsiz;\n\t}\n#endif\n\treturn dsiz;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,10 @@\n \t\t{\n \t\t\treset_table_decompress(state);\n \t\t\tdsiz = qlz_decompress_core((const unsigned char *)source, (unsigned char *)destination, dsiz, state, (const unsigned char *)destination);\n+\t\t\tif(0 == dsiz)\n+\t\t\t{\n+\t\t\t\tfprintf(stderr, \"Error: compressed file was corrupted - header data size and actual data size mismatch - cant decompress \\n\");\n+\t\t\t}\n \t\t}\n \t\telse\n \t\t{\n@@ -25,6 +29,10 @@\n \t\tif((*source & 1) == 1)\n \t\t{\n \t\t\tdsiz = qlz_decompress_core((const unsigned char *)source, dst, dsiz, state, (const unsigned char *)state->stream_buffer);\n+\t\t\tif(0 == dsiz)\n+\t\t\t{\n+\t\t\t\tfprintf(stderr, \"Error: compressed file was corrupted - header data size and actual data size mismatch - cant decompress \\n\");\n+\t\t\t}\n \t\t}\n \t\telse\n \t\t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif(0 == dsiz)",
                "\t\t\t{",
                "\t\t\t\tfprintf(stderr, \"Error: compressed file was corrupted - header data size and actual data size mismatch - cant decompress \\n\");",
                "\t\t\t}",
                "\t\t\tif(0 == dsiz)",
                "\t\t\t{",
                "\t\t\t\tfprintf(stderr, \"Error: compressed file was corrupted - header data size and actual data size mismatch - cant decompress \\n\");",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35852",
        "func_name": "OISF/suricata/SetupSavePath",
        "description": "In Suricata before 6.0.13 (when there is an adversary who controls an external source of rules), a dataset filename, that comes from a rule, may trigger absolute or relative directory traversal, and lead to write access to a local filesystem. This is addressed in 6.0.13 by requiring allow-absolute-filenames and allow-write (in the datasets rules configuration section) if an installation requires traversal/writing in this situation.",
        "git_url": "https://github.com/OISF/suricata/commit/735f5aa9ca3b28cfacc7a443f93a44387fbacf17",
        "commit_title": "datasets: flag to disable \"write\" actions",
        "commit_text": " Add a new configuration flag, \"datasets.rules.allow-write\" to control if rules can contain \"save\" or \"state\" rules which allow write access to the file system.  Ticket: #6123",
        "func_before": "static int SetupSavePath(const DetectEngineCtx *de_ctx,\n        char *save, size_t save_size)\n{\n    SCLogDebug(\"save %s\", save);\n\n    int allow_absolute = 0;\n    (void)ConfGetBool(\"datasets.rules.allow-absolute-filenames\", &allow_absolute);\n    if (allow_absolute) {\n        SCLogNotice(\"Allowing absolute filename for dataset rule: %s\", save);\n    } else {\n        if (PathIsAbsolute(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Absolute paths not allowed: %s\", save);\n            return -1;\n        }\n\n        if (SCPathContainsTraversal(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Directory traversals not allowed: %s\", save);\n            return -1;\n        }\n    }\n\n    // data dir\n    const char *dir = ConfigGetDataDirectory();\n    BUG_ON(dir == NULL); // should not be able to fail\n    char path[PATH_MAX];\n    if (snprintf(path, sizeof(path), \"%s/%s\", dir, save) >= (int)sizeof(path)) // TODO windows path\n        return -1;\n\n    /* TODO check if location exists and is writable */\n\n    strlcpy(save, path, save_size);\n\n    return 0;\n}",
        "func": "static int SetupSavePath(const DetectEngineCtx *de_ctx,\n        char *save, size_t save_size)\n{\n    SCLogDebug(\"save %s\", save);\n\n    int allow_save = 1;\n    if (ConfGetBool(\"datasets.rules.allow-write\", &allow_save)) {\n        if (!allow_save) {\n            SCLogError(SC_ERR_INVALID_SIGNATURE,\n                    \"Rules containing save/state datasets have been disabled\");\n            return -1;\n        }\n    }\n\n    int allow_absolute = 0;\n    (void)ConfGetBool(\"datasets.rules.allow-absolute-filenames\", &allow_absolute);\n    if (allow_absolute) {\n        SCLogNotice(\"Allowing absolute filename for dataset rule: %s\", save);\n    } else {\n        if (PathIsAbsolute(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Absolute paths not allowed: %s\", save);\n            return -1;\n        }\n\n        if (SCPathContainsTraversal(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Directory traversals not allowed: %s\", save);\n            return -1;\n        }\n    }\n\n    // data dir\n    const char *dir = ConfigGetDataDirectory();\n    BUG_ON(dir == NULL); // should not be able to fail\n    char path[PATH_MAX];\n    if (snprintf(path, sizeof(path), \"%s/%s\", dir, save) >= (int)sizeof(path)) // TODO windows path\n        return -1;\n\n    /* TODO check if location exists and is writable */\n\n    strlcpy(save, path, save_size);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,15 @@\n         char *save, size_t save_size)\n {\n     SCLogDebug(\"save %s\", save);\n+\n+    int allow_save = 1;\n+    if (ConfGetBool(\"datasets.rules.allow-write\", &allow_save)) {\n+        if (!allow_save) {\n+            SCLogError(SC_ERR_INVALID_SIGNATURE,\n+                    \"Rules containing save/state datasets have been disabled\");\n+            return -1;\n+        }\n+    }\n \n     int allow_absolute = 0;\n     (void)ConfGetBool(\"datasets.rules.allow-absolute-filenames\", &allow_absolute);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    int allow_save = 1;",
                "    if (ConfGetBool(\"datasets.rules.allow-write\", &allow_save)) {",
                "        if (!allow_save) {",
                "            SCLogError(SC_ERR_INVALID_SIGNATURE,",
                "                    \"Rules containing save/state datasets have been disabled\");",
                "            return -1;",
                "        }",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35852",
        "func_name": "OISF/suricata/SetupSavePath",
        "description": "In Suricata before 6.0.13 (when there is an adversary who controls an external source of rules), a dataset filename, that comes from a rule, may trigger absolute or relative directory traversal, and lead to write access to a local filesystem. This is addressed in 6.0.13 by requiring allow-absolute-filenames and allow-write (in the datasets rules configuration section) if an installation requires traversal/writing in this situation.",
        "git_url": "https://github.com/OISF/suricata/commit/aee1523b4591430ebed1ded0bb95508e6717a335",
        "commit_title": "datasets: don't allow absolute or paths with directory traversal",
        "commit_text": " For dataset filenames coming from rules, do not allow filenames that are absolute or contain a directory traversal with \"..\". This prevents datasets from escaping the define data-directory which may allow a bad rule to overwrite any file that Suricata has permission to write to.  Add a new configuration option, \"datasets.rules.allow-absolute-filenames\" to allow absolute filenames in dataset rules. This will be a way to revert back to the pre 6.0.13 behavior where save/state rules could use any filename.  Ticket: #6118",
        "func_before": "static int SetupSavePath(const DetectEngineCtx *de_ctx,\n        char *save, size_t save_size)\n{\n    SCLogDebug(\"save %s\", save);\n\n    if (PathIsAbsolute(save)) {\n        return 0;\n    }\n\n    // data dir\n    const char *dir = ConfigGetDataDirectory();\n    BUG_ON(dir == NULL); // should not be able to fail\n    char path[PATH_MAX];\n    if (snprintf(path, sizeof(path), \"%s/%s\", dir, save) >= (int)sizeof(path)) // TODO windows path\n        return -1;\n\n    /* TODO check if location exists and is writable */\n\n    strlcpy(save, path, save_size);\n\n    return 0;\n}",
        "func": "static int SetupSavePath(const DetectEngineCtx *de_ctx,\n        char *save, size_t save_size)\n{\n    SCLogDebug(\"save %s\", save);\n\n    int allow_absolute = 0;\n    (void)ConfGetBool(\"datasets.rules.allow-absolute-filenames\", &allow_absolute);\n    if (allow_absolute) {\n        SCLogNotice(\"Allowing absolute filename for dataset rule: %s\", save);\n    } else {\n        if (PathIsAbsolute(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Absolute paths not allowed: %s\", save);\n            return -1;\n        }\n\n        if (SCPathContainsTraversal(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Directory traversals not allowed: %s\", save);\n            return -1;\n        }\n    }\n\n    // data dir\n    const char *dir = ConfigGetDataDirectory();\n    BUG_ON(dir == NULL); // should not be able to fail\n    char path[PATH_MAX];\n    if (snprintf(path, sizeof(path), \"%s/%s\", dir, save) >= (int)sizeof(path)) // TODO windows path\n        return -1;\n\n    /* TODO check if location exists and is writable */\n\n    strlcpy(save, path, save_size);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,20 @@\n {\n     SCLogDebug(\"save %s\", save);\n \n-    if (PathIsAbsolute(save)) {\n-        return 0;\n+    int allow_absolute = 0;\n+    (void)ConfGetBool(\"datasets.rules.allow-absolute-filenames\", &allow_absolute);\n+    if (allow_absolute) {\n+        SCLogNotice(\"Allowing absolute filename for dataset rule: %s\", save);\n+    } else {\n+        if (PathIsAbsolute(save)) {\n+            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Absolute paths not allowed: %s\", save);\n+            return -1;\n+        }\n+\n+        if (SCPathContainsTraversal(save)) {\n+            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Directory traversals not allowed: %s\", save);\n+            return -1;\n+        }\n     }\n \n     // data dir",
        "diff_line_info": {
            "deleted_lines": [
                "    if (PathIsAbsolute(save)) {",
                "        return 0;"
            ],
            "added_lines": [
                "    int allow_absolute = 0;",
                "    (void)ConfGetBool(\"datasets.rules.allow-absolute-filenames\", &allow_absolute);",
                "    if (allow_absolute) {",
                "        SCLogNotice(\"Allowing absolute filename for dataset rule: %s\", save);",
                "    } else {",
                "        if (PathIsAbsolute(save)) {",
                "            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Absolute paths not allowed: %s\", save);",
                "            return -1;",
                "        }",
                "",
                "        if (SCPathContainsTraversal(save)) {",
                "            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Directory traversals not allowed: %s\", save);",
                "            return -1;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-29373",
        "func_name": "torvalds/linux/io_req_work_drop_env",
        "description": "An issue was discovered in fs/io_uring.c in the Linux kernel before 5.6. It unsafely handles the root directory during path lookups, and thus a process inside a mount namespace can escape to unintended filesystem locations, aka CID-ff002b30181d.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ff002b30181d30cdfbca316dadd099c3ca0d739c",
        "commit_title": "This passes it in to io-wq, so it assumes the right fs_struct when",
        "commit_text": "executing async work that may need to do lookups.  Cc: stable@vger.kernel.org # 5.3+ ",
        "func_before": "static inline void io_req_work_drop_env(struct io_kiocb *req)\n{\n\tif (req->work.mm) {\n\t\tmmdrop(req->work.mm);\n\t\treq->work.mm = NULL;\n\t}\n\tif (req->work.creds) {\n\t\tput_cred(req->work.creds);\n\t\treq->work.creds = NULL;\n\t}\n}",
        "func": "static inline void io_req_work_drop_env(struct io_kiocb *req)\n{\n\tif (req->work.mm) {\n\t\tmmdrop(req->work.mm);\n\t\treq->work.mm = NULL;\n\t}\n\tif (req->work.creds) {\n\t\tput_cred(req->work.creds);\n\t\treq->work.creds = NULL;\n\t}\n\tif (req->work.fs) {\n\t\tstruct fs_struct *fs = req->work.fs;\n\n\t\tspin_lock(&req->work.fs->lock);\n\t\tif (--fs->users)\n\t\t\tfs = NULL;\n\t\tspin_unlock(&req->work.fs->lock);\n\t\tif (fs)\n\t\t\tfree_fs_struct(fs);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,4 +8,14 @@\n \t\tput_cred(req->work.creds);\n \t\treq->work.creds = NULL;\n \t}\n+\tif (req->work.fs) {\n+\t\tstruct fs_struct *fs = req->work.fs;\n+\n+\t\tspin_lock(&req->work.fs->lock);\n+\t\tif (--fs->users)\n+\t\t\tfs = NULL;\n+\t\tspin_unlock(&req->work.fs->lock);\n+\t\tif (fs)\n+\t\t\tfree_fs_struct(fs);\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (req->work.fs) {",
                "\t\tstruct fs_struct *fs = req->work.fs;",
                "",
                "\t\tspin_lock(&req->work.fs->lock);",
                "\t\tif (--fs->users)",
                "\t\t\tfs = NULL;",
                "\t\tspin_unlock(&req->work.fs->lock);",
                "\t\tif (fs)",
                "\t\t\tfree_fs_struct(fs);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-29373",
        "func_name": "torvalds/linux/io_req_work_grab_env",
        "description": "An issue was discovered in fs/io_uring.c in the Linux kernel before 5.6. It unsafely handles the root directory during path lookups, and thus a process inside a mount namespace can escape to unintended filesystem locations, aka CID-ff002b30181d.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ff002b30181d30cdfbca316dadd099c3ca0d739c",
        "commit_title": "This passes it in to io-wq, so it assumes the right fs_struct when",
        "commit_text": "executing async work that may need to do lookups.  Cc: stable@vger.kernel.org # 5.3+ ",
        "func_before": "static inline void io_req_work_grab_env(struct io_kiocb *req,\n\t\t\t\t\tconst struct io_op_def *def)\n{\n\tif (!req->work.mm && def->needs_mm) {\n\t\tmmgrab(current->mm);\n\t\treq->work.mm = current->mm;\n\t}\n\tif (!req->work.creds)\n\t\treq->work.creds = get_current_cred();\n}",
        "func": "static inline void io_req_work_grab_env(struct io_kiocb *req,\n\t\t\t\t\tconst struct io_op_def *def)\n{\n\tif (!req->work.mm && def->needs_mm) {\n\t\tmmgrab(current->mm);\n\t\treq->work.mm = current->mm;\n\t}\n\tif (!req->work.creds)\n\t\treq->work.creds = get_current_cred();\n\tif (!req->work.fs && def->needs_fs) {\n\t\tspin_lock(&current->fs->lock);\n\t\tif (!current->fs->in_exec) {\n\t\t\treq->work.fs = current->fs;\n\t\t\treq->work.fs->users++;\n\t\t} else {\n\t\t\treq->work.flags |= IO_WQ_WORK_CANCEL;\n\t\t}\n\t\tspin_unlock(&current->fs->lock);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,4 +7,14 @@\n \t}\n \tif (!req->work.creds)\n \t\treq->work.creds = get_current_cred();\n+\tif (!req->work.fs && def->needs_fs) {\n+\t\tspin_lock(&current->fs->lock);\n+\t\tif (!current->fs->in_exec) {\n+\t\t\treq->work.fs = current->fs;\n+\t\t\treq->work.fs->users++;\n+\t\t} else {\n+\t\t\treq->work.flags |= IO_WQ_WORK_CANCEL;\n+\t\t}\n+\t\tspin_unlock(&current->fs->lock);\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!req->work.fs && def->needs_fs) {",
                "\t\tspin_lock(&current->fs->lock);",
                "\t\tif (!current->fs->in_exec) {",
                "\t\t\treq->work.fs = current->fs;",
                "\t\t\treq->work.fs->users++;",
                "\t\t} else {",
                "\t\t\treq->work.flags |= IO_WQ_WORK_CANCEL;",
                "\t\t}",
                "\t\tspin_unlock(&current->fs->lock);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-20277",
        "func_name": "troglobit/uftpd/compose_path",
        "description": "There are multiple unauthenticated directory traversal vulnerabilities in different FTP commands in uftpd FTP server versions 2.7 to 2.10 due to improper implementation of a chroot jail in common.c's compose_abspath function that can be abused to read or write to arbitrary files on the filesystem, leak process memory, or potentially lead to remote code execution.",
        "git_url": "https://github.com/troglobit/uftpd/commit/455b47d3756aed162d2d0ef7f40b549f3b5b30fe",
        "commit_title": "FTP/TFTP: Fix directory traversal regression, reported by Aaron Esau",
        "commit_text": "",
        "func_before": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}",
        "func": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\n\ncheck:\n\twhile ((ptr = strstr(dir, \"//\")))\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\n\t/*\n\t * Handle directories slightly differently, since dirname() on a\n\t * directory returns the parent directory.  So, just squash ..\n\t */\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Check realpath() of directory containing the file, a\n\t\t * STOR may want to save a new file.  Then append the\n\t\t * file and return it.\n\t\t */\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\n\tif (!chrooted && strncmp(rpath, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\n\treturn rpath;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,7 +60,7 @@\n \t\tstrlcat(rpath, name, sizeof(rpath));\n \t}\n \n-\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n+\tif (!chrooted && strncmp(rpath, home, strlen(home))) {\n \t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n \t\treturn NULL;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!chrooted && strncmp(dir, home, strlen(home))) {"
            ],
            "added_lines": [
                "\tif (!chrooted && strncmp(rpath, home, strlen(home))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28374",
        "func_name": "torvalds/linux/target_xcopy_locate_se_dev_e4_iter",
        "description": "In drivers/target/target_core_xcopy.c in the Linux kernel before 5.10.7, insufficient identifier checking in the LIO SCSI target code can be used by remote attackers to read or write files via directory traversal in an XCOPY request, aka CID-2896c93811e3. For example, an attack can occur over a network if the attacker has access to one iSCSI LUN. The attacker gains control over file access because I/O operations are proxied via an attacker-selected backstore.",
        "git_url": "https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4",
        "commit_title": "scsi: target: Fix XCOPY NAA identifier lookup",
        "commit_text": " When attempting to match EXTENDED COPY CSCD descriptors with corresponding se_devices, target_xcopy_locate_se_dev_e4() currently iterates over LIO's global devices list which includes all configured backstores.  This change ensures that only initiator-accessible backstores are considered during CSCD descriptor lookup, according to the session's se_node_acl LUN list.  To avoid LUN removal race conditions, device pinning is changed from being configfs based to instead using the se_node_acl lun_ref.  Reference: CVE-2020-28374",
        "func_before": "static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      void *data)\n{\n\tstruct xcopy_dev_search_info *info = data;\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\n\tif (!se_dev->dev_attrib.emulate_3pc)\n\t\treturn 0;\n\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\n\trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0)\n\t\treturn 0;\n\n\tinfo->found_dev = se_dev;\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\n\trc = target_depend_item(&se_dev->dev_group.cg_item);\n\tif (rc != 0) {\n\t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",\n\t\t       rc, se_dev);\n\t\treturn rc;\n\t}\n\n\tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t se_dev, &se_dev->dev_group);\n\treturn 1;\n}",
        "func": "static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      const unsigned char *dev_wwn)\n{\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\n\tif (!se_dev->dev_attrib.emulate_3pc) {\n\t\tpr_debug(\"XCOPY: emulate_3pc disabled on se_dev %p\\n\", se_dev);\n\t\treturn 0;\n\t}\n\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\n\trc = memcmp(&tmp_dev_wwn[0], dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0) {\n\t\tpr_debug(\"XCOPY: skip non-matching: %*ph\\n\",\n\t\t\t XCOPY_NAA_IEEE_REGEX_LEN, tmp_dev_wwn);\n\t\treturn 0;\n\t}\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,31 +1,24 @@\n static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n-\t\t\t\t\t      void *data)\n+\t\t\t\t\t      const unsigned char *dev_wwn)\n {\n-\tstruct xcopy_dev_search_info *info = data;\n \tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n \tint rc;\n \n-\tif (!se_dev->dev_attrib.emulate_3pc)\n+\tif (!se_dev->dev_attrib.emulate_3pc) {\n+\t\tpr_debug(\"XCOPY: emulate_3pc disabled on se_dev %p\\n\", se_dev);\n \t\treturn 0;\n+\t}\n \n \tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n \ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n \n-\trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n-\tif (rc != 0)\n+\trc = memcmp(&tmp_dev_wwn[0], dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n+\tif (rc != 0) {\n+\t\tpr_debug(\"XCOPY: skip non-matching: %*ph\\n\",\n+\t\t\t XCOPY_NAA_IEEE_REGEX_LEN, tmp_dev_wwn);\n \t\treturn 0;\n-\n-\tinfo->found_dev = se_dev;\n+\t}\n \tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n \n-\trc = target_depend_item(&se_dev->dev_group.cg_item);\n-\tif (rc != 0) {\n-\t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",\n-\t\t       rc, se_dev);\n-\t\treturn rc;\n-\t}\n-\n-\tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",\n-\t\t se_dev, &se_dev->dev_group);\n \treturn 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t      void *data)",
                "\tstruct xcopy_dev_search_info *info = data;",
                "\tif (!se_dev->dev_attrib.emulate_3pc)",
                "\trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);",
                "\tif (rc != 0)",
                "",
                "\tinfo->found_dev = se_dev;",
                "\trc = target_depend_item(&se_dev->dev_group.cg_item);",
                "\tif (rc != 0) {",
                "\t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",",
                "\t\t       rc, se_dev);",
                "\t\treturn rc;",
                "\t}",
                "",
                "\tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",",
                "\t\t se_dev, &se_dev->dev_group);"
            ],
            "added_lines": [
                "\t\t\t\t\t      const unsigned char *dev_wwn)",
                "\tif (!se_dev->dev_attrib.emulate_3pc) {",
                "\t\tpr_debug(\"XCOPY: emulate_3pc disabled on se_dev %p\\n\", se_dev);",
                "\t}",
                "\trc = memcmp(&tmp_dev_wwn[0], dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);",
                "\tif (rc != 0) {",
                "\t\tpr_debug(\"XCOPY: skip non-matching: %*ph\\n\",",
                "\t\t\t XCOPY_NAA_IEEE_REGEX_LEN, tmp_dev_wwn);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28374",
        "func_name": "torvalds/linux/xcopy_pt_undepend_remotedev",
        "description": "In drivers/target/target_core_xcopy.c in the Linux kernel before 5.10.7, insufficient identifier checking in the LIO SCSI target code can be used by remote attackers to read or write files via directory traversal in an XCOPY request, aka CID-2896c93811e3. For example, an attack can occur over a network if the attacker has access to one iSCSI LUN. The attacker gains control over file access because I/O operations are proxied via an attacker-selected backstore.",
        "git_url": "https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4",
        "commit_title": "scsi: target: Fix XCOPY NAA identifier lookup",
        "commit_text": " When attempting to match EXTENDED COPY CSCD descriptors with corresponding se_devices, target_xcopy_locate_se_dev_e4() currently iterates over LIO's global devices list which includes all configured backstores.  This change ensures that only initiator-accessible backstores are considered during CSCD descriptor lookup, according to the session's se_node_acl LUN list.  To avoid LUN removal race conditions, device pinning is changed from being configfs based to instead using the se_node_acl lun_ref.  Reference: CVE-2020-28374",
        "func_before": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}",
        "func": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tpr_debug(\"putting dst lun_ref for %p\\n\", xop->dst_dev);\n\telse\n\t\tpr_debug(\"putting src lun_ref for %p\\n\", xop->src_dev);\n\n\tpercpu_ref_put(xop->remote_lun_ref);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,9 @@\n static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n {\n-\tstruct se_device *remote_dev;\n+\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n+\t\tpr_debug(\"putting dst lun_ref for %p\\n\", xop->dst_dev);\n+\telse\n+\t\tpr_debug(\"putting src lun_ref for %p\\n\", xop->src_dev);\n \n-\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n-\t\tremote_dev = xop->dst_dev;\n-\telse\n-\t\tremote_dev = xop->src_dev;\n-\n-\tpr_debug(\"Calling configfs_undepend_item for\"\n-\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n-\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n-\n-\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n+\tpercpu_ref_put(xop->remote_lun_ref);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct se_device *remote_dev;",
                "\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)",
                "\t\tremote_dev = xop->dst_dev;",
                "\telse",
                "\t\tremote_dev = xop->src_dev;",
                "",
                "\tpr_debug(\"Calling configfs_undepend_item for\"",
                "\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",",
                "\t\t  remote_dev, &remote_dev->dev_group.cg_item);",
                "",
                "\ttarget_undepend_item(&remote_dev->dev_group.cg_item);"
            ],
            "added_lines": [
                "\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)",
                "\t\tpr_debug(\"putting dst lun_ref for %p\\n\", xop->dst_dev);",
                "\telse",
                "\t\tpr_debug(\"putting src lun_ref for %p\\n\", xop->src_dev);",
                "\tpercpu_ref_put(xop->remote_lun_ref);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28374",
        "func_name": "torvalds/linux/target_xcopy_locate_se_dev_e4",
        "description": "In drivers/target/target_core_xcopy.c in the Linux kernel before 5.10.7, insufficient identifier checking in the LIO SCSI target code can be used by remote attackers to read or write files via directory traversal in an XCOPY request, aka CID-2896c93811e3. For example, an attack can occur over a network if the attacker has access to one iSCSI LUN. The attacker gains control over file access because I/O operations are proxied via an attacker-selected backstore.",
        "git_url": "https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4",
        "commit_title": "scsi: target: Fix XCOPY NAA identifier lookup",
        "commit_text": " When attempting to match EXTENDED COPY CSCD descriptors with corresponding se_devices, target_xcopy_locate_se_dev_e4() currently iterates over LIO's global devices list which includes all configured backstores.  This change ensures that only initiator-accessible backstores are considered during CSCD descriptor lookup, according to the session's se_node_acl LUN list.  To avoid LUN removal race conditions, device pinning is changed from being configfs based to instead using the se_node_acl lun_ref.  Reference: CVE-2020-28374",
        "func_before": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}",
        "func": "static int target_xcopy_locate_se_dev_e4(struct se_session *sess,\n\t\t\t\t\tconst unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **_found_dev,\n\t\t\t\t\tstruct percpu_ref **_found_lun_ref)\n{\n\tstruct se_dev_entry *deve;\n\tstruct se_node_acl *nacl;\n\tstruct se_lun *this_lun = NULL;\n\tstruct se_device *found_dev = NULL;\n\n\t/* cmd with NULL sess indicates no associated $FABRIC_MOD */\n\tif (!sess)\n\t\tgoto err_out;\n\n\tpr_debug(\"XCOPY 0xe4: searching for: %*ph\\n\",\n\t\t XCOPY_NAA_IEEE_REGEX_LEN, dev_wwn);\n\n\tnacl = sess->se_node_acl;\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {\n\t\tstruct se_device *this_dev;\n\t\tint rc;\n\n\t\tthis_lun = rcu_dereference(deve->se_lun);\n\t\tthis_dev = rcu_dereference_raw(this_lun->lun_se_dev);\n\n\t\trc = target_xcopy_locate_se_dev_e4_iter(this_dev, dev_wwn);\n\t\tif (rc) {\n\t\t\tif (percpu_ref_tryget_live(&this_lun->lun_ref))\n\t\t\t\tfound_dev = this_dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (found_dev == NULL)\n\t\tgoto err_out;\n\n\tpr_debug(\"lun_ref held for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t found_dev, &found_dev->dev_group);\n\t*_found_dev = found_dev;\n\t*_found_lun_ref = &this_lun->lun_ref;\n\treturn 0;\nerr_out:\n\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\treturn -EINVAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,18 +1,46 @@\n-static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n-\t\t\t\t\tstruct se_device **found_dev)\n+static int target_xcopy_locate_se_dev_e4(struct se_session *sess,\n+\t\t\t\t\tconst unsigned char *dev_wwn,\n+\t\t\t\t\tstruct se_device **_found_dev,\n+\t\t\t\t\tstruct percpu_ref **_found_lun_ref)\n {\n-\tstruct xcopy_dev_search_info info;\n-\tint ret;\n+\tstruct se_dev_entry *deve;\n+\tstruct se_node_acl *nacl;\n+\tstruct se_lun *this_lun = NULL;\n+\tstruct se_device *found_dev = NULL;\n \n-\tmemset(&info, 0, sizeof(info));\n-\tinfo.dev_wwn = dev_wwn;\n+\t/* cmd with NULL sess indicates no associated $FABRIC_MOD */\n+\tif (!sess)\n+\t\tgoto err_out;\n \n-\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n-\tif (ret == 1) {\n-\t\t*found_dev = info.found_dev;\n-\t\treturn 0;\n-\t} else {\n-\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n-\t\treturn -EINVAL;\n+\tpr_debug(\"XCOPY 0xe4: searching for: %*ph\\n\",\n+\t\t XCOPY_NAA_IEEE_REGEX_LEN, dev_wwn);\n+\n+\tnacl = sess->se_node_acl;\n+\trcu_read_lock();\n+\thlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {\n+\t\tstruct se_device *this_dev;\n+\t\tint rc;\n+\n+\t\tthis_lun = rcu_dereference(deve->se_lun);\n+\t\tthis_dev = rcu_dereference_raw(this_lun->lun_se_dev);\n+\n+\t\trc = target_xcopy_locate_se_dev_e4_iter(this_dev, dev_wwn);\n+\t\tif (rc) {\n+\t\t\tif (percpu_ref_tryget_live(&this_lun->lun_ref))\n+\t\t\t\tfound_dev = this_dev;\n+\t\t\tbreak;\n+\t\t}\n \t}\n+\trcu_read_unlock();\n+\tif (found_dev == NULL)\n+\t\tgoto err_out;\n+\n+\tpr_debug(\"lun_ref held for se_dev: %p se_dev->se_dev_group: %p\\n\",\n+\t\t found_dev, &found_dev->dev_group);\n+\t*_found_dev = found_dev;\n+\t*_found_lun_ref = &this_lun->lun_ref;\n+\treturn 0;\n+err_out:\n+\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n+\treturn -EINVAL;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,",
                "\t\t\t\t\tstruct se_device **found_dev)",
                "\tstruct xcopy_dev_search_info info;",
                "\tint ret;",
                "\tmemset(&info, 0, sizeof(info));",
                "\tinfo.dev_wwn = dev_wwn;",
                "\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);",
                "\tif (ret == 1) {",
                "\t\t*found_dev = info.found_dev;",
                "\t\treturn 0;",
                "\t} else {",
                "\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");",
                "\t\treturn -EINVAL;"
            ],
            "added_lines": [
                "static int target_xcopy_locate_se_dev_e4(struct se_session *sess,",
                "\t\t\t\t\tconst unsigned char *dev_wwn,",
                "\t\t\t\t\tstruct se_device **_found_dev,",
                "\t\t\t\t\tstruct percpu_ref **_found_lun_ref)",
                "\tstruct se_dev_entry *deve;",
                "\tstruct se_node_acl *nacl;",
                "\tstruct se_lun *this_lun = NULL;",
                "\tstruct se_device *found_dev = NULL;",
                "\t/* cmd with NULL sess indicates no associated $FABRIC_MOD */",
                "\tif (!sess)",
                "\t\tgoto err_out;",
                "\tpr_debug(\"XCOPY 0xe4: searching for: %*ph\\n\",",
                "\t\t XCOPY_NAA_IEEE_REGEX_LEN, dev_wwn);",
                "",
                "\tnacl = sess->se_node_acl;",
                "\trcu_read_lock();",
                "\thlist_for_each_entry_rcu(deve, &nacl->lun_entry_hlist, link) {",
                "\t\tstruct se_device *this_dev;",
                "\t\tint rc;",
                "",
                "\t\tthis_lun = rcu_dereference(deve->se_lun);",
                "\t\tthis_dev = rcu_dereference_raw(this_lun->lun_se_dev);",
                "",
                "\t\trc = target_xcopy_locate_se_dev_e4_iter(this_dev, dev_wwn);",
                "\t\tif (rc) {",
                "\t\t\tif (percpu_ref_tryget_live(&this_lun->lun_ref))",
                "\t\t\t\tfound_dev = this_dev;",
                "\t\t\tbreak;",
                "\t\t}",
                "\trcu_read_unlock();",
                "\tif (found_dev == NULL)",
                "\t\tgoto err_out;",
                "",
                "\tpr_debug(\"lun_ref held for se_dev: %p se_dev->se_dev_group: %p\\n\",",
                "\t\t found_dev, &found_dev->dev_group);",
                "\t*_found_dev = found_dev;",
                "\t*_found_lun_ref = &this_lun->lun_ref;",
                "\treturn 0;",
                "err_out:",
                "\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");",
                "\treturn -EINVAL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28374",
        "func_name": "torvalds/linux/target_xcopy_parse_target_descriptors",
        "description": "In drivers/target/target_core_xcopy.c in the Linux kernel before 5.10.7, insufficient identifier checking in the LIO SCSI target code can be used by remote attackers to read or write files via directory traversal in an XCOPY request, aka CID-2896c93811e3. For example, an attack can occur over a network if the attacker has access to one iSCSI LUN. The attacker gains control over file access because I/O operations are proxied via an attacker-selected backstore.",
        "git_url": "https://github.com/torvalds/linux/commit/2896c93811e39d63a4d9b63ccf12a8fbc226e5e4",
        "commit_title": "scsi: target: Fix XCOPY NAA identifier lookup",
        "commit_text": " When attempting to match EXTENDED COPY CSCD descriptors with corresponding se_devices, target_xcopy_locate_se_dev_e4() currently iterates over LIO's global devices list which includes all configured backstores.  This change ensures that only initiator-accessible backstores are considered during CSCD descriptor lookup, according to the session's se_node_acl LUN list.  To avoid LUN removal race conditions, device pinning is changed from being configfs based to instead using the se_node_acl lun_ref.  Reference: CVE-2020-28374",
        "func_before": "static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,\n\t\t\t\tstruct xcopy_op *xop, unsigned char *p,\n\t\t\t\tunsigned short tdll, sense_reason_t *sense_ret)\n{\n\tstruct se_device *local_dev = se_cmd->se_dev;\n\tunsigned char *desc = p;\n\tint offset = tdll % XCOPY_TARGET_DESC_LEN, rc;\n\tunsigned short cscd_index = 0;\n\tunsigned short start = 0;\n\n\t*sense_ret = TCM_INVALID_PARAMETER_LIST;\n\n\tif (offset != 0) {\n\t\tpr_err(\"XCOPY target descriptor list length is not\"\n\t\t\t\" multiple of %d\\n\", XCOPY_TARGET_DESC_LEN);\n\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\treturn -EINVAL;\n\t}\n\tif (tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN) {\n\t\tpr_err(\"XCOPY target descriptor supports a maximum\"\n\t\t\t\" two src/dest descriptors, tdll: %hu too large..\\n\", tdll);\n\t\t/* spc4r37 6.4.3.4 CSCD DESCRIPTOR LIST LENGTH field */\n\t\t*sense_ret = TCM_TOO_MANY_TARGET_DESCS;\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Generate an IEEE Registered Extended designator based upon the\n\t * se_device the XCOPY was received upon..\n\t */\n\tmemset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]);\n\n\twhile (start < tdll) {\n\t\t/*\n\t\t * Check target descriptor identification with 0xE4 type, and\n\t\t * compare the current index with the CSCD descriptor IDs in\n\t\t * the segment descriptor. Use VPD 0x83 WWPN matching ..\n\t\t */\n\t\tswitch (desc[0]) {\n\t\tcase 0xe4:\n\t\t\trc = target_xcopy_parse_tiddesc_e4(se_cmd, xop,\n\t\t\t\t\t\t\t&desc[0], cscd_index);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto out;\n\t\t\tstart += XCOPY_TARGET_DESC_LEN;\n\t\t\tdesc += XCOPY_TARGET_DESC_LEN;\n\t\t\tcscd_index++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"XCOPY unsupported descriptor type code:\"\n\t\t\t\t\t\" 0x%02x\\n\", desc[0]);\n\t\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (xop->op_origin) {\n\tcase XCOL_SOURCE_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(xop->dst_tid_wwn,\n\t\t\t\t\t\t&xop->dst_dev);\n\t\tbreak;\n\tcase XCOL_DEST_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(xop->src_tid_wwn,\n\t\t\t\t\t\t&xop->src_dev);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"XCOPY CSCD descriptor IDs not found in CSCD list - \"\n\t\t\t\"stdi: %hu dtdi: %hu\\n\", xop->stdi, xop->dtdi);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\t/*\n\t * If a matching IEEE NAA 0x83 descriptor for the requested device\n\t * is not located on this node, return COPY_ABORTED with ASQ/ASQC\n\t * 0x0d/0x02 - COPY_TARGET_DEVICE_NOT_REACHABLE to request the\n\t * initiator to fall back to normal copy method.\n\t */\n\tif (rc < 0) {\n\t\t*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->src_dev, &xop->src_tid_wwn[0]);\n\tpr_debug(\"XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->dst_dev, &xop->dst_tid_wwn[0]);\n\n\treturn cscd_index;\n\nout:\n\treturn -EINVAL;\n}",
        "func": "static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,\n\t\t\t\tstruct xcopy_op *xop, unsigned char *p,\n\t\t\t\tunsigned short tdll, sense_reason_t *sense_ret)\n{\n\tstruct se_device *local_dev = se_cmd->se_dev;\n\tunsigned char *desc = p;\n\tint offset = tdll % XCOPY_TARGET_DESC_LEN, rc;\n\tunsigned short cscd_index = 0;\n\tunsigned short start = 0;\n\n\t*sense_ret = TCM_INVALID_PARAMETER_LIST;\n\n\tif (offset != 0) {\n\t\tpr_err(\"XCOPY target descriptor list length is not\"\n\t\t\t\" multiple of %d\\n\", XCOPY_TARGET_DESC_LEN);\n\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\treturn -EINVAL;\n\t}\n\tif (tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN) {\n\t\tpr_err(\"XCOPY target descriptor supports a maximum\"\n\t\t\t\" two src/dest descriptors, tdll: %hu too large..\\n\", tdll);\n\t\t/* spc4r37 6.4.3.4 CSCD DESCRIPTOR LIST LENGTH field */\n\t\t*sense_ret = TCM_TOO_MANY_TARGET_DESCS;\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * Generate an IEEE Registered Extended designator based upon the\n\t * se_device the XCOPY was received upon..\n\t */\n\tmemset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]);\n\n\twhile (start < tdll) {\n\t\t/*\n\t\t * Check target descriptor identification with 0xE4 type, and\n\t\t * compare the current index with the CSCD descriptor IDs in\n\t\t * the segment descriptor. Use VPD 0x83 WWPN matching ..\n\t\t */\n\t\tswitch (desc[0]) {\n\t\tcase 0xe4:\n\t\t\trc = target_xcopy_parse_tiddesc_e4(se_cmd, xop,\n\t\t\t\t\t\t\t&desc[0], cscd_index);\n\t\t\tif (rc != 0)\n\t\t\t\tgoto out;\n\t\t\tstart += XCOPY_TARGET_DESC_LEN;\n\t\t\tdesc += XCOPY_TARGET_DESC_LEN;\n\t\t\tcscd_index++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"XCOPY unsupported descriptor type code:\"\n\t\t\t\t\t\" 0x%02x\\n\", desc[0]);\n\t\t\t*sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (xop->op_origin) {\n\tcase XCOL_SOURCE_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n\t\t\t\t\t\txop->dst_tid_wwn,\n\t\t\t\t\t\t&xop->dst_dev,\n\t\t\t\t\t\t&xop->remote_lun_ref);\n\t\tbreak;\n\tcase XCOL_DEST_RECV_OP:\n\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n\t\t\t\t\t\txop->src_tid_wwn,\n\t\t\t\t\t\t&xop->src_dev,\n\t\t\t\t\t\t&xop->remote_lun_ref);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"XCOPY CSCD descriptor IDs not found in CSCD list - \"\n\t\t\t\"stdi: %hu dtdi: %hu\\n\", xop->stdi, xop->dtdi);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\t/*\n\t * If a matching IEEE NAA 0x83 descriptor for the requested device\n\t * is not located on this node, return COPY_ABORTED with ASQ/ASQC\n\t * 0x0d/0x02 - COPY_TARGET_DEVICE_NOT_REACHABLE to request the\n\t * initiator to fall back to normal copy method.\n\t */\n\tif (rc < 0) {\n\t\t*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->src_dev, &xop->src_tid_wwn[0]);\n\tpr_debug(\"XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\\n\",\n\t\t xop->dst_dev, &xop->dst_tid_wwn[0]);\n\n\treturn cscd_index;\n\nout:\n\treturn -EINVAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,12 +56,16 @@\n \n \tswitch (xop->op_origin) {\n \tcase XCOL_SOURCE_RECV_OP:\n-\t\trc = target_xcopy_locate_se_dev_e4(xop->dst_tid_wwn,\n-\t\t\t\t\t\t&xop->dst_dev);\n+\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n+\t\t\t\t\t\txop->dst_tid_wwn,\n+\t\t\t\t\t\t&xop->dst_dev,\n+\t\t\t\t\t\t&xop->remote_lun_ref);\n \t\tbreak;\n \tcase XCOL_DEST_RECV_OP:\n-\t\trc = target_xcopy_locate_se_dev_e4(xop->src_tid_wwn,\n-\t\t\t\t\t\t&xop->src_dev);\n+\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,\n+\t\t\t\t\t\txop->src_tid_wwn,\n+\t\t\t\t\t\t&xop->src_dev,\n+\t\t\t\t\t\t&xop->remote_lun_ref);\n \t\tbreak;\n \tdefault:\n \t\tpr_err(\"XCOPY CSCD descriptor IDs not found in CSCD list - \"",
        "diff_line_info": {
            "deleted_lines": [
                "\t\trc = target_xcopy_locate_se_dev_e4(xop->dst_tid_wwn,",
                "\t\t\t\t\t\t&xop->dst_dev);",
                "\t\trc = target_xcopy_locate_se_dev_e4(xop->src_tid_wwn,",
                "\t\t\t\t\t\t&xop->src_dev);"
            ],
            "added_lines": [
                "\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,",
                "\t\t\t\t\t\txop->dst_tid_wwn,",
                "\t\t\t\t\t\t&xop->dst_dev,",
                "\t\t\t\t\t\t&xop->remote_lun_ref);",
                "\t\trc = target_xcopy_locate_se_dev_e4(se_cmd->se_sess,",
                "\t\t\t\t\t\txop->src_tid_wwn,",
                "\t\t\t\t\t\t&xop->src_dev,",
                "\t\t\t\t\t\t&xop->remote_lun_ref);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3139",
        "func_name": "open-iscsi/tcmu-runner/xcopy_parse_parameter_list",
        "description": "In Open-iSCSI tcmu-runner 1.3.x, 1.4.x, and 1.5.x through 1.5.2, xcopy_locate_udev in tcmur_cmd_handler.c lacks a check for transport-layer restrictions, allowing remote attackers to read or write files via directory traversal in an XCOPY request. For example, an attack can occur over a network if the attacker has access to one iSCSI LUN. NOTE: relative to CVE-2020-28374, this is a similar mistake in a different algorithm.",
        "git_url": "https://github.com/open-iscsi/tcmu-runner/commit/2b16e96e6b63d0419d857f53e4cc67f0adb383fd",
        "commit_title": "tcmur: fail cross-device XCOPY requests",
        "commit_text": " tcmu-runner can't determine whether the device(s) referred to in XCOPY Copy Source/Copy Destination (CSCD) descriptors should be accessible to the initiator via transport settings, ACLs, etc. Consequently, fail XCOPY requests with CSCD descriptors which refer to any device other than where the XCOPY request is processed.  References: CVE-2020-28374",
        "func_before": "static int xcopy_parse_parameter_list(struct tcmu_device *dev,\n\t\t\t\t      struct tcmulib_cmd *cmd,\n\t\t\t\t      struct xcopy *xcopy)\n{\n\tuint8_t *cdb = cmd->cdb;\n\tsize_t data_length = tcmu_cdb_get_xfer_length(cdb);\n\tstruct iovec *iovec = cmd->iovec;\n\tsize_t iov_cnt = cmd->iov_cnt;\n\tuint32_t inline_dl;\n\tuint8_t *seg_desc, *tgt_desc, *par;\n\tuint16_t sdll, tdll;\n\tuint64_t num_lbas;\n\tint ret;\n\n\t/*\n\t * The PARAMETER LIST LENGTH field specifies the length in bytes\n\t * of the parameter data that shall be contained in the Data-Out\n\t * Buffer.\n\t*/\n\tpar = calloc(1, data_length);\n\tif (!par) {\n\t\ttcmu_dev_err(dev, \"calloc parameter list buffer error\\n\");\n\t\treturn TCMU_STS_NO_RESOURCE;\n\t}\n\n\ttcmu_memcpy_from_iovec(par, data_length, iovec, iov_cnt);\n\n\t/*\n\t * From spc4r31, section 6.18.4 OPERATING PARAMETERS service action\n\t *\n\t * A supports no list identifier (SNLID) bit set to one indicates\n\t * the copy manager supports an EXTENDED COPY (see 6.3) command\n\t * parameter list in which the LIST ID USAGE field is set to 11b\n\t * and the LIST IDENTIFIER field is set to zero as described in\n\t * table 105 (see 6.3.1).\n\t *\n\t * From spc4r31, section 6.3.1 EXTENDED COPY command introduction\n\t *\n\t * LIST ID USAGE == 11b, then the LIST IDENTIFIER field should be\n\t * as zero.\n\t */\n\ttcmu_dev_dbg(dev, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t     (par[1] & 0x18) >> 3, par[0]);\n\tif ((par[1] & 0x18) != 0x18 || par[0]) {\n\t\ttcmu_dev_err(dev, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t\t     (par[1] & 0x18) >> 3, par[0]);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * From spc4r31, section 6.3.6.1 Target descriptors introduction\n\t *\n\t * All target descriptors (see table 108) are 32 bytes or 64 bytes\n\t * in length\n\t * From spc4r36q, section6.4.3.4\n\t * An EXTENDED COPY command may reference one or more CSCDs.\n\t */\n\ttdll = be16toh(*(uint16_t *)&par[2]);\n\tif (tdll < 32 || tdll % 32 != 0) {\n\t\ttcmu_dev_err(dev, \"Illegal target descriptor length %u\\n\",\n\t\t\t     tdll);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * From spc4r31, section 6.3.7.1 Segment descriptors introduction\n\t *\n\t * Segment descriptors (see table 120) begin with an eight byte header.\n\t */\n\tsdll = be32toh(*(uint32_t *)&par[8]);\n\tif (sdll < 8) {\n\t\ttcmu_dev_err(dev, \"Illegal segment descriptor length %u\\n\",\n\t\t\t     tdll);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * The maximum length of the target and segment descriptors permitted\n\t * within a parameter list is indicated by the MAXIMUM DESCRIPTOR LIST\n\t * LENGTH field in the copy managers operating parameters.\n\t */\n\tif (tdll + sdll > RCR_OP_MAX_DESC_LIST_LEN) {\n\t\ttcmu_dev_err(dev, \"descriptor list length %u exceeds maximum %u\\n\",\n\t\t\t     tdll + sdll, RCR_OP_MAX_DESC_LIST_LEN);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * The INLINE DATA LENGTH field contains the number of bytes of inline\n\t * data, after the last segment descriptor.\n\t * */\n\tinline_dl = be32toh(*(uint32_t *)&par[12]);\n\n\t/* From spc4r31, section 6.3.1 EXTENDED COPY command introduction\n\t *\n\t * The EXTENDED COPY parameter list (see table 104) begins with a 16\n\t * byte header.\n\t *\n\t * The data length in CDB should be equal to tdll + sdll + inline_dl\n\t * + parameter list header length\n\t */\n\tif (data_length < (XCOPY_HDR_LEN + tdll + sdll + inline_dl)) {\n\t\ttcmu_dev_err(dev, \"Illegal list length: length from CDB is %zu,\"\n\t\t\t     \" but here the length is %u\\n\",\n\t\t\t     data_length, tdll + sdll + inline_dl);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\ttcmu_dev_dbg(dev, \"Processing XCOPY with tdll: %hu sdll: %u inline_dl: %u\\n\",\n\t\t     tdll, sdll, inline_dl);\n\n\t/*\n\t * Parse the segment descripters and for now we only support block\n\t * -> block type.\n\t *\n\t * The max seg_desc number support is 1(see RCR_OP_MAX_SG_DESC_COUNT)\n\t */\n\tseg_desc = par + XCOPY_HDR_LEN + tdll;\n\tret = xcopy_parse_segment_descs(seg_desc, xcopy, sdll);\n\tif (ret != TCMU_STS_OK)\n\t\tgoto err;\n\n\t/*\n\t * Parse the target descripter\n\t *\n\t * The max seg_desc number support is 2(see RCR_OP_MAX_TARGET_DESC_COUNT)\n\t */\n\ttgt_desc = par + XCOPY_HDR_LEN;\n\tret = xcopy_parse_target_descs(dev, xcopy, tgt_desc, tdll);\n\tif (ret != TCMU_STS_OK)\n\t\tgoto err;\n\n\tif (tcmu_dev_get_block_size(xcopy->src_dev) !=\n\t    tcmu_dev_get_block_size(xcopy->dst_dev)) {\n\t\ttcmu_dev_err(dev, \"The block size of src dev %u != dst dev %u\\n\",\n\t\t\t     tcmu_dev_get_block_size(xcopy->src_dev),\n\t\t\t     tcmu_dev_get_block_size(xcopy->dst_dev));\n\t\tret = TCMU_STS_INVALID_CP_TGT_DEV_TYPE;\n\t\tgoto err;\n\t}\n\n\tnum_lbas = tcmu_dev_get_num_lbas(xcopy->src_dev);\n\tif (xcopy->src_lba + xcopy->lba_cnt > num_lbas) {\n\t\ttcmu_dev_err(xcopy->src_dev,\n\t\t\t     \"src target exceeds last lba %\"PRIu64\" (lba %\"PRIu64\", copy len %u\\n\",\n\t\t\t     num_lbas, xcopy->src_lba, xcopy->lba_cnt);\n\t\tret = TCMU_STS_RANGE;\n\t\tgoto err;\n\t}\n\n\tnum_lbas = tcmu_dev_get_num_lbas(xcopy->dst_dev);\n\tif (xcopy->dst_lba + xcopy->lba_cnt > num_lbas) {\n\t\ttcmu_dev_err(xcopy->dst_dev,\n\t\t\t     \"dst target exceeds last lba %\"PRIu64\" (lba %\"PRIu64\", copy len %u)\\n\",\n\t\t\t     num_lbas, xcopy->dst_lba, xcopy->lba_cnt);\n\t\tret = TCMU_STS_RANGE;\n\t\tgoto err;\n\t}\n\n\tfree(par);\n\treturn TCMU_STS_OK;\n\nerr:\n\tfree(par);\n\n\treturn ret;\n}",
        "func": "static int xcopy_parse_parameter_list(struct tcmu_device *dev,\n\t\t\t\t      struct tcmulib_cmd *cmd,\n\t\t\t\t      struct xcopy *xcopy)\n{\n\tuint8_t *cdb = cmd->cdb;\n\tsize_t data_length = tcmu_cdb_get_xfer_length(cdb);\n\tstruct iovec *iovec = cmd->iovec;\n\tsize_t iov_cnt = cmd->iov_cnt;\n\tuint32_t inline_dl;\n\tuint8_t *seg_desc, *tgt_desc, *par;\n\tuint16_t sdll, tdll;\n\tuint64_t num_lbas;\n\tint ret;\n\n\t/*\n\t * The PARAMETER LIST LENGTH field specifies the length in bytes\n\t * of the parameter data that shall be contained in the Data-Out\n\t * Buffer.\n\t*/\n\tpar = calloc(1, data_length);\n\tif (!par) {\n\t\ttcmu_dev_err(dev, \"calloc parameter list buffer error\\n\");\n\t\treturn TCMU_STS_NO_RESOURCE;\n\t}\n\n\ttcmu_memcpy_from_iovec(par, data_length, iovec, iov_cnt);\n\n\t/*\n\t * From spc4r31, section 6.18.4 OPERATING PARAMETERS service action\n\t *\n\t * A supports no list identifier (SNLID) bit set to one indicates\n\t * the copy manager supports an EXTENDED COPY (see 6.3) command\n\t * parameter list in which the LIST ID USAGE field is set to 11b\n\t * and the LIST IDENTIFIER field is set to zero as described in\n\t * table 105 (see 6.3.1).\n\t *\n\t * From spc4r31, section 6.3.1 EXTENDED COPY command introduction\n\t *\n\t * LIST ID USAGE == 11b, then the LIST IDENTIFIER field should be\n\t * as zero.\n\t */\n\ttcmu_dev_dbg(dev, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t     (par[1] & 0x18) >> 3, par[0]);\n\tif ((par[1] & 0x18) != 0x18 || par[0]) {\n\t\ttcmu_dev_err(dev, \"LIST ID USAGE: 0x%x, LIST IDENTIFIER: 0x%x\\n\",\n\t\t\t     (par[1] & 0x18) >> 3, par[0]);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * From spc4r31, section 6.3.6.1 Target descriptors introduction\n\t *\n\t * All target descriptors (see table 108) are 32 bytes or 64 bytes\n\t * in length\n\t * From spc4r36q, section6.4.3.4\n\t * An EXTENDED COPY command may reference one or more CSCDs.\n\t */\n\ttdll = be16toh(*(uint16_t *)&par[2]);\n\tif (tdll < 32 || tdll % 32 != 0) {\n\t\ttcmu_dev_err(dev, \"Illegal target descriptor length %u\\n\",\n\t\t\t     tdll);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * From spc4r31, section 6.3.7.1 Segment descriptors introduction\n\t *\n\t * Segment descriptors (see table 120) begin with an eight byte header.\n\t */\n\tsdll = be32toh(*(uint32_t *)&par[8]);\n\tif (sdll < 8) {\n\t\ttcmu_dev_err(dev, \"Illegal segment descriptor length %u\\n\",\n\t\t\t     tdll);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * The maximum length of the target and segment descriptors permitted\n\t * within a parameter list is indicated by the MAXIMUM DESCRIPTOR LIST\n\t * LENGTH field in the copy managers operating parameters.\n\t */\n\tif (tdll + sdll > RCR_OP_MAX_DESC_LIST_LEN) {\n\t\ttcmu_dev_err(dev, \"descriptor list length %u exceeds maximum %u\\n\",\n\t\t\t     tdll + sdll, RCR_OP_MAX_DESC_LIST_LEN);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * The INLINE DATA LENGTH field contains the number of bytes of inline\n\t * data, after the last segment descriptor.\n\t * */\n\tinline_dl = be32toh(*(uint32_t *)&par[12]);\n\n\t/* From spc4r31, section 6.3.1 EXTENDED COPY command introduction\n\t *\n\t * The EXTENDED COPY parameter list (see table 104) begins with a 16\n\t * byte header.\n\t *\n\t * The data length in CDB should be equal to tdll + sdll + inline_dl\n\t * + parameter list header length\n\t */\n\tif (data_length < (XCOPY_HDR_LEN + tdll + sdll + inline_dl)) {\n\t\ttcmu_dev_err(dev, \"Illegal list length: length from CDB is %zu,\"\n\t\t\t     \" but here the length is %u\\n\",\n\t\t\t     data_length, tdll + sdll + inline_dl);\n\t\tret = TCMU_STS_INVALID_PARAM_LIST_LEN;\n\t\tgoto err;\n\t}\n\n\ttcmu_dev_dbg(dev, \"Processing XCOPY with tdll: %hu sdll: %u inline_dl: %u\\n\",\n\t\t     tdll, sdll, inline_dl);\n\n\t/*\n\t * Parse the segment descripters and for now we only support block\n\t * -> block type.\n\t *\n\t * The max seg_desc number support is 1(see RCR_OP_MAX_SG_DESC_COUNT)\n\t */\n\tseg_desc = par + XCOPY_HDR_LEN + tdll;\n\tret = xcopy_parse_segment_descs(seg_desc, xcopy, sdll);\n\tif (ret != TCMU_STS_OK)\n\t\tgoto err;\n\n\t/*\n\t * Parse the target descripter\n\t *\n\t * The max seg_desc number support is 2(see RCR_OP_MAX_TARGET_DESC_COUNT)\n\t */\n\ttgt_desc = par + XCOPY_HDR_LEN;\n\tret = xcopy_parse_target_descs(dev, xcopy, tgt_desc, tdll);\n\tif (ret != TCMU_STS_OK)\n\t\tgoto err;\n\n\t/*\n\t * tcmu-runner can't determine whether the device(s) referred to in an\n\t * XCOPY request should be accessible to the initiator via transport\n\t * settings, ACLs, etc. XXX Consequently, we need to fail any\n\t * cross-device requests for safety reasons.\n\t */\n\tif (dev != xcopy->src_dev || dev != xcopy->dst_dev) {\n\t\ttcmu_dev_err(dev, \"Cross-device XCOPY not supported\\n\");\n\t\tret = TCMU_STS_CP_TGT_DEV_NOTCONN;\n\t\tgoto err;\n\t}\n\n\tif (tcmu_dev_get_block_size(xcopy->src_dev) !=\n\t    tcmu_dev_get_block_size(xcopy->dst_dev)) {\n\t\ttcmu_dev_err(dev, \"The block size of src dev %u != dst dev %u\\n\",\n\t\t\t     tcmu_dev_get_block_size(xcopy->src_dev),\n\t\t\t     tcmu_dev_get_block_size(xcopy->dst_dev));\n\t\tret = TCMU_STS_INVALID_CP_TGT_DEV_TYPE;\n\t\tgoto err;\n\t}\n\n\tnum_lbas = tcmu_dev_get_num_lbas(xcopy->src_dev);\n\tif (xcopy->src_lba + xcopy->lba_cnt > num_lbas) {\n\t\ttcmu_dev_err(xcopy->src_dev,\n\t\t\t     \"src target exceeds last lba %\"PRIu64\" (lba %\"PRIu64\", copy len %u\\n\",\n\t\t\t     num_lbas, xcopy->src_lba, xcopy->lba_cnt);\n\t\tret = TCMU_STS_RANGE;\n\t\tgoto err;\n\t}\n\n\tnum_lbas = tcmu_dev_get_num_lbas(xcopy->dst_dev);\n\tif (xcopy->dst_lba + xcopy->lba_cnt > num_lbas) {\n\t\ttcmu_dev_err(xcopy->dst_dev,\n\t\t\t     \"dst target exceeds last lba %\"PRIu64\" (lba %\"PRIu64\", copy len %u)\\n\",\n\t\t\t     num_lbas, xcopy->dst_lba, xcopy->lba_cnt);\n\t\tret = TCMU_STS_RANGE;\n\t\tgoto err;\n\t}\n\n\tfree(par);\n\treturn TCMU_STS_OK;\n\nerr:\n\tfree(par);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -135,6 +135,18 @@\n \tif (ret != TCMU_STS_OK)\n \t\tgoto err;\n \n+\t/*\n+\t * tcmu-runner can't determine whether the device(s) referred to in an\n+\t * XCOPY request should be accessible to the initiator via transport\n+\t * settings, ACLs, etc. XXX Consequently, we need to fail any\n+\t * cross-device requests for safety reasons.\n+\t */\n+\tif (dev != xcopy->src_dev || dev != xcopy->dst_dev) {\n+\t\ttcmu_dev_err(dev, \"Cross-device XCOPY not supported\\n\");\n+\t\tret = TCMU_STS_CP_TGT_DEV_NOTCONN;\n+\t\tgoto err;\n+\t}\n+\n \tif (tcmu_dev_get_block_size(xcopy->src_dev) !=\n \t    tcmu_dev_get_block_size(xcopy->dst_dev)) {\n \t\ttcmu_dev_err(dev, \"The block size of src dev %u != dst dev %u\\n\",",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/*",
                "\t * tcmu-runner can't determine whether the device(s) referred to in an",
                "\t * XCOPY request should be accessible to the initiator via transport",
                "\t * settings, ACLs, etc. XXX Consequently, we need to fail any",
                "\t * cross-device requests for safety reasons.",
                "\t */",
                "\tif (dev != xcopy->src_dev || dev != xcopy->dst_dev) {",
                "\t\ttcmu_dev_err(dev, \"Cross-device XCOPY not supported\\n\");",
                "\t\tret = TCMU_STS_CP_TGT_DEV_NOTCONN;",
                "\t\tgoto err;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3178",
        "func_name": "torvalds/linux/compose_entry_fh",
        "description": "fs/nfsd/nfs3xdr.c in the Linux kernel through 5.10.8, when there is an NFS export of a subdirectory of a filesystem, allows remote attackers to traverse to other parts of the filesystem via READDIRPLUS. NOTE: some parties argue that such a subdirectory export is not intended to prevent this attack; see also the exports(5) no_subtree_check default behavior",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=51b2ee7d006a736a9126e8111d1f24e4fd0afaa6",
        "commit_title": "If you export a subdirectory of a filesystem, a READDIRPLUS on the root",
        "commit_text": "of that export will return the filehandle of the parent with the \"..\" entry.  The filehandle is optional, so let's just not return the filehandle for \"..\" if we're at the root of an export.  Note that once the client learns one filehandle outside of the export, they can trivially access the rest of the export using further lookups.  However, it is also not very difficult to guess filehandles outside of the export.  So exporting a subdirectory of a filesystem should considered equivalent to providing access to the entire filesystem.  To avoid confusion, we recommend only exporting entire filesystems.  Cc: stable@vger.kernel.org ",
        "func_before": "static __be32\ncompose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/* filesystem root - cannot return filehandle for \"..\" */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_positive_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}",
        "func": "static __be32\ncompose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/*\n\t\t\t * Don't return filehandle for \"..\" if we're at\n\t\t\t * the filesystem or export root:\n\t\t\t */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t\tif (dparent == exp->ex_path.dentry)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_positive_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,13 @@\n \tif (isdotent(name, namlen)) {\n \t\tif (namlen == 2) {\n \t\t\tdchild = dget_parent(dparent);\n-\t\t\t/* filesystem root - cannot return filehandle for \"..\" */\n+\t\t\t/*\n+\t\t\t * Don't return filehandle for \"..\" if we're at\n+\t\t\t * the filesystem or export root:\n+\t\t\t */\n \t\t\tif (dchild == dparent)\n+\t\t\t\tgoto out;\n+\t\t\tif (dparent == exp->ex_path.dentry)\n \t\t\t\tgoto out;\n \t\t} else\n \t\t\tdchild = dget(dparent);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t/* filesystem root - cannot return filehandle for \"..\" */"
            ],
            "added_lines": [
                "\t\t\t/*",
                "\t\t\t * Don't return filehandle for \"..\" if we're at",
                "\t\t\t * the filesystem or export root:",
                "\t\t\t */",
                "\t\t\t\tgoto out;",
                "\t\t\tif (dparent == exp->ex_path.dentry)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36241",
        "func_name": "GNOME/gnome-autoar/autoar_extractor_do_sanitize_pathname",
        "description": "autoar-extractor.c in GNOME gnome-autoar through 0.2.4, as used by GNOME Shell, Nautilus, and other software, allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink to a directory outside of the intended extraction location.",
        "git_url": "https://github.com/GNOME/gnome-autoar/commit/adb067e645732fdbe7103516e506d09eb6a54429",
        "commit_title": "AutoarExtractor: Do not extract files outside the destination dir",
        "commit_text": " Currently, a malicious archive can cause that the files are extracted outside of the destination dir. This can happen if the archive contains a file whose parent is a symbolic link, which points outside of the destination dir. This is potentially a security threat similar to CVE-2020-11736. Let's skip such problematic files when extracting. ",
        "func_before": "static GFile*\nautoar_extractor_do_sanitize_pathname (AutoarExtractor *self,\n                                       const char      *pathname_bytes)\n{\n  GFile *extracted_filename;\n  gboolean valid_filename;\n  g_autofree char *sanitized_pathname;\n  g_autofree char *utf8_pathname;\n\n  utf8_pathname = autoar_common_get_utf8_pathname (pathname_bytes);\n  extracted_filename = g_file_get_child (self->destination_dir,\n                                         utf8_pathname ?  utf8_pathname : pathname_bytes);\n\n  valid_filename =\n    g_file_equal (extracted_filename, self->destination_dir) ||\n    g_file_has_prefix (extracted_filename, self->destination_dir);\n\n  if (!valid_filename) {\n    g_autofree char *basename;\n\n    basename = g_file_get_basename (extracted_filename);\n\n    g_object_unref (extracted_filename);\n\n    extracted_filename = g_file_get_child (self->destination_dir,\n                                           basename);\n  }\n\n  if (self->prefix != NULL && self->new_prefix != NULL) {\n    g_autofree char *relative_path;\n    /* Replace the old prefix with the new one */\n    relative_path = g_file_get_relative_path (self->prefix,\n                                              extracted_filename);\n\n    relative_path = relative_path != NULL ? relative_path : g_strdup (\"\");\n\n    g_object_unref (extracted_filename);\n\n    extracted_filename = g_file_get_child (self->new_prefix,\n                                           relative_path);\n  }\n\n  sanitized_pathname = g_file_get_path (extracted_filename);\n\n  g_debug (\"autoar_extractor_do_sanitize_pathname: %s\", sanitized_pathname);\n\n  return extracted_filename;\n}",
        "func": "static GFile*\nautoar_extractor_do_sanitize_pathname (AutoarExtractor *self,\n                                       const char      *pathname_bytes)\n{\n  GFile *extracted_filename;\n  gboolean valid_filename;\n  g_autofree char *sanitized_pathname = NULL;\n  g_autofree char *utf8_pathname;\n\n  utf8_pathname = autoar_common_get_utf8_pathname (pathname_bytes);\n  extracted_filename = g_file_get_child (self->destination_dir,\n                                         utf8_pathname ?  utf8_pathname : pathname_bytes);\n\n  valid_filename = is_valid_filename (extracted_filename, self->destination_dir);\n  if (!valid_filename) {\n    g_warning (\"autoar_extractor_do_sanitize_pathname: %s is outside of the destination dir\",\n                g_file_peek_path (extracted_filename));\n\n    g_object_unref (extracted_filename);\n\n    return NULL;\n  }\n\n  if (self->prefix != NULL && self->new_prefix != NULL) {\n    g_autofree char *relative_path;\n    /* Replace the old prefix with the new one */\n    relative_path = g_file_get_relative_path (self->prefix,\n                                              extracted_filename);\n\n    relative_path = relative_path != NULL ? relative_path : g_strdup (\"\");\n\n    g_object_unref (extracted_filename);\n\n    extracted_filename = g_file_get_child (self->new_prefix,\n                                           relative_path);\n  }\n\n  sanitized_pathname = g_file_get_path (extracted_filename);\n\n  g_debug (\"autoar_extractor_do_sanitize_pathname: %s\", sanitized_pathname);\n\n  return extracted_filename;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,26 +4,21 @@\n {\n   GFile *extracted_filename;\n   gboolean valid_filename;\n-  g_autofree char *sanitized_pathname;\n+  g_autofree char *sanitized_pathname = NULL;\n   g_autofree char *utf8_pathname;\n \n   utf8_pathname = autoar_common_get_utf8_pathname (pathname_bytes);\n   extracted_filename = g_file_get_child (self->destination_dir,\n                                          utf8_pathname ?  utf8_pathname : pathname_bytes);\n \n-  valid_filename =\n-    g_file_equal (extracted_filename, self->destination_dir) ||\n-    g_file_has_prefix (extracted_filename, self->destination_dir);\n-\n+  valid_filename = is_valid_filename (extracted_filename, self->destination_dir);\n   if (!valid_filename) {\n-    g_autofree char *basename;\n-\n-    basename = g_file_get_basename (extracted_filename);\n+    g_warning (\"autoar_extractor_do_sanitize_pathname: %s is outside of the destination dir\",\n+                g_file_peek_path (extracted_filename));\n \n     g_object_unref (extracted_filename);\n \n-    extracted_filename = g_file_get_child (self->destination_dir,\n-                                           basename);\n+    return NULL;\n   }\n \n   if (self->prefix != NULL && self->new_prefix != NULL) {",
        "diff_line_info": {
            "deleted_lines": [
                "  g_autofree char *sanitized_pathname;",
                "  valid_filename =",
                "    g_file_equal (extracted_filename, self->destination_dir) ||",
                "    g_file_has_prefix (extracted_filename, self->destination_dir);",
                "",
                "    g_autofree char *basename;",
                "",
                "    basename = g_file_get_basename (extracted_filename);",
                "    extracted_filename = g_file_get_child (self->destination_dir,",
                "                                           basename);"
            ],
            "added_lines": [
                "  g_autofree char *sanitized_pathname = NULL;",
                "  valid_filename = is_valid_filename (extracted_filename, self->destination_dir);",
                "    g_warning (\"autoar_extractor_do_sanitize_pathname: %s is outside of the destination dir\",",
                "                g_file_peek_path (extracted_filename));",
                "    return NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36241",
        "func_name": "GNOME/gnome-autoar/autoar_extractor_step_extract",
        "description": "autoar-extractor.c in GNOME gnome-autoar through 0.2.4, as used by GNOME Shell, Nautilus, and other software, allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink to a directory outside of the intended extraction location.",
        "git_url": "https://github.com/GNOME/gnome-autoar/commit/adb067e645732fdbe7103516e506d09eb6a54429",
        "commit_title": "AutoarExtractor: Do not extract files outside the destination dir",
        "commit_text": " Currently, a malicious archive can cause that the files are extracted outside of the destination dir. This can happen if the archive contains a file whose parent is a symbolic link, which points outside of the destination dir. This is potentially a security threat similar to CVE-2020-11736. Let's skip such problematic files when extracting. ",
        "func_before": "static void\nautoar_extractor_step_extract (AutoarExtractor *self) {\n  /* Step 3: Extract files\n   * We have to re-open the archive to extract files\n   */\n\n  struct archive *a;\n  struct archive_entry *entry;\n\n  int r;\n\n  g_debug (\"autoar_extractor_step_extract: called\");\n\n  r = libarchive_create_read_object (self->use_raw_format, self, &a);\n  if (r != ARCHIVE_OK) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n    const char *pathname;\n    const char *hardlink;\n    g_autoptr (GFile) extracted_filename = NULL;\n    g_autoptr (GFile) hardlink_filename = NULL;\n    AutoarConflictAction action;\n    gboolean file_conflict;\n\n    if (g_cancellable_is_cancelled (self->cancellable)) {\n      archive_read_free (a);\n      return;\n    }\n\n    pathname = archive_entry_pathname (entry);\n    hardlink = archive_entry_hardlink (entry);\n\n    extracted_filename =\n      autoar_extractor_do_sanitize_pathname (self, pathname);\n\n    if (hardlink != NULL) {\n      hardlink_filename =\n        autoar_extractor_do_sanitize_pathname (self, hardlink);\n    }\n\n    /* Attempt to solve any name conflict before doing any operations */\n    file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                          archive_entry_filetype (entry));\n    while (file_conflict) {\n      GFile *new_extracted_filename = NULL;\n\n      action = autoar_extractor_signal_conflict (self,\n                                                 extracted_filename,\n                                                 &new_extracted_filename);\n\n      switch (action) {\n        case AUTOAR_CONFLICT_OVERWRITE:\n          break;\n        case AUTOAR_CONFLICT_CHANGE_DESTINATION:\n          g_assert_nonnull (new_extracted_filename);\n          g_clear_object (&extracted_filename);\n          extracted_filename = new_extracted_filename;\n          break;\n        case AUTOAR_CONFLICT_SKIP:\n          archive_read_data_skip (a);\n          break;\n        default:\n          g_assert_not_reached ();\n          break;\n      }\n\n      if (action != AUTOAR_CONFLICT_CHANGE_DESTINATION) {\n        break;\n      }\n\n      file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                            archive_entry_filetype (entry));\n    }\n\n    if (file_conflict && action == AUTOAR_CONFLICT_SKIP) {\n      continue;\n    }\n\n    autoar_extractor_do_write_entry (self, a, entry,\n                                     extracted_filename, hardlink_filename);\n\n    if (self->error != NULL) {\n      archive_read_free (a);\n      return;\n    }\n\n    self->completed_files++;\n    autoar_extractor_signal_progress (self);\n  }\n\n  if (r != ARCHIVE_EOF) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  archive_read_free (a);\n}",
        "func": "static void\nautoar_extractor_step_extract (AutoarExtractor *self) {\n  /* Step 3: Extract files\n   * We have to re-open the archive to extract files\n   */\n\n  struct archive *a;\n  struct archive_entry *entry;\n\n  int r;\n\n  g_debug (\"autoar_extractor_step_extract: called\");\n\n  r = libarchive_create_read_object (self->use_raw_format, self, &a);\n  if (r != ARCHIVE_OK) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n    const char *pathname;\n    const char *hardlink;\n    g_autoptr (GFile) extracted_filename = NULL;\n    g_autoptr (GFile) hardlink_filename = NULL;\n    AutoarConflictAction action;\n    gboolean file_conflict;\n\n    if (g_cancellable_is_cancelled (self->cancellable)) {\n      archive_read_free (a);\n      return;\n    }\n\n    pathname = archive_entry_pathname (entry);\n    hardlink = archive_entry_hardlink (entry);\n\n    extracted_filename =\n      autoar_extractor_do_sanitize_pathname (self, pathname);\n    if (extracted_filename == NULL) {\n      archive_read_data_skip (a);\n      continue;\n    }\n\n    if (hardlink != NULL) {\n      hardlink_filename =\n        autoar_extractor_do_sanitize_pathname (self, hardlink);\n        if (hardlink_filename == NULL) {\n          archive_read_data_skip (a);\n          continue;\n        }\n    }\n\n    /* Attempt to solve any name conflict before doing any operations */\n    file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                          archive_entry_filetype (entry));\n    while (file_conflict) {\n      GFile *new_extracted_filename = NULL;\n\n      action = autoar_extractor_signal_conflict (self,\n                                                 extracted_filename,\n                                                 &new_extracted_filename);\n\n      switch (action) {\n        case AUTOAR_CONFLICT_OVERWRITE:\n          break;\n        case AUTOAR_CONFLICT_CHANGE_DESTINATION:\n          g_assert_nonnull (new_extracted_filename);\n          g_clear_object (&extracted_filename);\n          extracted_filename = new_extracted_filename;\n          break;\n        case AUTOAR_CONFLICT_SKIP:\n          archive_read_data_skip (a);\n          break;\n        default:\n          g_assert_not_reached ();\n          break;\n      }\n\n      if (action != AUTOAR_CONFLICT_CHANGE_DESTINATION) {\n        break;\n      }\n\n      file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                            archive_entry_filetype (entry));\n    }\n\n    if (file_conflict && action == AUTOAR_CONFLICT_SKIP) {\n      continue;\n    }\n\n    autoar_extractor_do_write_entry (self, a, entry,\n                                     extracted_filename, hardlink_filename);\n\n    if (self->error != NULL) {\n      archive_read_free (a);\n      return;\n    }\n\n    self->completed_files++;\n    autoar_extractor_signal_progress (self);\n  }\n\n  if (r != ARCHIVE_EOF) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  archive_read_free (a);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,10 +39,18 @@\n \n     extracted_filename =\n       autoar_extractor_do_sanitize_pathname (self, pathname);\n+    if (extracted_filename == NULL) {\n+      archive_read_data_skip (a);\n+      continue;\n+    }\n \n     if (hardlink != NULL) {\n       hardlink_filename =\n         autoar_extractor_do_sanitize_pathname (self, hardlink);\n+        if (hardlink_filename == NULL) {\n+          archive_read_data_skip (a);\n+          continue;\n+        }\n     }\n \n     /* Attempt to solve any name conflict before doing any operations */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (extracted_filename == NULL) {",
                "      archive_read_data_skip (a);",
                "      continue;",
                "    }",
                "        if (hardlink_filename == NULL) {",
                "          archive_read_data_skip (a);",
                "          continue;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0496",
        "func_name": "freedink/dfarc/InstallVerifyFrame::InstallVerifyFrame",
        "description": "Directory traversal issues in the D-Mod extractor in DFArc and DFArc2 (as well as in RTsoft's Dink Smallwood HD / ProtonSDK version) before 3.14 allow an attacker to overwrite arbitrary files on the user's system.",
        "git_url": "https://git.savannah.gnu.org/cgit/freedink/dfarc.git/commit/?id=40cc957f52e772f45125126439ba9333cf2d2998",
        "commit_title": "",
        "commit_text": "",
        "func_before": "InstallVerifyFrame::InstallVerifyFrame(const wxString& lDmodFilePath)\n: InstallVerifyFrame_Base(NULL, wxID_ANY, _T(\"\"))\n{\n  mConfig = Config::GetConfig();\n\n  prepareDialog();\n  \n  int flags = wxPD_AUTO_HIDE | wxPD_APP_MODAL | wxPD_REMAINING_TIME;\n  wxProgressDialog lPrepareProgress(_(\"Preparing\"),\n    _(\"The D-Mod archive is being decompressed in a temporary file.\"), 100, this, flags);\n  \n  // Extract\n  BZip lBZip(lDmodFilePath);\n  mTarFilePath = lBZip.Extract(&lPrepareProgress);\n  \n  if (mTarFilePath.Len() != 0)\n    {\n      // Prepare the tar file for reading\n      Tar lTar(mTarFilePath);\n      lTar.ReadHeaders();\n     \n      // Get and display the dmod description\n      wxString lDmodDescription = lTar.getmDmodDescription();\n      if ( lDmodDescription.Len() == 0 )\n        {\n\t  lDmodDescription = wxString::Format(_(\"No Description Available.\\n\"\n\t\t\t\t\t\t\"\\n\"\n\t\t\t\t\t\t\"The D-Mod will be installed in subdirectory '%s'.\"),\n\t\t\t\t\t      lTar.getInstalledDmodDirectory().c_str());\n        }\n      else\n        {\n\t  int lBreakChar = lDmodDescription.Find( '\\r' );\n\t  if ( lBreakChar <= 0 )\n            {\n\t      lBreakChar = lDmodDescription.Find( '\\n' );\n            }\n\t  mDmodName = lDmodDescription.SubString( 0, lBreakChar - 1 );\n\t  this->SetTitle(_(\"DFArc - Install D-Mod - \") + mDmodName);\n        }\n      mDmodDescription->SetValue(lDmodDescription);\n      \n      // Re-enable the install button\n      mInstallButton->Enable(true);\n    }\n}",
        "func": "InstallVerifyFrame::InstallVerifyFrame(const wxString& lDmodFilePath)\n: InstallVerifyFrame_Base(NULL, wxID_ANY, _T(\"\"))\n{\n  mConfig = Config::GetConfig();\n\n  prepareDialog();\n  \n  int flags = wxPD_AUTO_HIDE | wxPD_APP_MODAL | wxPD_REMAINING_TIME;\n  wxProgressDialog lPrepareProgress(_(\"Preparing\"),\n    _(\"The D-Mod archive is being decompressed in a temporary file.\"), 100, this, flags);\n  \n  // Extract\n  BZip lBZip(lDmodFilePath);\n  mTarFilePath = lBZip.Extract(&lPrepareProgress);\n  \n  if (mTarFilePath.Len() != 0)\n    {\n      // Prepare the tar file for reading\n      Tar lTar(mTarFilePath);\n      if (lTar.ReadHeaders() == 1) {\n        this->EndModal(wxID_CANCEL);\n        return;\n      }\n     \n      // Get and display the dmod description\n      wxString lDmodDescription = lTar.getmDmodDescription();\n      if ( lDmodDescription.Len() == 0 )\n        {\n\t  lDmodDescription = wxString::Format(_(\"No Description Available.\\n\"\n\t\t\t\t\t\t\"\\n\"\n\t\t\t\t\t\t\"The D-Mod will be installed in subdirectory '%s'.\"),\n\t\t\t\t\t      lTar.getInstalledDmodDirectory().c_str());\n        }\n      else\n        {\n\t  int lBreakChar = lDmodDescription.Find( '\\r' );\n\t  if ( lBreakChar <= 0 )\n            {\n\t      lBreakChar = lDmodDescription.Find( '\\n' );\n            }\n\t  mDmodName = lDmodDescription.SubString( 0, lBreakChar - 1 );\n\t  this->SetTitle(_(\"DFArc - Install D-Mod - \") + mDmodName);\n        }\n      mDmodDescription->SetValue(lDmodDescription);\n      \n      // Re-enable the install button\n      mInstallButton->Enable(true);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,10 @@\n     {\n       // Prepare the tar file for reading\n       Tar lTar(mTarFilePath);\n-      lTar.ReadHeaders();\n+      if (lTar.ReadHeaders() == 1) {\n+        this->EndModal(wxID_CANCEL);\n+        return;\n+      }\n      \n       // Get and display the dmod description\n       wxString lDmodDescription = lTar.getmDmodDescription();",
        "diff_line_info": {
            "deleted_lines": [
                "      lTar.ReadHeaders();"
            ],
            "added_lines": [
                "      if (lTar.ReadHeaders() == 1) {",
                "        this->EndModal(wxID_CANCEL);",
                "        return;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0496",
        "func_name": "freedink/dfarc/InstallVerifyFrame::onInstall",
        "description": "Directory traversal issues in the D-Mod extractor in DFArc and DFArc2 (as well as in RTsoft's Dink Smallwood HD / ProtonSDK version) before 3.14 allow an attacker to overwrite arbitrary files on the user's system.",
        "git_url": "https://git.savannah.gnu.org/cgit/freedink/dfarc.git/commit/?id=40cc957f52e772f45125126439ba9333cf2d2998",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void InstallVerifyFrame::onInstall(wxCommandEvent &Event)\n{\n  int flags = wxPD_AUTO_HIDE | wxPD_APP_MODAL | wxPD_REMAINING_TIME;\n  wxProgressDialog lInstallProgress(_(\"DFArc - Installing\"), _T(\"\"),\n    100, this, flags);\n\n  // Install in the main dink dir, or in the specified DMod dir if any\n  wxString destdir = mConfig->GetDinkrefDir();\n  if (mDestdirBox->GetSelection() == 1)\n    destdir = mConfig->mDModDir;\n\n  Tar lTar(mTarFilePath);\n  lTar.ReadHeaders();\n  int lError = lTar.Extract(destdir, &lInstallProgress);\n  if (lError == 0)\n    {\n      if (mDmodName.Len() <= 0)\n        {\n\t  mDmodName = _(\"The D-Mod you selected\");\n        }\n      ::wxMessageBox(mDmodName + _(\" was successfully installed.\"),\n\t\t   _(\"Success\"), wxOK | wxICON_INFORMATION, this);\n      // Preselect this new D-Mod\n      wxString dmod_dir = lTar.getInstalledDmodDirectory();\n      if (dmod_dir.Last() == _T('/'))\n\tdmod_dir = dmod_dir.RemoveLast();\n      mConfig->mSelectedDmod = destdir + wxFileName::GetPathSeparator() + dmod_dir;\n      this->EndModal(wxID_OK);\n    }\n  else\n    {\n      wxLogError(_(\"An error occured while extracting the .dmod file.\"));\n    }\n}",
        "func": "void InstallVerifyFrame::onInstall(wxCommandEvent &Event)\n{\n  int flags = wxPD_AUTO_HIDE | wxPD_APP_MODAL | wxPD_REMAINING_TIME;\n  wxProgressDialog lInstallProgress(_(\"DFArc - Installing\"), _T(\"\"),\n    100, this, flags);\n\n  // Install in the main dink dir, or in the specified DMod dir if any\n  wxString destdir = mConfig->GetDinkrefDir();\n  if (mDestdirBox->GetSelection() == 1)\n    destdir = mConfig->mDModDir;\n\n  Tar lTar(mTarFilePath);\n  if (lTar.ReadHeaders() == 1) {\n    this->EndModal(wxID_CANCEL);\n    return;\n  }\n\n  if (wxDirExists(destdir + wxFileName::GetPathSeparator() + lTar.getInstalledDmodDirectory())) {\n    wxString question;\n    question.Printf(_(\"Directory '%s' already exists. Continue?\"), lTar.getInstalledDmodDirectory());\n    int lResult = wxMessageBox(question, _(\"DFArc - Installing\"),\n\t\t\t       wxYES_NO | wxICON_WARNING, this);\n    if (lResult == wxNO)\n      return;\n  }\n\n  int lError = lTar.Extract(destdir, &lInstallProgress);\n  if (lError == 0)\n    {\n      if (mDmodName.Len() <= 0)\n        {\n\t  mDmodName = _(\"The D-Mod you selected\");\n        }\n      ::wxMessageBox(mDmodName + _(\" was successfully installed.\"),\n\t\t   _(\"Success\"), wxOK | wxICON_INFORMATION, this);\n      // Preselect this new D-Mod\n      wxString dmod_dir = lTar.getInstalledDmodDirectory();\n      if (dmod_dir.Last() == _T('/'))\n\tdmod_dir = dmod_dir.RemoveLast();\n      mConfig->mSelectedDmod = destdir + wxFileName::GetPathSeparator() + dmod_dir;\n      this->EndModal(wxID_OK);\n    }\n  else\n    {\n      wxLogError(_(\"An error occured while extracting the .dmod file.\"));\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,20 @@\n     destdir = mConfig->mDModDir;\n \n   Tar lTar(mTarFilePath);\n-  lTar.ReadHeaders();\n+  if (lTar.ReadHeaders() == 1) {\n+    this->EndModal(wxID_CANCEL);\n+    return;\n+  }\n+\n+  if (wxDirExists(destdir + wxFileName::GetPathSeparator() + lTar.getInstalledDmodDirectory())) {\n+    wxString question;\n+    question.Printf(_(\"Directory '%s' already exists. Continue?\"), lTar.getInstalledDmodDirectory());\n+    int lResult = wxMessageBox(question, _(\"DFArc - Installing\"),\n+\t\t\t       wxYES_NO | wxICON_WARNING, this);\n+    if (lResult == wxNO)\n+      return;\n+  }\n+\n   int lError = lTar.Extract(destdir, &lInstallProgress);\n   if (lError == 0)\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "  lTar.ReadHeaders();"
            ],
            "added_lines": [
                "  if (lTar.ReadHeaders() == 1) {",
                "    this->EndModal(wxID_CANCEL);",
                "    return;",
                "  }",
                "",
                "  if (wxDirExists(destdir + wxFileName::GetPathSeparator() + lTar.getInstalledDmodDirectory())) {",
                "    wxString question;",
                "    question.Printf(_(\"Directory '%s' already exists. Continue?\"), lTar.getInstalledDmodDirectory());",
                "    int lResult = wxMessageBox(question, _(\"DFArc - Installing\"),",
                "\t\t\t       wxYES_NO | wxICON_WARNING, this);",
                "    if (lResult == wxNO)",
                "      return;",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0496",
        "func_name": "freedink/dfarc/Tar::ExtractData",
        "description": "Directory traversal issues in the D-Mod extractor in DFArc and DFArc2 (as well as in RTsoft's Dink Smallwood HD / ProtonSDK version) before 3.14 allow an attacker to overwrite arbitrary files on the user's system.",
        "git_url": "https://git.savannah.gnu.org/cgit/freedink/dfarc.git/commit/?id=40cc957f52e772f45125126439ba9333cf2d2998",
        "commit_title": "",
        "commit_text": "",
        "func_before": "int Tar::ExtractData(std::istream& aTarStreamIn, wxString destdir, wxProgressDialog* aProgressDialog)\n{\n    int lError = 0;\n\n    unsigned long lTotalBytes = 0;\n    unsigned long lTotalBytesRead = 0;\n\n    // Get the file size\n    aTarStreamIn.seekg(0, std::ios::end);\n    unsigned long lEnd = static_cast<unsigned long>(aTarStreamIn.tellg());\n    aTarStreamIn.seekg(0, std::ios::beg);\n    lTotalBytes = lEnd - static_cast<unsigned long>(aTarStreamIn.tellg());\n\n    // Move into the extract dir.\n    wxString lPreviousWorkingDirectory(::wxGetCwd());\n    ::wxSetWorkingDirectory(destdir);\n\n    // Extract the files.\n    int ebufsiz = 8192;\n    char buffer[ebufsiz];\n    for (unsigned int lTarRecordIndex = 0; lTarRecordIndex < TarRecords.size(); ++lTarRecordIndex)\n    {\n\t\tTarRecord lCurrentTarRecord = TarRecords.at(lTarRecordIndex);\n\t\twxString lCurrentFilePath = wxString(lCurrentTarRecord.Name, wxConvUTF8);\n\t\tif (lCurrentFilePath.IsEmpty())\n\t\t  {\n\t\t    /* Attempt convertion from latin-1 if not valid UTF-8 */\n\t\t    lCurrentFilePath = wxString(lCurrentTarRecord.Name, wxConvISO8859_1);\n\t\t  }\n\t\twxString lCurrentDirectory(lCurrentFilePath.substr(0, lCurrentFilePath.find_last_of('/')));\n\n        // Odd bad file problem...\n\tif (lCurrentFilePath.compare(_T(\"\\xFF\")) == 0) // \"\"\n        {\n            // Only warn them if it doesn't come at the end.\n            if (lTarRecordIndex != TarRecords.size() - 1)\n            {\n                lError = 1;\n                wxLogError(_(\"Got bad file %d/%d.  Skipping.\"), lTarRecordIndex, TarRecords.size() );\n            }\n        }\n        else\n\t{\n\t    // Create the directory if it doesn't exist\n\t    if (::wxDirExists(lCurrentDirectory) == false)\n\t    {\n\t\t// Use 0777 - the umask will remove group and/or\n\t\t// other write access as necessary. Don't forget\n\t\t// to prefix with a '0' for octal mode.\n\t\twxFileName::Mkdir(lCurrentDirectory, 0777, wxPATH_MKDIR_FULL);\n\t    }\n\t    \n            // Only write the file if it is a file... some files are stored as directories\n            char lLastCharacter = lCurrentFilePath[lCurrentFilePath.length() - 1];\n            if (lLastCharacter != '\\\\' && lLastCharacter != '/')\n            {\n                // Open the file.\n                wxFile wx_Out(lCurrentFilePath, wxFile::write);\n\t\tif (!wx_Out.IsOpened())\n                {\n\t\t    wxLogError(_(\"Error: Improperly archived file '%s'.  Skipping.\"), lCurrentFilePath);\n                    lError = 1;\n                    continue;\n                }\n\t\t__gnu_cxx::stdio_filebuf<char> filebuf(wx_Out.fd(), std::ios::out);\n\t\tstd::ostream lStreamOut(&filebuf);\n                \n\t\taTarStreamIn.seekg(lCurrentTarRecord.iFilePosBegin, std::ios::beg);\n\t\tlong remaining = lCurrentTarRecord.iFileSize;\n\t\twhile (remaining > 0)\n\t\t  {\n\t\t    int bufsiz = remaining;\n\t\t    if (bufsiz > ebufsiz) bufsiz = ebufsiz;\n\t\t    aTarStreamIn.read(buffer, bufsiz);\n\t\t    lStreamOut.write(buffer, bufsiz);\n\t\t    remaining -= bufsiz;\n\t\t  }\n                lTotalBytesRead += lCurrentTarRecord.iFileSize;\n                \n                // Close up.\n                lStreamOut.flush();\n                wx_Out.Close();\n            }\n            \n            // Update progress\n            if( aProgressDialog != NULL )\n            {\n                double lPercent( 100.0 * lTotalBytesRead / lTotalBytes ) ;\n                if ( lPercent >= 100 )\n                {\n                    lPercent = 99.0;\n                }\n                aProgressDialog->Update(static_cast<int>(lPercent), lCurrentFilePath);\n                ::wxYield();\n            }\n        }\n    }\n    aProgressDialog->Update(100, _(\"Done.\"));\n    ::wxSetWorkingDirectory(lPreviousWorkingDirectory);\n    return lError;\n}",
        "func": "int Tar::ExtractData(std::istream& aTarStreamIn, wxString destdir, wxProgressDialog* aProgressDialog)\n{\n    int lError = 0;\n\n    unsigned long lTotalBytes = 0;\n    unsigned long lTotalBytesRead = 0;\n\n    // Get the file size\n    aTarStreamIn.seekg(0, std::ios::end);\n    unsigned long lEnd = static_cast<unsigned long>(aTarStreamIn.tellg());\n    aTarStreamIn.seekg(0, std::ios::beg);\n    lTotalBytes = lEnd - static_cast<unsigned long>(aTarStreamIn.tellg());\n\n    // Extract the files.\n    int ebufsiz = 8192;\n    char buffer[ebufsiz];\n    for (unsigned int lTarRecordIndex = 0; lTarRecordIndex < TarRecords.size(); ++lTarRecordIndex)\n    {\n\t\tTarRecord lCurrentTarRecord = TarRecords.at(lTarRecordIndex);\n\t\twxString lCurrentFilePath = wxString(lCurrentTarRecord.Name, wxConvUTF8);\n\t\tif (lCurrentFilePath.IsEmpty())\n\t\t  {\n\t\t    /* Attempt convertion from latin-1 if not valid UTF-8 */\n\t\t    lCurrentFilePath = wxString(lCurrentTarRecord.Name, wxConvISO8859_1);\n\t\t  }\n        // Security: check if archive tries to jump out of destination directory\n        if (IsPathInsecure(lCurrentFilePath))\n        {\n            wxLogError(_(\"Error: Insecure filename: '%s'.  Stopping.\"), lCurrentFilePath);\n            lError = 1;\n            break;\n        }\n        // Security: ensure full, non-relative path, under destdir/\n        lCurrentFilePath = destdir + wxFileName::GetPathSeparator() + lCurrentFilePath;\n        wxString lCurrentDirectory = lCurrentFilePath.substr(0, lCurrentFilePath.find_last_of(\"/\\\\\"));\n\n        // Odd bad file problem...\n\tif (lCurrentFilePath.compare(_T(\"\\xFF\")) == 0) // \"\"\n        {\n            // Only warn them if it doesn't come at the end.\n            if (lTarRecordIndex != TarRecords.size() - 1)\n            {\n                lError = 1;\n                wxLogError(_(\"Got bad file %d/%d.  Skipping.\"), lTarRecordIndex, TarRecords.size() );\n            }\n        }\n        else\n\t{\n\t    // Create the directory if it doesn't exist\n\t    if (::wxDirExists(lCurrentDirectory) == false)\n\t    {\n\t\t// Use 0777 - the umask will remove group and/or\n\t\t// other write access as necessary. Don't forget\n\t\t// to prefix with a '0' for octal mode.\n\t\twxFileName::Mkdir(lCurrentDirectory, 0777, wxPATH_MKDIR_FULL);\n\t    }\n\t    \n            // Only write the file if it is a file... some files are stored as directories\n            char lLastCharacter = lCurrentFilePath[lCurrentFilePath.length() - 1];\n            if (lLastCharacter != '\\\\' && lLastCharacter != '/')\n            {\n                // Open the file.\n                wxFile wx_Out(lCurrentFilePath, wxFile::write);\n\t\tif (!wx_Out.IsOpened())\n                {\n\t\t    wxLogError(_(\"Error: Improperly archived file '%s'.  Skipping.\"), lCurrentFilePath);\n                    lError = 1;\n                    continue;\n                }\n\t\t__gnu_cxx::stdio_filebuf<char> filebuf(wx_Out.fd(), std::ios::out);\n\t\tstd::ostream lStreamOut(&filebuf);\n                \n\t\taTarStreamIn.seekg(lCurrentTarRecord.iFilePosBegin, std::ios::beg);\n\t\tlong remaining = lCurrentTarRecord.iFileSize;\n\t\twhile (remaining > 0)\n\t\t  {\n\t\t    int bufsiz = remaining;\n\t\t    if (bufsiz > ebufsiz) bufsiz = ebufsiz;\n\t\t    aTarStreamIn.read(buffer, bufsiz);\n\t\t    lStreamOut.write(buffer, bufsiz);\n\t\t    remaining -= bufsiz;\n\t\t  }\n                lTotalBytesRead += lCurrentTarRecord.iFileSize;\n                \n                // Close up.\n                lStreamOut.flush();\n                wx_Out.Close();\n            }\n            \n            // Update progress\n            if( aProgressDialog != NULL )\n            {\n                double lPercent( 100.0 * lTotalBytesRead / lTotalBytes ) ;\n                if ( lPercent >= 100 )\n                {\n                    lPercent = 99.0;\n                }\n                aProgressDialog->Update(static_cast<int>(lPercent), lCurrentFilePath);\n                ::wxYield();\n            }\n        }\n    }\n    aProgressDialog->Update(100, _(\"Done.\"));\n    return lError;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,10 +11,6 @@\n     aTarStreamIn.seekg(0, std::ios::beg);\n     lTotalBytes = lEnd - static_cast<unsigned long>(aTarStreamIn.tellg());\n \n-    // Move into the extract dir.\n-    wxString lPreviousWorkingDirectory(::wxGetCwd());\n-    ::wxSetWorkingDirectory(destdir);\n-\n     // Extract the files.\n     int ebufsiz = 8192;\n     char buffer[ebufsiz];\n@@ -27,7 +23,16 @@\n \t\t    /* Attempt convertion from latin-1 if not valid UTF-8 */\n \t\t    lCurrentFilePath = wxString(lCurrentTarRecord.Name, wxConvISO8859_1);\n \t\t  }\n-\t\twxString lCurrentDirectory(lCurrentFilePath.substr(0, lCurrentFilePath.find_last_of('/')));\n+        // Security: check if archive tries to jump out of destination directory\n+        if (IsPathInsecure(lCurrentFilePath))\n+        {\n+            wxLogError(_(\"Error: Insecure filename: '%s'.  Stopping.\"), lCurrentFilePath);\n+            lError = 1;\n+            break;\n+        }\n+        // Security: ensure full, non-relative path, under destdir/\n+        lCurrentFilePath = destdir + wxFileName::GetPathSeparator() + lCurrentFilePath;\n+        wxString lCurrentDirectory = lCurrentFilePath.substr(0, lCurrentFilePath.find_last_of(\"/\\\\\"));\n \n         // Odd bad file problem...\n \tif (lCurrentFilePath.compare(_T(\"\\xFF\")) == 0) // \"\"\n@@ -96,6 +101,5 @@\n         }\n     }\n     aProgressDialog->Update(100, _(\"Done.\"));\n-    ::wxSetWorkingDirectory(lPreviousWorkingDirectory);\n     return lError;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    // Move into the extract dir.",
                "    wxString lPreviousWorkingDirectory(::wxGetCwd());",
                "    ::wxSetWorkingDirectory(destdir);",
                "",
                "\t\twxString lCurrentDirectory(lCurrentFilePath.substr(0, lCurrentFilePath.find_last_of('/')));",
                "    ::wxSetWorkingDirectory(lPreviousWorkingDirectory);"
            ],
            "added_lines": [
                "        // Security: check if archive tries to jump out of destination directory",
                "        if (IsPathInsecure(lCurrentFilePath))",
                "        {",
                "            wxLogError(_(\"Error: Insecure filename: '%s'.  Stopping.\"), lCurrentFilePath);",
                "            lError = 1;",
                "            break;",
                "        }",
                "        // Security: ensure full, non-relative path, under destdir/",
                "        lCurrentFilePath = destdir + wxFileName::GetPathSeparator() + lCurrentFilePath;",
                "        wxString lCurrentDirectory = lCurrentFilePath.substr(0, lCurrentFilePath.find_last_of(\"/\\\\\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0496",
        "func_name": "freedink/dfarc/Tar::ReadHeaders",
        "description": "Directory traversal issues in the D-Mod extractor in DFArc and DFArc2 (as well as in RTsoft's Dink Smallwood HD / ProtonSDK version) before 3.14 allow an attacker to overwrite arbitrary files on the user's system.",
        "git_url": "https://git.savannah.gnu.org/cgit/freedink/dfarc.git/commit/?id=40cc957f52e772f45125126439ba9333cf2d2998",
        "commit_title": "",
        "commit_text": "",
        "func_before": "int Tar::ReadHeaders( void )\n{\n  FILE *in;\n  TarHeader lHeader;\n  TarRecord lRecord;\n  unsigned int iBegData = 0;\n  char buf_header[512];\n  \n  in = fopen(mFilePath.fn_str(), \"rb\");\n  \n  if(in == NULL)\n    {\n      wxLogFatalError(_(\"Error: File '%s' not found!  Cannot read data.\"), mFilePath.c_str());\n      return 1;\n    }\n  \n  wxString lDmodDizPath;\n  mmDmodDescription = _T(\"\");\n  mInstalledDmodDirectory = _T(\"\");\n\n  int total_read = 0;\n  while (true)\n    {\n      memset(&lHeader, 0, sizeof(TarHeader));\n      memset(&lRecord, 0, sizeof(TarRecord));\n      \n      // Read the data. Dont load the whole header to a struct, you\n      // never know what the memory alignment will be, especially in\n      // these 32->64bits days\n      fread((char*)&lHeader.Name, 100, 1, in);\n      fread((char*)&lHeader.Mode, 8, 1, in);\n      fread((char*)&lHeader.Uid, 8, 1, in);\n      fread((char*)&lHeader.Gid, 8, 1, in);\n      fread((char*)&lHeader.Size, 12, 1, in);\n      fread((char*)&lHeader.Mtime, 12, 1, in);\n      fread((char*)&lHeader.Chksum, 8, 1, in);\n      fread((char*)&lHeader.Linkflag, 1, 1, in);\n      fread((char*)&lHeader.Linkname, 100, 1, in);\n      fread((char*)&lHeader.Magic, 8, 1, in);\n      fread((char*)&lHeader.Uname, 32, 1, in);\n      fread((char*)&lHeader.Gname, 32, 1, in);\n      fread((char*)&lHeader.Devmajor, 8, 1, in);\n      fread((char*)&lHeader.Devminor, 8, 1, in);\n      fread((char*)&lHeader.Padding, 167, 1, in);\n      total_read += 512;\n\n      if(!VerifyChecksum(&lHeader))\n        {\n\t  // Nope.  Exit.\n\t  wxLogFatalError(_(\"Error: This .dmod file has an invalid checksum!  Cannot read file.\"));\n\t  return 1;\n        }\n        \n      strncpy(lRecord.Name, lHeader.Name, 100);\n      \n      // Bug fix for phantom files that aren't really files...\n      // This is due to a bug in DFArc1.5 with empty files\n      if (strcmp(lHeader.Name, \"\\xFF\") == 0)\n\tcontinue;\n      \n      // Size\n      sscanf((const char*)&lHeader.Size, \"%o\", &lRecord.iFileSize);\n      // Start\n      lRecord.iFilePosBegin = total_read;\n      \n      // Tar files (except for a design bug in DFArc1.5) have a\n      // multitude of NULL characters at the end to round up to the\n      // 10K mark.  If the header is blank, we don't have any more\n      // data.\n      if(strcmp(lHeader.Name, \"\") == 0)\n        {\n\t  break;\n        }\n      //wxLogError(\"%s %d\", lHeader.Name, lRecord.iFileSize);\n      \n      wxString lPath(lRecord.Name, wxConvUTF8);\n      if (mInstalledDmodDirectory.Length() == 0)\n        {\n\t  mInstalledDmodDirectory = lPath.SubString( 0, lPath.Find( '/' ) );\n\t  lDmodDizPath = mInstalledDmodDirectory + _T(\"dmod.diz\");\n\t  lDmodDizPath.LowerCase();\n        }\n      if (lPath.Lower() == lDmodDizPath && lRecord.iFileSize < 100*1024)\n\t{\n\t  // Read dmod.diz content, but only if < 100kB\n\t  char *buf = (char*)malloc(lRecord.iFileSize + 1);\n\t  fread(buf, 1, lRecord.iFileSize, in);\n\t  buf[lRecord.iFileSize] = '\\0';\n\t  // dmod.diz are typically uncoded in ISO-8859-1/latin-1\n\t  mmDmodDescription = wxString(buf, wxConvISO8859_1);\n\t  free(buf);\n\t}\n      else\n\t{\n\t  int remaining = lRecord.iFileSize;\n\t  char buf[BUFSIZ];\n\t  while (remaining > 0)\n\t    {\n\t      if (feof(in))\n\t\tbreak; // TODO: error, unexpected end of file\n\t      int nb_read = fread(buf, 1, (remaining > BUFSIZ) ? BUFSIZ : remaining, in);\n\t      remaining -= nb_read;\n\t    }\n\t}\n      total_read += lRecord.iFileSize;\n      TarRecords.push_back(lRecord);\n      \n      // Move to the beginning of the next header\n      int padding_size = (512 - (total_read % 512)) % 512;\n      fread(buf_header, 1, padding_size, in);\n      total_read += padding_size;\n    }\n  \n  fclose(in);\n  \n  return 0;\n}",
        "func": "int Tar::ReadHeaders( void )\n{\n  FILE *in;\n  TarHeader lHeader;\n  TarRecord lRecord;\n  unsigned int iBegData = 0;\n  char buf_header[512];\n  \n  in = fopen(mFilePath.fn_str(), \"rb\");\n  \n  if(in == NULL)\n    {\n      wxLogFatalError(_(\"Error: File '%s' not found!  Cannot read data.\"), mFilePath.c_str());\n      return 1;\n    }\n  \n  wxString lDmodDizPath;\n  mmDmodDescription = _T(\"\");\n  mInstalledDmodDirectory = _T(\"\");\n\n  int total_read = 0;\n  while (true)\n    {\n      memset(&lHeader, 0, sizeof(TarHeader));\n      memset(&lRecord, 0, sizeof(TarRecord));\n      \n      // Read the data. Dont load the whole header to a struct, you\n      // never know what the memory alignment will be, especially in\n      // these 32->64bits days\n      fread((char*)&lHeader.Name, 100, 1, in);\n      fread((char*)&lHeader.Mode, 8, 1, in);\n      fread((char*)&lHeader.Uid, 8, 1, in);\n      fread((char*)&lHeader.Gid, 8, 1, in);\n      fread((char*)&lHeader.Size, 12, 1, in);\n      fread((char*)&lHeader.Mtime, 12, 1, in);\n      fread((char*)&lHeader.Chksum, 8, 1, in);\n      fread((char*)&lHeader.Linkflag, 1, 1, in);\n      fread((char*)&lHeader.Linkname, 100, 1, in);\n      fread((char*)&lHeader.Magic, 8, 1, in);\n      fread((char*)&lHeader.Uname, 32, 1, in);\n      fread((char*)&lHeader.Gname, 32, 1, in);\n      fread((char*)&lHeader.Devmajor, 8, 1, in);\n      fread((char*)&lHeader.Devminor, 8, 1, in);\n      fread((char*)&lHeader.Padding, 167, 1, in);\n      total_read += 512;\n\n      if(!VerifyChecksum(&lHeader))\n        {\n\t  // Nope.  Exit.\n\t  wxLogFatalError(_(\"Error: This .dmod file has an invalid checksum!  Cannot read file.\"));\n\t  return 1;\n        }\n        \n      strncpy(lRecord.Name, lHeader.Name, 100);\n      \n      // Bug fix for phantom files that aren't really files...\n      // This is due to a bug in DFArc1.5 with empty files\n      if (strcmp(lHeader.Name, \"\\xFF\") == 0)\n\tcontinue;\n      \n      // Size\n      sscanf((const char*)&lHeader.Size, \"%o\", &lRecord.iFileSize);\n      // Start\n      lRecord.iFilePosBegin = total_read;\n      \n      // Tar files (except for a design bug in DFArc1.5) have a\n      // multitude of NULL characters at the end to round up to the\n      // 10K mark.  If the header is blank, we don't have any more\n      // data.\n      if(strcmp(lHeader.Name, \"\") == 0)\n        {\n\t  break;\n        }\n      //wxLogError(\"%s %d\", lHeader.Name, lRecord.iFileSize);\n      \n      wxString lPath(lRecord.Name, wxConvUTF8);\n      if (mInstalledDmodDirectory.Length() == 0)\n        {\n\t  // Security: ensure the D-Mod directory is non-empty\n\t  wxString firstDir = GetFirstDir(lPath);\n\t  if (firstDir.IsSameAs(\"\", true) || firstDir.IsSameAs(\"..\", true) || firstDir.IsSameAs(\"dink\", true))\n            {\n\t      wxLogError(_(\"Error: invalid D-Mod directory.  Stopping.\"));\n              return 1;\n            }\n          mInstalledDmodDirectory = firstDir;\n\n\t  lDmodDizPath = mInstalledDmodDirectory + _T(\"dmod.diz\");\n\t  lDmodDizPath.LowerCase();\n        }\n      if (lPath.Lower() == lDmodDizPath && lRecord.iFileSize < 100*1024)\n\t{\n\t  // Read dmod.diz content, but only if < 100kB\n\t  char *buf = (char*)malloc(lRecord.iFileSize + 1);\n\t  fread(buf, 1, lRecord.iFileSize, in);\n\t  buf[lRecord.iFileSize] = '\\0';\n\t  // dmod.diz are typically uncoded in ISO-8859-1/latin-1\n\t  mmDmodDescription = wxString(buf, wxConvISO8859_1);\n\t  free(buf);\n\t}\n      else\n\t{\n\t  int remaining = lRecord.iFileSize;\n\t  char buf[BUFSIZ];\n\t  while (remaining > 0)\n\t    {\n\t      if (feof(in))\n\t\tbreak; // TODO: error, unexpected end of file\n\t      int nb_read = fread(buf, 1, (remaining > BUFSIZ) ? BUFSIZ : remaining, in);\n\t      remaining -= nb_read;\n\t    }\n\t}\n      total_read += lRecord.iFileSize;\n      TarRecords.push_back(lRecord);\n      \n      // Move to the beginning of the next header\n      int padding_size = (512 - (total_read % 512)) % 512;\n      fread(buf_header, 1, padding_size, in);\n      total_read += padding_size;\n    }\n  \n  fclose(in);\n  \n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,7 +76,15 @@\n       wxString lPath(lRecord.Name, wxConvUTF8);\n       if (mInstalledDmodDirectory.Length() == 0)\n         {\n-\t  mInstalledDmodDirectory = lPath.SubString( 0, lPath.Find( '/' ) );\n+\t  // Security: ensure the D-Mod directory is non-empty\n+\t  wxString firstDir = GetFirstDir(lPath);\n+\t  if (firstDir.IsSameAs(\"\", true) || firstDir.IsSameAs(\"..\", true) || firstDir.IsSameAs(\"dink\", true))\n+            {\n+\t      wxLogError(_(\"Error: invalid D-Mod directory.  Stopping.\"));\n+              return 1;\n+            }\n+          mInstalledDmodDirectory = firstDir;\n+\n \t  lDmodDizPath = mInstalledDmodDirectory + _T(\"dmod.diz\");\n \t  lDmodDizPath.LowerCase();\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "\t  mInstalledDmodDirectory = lPath.SubString( 0, lPath.Find( '/' ) );"
            ],
            "added_lines": [
                "\t  // Security: ensure the D-Mod directory is non-empty",
                "\t  wxString firstDir = GetFirstDir(lPath);",
                "\t  if (firstDir.IsSameAs(\"\", true) || firstDir.IsSameAs(\"..\", true) || firstDir.IsSameAs(\"dink\", true))",
                "            {",
                "\t      wxLogError(_(\"Error: invalid D-Mod directory.  Stopping.\"));",
                "              return 1;",
                "            }",
                "          mInstalledDmodDirectory = firstDir;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0496",
        "func_name": "freedink/dfarc/Tar::Extract",
        "description": "Directory traversal issues in the D-Mod extractor in DFArc and DFArc2 (as well as in RTsoft's Dink Smallwood HD / ProtonSDK version) before 3.14 allow an attacker to overwrite arbitrary files on the user's system.",
        "git_url": "https://git.savannah.gnu.org/cgit/freedink/dfarc.git/commit/?id=40cc957f52e772f45125126439ba9333cf2d2998",
        "commit_title": "",
        "commit_text": "",
        "func_before": "int Tar::Extract(wxString destdir, wxProgressDialog* aProgressDialog)\n{\n    wxString strBuf;\n    int lError = 0;\n\n    // Remember current directory\n    wxString strCwd = ::wxGetCwd();\n\n\n    // Open the file here so it doesn't error after changing.\n    wxFile wx_In(mFilePath, wxFile::read);\n\n    if(!wx_In.IsOpened())\n    {\n      lError = 1;\n      wxLogFatalError(_(\"Error: File '%s' not found!  Cannot extract data.\"), mFilePath.c_str());\n      throw;\n    }\n    \n    // Attempt to create destination if not present (e.g. custom\n    // DModDir that is not created yet)\n    if (!::wxDirExists(destdir))\n      wxFileName::Mkdir(destdir, 0777, wxPATH_MKDIR_FULL); // 0777 minus umask\n    if (!::wxDirExists(destdir))\n      {\n\twxLogFatalError(_(\"Error: Cannot create directory '%s'.  Cannot extract data.\"), destdir.c_str());\n\tthrow;\n      }\n    // Move to the directory.\n    ::wxSetWorkingDirectory(destdir);\n\n    // Put the data in the directories.\n    __gnu_cxx::stdio_filebuf<char> filebuf(wx_In.fd(), std::ios::in);\n    std::istream f_In(&filebuf);\n    if (ExtractData(f_In, destdir, aProgressDialog) != 0)\n    {\n        lError = 1;\n    }\n    wx_In.Close();\n\n\n    // We're done.  Move back.\n    ::wxSetWorkingDirectory(strCwd);\n    \n    return lError;\n}",
        "func": "int Tar::Extract(wxString destdir, wxProgressDialog* aProgressDialog)\n{\n    wxString strBuf;\n    int lError = 0;\n\n    // Open the file here so it doesn't error after changing.\n    wxFile wx_In(mFilePath, wxFile::read);\n\n    if(!wx_In.IsOpened())\n    {\n      lError = 1;\n      wxLogFatalError(_(\"Error: File '%s' not found!  Cannot extract data.\"), mFilePath.c_str());\n      throw;\n    }\n    \n    // Attempt to create destination if not present (e.g. custom\n    // DModDir that is not created yet)\n    if (!::wxDirExists(destdir))\n      wxFileName::Mkdir(destdir, 0777, wxPATH_MKDIR_FULL); // 0777 minus umask\n    if (!::wxDirExists(destdir))\n      {\n\twxLogFatalError(_(\"Error: Cannot create directory '%s'.  Cannot extract data.\"), destdir.c_str());\n\tthrow;\n      }\n\n    // Put the data in the directories.\n    __gnu_cxx::stdio_filebuf<char> filebuf(wx_In.fd(), std::ios::in);\n    std::istream f_In(&filebuf);\n    if (ExtractData(f_In, destdir, aProgressDialog) != 0)\n    {\n        lError = 1;\n    }\n    wx_In.Close();\n\n    return lError;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,10 +2,6 @@\n {\n     wxString strBuf;\n     int lError = 0;\n-\n-    // Remember current directory\n-    wxString strCwd = ::wxGetCwd();\n-\n \n     // Open the file here so it doesn't error after changing.\n     wxFile wx_In(mFilePath, wxFile::read);\n@@ -26,8 +22,6 @@\n \twxLogFatalError(_(\"Error: Cannot create directory '%s'.  Cannot extract data.\"), destdir.c_str());\n \tthrow;\n       }\n-    // Move to the directory.\n-    ::wxSetWorkingDirectory(destdir);\n \n     // Put the data in the directories.\n     __gnu_cxx::stdio_filebuf<char> filebuf(wx_In.fd(), std::ios::in);\n@@ -38,9 +32,5 @@\n     }\n     wx_In.Close();\n \n-\n-    // We're done.  Move back.\n-    ::wxSetWorkingDirectory(strCwd);\n-    \n     return lError;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "    // Remember current directory",
                "    wxString strCwd = ::wxGetCwd();",
                "",
                "    // Move to the directory.",
                "    ::wxSetWorkingDirectory(destdir);",
                "",
                "    // We're done.  Move back.",
                "    ::wxSetWorkingDirectory(strCwd);",
                "    "
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-11736",
        "func_name": "GNOME/file-roller/extract_archive_thread",
        "description": "fr-archive-libarchive.c in GNOME file-roller through 3.36.1 allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink to a directory outside of the intended extraction location.",
        "git_url": "https://github.com/GNOME/file-roller/commit/21dfcdbfe258984db89fb65243a1a888924e45a0",
        "commit_title": "libarchive: do not follow external links when extracting files",
        "commit_text": " Do not extract a file if its parent is a symbolic link to a directory external to the destination.",
        "func_before": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "func": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tGHashTable           *external_links;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tg_hash_table_unref (external_links);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n \tGHashTable           *checked_folders;\n \tGHashTable           *created_files;\n \tGHashTable           *folders_created_during_extraction;\n+\tGHashTable           *external_links;\n \tstruct archive       *a;\n \tstruct archive_entry *entry;\n \tint                   r;\n@@ -24,6 +25,7 @@\n \tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n \tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n \tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n+\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n \tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n \n \twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n@@ -51,6 +53,15 @@\n \t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n \t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n \t\tif (relative_path == NULL) {\n+\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n+\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n+\t\t\tarchive_read_data_skip (a);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n+\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n+\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n \t\t\tarchive_read_data_skip (a);\n \t\t\tcontinue;\n \t\t}\n@@ -259,6 +270,8 @@\n \t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n \t\t\t\t\tg_clear_error (&local_error);\n \t\t\t\t}\n+\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n+\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n \t\t\t\tarchive_read_data_skip (a);\n \t\t\t\tbreak;\n \n@@ -293,6 +306,7 @@\n \tg_hash_table_unref (folders_created_during_extraction);\n \tg_hash_table_unref (created_files);\n \tg_hash_table_unref (checked_folders);\n+\tg_hash_table_unref (external_links);\n \tarchive_read_free (a);\n \textract_data_free (extract_data);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tGHashTable           *external_links;",
                "\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);",
                "\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);",
                "\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);",
                "\t\t\tarchive_read_data_skip (a);",
                "\t\t\tcontinue;",
                "\t\t}",
                "",
                "\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {",
                "\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);",
                "\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);",
                "\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))",
                "\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));",
                "\tg_hash_table_unref (external_links);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12649",
        "func_name": "sirdude/gurbalib/main",
        "description": "Gurbalib through 2020-04-30 allows lib/cmds/player/help.c directory traversal for reading administrative paths.",
        "git_url": "https://github.com/sirdude/gurbalib/commit/220ec8cceaff2e3bda20f09164a6a96654957840",
        "commit_title": "Update help.c",
        "commit_text": " added missing parts of the pr, sorry about that",
        "func_before": "static void main(string arg) {\n   string file, *exparg;\n   int szof;\n   \n   /* remove capability of path traversal */\n   /* discoverd by David Byrne of X-Force Red */\n   if (szof > 1) {\n      return 1;\n   }\n\n   if (!alsos) {\n      setup_alsos();\n   }\n\n   if (empty_str(arg) || (arg == \"help\")) {\n      this_player()->more(usage());\n      return;\n   }\n\n   if (sscanf(arg, \"-%s\", arg)) {\n      this_player()->more(usage());\n      return;\n   }\n\n   file = normalize_path(arg, \"/doc/help/\");\n   if (show_help(file)) {\n      return;\n   }\n\n   if (query_wizard(this_player())) {\n      file = normalize_path(arg, \"/doc/help/wiz/\");\n      if (show_help(file)) {\n         return;\n      }\n   }\n\n   if (show_help_for_command(arg)) {\n      return;\n   }\n\n   write(capitalize(arg) + \": Unknown help topic.\");\n   if (query_wizard(this_player())) {\n      write(\"Try one of the following for more info:\\n\");\n      write(\"\\tman \" + arg + \"\\n\");\n      write(\"\\t\" + arg + \" -h\\n\");\n   } else {\n      write(\"If \" + arg + \" is a command, for more info try: \" + \n         arg + \" -h\\n\");\n   }\n   LOG_D->write_log(\"help\", this_player()->query_Name() +\n      \" on \" + ctime(time()) + \": \" + arg + \"\\n\");\n   return;\n}",
        "func": "static void main(string arg) {\n   string file, *exparg;\n   int szof;\n   \n   /* remove capability of path traversal */\n   /* discoverd by David Byrne of X-Force Red */\n   exparg = explode(arg, \"/\");\n   szof = sizeof(exparg);\n   if (szof > 1) {\n      return 1;\n   }\n\n   if (!alsos) {\n      setup_alsos();\n   }\n\n   if (empty_str(arg) || (arg == \"help\")) {\n      this_player()->more(usage());\n      return;\n   }\n\n   if (sscanf(arg, \"-%s\", arg)) {\n      this_player()->more(usage());\n      return;\n   }\n\n   file = normalize_path(arg, \"/doc/help/\");\n   if (show_help(file)) {\n      return;\n   }\n\n   if (query_wizard(this_player())) {\n      file = normalize_path(arg, \"/doc/help/wiz/\");\n      if (show_help(file)) {\n         return;\n      }\n   }\n\n   if (show_help_for_command(arg)) {\n      return;\n   }\n\n   write(capitalize(arg) + \": Unknown help topic.\");\n   if (query_wizard(this_player())) {\n      write(\"Try one of the following for more info:\\n\");\n      write(\"\\tman \" + arg + \"\\n\");\n      write(\"\\t\" + arg + \" -h\\n\");\n   } else {\n      write(\"If \" + arg + \" is a command, for more info try: \" + \n         arg + \" -h\\n\");\n   }\n   LOG_D->write_log(\"help\", this_player()->query_Name() +\n      \" on \" + ctime(time()) + \": \" + arg + \"\\n\");\n   return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n    \n    /* remove capability of path traversal */\n    /* discoverd by David Byrne of X-Force Red */\n+   exparg = explode(arg, \"/\");\n+   szof = sizeof(exparg);\n    if (szof > 1) {\n       return 1;\n    }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "   exparg = explode(arg, \"/\");",
                "   szof = sizeof(exparg);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12649",
        "func_name": "sirdude/gurbalib/main",
        "description": "Gurbalib through 2020-04-30 allows lib/cmds/player/help.c directory traversal for reading administrative paths.",
        "git_url": "https://github.com/sirdude/gurbalib/commit/2c0e744927d4aaa5c5f1b5d4b5405104350f5f83",
        "commit_title": "update help.c to fix security bug",
        "commit_text": " path traversal in help.c allows administrative paths to be read",
        "func_before": "static void main(string arg) {\n   string file;\n\n   if (!alsos) {\n      setup_alsos();\n   }\n\n   if (empty_str(arg) || (arg == \"help\")) {\n      this_player()->more(usage());\n      return;\n   }\n\n   if (sscanf(arg, \"-%s\", arg)) {\n      this_player()->more(usage());\n      return;\n   }\n\n   file = normalize_path(arg, \"/doc/help/\");\n   if (show_help(file)) {\n      return;\n   }\n\n   if (query_wizard(this_player())) {\n      file = normalize_path(arg, \"/doc/help/wiz/\");\n      if (show_help(file)) {\n         return;\n      }\n   }\n\n   if (show_help_for_command(arg)) {\n      return;\n   }\n\n   write(capitalize(arg) + \": Unknown help topic.\");\n   if (query_wizard(this_player())) {\n      write(\"Try one of the following for more info:\\n\");\n      write(\"\\tman \" + arg + \"\\n\");\n      write(\"\\t\" + arg + \" -h\\n\");\n   } else {\n      write(\"If \" + arg + \" is a command, for more info try: \" + \n         arg + \" -h\\n\");\n   }\n   LOG_D->write_log(\"help\", this_player()->query_Name() +\n      \" on \" + ctime(time()) + \": \" + arg + \"\\n\");\n   return;\n}",
        "func": "static void main(string arg) {\n   string file, *exparg;\n   int szof;\n   \n   /* remove capability of path traversal */\n   /* discoverd by David Byrne of X-Force Red */\n   if (szof > 1) {\n      return 1;\n   }\n\n   if (!alsos) {\n      setup_alsos();\n   }\n\n   if (empty_str(arg) || (arg == \"help\")) {\n      this_player()->more(usage());\n      return;\n   }\n\n   if (sscanf(arg, \"-%s\", arg)) {\n      this_player()->more(usage());\n      return;\n   }\n\n   file = normalize_path(arg, \"/doc/help/\");\n   if (show_help(file)) {\n      return;\n   }\n\n   if (query_wizard(this_player())) {\n      file = normalize_path(arg, \"/doc/help/wiz/\");\n      if (show_help(file)) {\n         return;\n      }\n   }\n\n   if (show_help_for_command(arg)) {\n      return;\n   }\n\n   write(capitalize(arg) + \": Unknown help topic.\");\n   if (query_wizard(this_player())) {\n      write(\"Try one of the following for more info:\\n\");\n      write(\"\\tman \" + arg + \"\\n\");\n      write(\"\\t\" + arg + \" -h\\n\");\n   } else {\n      write(\"If \" + arg + \" is a command, for more info try: \" + \n         arg + \" -h\\n\");\n   }\n   LOG_D->write_log(\"help\", this_player()->query_Name() +\n      \" on \" + ctime(time()) + \": \" + arg + \"\\n\");\n   return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,12 @@\n static void main(string arg) {\n-   string file;\n+   string file, *exparg;\n+   int szof;\n+   \n+   /* remove capability of path traversal */\n+   /* discoverd by David Byrne of X-Force Red */\n+   if (szof > 1) {\n+      return 1;\n+   }\n \n    if (!alsos) {\n       setup_alsos();",
        "diff_line_info": {
            "deleted_lines": [
                "   string file;"
            ],
            "added_lines": [
                "   string file, *exparg;",
                "   int szof;",
                "   ",
                "   /* remove capability of path traversal */",
                "   /* discoverd by David Byrne of X-Force Red */",
                "   if (szof > 1) {",
                "      return 1;",
                "   }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12649",
        "func_name": "sirdude/gurbalib/main",
        "description": "Gurbalib through 2020-04-30 allows lib/cmds/player/help.c directory traversal for reading administrative paths.",
        "git_url": "https://github.com/sirdude/gurbalib/commit/7fb572c700229ec29a83ebf7b5f67c62eece6082",
        "commit_title": "Update help.c",
        "commit_text": "",
        "func_before": "static void main(string arg) {\n   string file, *exparg;\n   int szof;\n   \n   /* remove capability of path traversal */\n   /* discoverd by David Byrne of X-Force Red */\n   exparg = explode(arg, \"/\");\n   szof = sizeof(exparg);\n   if (szof > 1) {\n      return 1;\n   }\n\n   if (!alsos) {\n      setup_alsos();\n   }\n\n   if (empty_str(arg) || (arg == \"help\")) {\n      this_player()->more(usage());\n      return;\n   }\n\n   if (sscanf(arg, \"-%s\", arg)) {\n      this_player()->more(usage());\n      return;\n   }\n\n   file = normalize_path(arg, \"/doc/help/\");\n   if (show_help(file)) {\n      return;\n   }\n\n   if (query_wizard(this_player())) {\n      file = normalize_path(arg, \"/doc/help/wiz/\");\n      if (show_help(file)) {\n         return;\n      }\n   }\n\n   if (show_help_for_command(arg)) {\n      return;\n   }\n\n   write(capitalize(arg) + \": Unknown help topic.\");\n   if (query_wizard(this_player())) {\n      write(\"Try one of the following for more info:\\n\");\n      write(\"\\tman \" + arg + \"\\n\");\n      write(\"\\t\" + arg + \" -h\\n\");\n   } else {\n      write(\"If \" + arg + \" is a command, for more info try: \" + \n         arg + \" -h\\n\");\n   }\n   LOG_D->write_log(\"help\", this_player()->query_Name() +\n      \" on \" + ctime(time()) + \": \" + arg + \"\\n\");\n   return;\n}",
        "func": "static void main(string arg) {\n   string file, *exparg;\n   int szof;\n   \n   /* remove capability of path traversal */\n   /* discoverd by David Byrne of X-Force Red */\n   /* CVE-2020-12649 */\n   exparg = explode(arg, \"/\");\n   szof = sizeof(exparg);\n   if (szof > 1) {\n      return 1;\n   }\n\n   if (!alsos) {\n      setup_alsos();\n   }\n\n   if (empty_str(arg) || (arg == \"help\")) {\n      this_player()->more(usage());\n      return;\n   }\n\n   if (sscanf(arg, \"-%s\", arg)) {\n      this_player()->more(usage());\n      return;\n   }\n\n   file = normalize_path(arg, \"/doc/help/\");\n   if (show_help(file)) {\n      return;\n   }\n\n   if (query_wizard(this_player())) {\n      file = normalize_path(arg, \"/doc/help/wiz/\");\n      if (show_help(file)) {\n         return;\n      }\n   }\n\n   if (show_help_for_command(arg)) {\n      return;\n   }\n\n   write(capitalize(arg) + \": Unknown help topic.\");\n   if (query_wizard(this_player())) {\n      write(\"Try one of the following for more info:\\n\");\n      write(\"\\tman \" + arg + \"\\n\");\n      write(\"\\t\" + arg + \" -h\\n\");\n   } else {\n      write(\"If \" + arg + \" is a command, for more info try: \" + \n         arg + \" -h\\n\");\n   }\n   LOG_D->write_log(\"help\", this_player()->query_Name() +\n      \" on \" + ctime(time()) + \": \" + arg + \"\\n\");\n   return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n    \n    /* remove capability of path traversal */\n    /* discoverd by David Byrne of X-Force Red */\n+   /* CVE-2020-12649 */\n    exparg = explode(arg, \"/\");\n    szof = sizeof(exparg);\n    if (szof > 1) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "   /* CVE-2020-12649 */"
            ]
        }
    }
]