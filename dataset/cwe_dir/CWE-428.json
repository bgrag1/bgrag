[
    {
        "cve_id": "CVE-2023-38408",
        "func_name": "openbsd/src/main",
        "description": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.",
        "git_url": "https://github.com/openbsd/src/commit/7bc29a9d5cd697290aa056e94ecee6253d3425f8",
        "commit_title": "Disallow remote addition of FIDO/PKCS11 provider libraries to",
        "commit_text": "ssh-agent by default.  The old behaviour of allowing remote clients from loading providers can be restored using `ssh-agent -O allow-remote-pkcs11`.  Detection of local/remote clients requires a ssh(1) that supports the `session-bind@openssh.com` extension. Forwarding access to a ssh-agent socket using non-OpenSSH tools may circumvent this control.  ok markus@",
        "func_before": "int\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, ch, result, saved_errno;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tsize_t len;\n\tmode_t prev_mask;\n\tint timeout = -1; /* INFTIM */\n\tstruct pollfd *pfd = NULL;\n\tsize_t npfd = 0;\n\tu_int maxfds;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\t(void)setegid(getgid());\n\t(void)setgid(getgid());\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) == -1)\n\t\tfatal(\"%s: getrlimit: %s\", __progname, strerror(errno));\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:O:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (strcmp(optarg, \"no-restrict-websafe\") == 0)\n\t\t\t\trestrict_websafe  = 0;\n\t\t\telse\n\t\t\t\tfatal(\"Unknown -O option\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (allowed_providers != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tallowed_providers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (allowed_providers == NULL)\n\t\tallowed_providers = xstrdup(DEFAULT_ALLOWED_PROVIDERS);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\n\t/*\n\t * Minimum file descriptors:\n\t * stdio (3) + listener (1) + syslog (1 maybe) + connection (1) +\n\t * a few spare for libc / stack protectors / sanitisers, etc.\n\t */\n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\tif (rlim.rlim_cur < SSH_AGENT_MIN_FDS)\n\t\tfatal(\"%s: file descriptor rlimit %lld too low (minimum %u)\",\n\t\t    __progname, (long long)rlim.rlim_cur, SSH_AGENT_MIN_FDS);\n\tmaxfds = rlim.rlim_cur - SSH_AGENT_MIN_FDS;\n\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif (stdfd_devnull(1, 1, 1) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) == -1) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tssh_signal(SIGPIPE, SIG_IGN);\n\tssh_signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tssh_signal(SIGHUP, cleanup_handler);\n\tssh_signal(SIGTERM, cleanup_handler);\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_poll(&pfd, &npfd, &timeout, maxfds);\n\t\tresult = poll(pfd, npfd, timeout);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result == -1) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_poll(pfd, npfd, maxfds);\n\t}\n\t/* NOTREACHED */\n}",
        "func": "int\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, ch, result, saved_errno;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tsize_t len;\n\tmode_t prev_mask;\n\tint timeout = -1; /* INFTIM */\n\tstruct pollfd *pfd = NULL;\n\tsize_t npfd = 0;\n\tu_int maxfds;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\t(void)setegid(getgid());\n\t(void)setgid(getgid());\n\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) == -1)\n\t\tfatal(\"%s: getrlimit: %s\", __progname, strerror(errno));\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:O:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (strcmp(optarg, \"no-restrict-websafe\") == 0)\n\t\t\t\trestrict_websafe = 0;\n\t\t\telse if (strcmp(optarg, \"allow-remote-pkcs11\") == 0)\n\t\t\t\tremote_add_provider = 1;\n\t\t\telse\n\t\t\t\tfatal(\"Unknown -O option\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (allowed_providers != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tallowed_providers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (allowed_providers == NULL)\n\t\tallowed_providers = xstrdup(DEFAULT_ALLOWED_PROVIDERS);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\n\t/*\n\t * Minimum file descriptors:\n\t * stdio (3) + listener (1) + syslog (1 maybe) + connection (1) +\n\t * a few spare for libc / stack protectors / sanitisers, etc.\n\t */\n#define SSH_AGENT_MIN_FDS (3+1+1+1+4)\n\tif (rlim.rlim_cur < SSH_AGENT_MIN_FDS)\n\t\tfatal(\"%s: file descriptor rlimit %lld too low (minimum %u)\",\n\t\t    __progname, (long long)rlim.rlim_cur, SSH_AGENT_MIN_FDS);\n\tmaxfds = rlim.rlim_cur - SSH_AGENT_MIN_FDS;\n\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif (stdfd_devnull(1, 1, 1) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) == -1) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tssh_signal(SIGPIPE, SIG_IGN);\n\tssh_signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tssh_signal(SIGHUP, cleanup_handler);\n\tssh_signal(SIGTERM, cleanup_handler);\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_poll(&pfd, &npfd, &timeout, maxfds);\n\t\tresult = poll(pfd, npfd, timeout);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result == -1) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_poll(pfd, npfd, maxfds);\n\t}\n\t/* NOTREACHED */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,7 +47,9 @@\n \t\t\tbreak;\n \t\tcase 'O':\n \t\t\tif (strcmp(optarg, \"no-restrict-websafe\") == 0)\n-\t\t\t\trestrict_websafe  = 0;\n+\t\t\t\trestrict_websafe = 0;\n+\t\t\telse if (strcmp(optarg, \"allow-remote-pkcs11\") == 0)\n+\t\t\t\tremote_add_provider = 1;\n \t\t\telse\n \t\t\t\tfatal(\"Unknown -O option\");\n \t\t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\trestrict_websafe  = 0;"
            ],
            "added_lines": [
                "\t\t\t\trestrict_websafe = 0;",
                "\t\t\telse if (strcmp(optarg, \"allow-remote-pkcs11\") == 0)",
                "\t\t\t\tremote_add_provider = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-38408",
        "func_name": "openbsd/src/process_add_identity",
        "description": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.",
        "git_url": "https://github.com/openbsd/src/commit/7bc29a9d5cd697290aa056e94ecee6253d3425f8",
        "commit_title": "Disallow remote addition of FIDO/PKCS11 provider libraries to",
        "commit_text": "ssh-agent by default.  The old behaviour of allowing remote clients from loading providers can be restored using `ssh-agent -O allow-remote-pkcs11`.  Detection of local/remote clients requires a ssh(1) that supports the `session-bind@openssh.com` extension. Forwarding access to a ssh-agent socket using non-OpenSSH tools may circumvent this control.  ok markus@",
        "func_before": "static void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tchar *fp, *comment = NULL, *sk_provider = NULL;\n\tchar canonical_provider[PATH_MAX];\n\ttime_t death = 0;\n\tu_int seconds = 0;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (parse_key_constraints(e->request, k, &death, &seconds, &confirm,\n\t    &sk_provider, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tsshbuf_reset(e->request);\n\t\tgoto out;\n\t}\n\n\tif (sk_provider != NULL) {\n\t\tif (!sshkey_is_sk(k)) {\n\t\t\terror(\"Cannot add provider: %s is not an \"\n\t\t\t    \"authenticator-hosted key\", sshkey_type(k));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(sk_provider, \"internal\") == 0) {\n\t\t\tdebug_f(\"internal provider\");\n\t\t} else {\n\t\t\tif (realpath(sk_provider, canonical_provider) == NULL) {\n\t\t\t\tverbose(\"failed provider \\\"%.100s\\\": \"\n\t\t\t\t    \"realpath: %s\", sk_provider,\n\t\t\t\t    strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(sk_provider);\n\t\t\tsk_provider = xstrdup(canonical_provider);\n\t\t\tif (match_pattern_list(sk_provider,\n\t\t\t    allowed_providers, 0) != 1) {\n\t\t\t\terror(\"Refusing add key: \"\n\t\t\t\t    \"provider %s not allowed\", sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif ((r = sshkey_shield_private(k)) != 0) {\n\t\terror_fr(r, \"shield private\");\n\t\tgoto out;\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* identity not visible, do not update */\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tgoto out; /* error already logged */\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t\tfree(id->sk_provider);\n\t\tfree_dest_constraints(id->dest_constraints,\n\t\t    id->ndest_constraints);\n\t}\n\t/* success */\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\n\tid->sk_provider = sk_provider;\n\tid->dest_constraints = dest_constraints;\n\tid->ndest_constraints = ndest_constraints;\n\n\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tdebug_f(\"add %s %s \\\"%.100s\\\" (life: %u) (confirm: %u) \"\n\t    \"(provider: %s) (destination constraints: %zu)\",\n\t    sshkey_ssh_name(k), fp, comment, seconds, confirm,\n\t    sk_provider == NULL ? \"none\" : sk_provider, ndest_constraints);\n\tfree(fp);\n\t/* transferred */\n\tk = NULL;\n\tcomment = NULL;\n\tsk_provider = NULL;\n\tdest_constraints = NULL;\n\tndest_constraints = 0;\n\tsuccess = 1;\n out:\n\tfree(sk_provider);\n\tfree(comment);\n\tsshkey_free(k);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}",
        "func": "static void\nprocess_add_identity(SocketEntry *e)\n{\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tchar *fp, *comment = NULL, *sk_provider = NULL;\n\tchar canonical_provider[PATH_MAX];\n\ttime_t death = 0;\n\tu_int seconds = 0;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshkey_private_deserialize(e->request, &k)) != 0 ||\n\t    k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif (parse_key_constraints(e->request, k, &death, &seconds, &confirm,\n\t    &sk_provider, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tsshbuf_reset(e->request);\n\t\tgoto out;\n\t}\n\n\tif (sk_provider != NULL) {\n\t\tif (!sshkey_is_sk(k)) {\n\t\t\terror(\"Cannot add provider: %s is not an \"\n\t\t\t    \"authenticator-hosted key\", sshkey_type(k));\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(sk_provider, \"internal\") == 0) {\n\t\t\tdebug_f(\"internal provider\");\n\t\t} else {\n\t\t\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\t\t\tverbose(\"failed add of SK provider \\\"%.100s\\\": \"\n\t\t\t\t    \"remote addition of providers is disabled\",\n\t\t\t\t    sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (realpath(sk_provider, canonical_provider) == NULL) {\n\t\t\t\tverbose(\"failed provider \\\"%.100s\\\": \"\n\t\t\t\t    \"realpath: %s\", sk_provider,\n\t\t\t\t    strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(sk_provider);\n\t\t\tsk_provider = xstrdup(canonical_provider);\n\t\t\tif (match_pattern_list(sk_provider,\n\t\t\t    allowed_providers, 0) != 1) {\n\t\t\t\terror(\"Refusing add key: \"\n\t\t\t\t    \"provider %s not allowed\", sk_provider);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif ((r = sshkey_shield_private(k)) != 0) {\n\t\terror_fr(r, \"shield private\");\n\t\tgoto out;\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\tidtab->nentries++;\n\t} else {\n\t\t/* identity not visible, do not update */\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tgoto out; /* error already logged */\n\t\t/* key state might have been updated */\n\t\tsshkey_free(id->key);\n\t\tfree(id->comment);\n\t\tfree(id->sk_provider);\n\t\tfree_dest_constraints(id->dest_constraints,\n\t\t    id->ndest_constraints);\n\t}\n\t/* success */\n\tid->key = k;\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\n\tid->sk_provider = sk_provider;\n\tid->dest_constraints = dest_constraints;\n\tid->ndest_constraints = ndest_constraints;\n\n\tif ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\tdebug_f(\"add %s %s \\\"%.100s\\\" (life: %u) (confirm: %u) \"\n\t    \"(provider: %s) (destination constraints: %zu)\",\n\t    sshkey_ssh_name(k), fp, comment, seconds, confirm,\n\t    sk_provider == NULL ? \"none\" : sk_provider, ndest_constraints);\n\tfree(fp);\n\t/* transferred */\n\tk = NULL;\n\tcomment = NULL;\n\tsk_provider = NULL;\n\tdest_constraints = NULL;\n\tndest_constraints = 0;\n\tsuccess = 1;\n out:\n\tfree(sk_provider);\n\tfree(comment);\n\tsshkey_free(k);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,12 @@\n \t\tif (strcasecmp(sk_provider, \"internal\") == 0) {\n \t\t\tdebug_f(\"internal provider\");\n \t\t} else {\n+\t\t\tif (e->nsession_ids != 0 && !remote_add_provider) {\n+\t\t\t\tverbose(\"failed add of SK provider \\\"%.100s\\\": \"\n+\t\t\t\t    \"remote addition of providers is disabled\",\n+\t\t\t\t    sk_provider);\n+\t\t\t\tgoto out;\n+\t\t\t}\n \t\t\tif (realpath(sk_provider, canonical_provider) == NULL) {\n \t\t\t\tverbose(\"failed provider \\\"%.100s\\\": \"\n \t\t\t\t    \"realpath: %s\", sk_provider,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif (e->nsession_ids != 0 && !remote_add_provider) {",
                "\t\t\t\tverbose(\"failed add of SK provider \\\"%.100s\\\": \"",
                "\t\t\t\t    \"remote addition of providers is disabled\",",
                "\t\t\t\t    sk_provider);",
                "\t\t\t\tgoto out;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-38408",
        "func_name": "openbsd/src/process_add_smartcard_key",
        "description": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.",
        "git_url": "https://github.com/openbsd/src/commit/7bc29a9d5cd697290aa056e94ecee6253d3425f8",
        "commit_title": "Disallow remote addition of FIDO/PKCS11 provider libraries to",
        "commit_text": "ssh-agent by default.  The old behaviour of allowing remote clients from loading providers can be restored using `ssh-agent -O allow-remote-pkcs11`.  Detection of local/remote clients requires a ssh(1) that supports the `session-bind@openssh.com` extension. Forwarding access to a ssh-agent socket using non-OpenSSH tools may circumvent this control.  ok markus@",
        "func_before": "static void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tchar **comments = NULL;\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds = 0;\n\ttime_t death = 0;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not allowed\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug_f(\"add %.100s\", canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys, &comments);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tkeys[i] = NULL; /* transferred */\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tif (*comments[i] != '\\0') {\n\t\t\t\tid->comment = comments[i];\n\t\t\t\tcomments[i] = NULL; /* transferred */\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tid->dest_constraints = dest_constraints;\n\t\t\tid->ndest_constraints = ndest_constraints;\n\t\t\tdest_constraints = NULL; /* transferred */\n\t\t\tndest_constraints = 0;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t/* XXX update constraints for existing keys */\n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tfree(comments);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}",
        "func": "static void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];\n\tchar **comments = NULL;\n\tint r, i, count = 0, success = 0, confirm = 0;\n\tu_int seconds = 0;\n\ttime_t death = 0;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tstruct dest_constraint *dest_constraints = NULL;\n\tsize_t ndest_constraints = 0;\n\n\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"\n\t\t    \"providers is disabled\", provider);\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not allowed\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug_f(\"add %.100s\", canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys, &comments);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tif (lookup_identity(k) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tkeys[i] = NULL; /* transferred */\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tif (*comments[i] != '\\0') {\n\t\t\t\tid->comment = comments[i];\n\t\t\t\tcomments[i] = NULL; /* transferred */\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tid->dest_constraints = dest_constraints;\n\t\t\tid->ndest_constraints = ndest_constraints;\n\t\t\tdest_constraints = NULL; /* transferred */\n\t\t\tndest_constraints = 0;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t/* XXX update constraints for existing keys */\n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tfree(comments);\n\tfree_dest_constraints(dest_constraints, ndest_constraints);\n\tsend_status(e, success);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,11 @@\n \tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n \t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n \t\terror_f(\"failed to parse constraints\");\n+\t\tgoto send;\n+\t}\n+\tif (e->nsession_ids != 0 && !remote_add_provider) {\n+\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"\n+\t\t    \"providers is disabled\", provider);\n \t\tgoto send;\n \t}\n \tif (realpath(provider, canonical_provider) == NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tgoto send;",
                "\t}",
                "\tif (e->nsession_ids != 0 && !remote_add_provider) {",
                "\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"",
                "\t\t    \"providers is disabled\", provider);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-38408",
        "func_name": "openbsd/src/pkcs11_register_provider",
        "description": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.",
        "git_url": "https://github.com/openbsd/src/commit/f8f5a6b003981bb824329dc987d101977beda7ca",
        "commit_title": "Ensure FIDO/PKCS11 libraries contain expected symbols",
        "commit_text": " This checks via nlist(3) that candidate provider libraries contain one of the symbols that we will require prior to dlopen(), which can cause a number of side effects, including execution of constructors.  Feedback deraadt; ok markus",
        "func_before": "static int\npkcs11_register_provider(char *provider_id, char *pin,\n    struct sshkey ***keyp, char ***labelsp,\n    struct pkcs11_provider **providerp, CK_ULONG user)\n{\n\tint nkeys, need_finalize = 0;\n\tint ret = -1;\n\tstruct pkcs11_provider *p = NULL;\n\tvoid *handle = NULL;\n\tCK_RV (*getfunctionlist)(CK_FUNCTION_LIST **);\n\tCK_RV rv;\n\tCK_FUNCTION_LIST *f = NULL;\n\tCK_TOKEN_INFO *token;\n\tCK_ULONG i;\n\n\tif (providerp == NULL)\n\t\tgoto fail;\n\t*providerp = NULL;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (labelsp != NULL)\n\t\t*labelsp = NULL;\n\n\tif (pkcs11_provider_lookup(provider_id) != NULL) {\n\t\tdebug_f(\"provider already registered: %s\", provider_id);\n\t\tgoto fail;\n\t}\n\t/* open shared pkcs11-library */\n\tif ((handle = dlopen(provider_id, RTLD_NOW)) == NULL) {\n\t\terror(\"dlopen %s failed: %s\", provider_id, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL)\n\t\tfatal(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());\n\tp = xcalloc(1, sizeof(*p));\n\tp->name = xstrdup(provider_id);\n\tp->handle = handle;\n\t/* setup the pkcs11 callbacks */\n\tif ((rv = (*getfunctionlist)(&f)) != CKR_OK) {\n\t\terror(\"C_GetFunctionList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->function_list = f;\n\tif ((rv = f->C_Initialize(NULL)) != CKR_OK) {\n\t\terror(\"C_Initialize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tneed_finalize = 1;\n\tif ((rv = f->C_GetInfo(&p->info)) != CKR_OK) {\n\t\terror(\"C_GetInfo for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\trmspace(p->info.manufacturerID, sizeof(p->info.manufacturerID));\n\trmspace(p->info.libraryDescription, sizeof(p->info.libraryDescription));\n\tdebug(\"provider %s: manufacturerID <%s> cryptokiVersion %d.%d\"\n\t    \" libraryDescription <%s> libraryVersion %d.%d\",\n\t    provider_id,\n\t    p->info.manufacturerID,\n\t    p->info.cryptokiVersion.major,\n\t    p->info.cryptokiVersion.minor,\n\t    p->info.libraryDescription,\n\t    p->info.libraryVersion.major,\n\t    p->info.libraryVersion.minor);\n\tif ((rv = f->C_GetSlotList(CK_TRUE, NULL, &p->nslots)) != CKR_OK) {\n\t\terror(\"C_GetSlotList failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\tif (p->nslots == 0) {\n\t\tdebug_f(\"provider %s returned no slots\", provider_id);\n\t\tret = -SSH_PKCS11_ERR_NO_SLOTS;\n\t\tgoto fail;\n\t}\n\tp->slotlist = xcalloc(p->nslots, sizeof(CK_SLOT_ID));\n\tif ((rv = f->C_GetSlotList(CK_TRUE, p->slotlist, &p->nslots))\n\t    != CKR_OK) {\n\t\terror(\"C_GetSlotList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->slotinfo = xcalloc(p->nslots, sizeof(struct pkcs11_slotinfo));\n\tp->valid = 1;\n\tnkeys = 0;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\ttoken = &p->slotinfo[i].token;\n\t\tif ((rv = f->C_GetTokenInfo(p->slotlist[i], token))\n\t\t    != CKR_OK) {\n\t\t\terror(\"C_GetTokenInfo for provider %s slot %lu \"\n\t\t\t    \"failed: %lu\", provider_id, (u_long)i, rv);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((token->flags & CKF_TOKEN_INITIALIZED) == 0) {\n\t\t\tdebug2_f(\"ignoring uninitialised token in \"\n\t\t\t    \"provider %s slot %lu\", provider_id, (u_long)i);\n\t\t\tcontinue;\n\t\t}\n\t\trmspace(token->label, sizeof(token->label));\n\t\trmspace(token->manufacturerID, sizeof(token->manufacturerID));\n\t\trmspace(token->model, sizeof(token->model));\n\t\trmspace(token->serialNumber, sizeof(token->serialNumber));\n\t\tdebug(\"provider %s slot %lu: label <%s> manufacturerID <%s> \"\n\t\t    \"model <%s> serial <%s> flags 0x%lx\",\n\t\t    provider_id, (unsigned long)i,\n\t\t    token->label, token->manufacturerID, token->model,\n\t\t    token->serialNumber, token->flags);\n\t\t/*\n\t\t * open session, login with pin and retrieve public\n\t\t * keys (if keyp is provided)\n\t\t */\n\t\tif ((ret = pkcs11_open_session(p, i, pin, user)) != 0 ||\n\t\t    keyp == NULL)\n\t\t\tcontinue;\n\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\tif (nkeys == 0 && !p->slotinfo[i].logged_in &&\n\t\t    pkcs11_interactive) {\n\t\t\t/*\n\t\t\t * Some tokens require login before they will\n\t\t\t * expose keys.\n\t\t\t */\n\t\t\tif (pkcs11_login_slot(p, &p->slotinfo[i],\n\t\t\t    CKU_USER) < 0) {\n\t\t\t\terror(\"login failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\t}\n\t}\n\n\t/* now owned by caller */\n\t*providerp = p;\n\n\tTAILQ_INSERT_TAIL(&pkcs11_providers, p, next);\n\tp->refcount++;\t/* add to provider list */\n\n\treturn (nkeys);\nfail:\n\tif (need_finalize && (rv = f->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\tif (p) {\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n\tif (handle)\n\t\tdlclose(handle);\n\tif (ret > 0)\n\t\tret = -1;\n\treturn (ret);\n}",
        "func": "static int\npkcs11_register_provider(char *provider_id, char *pin,\n    struct sshkey ***keyp, char ***labelsp,\n    struct pkcs11_provider **providerp, CK_ULONG user)\n{\n\tint nkeys, need_finalize = 0;\n\tint ret = -1;\n\tstruct pkcs11_provider *p = NULL;\n\tvoid *handle = NULL;\n\tCK_RV (*getfunctionlist)(CK_FUNCTION_LIST **);\n\tCK_RV rv;\n\tCK_FUNCTION_LIST *f = NULL;\n\tCK_TOKEN_INFO *token;\n\tCK_ULONG i;\n\n\tif (providerp == NULL)\n\t\tgoto fail;\n\t*providerp = NULL;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (labelsp != NULL)\n\t\t*labelsp = NULL;\n\n\tif (pkcs11_provider_lookup(provider_id) != NULL) {\n\t\tdebug_f(\"provider already registered: %s\", provider_id);\n\t\tgoto fail;\n\t}\n\tif (lib_contains_symbol(provider_id, \"C_GetFunctionList\") != 0) {\n\t\terror(\"provider %s is not a PKCS11 library\", provider_id);\n\t\tgoto fail;\n\t}\n\t/* open shared pkcs11-library */\n\tif ((handle = dlopen(provider_id, RTLD_NOW)) == NULL) {\n\t\terror(\"dlopen %s failed: %s\", provider_id, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL)\n\t\tfatal(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());\n\tp = xcalloc(1, sizeof(*p));\n\tp->name = xstrdup(provider_id);\n\tp->handle = handle;\n\t/* setup the pkcs11 callbacks */\n\tif ((rv = (*getfunctionlist)(&f)) != CKR_OK) {\n\t\terror(\"C_GetFunctionList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->function_list = f;\n\tif ((rv = f->C_Initialize(NULL)) != CKR_OK) {\n\t\terror(\"C_Initialize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tneed_finalize = 1;\n\tif ((rv = f->C_GetInfo(&p->info)) != CKR_OK) {\n\t\terror(\"C_GetInfo for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\trmspace(p->info.manufacturerID, sizeof(p->info.manufacturerID));\n\trmspace(p->info.libraryDescription, sizeof(p->info.libraryDescription));\n\tdebug(\"provider %s: manufacturerID <%s> cryptokiVersion %d.%d\"\n\t    \" libraryDescription <%s> libraryVersion %d.%d\",\n\t    provider_id,\n\t    p->info.manufacturerID,\n\t    p->info.cryptokiVersion.major,\n\t    p->info.cryptokiVersion.minor,\n\t    p->info.libraryDescription,\n\t    p->info.libraryVersion.major,\n\t    p->info.libraryVersion.minor);\n\tif ((rv = f->C_GetSlotList(CK_TRUE, NULL, &p->nslots)) != CKR_OK) {\n\t\terror(\"C_GetSlotList failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\tif (p->nslots == 0) {\n\t\tdebug_f(\"provider %s returned no slots\", provider_id);\n\t\tret = -SSH_PKCS11_ERR_NO_SLOTS;\n\t\tgoto fail;\n\t}\n\tp->slotlist = xcalloc(p->nslots, sizeof(CK_SLOT_ID));\n\tif ((rv = f->C_GetSlotList(CK_TRUE, p->slotlist, &p->nslots))\n\t    != CKR_OK) {\n\t\terror(\"C_GetSlotList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->slotinfo = xcalloc(p->nslots, sizeof(struct pkcs11_slotinfo));\n\tp->valid = 1;\n\tnkeys = 0;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\ttoken = &p->slotinfo[i].token;\n\t\tif ((rv = f->C_GetTokenInfo(p->slotlist[i], token))\n\t\t    != CKR_OK) {\n\t\t\terror(\"C_GetTokenInfo for provider %s slot %lu \"\n\t\t\t    \"failed: %lu\", provider_id, (u_long)i, rv);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((token->flags & CKF_TOKEN_INITIALIZED) == 0) {\n\t\t\tdebug2_f(\"ignoring uninitialised token in \"\n\t\t\t    \"provider %s slot %lu\", provider_id, (u_long)i);\n\t\t\tcontinue;\n\t\t}\n\t\trmspace(token->label, sizeof(token->label));\n\t\trmspace(token->manufacturerID, sizeof(token->manufacturerID));\n\t\trmspace(token->model, sizeof(token->model));\n\t\trmspace(token->serialNumber, sizeof(token->serialNumber));\n\t\tdebug(\"provider %s slot %lu: label <%s> manufacturerID <%s> \"\n\t\t    \"model <%s> serial <%s> flags 0x%lx\",\n\t\t    provider_id, (unsigned long)i,\n\t\t    token->label, token->manufacturerID, token->model,\n\t\t    token->serialNumber, token->flags);\n\t\t/*\n\t\t * open session, login with pin and retrieve public\n\t\t * keys (if keyp is provided)\n\t\t */\n\t\tif ((ret = pkcs11_open_session(p, i, pin, user)) != 0 ||\n\t\t    keyp == NULL)\n\t\t\tcontinue;\n\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\tif (nkeys == 0 && !p->slotinfo[i].logged_in &&\n\t\t    pkcs11_interactive) {\n\t\t\t/*\n\t\t\t * Some tokens require login before they will\n\t\t\t * expose keys.\n\t\t\t */\n\t\t\tif (pkcs11_login_slot(p, &p->slotinfo[i],\n\t\t\t    CKU_USER) < 0) {\n\t\t\t\terror(\"login failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\t}\n\t}\n\n\t/* now owned by caller */\n\t*providerp = p;\n\n\tTAILQ_INSERT_TAIL(&pkcs11_providers, p, next);\n\tp->refcount++;\t/* add to provider list */\n\n\treturn (nkeys);\nfail:\n\tif (need_finalize && (rv = f->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\tif (p) {\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n\tif (handle)\n\t\tdlclose(handle);\n\tif (ret > 0)\n\t\tret = -1;\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,10 @@\n \n \tif (pkcs11_provider_lookup(provider_id) != NULL) {\n \t\tdebug_f(\"provider already registered: %s\", provider_id);\n+\t\tgoto fail;\n+\t}\n+\tif (lib_contains_symbol(provider_id, \"C_GetFunctionList\") != 0) {\n+\t\terror(\"provider %s is not a PKCS11 library\", provider_id);\n \t\tgoto fail;\n \t}\n \t/* open shared pkcs11-library */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tgoto fail;",
                "\t}",
                "\tif (lib_contains_symbol(provider_id, \"C_GetFunctionList\") != 0) {",
                "\t\terror(\"provider %s is not a PKCS11 library\", provider_id);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-38408",
        "func_name": "openbsd/src/sshsk_open",
        "description": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.",
        "git_url": "https://github.com/openbsd/src/commit/f8f5a6b003981bb824329dc987d101977beda7ca",
        "commit_title": "Ensure FIDO/PKCS11 libraries contain expected symbols",
        "commit_text": " This checks via nlist(3) that candidate provider libraries contain one of the symbols that we will require prior to dlopen(), which can cause a number of side effects, including execution of constructors.  Feedback deraadt; ok markus",
        "func_before": "static struct sshsk_provider *\nsshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\t/* Skip the rest if we're using the linked in middleware */\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\t/* success */\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}",
        "func": "static struct sshsk_provider *\nsshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\t/* Skip the rest if we're using the linked in middleware */\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n\t}\n\tif (lib_contains_symbol(path, \"sk_api_version\") != 0) {\n\t\terror(\"provider %s is not an OpenSSH FIDO library\", path);\n\t\tgoto fail;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\tfatal(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\t/* success */\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,15 +23,18 @@\n \t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n \t\treturn ret;\n \t}\n+\tif (lib_contains_symbol(path, \"sk_api_version\") != 0) {\n+\t\terror(\"provider %s is not an OpenSSH FIDO library\", path);\n+\t\tgoto fail;\n+\t}\n \tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n \t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n \t\tgoto fail;\n \t}\n \tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n \t    \"sk_api_version\")) == NULL) {\n-\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n+\t\tfatal(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n \t\t    path, dlerror());\n-\t\tgoto fail;\n \t}\n \tversion = ret->sk_api_version();\n \tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,",
        "diff_line_info": {
            "deleted_lines": [
                "\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",",
                "\t\tgoto fail;"
            ],
            "added_lines": [
                "\tif (lib_contains_symbol(path, \"sk_api_version\") != 0) {",
                "\t\terror(\"provider %s is not an OpenSSH FIDO library\", path);",
                "\t\tgoto fail;",
                "\t}",
                "\t\tfatal(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\","
            ]
        }
    },
    {
        "cve_id": "CVE-2023-38408",
        "func_name": "openbsd/src/pkcs11_register_provider",
        "description": "The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.",
        "git_url": "https://github.com/openbsd/src/commit/f03a4faa55c4ce0818324701dadbf91988d7351d",
        "commit_title": "terminate process if requested to load a PKCS#11 provider that",
        "commit_text": "isn't a PKCS#11 provider; from / ok markus@",
        "func_before": "static int\npkcs11_register_provider(char *provider_id, char *pin,\n    struct sshkey ***keyp, char ***labelsp,\n    struct pkcs11_provider **providerp, CK_ULONG user)\n{\n\tint nkeys, need_finalize = 0;\n\tint ret = -1;\n\tstruct pkcs11_provider *p = NULL;\n\tvoid *handle = NULL;\n\tCK_RV (*getfunctionlist)(CK_FUNCTION_LIST **);\n\tCK_RV rv;\n\tCK_FUNCTION_LIST *f = NULL;\n\tCK_TOKEN_INFO *token;\n\tCK_ULONG i;\n\n\tif (providerp == NULL)\n\t\tgoto fail;\n\t*providerp = NULL;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (labelsp != NULL)\n\t\t*labelsp = NULL;\n\n\tif (pkcs11_provider_lookup(provider_id) != NULL) {\n\t\tdebug_f(\"provider already registered: %s\", provider_id);\n\t\tgoto fail;\n\t}\n\t/* open shared pkcs11-library */\n\tif ((handle = dlopen(provider_id, RTLD_NOW)) == NULL) {\n\t\terror(\"dlopen %s failed: %s\", provider_id, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL) {\n\t\terror(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());\n\t\tgoto fail;\n\t}\n\tp = xcalloc(1, sizeof(*p));\n\tp->name = xstrdup(provider_id);\n\tp->handle = handle;\n\t/* setup the pkcs11 callbacks */\n\tif ((rv = (*getfunctionlist)(&f)) != CKR_OK) {\n\t\terror(\"C_GetFunctionList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->function_list = f;\n\tif ((rv = f->C_Initialize(NULL)) != CKR_OK) {\n\t\terror(\"C_Initialize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tneed_finalize = 1;\n\tif ((rv = f->C_GetInfo(&p->info)) != CKR_OK) {\n\t\terror(\"C_GetInfo for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\trmspace(p->info.manufacturerID, sizeof(p->info.manufacturerID));\n\trmspace(p->info.libraryDescription, sizeof(p->info.libraryDescription));\n\tdebug(\"provider %s: manufacturerID <%s> cryptokiVersion %d.%d\"\n\t    \" libraryDescription <%s> libraryVersion %d.%d\",\n\t    provider_id,\n\t    p->info.manufacturerID,\n\t    p->info.cryptokiVersion.major,\n\t    p->info.cryptokiVersion.minor,\n\t    p->info.libraryDescription,\n\t    p->info.libraryVersion.major,\n\t    p->info.libraryVersion.minor);\n\tif ((rv = f->C_GetSlotList(CK_TRUE, NULL, &p->nslots)) != CKR_OK) {\n\t\terror(\"C_GetSlotList failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\tif (p->nslots == 0) {\n\t\tdebug_f(\"provider %s returned no slots\", provider_id);\n\t\tret = -SSH_PKCS11_ERR_NO_SLOTS;\n\t\tgoto fail;\n\t}\n\tp->slotlist = xcalloc(p->nslots, sizeof(CK_SLOT_ID));\n\tif ((rv = f->C_GetSlotList(CK_TRUE, p->slotlist, &p->nslots))\n\t    != CKR_OK) {\n\t\terror(\"C_GetSlotList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->slotinfo = xcalloc(p->nslots, sizeof(struct pkcs11_slotinfo));\n\tp->valid = 1;\n\tnkeys = 0;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\ttoken = &p->slotinfo[i].token;\n\t\tif ((rv = f->C_GetTokenInfo(p->slotlist[i], token))\n\t\t    != CKR_OK) {\n\t\t\terror(\"C_GetTokenInfo for provider %s slot %lu \"\n\t\t\t    \"failed: %lu\", provider_id, (u_long)i, rv);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((token->flags & CKF_TOKEN_INITIALIZED) == 0) {\n\t\t\tdebug2_f(\"ignoring uninitialised token in \"\n\t\t\t    \"provider %s slot %lu\", provider_id, (u_long)i);\n\t\t\tcontinue;\n\t\t}\n\t\trmspace(token->label, sizeof(token->label));\n\t\trmspace(token->manufacturerID, sizeof(token->manufacturerID));\n\t\trmspace(token->model, sizeof(token->model));\n\t\trmspace(token->serialNumber, sizeof(token->serialNumber));\n\t\tdebug(\"provider %s slot %lu: label <%s> manufacturerID <%s> \"\n\t\t    \"model <%s> serial <%s> flags 0x%lx\",\n\t\t    provider_id, (unsigned long)i,\n\t\t    token->label, token->manufacturerID, token->model,\n\t\t    token->serialNumber, token->flags);\n\t\t/*\n\t\t * open session, login with pin and retrieve public\n\t\t * keys (if keyp is provided)\n\t\t */\n\t\tif ((ret = pkcs11_open_session(p, i, pin, user)) != 0 ||\n\t\t    keyp == NULL)\n\t\t\tcontinue;\n\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\tif (nkeys == 0 && !p->slotinfo[i].logged_in &&\n\t\t    pkcs11_interactive) {\n\t\t\t/*\n\t\t\t * Some tokens require login before they will\n\t\t\t * expose keys.\n\t\t\t */\n\t\t\tif (pkcs11_login_slot(p, &p->slotinfo[i],\n\t\t\t    CKU_USER) < 0) {\n\t\t\t\terror(\"login failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\t}\n\t}\n\n\t/* now owned by caller */\n\t*providerp = p;\n\n\tTAILQ_INSERT_TAIL(&pkcs11_providers, p, next);\n\tp->refcount++;\t/* add to provider list */\n\n\treturn (nkeys);\nfail:\n\tif (need_finalize && (rv = f->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\tif (p) {\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n\tif (handle)\n\t\tdlclose(handle);\n\tif (ret > 0)\n\t\tret = -1;\n\treturn (ret);\n}",
        "func": "static int\npkcs11_register_provider(char *provider_id, char *pin,\n    struct sshkey ***keyp, char ***labelsp,\n    struct pkcs11_provider **providerp, CK_ULONG user)\n{\n\tint nkeys, need_finalize = 0;\n\tint ret = -1;\n\tstruct pkcs11_provider *p = NULL;\n\tvoid *handle = NULL;\n\tCK_RV (*getfunctionlist)(CK_FUNCTION_LIST **);\n\tCK_RV rv;\n\tCK_FUNCTION_LIST *f = NULL;\n\tCK_TOKEN_INFO *token;\n\tCK_ULONG i;\n\n\tif (providerp == NULL)\n\t\tgoto fail;\n\t*providerp = NULL;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\tif (labelsp != NULL)\n\t\t*labelsp = NULL;\n\n\tif (pkcs11_provider_lookup(provider_id) != NULL) {\n\t\tdebug_f(\"provider already registered: %s\", provider_id);\n\t\tgoto fail;\n\t}\n\t/* open shared pkcs11-library */\n\tif ((handle = dlopen(provider_id, RTLD_NOW)) == NULL) {\n\t\terror(\"dlopen %s failed: %s\", provider_id, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL)\n\t\tfatal(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());\n\tp = xcalloc(1, sizeof(*p));\n\tp->name = xstrdup(provider_id);\n\tp->handle = handle;\n\t/* setup the pkcs11 callbacks */\n\tif ((rv = (*getfunctionlist)(&f)) != CKR_OK) {\n\t\terror(\"C_GetFunctionList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->function_list = f;\n\tif ((rv = f->C_Initialize(NULL)) != CKR_OK) {\n\t\terror(\"C_Initialize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tneed_finalize = 1;\n\tif ((rv = f->C_GetInfo(&p->info)) != CKR_OK) {\n\t\terror(\"C_GetInfo for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\trmspace(p->info.manufacturerID, sizeof(p->info.manufacturerID));\n\trmspace(p->info.libraryDescription, sizeof(p->info.libraryDescription));\n\tdebug(\"provider %s: manufacturerID <%s> cryptokiVersion %d.%d\"\n\t    \" libraryDescription <%s> libraryVersion %d.%d\",\n\t    provider_id,\n\t    p->info.manufacturerID,\n\t    p->info.cryptokiVersion.major,\n\t    p->info.cryptokiVersion.minor,\n\t    p->info.libraryDescription,\n\t    p->info.libraryVersion.major,\n\t    p->info.libraryVersion.minor);\n\tif ((rv = f->C_GetSlotList(CK_TRUE, NULL, &p->nslots)) != CKR_OK) {\n\t\terror(\"C_GetSlotList failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\tif (p->nslots == 0) {\n\t\tdebug_f(\"provider %s returned no slots\", provider_id);\n\t\tret = -SSH_PKCS11_ERR_NO_SLOTS;\n\t\tgoto fail;\n\t}\n\tp->slotlist = xcalloc(p->nslots, sizeof(CK_SLOT_ID));\n\tif ((rv = f->C_GetSlotList(CK_TRUE, p->slotlist, &p->nslots))\n\t    != CKR_OK) {\n\t\terror(\"C_GetSlotList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->slotinfo = xcalloc(p->nslots, sizeof(struct pkcs11_slotinfo));\n\tp->valid = 1;\n\tnkeys = 0;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\ttoken = &p->slotinfo[i].token;\n\t\tif ((rv = f->C_GetTokenInfo(p->slotlist[i], token))\n\t\t    != CKR_OK) {\n\t\t\terror(\"C_GetTokenInfo for provider %s slot %lu \"\n\t\t\t    \"failed: %lu\", provider_id, (u_long)i, rv);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((token->flags & CKF_TOKEN_INITIALIZED) == 0) {\n\t\t\tdebug2_f(\"ignoring uninitialised token in \"\n\t\t\t    \"provider %s slot %lu\", provider_id, (u_long)i);\n\t\t\tcontinue;\n\t\t}\n\t\trmspace(token->label, sizeof(token->label));\n\t\trmspace(token->manufacturerID, sizeof(token->manufacturerID));\n\t\trmspace(token->model, sizeof(token->model));\n\t\trmspace(token->serialNumber, sizeof(token->serialNumber));\n\t\tdebug(\"provider %s slot %lu: label <%s> manufacturerID <%s> \"\n\t\t    \"model <%s> serial <%s> flags 0x%lx\",\n\t\t    provider_id, (unsigned long)i,\n\t\t    token->label, token->manufacturerID, token->model,\n\t\t    token->serialNumber, token->flags);\n\t\t/*\n\t\t * open session, login with pin and retrieve public\n\t\t * keys (if keyp is provided)\n\t\t */\n\t\tif ((ret = pkcs11_open_session(p, i, pin, user)) != 0 ||\n\t\t    keyp == NULL)\n\t\t\tcontinue;\n\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\tif (nkeys == 0 && !p->slotinfo[i].logged_in &&\n\t\t    pkcs11_interactive) {\n\t\t\t/*\n\t\t\t * Some tokens require login before they will\n\t\t\t * expose keys.\n\t\t\t */\n\t\t\tif (pkcs11_login_slot(p, &p->slotinfo[i],\n\t\t\t    CKU_USER) < 0) {\n\t\t\t\terror(\"login failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpkcs11_fetch_keys(p, i, keyp, labelsp, &nkeys);\n\t\t\tpkcs11_fetch_certs(p, i, keyp, labelsp, &nkeys);\n\t\t}\n\t}\n\n\t/* now owned by caller */\n\t*providerp = p;\n\n\tTAILQ_INSERT_TAIL(&pkcs11_providers, p, next);\n\tp->refcount++;\t/* add to provider list */\n\n\treturn (nkeys);\nfail:\n\tif (need_finalize && (rv = f->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\tif (p) {\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n\tif (handle)\n\t\tdlclose(handle);\n\tif (ret > 0)\n\t\tret = -1;\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,10 +31,8 @@\n \t\terror(\"dlopen %s failed: %s\", provider_id, dlerror());\n \t\tgoto fail;\n \t}\n-\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL) {\n-\t\terror(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());\n-\t\tgoto fail;\n-\t}\n+\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL)\n+\t\tfatal(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());\n \tp = xcalloc(1, sizeof(*p));\n \tp->name = xstrdup(provider_id);\n \tp->handle = handle;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL) {",
                "\t\terror(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());",
                "\t\tgoto fail;",
                "\t}"
            ],
            "added_lines": [
                "\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL)",
                "\t\tfatal(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15261",
        "func_name": "veyon/WindowsServiceControl::install",
        "description": "On Windows the Veyon Service before version 4.4.2 contains an unquoted service path vulnerability, allowing locally authenticated users with administrative privileges to run malicious executables with LocalSystem privileges. Since Veyon users (both students and teachers) usually don't have administrative privileges, this vulnerability is only dangerous in anyway unsafe setups. The problem has been fixed in version 4.4.2. As a workaround, the exploitation of the vulnerability can be prevented by revoking administrative privileges from all potentially untrustworthy users.",
        "git_url": "https://github.com/veyon/veyon/commit/f231ec511b9a09f43f49b2c7bb7c60b8046276b1",
        "commit_title": "WindowsServiceControl: quote service binary path",
        "commit_text": " Fix unquoted service path vulnerability.  Closes #657.",
        "func_before": "bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t// SCManager database\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t// name of service\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),// name to display\n\t\t\t\tSERVICE_ALL_ACCESS,\t// desired access\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\t// service type\n\t\t\t\tSERVICE_AUTO_START,\t// start type\n\t\t\t\tSERVICE_ERROR_NORMAL,\t// error control type\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t// service's binary\n\t\t\t\tnullptr,\t\t\t// no load ordering group\n\t\t\t\tnullptr,\t\t\t// no tag identifier\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t// dependencies\n\t\t\t\tnullptr,\t\t\t// LocalSystem account\n\t\t\t\tnullptr );\t\t\t// no password\n\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\n\t// Everything went fine\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\n\treturn true;\n}",
        "func": "bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tconst auto binaryPath = QStringLiteral(\"\\\"%1\\\"\").arg( QString( filePath ).replace( QLatin1Char('\"'), QString() ) );\n\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t// SCManager database\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t// name of service\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),// name to display\n\t\t\t\tSERVICE_ALL_ACCESS,\t// desired access\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\t// service type\n\t\t\t\tSERVICE_AUTO_START,\t// start type\n\t\t\t\tSERVICE_ERROR_NORMAL,\t// error control type\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( binaryPath ),\t\t// service's binary\n\t\t\t\tnullptr,\t\t\t// no load ordering group\n\t\t\t\tnullptr,\t\t\t// no tag identifier\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t// dependencies\n\t\t\t\tnullptr,\t\t\t// LocalSystem account\n\t\t\t\tnullptr );\t\t\t// no password\n\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\n\t// Everything went fine\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n {\n+\tconst auto binaryPath = QStringLiteral(\"\\\"%1\\\"\").arg( QString( filePath ).replace( QLatin1Char('\"'), QString() ) );\n+\n \tm_serviceHandle = CreateService(\n \t\t\t\tm_serviceManager,\t\t// SCManager database\n \t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t// name of service\n@@ -9,7 +11,7 @@\n \t\t\t\t// service type\n \t\t\t\tSERVICE_AUTO_START,\t// start type\n \t\t\t\tSERVICE_ERROR_NORMAL,\t// error control type\n-\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t// service's binary\n+\t\t\t\tWindowsCoreFunctions::toConstWCharArray( binaryPath ),\t\t// service's binary\n \t\t\t\tnullptr,\t\t\t// no load ordering group\n \t\t\t\tnullptr,\t\t\t// no tag identifier\n \t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t// dependencies",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t// service's binary"
            ],
            "added_lines": [
                "\tconst auto binaryPath = QStringLiteral(\"\\\"%1\\\"\").arg( QString( filePath ).replace( QLatin1Char('\"'), QString() ) );",
                "",
                "\t\t\t\tWindowsCoreFunctions::toConstWCharArray( binaryPath ),\t\t// service's binary"
            ]
        }
    }
]