[
    {
        "cve_id": "CVE-2019-14523",
        "func_name": "schismtracker/fmt_mtm_load_song",
        "description": "An issue was discovered in Schism Tracker through 20190722. There is an integer underflow via a large plen in fmt_okt_load_song in the Amiga Oktalyzer parser in fmt/okt.c.",
        "git_url": "https://github.com/schismtracker/schismtracker/commit/c8986a876959a9d282e882d782af351a86e4034c",
        "commit_title": "Guard against negative size_t to memset in MTM and OKT loaders (#202)",
        "commit_text": "",
        "func_before": "int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t b[192];\n\tint16_t ntrk, nchan, nord, npat, nsmp; // signed so that EOF is -1\n\tuint16_t comment_len;\n\tint n, pat, chan, smp, rows, todo = 0;\n\tsong_note_t *note;\n\tuint16_t tmp;\n\tuint32_t tmplong;\n\tsong_note_t **trackdata, *tracknote;\n\tsong_sample_t *sample;\n\n\tslurp_read(fp, b, 3);\n\tif (memcmp(b, \"MTM\", 3) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\tn = slurp_getc(fp);\n\tsprintf(song->tracker_id, \"MultiTracker %d.%d\", n >> 4, n & 0xf);\n\tslurp_read(fp, song->title, 20);\n\tsong->title[20] = 0;\n\tslurp_read(fp, &ntrk, 2);\n\tntrk = bswapLE16(ntrk);\n\tnpat = slurp_getc(fp);\n\tnord = slurp_getc(fp) + 1;\n\n\tslurp_read(fp, &comment_len, 2);\n\tcomment_len = bswapLE16(comment_len);\n\n\tnsmp = slurp_getc(fp);\n\tslurp_getc(fp); /* attribute byte (unused) */\n\trows = slurp_getc(fp); /* beats per track (translation: number of rows in every pattern) */\n\tif (rows != 64)\n\t\ttodo |= 64;\n\trows = MIN(rows, 64);\n\tnchan = slurp_getc(fp);\n\tfor (n = 0; n < 32; n++) {\n\t\tint pan = slurp_getc(fp) & 0xf;\n\t\tpan = SHORT_PANNING(pan);\n\t\tpan *= 4; //mphack\n\t\tsong->channels[n].panning = pan;\n\t}\n\tfor (n = nchan; n < MAX_CHANNELS; n++)\n\t\tsong->channels[n].flags = CHN_MUTE;\n\n\t/* samples */\n\tif (nsmp > MAX_SAMPLES) {\n\t\tlog_appendf(4, \" Warning: Too many samples\");\n\t}\n\tfor (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) {\n\t\tif (n > MAX_SAMPLES) {\n\t\t\tslurp_seek(fp, 37, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* IT truncates .mtm sample names at the first \\0 rather than the normal behavior\n\t\tof presenting them as spaces (k-achaet.mtm has some \"junk\" in the sample text) */\n\t\tchar name[23];\n\t\tslurp_read(fp, name, 22);\n\t\tname[22] = '\\0';\n\t\tstrcpy(sample->name, name);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->length = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_start = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_end = bswapLE32(tmplong);\n\t\tif ((sample->loop_end - sample->loop_start) > 2) {\n\t\t\tsample->flags |= CHN_LOOP;\n\t\t} else {\n\t\t\t/* Both Impulse Tracker and Modplug do this */\n\t\t\tsample->loop_start = 0;\n\t\t\tsample->loop_end = 0;\n\t\t}\n\t\tsong->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp));\n\t\tsample->volume = slurp_getc(fp);\n\t\tsample->volume *= 4; //mphack\n\t\tsample->global_volume = 64;\n\t\tif (slurp_getc(fp) & 1) {\n\t\t\ttodo |= 16;\n\t\t\tsample->flags |= CHN_16BIT;\n\t\t\tsample->length >>= 1;\n\t\t\tsample->loop_start >>= 1;\n\t\t\tsample->loop_end >>= 1;\n\t\t}\n\t\tsong->samples[n].vib_type = 0;\n\t\tsong->samples[n].vib_rate = 0;\n\t\tsong->samples[n].vib_depth = 0;\n\t\tsong->samples[n].vib_speed = 0;\n\t}\n\n\t/* orderlist */\n\tslurp_read(fp, song->orderlist, 128);\n\tmemset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord);\n\n\t/* tracks */\n\ttrackdata = mem_calloc(ntrk, sizeof(song_note_t *));\n\tfor (n = 0; n < ntrk; n++) {\n\t\tslurp_read(fp, b, 3 * rows);\n\t\ttrackdata[n] = mem_calloc(rows, sizeof(song_note_t));\n\t\tmtm_unpack_track(b, trackdata[n], rows);\n\t}\n\n\t/* patterns */\n\tif (npat >= MAX_PATTERNS) {\n\t\tlog_appendf(4, \" Warning: Too many patterns\");\n\t}\n\tfor (pat = 0; pat <= npat; pat++) {\n\t\t// skip ones that can't be loaded\n\t\tif (pat >= MAX_PATTERNS) {\n\t\t\tslurp_seek(fp, 64, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsong->patterns[pat] = csf_allocate_pattern(MAX(rows, 32));\n\t\tsong->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;\n\t\ttracknote = trackdata[n];\n\t\tfor (chan = 0; chan < 32; chan++) {\n\t\t\tslurp_read(fp, &tmp, 2);\n\t\t\ttmp = bswapLE16(tmp);\n\t\t\tif (tmp == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (tmp > ntrk) {\n\t\t\t\tfor (n = 0; n < ntrk; n++)\n\t\t\t\t\tfree(trackdata[n]);\n\t\t\t\tfree(trackdata);\n\t\t\t\treturn LOAD_FORMAT_ERROR;\n\t\t\t}\n\t\t\tnote = song->patterns[pat] + chan;\n\t\t\ttracknote = trackdata[tmp - 1];\n\t\t\tfor (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS)\n\t\t\t\t*note = *tracknote;\n\t\t}\n\t\tif (rows < 32) {\n\t\t\t/* stick a pattern break on the first channel with an empty effect column\n\t\t\t * (XXX don't do this if there's already one in another column) */\n\t\t\tnote = song->patterns[pat] + 64 * (rows - 1);\n\t\t\twhile (note->effect || note->param)\n\t\t\t\tnote++;\n\t\t\tnote->effect = FX_PATTERNBREAK;\n\t\t}\n\t}\n\n\t/* free willy */\n\tfor (n = 0; n < ntrk; n++)\n\t\tfree(trackdata[n]);\n\tfree(trackdata);\n\n\tread_lined_message(song->message, fp, comment_len, 40);\n\n\t/* sample data */\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) {\n\t\t\tuint32_t ssize;\n\n\t\t\tif (song->samples[smp].length == 0)\n\t\t\t\tcontinue;\n\t\t\tssize = csf_read_sample(song->samples + smp,\n\t\t\t\t(SF_LE | SF_PCMU | SF_M\n\t\t\t\t | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)),\n\t\t\t\tfp->data + fp->pos, fp->length - fp->pos);\n\t\t\tslurp_seek(fp, ssize, SEEK_CUR);\n\t\t}\n\t}\n\n\t/* set the rest of the stuff */\n\tsong->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX;\n\n//      if (ferror(fp)) {\n//              return LOAD_FILE_ERROR;\n//      }\n\n\tif (todo & 64)\n\t\tlog_appendf(2, \" TODO: test this file with other players (beats per track != 64)\");\n\tif (todo & 16)\n\t\tlog_appendf(2, \" TODO: double check 16 bit sample loading\");\n\n\t/* done! */\n\treturn LOAD_SUCCESS;\n}",
        "func": "int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t b[192];\n\tint16_t ntrk, nchan, nord, npat, nsmp; // signed so that EOF is -1\n\tuint16_t comment_len;\n\tint n, pat, chan, smp, rows, todo = 0;\n\tsong_note_t *note;\n\tuint16_t tmp;\n\tuint32_t tmplong;\n\tsong_note_t **trackdata, *tracknote;\n\tsong_sample_t *sample;\n\n\tslurp_read(fp, b, 3);\n\tif (memcmp(b, \"MTM\", 3) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\tn = slurp_getc(fp);\n\tsprintf(song->tracker_id, \"MultiTracker %d.%d\", n >> 4, n & 0xf);\n\tslurp_read(fp, song->title, 20);\n\tsong->title[20] = 0;\n\tslurp_read(fp, &ntrk, 2);\n\tntrk = bswapLE16(ntrk);\n\tnpat = slurp_getc(fp);\n\tnord = slurp_getc(fp) + 1;\n\n\tslurp_read(fp, &comment_len, 2);\n\tcomment_len = bswapLE16(comment_len);\n\n\tnsmp = slurp_getc(fp);\n\tslurp_getc(fp); /* attribute byte (unused) */\n\trows = slurp_getc(fp); /* beats per track (translation: number of rows in every pattern) */\n\tif (rows != 64)\n\t\ttodo |= 64;\n\trows = MIN(rows, 64);\n\tnchan = slurp_getc(fp);\n\tfor (n = 0; n < 32; n++) {\n\t\tint pan = slurp_getc(fp) & 0xf;\n\t\tpan = SHORT_PANNING(pan);\n\t\tpan *= 4; //mphack\n\t\tsong->channels[n].panning = pan;\n\t}\n\tfor (n = nchan; n < MAX_CHANNELS; n++)\n\t\tsong->channels[n].flags = CHN_MUTE;\n\n\tif (slurp_eof(fp)) {\n\t\treturn LOAD_FORMAT_ERROR;\n\t}\n\n\t/* samples */\n\tif (nsmp > MAX_SAMPLES) {\n\t\tlog_appendf(4, \" Warning: Too many samples\");\n\t}\n\tfor (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) {\n\t\tif (n > MAX_SAMPLES) {\n\t\t\tslurp_seek(fp, 37, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* IT truncates .mtm sample names at the first \\0 rather than the normal behavior\n\t\tof presenting them as spaces (k-achaet.mtm has some \"junk\" in the sample text) */\n\t\tchar name[23];\n\t\tslurp_read(fp, name, 22);\n\t\tname[22] = '\\0';\n\t\tstrcpy(sample->name, name);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->length = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_start = bswapLE32(tmplong);\n\t\tslurp_read(fp, &tmplong, 4);\n\t\tsample->loop_end = bswapLE32(tmplong);\n\t\tif ((sample->loop_end - sample->loop_start) > 2) {\n\t\t\tsample->flags |= CHN_LOOP;\n\t\t} else {\n\t\t\t/* Both Impulse Tracker and Modplug do this */\n\t\t\tsample->loop_start = 0;\n\t\t\tsample->loop_end = 0;\n\t\t}\n\t\tsong->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp));\n\t\tsample->volume = slurp_getc(fp);\n\t\tsample->volume *= 4; //mphack\n\t\tsample->global_volume = 64;\n\t\tif (slurp_getc(fp) & 1) {\n\t\t\ttodo |= 16;\n\t\t\tsample->flags |= CHN_16BIT;\n\t\t\tsample->length >>= 1;\n\t\t\tsample->loop_start >>= 1;\n\t\t\tsample->loop_end >>= 1;\n\t\t}\n\t\tsong->samples[n].vib_type = 0;\n\t\tsong->samples[n].vib_rate = 0;\n\t\tsong->samples[n].vib_depth = 0;\n\t\tsong->samples[n].vib_speed = 0;\n\t}\n\n\t/* orderlist */\n\tslurp_read(fp, song->orderlist, 128);\n\tmemset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord);\n\n\t/* tracks */\n\ttrackdata = mem_calloc(ntrk, sizeof(song_note_t *));\n\tfor (n = 0; n < ntrk; n++) {\n\t\tslurp_read(fp, b, 3 * rows);\n\t\ttrackdata[n] = mem_calloc(rows, sizeof(song_note_t));\n\t\tmtm_unpack_track(b, trackdata[n], rows);\n\t}\n\n\t/* patterns */\n\tif (npat >= MAX_PATTERNS) {\n\t\tlog_appendf(4, \" Warning: Too many patterns\");\n\t}\n\tfor (pat = 0; pat <= npat; pat++) {\n\t\t// skip ones that can't be loaded\n\t\tif (pat >= MAX_PATTERNS) {\n\t\t\tslurp_seek(fp, 64, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsong->patterns[pat] = csf_allocate_pattern(MAX(rows, 32));\n\t\tsong->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;\n\t\ttracknote = trackdata[n];\n\t\tfor (chan = 0; chan < 32; chan++) {\n\t\t\tslurp_read(fp, &tmp, 2);\n\t\t\ttmp = bswapLE16(tmp);\n\t\t\tif (tmp == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (tmp > ntrk) {\n\t\t\t\tfor (n = 0; n < ntrk; n++)\n\t\t\t\t\tfree(trackdata[n]);\n\t\t\t\tfree(trackdata);\n\t\t\t\treturn LOAD_FORMAT_ERROR;\n\t\t\t}\n\t\t\tnote = song->patterns[pat] + chan;\n\t\t\ttracknote = trackdata[tmp - 1];\n\t\t\tfor (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS)\n\t\t\t\t*note = *tracknote;\n\t\t}\n\t\tif (rows < 32) {\n\t\t\t/* stick a pattern break on the first channel with an empty effect column\n\t\t\t * (XXX don't do this if there's already one in another column) */\n\t\t\tnote = song->patterns[pat] + 64 * (rows - 1);\n\t\t\twhile (note->effect || note->param)\n\t\t\t\tnote++;\n\t\t\tnote->effect = FX_PATTERNBREAK;\n\t\t}\n\t}\n\n\t/* free willy */\n\tfor (n = 0; n < ntrk; n++)\n\t\tfree(trackdata[n]);\n\tfree(trackdata);\n\n\tread_lined_message(song->message, fp, comment_len, 40);\n\n\t/* sample data */\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) {\n\t\t\tuint32_t ssize;\n\n\t\t\tif (song->samples[smp].length == 0)\n\t\t\t\tcontinue;\n\t\t\tssize = csf_read_sample(song->samples + smp,\n\t\t\t\t(SF_LE | SF_PCMU | SF_M\n\t\t\t\t | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)),\n\t\t\t\tfp->data + fp->pos, fp->length - fp->pos);\n\t\t\tslurp_seek(fp, ssize, SEEK_CUR);\n\t\t}\n\t}\n\n\t/* set the rest of the stuff */\n\tsong->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX;\n\n//      if (ferror(fp)) {\n//              return LOAD_FILE_ERROR;\n//      }\n\n\tif (todo & 64)\n\t\tlog_appendf(2, \" TODO: test this file with other players (beats per track != 64)\");\n\tif (todo & 16)\n\t\tlog_appendf(2, \" TODO: double check 16 bit sample loading\");\n\n\t/* done! */\n\treturn LOAD_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,10 @@\n \t}\n \tfor (n = nchan; n < MAX_CHANNELS; n++)\n \t\tsong->channels[n].flags = CHN_MUTE;\n+\n+\tif (slurp_eof(fp)) {\n+\t\treturn LOAD_FORMAT_ERROR;\n+\t}\n \n \t/* samples */\n \tif (nsmp > MAX_SAMPLES) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (slurp_eof(fp)) {",
                "\t\treturn LOAD_FORMAT_ERROR;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14523",
        "func_name": "schismtracker/fmt_okt_load_song",
        "description": "An issue was discovered in Schism Tracker through 20190722. There is an integer underflow via a large plen in fmt_okt_load_song in the Amiga Oktalyzer parser in fmt/okt.c.",
        "git_url": "https://github.com/schismtracker/schismtracker/commit/c8986a876959a9d282e882d782af351a86e4034c",
        "commit_title": "Guard against negative size_t to memset in MTM and OKT loaders (#202)",
        "commit_text": "",
        "func_before": "int fmt_okt_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t tag[8];\n\tunsigned int readflags = 0;\n\tuint16_t w; // temp for reading\n\tint plen = 0; // how many positions in the orderlist are valid\n\tint npat = 0; // next pattern to read\n\tint nsmp = 1; // next sample (data, not header)\n\tint pat, sh, sd, e; // iterators (pattern, sample header, sample data, effect warnings\n\tint nchn = 0; // how many channels does this song use?\n\tsize_t patseek[MAX_PATTERNS] = {0};\n\tsize_t smpseek[MAX_SAMPLES + 1] = {0}; // where the sample's data starts\n\tuint32_t smpsize[MAX_SAMPLES + 2] = {0}; // data size (one element bigger to simplify loop condition)\n\tuint32_t smpflag[MAX_SAMPLES + 1] = {0}; // bit width\n\tuint32_t effwarn = 0; // effect warning mask\n\n\tslurp_read(fp, tag, 8);\n\tif (memcmp(tag, \"OKTASONG\", 8) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\n\twhile (!slurp_eof(fp)) {\n\t\tuint32_t blklen; // length of this block\n\t\tsize_t nextpos; // ... and start of next one\n\n\t\tslurp_read(fp, tag, 4);\n\t\tslurp_read(fp, &blklen, 4);\n\t\tblklen = bswapBE32(blklen);\n\t\tnextpos = slurp_tell(fp) + blklen;\n\n\t\tswitch (OKT_BLOCK(tag[0], tag[1], tag[2], tag[3])) {\n\t\tcase OKT_BLK_CMOD:\n\t\t\tif (!(readflags & OKT_HAS_CMOD)) {\n\t\t\t\treadflags |= OKT_HAS_CMOD;\n\t\t\t\tnchn = okt_read_cmod(song, fp);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SAMP:\n\t\t\tif (!(readflags & OKT_HAS_SAMP)) {\n\t\t\t\treadflags |= OKT_HAS_SAMP;\n\t\t\t\tokt_read_samp(song, fp, blklen, smpflag);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SPEE:\n\t\t\tif (!(readflags & OKT_HAS_SPEE)) {\n\t\t\t\treadflags |= OKT_HAS_SPEE;\n\t\t\t\tslurp_read(fp, &w, 2);\n\t\t\t\tw = bswapBE16(w);\n\t\t\t\tsong->initial_speed = CLAMP(w, 1, 255);\n\t\t\t\tsong->initial_tempo = 125;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SLEN:\n\t\t\t// Don't care.\n\t\t\tbreak;\n\t\tcase OKT_BLK_PLEN:\n\t\t\tif (!(readflags & OKT_HAS_PLEN)) {\n\t\t\t\treadflags |= OKT_HAS_PLEN;\n\t\t\t\tslurp_read(fp, &w, 2);\n\t\t\t\tplen = bswapBE16(w);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_PATT:\n\t\t\tif (!(readflags & OKT_HAS_PATT)) {\n\t\t\t\treadflags |= OKT_HAS_PATT;\n\t\t\t\tslurp_read(fp, song->orderlist, MIN(blklen, MAX_ORDERS));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_PBOD:\n\t\t\t/* Need the channel count (in CMOD) in order to read these */\n\t\t\tif (npat < MAX_PATTERNS) {\n\t\t\t\tif (blklen > 0)\n\t\t\t\t\tpatseek[npat] = slurp_tell(fp);\n\t\t\t\tnpat++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SBOD:\n\t\t\tif (nsmp < MAX_SAMPLES) {\n\t\t\t\tsmpseek[nsmp] = slurp_tell(fp);\n\t\t\t\tsmpsize[nsmp] = blklen;\n\t\t\t\tif (smpsize[nsmp])\n\t\t\t\t\tnsmp++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t//log_appendf(4, \" Warning: Unknown block of type '%c%c%c%c' at 0x%lx\",\n\t\t\t//        tag[0], tag[1], tag[2], tag[3], fp->pos - 8);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (slurp_seek(fp, nextpos, SEEK_SET) != 0) {\n\t\t\tlog_appendf(4, \" Warning: Failed to seek (file truncated?)\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((readflags & (OKT_HAS_CMOD | OKT_HAS_SPEE)) != (OKT_HAS_CMOD | OKT_HAS_SPEE))\n\t\treturn LOAD_FORMAT_ERROR;\n\n\tif (!(lflags & LOAD_NOPATTERNS)) {\n\t\tfor (pat = 0; pat < npat; pat++) {\n\t\t\tslurp_seek(fp, patseek[pat], SEEK_SET);\n\t\t\teffwarn |= okt_read_pbod(song, fp, nchn, pat);\n\t\t}\n\n\t\tif (effwarn) {\n\t\t\tif (effwarn & 1)\n\t\t\t\tlog_appendf(4, \" Warning: Out-of-range effects (junk data?)\");\n\t\t\tfor (e = 2; e <= 32; e++) {\n\t\t\t\tif (effwarn & (1 << (e - 1))) {\n\t\t\t\t\tlog_appendf(4, \" Warning: Unimplemented effect %cxx\",\n\t\t\t\t\t\te + (e < 10 ? '0' : ('A' - 10)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (sh = sd = 1; sh < MAX_SAMPLES && smpsize[sd]; sh++) {\n\t\t\tsong_sample_t *ssmp = song->samples + sh;\n\t\t\tif (!ssmp->length)\n\t\t\t\tcontinue;\n\n\t\t\tif (ssmp->length != smpsize[sd]) {\n\t\t\t\tlog_appendf(4, \" Warning: Sample %d: header/data size mismatch (%d/%d)\", sh,\n\t\t\t\t\tssmp->length, smpsize[sd]);\n\t\t\t\tssmp->length = MIN(smpsize[sd], ssmp->length);\n\t\t\t}\n\n\t\t\tcsf_read_sample(ssmp, SF_BE | SF_M | SF_PCMS | smpflag[sd],\n\t\t\t\t\tfp->data + smpseek[sd], ssmp->length);\n\t\t\tsd++;\n\t\t}\n\t\t// Make sure there's nothing weird going on\n\t\tfor (; sh < MAX_SAMPLES; sh++) {\n\t\t\tif (song->samples[sh].length) {\n\t\t\t\tlog_appendf(4, \" Warning: Sample %d: file truncated\", sh);\n\t\t\t\tsong->samples[sh].length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tsong->pan_separation = 64;\n\tmemset(song->orderlist + plen, ORDER_LAST, MAX_ORDERS - plen);\n\tstrcpy(song->tracker_id, \"Amiga Oktalyzer\");\n\n\treturn LOAD_SUCCESS;\n}",
        "func": "int fmt_okt_load_song(song_t *song, slurp_t *fp, unsigned int lflags)\n{\n\tuint8_t tag[8];\n\tunsigned int readflags = 0;\n\tuint16_t w; // temp for reading\n\tint plen = 0; // how many positions in the orderlist are valid\n\tint npat = 0; // next pattern to read\n\tint nsmp = 1; // next sample (data, not header)\n\tint pat, sh, sd, e; // iterators (pattern, sample header, sample data, effect warnings\n\tint nchn = 0; // how many channels does this song use?\n\tsize_t patseek[MAX_PATTERNS] = {0};\n\tsize_t smpseek[MAX_SAMPLES + 1] = {0}; // where the sample's data starts\n\tuint32_t smpsize[MAX_SAMPLES + 2] = {0}; // data size (one element bigger to simplify loop condition)\n\tuint32_t smpflag[MAX_SAMPLES + 1] = {0}; // bit width\n\tuint32_t effwarn = 0; // effect warning mask\n\n\tslurp_read(fp, tag, 8);\n\tif (memcmp(tag, \"OKTASONG\", 8) != 0)\n\t\treturn LOAD_UNSUPPORTED;\n\n\twhile (!slurp_eof(fp)) {\n\t\tuint32_t blklen; // length of this block\n\t\tsize_t nextpos; // ... and start of next one\n\n\t\tslurp_read(fp, tag, 4);\n\t\tslurp_read(fp, &blklen, 4);\n\t\tblklen = bswapBE32(blklen);\n\t\tnextpos = slurp_tell(fp) + blklen;\n\n\t\tswitch (OKT_BLOCK(tag[0], tag[1], tag[2], tag[3])) {\n\t\tcase OKT_BLK_CMOD:\n\t\t\tif (!(readflags & OKT_HAS_CMOD)) {\n\t\t\t\treadflags |= OKT_HAS_CMOD;\n\t\t\t\tnchn = okt_read_cmod(song, fp);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SAMP:\n\t\t\tif (!(readflags & OKT_HAS_SAMP)) {\n\t\t\t\treadflags |= OKT_HAS_SAMP;\n\t\t\t\tokt_read_samp(song, fp, blklen, smpflag);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SPEE:\n\t\t\tif (!(readflags & OKT_HAS_SPEE)) {\n\t\t\t\treadflags |= OKT_HAS_SPEE;\n\t\t\t\tslurp_read(fp, &w, 2);\n\t\t\t\tw = bswapBE16(w);\n\t\t\t\tsong->initial_speed = CLAMP(w, 1, 255);\n\t\t\t\tsong->initial_tempo = 125;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SLEN:\n\t\t\t// Don't care.\n\t\t\tbreak;\n\t\tcase OKT_BLK_PLEN:\n\t\t\tif (!(readflags & OKT_HAS_PLEN)) {\n\t\t\t\treadflags |= OKT_HAS_PLEN;\n\t\t\t\tslurp_read(fp, &w, 2);\n\t\t\t\tplen = bswapBE16(w);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_PATT:\n\t\t\tif (!(readflags & OKT_HAS_PATT)) {\n\t\t\t\treadflags |= OKT_HAS_PATT;\n\t\t\t\tslurp_read(fp, song->orderlist, MIN(blklen, MAX_ORDERS));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_PBOD:\n\t\t\t/* Need the channel count (in CMOD) in order to read these */\n\t\t\tif (npat < MAX_PATTERNS) {\n\t\t\t\tif (blklen > 0)\n\t\t\t\t\tpatseek[npat] = slurp_tell(fp);\n\t\t\t\tnpat++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OKT_BLK_SBOD:\n\t\t\tif (nsmp < MAX_SAMPLES) {\n\t\t\t\tsmpseek[nsmp] = slurp_tell(fp);\n\t\t\t\tsmpsize[nsmp] = blklen;\n\t\t\t\tif (smpsize[nsmp])\n\t\t\t\t\tnsmp++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t//log_appendf(4, \" Warning: Unknown block of type '%c%c%c%c' at 0x%lx\",\n\t\t\t//        tag[0], tag[1], tag[2], tag[3], fp->pos - 8);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (slurp_seek(fp, nextpos, SEEK_SET) != 0) {\n\t\t\tlog_appendf(4, \" Warning: Failed to seek (file truncated?)\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((readflags & (OKT_HAS_CMOD | OKT_HAS_SPEE)) != (OKT_HAS_CMOD | OKT_HAS_SPEE))\n\t\treturn LOAD_FORMAT_ERROR;\n\n\tif (!(lflags & LOAD_NOPATTERNS)) {\n\t\tfor (pat = 0; pat < npat; pat++) {\n\t\t\tslurp_seek(fp, patseek[pat], SEEK_SET);\n\t\t\teffwarn |= okt_read_pbod(song, fp, nchn, pat);\n\t\t}\n\n\t\tif (effwarn) {\n\t\t\tif (effwarn & 1)\n\t\t\t\tlog_appendf(4, \" Warning: Out-of-range effects (junk data?)\");\n\t\t\tfor (e = 2; e <= 32; e++) {\n\t\t\t\tif (effwarn & (1 << (e - 1))) {\n\t\t\t\t\tlog_appendf(4, \" Warning: Unimplemented effect %cxx\",\n\t\t\t\t\t\te + (e < 10 ? '0' : ('A' - 10)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(lflags & LOAD_NOSAMPLES)) {\n\t\tfor (sh = sd = 1; sh < MAX_SAMPLES && smpsize[sd]; sh++) {\n\t\t\tsong_sample_t *ssmp = song->samples + sh;\n\t\t\tif (!ssmp->length)\n\t\t\t\tcontinue;\n\n\t\t\tif (ssmp->length != smpsize[sd]) {\n\t\t\t\tlog_appendf(4, \" Warning: Sample %d: header/data size mismatch (%d/%d)\", sh,\n\t\t\t\t\tssmp->length, smpsize[sd]);\n\t\t\t\tssmp->length = MIN(smpsize[sd], ssmp->length);\n\t\t\t}\n\n\t\t\tcsf_read_sample(ssmp, SF_BE | SF_M | SF_PCMS | smpflag[sd],\n\t\t\t\t\tfp->data + smpseek[sd], ssmp->length);\n\t\t\tsd++;\n\t\t}\n\t\t// Make sure there's nothing weird going on\n\t\tfor (; sh < MAX_SAMPLES; sh++) {\n\t\t\tif (song->samples[sh].length) {\n\t\t\t\tlog_appendf(4, \" Warning: Sample %d: file truncated\", sh);\n\t\t\t\tsong->samples[sh].length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tsong->pan_separation = 64;\n\tmemset(song->orderlist + plen, ORDER_LAST, MAX(0, MAX_ORDERS - plen));\n\tstrcpy(song->tracker_id, \"Amiga Oktalyzer\");\n\n\treturn LOAD_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -141,7 +141,7 @@\n \t}\n \n \tsong->pan_separation = 64;\n-\tmemset(song->orderlist + plen, ORDER_LAST, MAX_ORDERS - plen);\n+\tmemset(song->orderlist + plen, ORDER_LAST, MAX(0, MAX_ORDERS - plen));\n \tstrcpy(song->tracker_id, \"Amiga Oktalyzer\");\n \n \treturn LOAD_SUCCESS;",
        "diff_line_info": {
            "deleted_lines": [
                "\tmemset(song->orderlist + plen, ORDER_LAST, MAX_ORDERS - plen);"
            ],
            "added_lines": [
                "\tmemset(song->orderlist + plen, ORDER_LAST, MAX(0, MAX_ORDERS - plen));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0185",
        "func_name": "torvalds/linux/legacy_parse_param",
        "description": "A heap-based buffer overflow flaw was found in the way the legacy_parse_param function in the Filesystem Context functionality of the Linux kernel verified the supplied parameters length. An unprivileged (in case of unprivileged user namespaces enabled, otherwise needs namespaced CAP_SYS_ADMIN privilege) local user able to open a filesystem that does not support the Filesystem Context API (and thus fallbacks to legacy handling) could use this flaw to escalate their privileges on the system.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=722d94847de2",
        "commit_title": "The \"PAGE_SIZE - 2 - size\" calculation in legacy_parse_param() is an",
        "commit_text": "unsigned type so a large value of \"size\" results in a high positive value instead of a negative value as expected.  Fix this by getting rid of the subtraction.  ",
        "func_before": "static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tunsigned int size = ctx->data_size;\n\tsize_t len = 0;\n\tint ret;\n\n\tret = vfs_parse_fs_param_source(fc, param);\n\tif (ret != -ENOPARAM)\n\t\treturn ret;\n\n\tif (ctx->param_type == LEGACY_FS_MONOLITHIC_PARAMS)\n\t\treturn invalf(fc, \"VFS: Legacy: Can't mix monolithic and individual options\");\n\n\tswitch (param->type) {\n\tcase fs_value_is_string:\n\t\tlen = 1 + param->size;\n\t\tfallthrough;\n\tcase fs_value_is_flag:\n\t\tlen += strlen(param->key);\n\t\tbreak;\n\tdefault:\n\t\treturn invalf(fc, \"VFS: Legacy: Parameter type for '%s' not supported\",\n\t\t\t      param->key);\n\t}\n\n\tif (len > PAGE_SIZE - 2 - size)\n\t\treturn invalf(fc, \"VFS: Legacy: Cumulative options too large\");\n\tif (strchr(param->key, ',') ||\n\t    (param->type == fs_value_is_string &&\n\t     memchr(param->string, ',', param->size)))\n\t\treturn invalf(fc, \"VFS: Legacy: Option '%s' contained comma\",\n\t\t\t      param->key);\n\tif (!ctx->legacy_data) {\n\t\tctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\t\tif (!ctx->legacy_data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tctx->legacy_data[size++] = ',';\n\tlen = strlen(param->key);\n\tmemcpy(ctx->legacy_data + size, param->key, len);\n\tsize += len;\n\tif (param->type == fs_value_is_string) {\n\t\tctx->legacy_data[size++] = '=';\n\t\tmemcpy(ctx->legacy_data + size, param->string, param->size);\n\t\tsize += param->size;\n\t}\n\tctx->legacy_data[size] = '\\0';\n\tctx->data_size = size;\n\tctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS;\n\treturn 0;\n}",
        "func": "static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tunsigned int size = ctx->data_size;\n\tsize_t len = 0;\n\tint ret;\n\n\tret = vfs_parse_fs_param_source(fc, param);\n\tif (ret != -ENOPARAM)\n\t\treturn ret;\n\n\tif (ctx->param_type == LEGACY_FS_MONOLITHIC_PARAMS)\n\t\treturn invalf(fc, \"VFS: Legacy: Can't mix monolithic and individual options\");\n\n\tswitch (param->type) {\n\tcase fs_value_is_string:\n\t\tlen = 1 + param->size;\n\t\tfallthrough;\n\tcase fs_value_is_flag:\n\t\tlen += strlen(param->key);\n\t\tbreak;\n\tdefault:\n\t\treturn invalf(fc, \"VFS: Legacy: Parameter type for '%s' not supported\",\n\t\t\t      param->key);\n\t}\n\n\tif (size + len + 2 > PAGE_SIZE)\n\t\treturn invalf(fc, \"VFS: Legacy: Cumulative options too large\");\n\tif (strchr(param->key, ',') ||\n\t    (param->type == fs_value_is_string &&\n\t     memchr(param->string, ',', param->size)))\n\t\treturn invalf(fc, \"VFS: Legacy: Option '%s' contained comma\",\n\t\t\t      param->key);\n\tif (!ctx->legacy_data) {\n\t\tctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\t\tif (!ctx->legacy_data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tctx->legacy_data[size++] = ',';\n\tlen = strlen(param->key);\n\tmemcpy(ctx->legacy_data + size, param->key, len);\n\tsize += len;\n\tif (param->type == fs_value_is_string) {\n\t\tctx->legacy_data[size++] = '=';\n\t\tmemcpy(ctx->legacy_data + size, param->string, param->size);\n\t\tsize += param->size;\n\t}\n\tctx->legacy_data[size] = '\\0';\n\tctx->data_size = size;\n\tctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n \t\t\t      param->key);\n \t}\n \n-\tif (len > PAGE_SIZE - 2 - size)\n+\tif (size + len + 2 > PAGE_SIZE)\n \t\treturn invalf(fc, \"VFS: Legacy: Cumulative options too large\");\n \tif (strchr(param->key, ',') ||\n \t    (param->type == fs_value_is_string &&",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (len > PAGE_SIZE - 2 - size)"
            ],
            "added_lines": [
                "\tif (size + len + 2 > PAGE_SIZE)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3165",
        "func_name": "qemu-project/qemu/protocol_client_msg",
        "description": "An integer underflow issue was found in the QEMU VNC server while processing ClientCutText messages in the extended format. A malicious client could use this flaw to make QEMU unresponsive by sending a specially crafted payload message, resulting in a denial of service.",
        "git_url": "https://gitlab.com/qemu-project/qemu/-/commit/d307040b18bfcb1393b910f1bae753d5c12a4dc7",
        "commit_title": "ui/vnc-clipboard: fix integer underflow in vnc_client_cut_text_ext",
        "commit_text": " Extended ClientCutText messages start with a 4-byte header. If len < 4, an integer underflow occurs in vnc_client_cut_text_ext. The result is used to decompress data in a while loop in inflate_buffer, leading to CPU consumption and denial of service. Prevent this by checking dlen in protocol_client_msg.  Message-Id: <20220925204511.1103214-1-mcascell@redhat.com> ",
        "func_before": "static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    uint32_t freq;\n    VncDisplay *vd = vs->vd;\n\n    if (data[0] > 3) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit > 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i < limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1) {\n            return 8;\n        }\n        if (len == 8) {\n            uint32_t dlen = abs(read_s32(data, 4));\n            if (dlen > (1 << 20)) {\n                error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n                             \" which exceeds our limit of 1MB.\", dlen);\n                vnc_client_error(vs);\n                break;\n            }\n            if (dlen > 0) {\n                return 8 + dlen;\n            }\n        }\n\n        if (read_s32(data, 4) < 0) {\n            vnc_client_cut_text_ext(vs, abs(read_s32(data, 4)),\n                                    read_u32(data, 8), data + 12);\n            break;\n        }\n        vnc_client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_XVP:\n        if (!(vs->features & VNC_FEATURE_XVP)) {\n            error_report(\"vnc: xvp client message while disabled\");\n            vnc_client_error(vs);\n            break;\n        }\n        if (len == 1) {\n            return 4;\n        }\n        if (len == 4) {\n            uint8_t version = read_u8(data, 2);\n            uint8_t action = read_u8(data, 3);\n\n            if (version != 1) {\n                error_report(\"vnc: xvp client message version %d != 1\",\n                             version);\n                vnc_client_error(vs);\n                break;\n            }\n\n            switch (action) {\n            case VNC_XVP_ACTION_SHUTDOWN:\n                qemu_system_powerdown_request();\n                break;\n            case VNC_XVP_ACTION_REBOOT:\n                send_xvp_message(vs, VNC_XVP_CODE_FAIL);\n                break;\n            case VNC_XVP_ACTION_RESET:\n                qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);\n                break;\n            default:\n                send_xvp_message(vs, VNC_XVP_CODE_FAIL);\n                break;\n            }\n        }\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                trace_vnc_msg_client_audio_enable(vs, vs->ioc);\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                trace_vnc_msg_client_audio_disable(vs, vs->ioc);\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs->as.fmt = AUDIO_FORMAT_U8; break;\n                case 1: vs->as.fmt = AUDIO_FORMAT_S8; break;\n                case 2: vs->as.fmt = AUDIO_FORMAT_U16; break;\n                case 3: vs->as.fmt = AUDIO_FORMAT_S16; break;\n                case 4: vs->as.fmt = AUDIO_FORMAT_U32; break;\n                case 5: vs->as.fmt = AUDIO_FORMAT_S32; break;\n                default:\n                    VNC_DEBUG(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.nchannels = read_u8(data, 5);\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                    VNC_DEBUG(\"Invalid audio channel count %d\\n\",\n                              read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                freq = read_u32(data, 6);\n                /* No official limit for protocol, but 48khz is a sensible\n                 * upper bound for trustworthy clients, and this limit\n                 * protects calculations involving 'vs->as.freq' later.\n                 */\n                if (freq > 48000) {\n                    VNC_DEBUG(\"Invalid audio frequency %u > 48000\", freq);\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.freq = freq;\n                trace_vnc_msg_client_audio_format(\n                    vs, vs->ioc, vs->as.fmt, vs->as.nchannels, vs->as.freq);\n                break;\n            default:\n                VNC_DEBUG(\"Invalid audio message %d\\n\", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            VNC_DEBUG(\"Msg: %d\\n\", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    case VNC_MSG_CLIENT_SET_DESKTOP_SIZE:\n    {\n        size_t size;\n        uint8_t screens;\n        int w, h;\n\n        if (len < 8) {\n            return 8;\n        }\n\n        screens = read_u8(data, 6);\n        size    = 8 + screens * 16;\n        if (len < size) {\n            return size;\n        }\n        w = read_u16(data, 2);\n        h = read_u16(data, 4);\n\n        trace_vnc_msg_client_set_desktop_size(vs, vs->ioc, w, h, screens);\n        if (dpy_ui_info_supported(vs->vd->dcl.con)) {\n            QemuUIInfo info;\n            memset(&info, 0, sizeof(info));\n            info.width = w;\n            info.height = h;\n            dpy_set_ui_info(vs->vd->dcl.con, &info, false);\n            vnc_desktop_resize_ext(vs, 4 /* Request forwarded */);\n        } else {\n            vnc_desktop_resize_ext(vs, 3 /* Invalid screen layout */);\n        }\n\n        break;\n    }\n    default:\n        VNC_DEBUG(\"Msg: %d\\n\", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_update_throttle_offset(vs);\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}",
        "func": "static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    uint32_t freq;\n    VncDisplay *vd = vs->vd;\n\n    if (data[0] > 3) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit > 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i < limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1) {\n            return 8;\n        }\n        uint32_t dlen = abs(read_s32(data, 4));\n        if (len == 8) {\n            if (dlen > (1 << 20)) {\n                error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n                             \" which exceeds our limit of 1MB.\", dlen);\n                vnc_client_error(vs);\n                break;\n            }\n            if (dlen > 0) {\n                return 8 + dlen;\n            }\n        }\n\n        if (read_s32(data, 4) < 0) {\n            if (dlen < 4) {\n                error_report(\"vnc: malformed payload (header less than 4 bytes)\"\n                             \" in extended clipboard pseudo-encoding.\");\n                vnc_client_error(vs);\n                break;\n            }\n            vnc_client_cut_text_ext(vs, dlen, read_u32(data, 8), data + 12);\n            break;\n        }\n        vnc_client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_XVP:\n        if (!(vs->features & VNC_FEATURE_XVP)) {\n            error_report(\"vnc: xvp client message while disabled\");\n            vnc_client_error(vs);\n            break;\n        }\n        if (len == 1) {\n            return 4;\n        }\n        if (len == 4) {\n            uint8_t version = read_u8(data, 2);\n            uint8_t action = read_u8(data, 3);\n\n            if (version != 1) {\n                error_report(\"vnc: xvp client message version %d != 1\",\n                             version);\n                vnc_client_error(vs);\n                break;\n            }\n\n            switch (action) {\n            case VNC_XVP_ACTION_SHUTDOWN:\n                qemu_system_powerdown_request();\n                break;\n            case VNC_XVP_ACTION_REBOOT:\n                send_xvp_message(vs, VNC_XVP_CODE_FAIL);\n                break;\n            case VNC_XVP_ACTION_RESET:\n                qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);\n                break;\n            default:\n                send_xvp_message(vs, VNC_XVP_CODE_FAIL);\n                break;\n            }\n        }\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                trace_vnc_msg_client_audio_enable(vs, vs->ioc);\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                trace_vnc_msg_client_audio_disable(vs, vs->ioc);\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs->as.fmt = AUDIO_FORMAT_U8; break;\n                case 1: vs->as.fmt = AUDIO_FORMAT_S8; break;\n                case 2: vs->as.fmt = AUDIO_FORMAT_U16; break;\n                case 3: vs->as.fmt = AUDIO_FORMAT_S16; break;\n                case 4: vs->as.fmt = AUDIO_FORMAT_U32; break;\n                case 5: vs->as.fmt = AUDIO_FORMAT_S32; break;\n                default:\n                    VNC_DEBUG(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.nchannels = read_u8(data, 5);\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                    VNC_DEBUG(\"Invalid audio channel count %d\\n\",\n                              read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                freq = read_u32(data, 6);\n                /* No official limit for protocol, but 48khz is a sensible\n                 * upper bound for trustworthy clients, and this limit\n                 * protects calculations involving 'vs->as.freq' later.\n                 */\n                if (freq > 48000) {\n                    VNC_DEBUG(\"Invalid audio frequency %u > 48000\", freq);\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.freq = freq;\n                trace_vnc_msg_client_audio_format(\n                    vs, vs->ioc, vs->as.fmt, vs->as.nchannels, vs->as.freq);\n                break;\n            default:\n                VNC_DEBUG(\"Invalid audio message %d\\n\", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            VNC_DEBUG(\"Msg: %d\\n\", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    case VNC_MSG_CLIENT_SET_DESKTOP_SIZE:\n    {\n        size_t size;\n        uint8_t screens;\n        int w, h;\n\n        if (len < 8) {\n            return 8;\n        }\n\n        screens = read_u8(data, 6);\n        size    = 8 + screens * 16;\n        if (len < size) {\n            return size;\n        }\n        w = read_u16(data, 2);\n        h = read_u16(data, 4);\n\n        trace_vnc_msg_client_set_desktop_size(vs, vs->ioc, w, h, screens);\n        if (dpy_ui_info_supported(vs->vd->dcl.con)) {\n            QemuUIInfo info;\n            memset(&info, 0, sizeof(info));\n            info.width = w;\n            info.height = h;\n            dpy_set_ui_info(vs->vd->dcl.con, &info, false);\n            vnc_desktop_resize_ext(vs, 4 /* Request forwarded */);\n        } else {\n            vnc_desktop_resize_ext(vs, 3 /* Invalid screen layout */);\n        }\n\n        break;\n    }\n    default:\n        VNC_DEBUG(\"Msg: %d\\n\", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_update_throttle_offset(vs);\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,8 +62,8 @@\n         if (len == 1) {\n             return 8;\n         }\n+        uint32_t dlen = abs(read_s32(data, 4));\n         if (len == 8) {\n-            uint32_t dlen = abs(read_s32(data, 4));\n             if (dlen > (1 << 20)) {\n                 error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n                              \" which exceeds our limit of 1MB.\", dlen);\n@@ -76,8 +76,13 @@\n         }\n \n         if (read_s32(data, 4) < 0) {\n-            vnc_client_cut_text_ext(vs, abs(read_s32(data, 4)),\n-                                    read_u32(data, 8), data + 12);\n+            if (dlen < 4) {\n+                error_report(\"vnc: malformed payload (header less than 4 bytes)\"\n+                             \" in extended clipboard pseudo-encoding.\");\n+                vnc_client_error(vs);\n+                break;\n+            }\n+            vnc_client_cut_text_ext(vs, dlen, read_u32(data, 8), data + 12);\n             break;\n         }\n         vnc_client_cut_text(vs, read_u32(data, 4), data + 8);",
        "diff_line_info": {
            "deleted_lines": [
                "            uint32_t dlen = abs(read_s32(data, 4));",
                "            vnc_client_cut_text_ext(vs, abs(read_s32(data, 4)),",
                "                                    read_u32(data, 8), data + 12);"
            ],
            "added_lines": [
                "        uint32_t dlen = abs(read_s32(data, 4));",
                "            if (dlen < 4) {",
                "                error_report(\"vnc: malformed payload (header less than 4 bytes)\"",
                "                             \" in extended clipboard pseudo-encoding.\");",
                "                vnc_client_error(vs);",
                "                break;",
                "            }",
                "            vnc_client_cut_text_ext(vs, dlen, read_u32(data, 8), data + 12);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15900",
        "func_name": "ArtifexSoftware/ghostpdl/search_impl",
        "description": "A memory corruption issue was found in Artifex Ghostscript 9.50 and 9.52. Use of a non-standard PostScript operator can allow overriding of file access controls. The 'rsearch' calculation for the 'post' size resulted in a size that was too large, and could underflow to max uint32_t. This was fixed in commit 5d499272b95a6b890a1397e11d20937de000d31b.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b",
        "commit_title": "Bug 702582, CVE 2020-15900 Memory Corruption in Ghostscript 9.52",
        "commit_text": " Fix the 'rsearch' calculation for the 'post' size to give the correct size.  Previous calculation would result in a size that was too large, and could underflow to max uint32_t. Also fix 'rsearch' to return the correct 'pre' string with empty string match.  A future change may 'undefine' this undocumented, non-standard operator during initialization as we do with the many other non-standard internal PostScript operators and procedures.",
        "func_before": "static int\nsearch_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t/* can't match */\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    /* No match */\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}",
        "func": "static int\nsearch_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t/* can't match */\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    /* No match */\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\t\t\t\t/* match */\n    op->tas.rsize = size;\t\t\t\t/* match */\n    push(2);\n    op[-1] = *op1;\t\t\t\t\t/* pre */\n    op[-3].value.bytes = ptr + size;\t\t\t/* post */\n    if (forward) {\n        op[-1].tas.rsize = ptr - op[-1].value.bytes;\t/* pre */\n        op[-3].tas.rsize = count;\t\t\t/* post */\n    } else {\n        op[-1].tas.rsize = count;\t\t\t/* pre */\n        op[-3].tas.rsize -= count + size;\t\t/* post */\n    }\n    make_true(op);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,13 +35,18 @@\n     return 0;\n found:\n     op->tas.type_attrs = op1->tas.type_attrs;\n-    op->value.bytes = ptr;\n-    r_set_size(op, size);\n+    op->value.bytes = ptr;\t\t\t\t/* match */\n+    op->tas.rsize = size;\t\t\t\t/* match */\n     push(2);\n-    op[-1] = *op1;\n-    r_set_size(op - 1, ptr - op[-1].value.bytes);\n-    op1->value.bytes = ptr + size;\n-    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n+    op[-1] = *op1;\t\t\t\t\t/* pre */\n+    op[-3].value.bytes = ptr + size;\t\t\t/* post */\n+    if (forward) {\n+        op[-1].tas.rsize = ptr - op[-1].value.bytes;\t/* pre */\n+        op[-3].tas.rsize = count;\t\t\t/* post */\n+    } else {\n+        op[-1].tas.rsize = count;\t\t\t/* pre */\n+        op[-3].tas.rsize -= count + size;\t\t/* post */\n+    }\n     make_true(op);\n     return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    op->value.bytes = ptr;",
                "    r_set_size(op, size);",
                "    op[-1] = *op1;",
                "    r_set_size(op - 1, ptr - op[-1].value.bytes);",
                "    op1->value.bytes = ptr + size;",
                "    r_set_size(op1, count + (!forward ? (size - 1) : 0));"
            ],
            "added_lines": [
                "    op->value.bytes = ptr;\t\t\t\t/* match */",
                "    op->tas.rsize = size;\t\t\t\t/* match */",
                "    op[-1] = *op1;\t\t\t\t\t/* pre */",
                "    op[-3].value.bytes = ptr + size;\t\t\t/* post */",
                "    if (forward) {",
                "        op[-1].tas.rsize = ptr - op[-1].value.bytes;\t/* pre */",
                "        op[-3].tas.rsize = count;\t\t\t/* post */",
                "    } else {",
                "        op[-1].tas.rsize = count;\t\t\t/* pre */",
                "        op[-3].tas.rsize -= count + size;\t\t/* post */",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24370",
        "func_name": "lua/luaG_findlocal",
        "description": "ldebug.c in Lua 5.4.0 allows a negation overflow and segmentation fault in getlocal and setlocal, as demonstrated by getlocal(3,2^31).",
        "git_url": "https://github.com/lua/lua/commit/a585eae6e7ada1ca9271607a4f48dfb17868ab7b",
        "commit_title": "Fixed bug: Negation overflow in getlocal/setlocal",
        "commit_text": "",
        "func_before": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}",
        "func": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n   const char *name = NULL;\n   if (isLua(ci)) {\n     if (n < 0)  /* access to vararg values? */\n-      return findvararg(ci, -n, pos);\n+      return findvararg(ci, n, pos);\n     else\n       name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "      return findvararg(ci, -n, pos);"
            ],
            "added_lines": [
                "      return findvararg(ci, n, pos);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24370",
        "func_name": "lua/findvararg",
        "description": "ldebug.c in Lua 5.4.0 allows a negation overflow and segmentation fault in getlocal and setlocal, as demonstrated by getlocal(3,2^31).",
        "git_url": "https://github.com/lua/lua/commit/a585eae6e7ada1ca9271607a4f48dfb17868ab7b",
        "commit_title": "Fixed bug: Negation overflow in getlocal/setlocal",
        "commit_text": "",
        "func_before": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}",
        "func": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n >= -nextra) {  /* 'n' is negative */\n      *pos = ci->func - nextra - (n + 1);\n      return \"(vararg)\";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,8 @@\n static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n   if (clLvalue(s2v(ci->func))->p->is_vararg) {\n     int nextra = ci->u.l.nextraargs;\n-    if (n <= nextra) {\n-      *pos = ci->func - nextra + (n - 1);\n+    if (n >= -nextra) {  /* 'n' is negative */\n+      *pos = ci->func - nextra - (n + 1);\n       return \"(vararg)\";  /* generic name for any vararg */\n     }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (n <= nextra) {",
                "      *pos = ci->func - nextra + (n - 1);"
            ],
            "added_lines": [
                "    if (n >= -nextra) {  /* 'n' is negative */",
                "      *pos = ci->func - nextra - (n + 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15158",
        "func_name": "mz-automation/libiec61850/CotpConnection_readToTpktBuffer",
        "description": "In libIEC61850 before version 1.4.3, when a message with COTP message length field with value < 4 is received an integer underflow will happen leading to heap buffer overflow. This can cause an application crash or on some platforms even the execution of remote code. If your application is used in open networks or there are untrusted nodes in the network it is highly recommend to apply the patch. This was patched with commit 033ab5b. Users of version 1.4.x should upgrade to version 1.4.3 when available. As a workaround changes of commit 033ab5b can be applied to older versions.",
        "git_url": "https://github.com/mz-automation/libiec61850/commit/033ab5b6488250c8c3b838f25a7cbc3e099230bb",
        "commit_title": "- COTP: fixed possible heap buffer overflow when handling message with invalid (zero) value in length field (#250)",
        "commit_text": "",
        "func_before": "TpktState\nCotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n\n    assert (bufferSize > 4);\n\n    int readBytes;\n\n    if (bufPos < 4) {\n\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n\n        if (readBytes < 0)\n            goto exit_closed;\n\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n\n        bufPos += readBytes;\n\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n\n    if (readBytes < 0)\n        goto exit_closed;\n\n    bufPos += readBytes;\n\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\n\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\n\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\n\nexit_waiting:\n\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}",
        "func": "TpktState\nCotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n\n    assert (bufferSize > 4);\n\n    int readBytes;\n\n    if (bufPos < 4) {\n\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n\n        if (readBytes < 0)\n            goto exit_closed;\n\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n\n        bufPos += readBytes;\n\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n\n    if (self->packetSize <= bufPos)\n        goto exit_error;\n\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n\n    if (readBytes < 0)\n        goto exit_closed;\n\n    bufPos += readBytes;\n\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\n\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\n\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\n\nexit_waiting:\n\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,6 +44,9 @@\n             goto exit_waiting;\n     }\n \n+    if (self->packetSize <= bufPos)\n+        goto exit_error;\n+\n     readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n \n     if (readBytes < 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (self->packetSize <= bufPos)",
                "        goto exit_error;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-38427",
        "func_name": "torvalds/linux/deassemble_neg_contexts",
        "description": "An issue was discovered in the Linux kernel before 6.3.8. fs/smb/server/smb2pdu.c in ksmbd has an integer underflow and out-of-bounds read in deassemble_neg_contexts.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/smb/server?h=f1a411873c85b642f13b01f21b534c2bab81fc1b",
        "commit_title": "The check in the beginning is",
        "commit_text": "`clen + sizeof(struct smb2_neg_context) <= len_of_ctxts`, but in the end of loop, `len_of_ctxts` will subtract `((clen + 7) & ~0x7) + sizeof(struct smb2_neg_context)`, which causes integer underflow when clen does the 8 alignment. We should use `(clen + 7) & ~0x7` in the check to avoid underflow from happening.  Then there are some variables that need to be declared unsigned instead of signed.  [   11.671070] BUG: KASAN: slab-out-of-bounds in smb2_handle_negotiate+0x799/0x1610 [   11.671533] Read of size 2 at addr ffff888005e86cf2 by task kworker/0:0/7 ... [   11.673383] Call Trace: [   11.673541]  <TASK> [   11.673679]  dump_stack_lvl+0x33/0x50 [   11.673913]  print_report+0xcc/0x620 [   11.674671]  kasan_report+0xae/0xe0 [   11.675171]  kasan_check_range+0x35/0x1b0 [   11.675412]  smb2_handle_negotiate+0x799/0x1610 [   11.676217]  ksmbd_smb_negotiate_common+0x526/0x770 [   11.676795]  handle_ksmbd_work+0x274/0x810 ...  Cc: stable@vger.kernel.org ",
        "func_before": "static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tint offset = le32_to_cpu(req->NegotiateContextOffset);\n\tint neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen, ctxt_len;\n\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tctxt_len = clen + sizeof(struct smb2_neg_context);\n\n\t\tif (ctxt_len > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx,\n\t\t\t\t\t\t     ctxt_len);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    ctxt_len);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     ctxt_len);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset = clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen + sizeof(struct smb2_neg_context);\n\t}\n\treturn status;\n}",
        "func": "static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      unsigned int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tunsigned int offset = le32_to_cpu(req->NegotiateContextOffset);\n\tunsigned int neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen, ctxt_len;\n\n\t\tif (len_of_ctxts < (int)sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tctxt_len = clen + sizeof(struct smb2_neg_context);\n\n\t\tif (ctxt_len > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx,\n\t\t\t\t\t\t     ctxt_len);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    ctxt_len);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     ctxt_len);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\toffset = (ctxt_len + 7) & ~0x7;\n\t\tlen_of_ctxts -= offset;\n\t}\n\treturn status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,12 @@\n static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n \t\t\t\t      struct smb2_negotiate_req *req,\n-\t\t\t\t      int len_of_smb)\n+\t\t\t\t      unsigned int len_of_smb)\n {\n \t/* +4 is to account for the RFC1001 len field */\n \tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n \tint i = 0, len_of_ctxts;\n-\tint offset = le32_to_cpu(req->NegotiateContextOffset);\n-\tint neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n+\tunsigned int offset = le32_to_cpu(req->NegotiateContextOffset);\n+\tunsigned int neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n \t__le32 status = STATUS_INVALID_PARAMETER;\n \n \tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n@@ -20,7 +20,7 @@\n \twhile (i++ < neg_ctxt_cnt) {\n \t\tint clen, ctxt_len;\n \n-\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n+\t\tif (len_of_ctxts < (int)sizeof(struct smb2_neg_context))\n \t\t\tbreak;\n \n \t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n@@ -75,9 +75,8 @@\n \t\t}\n \n \t\t/* offsets must be 8 byte aligned */\n-\t\tclen = (clen + 7) & ~0x7;\n-\t\toffset = clen + sizeof(struct smb2_neg_context);\n-\t\tlen_of_ctxts -= clen + sizeof(struct smb2_neg_context);\n+\t\toffset = (ctxt_len + 7) & ~0x7;\n+\t\tlen_of_ctxts -= offset;\n \t}\n \treturn status;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t      int len_of_smb)",
                "\tint offset = le32_to_cpu(req->NegotiateContextOffset);",
                "\tint neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);",
                "\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))",
                "\t\tclen = (clen + 7) & ~0x7;",
                "\t\toffset = clen + sizeof(struct smb2_neg_context);",
                "\t\tlen_of_ctxts -= clen + sizeof(struct smb2_neg_context);"
            ],
            "added_lines": [
                "\t\t\t\t      unsigned int len_of_smb)",
                "\tunsigned int offset = le32_to_cpu(req->NegotiateContextOffset);",
                "\tunsigned int neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);",
                "\t\tif (len_of_ctxts < (int)sizeof(struct smb2_neg_context))",
                "\t\toffset = (ctxt_len + 7) & ~0x7;",
                "\t\tlen_of_ctxts -= offset;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2497",
        "func_name": "torvalds/linux/l2cap_config_req",
        "description": "Integer underflow in the l2cap_config_req function in net/bluetooth/l2cap_core.c in the Linux kernel before 3.0 allows remote attackers to cause a denial of service (heap memory corruption) or possibly have unspecified other impact via a small command-size value within the command header of a Logical Link Control and Adaptation Protocol (L2CAP) configuration request, leading to a buffer overflow.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=7ac28817536797fd40e9646452183606f9e17f71",
        "commit_title": "A remote user can provide a small value for the command size field in",
        "commit_text": "the command header of an l2cap configuration request, resulting in an integer underflow when subtracting the size of the configuration request header.  This results in copying a very large amount of data via memcpy() and destroying the kernel heap.  Check for underflow.  Cc: stable <stable@kernel.org> ",
        "func_before": "static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct l2cap_chan *chan;\n\tstruct sock *sk;\n\tint len;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tchan = l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan)\n\t\treturn -ENOENT;\n\n\tsk = chan->sk;\n\n\tif (sk->sk_state != BT_CONFIG) {\n\t\tstruct l2cap_cmd_rej rej;\n\n\t\trej.reason = cpu_to_le16(0x0002);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,\n\t\t\t\tsizeof(rej), &rej);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(chan, rsp,\n\t\t\t\t\tL2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(chan->conf_req + chan->conf_len, req->data, len);\n\tchan->conf_len += len;\n\n\tif (flags & 0x0001) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(chan, rsp,\n\t\t\t\t\tL2CAP_CONF_SUCCESS, 0x0001), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(chan, rsp);\n\tif (len < 0) {\n\t\tl2cap_send_disconn_req(conn, chan, ECONNRESET);\n\t\tgoto unlock;\n\t}\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tchan->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tchan->conf_len = 0;\n\n\tif (!(chan->conf_state & L2CAP_CONF_OUTPUT_DONE))\n\t\tgoto unlock;\n\n\tif (chan->conf_state & L2CAP_CONF_INPUT_DONE) {\n\t\tset_default_fcs(chan);\n\n\t\tsk->sk_state = BT_CONNECTED;\n\n\t\tchan->next_tx_seq = 0;\n\t\tchan->expected_tx_seq = 0;\n\t\tskb_queue_head_init(&chan->tx_q);\n\t\tif (chan->mode == L2CAP_MODE_ERTM)\n\t\t\tl2cap_ertm_init(chan);\n\n\t\tl2cap_chan_ready(sk);\n\t\tgoto unlock;\n\t}\n\n\tif (!(chan->conf_state & L2CAP_CONF_REQ_SENT)) {\n\t\tu8 buf[64];\n\t\tchan->conf_state |= L2CAP_CONF_REQ_SENT;\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\tl2cap_build_conf_req(chan, buf), buf);\n\t\tchan->num_conf_req++;\n\t}\n\nunlock:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}",
        "func": "static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct l2cap_chan *chan;\n\tstruct sock *sk;\n\tint len;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tchan = l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan)\n\t\treturn -ENOENT;\n\n\tsk = chan->sk;\n\n\tif (sk->sk_state != BT_CONFIG) {\n\t\tstruct l2cap_cmd_rej rej;\n\n\t\trej.reason = cpu_to_le16(0x0002);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,\n\t\t\t\tsizeof(rej), &rej);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (len < 0 || chan->conf_len + len > sizeof(chan->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(chan, rsp,\n\t\t\t\t\tL2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(chan->conf_req + chan->conf_len, req->data, len);\n\tchan->conf_len += len;\n\n\tif (flags & 0x0001) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t\tl2cap_build_conf_rsp(chan, rsp,\n\t\t\t\t\tL2CAP_CONF_SUCCESS, 0x0001), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(chan, rsp);\n\tif (len < 0) {\n\t\tl2cap_send_disconn_req(conn, chan, ECONNRESET);\n\t\tgoto unlock;\n\t}\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tchan->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tchan->conf_len = 0;\n\n\tif (!(chan->conf_state & L2CAP_CONF_OUTPUT_DONE))\n\t\tgoto unlock;\n\n\tif (chan->conf_state & L2CAP_CONF_INPUT_DONE) {\n\t\tset_default_fcs(chan);\n\n\t\tsk->sk_state = BT_CONNECTED;\n\n\t\tchan->next_tx_seq = 0;\n\t\tchan->expected_tx_seq = 0;\n\t\tskb_queue_head_init(&chan->tx_q);\n\t\tif (chan->mode == L2CAP_MODE_ERTM)\n\t\t\tl2cap_ertm_init(chan);\n\n\t\tl2cap_chan_ready(sk);\n\t\tgoto unlock;\n\t}\n\n\tif (!(chan->conf_state & L2CAP_CONF_REQ_SENT)) {\n\t\tu8 buf[64];\n\t\tchan->conf_state |= L2CAP_CONF_REQ_SENT;\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\tl2cap_build_conf_req(chan, buf), buf);\n\t\tchan->num_conf_req++;\n\t}\n\nunlock:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n \n \t/* Reject if config buffer is too small. */\n \tlen = cmd_len - sizeof(*req);\n-\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n+\tif (len < 0 || chan->conf_len + len > sizeof(chan->conf_req)) {\n \t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n \t\t\t\tl2cap_build_conf_rsp(chan, rsp,\n \t\t\t\t\tL2CAP_CONF_REJECT, flags), rsp);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (chan->conf_len + len > sizeof(chan->conf_req)) {"
            ],
            "added_lines": [
                "\tif (len < 0 || chan->conf_len + len > sizeof(chan->conf_req)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1208",
        "func_name": "ffmpeg/mov_read_default",
        "description": "Integer underflow in the mov_read_default function in libavformat/mov.c in FFmpeg before 2.4.6 allows remote attackers to obtain sensitive information from heap and/or stack memory via a crafted MP4 file.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=3ebd76a9c57558e284e94da367dd23b435e6a6d0",
        "commit_title": "",
        "commit_text": "mov: Fix negative size calculation in mov_read_default().  The previous code assumed if an atom was marked with a 64-bit size extension, it actually had that data available. The new code verfies there's enough data in the atom for this to be done.  Failure to verify causes total_size > atom.size which will result in negative size calculations later on.  ",
        "func_before": "static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t total_size = 0;\n    MOVAtom a;\n    int i;\n\n    if (c->atom_depth > 10) {\n        av_log(c->fc, AV_LOG_ERROR, \"Atoms too deeply nested\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    c->atom_depth ++;\n\n    if (atom.size < 0)\n        atom.size = INT64_MAX;\n    while (total_size + 8 <= atom.size && !avio_feof(pb)) {\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n        a.size = atom.size;\n        a.type=0;\n        if (atom.size >= 8) {\n            a.size = avio_rb32(pb);\n            a.type = avio_rl32(pb);\n            if (a.type == MKTAG('f','r','e','e') &&\n                a.size >= 8 &&\n                c->moov_retry) {\n                uint8_t buf[8];\n                uint32_t *type = (uint32_t *)buf + 1;\n                avio_read(pb, buf, 8);\n                avio_seek(pb, -8, SEEK_CUR);\n                if (*type == MKTAG('m','v','h','d') ||\n                    *type == MKTAG('c','m','o','v')) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free atom.\\n\");\n                    a.type = MKTAG('m','o','o','v');\n                }\n            }\n            if (atom.type != MKTAG('r','o','o','t') &&\n                atom.type != MKTAG('m','o','o','v'))\n            {\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n                {\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n                    avio_skip(pb, -8);\n                    c->atom_depth --;\n                    return 0;\n                }\n            }\n            total_size += 8;\n            if (a.size == 1) { /* 64 bit extended size */\n                a.size = avio_rb64(pb) - 8;\n                total_size += 8;\n            }\n        }\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n        if (a.size == 0) {\n            a.size = atom.size - total_size + 8;\n        }\n        a.size -= 8;\n        if (a.size < 0)\n            break;\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n            if (mov_default_parse_table[i].type == a.type) {\n                parse = mov_default_parse_table[i].parse;\n                break;\n            }\n\n        // container is user data\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n                       atom.type == MKTAG('i','l','s','t')))\n            parse = mov_read_udta_string;\n\n        if (!parse) { /* skip leaf atoms data */\n            avio_skip(pb, a.size);\n        } else {\n            int64_t start_pos = avio_tell(pb);\n            int64_t left;\n            int err = parse(c, pb, a);\n            if (err < 0) {\n                c->atom_depth --;\n                return err;\n            }\n            if (c->found_moov && c->found_mdat &&\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n                 start_pos + a.size == avio_size(pb))) {\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n                    c->next_root_atom = start_pos + a.size;\n                c->atom_depth --;\n                return 0;\n            }\n            left = a.size - avio_tell(pb) + start_pos;\n            if (left > 0) /* skip garbage at atom end */\n                avio_skip(pb, left);\n            else if (left < 0) {\n                av_log(c->fc, AV_LOG_WARNING,\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n                       (char*)&a.type, -left);\n                avio_seek(pb, left, SEEK_CUR);\n            }\n        }\n\n        total_size += a.size;\n    }\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n        avio_skip(pb, atom.size - total_size);\n\n    c->atom_depth --;\n    return 0;\n}",
        "func": "static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t total_size = 0;\n    MOVAtom a;\n    int i;\n\n    if (c->atom_depth > 10) {\n        av_log(c->fc, AV_LOG_ERROR, \"Atoms too deeply nested\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    c->atom_depth ++;\n\n    if (atom.size < 0)\n        atom.size = INT64_MAX;\n    while (total_size + 8 <= atom.size && !avio_feof(pb)) {\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n        a.size = atom.size;\n        a.type=0;\n        if (atom.size >= 8) {\n            a.size = avio_rb32(pb);\n            a.type = avio_rl32(pb);\n            if (a.type == MKTAG('f','r','e','e') &&\n                a.size >= 8 &&\n                c->moov_retry) {\n                uint8_t buf[8];\n                uint32_t *type = (uint32_t *)buf + 1;\n                avio_read(pb, buf, 8);\n                avio_seek(pb, -8, SEEK_CUR);\n                if (*type == MKTAG('m','v','h','d') ||\n                    *type == MKTAG('c','m','o','v')) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free atom.\\n\");\n                    a.type = MKTAG('m','o','o','v');\n                }\n            }\n            if (atom.type != MKTAG('r','o','o','t') &&\n                atom.type != MKTAG('m','o','o','v'))\n            {\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n                {\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n                    avio_skip(pb, -8);\n                    c->atom_depth --;\n                    return 0;\n                }\n            }\n            total_size += 8;\n            if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */\n                a.size = avio_rb64(pb) - 8;\n                total_size += 8;\n            }\n        }\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n        if (a.size == 0) {\n            a.size = atom.size - total_size + 8;\n        }\n        a.size -= 8;\n        if (a.size < 0)\n            break;\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n            if (mov_default_parse_table[i].type == a.type) {\n                parse = mov_default_parse_table[i].parse;\n                break;\n            }\n\n        // container is user data\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n                       atom.type == MKTAG('i','l','s','t')))\n            parse = mov_read_udta_string;\n\n        if (!parse) { /* skip leaf atoms data */\n            avio_skip(pb, a.size);\n        } else {\n            int64_t start_pos = avio_tell(pb);\n            int64_t left;\n            int err = parse(c, pb, a);\n            if (err < 0) {\n                c->atom_depth --;\n                return err;\n            }\n            if (c->found_moov && c->found_mdat &&\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n                 start_pos + a.size == avio_size(pb))) {\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n                    c->next_root_atom = start_pos + a.size;\n                c->atom_depth --;\n                return 0;\n            }\n            left = a.size - avio_tell(pb) + start_pos;\n            if (left > 0) /* skip garbage at atom end */\n                avio_skip(pb, left);\n            else if (left < 0) {\n                av_log(c->fc, AV_LOG_WARNING,\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n                       (char*)&a.type, -left);\n                avio_seek(pb, left, SEEK_CUR);\n            }\n        }\n\n        total_size += a.size;\n    }\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n        avio_skip(pb, atom.size - total_size);\n\n    c->atom_depth --;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,7 +44,7 @@\n                 }\n             }\n             total_size += 8;\n-            if (a.size == 1) { /* 64 bit extended size */\n+            if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */\n                 a.size = avio_rb64(pb) - 8;\n                 total_size += 8;\n             }",
        "diff_line_info": {
            "deleted_lines": [
                "            if (a.size == 1) { /* 64 bit extended size */"
            ],
            "added_lines": [
                "            if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2497",
        "func_name": "freetype/freetype2/gray_render_cubic",
        "description": "Integer underflow in glyph handling in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.",
        "git_url": "http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=7d3d2cc4fef72c6be9c454b3809c387e12b44cfc",
        "commit_title": "* src/cff/cffgload.c (cff_decoder_parse_charstrings)",
        "commit_text": "<cff_op_callothersubr>: Protect against stack underflow. ",
        "func_before": "static void\n  gray_render_cubic( RAS_ARG_ const FT_Vector*  control1,\n                              const FT_Vector*  control2,\n                              const FT_Vector*  to )\n  {\n    TPos        dx, dy, da, db;\n    int         top, level;\n    int*        levels;\n    FT_Vector*  arc;\n\n\n    dx = DOWNSCALE( ras.x ) + to->x - ( control1->x << 1 );\n    if ( dx < 0 )\n      dx = -dx;\n    dy = DOWNSCALE( ras.y ) + to->y - ( control1->y << 1 );\n    if ( dy < 0 )\n      dy = -dy;\n    if ( dx < dy )\n      dx = dy;\n    da = dx;\n\n    dx = DOWNSCALE( ras.x ) + to->x - 3 * ( control1->x + control2->x );\n    if ( dx < 0 )\n      dx = -dx;\n    dy = DOWNSCALE( ras.y ) + to->y - 3 * ( control1->x + control2->y );\n    if ( dy < 0 )\n      dy = -dy;\n    if ( dx < dy )\n      dx = dy;\n    db = dx;\n\n    level = 1;\n    da    = da / ras.cubic_level;\n    db    = db / ras.conic_level;\n    while ( da > 0 || db > 0 )\n    {\n      da >>= 2;\n      db >>= 3;\n      level++;\n    }\n\n    if ( level <= 1 )\n    {\n      TPos   to_x, to_y, mid_x, mid_y;\n\n\n      to_x  = UPSCALE( to->x );\n      to_y  = UPSCALE( to->y );\n      mid_x = ( ras.x + to_x +\n                3 * UPSCALE( control1->x + control2->x ) ) / 8;\n      mid_y = ( ras.y + to_y +\n                3 * UPSCALE( control1->y + control2->y ) ) / 8;\n\n      gray_render_line( RAS_VAR_ mid_x, mid_y );\n      gray_render_line( RAS_VAR_ to_x, to_y );\n      return;\n    }\n\n    arc      = ras.bez_stack;\n    arc[0].x = UPSCALE( to->x );\n    arc[0].y = UPSCALE( to->y );\n    arc[1].x = UPSCALE( control2->x );\n    arc[1].y = UPSCALE( control2->y );\n    arc[2].x = UPSCALE( control1->x );\n    arc[2].y = UPSCALE( control1->y );\n    arc[3].x = ras.x;\n    arc[3].y = ras.y;\n\n    levels    = ras.lev_stack;\n    top       = 0;\n    levels[0] = level;\n\n    while ( top >= 0 )\n    {\n      level = levels[top];\n      if ( level > 1 )\n      {\n        /* check that the arc crosses the current band */\n        TPos  min, max, y;\n\n\n        min = max = arc[0].y;\n        y = arc[1].y;\n        if ( y < min ) min = y;\n        if ( y > max ) max = y;\n        y = arc[2].y;\n        if ( y < min ) min = y;\n        if ( y > max ) max = y;\n        y = arc[3].y;\n        if ( y < min ) min = y;\n        if ( y > max ) max = y;\n        if ( TRUNC( min ) >= ras.max_ey || TRUNC( max ) < 0 )\n          goto Draw;\n        gray_split_cubic( arc );\n        arc += 3;\n        top ++;\n        levels[top] = levels[top - 1] = level - 1;\n        continue;\n      }\n\n    Draw:\n      {\n        TPos  to_x, to_y, mid_x, mid_y;\n\n\n        to_x  = arc[0].x;\n        to_y  = arc[0].y;\n        mid_x = ( ras.x + to_x + 3 * ( arc[1].x + arc[2].x ) ) / 8;\n        mid_y = ( ras.y + to_y + 3 * ( arc[1].y + arc[2].y ) ) / 8;\n\n        gray_render_line( RAS_VAR_ mid_x, mid_y );\n        gray_render_line( RAS_VAR_ to_x, to_y );\n        top --;\n        arc -= 3;\n      }\n    }\n\n    return;\n  }",
        "func": "static void\n  gray_render_cubic( RAS_ARG_ const FT_Vector*  control1,\n                              const FT_Vector*  control2,\n                              const FT_Vector*  to )\n  {\n    TPos        dx, dy;\n    TPos        mid_x, mid_y;\n    int         top, level;\n    int*        levels;\n    FT_Vector*  arc;\n\n\n    /* Calculate midpoint and compare it with start and end. */\n    mid_x = ( DOWNSCALE( ras.x ) + to->x +\n              3 * ( control1->x + control2->x ) ) / 8;\n    mid_y = ( DOWNSCALE( ras.y ) + to->y +\n              3 * ( control1->y + control2->y ) ) / 8;\n\n    dx = DOWNSCALE( ras.x ) + to->x - ( mid_x << 1 );\n    if ( dx < 0 )\n      dx = -dx;\n    dy = DOWNSCALE( ras.y ) + to->y - ( mid_y << 1 );\n    if ( dy < 0 )\n      dy = -dy;\n    if ( dx < dy )\n      dx = dy;\n\n    /* Check whether an approximation with straight lines is sufficient. */\n    level = 1;\n    dx    = dx / ras.conic_level;\n    while ( dx > 0 )\n    {\n      dx >>= 3;\n      level++;\n    }\n\n    if ( level <= 1 )\n    {\n      TPos   to_x, to_y;\n\n\n      to_x  = UPSCALE( to->x );\n      to_y  = UPSCALE( to->y );\n      mid_x = ( ras.x + to_x +\n                3 * UPSCALE( control1->x + control2->x ) ) / 8;\n      mid_y = ( ras.y + to_y +\n                3 * UPSCALE( control1->y + control2->y ) ) / 8;\n\n      gray_render_line( RAS_VAR_ mid_x, mid_y );\n      gray_render_line( RAS_VAR_ to_x, to_y );\n      return;\n    }\n\n    arc      = ras.bez_stack;\n    arc[0].x = UPSCALE( to->x );\n    arc[0].y = UPSCALE( to->y );\n    arc[1].x = UPSCALE( control2->x );\n    arc[1].y = UPSCALE( control2->y );\n    arc[2].x = UPSCALE( control1->x );\n    arc[2].y = UPSCALE( control1->y );\n    arc[3].x = ras.x;\n    arc[3].y = ras.y;\n\n    levels    = ras.lev_stack;\n    top       = 0;\n    levels[0] = level;\n\n    while ( top >= 0 )\n    {\n      level = levels[top];\n      if ( level > 1 )\n      {\n        /* check that the arc crosses the current band */\n        TPos  min, max, y;\n\n\n        min = max = arc[0].y;\n        y = arc[1].y;\n        if ( y < min ) min = y;\n        if ( y > max ) max = y;\n        y = arc[2].y;\n        if ( y < min ) min = y;\n        if ( y > max ) max = y;\n        y = arc[3].y;\n        if ( y < min ) min = y;\n        if ( y > max ) max = y;\n        if ( TRUNC( min ) >= ras.max_ey || TRUNC( max ) < 0 )\n          goto Draw;\n        gray_split_cubic( arc );\n        arc += 3;\n        top ++;\n        levels[top] = levels[top - 1] = level - 1;\n        continue;\n      }\n\n    Draw:\n      {\n        TPos  to_x, to_y;\n\n\n        to_x  = arc[0].x;\n        to_y  = arc[0].y;\n        mid_x = ( ras.x + to_x + 3 * ( arc[1].x + arc[2].x ) ) / 8;\n        mid_y = ( ras.y + to_y + 3 * ( arc[1].y + arc[2].y ) ) / 8;\n\n        gray_render_line( RAS_VAR_ mid_x, mid_y );\n        gray_render_line( RAS_VAR_ to_x, to_y );\n        top --;\n        arc -= 3;\n      }\n    }\n\n    return;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,45 +3,40 @@\n                               const FT_Vector*  control2,\n                               const FT_Vector*  to )\n   {\n-    TPos        dx, dy, da, db;\n+    TPos        dx, dy;\n+    TPos        mid_x, mid_y;\n     int         top, level;\n     int*        levels;\n     FT_Vector*  arc;\n \n \n-    dx = DOWNSCALE( ras.x ) + to->x - ( control1->x << 1 );\n+    /* Calculate midpoint and compare it with start and end. */\n+    mid_x = ( DOWNSCALE( ras.x ) + to->x +\n+              3 * ( control1->x + control2->x ) ) / 8;\n+    mid_y = ( DOWNSCALE( ras.y ) + to->y +\n+              3 * ( control1->y + control2->y ) ) / 8;\n+\n+    dx = DOWNSCALE( ras.x ) + to->x - ( mid_x << 1 );\n     if ( dx < 0 )\n       dx = -dx;\n-    dy = DOWNSCALE( ras.y ) + to->y - ( control1->y << 1 );\n+    dy = DOWNSCALE( ras.y ) + to->y - ( mid_y << 1 );\n     if ( dy < 0 )\n       dy = -dy;\n     if ( dx < dy )\n       dx = dy;\n-    da = dx;\n \n-    dx = DOWNSCALE( ras.x ) + to->x - 3 * ( control1->x + control2->x );\n-    if ( dx < 0 )\n-      dx = -dx;\n-    dy = DOWNSCALE( ras.y ) + to->y - 3 * ( control1->x + control2->y );\n-    if ( dy < 0 )\n-      dy = -dy;\n-    if ( dx < dy )\n-      dx = dy;\n-    db = dx;\n-\n+    /* Check whether an approximation with straight lines is sufficient. */\n     level = 1;\n-    da    = da / ras.cubic_level;\n-    db    = db / ras.conic_level;\n-    while ( da > 0 || db > 0 )\n+    dx    = dx / ras.conic_level;\n+    while ( dx > 0 )\n     {\n-      da >>= 2;\n-      db >>= 3;\n+      dx >>= 3;\n       level++;\n     }\n \n     if ( level <= 1 )\n     {\n-      TPos   to_x, to_y, mid_x, mid_y;\n+      TPos   to_x, to_y;\n \n \n       to_x  = UPSCALE( to->x );\n@@ -100,7 +95,7 @@\n \n     Draw:\n       {\n-        TPos  to_x, to_y, mid_x, mid_y;\n+        TPos  to_x, to_y;\n \n \n         to_x  = arc[0].x;",
        "diff_line_info": {
            "deleted_lines": [
                "    TPos        dx, dy, da, db;",
                "    dx = DOWNSCALE( ras.x ) + to->x - ( control1->x << 1 );",
                "    dy = DOWNSCALE( ras.y ) + to->y - ( control1->y << 1 );",
                "    da = dx;",
                "    dx = DOWNSCALE( ras.x ) + to->x - 3 * ( control1->x + control2->x );",
                "    if ( dx < 0 )",
                "      dx = -dx;",
                "    dy = DOWNSCALE( ras.y ) + to->y - 3 * ( control1->x + control2->y );",
                "    if ( dy < 0 )",
                "      dy = -dy;",
                "    if ( dx < dy )",
                "      dx = dy;",
                "    db = dx;",
                "",
                "    da    = da / ras.cubic_level;",
                "    db    = db / ras.conic_level;",
                "    while ( da > 0 || db > 0 )",
                "      da >>= 2;",
                "      db >>= 3;",
                "      TPos   to_x, to_y, mid_x, mid_y;",
                "        TPos  to_x, to_y, mid_x, mid_y;"
            ],
            "added_lines": [
                "    TPos        dx, dy;",
                "    TPos        mid_x, mid_y;",
                "    /* Calculate midpoint and compare it with start and end. */",
                "    mid_x = ( DOWNSCALE( ras.x ) + to->x +",
                "              3 * ( control1->x + control2->x ) ) / 8;",
                "    mid_y = ( DOWNSCALE( ras.y ) + to->y +",
                "              3 * ( control1->y + control2->y ) ) / 8;",
                "",
                "    dx = DOWNSCALE( ras.x ) + to->x - ( mid_x << 1 );",
                "    dy = DOWNSCALE( ras.y ) + to->y - ( mid_y << 1 );",
                "    /* Check whether an approximation with straight lines is sufficient. */",
                "    dx    = dx / ras.conic_level;",
                "    while ( dx > 0 )",
                "      dx >>= 3;",
                "      TPos   to_x, to_y;",
                "        TPos  to_x, to_y;"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4164",
        "func_name": "torvalds/linux/x25_parse_facilities",
        "description": "Multiple integer underflows in the x25_parse_facilities function in net/x25/x25_facilities.c in the Linux kernel before 2.6.36.2 allow remote attackers to cause a denial of service (system crash) via malformed X.25 (1) X25_FAC_CLASS_A, (2) X25_FAC_CLASS_B, (3) X25_FAC_CLASS_C, or (4) X25_FAC_CLASS_D facility data, a different vulnerability than CVE-2010-3873.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=5ef41308f94dcbb3b7afc56cdef1c2ba53fa5d2f",
        "commit_title": "Now with improved comma support.",
        "commit_text": " On parsing malformed X.25 facilities, decrementing the remaining length may cause it to underflow.  Since the length is an unsigned integer, this will result in the loop continuing until the kernel crashes.  This patch adds checks to ensure decrementing the remaining length does not cause it to wrap around.  ",
        "func_before": "int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,\n\t\tstruct x25_dte_facilities *dte_facs, unsigned long *vc_fac_mask)\n{\n\tunsigned char *p = skb->data;\n\tunsigned int len;\n\n\t*vc_fac_mask = 0;\n\n\t/*\n\t * The kernel knows which facilities were set on an incoming call but\n\t * currently this information is not available to userspace.  Here we\n\t * give userspace who read incoming call facilities 0 length to indicate\n\t * it wasn't set.\n\t */\n\tdte_facs->calling_len = 0;\n\tdte_facs->called_len = 0;\n\tmemset(dte_facs->called_ae, '\\0', sizeof(dte_facs->called_ae));\n\tmemset(dte_facs->calling_ae, '\\0', sizeof(dte_facs->calling_ae));\n\n\tif (skb->len < 1)\n\t\treturn 0;\n\n\tlen = *p++;\n\n\tif (len >= skb->len)\n\t\treturn -1;\n\n\twhile (len > 0) {\n\t\tswitch (*p & X25_FAC_CLASS_MASK) {\n\t\tcase X25_FAC_CLASS_A:\n\t\t\tswitch (*p) {\n\t\t\tcase X25_FAC_REVERSE:\n\t\t\t\tif((p[1] & 0x81) == 0x81) {\n\t\t\t\t\tfacilities->reverse = p[1] & 0x81;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif((p[1] & 0x01) == 0x01) {\n\t\t\t\t\tfacilities->reverse = p[1] & 0x01;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif((p[1] & 0x80) == 0x80) {\n\t\t\t\t\tfacilities->reverse = p[1] & 0x80;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(p[1] == 0x00) {\n\t\t\t\t\tfacilities->reverse\n\t\t\t\t\t\t= X25_DEFAULT_REVERSE;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase X25_FAC_THROUGHPUT:\n\t\t\t\tfacilities->throughput = p[1];\n\t\t\t\t*vc_fac_mask |= X25_MASK_THROUGHPUT;\n\t\t\t\tbreak;\n\t\t\tcase X25_MARKER:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility \"\n\t\t\t\t       \"%02X, value %02X\\n\",\n\t\t\t\t       p[0], p[1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\t\tcase X25_FAC_CLASS_B:\n\t\t\tswitch (*p) {\n\t\t\tcase X25_FAC_PACKET_SIZE:\n\t\t\t\tfacilities->pacsize_in  = p[1];\n\t\t\t\tfacilities->pacsize_out = p[2];\n\t\t\t\t*vc_fac_mask |= X25_MASK_PACKET_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase X25_FAC_WINDOW_SIZE:\n\t\t\t\tfacilities->winsize_in  = p[1];\n\t\t\t\tfacilities->winsize_out = p[2];\n\t\t\t\t*vc_fac_mask |= X25_MASK_WINDOW_SIZE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility \"\n\t\t\t\t       \"%02X, values %02X, %02X\\n\",\n\t\t\t\t       p[0], p[1], p[2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\t\tcase X25_FAC_CLASS_C:\n\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility %02X, \"\n\t\t\t       \"values %02X, %02X, %02X\\n\",\n\t\t\t       p[0], p[1], p[2], p[3]);\n\t\t\tp   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\t\tcase X25_FAC_CLASS_D:\n\t\t\tswitch (*p) {\n\t\t\tcase X25_FAC_CALLING_AE:\n\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tdte_facs->calling_len = p[2];\n\t\t\t\tmemcpy(dte_facs->calling_ae, &p[3], p[1] - 1);\n\t\t\t\t*vc_fac_mask |= X25_MASK_CALLING_AE;\n\t\t\t\tbreak;\n\t\t\tcase X25_FAC_CALLED_AE:\n\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tdte_facs->called_len = p[2];\n\t\t\t\tmemcpy(dte_facs->called_ae, &p[3], p[1] - 1);\n\t\t\t\t*vc_fac_mask |= X25_MASK_CALLED_AE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility %02X,\"\n\t\t\t\t\t\"length %d, values %02X, %02X, \"\n\t\t\t\t\t\"%02X, %02X\\n\",\n\t\t\t\t\tp[0], p[1], p[2], p[3], p[4], p[5]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= p[1] + 2;\n\t\t\tp += p[1] + 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn p - skb->data;\n}",
        "func": "int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,\n\t\tstruct x25_dte_facilities *dte_facs, unsigned long *vc_fac_mask)\n{\n\tunsigned char *p = skb->data;\n\tunsigned int len;\n\n\t*vc_fac_mask = 0;\n\n\t/*\n\t * The kernel knows which facilities were set on an incoming call but\n\t * currently this information is not available to userspace.  Here we\n\t * give userspace who read incoming call facilities 0 length to indicate\n\t * it wasn't set.\n\t */\n\tdte_facs->calling_len = 0;\n\tdte_facs->called_len = 0;\n\tmemset(dte_facs->called_ae, '\\0', sizeof(dte_facs->called_ae));\n\tmemset(dte_facs->calling_ae, '\\0', sizeof(dte_facs->calling_ae));\n\n\tif (skb->len < 1)\n\t\treturn 0;\n\n\tlen = *p++;\n\n\tif (len >= skb->len)\n\t\treturn -1;\n\n\twhile (len > 0) {\n\t\tswitch (*p & X25_FAC_CLASS_MASK) {\n\t\tcase X25_FAC_CLASS_A:\n\t\t\tif (len < 2)\n\t\t\t\treturn 0;\n\t\t\tswitch (*p) {\n\t\t\tcase X25_FAC_REVERSE:\n\t\t\t\tif((p[1] & 0x81) == 0x81) {\n\t\t\t\t\tfacilities->reverse = p[1] & 0x81;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif((p[1] & 0x01) == 0x01) {\n\t\t\t\t\tfacilities->reverse = p[1] & 0x01;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif((p[1] & 0x80) == 0x80) {\n\t\t\t\t\tfacilities->reverse = p[1] & 0x80;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(p[1] == 0x00) {\n\t\t\t\t\tfacilities->reverse\n\t\t\t\t\t\t= X25_DEFAULT_REVERSE;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase X25_FAC_THROUGHPUT:\n\t\t\t\tfacilities->throughput = p[1];\n\t\t\t\t*vc_fac_mask |= X25_MASK_THROUGHPUT;\n\t\t\t\tbreak;\n\t\t\tcase X25_MARKER:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility \"\n\t\t\t\t       \"%02X, value %02X\\n\",\n\t\t\t\t       p[0], p[1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\t\tcase X25_FAC_CLASS_B:\n\t\t\tif (len < 3)\n\t\t\t\treturn 0;\n\t\t\tswitch (*p) {\n\t\t\tcase X25_FAC_PACKET_SIZE:\n\t\t\t\tfacilities->pacsize_in  = p[1];\n\t\t\t\tfacilities->pacsize_out = p[2];\n\t\t\t\t*vc_fac_mask |= X25_MASK_PACKET_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase X25_FAC_WINDOW_SIZE:\n\t\t\t\tfacilities->winsize_in  = p[1];\n\t\t\t\tfacilities->winsize_out = p[2];\n\t\t\t\t*vc_fac_mask |= X25_MASK_WINDOW_SIZE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility \"\n\t\t\t\t       \"%02X, values %02X, %02X\\n\",\n\t\t\t\t       p[0], p[1], p[2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\t\tcase X25_FAC_CLASS_C:\n\t\t\tif (len < 4)\n\t\t\t\treturn 0;\n\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility %02X, \"\n\t\t\t       \"values %02X, %02X, %02X\\n\",\n\t\t\t       p[0], p[1], p[2], p[3]);\n\t\t\tp   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\t\tcase X25_FAC_CLASS_D:\n\t\t\tif (len < p[1] + 2)\n\t\t\t\treturn 0;\n\t\t\tswitch (*p) {\n\t\t\tcase X25_FAC_CALLING_AE:\n\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tdte_facs->calling_len = p[2];\n\t\t\t\tmemcpy(dte_facs->calling_ae, &p[3], p[1] - 1);\n\t\t\t\t*vc_fac_mask |= X25_MASK_CALLING_AE;\n\t\t\t\tbreak;\n\t\t\tcase X25_FAC_CALLED_AE:\n\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tdte_facs->called_len = p[2];\n\t\t\t\tmemcpy(dte_facs->called_ae, &p[3], p[1] - 1);\n\t\t\t\t*vc_fac_mask |= X25_MASK_CALLED_AE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility %02X,\"\n\t\t\t\t\t\"length %d\\n\", p[0], p[1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= p[1] + 2;\n\t\t\tp += p[1] + 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn p - skb->data;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,8 @@\n \twhile (len > 0) {\n \t\tswitch (*p & X25_FAC_CLASS_MASK) {\n \t\tcase X25_FAC_CLASS_A:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn 0;\n \t\t\tswitch (*p) {\n \t\t\tcase X25_FAC_REVERSE:\n \t\t\t\tif((p[1] & 0x81) == 0x81) {\n@@ -71,6 +73,8 @@\n \t\t\tlen -= 2;\n \t\t\tbreak;\n \t\tcase X25_FAC_CLASS_B:\n+\t\t\tif (len < 3)\n+\t\t\t\treturn 0;\n \t\t\tswitch (*p) {\n \t\t\tcase X25_FAC_PACKET_SIZE:\n \t\t\t\tfacilities->pacsize_in  = p[1];\n@@ -92,6 +96,8 @@\n \t\t\tlen -= 3;\n \t\t\tbreak;\n \t\tcase X25_FAC_CLASS_C:\n+\t\t\tif (len < 4)\n+\t\t\t\treturn 0;\n \t\t\tprintk(KERN_DEBUG \"X.25: unknown facility %02X, \"\n \t\t\t       \"values %02X, %02X, %02X\\n\",\n \t\t\t       p[0], p[1], p[2], p[3]);\n@@ -99,6 +105,8 @@\n \t\t\tlen -= 4;\n \t\t\tbreak;\n \t\tcase X25_FAC_CLASS_D:\n+\t\t\tif (len < p[1] + 2)\n+\t\t\t\treturn 0;\n \t\t\tswitch (*p) {\n \t\t\tcase X25_FAC_CALLING_AE:\n \t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n@@ -116,9 +124,7 @@\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility %02X,\"\n-\t\t\t\t\t\"length %d, values %02X, %02X, \"\n-\t\t\t\t\t\"%02X, %02X\\n\",\n-\t\t\t\t\tp[0], p[1], p[2], p[3], p[4], p[5]);\n+\t\t\t\t\t\"length %d\\n\", p[0], p[1]);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tlen -= p[1] + 2;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t\"length %d, values %02X, %02X, \"",
                "\t\t\t\t\t\"%02X, %02X\\n\",",
                "\t\t\t\t\tp[0], p[1], p[2], p[3], p[4], p[5]);"
            ],
            "added_lines": [
                "\t\t\tif (len < 2)",
                "\t\t\t\treturn 0;",
                "\t\t\tif (len < 3)",
                "\t\t\t\treturn 0;",
                "\t\t\tif (len < 4)",
                "\t\t\t\treturn 0;",
                "\t\t\tif (len < p[1] + 2)",
                "\t\t\t\treturn 0;",
                "\t\t\t\t\t\"length %d\\n\", p[0], p[1]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4529",
        "func_name": "torvalds/linux/irda_getsockopt",
        "description": "Integer underflow in the irda_getsockopt function in net/irda/af_irda.c in the Linux kernel before 2.6.37 on platforms other than x86 allows local users to obtain potentially sensitive information from kernel heap memory via an IRLMP_ENUMDEVICES getsockopt call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=fdac1e0697356ac212259f2147aa60c72e334861",
        "commit_title": "If the user-provided len is less than the expected offset, the",
        "commit_text": "IRLMP_ENUMDEVICES getsockopt will do a copy_to_user() with a very large size value.  While this isn't be a security issue on x86 because it will get caught by the access_ok() check, it may leak large amounts of kernel heap on other architectures.  In any event, this patch fixes it.  ",
        "func_before": "static int irda_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct irda_device_list list;\n\tstruct irda_device_info *discoveries;\n\tstruct irda_ias_set *\tias_opt;\t/* IAS get/query params */\n\tstruct ias_object *\tias_obj;\t/* Object in IAS */\n\tstruct ias_attrib *\tias_attr;\t/* Attribute in IAS object */\n\tint daddr = DEV_ADDR_ANY;\t/* Dest address for IAS queries */\n\tint val = 0;\n\tint len = 0;\n\tint err = 0;\n\tint offset, total;\n\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\n\tif (level != SOL_IRLMP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif(len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IRLMP_ENUMDEVICES:\n\t\t/* Ask lmp for the current discovery log */\n\t\tdiscoveries = irlmp_get_discoveries(&list.len, self->mask.word,\n\t\t\t\t\t\t    self->nslots);\n\t\t/* Check if the we got some results */\n\t\tif (discoveries == NULL) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\t\t/* Didn't find any devices */\n\t\t}\n\n\t\t/* Write total list length back to client */\n\t\tif (copy_to_user(optval, &list,\n\t\t\t\t sizeof(struct irda_device_list) -\n\t\t\t\t sizeof(struct irda_device_info)))\n\t\t\terr = -EFAULT;\n\n\t\t/* Offset to first device entry */\n\t\toffset = sizeof(struct irda_device_list) -\n\t\t\tsizeof(struct irda_device_info);\n\n\t\t/* Copy the list itself - watch for overflow */\n\t\tif (list.len > 2048) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto bed;\n\t\t}\n\t\ttotal = offset + (list.len * sizeof(struct irda_device_info));\n\t\tif (total > len)\n\t\t\ttotal = len;\n\t\tif (copy_to_user(optval+offset, discoveries, total - offset))\n\t\t\terr = -EFAULT;\n\n\t\t/* Write total number of bytes used back to client */\n\t\tif (put_user(total, optlen))\n\t\t\terr = -EFAULT;\nbed:\n\t\t/* Free up our buffer */\n\t\tkfree(discoveries);\n\t\tbreak;\n\tcase IRLMP_MAX_SDU_SIZE:\n\t\tval = self->max_data_size;\n\t\tlen = sizeof(int);\n\t\tif (put_user(len, optlen)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user(optval, &val, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\tcase IRLMP_IAS_GET:\n\t\t/* The user want an object from our local IAS database.\n\t\t * We just need to query the IAS and return the value\n\t\t * that we found */\n\n\t\t/* Check that the user has allocated the right space for us */\n\t\tif (len != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, len)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the object we target.\n\t\t * If the user gives us an empty string, we use the object\n\t\t * associated with this socket. This will workaround\n\t\t * duplicated class name - Jean II */\n\t\tif(ias_opt->irda_class_name[0] == '\\0')\n\t\t\tias_obj = self->ias_obj;\n\t\telse\n\t\t\tias_obj = irias_find_object(ias_opt->irda_class_name);\n\t\tif(ias_obj == (struct ias_object *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the attribute (in the object) we target */\n\t\tias_attr = irias_find_attrib(ias_obj,\n\t\t\t\t\t     ias_opt->irda_attrib_name);\n\t\tif(ias_attr == (struct ias_attrib *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Translate from internal to user structure */\n\t\terr = irda_extract_ias_value(ias_opt, ias_attr->value);\n\t\tif(err) {\n\t\t\tkfree(ias_opt);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy reply to the user */\n\t\tif (copy_to_user(optval, ias_opt,\n\t\t\t\t sizeof(struct irda_ias_set))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Note : don't need to put optlen, we checked it */\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_IAS_QUERY:\n\t\t/* The user want an object from a remote IAS database.\n\t\t * We need to use IAP to query the remote database and\n\t\t * then wait for the answer to come back. */\n\n\t\t/* Check that the user has allocated the right space for us */\n\t\tif (len != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, len)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* At this point, there are two cases...\n\t\t * 1) the socket is connected - that's the easy case, we\n\t\t *\tjust query the device we are connected to...\n\t\t * 2) the socket is not connected - the user doesn't want\n\t\t *\tto connect and/or may not have a valid service name\n\t\t *\t(so can't create a fake connection). In this case,\n\t\t *\twe assume that the user pass us a valid destination\n\t\t *\taddress in the requesting structure...\n\t\t */\n\t\tif(self->daddr != DEV_ADDR_ANY) {\n\t\t\t/* We are connected - reuse known daddr */\n\t\t\tdaddr = self->daddr;\n\t\t} else {\n\t\t\t/* We are not connected, we must specify a valid\n\t\t\t * destination address */\n\t\t\tdaddr = ias_opt->daddr;\n\t\t\tif((!daddr) || (daddr == DEV_ADDR_ANY)) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* Check that we can proceed with IAP */\n\t\tif (self->iriap) {\n\t\t\tIRDA_WARNING(\"%s: busy with a previous query\\n\",\n\t\t\t\t     __func__);\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\n\t\t\t\t\t irda_getvalue_confirm);\n\n\t\tif (self->iriap == NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Treat unexpected wakeup as disconnect */\n\t\tself->errno = -EHOSTUNREACH;\n\n\t\t/* Query remote LM-IAS */\n\t\tiriap_getvaluebyclass_request(self->iriap,\n\t\t\t\t\t      self->saddr, daddr,\n\t\t\t\t\t      ias_opt->irda_class_name,\n\t\t\t\t\t      ias_opt->irda_attrib_name);\n\n\t\t/* Wait for answer, if not yet finished (or failed) */\n\t\tif (wait_event_interruptible(self->query_wait,\n\t\t\t\t\t     (self->iriap == NULL))) {\n\t\t\t/* pending request uses copy of ias_opt-content\n\t\t\t * we can free it regardless! */\n\t\t\tkfree(ias_opt);\n\t\t\t/* Treat signals as disconnect */\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check what happened */\n\t\tif (self->errno)\n\t\t{\n\t\t\tkfree(ias_opt);\n\t\t\t/* Requested object/attribute doesn't exist */\n\t\t\tif((self->errno == IAS_CLASS_UNKNOWN) ||\n\t\t\t   (self->errno == IAS_ATTRIB_UNKNOWN))\n\t\t\t\terr = -EADDRNOTAVAIL;\n\t\t\telse\n\t\t\t\terr = -EHOSTUNREACH;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Translate from internal to user structure */\n\t\terr = irda_extract_ias_value(ias_opt, self->ias_result);\n\t\tif (self->ias_result)\n\t\t\tirias_delete_value(self->ias_result);\n\t\tif (err) {\n\t\t\tkfree(ias_opt);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy reply to the user */\n\t\tif (copy_to_user(optval, ias_opt,\n\t\t\t\t sizeof(struct irda_ias_set))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Note : don't need to put optlen, we checked it */\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_WAITDEVICE:\n\t\t/* This function is just another way of seeing life ;-)\n\t\t * IRLMP_ENUMDEVICES assumes that you have a static network,\n\t\t * and that you just want to pick one of the devices present.\n\t\t * On the other hand, in here we assume that no device is\n\t\t * present and that at some point in the future a device will\n\t\t * come into range. When this device arrive, we just wake\n\t\t * up the caller, so that he has time to connect to it before\n\t\t * the device goes away...\n\t\t * Note : once the node has been discovered for more than a\n\t\t * few second, it won't trigger this function, unless it\n\t\t * goes away and come back changes its hint bits (so we\n\t\t * might call it IRLMP_WAITNEWDEVICE).\n\t\t */\n\n\t\t/* Check that the user is passing us an int */\n\t\tif (len != sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Get timeout in ms (max time we block the caller) */\n\t\tif (get_user(val, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Tell IrLMP we want to be notified */\n\t\tirlmp_update_client(self->ckey, self->mask.word,\n\t\t\t\t    irda_selective_discovery_indication,\n\t\t\t\t    NULL, (void *) self);\n\n\t\t/* Do some discovery (and also return cached results) */\n\t\tirlmp_discovery_request(self->nslots);\n\n\t\t/* Wait until a node is discovered */\n\t\tif (!self->cachedaddr) {\n\t\t\tIRDA_DEBUG(1, \"%s(), nothing discovered yet, going to sleep...\\n\", __func__);\n\n\t\t\t/* Set watchdog timer to expire in <val> ms. */\n\t\t\tself->errno = 0;\n\t\t\tsetup_timer(&self->watchdog, irda_discovery_timeout,\n\t\t\t\t\t(unsigned long)self);\n\t\t\tself->watchdog.expires = jiffies + (val * HZ/1000);\n\t\t\tadd_timer(&(self->watchdog));\n\n\t\t\t/* Wait for IR-LMP to call us back */\n\t\t\t__wait_event_interruptible(self->query_wait,\n\t\t\t      (self->cachedaddr != 0 || self->errno == -ETIME),\n\t\t\t\t\t\t   err);\n\n\t\t\t/* If watchdog is still activated, kill it! */\n\t\t\tif(timer_pending(&(self->watchdog)))\n\t\t\t\tdel_timer(&(self->watchdog));\n\n\t\t\tIRDA_DEBUG(1, \"%s(), ...waking up !\\n\", __func__);\n\n\t\t\tif (err != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\telse\n\t\t\tIRDA_DEBUG(1, \"%s(), found immediately !\\n\",\n\t\t\t\t   __func__);\n\n\t\t/* Tell IrLMP that we have been notified */\n\t\tirlmp_update_client(self->ckey, self->mask.word,\n\t\t\t\t    NULL, NULL, NULL);\n\n\t\t/* Check if the we got some results */\n\t\tif (!self->cachedaddr)\n\t\t\treturn -EAGAIN;\t\t/* Didn't find any devices */\n\t\tdaddr = self->cachedaddr;\n\t\t/* Cleanup */\n\t\tself->cachedaddr = 0;\n\n\t\t/* We return the daddr of the device that trigger the\n\t\t * wakeup. As irlmp pass us only the new devices, we\n\t\t * are sure that it's not an old device.\n\t\t * If the user want more details, he should query\n\t\t * the whole discovery log and pick one device...\n\t\t */\n\t\tif (put_user(daddr, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\nout:\n\n\trelease_sock(sk);\n\n\treturn err;\n}",
        "func": "static int irda_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct irda_device_list list;\n\tstruct irda_device_info *discoveries;\n\tstruct irda_ias_set *\tias_opt;\t/* IAS get/query params */\n\tstruct ias_object *\tias_obj;\t/* Object in IAS */\n\tstruct ias_attrib *\tias_attr;\t/* Attribute in IAS object */\n\tint daddr = DEV_ADDR_ANY;\t/* Dest address for IAS queries */\n\tint val = 0;\n\tint len = 0;\n\tint err = 0;\n\tint offset, total;\n\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\n\tif (level != SOL_IRLMP)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif(len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IRLMP_ENUMDEVICES:\n\n\t\t/* Offset to first device entry */\n\t\toffset = sizeof(struct irda_device_list) -\n\t\t\tsizeof(struct irda_device_info);\n\n\t\tif (len < offset) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Ask lmp for the current discovery log */\n\t\tdiscoveries = irlmp_get_discoveries(&list.len, self->mask.word,\n\t\t\t\t\t\t    self->nslots);\n\t\t/* Check if the we got some results */\n\t\tif (discoveries == NULL) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\t\t/* Didn't find any devices */\n\t\t}\n\n\t\t/* Write total list length back to client */\n\t\tif (copy_to_user(optval, &list, offset))\n\t\t\terr = -EFAULT;\n\n\t\t/* Copy the list itself - watch for overflow */\n\t\tif (list.len > 2048) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto bed;\n\t\t}\n\t\ttotal = offset + (list.len * sizeof(struct irda_device_info));\n\t\tif (total > len)\n\t\t\ttotal = len;\n\t\tif (copy_to_user(optval+offset, discoveries, total - offset))\n\t\t\terr = -EFAULT;\n\n\t\t/* Write total number of bytes used back to client */\n\t\tif (put_user(total, optlen))\n\t\t\terr = -EFAULT;\nbed:\n\t\t/* Free up our buffer */\n\t\tkfree(discoveries);\n\t\tbreak;\n\tcase IRLMP_MAX_SDU_SIZE:\n\t\tval = self->max_data_size;\n\t\tlen = sizeof(int);\n\t\tif (put_user(len, optlen)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user(optval, &val, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\tcase IRLMP_IAS_GET:\n\t\t/* The user want an object from our local IAS database.\n\t\t * We just need to query the IAS and return the value\n\t\t * that we found */\n\n\t\t/* Check that the user has allocated the right space for us */\n\t\tif (len != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, len)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the object we target.\n\t\t * If the user gives us an empty string, we use the object\n\t\t * associated with this socket. This will workaround\n\t\t * duplicated class name - Jean II */\n\t\tif(ias_opt->irda_class_name[0] == '\\0')\n\t\t\tias_obj = self->ias_obj;\n\t\telse\n\t\t\tias_obj = irias_find_object(ias_opt->irda_class_name);\n\t\tif(ias_obj == (struct ias_object *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Find the attribute (in the object) we target */\n\t\tias_attr = irias_find_attrib(ias_obj,\n\t\t\t\t\t     ias_opt->irda_attrib_name);\n\t\tif(ias_attr == (struct ias_attrib *) NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Translate from internal to user structure */\n\t\terr = irda_extract_ias_value(ias_opt, ias_attr->value);\n\t\tif(err) {\n\t\t\tkfree(ias_opt);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy reply to the user */\n\t\tif (copy_to_user(optval, ias_opt,\n\t\t\t\t sizeof(struct irda_ias_set))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Note : don't need to put optlen, we checked it */\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_IAS_QUERY:\n\t\t/* The user want an object from a remote IAS database.\n\t\t * We need to use IAP to query the remote database and\n\t\t * then wait for the answer to come back. */\n\n\t\t/* Check that the user has allocated the right space for us */\n\t\tif (len != sizeof(struct irda_ias_set)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tias_opt = kmalloc(sizeof(struct irda_ias_set), GFP_ATOMIC);\n\t\tif (ias_opt == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy query to the driver. */\n\t\tif (copy_from_user(ias_opt, optval, len)) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* At this point, there are two cases...\n\t\t * 1) the socket is connected - that's the easy case, we\n\t\t *\tjust query the device we are connected to...\n\t\t * 2) the socket is not connected - the user doesn't want\n\t\t *\tto connect and/or may not have a valid service name\n\t\t *\t(so can't create a fake connection). In this case,\n\t\t *\twe assume that the user pass us a valid destination\n\t\t *\taddress in the requesting structure...\n\t\t */\n\t\tif(self->daddr != DEV_ADDR_ANY) {\n\t\t\t/* We are connected - reuse known daddr */\n\t\t\tdaddr = self->daddr;\n\t\t} else {\n\t\t\t/* We are not connected, we must specify a valid\n\t\t\t * destination address */\n\t\t\tdaddr = ias_opt->daddr;\n\t\t\tif((!daddr) || (daddr == DEV_ADDR_ANY)) {\n\t\t\t\tkfree(ias_opt);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/* Check that we can proceed with IAP */\n\t\tif (self->iriap) {\n\t\t\tIRDA_WARNING(\"%s: busy with a previous query\\n\",\n\t\t\t\t     __func__);\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tself->iriap = iriap_open(LSAP_ANY, IAS_CLIENT, self,\n\t\t\t\t\t irda_getvalue_confirm);\n\n\t\tif (self->iriap == NULL) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Treat unexpected wakeup as disconnect */\n\t\tself->errno = -EHOSTUNREACH;\n\n\t\t/* Query remote LM-IAS */\n\t\tiriap_getvaluebyclass_request(self->iriap,\n\t\t\t\t\t      self->saddr, daddr,\n\t\t\t\t\t      ias_opt->irda_class_name,\n\t\t\t\t\t      ias_opt->irda_attrib_name);\n\n\t\t/* Wait for answer, if not yet finished (or failed) */\n\t\tif (wait_event_interruptible(self->query_wait,\n\t\t\t\t\t     (self->iriap == NULL))) {\n\t\t\t/* pending request uses copy of ias_opt-content\n\t\t\t * we can free it regardless! */\n\t\t\tkfree(ias_opt);\n\t\t\t/* Treat signals as disconnect */\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check what happened */\n\t\tif (self->errno)\n\t\t{\n\t\t\tkfree(ias_opt);\n\t\t\t/* Requested object/attribute doesn't exist */\n\t\t\tif((self->errno == IAS_CLASS_UNKNOWN) ||\n\t\t\t   (self->errno == IAS_ATTRIB_UNKNOWN))\n\t\t\t\terr = -EADDRNOTAVAIL;\n\t\t\telse\n\t\t\t\terr = -EHOSTUNREACH;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Translate from internal to user structure */\n\t\terr = irda_extract_ias_value(ias_opt, self->ias_result);\n\t\tif (self->ias_result)\n\t\t\tirias_delete_value(self->ias_result);\n\t\tif (err) {\n\t\t\tkfree(ias_opt);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Copy reply to the user */\n\t\tif (copy_to_user(optval, ias_opt,\n\t\t\t\t sizeof(struct irda_ias_set))) {\n\t\t\tkfree(ias_opt);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Note : don't need to put optlen, we checked it */\n\t\tkfree(ias_opt);\n\t\tbreak;\n\tcase IRLMP_WAITDEVICE:\n\t\t/* This function is just another way of seeing life ;-)\n\t\t * IRLMP_ENUMDEVICES assumes that you have a static network,\n\t\t * and that you just want to pick one of the devices present.\n\t\t * On the other hand, in here we assume that no device is\n\t\t * present and that at some point in the future a device will\n\t\t * come into range. When this device arrive, we just wake\n\t\t * up the caller, so that he has time to connect to it before\n\t\t * the device goes away...\n\t\t * Note : once the node has been discovered for more than a\n\t\t * few second, it won't trigger this function, unless it\n\t\t * goes away and come back changes its hint bits (so we\n\t\t * might call it IRLMP_WAITNEWDEVICE).\n\t\t */\n\n\t\t/* Check that the user is passing us an int */\n\t\tif (len != sizeof(int)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t/* Get timeout in ms (max time we block the caller) */\n\t\tif (get_user(val, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Tell IrLMP we want to be notified */\n\t\tirlmp_update_client(self->ckey, self->mask.word,\n\t\t\t\t    irda_selective_discovery_indication,\n\t\t\t\t    NULL, (void *) self);\n\n\t\t/* Do some discovery (and also return cached results) */\n\t\tirlmp_discovery_request(self->nslots);\n\n\t\t/* Wait until a node is discovered */\n\t\tif (!self->cachedaddr) {\n\t\t\tIRDA_DEBUG(1, \"%s(), nothing discovered yet, going to sleep...\\n\", __func__);\n\n\t\t\t/* Set watchdog timer to expire in <val> ms. */\n\t\t\tself->errno = 0;\n\t\t\tsetup_timer(&self->watchdog, irda_discovery_timeout,\n\t\t\t\t\t(unsigned long)self);\n\t\t\tself->watchdog.expires = jiffies + (val * HZ/1000);\n\t\t\tadd_timer(&(self->watchdog));\n\n\t\t\t/* Wait for IR-LMP to call us back */\n\t\t\t__wait_event_interruptible(self->query_wait,\n\t\t\t      (self->cachedaddr != 0 || self->errno == -ETIME),\n\t\t\t\t\t\t   err);\n\n\t\t\t/* If watchdog is still activated, kill it! */\n\t\t\tif(timer_pending(&(self->watchdog)))\n\t\t\t\tdel_timer(&(self->watchdog));\n\n\t\t\tIRDA_DEBUG(1, \"%s(), ...waking up !\\n\", __func__);\n\n\t\t\tif (err != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\telse\n\t\t\tIRDA_DEBUG(1, \"%s(), found immediately !\\n\",\n\t\t\t\t   __func__);\n\n\t\t/* Tell IrLMP that we have been notified */\n\t\tirlmp_update_client(self->ckey, self->mask.word,\n\t\t\t\t    NULL, NULL, NULL);\n\n\t\t/* Check if the we got some results */\n\t\tif (!self->cachedaddr)\n\t\t\treturn -EAGAIN;\t\t/* Didn't find any devices */\n\t\tdaddr = self->cachedaddr;\n\t\t/* Cleanup */\n\t\tself->cachedaddr = 0;\n\n\t\t/* We return the daddr of the device that trigger the\n\t\t * wakeup. As irlmp pass us only the new devices, we\n\t\t * are sure that it's not an old device.\n\t\t * If the user want more details, he should query\n\t\t * the whole discovery log and pick one device...\n\t\t */\n\t\tif (put_user(daddr, (int __user *)optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\nout:\n\n\trelease_sock(sk);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,16 @@\n \n \tswitch (optname) {\n \tcase IRLMP_ENUMDEVICES:\n+\n+\t\t/* Offset to first device entry */\n+\t\toffset = sizeof(struct irda_device_list) -\n+\t\t\tsizeof(struct irda_device_info);\n+\n+\t\tif (len < offset) {\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto out;\n+\t\t}\n+\n \t\t/* Ask lmp for the current discovery log */\n \t\tdiscoveries = irlmp_get_discoveries(&list.len, self->mask.word,\n \t\t\t\t\t\t    self->nslots);\n@@ -39,14 +49,8 @@\n \t\t}\n \n \t\t/* Write total list length back to client */\n-\t\tif (copy_to_user(optval, &list,\n-\t\t\t\t sizeof(struct irda_device_list) -\n-\t\t\t\t sizeof(struct irda_device_info)))\n-\t\t\terr = -EFAULT;\n-\n-\t\t/* Offset to first device entry */\n-\t\toffset = sizeof(struct irda_device_list) -\n-\t\t\tsizeof(struct irda_device_info);\n+\t\tif (copy_to_user(optval, &list, offset))\n+\t\t\terr = -EFAULT;\n \n \t\t/* Copy the list itself - watch for overflow */\n \t\tif (list.len > 2048) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (copy_to_user(optval, &list,",
                "\t\t\t\t sizeof(struct irda_device_list) -",
                "\t\t\t\t sizeof(struct irda_device_info)))",
                "\t\t\terr = -EFAULT;",
                "",
                "\t\t/* Offset to first device entry */",
                "\t\toffset = sizeof(struct irda_device_list) -",
                "\t\t\tsizeof(struct irda_device_info);"
            ],
            "added_lines": [
                "",
                "\t\t/* Offset to first device entry */",
                "\t\toffset = sizeof(struct irda_device_list) -",
                "\t\t\tsizeof(struct irda_device_info);",
                "",
                "\t\tif (len < offset) {",
                "\t\t\terr = -EINVAL;",
                "\t\t\tgoto out;",
                "\t\t}",
                "",
                "\t\tif (copy_to_user(optval, &list, offset))",
                "\t\t\terr = -EFAULT;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10166",
        "func_name": "libgd/_gdContributionsAlloc",
        "description": "Integer underflow in the _gdContributionsAlloc function in gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via vectors related to decrementing the u variable.",
        "git_url": "https://github.com/libgd/libgd/commit/60bfb401ad5a4a8ae995dcd36372fe15c71e1a35",
        "commit_title": "Fix potential unsigned underflow",
        "commit_text": " No need to decrease `u`, so we don't do it. While we're at it, we also factor out the overflow check of the loop, what improves performance and readability.  This issue has been reported by Stefan Esser to security@libgd.org.",
        "func_before": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}",
        "func": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tsize_t weights_size;\n\n\tif (overflow2(windows_size, sizeof(double))) {\n\t\treturn NULL;\n\t} else {\n\t\tweights_size = windows_size * sizeof(double);\n\t}\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tres->ContribRow[u].Weights = (double *) gdMalloc(weights_size);\n\t\tif (res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i=0;i<u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,13 @@\n {\n \tunsigned int u = 0;\n \tLineContribType *res;\n-\tint overflow_error = 0;\n+\tsize_t weights_size;\n \n+\tif (overflow2(windows_size, sizeof(double))) {\n+\t\treturn NULL;\n+\t} else {\n+\t\tweights_size = windows_size * sizeof(double);\n+\t}\n \tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n \tif (!res) {\n \t\treturn NULL;\n@@ -20,15 +25,11 @@\n \t\treturn NULL;\n \t}\n \tfor (u = 0 ; u < line_length ; u++) {\n-\t\tif (overflow2(windows_size, sizeof(double))) {\n-\t\t\toverflow_error = 1;\n-\t\t} else {\n-\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n-\t\t}\n-\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n+\t\tres->ContribRow[u].Weights = (double *) gdMalloc(weights_size);\n+\t\tif (res->ContribRow[u].Weights == NULL) {\n \t\t\tunsigned int i;\n-\t\t\tu--;\n-\t\t\tfor (i=0;i<=u;i++) {\n+\n+\t\t\tfor (i=0;i<u;i++) {\n \t\t\t\tgdFree(res->ContribRow[i].Weights);\n \t\t\t}\n \t\t\tgdFree(res->ContribRow);",
        "diff_line_info": {
            "deleted_lines": [
                "\tint overflow_error = 0;",
                "\t\tif (overflow2(windows_size, sizeof(double))) {",
                "\t\t\toverflow_error = 1;",
                "\t\t} else {",
                "\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));",
                "\t\t}",
                "\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {",
                "\t\t\tu--;",
                "\t\t\tfor (i=0;i<=u;i++) {"
            ],
            "added_lines": [
                "\tsize_t weights_size;",
                "\tif (overflow2(windows_size, sizeof(double))) {",
                "\t\treturn NULL;",
                "\t} else {",
                "\t\tweights_size = windows_size * sizeof(double);",
                "\t}",
                "\t\tres->ContribRow[u].Weights = (double *) gdMalloc(weights_size);",
                "\t\tif (res->ContribRow[u].Weights == NULL) {",
                "",
                "\t\t\tfor (i=0;i<u;i++) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8924",
        "func_name": "torvalds/linux/edge_bulk_in_callback",
        "description": "The edge_bulk_in_callback function in drivers/usb/serial/io_ti.c in the Linux kernel before 4.10.4 allows local users to obtain sensitive information (in the dmesg ringbuffer and syslog) from uninitialized kernel memory by using a crafted USB device (posing as an io_ti USB serial device) to trigger an integer underflow.",
        "git_url": "https://github.com/torvalds/linux/commit/654b404f2a222f918af9b0cd18ad469d0c941a8e",
        "commit_title": "USB: serial: io_ti: fix information leak in completion handler",
        "commit_text": " Add missing sanity check to the bulk-in completion handler to avoid an integer underflow that can be triggered by a malicious device.  This avoids leaking 128 kB of memory content from after the URB transfer buffer to user space.  Cc: stable <stable@vger.kernel.org>\t# 2.6.30",
        "func_before": "static void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tport_number = edge_port->port->port_number;\n\n\tif (edge_port->lsr_event) {\n\t\tedge_port->lsr_event = 0;\n\t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n\t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t/* Adjust buffer length/pointer */\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\n\nexit:\n\t/* continue read unless stopped */\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}",
        "func": "static void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tport_number = edge_port->port->port_number;\n\n\tif (urb->actual_length > 0 && edge_port->lsr_event) {\n\t\tedge_port->lsr_event = 0;\n\t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n\t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t/* Adjust buffer length/pointer */\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\n\nexit:\n\t/* continue read unless stopped */\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tport_number = edge_port->port->port_number;\n \n-\tif (edge_port->lsr_event) {\n+\tif (urb->actual_length > 0 && edge_port->lsr_event) {\n \t\tedge_port->lsr_event = 0;\n \t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n \t\t\t__func__, port_number, edge_port->lsr_mask, *data);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (edge_port->lsr_event) {"
            ],
            "added_lines": [
                "\tif (urb->actual_length > 0 && edge_port->lsr_event) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14353",
        "func_name": "neomutt/imap_quote_string",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap_quote_string in imap/util.c has an integer underflow.",
        "git_url": "https://github.com/neomutt/neomutt/commit/65d64a5b60a4a3883f2cd799d92c6091d8854f23",
        "commit_title": "Check for int underflow in imap_quote_string",
        "commit_text": "",
        "func_before": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}",
        "func": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,9 +15,9 @@\n   {\n     if (strchr(quote, *s))\n     {\n+      if (dlen < 2)\n+        break;\n       dlen -= 2;\n-      if (dlen == 0)\n-        break;\n       *pt++ = '\\\\';\n       *pt++ = *s;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "      if (dlen == 0)",
                "        break;"
            ],
            "added_lines": [
                "      if (dlen < 2)",
                "        break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3472",
        "func_name": "xorg/xserver/ProcXChangeFeedbackControl",
        "description": "A flaw was found in xorg-x11-server in versions before 1.20.11. An integer underflow can occur in xserver which can lead to a local privilege escalation. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.",
        "git_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=7aaf54a1884f71dc363f0b884e57bcb67407a6cd",
        "commit_title": "CVE-2021-3472 / ZDI-CAN-1259",
        "commit_text": " This vulnerability was discovered by: Jan-Niklas Sohn working with Trend Micro Zero Day Initiative  ",
        "func_before": "int\nProcXChangeFeedbackControl(ClientPtr client)\n{\n    unsigned len;\n    DeviceIntPtr dev;\n    KbdFeedbackPtr k;\n    PtrFeedbackPtr p;\n    IntegerFeedbackPtr i;\n    StringFeedbackPtr s;\n    BellFeedbackPtr b;\n    LedFeedbackPtr l;\n    int rc;\n\n    REQUEST(xChangeFeedbackControlReq);\n    REQUEST_AT_LEAST_SIZE(xChangeFeedbackControlReq);\n\n    len = stuff->length - bytes_to_int32(sizeof(xChangeFeedbackControlReq));\n    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);\n    if (rc != Success)\n        return rc;\n\n    switch (stuff->feedbackid) {\n    case KbdFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xKbdFeedbackCtl)))\n            return BadLength;\n\n        for (k = dev->kbdfeed; k; k = k->next)\n            if (k->ctrl.id == ((xKbdFeedbackCtl *) &stuff[1])->id)\n                return ChangeKbdFeedback(client, dev, stuff->mask, k,\n                                         (xKbdFeedbackCtl *) &stuff[1]);\n        break;\n    case PtrFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xPtrFeedbackCtl)))\n            return BadLength;\n\n        for (p = dev->ptrfeed; p; p = p->next)\n            if (p->ctrl.id == ((xPtrFeedbackCtl *) &stuff[1])->id)\n                return ChangePtrFeedback(client, dev, stuff->mask, p,\n                                         (xPtrFeedbackCtl *) &stuff[1]);\n        break;\n    case StringFeedbackClass:\n    {\n        xStringFeedbackCtl *f = ((xStringFeedbackCtl *) &stuff[1]);\n\n        if (client->swapped) {\n            if (len < bytes_to_int32(sizeof(xStringFeedbackCtl)))\n                return BadLength;\n            swaps(&f->num_keysyms);\n        }\n        if (len !=\n            (bytes_to_int32(sizeof(xStringFeedbackCtl)) + f->num_keysyms))\n            return BadLength;\n\n        for (s = dev->stringfeed; s; s = s->next)\n            if (s->ctrl.id == ((xStringFeedbackCtl *) &stuff[1])->id)\n                return ChangeStringFeedback(client, dev, stuff->mask, s,\n                                            (xStringFeedbackCtl *) &stuff[1]);\n        break;\n    }\n    case IntegerFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xIntegerFeedbackCtl)))\n            return BadLength;\n\n        for (i = dev->intfeed; i; i = i->next)\n            if (i->ctrl.id == ((xIntegerFeedbackCtl *) &stuff[1])->id)\n                return ChangeIntegerFeedback(client, dev, stuff->mask, i,\n                                             (xIntegerFeedbackCtl *) &\n                                             stuff[1]);\n        break;\n    case LedFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xLedFeedbackCtl)))\n            return BadLength;\n\n        for (l = dev->leds; l; l = l->next)\n            if (l->ctrl.id == ((xLedFeedbackCtl *) &stuff[1])->id)\n                return ChangeLedFeedback(client, dev, stuff->mask, l,\n                                         (xLedFeedbackCtl *) &stuff[1]);\n        break;\n    case BellFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xBellFeedbackCtl)))\n            return BadLength;\n\n        for (b = dev->bell; b; b = b->next)\n            if (b->ctrl.id == ((xBellFeedbackCtl *) &stuff[1])->id)\n                return ChangeBellFeedback(client, dev, stuff->mask, b,\n                                          (xBellFeedbackCtl *) &stuff[1]);\n        break;\n    default:\n        break;\n    }\n\n    return BadMatch;\n}",
        "func": "int\nProcXChangeFeedbackControl(ClientPtr client)\n{\n    unsigned len;\n    DeviceIntPtr dev;\n    KbdFeedbackPtr k;\n    PtrFeedbackPtr p;\n    IntegerFeedbackPtr i;\n    StringFeedbackPtr s;\n    BellFeedbackPtr b;\n    LedFeedbackPtr l;\n    int rc;\n\n    REQUEST(xChangeFeedbackControlReq);\n    REQUEST_AT_LEAST_SIZE(xChangeFeedbackControlReq);\n\n    len = stuff->length - bytes_to_int32(sizeof(xChangeFeedbackControlReq));\n    rc = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess);\n    if (rc != Success)\n        return rc;\n\n    switch (stuff->feedbackid) {\n    case KbdFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xKbdFeedbackCtl)))\n            return BadLength;\n\n        for (k = dev->kbdfeed; k; k = k->next)\n            if (k->ctrl.id == ((xKbdFeedbackCtl *) &stuff[1])->id)\n                return ChangeKbdFeedback(client, dev, stuff->mask, k,\n                                         (xKbdFeedbackCtl *) &stuff[1]);\n        break;\n    case PtrFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xPtrFeedbackCtl)))\n            return BadLength;\n\n        for (p = dev->ptrfeed; p; p = p->next)\n            if (p->ctrl.id == ((xPtrFeedbackCtl *) &stuff[1])->id)\n                return ChangePtrFeedback(client, dev, stuff->mask, p,\n                                         (xPtrFeedbackCtl *) &stuff[1]);\n        break;\n    case StringFeedbackClass:\n    {\n        xStringFeedbackCtl *f;\n\n        REQUEST_AT_LEAST_EXTRA_SIZE(xChangeFeedbackControlReq,\n                                    sizeof(xStringFeedbackCtl));\n        f = ((xStringFeedbackCtl *) &stuff[1]);\n        if (client->swapped) {\n            if (len < bytes_to_int32(sizeof(xStringFeedbackCtl)))\n                return BadLength;\n            swaps(&f->num_keysyms);\n        }\n        if (len !=\n            (bytes_to_int32(sizeof(xStringFeedbackCtl)) + f->num_keysyms))\n            return BadLength;\n\n        for (s = dev->stringfeed; s; s = s->next)\n            if (s->ctrl.id == ((xStringFeedbackCtl *) &stuff[1])->id)\n                return ChangeStringFeedback(client, dev, stuff->mask, s,\n                                            (xStringFeedbackCtl *) &stuff[1]);\n        break;\n    }\n    case IntegerFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xIntegerFeedbackCtl)))\n            return BadLength;\n\n        for (i = dev->intfeed; i; i = i->next)\n            if (i->ctrl.id == ((xIntegerFeedbackCtl *) &stuff[1])->id)\n                return ChangeIntegerFeedback(client, dev, stuff->mask, i,\n                                             (xIntegerFeedbackCtl *) &\n                                             stuff[1]);\n        break;\n    case LedFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xLedFeedbackCtl)))\n            return BadLength;\n\n        for (l = dev->leds; l; l = l->next)\n            if (l->ctrl.id == ((xLedFeedbackCtl *) &stuff[1])->id)\n                return ChangeLedFeedback(client, dev, stuff->mask, l,\n                                         (xLedFeedbackCtl *) &stuff[1]);\n        break;\n    case BellFeedbackClass:\n        if (len != bytes_to_int32(sizeof(xBellFeedbackCtl)))\n            return BadLength;\n\n        for (b = dev->bell; b; b = b->next)\n            if (b->ctrl.id == ((xBellFeedbackCtl *) &stuff[1])->id)\n                return ChangeBellFeedback(client, dev, stuff->mask, b,\n                                          (xBellFeedbackCtl *) &stuff[1]);\n        break;\n    default:\n        break;\n    }\n\n    return BadMatch;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,8 +40,11 @@\n         break;\n     case StringFeedbackClass:\n     {\n-        xStringFeedbackCtl *f = ((xStringFeedbackCtl *) &stuff[1]);\n+        xStringFeedbackCtl *f;\n \n+        REQUEST_AT_LEAST_EXTRA_SIZE(xChangeFeedbackControlReq,\n+                                    sizeof(xStringFeedbackCtl));\n+        f = ((xStringFeedbackCtl *) &stuff[1]);\n         if (client->swapped) {\n             if (len < bytes_to_int32(sizeof(xStringFeedbackCtl)))\n                 return BadLength;",
        "diff_line_info": {
            "deleted_lines": [
                "        xStringFeedbackCtl *f = ((xStringFeedbackCtl *) &stuff[1]);"
            ],
            "added_lines": [
                "        xStringFeedbackCtl *f;",
                "        REQUEST_AT_LEAST_EXTRA_SIZE(xChangeFeedbackControlReq,",
                "                                    sizeof(xStringFeedbackCtl));",
                "        f = ((xStringFeedbackCtl *) &stuff[1]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24820",
        "func_name": "RIOT-OS/RIOT/gnrc_sixlowpan_iphc_recv",
        "description": "RIOT-OS, an operating system that supports Internet of Things devices, contains a network stack with the ability to process 6LoWPAN frames. An attacker can send a crafted frame to the device resulting in a large out of bounds write beyond the packet buffer. The write will create a hard fault exception after reaching the last page of RAM. The hard fault is not handled and the system will be stuck until reset. Thus the impact is denial of service. Version 2022.10 fixes this issue. As a workaround, apply the patch manually.",
        "git_url": "https://github.com/RIOT-OS/RIOT/commit/d052e2ee166e55bbdfe4c455e65dbd7e3479ebe3",
        "commit_title": "gnrc_sixlowpan_iphc: fix integer underflow in gnrc_sixlowpan_iphc_recv()",
        "commit_text": " (cherry picked from commit 2709fbd827b688fe62df2c77c316914f4a3a6d4a)",
        "func_before": "void gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *sixlo, void *rbuf_ptr,\n                              unsigned page)\n{\n    assert(sixlo != NULL);\n    gnrc_pktsnip_t *ipv6, *netif;\n    gnrc_netif_t *iface;\n    ipv6_hdr_t *ipv6_hdr;\n    uint8_t *iphc_hdr = sixlo->data;\n    size_t payload_offset;\n    size_t uncomp_hdr_len = sizeof(ipv6_hdr_t);\n    gnrc_sixlowpan_frag_rb_t *rbuf = rbuf_ptr;\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n    gnrc_sixlowpan_frag_vrb_t *vrbe = NULL;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\n    if (rbuf != NULL) {\n        ipv6 = rbuf->pkt;\n        assert(ipv6 != NULL);\n        if ((ipv6->size < sizeof(ipv6_hdr_t)) &&\n            (gnrc_pktbuf_realloc_data(ipv6, sizeof(ipv6_hdr_t)) != 0)) {\n            DEBUG(\"6lo iphc: no space to decompress IPHC\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        ipv6 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               GNRC_NETTYPE_IPV6);\n        if (ipv6 == NULL) {\n            gnrc_pktbuf_release(sixlo);\n            return;\n        }\n    }\n\n    assert(ipv6->size >= sizeof(ipv6_hdr_t));\n\n    netif = gnrc_pktsnip_search_type(sixlo, GNRC_NETTYPE_NETIF);\n    assert(netif != NULL);\n    iface = gnrc_netif_hdr_get_netif(netif->data);\n    payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                       ipv6->data);\n    if (payload_offset == 0) {\n        /* unable to parse IPHC header */\n        _recv_error_release(sixlo, ipv6, rbuf);\n        return;\n    }\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    if (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n        bool nhc_header = true;\n        ipv6_hdr = ipv6->data;\n        size_t prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n\n        while (nhc_header) {\n            switch (iphc_hdr[payload_offset] & NHC_ID_MASK) {\n                case NHC_IPV6_EXT_ID:\n                case NHC_IPV6_EXT_ID_ALT:\n                    payload_offset = _iphc_nhc_ipv6_decode(sixlo,\n                                                           payload_offset,\n                                                           rbuf,\n                                                           &prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n                    if (payload_offset == 0) {\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* prev_nh_offset is set to 0 if next header is not\n                     * compressed (== NH flag in compression header not set) */\n                    nhc_header = (prev_nh_offset > 0);\n                    break;\n                case NHC_UDP_ID: {\n                    payload_offset = _iphc_nhc_udp_decode(sixlo,\n                                                          payload_offset,\n                                                          rbuf,\n                                                          prev_nh_offset,\n                                                          ipv6,\n                                                          &uncomp_hdr_len);\n                    if (payload_offset == 0) {\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* no NHC after UDP header */\n                    nhc_header = false;\n                    break;\n                }\n                default:\n                    nhc_header = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t payload_len;\n    if (rbuf != NULL) {\n        /* for a fragmented datagram we know the overall length already */\n        if (_is_rfrag(sixlo)) {\n            DEBUG(\"6lo iphc: calculating payload length for SFR\\n\");\n            DEBUG(\" - rbuf->super.datagram_size: %u\\n\",\n                  rbuf->super.datagram_size);\n            DEBUG(\" - payload_offset: %u\\n\", (unsigned)payload_offset);\n            DEBUG(\" - uncomp_hdr_len: %u\\n\", (unsigned)uncomp_hdr_len);\n            /* set IPv6 header payload length field to the length of whatever is\n             * left after removing the 6LoWPAN header and adding uncompressed\n             * headers */\n            payload_len = (rbuf->super.datagram_size - payload_offset) +\n                          (uncomp_hdr_len - sizeof(ipv6_hdr_t));\n            DEBUG(\"   => %u\\n\", payload_len);\n            /* adapt datagram size for uncompressed datagram */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n            /* guard required because SFR-specific field of vrbe is accessed */\n            rbuf->offset_diff += (uncomp_hdr_len - payload_offset);\n            rbuf->super.datagram_size += rbuf->offset_diff;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n        }\n        else {\n            /* for a fragmented datagram we know the overall length already */\n            payload_len = (uint16_t)(rbuf->super.datagram_size - sizeof(ipv6_hdr_t));\n        }\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));\n        /* re-assign IPv6 header in case realloc changed the address */\n        ipv6_hdr = ipv6->data;\n        /* only create virtual reassembly buffer entry from IPv6 destination if\n         * the current first fragment is the only received fragment in the\n         * reassembly buffer so far and the hop-limit is larger than 1\n         */\n        if ((rbuf->super.current_size <= sixlo->size) && (ipv6_hdr->hl > 1U) &&\n            /* and there is enough slack for changing compression */\n            (rbuf->super.current_size <= iface->sixlo.max_frag_size) &&\n            (vrbe = gnrc_sixlowpan_frag_vrb_from_route(&rbuf->super, iface,\n                                                       ipv6))) {\n            /* add netif header to `ipv6` so its flags can be used when\n             * forwarding the fragment */\n            sixlo = gnrc_pkt_delete(sixlo, netif);\n            ipv6 = gnrc_pkt_append(ipv6, netif);\n            /* provide space to copy remaining payload */\n            if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + sixlo->size -\n                                         payload_offset) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n                _recv_error_release(sixlo, ipv6, rbuf);\n                return;\n            }\n        }\n        /* reallocate to copy complete payload */\n        else if (gnrc_pktbuf_realloc_data(ipv6, rbuf->super.datagram_size) != 0) {\n            DEBUG(\"6lo iphc: no space left to reassemble payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        /* set IPv6 header payload length field to the length of whatever is left\n         * after removing the 6LoWPAN header and adding uncompressed headers */\n        payload_len = (sixlo->size + uncomp_hdr_len -\n                       payload_offset - sizeof(ipv6_hdr_t));\n    }\n    if (rbuf == NULL) {\n        /* (rbuf == NULL) => forwarding is not affected by this */\n        if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + payload_len) != 0) {\n            DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        if (ipv6->size < (uncomp_hdr_len + (sixlo->size - payload_offset))) {\n            DEBUG(\"6lo iphc: not enough space to copy payload.\\n\");\n            DEBUG(\"6lo iphc: potentially malicious datagram size received.\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n\n    /* re-assign IPv6 header in case realloc changed the address */\n    ipv6_hdr = ipv6->data;\n    ipv6_hdr->len = byteorder_htons(payload_len);\n    memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n           ((uint8_t *)sixlo->data) + payload_offset,\n           sixlo->size - payload_offset);\n    if (rbuf != NULL) {\n        rbuf->super.current_size += (uncomp_hdr_len - payload_offset);\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        if (vrbe != NULL) {\n            int res = -1;\n            DEBUG(\"6lo iphc: found route, trying to forward\\n\");\n            ipv6_hdr->hl--;\n            vrbe->super.current_size = rbuf->super.current_size;\n            if ((ipv6 = _encode_frag_for_forwarding(ipv6, vrbe))) {\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n                /* guard required because SFR-specific field of vrbe is\n                 * accessed */\n                if (_is_rfrag(sixlo)) {\n                    vrbe->in_netif = iface;\n                    /* calculate offset difference due to compression */\n                    vrbe->offset_diff = ((int)gnrc_pkt_len(ipv6->next)) -\n                                        sixlo->size;\n                }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n                if ((res = _forward_frag(ipv6, sixlo->next, vrbe, page)) == 0) {\n                    DEBUG(\"6lo iphc: successfully recompressed and forwarded \"\n                          \"1st fragment\\n\");\n                    /* empty list, as it should be in VRB now */\n                    rbuf->super.ints = NULL;\n                }\n            }\n            if ((ipv6 == NULL) || (res < 0)) {\n                /* TODO: There is a potential to fall-back to classic reassembly\n                 * when ipv6 != NULL. However, since `ipv6` was reversed in\n                 * `_encode_frag_for_forwarding`, that step needs to be reversed\n                 * or a version of the old ipv6 needs to be held in the buffer.\n                 * For now, just drop the packet all together in an error case\n                 */\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n            }\n            gnrc_pktbuf_release(sixlo);\n            /* don't remove `rbuf->pkt` (aka ipv6) as it was forwarded */\n            gnrc_sixlowpan_frag_rb_remove(rbuf);\n            return;\n        }\n        DEBUG(\"6lo iphc: no route found, reassemble datagram normally\\n\");\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        sixlo = gnrc_pkt_delete(sixlo, netif);\n        ipv6 = gnrc_pkt_append(ipv6, netif);\n        gnrc_sixlowpan_dispatch_recv(ipv6, NULL, page);\n    }\n    gnrc_pktbuf_release(sixlo);\n    return;\n}",
        "func": "void gnrc_sixlowpan_iphc_recv(gnrc_pktsnip_t *sixlo, void *rbuf_ptr,\n                              unsigned page)\n{\n    assert(sixlo != NULL);\n    gnrc_pktsnip_t *ipv6, *netif;\n    gnrc_netif_t *iface;\n    ipv6_hdr_t *ipv6_hdr;\n    uint8_t *iphc_hdr = sixlo->data;\n    size_t payload_offset;\n    size_t uncomp_hdr_len = sizeof(ipv6_hdr_t);\n    gnrc_sixlowpan_frag_rb_t *rbuf = rbuf_ptr;\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n    gnrc_sixlowpan_frag_vrb_t *vrbe = NULL;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\n    if (rbuf != NULL) {\n        ipv6 = rbuf->pkt;\n        assert(ipv6 != NULL);\n        if ((ipv6->size < sizeof(ipv6_hdr_t)) &&\n            (gnrc_pktbuf_realloc_data(ipv6, sizeof(ipv6_hdr_t)) != 0)) {\n            DEBUG(\"6lo iphc: no space to decompress IPHC\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        ipv6 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               GNRC_NETTYPE_IPV6);\n        if (ipv6 == NULL) {\n            gnrc_pktbuf_release(sixlo);\n            return;\n        }\n    }\n\n    assert(ipv6->size >= sizeof(ipv6_hdr_t));\n\n    netif = gnrc_pktsnip_search_type(sixlo, GNRC_NETTYPE_NETIF);\n    assert(netif != NULL);\n    iface = gnrc_netif_hdr_get_netif(netif->data);\n    payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                       ipv6->data);\n    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n        /* unable to parse IPHC header or malicious packet */\n        DEBUG(\"6lo iphc: malformed IPHC header\\n\");\n        _recv_error_release(sixlo, ipv6, rbuf);\n        return;\n    }\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    if (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n        bool nhc_header = true;\n        ipv6_hdr = ipv6->data;\n        size_t prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n\n        while (nhc_header) {\n            switch (iphc_hdr[payload_offset] & NHC_ID_MASK) {\n                case NHC_IPV6_EXT_ID:\n                case NHC_IPV6_EXT_ID_ALT:\n                    payload_offset = _iphc_nhc_ipv6_decode(sixlo,\n                                                           payload_offset,\n                                                           rbuf,\n                                                           &prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n                        /* unable to parse IPHC header or malicious packet */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* prev_nh_offset is set to 0 if next header is not\n                     * compressed (== NH flag in compression header not set) */\n                    nhc_header = (prev_nh_offset > 0);\n                    break;\n                case NHC_UDP_ID: {\n                    payload_offset = _iphc_nhc_udp_decode(sixlo,\n                                                          payload_offset,\n                                                          rbuf,\n                                                          prev_nh_offset,\n                                                          ipv6,\n                                                          &uncomp_hdr_len);\n                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n                        /* unable to parse IPHC header or malicious packet */\n                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* no NHC after UDP header */\n                    nhc_header = false;\n                    break;\n                }\n                default:\n                    nhc_header = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t payload_len;\n    if (rbuf != NULL) {\n        /* for a fragmented datagram we know the overall length already */\n        if (_is_rfrag(sixlo)) {\n            DEBUG(\"6lo iphc: calculating payload length for SFR\\n\");\n            DEBUG(\" - rbuf->super.datagram_size: %u\\n\",\n                  rbuf->super.datagram_size);\n            DEBUG(\" - payload_offset: %u\\n\", (unsigned)payload_offset);\n            DEBUG(\" - uncomp_hdr_len: %u\\n\", (unsigned)uncomp_hdr_len);\n            /* set IPv6 header payload length field to the length of whatever is\n             * left after removing the 6LoWPAN header and adding uncompressed\n             * headers */\n            payload_len = (rbuf->super.datagram_size - payload_offset) +\n                          (uncomp_hdr_len - sizeof(ipv6_hdr_t));\n            DEBUG(\"   => %u\\n\", payload_len);\n            /* adapt datagram size for uncompressed datagram */\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n            /* guard required because SFR-specific field of vrbe is accessed */\n            rbuf->offset_diff += (uncomp_hdr_len - payload_offset);\n            rbuf->super.datagram_size += rbuf->offset_diff;\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n        }\n        else {\n            /* for a fragmented datagram we know the overall length already */\n            payload_len = (uint16_t)(rbuf->super.datagram_size - sizeof(ipv6_hdr_t));\n        }\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));\n        /* re-assign IPv6 header in case realloc changed the address */\n        ipv6_hdr = ipv6->data;\n        /* only create virtual reassembly buffer entry from IPv6 destination if\n         * the current first fragment is the only received fragment in the\n         * reassembly buffer so far and the hop-limit is larger than 1\n         */\n        if ((rbuf->super.current_size <= sixlo->size) && (ipv6_hdr->hl > 1U) &&\n            /* and there is enough slack for changing compression */\n            (rbuf->super.current_size <= iface->sixlo.max_frag_size) &&\n            (vrbe = gnrc_sixlowpan_frag_vrb_from_route(&rbuf->super, iface,\n                                                       ipv6))) {\n            /* add netif header to `ipv6` so its flags can be used when\n             * forwarding the fragment */\n            sixlo = gnrc_pkt_delete(sixlo, netif);\n            ipv6 = gnrc_pkt_append(ipv6, netif);\n            /* provide space to copy remaining payload */\n            if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + sixlo->size -\n                                         payload_offset) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n                _recv_error_release(sixlo, ipv6, rbuf);\n                return;\n            }\n        }\n        /* reallocate to copy complete payload */\n        else if (gnrc_pktbuf_realloc_data(ipv6, rbuf->super.datagram_size) != 0) {\n            DEBUG(\"6lo iphc: no space left to reassemble payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        /* set IPv6 header payload length field to the length of whatever is left\n         * after removing the 6LoWPAN header and adding uncompressed headers */\n        payload_len = (sixlo->size + uncomp_hdr_len -\n                       payload_offset - sizeof(ipv6_hdr_t));\n    }\n    if (rbuf == NULL) {\n        /* (rbuf == NULL) => forwarding is not affected by this */\n        if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + payload_len) != 0) {\n            DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n    else {\n        if (ipv6->size < (uncomp_hdr_len + (sixlo->size - payload_offset))) {\n            DEBUG(\"6lo iphc: not enough space to copy payload.\\n\");\n            DEBUG(\"6lo iphc: potentially malicious datagram size received.\\n\");\n            _recv_error_release(sixlo, ipv6, rbuf);\n            return;\n        }\n    }\n\n    /* re-assign IPv6 header in case realloc changed the address */\n    ipv6_hdr = ipv6->data;\n    ipv6_hdr->len = byteorder_htons(payload_len);\n    if (sixlo->size > payload_offset) {\n        memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n               ((uint8_t *)sixlo->data) + payload_offset,\n               sixlo->size - payload_offset);\n    }\n    if (rbuf != NULL) {\n        rbuf->super.current_size += (uncomp_hdr_len - payload_offset);\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        if (vrbe != NULL) {\n            int res = -1;\n            DEBUG(\"6lo iphc: found route, trying to forward\\n\");\n            ipv6_hdr->hl--;\n            vrbe->super.current_size = rbuf->super.current_size;\n            if ((ipv6 = _encode_frag_for_forwarding(ipv6, vrbe))) {\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR\n                /* guard required because SFR-specific field of vrbe is\n                 * accessed */\n                if (_is_rfrag(sixlo)) {\n                    vrbe->in_netif = iface;\n                    /* calculate offset difference due to compression */\n                    vrbe->offset_diff = ((int)gnrc_pkt_len(ipv6->next)) -\n                                        sixlo->size;\n                }\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */\n                if ((res = _forward_frag(ipv6, sixlo->next, vrbe, page)) == 0) {\n                    DEBUG(\"6lo iphc: successfully recompressed and forwarded \"\n                          \"1st fragment\\n\");\n                    /* empty list, as it should be in VRB now */\n                    rbuf->super.ints = NULL;\n                }\n            }\n            if ((ipv6 == NULL) || (res < 0)) {\n                /* TODO: There is a potential to fall-back to classic reassembly\n                 * when ipv6 != NULL. However, since `ipv6` was reversed in\n                 * `_encode_frag_for_forwarding`, that step needs to be reversed\n                 * or a version of the old ipv6 needs to be held in the buffer.\n                 * For now, just drop the packet all together in an error case\n                 */\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n            }\n            gnrc_pktbuf_release(sixlo);\n            /* don't remove `rbuf->pkt` (aka ipv6) as it was forwarded */\n            gnrc_sixlowpan_frag_rb_remove(rbuf);\n            return;\n        }\n        DEBUG(\"6lo iphc: no route found, reassemble datagram normally\\n\");\n#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n    }\n    else {\n        sixlo = gnrc_pkt_delete(sixlo, netif);\n        ipv6 = gnrc_pkt_append(ipv6, netif);\n        gnrc_sixlowpan_dispatch_recv(ipv6, NULL, page);\n    }\n    gnrc_pktbuf_release(sixlo);\n    return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,8 +39,9 @@\n     iface = gnrc_netif_hdr_get_netif(netif->data);\n     payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                        ipv6->data);\n-    if (payload_offset == 0) {\n-        /* unable to parse IPHC header */\n+    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n+        /* unable to parse IPHC header or malicious packet */\n+        DEBUG(\"6lo iphc: malformed IPHC header\\n\");\n         _recv_error_release(sixlo, ipv6, rbuf);\n         return;\n     }\n@@ -60,7 +61,9 @@\n                                                            &prev_nh_offset,\n                                                            ipv6,\n                                                            &uncomp_hdr_len);\n-                    if (payload_offset == 0) {\n+                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n+                        /* unable to parse IPHC header or malicious packet */\n+                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                         _recv_error_release(sixlo, ipv6, rbuf);\n                         return;\n                     }\n@@ -75,7 +78,9 @@\n                                                           prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n-                    if (payload_offset == 0) {\n+                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {\n+                        /* unable to parse IPHC header or malicious packet */\n+                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");\n                         _recv_error_release(sixlo, ipv6, rbuf);\n                         return;\n                     }\n@@ -177,9 +182,11 @@\n     /* re-assign IPv6 header in case realloc changed the address */\n     ipv6_hdr = ipv6->data;\n     ipv6_hdr->len = byteorder_htons(payload_len);\n-    memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n-           ((uint8_t *)sixlo->data) + payload_offset,\n-           sixlo->size - payload_offset);\n+    if (sixlo->size > payload_offset) {\n+        memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,\n+               ((uint8_t *)sixlo->data) + payload_offset,\n+               sixlo->size - payload_offset);\n+    }\n     if (rbuf != NULL) {\n         rbuf->super.current_size += (uncomp_hdr_len - payload_offset);\n #ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB",
        "diff_line_info": {
            "deleted_lines": [
                "    if (payload_offset == 0) {",
                "        /* unable to parse IPHC header */",
                "                    if (payload_offset == 0) {",
                "                    if (payload_offset == 0) {",
                "    memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,",
                "           ((uint8_t *)sixlo->data) + payload_offset,",
                "           sixlo->size - payload_offset);"
            ],
            "added_lines": [
                "    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {",
                "        /* unable to parse IPHC header or malicious packet */",
                "        DEBUG(\"6lo iphc: malformed IPHC header\\n\");",
                "                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {",
                "                        /* unable to parse IPHC header or malicious packet */",
                "                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");",
                "                    if ((payload_offset == 0) || (payload_offset > sixlo->size)) {",
                "                        /* unable to parse IPHC header or malicious packet */",
                "                        DEBUG(\"6lo iphc: malformed IPHC NHC IPv6 header\\n\");",
                "    if (sixlo->size > payload_offset) {",
                "        memcpy(((uint8_t *)ipv6->data) + uncomp_hdr_len,",
                "               ((uint8_t *)sixlo->data) + payload_offset,",
                "               sixlo->size - payload_offset);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24821",
        "func_name": "RIOT-OS/RIOT/_6lo_frag_size",
        "description": "RIOT-OS, an operating system that supports Internet of Things devices, contains a network stack with the ability to process 6LoWPAN frames. Prior to version 2022.10, an attacker can send a crafted frame to the device resulting in a large out of bounds write beyond the packet buffer. The write will create a hard fault exception after reaching the last page of RAM. The hard fault is not handled and the system will be stuck until reset, thus the impact is denial of service. Version 2022.10 fixes this issue. As a workaround, disable support for fragmented IP datagrams or apply the patches manually.",
        "git_url": "https://github.com/RIOT-OS/RIOT/commit/bd31010231f5340e21410595dd95afc86bbfd341",
        "commit_title": "gnrc_sixlowpan_frag_rb: fix integer underflow in _6lo_frag_size()",
        "commit_text": " (cherry picked from commit 9728f727e75d7d78dbfb5918e0de1b938b7b6d2c)",
        "func_before": "static size_t _6lo_frag_size(gnrc_pktsnip_t *pkt, size_t offset, uint8_t *data)\n{\n    size_t frag_size;\n\n    if (offset == 0) {\n        frag_size = pkt->size - sizeof(sixlowpan_frag_t);\n        if (data[0] == SIXLOWPAN_UNCOMP) {\n            /* subtract SIXLOWPAN_UNCOMP byte from fragment size,\n             * data pointer must be changed by caller (see _rbuf_add()) */\n            frag_size--;\n        }\n    }\n    else {\n        frag_size = pkt->size - sizeof(sixlowpan_frag_n_t);\n    }\n    return frag_size;\n}",
        "func": "static size_t _6lo_frag_size(gnrc_pktsnip_t *pkt, size_t offset, uint8_t *data)\n{\n    size_t frag_size;\n\n    if (offset == 0) {\n        if (pkt->size < sizeof(sixlowpan_frag_t)) {\n            return 0;\n        }\n        frag_size = pkt->size - sizeof(sixlowpan_frag_t);\n        if (data[0] == SIXLOWPAN_UNCOMP) {\n            /* subtract SIXLOWPAN_UNCOMP byte from fragment size,\n             * data pointer must be changed by caller (see _rbuf_add()) */\n            frag_size--;\n        }\n    }\n    else {\n        if (pkt->size < sizeof(sixlowpan_frag_n_t)) {\n            return 0;\n        }\n        frag_size = pkt->size - sizeof(sixlowpan_frag_n_t);\n    }\n    return frag_size;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n     size_t frag_size;\n \n     if (offset == 0) {\n+        if (pkt->size < sizeof(sixlowpan_frag_t)) {\n+            return 0;\n+        }\n         frag_size = pkt->size - sizeof(sixlowpan_frag_t);\n         if (data[0] == SIXLOWPAN_UNCOMP) {\n             /* subtract SIXLOWPAN_UNCOMP byte from fragment size,\n@@ -11,6 +14,9 @@\n         }\n     }\n     else {\n+        if (pkt->size < sizeof(sixlowpan_frag_n_t)) {\n+            return 0;\n+        }\n         frag_size = pkt->size - sizeof(sixlowpan_frag_n_t);\n     }\n     return frag_size;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (pkt->size < sizeof(sixlowpan_frag_t)) {",
                "            return 0;",
                "        }",
                "        if (pkt->size < sizeof(sixlowpan_frag_n_t)) {",
                "            return 0;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24821",
        "func_name": "RIOT-OS/RIOT/_rbuf_add",
        "description": "RIOT-OS, an operating system that supports Internet of Things devices, contains a network stack with the ability to process 6LoWPAN frames. Prior to version 2022.10, an attacker can send a crafted frame to the device resulting in a large out of bounds write beyond the packet buffer. The write will create a hard fault exception after reaching the last page of RAM. The hard fault is not handled and the system will be stuck until reset, thus the impact is denial of service. Version 2022.10 fixes this issue. As a workaround, disable support for fragmented IP datagrams or apply the patches manually.",
        "git_url": "https://github.com/RIOT-OS/RIOT/commit/bd31010231f5340e21410595dd95afc86bbfd341",
        "commit_title": "gnrc_sixlowpan_frag_rb: fix integer underflow in _6lo_frag_size()",
        "commit_text": " (cherry picked from commit 9728f727e75d7d78dbfb5918e0de1b938b7b6d2c)",
        "func_before": "static int _rbuf_add(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                     size_t offset, unsigned page)\n{\n    union {\n        gnrc_sixlowpan_frag_rb_base_t *super;\n        gnrc_sixlowpan_frag_rb_t *rbuf;\n        gnrc_sixlowpan_frag_vrb_t *vrb;\n    } entry;\n    const uint8_t *src = gnrc_netif_hdr_get_src_addr(netif_hdr);\n    const uint8_t *dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);\n    uint8_t *data = NULL;\n    size_t frag_size = 0;   /* assign 0, otherwise cppcheck complains ;-) */\n    int res;\n    uint16_t datagram_size;\n    uint16_t datagram_tag;\n\n    /* check if provided offset is the same as in fragment */\n    assert(_valid_offset(pkt, offset));\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {\n        data = _6lo_frag_payload(pkt);\n        frag_size = _6lo_frag_size(pkt, offset, data);\n        datagram_size = sixlowpan_frag_datagram_size(pkt->data);\n        datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);\n    }\n    else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&\n             sixlowpan_sfr_rfrag_is(pkt->data)) {\n        sixlowpan_sfr_rfrag_t *rfrag = pkt->data;\n\n        data = _6lo_sfr_payload(pkt);\n        frag_size = _6lo_sfr_frag_size(pkt);\n        /* offset doubles as datagram size in RFRAG header when sequence number\n         * is 0 */\n        datagram_size = _6lo_sfr_datagram_size(pkt, offset);\n        datagram_tag = rfrag->base.tag;\n    }\n    else {\n        /* either one of the if branches above was taken */\n        assert(data != NULL);\n        gnrc_pktbuf_release(pkt);\n        return RBUF_ADD_ERROR;\n    }\n\n    gnrc_sixlowpan_frag_rb_gc();\n    /* only check VRB for subsequent frags, first frags create and not get VRB\n     * entries below */\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n        (offset > 0) &&\n        sixlowpan_frag_n_is(pkt->data) &&\n        (entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,\n                                                 datagram_tag)) != NULL) {\n        DEBUG(\"6lo rbuf minfwd: VRB entry found, trying to forward\\n\");\n        switch (_check_fragments(entry.super, frag_size, offset)) {\n            case RBUF_ADD_REPEAT:\n                DEBUG(\"6lo rbuf minfwd: overlap found; dropping VRB\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(entry.vrb);\n                /* we don't repeat for VRB */\n                gnrc_pktbuf_release(pkt);\n                return RBUF_ADD_ERROR;\n            case RBUF_ADD_DUPLICATE:\n                DEBUG(\"6lo rbuf minfwd: not forwarding duplicate\\n\");\n                gnrc_pktbuf_release(pkt);\n                return RBUF_ADD_FORWARDED;\n            default:\n                break;\n        }\n        res = RBUF_ADD_ERROR;\n        if (_rbuf_update_ints(entry.super, offset, frag_size)) {\n            DEBUG(\"6lo rbuf minfwd: trying to forward fragment\\n\");\n            entry.super->current_size += (uint16_t)frag_size;\n            if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,\n                              page) < 0) {\n                DEBUG(\"6lo rbuf minfwd: unable to forward fragment\\n\");\n                return RBUF_ADD_ERROR;\n            }\n            res = RBUF_ADD_FORWARDED;\n        }\n        return res;\n    }\n    else if ((res = _rbuf_get(src, netif_hdr->src_l2addr_len,\n                              dst, netif_hdr->dst_l2addr_len,\n                              datagram_size, datagram_tag, page)) < 0) {\n        DEBUG(\"6lo rbuf: reassembly buffer full.\\n\");\n        gnrc_pktbuf_release(pkt);\n        return RBUF_ADD_ERROR;\n    }\n    entry.rbuf = &rbuf[res];\n#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)\n    offset += entry.rbuf->offset_diff;\n#endif  /* IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) */\n    if ((offset + frag_size) > entry.super->datagram_size) {\n        DEBUG(\"6lo rfrag: fragment too big for resulting datagram, discarding datagram\\n\");\n        gnrc_pktbuf_release(entry.rbuf->pkt);\n        gnrc_pktbuf_release(pkt);\n        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n        return RBUF_ADD_ERROR;\n    }\n\n    switch (_check_fragments(entry.super, frag_size, offset)) {\n        case RBUF_ADD_REPEAT:\n            DEBUG(\"6lo rfrag: overlapping intervals, discarding datagram\\n\");\n            gnrc_pktbuf_release(entry.rbuf->pkt);\n            gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n            return RBUF_ADD_REPEAT;\n        case RBUF_ADD_DUPLICATE:\n            gnrc_pktbuf_release(pkt);\n            return res;\n        default:\n            break;\n    }\n\n    if (_rbuf_update_ints(entry.super, offset, frag_size)) {\n        DEBUG(\"6lo rbuf: add fragment data\\n\");\n        entry.super->current_size += (uint16_t)frag_size;\n        if (offset == 0) {\n            if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&\n                sixlowpan_iphc_is(data)) {\n                DEBUG(\"6lo rbuf: detected IPHC header.\\n\");\n                gnrc_pktsnip_t *frag_hdr = _mark_frag_hdr(pkt);\n\n                if (frag_hdr == NULL) {\n                    DEBUG(\"6lo rbuf: unable to mark fragment header. \"\n                          \"aborting reassembly.\\n\");\n                    gnrc_pktbuf_release(entry.rbuf->pkt);\n                    gnrc_pktbuf_release(pkt);\n                    gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n                    return RBUF_ADD_ERROR;\n                }\n                else {\n                    DEBUG(\"6lo rbuf: handing over to IPHC reception.\\n\");\n                    /* `pkt` released in IPHC */\n                    gnrc_sixlowpan_iphc_recv(pkt, entry.rbuf, 0);\n                    /* check if entry was deleted in IPHC (error case) */\n                    if (gnrc_sixlowpan_frag_rb_entry_empty(entry.rbuf)) {\n                        res = RBUF_ADD_ERROR;\n                    }\n                    return res;\n                }\n            }\n            else if (data[0] == SIXLOWPAN_UNCOMP) {\n                DEBUG(\"6lo rbuf: detected uncompressed datagram\\n\");\n                data++;\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n                    /* only try minimal forwarding when fragment is the only\n                     * fragment in reassembly buffer yet */\n                    sixlowpan_frag_1_is(pkt->data) &&\n                    (entry.super->current_size == frag_size)) {\n                    gnrc_sixlowpan_frag_vrb_t *vrbe;\n                    gnrc_pktsnip_t tmp = {\n                        .data = data,\n                        .size = frag_size,\n                        .users = 1,\n                    };\n\n                    if (_check_hdr(&tmp, page) &&\n                        (vrbe = gnrc_sixlowpan_frag_vrb_from_route(\n                                    entry.super,\n                                    gnrc_netif_hdr_get_netif(netif_hdr),\n                                    &tmp))) {\n                        _adapt_hdr(&tmp, page);\n                        return _forward_uncomp(pkt, rbuf, vrbe, page);\n                    }\n                }\n                else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&\n                         sixlowpan_sfr_rfrag_is(pkt->data)) {\n                    entry.super->datagram_size--;\n                }\n            }\n        }\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) ||\n            IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)) {\n            /* all cases to try forwarding with minfwd or SFR above failed so\n             * just do normal reassembly. For the `minfwd` case however, we need\n             * to resize `entry.rbuf->pkt`, since we kept the packet allocation\n             * with fragment forwarding as minimal as possible in\n             * `_rbuf_get()` */\n            res = _rbuf_resize_for_reassembly(entry.rbuf);\n            if (res == RBUF_ADD_ERROR) {\n                gnrc_pktbuf_release(pkt);\n                return res;\n            }\n        }\n        memcpy(((uint8_t *)entry.rbuf->pkt->data) + offset, data,\n               frag_size);\n    }\n    else {\n        /* no space left in rbuf interval buffer*/\n        gnrc_pktbuf_release(entry.rbuf->pkt);\n        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n        res = RBUF_ADD_ERROR;\n    }\n    /* no errors and not consumed => release packet */\n    gnrc_pktbuf_release(pkt);\n    return res;\n}",
        "func": "static int _rbuf_add(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                     size_t offset, unsigned page)\n{\n    union {\n        gnrc_sixlowpan_frag_rb_base_t *super;\n        gnrc_sixlowpan_frag_rb_t *rbuf;\n        gnrc_sixlowpan_frag_vrb_t *vrb;\n    } entry;\n    const uint8_t *src = gnrc_netif_hdr_get_src_addr(netif_hdr);\n    const uint8_t *dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);\n    uint8_t *data = NULL;\n    size_t frag_size = 0;   /* assign 0, otherwise cppcheck complains ;-) */\n    int res;\n    uint16_t datagram_size;\n    uint16_t datagram_tag;\n\n    /* check if provided offset is the same as in fragment */\n    assert(_valid_offset(pkt, offset));\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {\n        data = _6lo_frag_payload(pkt);\n        frag_size = _6lo_frag_size(pkt, offset, data);\n        if (frag_size == 0) {\n            DEBUG(\"6lo rbuf: integer underflow detected.\\n\");\n            gnrc_pktbuf_release(pkt);\n            return RBUF_ADD_ERROR;\n        }\n        datagram_size = sixlowpan_frag_datagram_size(pkt->data);\n        datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);\n    }\n    else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&\n             sixlowpan_sfr_rfrag_is(pkt->data)) {\n        sixlowpan_sfr_rfrag_t *rfrag = pkt->data;\n\n        data = _6lo_sfr_payload(pkt);\n        frag_size = _6lo_sfr_frag_size(pkt);\n        /* offset doubles as datagram size in RFRAG header when sequence number\n         * is 0 */\n        datagram_size = _6lo_sfr_datagram_size(pkt, offset);\n        datagram_tag = rfrag->base.tag;\n    }\n    else {\n        /* either one of the if branches above was taken */\n        assert(data != NULL);\n        gnrc_pktbuf_release(pkt);\n        return RBUF_ADD_ERROR;\n    }\n\n    gnrc_sixlowpan_frag_rb_gc();\n    /* only check VRB for subsequent frags, first frags create and not get VRB\n     * entries below */\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n        (offset > 0) &&\n        sixlowpan_frag_n_is(pkt->data) &&\n        (entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,\n                                                 datagram_tag)) != NULL) {\n        DEBUG(\"6lo rbuf minfwd: VRB entry found, trying to forward\\n\");\n        switch (_check_fragments(entry.super, frag_size, offset)) {\n            case RBUF_ADD_REPEAT:\n                DEBUG(\"6lo rbuf minfwd: overlap found; dropping VRB\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(entry.vrb);\n                /* we don't repeat for VRB */\n                gnrc_pktbuf_release(pkt);\n                return RBUF_ADD_ERROR;\n            case RBUF_ADD_DUPLICATE:\n                DEBUG(\"6lo rbuf minfwd: not forwarding duplicate\\n\");\n                gnrc_pktbuf_release(pkt);\n                return RBUF_ADD_FORWARDED;\n            default:\n                break;\n        }\n        res = RBUF_ADD_ERROR;\n        if (_rbuf_update_ints(entry.super, offset, frag_size)) {\n            DEBUG(\"6lo rbuf minfwd: trying to forward fragment\\n\");\n            entry.super->current_size += (uint16_t)frag_size;\n            if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,\n                              page) < 0) {\n                DEBUG(\"6lo rbuf minfwd: unable to forward fragment\\n\");\n                return RBUF_ADD_ERROR;\n            }\n            res = RBUF_ADD_FORWARDED;\n        }\n        return res;\n    }\n    else if ((res = _rbuf_get(src, netif_hdr->src_l2addr_len,\n                              dst, netif_hdr->dst_l2addr_len,\n                              datagram_size, datagram_tag, page)) < 0) {\n        DEBUG(\"6lo rbuf: reassembly buffer full.\\n\");\n        gnrc_pktbuf_release(pkt);\n        return RBUF_ADD_ERROR;\n    }\n    entry.rbuf = &rbuf[res];\n#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)\n    offset += entry.rbuf->offset_diff;\n#endif  /* IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) */\n    if ((offset + frag_size) > entry.super->datagram_size) {\n        DEBUG(\"6lo rfrag: fragment too big for resulting datagram, discarding datagram\\n\");\n        gnrc_pktbuf_release(entry.rbuf->pkt);\n        gnrc_pktbuf_release(pkt);\n        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n        return RBUF_ADD_ERROR;\n    }\n\n    switch (_check_fragments(entry.super, frag_size, offset)) {\n        case RBUF_ADD_REPEAT:\n            DEBUG(\"6lo rfrag: overlapping intervals, discarding datagram\\n\");\n            gnrc_pktbuf_release(entry.rbuf->pkt);\n            gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n            return RBUF_ADD_REPEAT;\n        case RBUF_ADD_DUPLICATE:\n            gnrc_pktbuf_release(pkt);\n            return res;\n        default:\n            break;\n    }\n\n    if (_rbuf_update_ints(entry.super, offset, frag_size)) {\n        DEBUG(\"6lo rbuf: add fragment data\\n\");\n        entry.super->current_size += (uint16_t)frag_size;\n        if (offset == 0) {\n            if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&\n                sixlowpan_iphc_is(data)) {\n                DEBUG(\"6lo rbuf: detected IPHC header.\\n\");\n                gnrc_pktsnip_t *frag_hdr = _mark_frag_hdr(pkt);\n\n                if (frag_hdr == NULL) {\n                    DEBUG(\"6lo rbuf: unable to mark fragment header. \"\n                          \"aborting reassembly.\\n\");\n                    gnrc_pktbuf_release(entry.rbuf->pkt);\n                    gnrc_pktbuf_release(pkt);\n                    gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n                    return RBUF_ADD_ERROR;\n                }\n                else {\n                    DEBUG(\"6lo rbuf: handing over to IPHC reception.\\n\");\n                    /* `pkt` released in IPHC */\n                    gnrc_sixlowpan_iphc_recv(pkt, entry.rbuf, 0);\n                    /* check if entry was deleted in IPHC (error case) */\n                    if (gnrc_sixlowpan_frag_rb_entry_empty(entry.rbuf)) {\n                        res = RBUF_ADD_ERROR;\n                    }\n                    return res;\n                }\n            }\n            else if (data[0] == SIXLOWPAN_UNCOMP) {\n                DEBUG(\"6lo rbuf: detected uncompressed datagram\\n\");\n                data++;\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&\n                    /* only try minimal forwarding when fragment is the only\n                     * fragment in reassembly buffer yet */\n                    sixlowpan_frag_1_is(pkt->data) &&\n                    (entry.super->current_size == frag_size)) {\n                    gnrc_sixlowpan_frag_vrb_t *vrbe;\n                    gnrc_pktsnip_t tmp = {\n                        .data = data,\n                        .size = frag_size,\n                        .users = 1,\n                    };\n\n                    if (_check_hdr(&tmp, page) &&\n                        (vrbe = gnrc_sixlowpan_frag_vrb_from_route(\n                                    entry.super,\n                                    gnrc_netif_hdr_get_netif(netif_hdr),\n                                    &tmp))) {\n                        _adapt_hdr(&tmp, page);\n                        return _forward_uncomp(pkt, rbuf, vrbe, page);\n                    }\n                }\n                else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&\n                         sixlowpan_sfr_rfrag_is(pkt->data)) {\n                    entry.super->datagram_size--;\n                }\n            }\n        }\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) ||\n            IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)) {\n            /* all cases to try forwarding with minfwd or SFR above failed so\n             * just do normal reassembly. For the `minfwd` case however, we need\n             * to resize `entry.rbuf->pkt`, since we kept the packet allocation\n             * with fragment forwarding as minimal as possible in\n             * `_rbuf_get()` */\n            res = _rbuf_resize_for_reassembly(entry.rbuf);\n            if (res == RBUF_ADD_ERROR) {\n                gnrc_pktbuf_release(pkt);\n                return res;\n            }\n        }\n        memcpy(((uint8_t *)entry.rbuf->pkt->data) + offset, data,\n               frag_size);\n    }\n    else {\n        /* no space left in rbuf interval buffer*/\n        gnrc_pktbuf_release(entry.rbuf->pkt);\n        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);\n        res = RBUF_ADD_ERROR;\n    }\n    /* no errors and not consumed => release packet */\n    gnrc_pktbuf_release(pkt);\n    return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,11 @@\n     if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {\n         data = _6lo_frag_payload(pkt);\n         frag_size = _6lo_frag_size(pkt, offset, data);\n+        if (frag_size == 0) {\n+            DEBUG(\"6lo rbuf: integer underflow detected.\\n\");\n+            gnrc_pktbuf_release(pkt);\n+            return RBUF_ADD_ERROR;\n+        }\n         datagram_size = sixlowpan_frag_datagram_size(pkt->data);\n         datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (frag_size == 0) {",
                "            DEBUG(\"6lo rbuf: integer underflow detected.\\n\");",
                "            gnrc_pktbuf_release(pkt);",
                "            return RBUF_ADD_ERROR;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31137",
        "func_name": "samboy/MaraDNS/decomp_get_rddata",
        "description": "MaraDNS is open-source software that implements the Domain Name System (DNS). In version 3.5.0024 and prior, a remotely exploitable integer underflow vulnerability in the DNS packet decompression function allows an attacker to cause a Denial of Service by triggering an abnormal program termination.\n\nThe vulnerability exists in the `decomp_get_rddata` function within the `Decompress.c` file. When handling a DNS packet with an Answer RR of qtype 16 (TXT record) and any qclass, if the `rdlength` is smaller than `rdata`, the result of the line `Decompress.c:886` is a negative number `len = rdlength - total;`. This value is then passed to the `decomp_append_bytes` function without proper validation, causing the program to attempt to allocate a massive chunk of memory that is impossible to allocate. Consequently, the program exits with an error code of 64, causing a Denial of Service.\n\nOne proposed fix for this vulnerability is to patch `Decompress.c:887` by breaking `if(len <= 0)`, which has been incorporated in version 3.5.0036 via commit bab062bde40b2ae8a91eecd522e84d8b993bab58.",
        "git_url": "https://github.com/samboy/MaraDNS/commit/bab062bde40b2ae8a91eecd522e84d8b993bab58",
        "commit_title": "Fix long standing issue in this code from 2002",
        "commit_text": "",
        "func_before": "int decomp_get_rddata(js_string *compressed, js_string *out,\n                      unsigned int compressed_offset, int type, int rdlength) {\n\n    char *desc;\n    int subtype, total, len;\n\n    desc = decomp_get_rrdesc(type);\n\n    if(desc == 0) { /* Unknown RR type */\n        if(rdlength == 0) {\n            return JS_SUCCESS;\n            }\n        if(decomp_append_bytes(compressed,out,compressed_offset,\n                               rdlength) != JS_SUCCESS) {\n            return JS_ERROR;\n            }\n        else {\n            return JS_SUCCESS;\n            }\n        }\n    else {\n        subtype = *desc;\n        total = 0;\n        /* Handle the various types of data we can get in the RR RDDATA */\n        while(subtype != 0) {\n            /* Fix-length data fields */\n            if(subtype > 0 && subtype < 64) {\n                if(decomp_append_bytes(compressed,out,\n                   compressed_offset,subtype) != JS_SUCCESS) {\n                       return JS_ERROR;\n                       }\n                total += subtype;\n                compressed_offset += subtype;\n                }\n            /* Dlabels (which may be compressed) */\n            else if(subtype == RRSUB_DLABEL) {\n                len = decomp_append_dlabel(compressed,out,\n                        compressed_offset);\n                if(len == JS_ERROR) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Text data fields */\n            else if(subtype == RRSUB_TEXT) {\n                /* Data abstraction violation */\n                len = *(compressed->string + compressed_offset);\n                len += 1; /* To account for the one byte which\n                             describes the length */\n                if(len < 0 || len > 256) {\n                    return JS_ERROR;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) !=\n                   JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Variable length data (length determined by rdlength) */\n            else if(subtype == RRSUB_VARIABLE) {\n                len = rdlength - total;\n                if(len == 0) {\n                    break;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) != JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else { /* Should never happen */\n                return JS_ERROR;\n                }\n            desc++;\n            /* RRSUB_VARIABLE must be the last subtype */\n            if(subtype != RRSUB_VARIABLE)\n                subtype = *desc;\n            else\n                subtype = 0; /* break the loop */\n            }\n        /* Sanity check; make sure that rdlength panned out */\n        if(rdlength != total) {\n            return JS_ERROR;\n            }\n        }\n\n    /* The record's rddata was sucessfully decompressed */\n    return JS_SUCCESS;\n    }",
        "func": "int decomp_get_rddata(js_string *compressed, js_string *out,\n                      unsigned int compressed_offset, int type, int rdlength) {\n\n    char *desc;\n    int subtype, total, len;\n\n    desc = decomp_get_rrdesc(type);\n\n    if(desc == 0) { /* Unknown RR type */\n        if(rdlength == 0) {\n            return JS_SUCCESS;\n            }\n        if(decomp_append_bytes(compressed,out,compressed_offset,\n                               rdlength) != JS_SUCCESS) {\n            return JS_ERROR;\n            }\n        else {\n            return JS_SUCCESS;\n            }\n        }\n    else {\n        subtype = *desc;\n        total = 0;\n        /* Handle the various types of data we can get in the RR RDDATA */\n        while(subtype != 0) {\n            /* Fix-length data fields */\n            if(subtype > 0 && subtype < 64) {\n                if(decomp_append_bytes(compressed,out,\n                   compressed_offset,subtype) != JS_SUCCESS) {\n                       return JS_ERROR;\n                       }\n                total += subtype;\n                compressed_offset += subtype;\n                }\n            /* Dlabels (which may be compressed) */\n            else if(subtype == RRSUB_DLABEL) {\n                len = decomp_append_dlabel(compressed,out,\n                        compressed_offset);\n                if(len == JS_ERROR) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Text data fields */\n            else if(subtype == RRSUB_TEXT) {\n                /* Data abstraction violation */\n                len = *(compressed->string + compressed_offset);\n                len += 1; /* To account for the one byte which\n                             describes the length */\n                if(len < 0 || len > 256) {\n                    return JS_ERROR;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) !=\n                   JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Variable length data (length determined by rdlength) */\n            else if(subtype == RRSUB_VARIABLE) {\n                len = rdlength - total;\n                if(len <= 0) {\n                    break;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) != JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else { /* Should never happen */\n                return JS_ERROR;\n                }\n            desc++;\n            /* RRSUB_VARIABLE must be the last subtype */\n            if(subtype != RRSUB_VARIABLE)\n                subtype = *desc;\n            else\n                subtype = 0; /* break the loop */\n            }\n        /* Sanity check; make sure that rdlength panned out */\n        if(rdlength != total) {\n            return JS_ERROR;\n            }\n        }\n\n    /* The record's rddata was sucessfully decompressed */\n    return JS_SUCCESS;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,7 +62,7 @@\n             /* Variable length data (length determined by rdlength) */\n             else if(subtype == RRSUB_VARIABLE) {\n                 len = rdlength - total;\n-                if(len == 0) {\n+                if(len <= 0) {\n                     break;\n                     }\n                 if(decomp_append_bytes(compressed,out,",
        "diff_line_info": {
            "deleted_lines": [
                "                if(len == 0) {"
            ],
            "added_lines": [
                "                if(len <= 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35790",
        "func_name": "libjxl/PatchDictionary::Decode",
        "description": "An issue was discovered in dec_patch_dictionary.cc in libjxl before 0.8.2. An integer underflow in patch decoding can lead to a denial of service, such as an infinite loop.",
        "git_url": "https://github.com/libjxl/libjxl/commit/489b6b82a6ad27d563646d5d920d8d6bcadbc26b",
        "commit_title": "Fix an integer underflow bug in patch decoding.",
        "commit_text": " When reading patches, the code doesn't properly check that all patches are in bounds.  In particular, if the start of a patch becomes negative (due to the delta coding of patch positions), but not negative *enough* to cause `start + size` to still be negative, the decoder happily accepted the patch. Such a patch would then lead the interval tree building code to run into an infinite loop.",
        "func_before": "Status PatchDictionary::Decode(BitReader* br, size_t xsize, size_t ysize,\n                               bool* uses_extra_channels) {\n  positions_.clear();\n  std::vector<uint8_t> context_map;\n  ANSCode code;\n  JXL_RETURN_IF_ERROR(\n      DecodeHistograms(br, kNumPatchDictionaryContexts, &code, &context_map));\n  ANSSymbolReader decoder(&code, br);\n\n  auto read_num = [&](size_t context) {\n    size_t r = decoder.ReadHybridUint(context, br, context_map);\n    return r;\n  };\n\n  size_t num_ref_patch = read_num(kNumRefPatchContext);\n  // Limit max memory usage of patches to about 66 bytes per pixel (assuming 8\n  // bytes per size_t)\n  const size_t num_pixels = xsize * ysize;\n  const size_t max_ref_patches = 1024 + num_pixels / 4;\n  const size_t max_patches = max_ref_patches * 4;\n  const size_t max_blending_infos = max_patches * 4;\n  if (num_ref_patch > max_ref_patches) {\n    return JXL_FAILURE(\"Too many patches in dictionary\");\n  }\n  size_t num_ec = shared_->metadata->m.num_extra_channels;\n\n  size_t total_patches = 0;\n  size_t next_size = 1;\n\n  for (size_t id = 0; id < num_ref_patch; id++) {\n    PatchReferencePosition ref_pos;\n    ref_pos.ref = read_num(kReferenceFrameContext);\n    if (ref_pos.ref >= kMaxNumReferenceFrames ||\n        shared_->reference_frames[ref_pos.ref].frame.xsize() == 0) {\n      return JXL_FAILURE(\"Invalid reference frame ID\");\n    }\n    if (!shared_->reference_frames[ref_pos.ref].ib_is_in_xyb) {\n      return JXL_FAILURE(\n          \"Patches cannot use frames saved post color transforms\");\n    }\n    const ImageBundle& ib = shared_->reference_frames[ref_pos.ref].frame;\n    ref_pos.x0 = read_num(kPatchReferencePositionContext);\n    ref_pos.y0 = read_num(kPatchReferencePositionContext);\n    ref_pos.xsize = read_num(kPatchSizeContext) + 1;\n    ref_pos.ysize = read_num(kPatchSizeContext) + 1;\n    if (ref_pos.x0 + ref_pos.xsize > ib.xsize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    if (ref_pos.y0 + ref_pos.ysize > ib.ysize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    size_t id_count = read_num(kPatchCountContext) + 1;\n    total_patches += id_count;\n    if (total_patches > max_patches) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    if (next_size < total_patches) {\n      next_size *= 2;\n      next_size = std::min<size_t>(next_size, max_patches);\n    }\n    if (next_size * (num_ec + 1) > max_blending_infos) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    positions_.reserve(next_size);\n    blendings_.reserve(next_size * (num_ec + 1));\n    for (size_t i = 0; i < id_count; i++) {\n      PatchPosition pos;\n      pos.ref_pos_idx = ref_positions_.size();\n      if (i == 0) {\n        pos.x = read_num(kPatchPositionContext);\n        pos.y = read_num(kPatchPositionContext);\n      } else {\n        pos.x =\n            positions_.back().x + UnpackSigned(read_num(kPatchOffsetContext));\n        pos.y =\n            positions_.back().y + UnpackSigned(read_num(kPatchOffsetContext));\n      }\n      if (pos.x + ref_pos.xsize > xsize) {\n        return JXL_FAILURE(\"Invalid patch x: at %\" PRIuS \" + %\" PRIuS\n                           \" > %\" PRIuS,\n                           pos.x, ref_pos.xsize, xsize);\n      }\n      if (pos.y + ref_pos.ysize > ysize) {\n        return JXL_FAILURE(\"Invalid patch y: at %\" PRIuS \" + %\" PRIuS\n                           \" > %\" PRIuS,\n                           pos.y, ref_pos.ysize, ysize);\n      }\n      for (size_t j = 0; j < num_ec + 1; j++) {\n        uint32_t blend_mode = read_num(kPatchBlendModeContext);\n        if (blend_mode >= uint32_t(PatchBlendMode::kNumBlendModes)) {\n          return JXL_FAILURE(\"Invalid patch blend mode: %u\", blend_mode);\n        }\n        PatchBlending info;\n        info.mode = static_cast<PatchBlendMode>(blend_mode);\n        if (UsesAlpha(info.mode)) {\n          *uses_extra_channels = true;\n        }\n        if (info.mode != PatchBlendMode::kNone && j > 0) {\n          *uses_extra_channels = true;\n        }\n        if (UsesAlpha(info.mode) &&\n            shared_->metadata->m.extra_channel_info.size() > 1) {\n          info.alpha_channel = read_num(kPatchAlphaChannelContext);\n          if (info.alpha_channel >=\n              shared_->metadata->m.extra_channel_info.size()) {\n            return JXL_FAILURE(\n                \"Invalid alpha channel for blending: %u out of %u\\n\",\n                info.alpha_channel,\n                (uint32_t)shared_->metadata->m.extra_channel_info.size());\n          }\n        } else {\n          info.alpha_channel = 0;\n        }\n        if (UsesClamp(info.mode)) {\n          info.clamp = read_num(kPatchClampContext);\n        } else {\n          info.clamp = false;\n        }\n        blendings_.push_back(info);\n      }\n      positions_.push_back(std::move(pos));\n    }\n    ref_positions_.emplace_back(std::move(ref_pos));\n  }\n  positions_.shrink_to_fit();\n\n  if (!decoder.CheckANSFinalState()) {\n    return JXL_FAILURE(\"ANS checksum failure.\");\n  }\n\n  ComputePatchTree();\n  return true;\n}",
        "func": "Status PatchDictionary::Decode(BitReader* br, size_t xsize, size_t ysize,\n                               bool* uses_extra_channels) {\n  positions_.clear();\n  std::vector<uint8_t> context_map;\n  ANSCode code;\n  JXL_RETURN_IF_ERROR(\n      DecodeHistograms(br, kNumPatchDictionaryContexts, &code, &context_map));\n  ANSSymbolReader decoder(&code, br);\n\n  auto read_num = [&](size_t context) {\n    size_t r = decoder.ReadHybridUint(context, br, context_map);\n    return r;\n  };\n\n  size_t num_ref_patch = read_num(kNumRefPatchContext);\n  // Limit max memory usage of patches to about 66 bytes per pixel (assuming 8\n  // bytes per size_t)\n  const size_t num_pixels = xsize * ysize;\n  const size_t max_ref_patches = 1024 + num_pixels / 4;\n  const size_t max_patches = max_ref_patches * 4;\n  const size_t max_blending_infos = max_patches * 4;\n  if (num_ref_patch > max_ref_patches) {\n    return JXL_FAILURE(\"Too many patches in dictionary\");\n  }\n  size_t num_ec = shared_->metadata->m.num_extra_channels;\n\n  size_t total_patches = 0;\n  size_t next_size = 1;\n\n  for (size_t id = 0; id < num_ref_patch; id++) {\n    PatchReferencePosition ref_pos;\n    ref_pos.ref = read_num(kReferenceFrameContext);\n    if (ref_pos.ref >= kMaxNumReferenceFrames ||\n        shared_->reference_frames[ref_pos.ref].frame.xsize() == 0) {\n      return JXL_FAILURE(\"Invalid reference frame ID\");\n    }\n    if (!shared_->reference_frames[ref_pos.ref].ib_is_in_xyb) {\n      return JXL_FAILURE(\n          \"Patches cannot use frames saved post color transforms\");\n    }\n    const ImageBundle& ib = shared_->reference_frames[ref_pos.ref].frame;\n    ref_pos.x0 = read_num(kPatchReferencePositionContext);\n    ref_pos.y0 = read_num(kPatchReferencePositionContext);\n    ref_pos.xsize = read_num(kPatchSizeContext) + 1;\n    ref_pos.ysize = read_num(kPatchSizeContext) + 1;\n    if (ref_pos.x0 + ref_pos.xsize > ib.xsize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    if (ref_pos.y0 + ref_pos.ysize > ib.ysize()) {\n      return JXL_FAILURE(\"Invalid position specified in reference frame\");\n    }\n    size_t id_count = read_num(kPatchCountContext) + 1;\n    total_patches += id_count;\n    if (total_patches > max_patches) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    if (next_size < total_patches) {\n      next_size *= 2;\n      next_size = std::min<size_t>(next_size, max_patches);\n    }\n    if (next_size * (num_ec + 1) > max_blending_infos) {\n      return JXL_FAILURE(\"Too many patches in dictionary\");\n    }\n    positions_.reserve(next_size);\n    blendings_.reserve(next_size * (num_ec + 1));\n    for (size_t i = 0; i < id_count; i++) {\n      PatchPosition pos;\n      pos.ref_pos_idx = ref_positions_.size();\n      if (i == 0) {\n        pos.x = read_num(kPatchPositionContext);\n        pos.y = read_num(kPatchPositionContext);\n      } else {\n        ssize_t deltax = UnpackSigned(read_num(kPatchOffsetContext));\n        if (deltax < 0 && static_cast<size_t>(-deltax) > positions_.back().x) {\n          return JXL_FAILURE(\"Invalid patch: negative x coordinate (%\" PRIuS\n                             \" base x %\" PRIdS \" delta x)\",\n                             positions_.back().x, deltax);\n        }\n        pos.x = positions_.back().x + deltax;\n        ssize_t deltay = UnpackSigned(read_num(kPatchOffsetContext));\n        if (deltay < 0 && static_cast<size_t>(-deltay) > positions_.back().y) {\n          return JXL_FAILURE(\"Invalid patch: negative y coordinate (%\" PRIuS\n                             \" base y %\" PRIdS \" delta y)\",\n                             positions_.back().y, deltay);\n        }\n        pos.y = positions_.back().y + deltay;\n      }\n      if (pos.x + ref_pos.xsize > xsize) {\n        return JXL_FAILURE(\"Invalid patch x: at %\" PRIuS \" + %\" PRIuS\n                           \" > %\" PRIuS,\n                           pos.x, ref_pos.xsize, xsize);\n      }\n      if (pos.y + ref_pos.ysize > ysize) {\n        return JXL_FAILURE(\"Invalid patch y: at %\" PRIuS \" + %\" PRIuS\n                           \" > %\" PRIuS,\n                           pos.y, ref_pos.ysize, ysize);\n      }\n      for (size_t j = 0; j < num_ec + 1; j++) {\n        uint32_t blend_mode = read_num(kPatchBlendModeContext);\n        if (blend_mode >= uint32_t(PatchBlendMode::kNumBlendModes)) {\n          return JXL_FAILURE(\"Invalid patch blend mode: %u\", blend_mode);\n        }\n        PatchBlending info;\n        info.mode = static_cast<PatchBlendMode>(blend_mode);\n        if (UsesAlpha(info.mode)) {\n          *uses_extra_channels = true;\n        }\n        if (info.mode != PatchBlendMode::kNone && j > 0) {\n          *uses_extra_channels = true;\n        }\n        if (UsesAlpha(info.mode) &&\n            shared_->metadata->m.extra_channel_info.size() > 1) {\n          info.alpha_channel = read_num(kPatchAlphaChannelContext);\n          if (info.alpha_channel >=\n              shared_->metadata->m.extra_channel_info.size()) {\n            return JXL_FAILURE(\n                \"Invalid alpha channel for blending: %u out of %u\\n\",\n                info.alpha_channel,\n                (uint32_t)shared_->metadata->m.extra_channel_info.size());\n          }\n        } else {\n          info.alpha_channel = 0;\n        }\n        if (UsesClamp(info.mode)) {\n          info.clamp = read_num(kPatchClampContext);\n        } else {\n          info.clamp = false;\n        }\n        blendings_.push_back(info);\n      }\n      positions_.push_back(std::move(pos));\n    }\n    ref_positions_.emplace_back(std::move(ref_pos));\n  }\n  positions_.shrink_to_fit();\n\n  if (!decoder.CheckANSFinalState()) {\n    return JXL_FAILURE(\"ANS checksum failure.\");\n  }\n\n  ComputePatchTree();\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -70,10 +70,20 @@\n         pos.x = read_num(kPatchPositionContext);\n         pos.y = read_num(kPatchPositionContext);\n       } else {\n-        pos.x =\n-            positions_.back().x + UnpackSigned(read_num(kPatchOffsetContext));\n-        pos.y =\n-            positions_.back().y + UnpackSigned(read_num(kPatchOffsetContext));\n+        ssize_t deltax = UnpackSigned(read_num(kPatchOffsetContext));\n+        if (deltax < 0 && static_cast<size_t>(-deltax) > positions_.back().x) {\n+          return JXL_FAILURE(\"Invalid patch: negative x coordinate (%\" PRIuS\n+                             \" base x %\" PRIdS \" delta x)\",\n+                             positions_.back().x, deltax);\n+        }\n+        pos.x = positions_.back().x + deltax;\n+        ssize_t deltay = UnpackSigned(read_num(kPatchOffsetContext));\n+        if (deltay < 0 && static_cast<size_t>(-deltay) > positions_.back().y) {\n+          return JXL_FAILURE(\"Invalid patch: negative y coordinate (%\" PRIuS\n+                             \" base y %\" PRIdS \" delta y)\",\n+                             positions_.back().y, deltay);\n+        }\n+        pos.y = positions_.back().y + deltay;\n       }\n       if (pos.x + ref_pos.xsize > xsize) {\n         return JXL_FAILURE(\"Invalid patch x: at %\" PRIuS \" + %\" PRIuS",
        "diff_line_info": {
            "deleted_lines": [
                "        pos.x =",
                "            positions_.back().x + UnpackSigned(read_num(kPatchOffsetContext));",
                "        pos.y =",
                "            positions_.back().y + UnpackSigned(read_num(kPatchOffsetContext));"
            ],
            "added_lines": [
                "        ssize_t deltax = UnpackSigned(read_num(kPatchOffsetContext));",
                "        if (deltax < 0 && static_cast<size_t>(-deltax) > positions_.back().x) {",
                "          return JXL_FAILURE(\"Invalid patch: negative x coordinate (%\" PRIuS",
                "                             \" base x %\" PRIdS \" delta x)\",",
                "                             positions_.back().x, deltax);",
                "        }",
                "        pos.x = positions_.back().x + deltax;",
                "        ssize_t deltay = UnpackSigned(read_num(kPatchOffsetContext));",
                "        if (deltay < 0 && static_cast<size_t>(-deltay) > positions_.back().y) {",
                "          return JXL_FAILURE(\"Invalid patch: negative y coordinate (%\" PRIuS",
                "                             \" base y %\" PRIdS \" delta y)\",",
                "                             positions_.back().y, deltay);",
                "        }",
                "        pos.y = positions_.back().y + deltay;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-37706",
        "func_name": "pjsip/pjproject/decode_errcode_attr",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In affected versions if the incoming STUN message contains an ERROR-CODE attribute, the header length is not checked before performing a subtraction operation, potentially resulting in an integer underflow scenario. This issue affects all users that use STUN. A malicious actor located within the victims network may forge and send a specially crafted UDP (STUN) message that could remotely execute arbitrary code on the victims machine. Users are advised to upgrade as soon as possible. There are no known workarounds.",
        "git_url": "https://github.com/pjsip/pjproject/commit/15663e3f37091069b8c98a7fce680dc04bc8e865",
        "commit_title": "Merge pull request from GHSA-2qpg-f6wf-w984",
        "commit_text": "",
        "func_before": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}",
        "func": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    /* Make sure the length is never negative */\n    if (value.slen < 0)\n    \tvalue.slen = 0;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,9 @@\n     /* Get pointer to the string in the message */\n     value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n     value.slen = attr->hdr.length - 4;\n+    /* Make sure the length is never negative */\n+    if (value.slen < 0)\n+    \tvalue.slen = 0;\n \n     /* Copy the string to the attribute */\n     pj_strdup(pool, &attr->reason, &value);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* Make sure the length is never negative */",
                "    if (value.slen < 0)",
                "    \tvalue.slen = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9626",
        "func_name": "videolan/vlc/MP4_ReadBox_String",
        "description": "Integer underflow in the MP4_ReadBox_String function in modules/demux/mp4/libmp4.c in VideoLAN VLC media player before 2.1.6 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a box size less than 7.",
        "git_url": "https://github.com/videolan/vlc/commit/2e7c7091a61aa5d07e7997b393d821e91f593c39",
        "commit_title": "demux: mp4: fix buffer overflow in parsing of string boxes.",
        "commit_text": " We ensure that pbox->i_size is never smaller than 8 to avoid an integer underflow in the third argument of the subsequent call to memcpy. We also make sure no truncation occurs when passing values derived from the 64 bit integer p_box->i_size to arguments of malloc and memcpy that may be 32 bit integers on 32 bit platforms. ",
        "func_before": "static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}",
        "func": "static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX )\n        MP4_READBOX_EXIT( 0 );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n {\n     MP4_READBOX_ENTER( MP4_Box_data_string_t );\n+\n+    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX )\n+        MP4_READBOX_EXIT( 0 );\n \n     p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\\0, -name, -size */\n     if( p_box->data.p_string->psz_text == NULL )",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX )",
                "        MP4_READBOX_EXIT( 0 );"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28194",
        "func_name": "accel-ppp/rad_packet_recv",
        "description": "Variable underflow exists in accel-ppp radius/packet.c when receiving a RADIUS vendor-specific attribute with length field is less than 2. It has an impact only when the attacker controls the RADIUS server, which can lead to arbitrary code execution.",
        "git_url": "https://github.com/accel-ppp/accel-ppp/commit/e9d369aa0054312b7633e964e9f7eb323f1f3d69",
        "commit_title": "radius: sanity check for vendor attribute length",
        "commit_text": "",
        "func_before": "int rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n{\n\tstruct rad_packet_t *pack;\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_attr_t *da;\n\tstruct rad_dict_vendor_t *vendor;\n\tuint8_t *ptr;\n\tint n, id, len, vendor_id;\n\tsocklen_t addr_len = sizeof(*addr);\n\n\t*p = NULL;\n\n\tpack = rad_packet_alloc(0);\n\tif (!pack)\n\t\treturn 0;\n\n\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tptr = mempool_alloc(buf_pool);\n\tif (ptr == MAP_FAILED) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpack->buf = ptr;\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n\t\telse\n\t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n\t\tif (n < 0) {\n\t\t\trad_packet_free(pack);\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 1;\n\n\t\t\tif (errno != ECONNREFUSED)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (n < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n\t\tgoto out_err;\n\t}\n\n\tpack->code = *ptr; ptr++;\n\tpack->id = *ptr; ptr++;\n\tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n\n\tif (pack->len > n) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n\t\tgoto out_err;\n\t}\n\n\tptr += 16;\n\tn -= 20;\n\n\twhile (n>0) {\n\t\tid = *ptr; ptr++;\n\t\tlen = *ptr - 2; ptr++;\n\t\tif (len < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + len > n) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (id == 26) {\n\t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n\t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n\t\t\tif (vendor) {\n\t\t\t\tptr += 4;\n\n\t\t\t\tif (vendor->tag == 2)\n\t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tid = *ptr;\n\n\t\t\t\tptr += vendor->tag;\n\n\t\t\t\tif (vendor->len == 2)\n\t\t\t\t\tlen = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tlen = *ptr;\n\n\t\t\t\tptr += vendor->len;\n\n\t\t\t\tlen -= vendor->tag + vendor->len;\n\n\t\t\t\tn -= 4 + vendor->tag + vendor->len;\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n\t\t} else\n\t\t\tvendor = NULL;\n\t\tda = rad_dict_find_attr_id(vendor, id);\n\t\tif (da) {\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tif (!attr) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->vendor = vendor;\n\t\t\tattr->attr = da;\n\t\t\tattr->len = len;\n\t\t\tattr->raw = ptr;\n\n\t\t\tif (!da->array) {\n\t\t\t\tswitch (da->type) {\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tattr->alloc = 1;\n\t\t\t\t\t\tattr->val.string = _malloc(len + 1);\n\t\t\t\t\t\tmemcpy(attr->val.string, ptr, len);\n\t\t\t\t\t\tattr->val.string[len] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tcase ATTR_TYPE_ETHER:\n\t\t\t\t\tcase ATTR_TYPE_TLV:\n\t\t\t\t\t\tattr->val.octets = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (len != da->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tif (len == 4)\n\t\t\t\t\t\t\tattr->val.integer = ntohl(*(uint32_t*)ptr);\n\t\t\t\t\t\telse if (len == 2)\n\t\t\t\t\t\t\tattr->val.integer = ntohs(*(uint16_t*)ptr);\n\t\t\t\t\t\telse if (len == 1)\n\t\t\t\t\t\t\tattr->val.integer = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n\t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", vendor ? vendor->id : 0, id);\n\t\tptr += len;\n\t\tn -= 2 + len;\n\t}\n\n\t*p = pack;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(pack);\n\treturn 1;\n}",
        "func": "int rad_packet_recv(int fd, struct rad_packet_t **p, struct sockaddr_in *addr)\n{\n\tstruct rad_packet_t *pack;\n\tstruct rad_attr_t *attr;\n\tstruct rad_dict_attr_t *da;\n\tstruct rad_dict_vendor_t *vendor;\n\tuint8_t *ptr;\n\tint n, id, len, vendor_id;\n\tsocklen_t addr_len = sizeof(*addr);\n\n\t*p = NULL;\n\n\tpack = rad_packet_alloc(0);\n\tif (!pack)\n\t\treturn 0;\n\n\t//ptr = mmap(NULL, REQ_LENGTH_MAX, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n\tptr = mempool_alloc(buf_pool);\n\tif (ptr == MAP_FAILED) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\tgoto out_err;\n\t}\n\n\tpack->buf = ptr;\n\tclock_gettime(CLOCK_MONOTONIC, &pack->tv);\n\n\twhile (1) {\n\t\tif (addr)\n\t\t\tn = recvfrom(fd, pack->buf, REQ_LENGTH_MAX, 0, addr, &addr_len);\n\t\telse\n\t\t\tn = read(fd, pack->buf, REQ_LENGTH_MAX);\n\t\tif (n < 0) {\n\t\t\trad_packet_free(pack);\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 1;\n\n\t\t\tif (errno != ECONNREFUSED)\n\t\t\t\tlog_ppp_error(\"radius:packet:read: %s\\n\", strerror(errno));\n\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (n < 20) {\n\t\tlog_ppp_warn(\"radius:packet: short packed received (%i)\\n\", n);\n\t\tgoto out_err;\n\t}\n\n\tpack->code = *ptr; ptr++;\n\tpack->id = *ptr; ptr++;\n\tpack->len = ntohs(*(uint16_t*)ptr); ptr += 2;\n\n\tif (pack->len > n) {\n\t\tlog_ppp_warn(\"radius:packet: short packet received %i, expected %i\\n\", pack->len, n);\n\t\tgoto out_err;\n\t}\n\n\tptr += 16;\n\tn -= 20;\n\n\twhile (n>0) {\n\t\tid = *ptr; ptr++;\n\t\tlen = *ptr - 2; ptr++;\n\t\tif (len < 0) {\n\t\t\tlog_ppp_warn(\"radius:packet short attribute len received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (2 + len > n) {\n\t\t\tlog_ppp_warn(\"radius:packet: too long attribute received (%i, %i)\\n\", id, len);\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (id == 26) {\n\t\t\tvendor_id = ntohl(*(uint32_t *)ptr);\n\t\t\tvendor = rad_dict_find_vendor_id(vendor_id);\n\t\t\tif (vendor) {\n\t\t\t\tptr += 4;\n\n\t\t\t\tif (vendor->tag == 2)\n\t\t\t\t\tid = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tid = *ptr;\n\n\t\t\t\tptr += vendor->tag;\n\n\t\t\t\tif (vendor->len == 2)\n\t\t\t\t\tlen = (uint16_t)ntohs(*(uint16_t *)ptr);\n\t\t\t\telse\n\t\t\t\t\tlen = *ptr;\n\n\t\t\t\tptr += vendor->len;\n\n\t\t\t\tlen -= vendor->tag + vendor->len;\n\n\t\t\t\tn -= 4 + vendor->tag + vendor->len;\n\t\t\t\tif (len < 0) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet invalid vendor attribute len received\\n\");\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (2 + len > n) {\n\t\t\t\t\tlog_ppp_warn(\"radius:packet: too long vendor attribute received (%i, %i)\\n\", id, len);\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n\t\t} else\n\t\t\tvendor = NULL;\n\t\tda = rad_dict_find_attr_id(vendor, id);\n\t\tif (da) {\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tif (!attr) {\n\t\t\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->vendor = vendor;\n\t\t\tattr->attr = da;\n\t\t\tattr->len = len;\n\t\t\tattr->raw = ptr;\n\n\t\t\tif (!da->array) {\n\t\t\t\tswitch (da->type) {\n\t\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\t\tattr->alloc = 1;\n\t\t\t\t\t\tattr->val.string = _malloc(len + 1);\n\t\t\t\t\t\tmemcpy(attr->val.string, ptr, len);\n\t\t\t\t\t\tattr->val.string[len] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_OCTETS:\n\t\t\t\t\tcase ATTR_TYPE_ETHER:\n\t\t\t\t\tcase ATTR_TYPE_TLV:\n\t\t\t\t\t\tattr->val.octets = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_INTEGER:\n\t\t\t\t\t\tif (len != da->size)\n\t\t\t\t\t\t\tlog_ppp_warn(\"radius:packet: attribute %s has invalid length %i (must be %i)\\n\", da->name, len, da->size);\n\t\t\t\t\tcase ATTR_TYPE_DATE:\n\t\t\t\t\t\tif (len == 4)\n\t\t\t\t\t\t\tattr->val.integer = ntohl(*(uint32_t*)ptr);\n\t\t\t\t\t\telse if (len == 2)\n\t\t\t\t\t\t\tattr->val.integer = ntohs(*(uint16_t*)ptr);\n\t\t\t\t\t\telse if (len == 1)\n\t\t\t\t\t\t\tattr->val.integer = *ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPADDR:\n\t\t\t\t\tcase ATTR_TYPE_IFID:\n\t\t\t\t\tcase ATTR_TYPE_IPV6ADDR:\n\t\t\t\t\t\tmemcpy(&attr->val.integer, ptr, len);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ATTR_TYPE_IPV6PREFIX:\n\t\t\t\t\t\tattr->val.ipv6prefix.len = ptr[1];\n\t\t\t\t\t\tmemset(&attr->val.ipv6prefix.prefix, 0, sizeof(attr->val.ipv6prefix.prefix));\n\t\t\t\t\t\tmemcpy(&attr->val.ipv6prefix.prefix, ptr + 2, len - 2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\t\t} else\n\t\t\tlog_ppp_warn(\"radius:packet: unknown attribute received (%i,%i)\\n\", vendor ? vendor->id : 0, id);\n\t\tptr += len;\n\t\tn -= 2 + len;\n\t}\n\n\t*p = pack;\n\n\treturn 0;\n\nout_err:\n\trad_packet_free(pack);\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -93,6 +93,14 @@\n \t\t\t\tlen -= vendor->tag + vendor->len;\n \n \t\t\t\tn -= 4 + vendor->tag + vendor->len;\n+\t\t\t\tif (len < 0) {\n+\t\t\t\t\tlog_ppp_warn(\"radius:packet invalid vendor attribute len received\\n\");\n+\t\t\t\t\tgoto out_err;\n+\t\t\t\t}\n+\t\t\t\tif (2 + len > n) {\n+\t\t\t\t\tlog_ppp_warn(\"radius:packet: too long vendor attribute received (%i, %i)\\n\", id, len);\n+\t\t\t\t\tgoto out_err;\n+\t\t\t\t}\n \t\t\t} else\n \t\t\t\tlog_ppp_warn(\"radius:packet: vendor %i not found\\n\", id);\n \t\t} else",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tif (len < 0) {",
                "\t\t\t\t\tlog_ppp_warn(\"radius:packet invalid vendor attribute len received\\n\");",
                "\t\t\t\t\tgoto out_err;",
                "\t\t\t\t}",
                "\t\t\t\tif (2 + len > n) {",
                "\t\t\t\t\tlog_ppp_warn(\"radius:packet: too long vendor attribute received (%i, %i)\\n\", id, len);",
                "\t\t\t\t\tgoto out_err;",
                "\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4031",
        "func_name": "ffmpeg/asfrtp_parse_packet",
        "description": "Integer underflow in the asfrtp_parse_packet function in libavformat/rtpdec_asf.c in FFmpeg before 0.8.3 allows remote attackers to execute arbitrary code via a crafted ASF packet.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=c2a2ad133eb9d42361804a568dee336992349a5e",
        "commit_title": "",
        "commit_text": "rtp: Fix integer underflow that could allow remote code execution.  Fixes MSVR-11-0088 Credit:  Jeong Wook Oh of Microsoft and Microsoft Vulnerability Research (MSVR) (cherry picked from commit ba9a7e0d71bd34f8b89ae99322b62a310be163a6) ",
        "func_before": "static int asfrtp_parse_packet(AVFormatContext *s, PayloadContext *asf,\n                               AVStream *st, AVPacket *pkt,\n                               uint32_t *timestamp,\n                               const uint8_t *buf, int len, int flags)\n{\n    AVIOContext *pb = &asf->pb;\n    int res, mflags, len_off;\n    RTSPState *rt = s->priv_data;\n\n    if (!rt->asf_ctx)\n        return -1;\n\n    if (len > 0) {\n        int off, out_len = 0;\n\n        if (len < 4)\n            return -1;\n\n        av_freep(&asf->buf);\n\n        ffio_init_context(pb, buf, len, 0, NULL, NULL, NULL, NULL);\n\n        while (avio_tell(pb) + 4 < len) {\n            int start_off = avio_tell(pb);\n\n            mflags = avio_r8(pb);\n            if (mflags & 0x80)\n                flags |= RTP_FLAG_KEY;\n            len_off = avio_rb24(pb);\n            if (mflags & 0x20)   /**< relative timestamp */\n                avio_skip(pb, 4);\n            if (mflags & 0x10)   /**< has duration */\n                avio_skip(pb, 4);\n            if (mflags & 0x8)    /**< has location ID */\n                avio_skip(pb, 4);\n            off = avio_tell(pb);\n\n            if (!(mflags & 0x40)) {\n                /**\n                 * If 0x40 is not set, the len_off field specifies an offset\n                 * of this packet's payload data in the complete (reassembled)\n                 * ASF packet. This is used to spread one ASF packet over\n                 * multiple RTP packets.\n                 */\n                if (asf->pktbuf && len_off != avio_tell(asf->pktbuf)) {\n                    uint8_t *p;\n                    avio_close_dyn_buf(asf->pktbuf, &p);\n                    asf->pktbuf = NULL;\n                    av_free(p);\n                }\n                if (!len_off && !asf->pktbuf &&\n                    (res = avio_open_dyn_buf(&asf->pktbuf)) < 0)\n                    return res;\n                if (!asf->pktbuf)\n                    return AVERROR(EIO);\n\n                avio_write(asf->pktbuf, buf + off, len - off);\n                avio_skip(pb, len - off);\n                if (!(flags & RTP_FLAG_MARKER))\n                    return -1;\n                out_len     = avio_close_dyn_buf(asf->pktbuf, &asf->buf);\n                asf->pktbuf = NULL;\n            } else {\n                /**\n                 * If 0x40 is set, the len_off field specifies the length of\n                 * the next ASF packet that can be read from this payload\n                 * data alone. This is commonly the same as the payload size,\n                 * but could be less in case of packet splitting (i.e.\n                 * multiple ASF packets in one RTP packet).\n                 */\n\n                int cur_len = start_off + len_off - off;\n                int prev_len = out_len;\n                out_len += cur_len;\n                asf->buf = av_realloc(asf->buf, out_len);\n                memcpy(asf->buf + prev_len, buf + off,\n                       FFMIN(cur_len, len - off));\n                avio_skip(pb, cur_len);\n            }\n        }\n\n        init_packetizer(pb, asf->buf, out_len);\n        pb->pos += rt->asf_pb_pos;\n        pb->eof_reached = 0;\n        rt->asf_ctx->pb = pb;\n    }\n\n    for (;;) {\n        int i;\n\n        res = av_read_packet(rt->asf_ctx, pkt);\n        rt->asf_pb_pos = avio_tell(pb);\n        if (res != 0)\n            break;\n        for (i = 0; i < s->nb_streams; i++) {\n            if (s->streams[i]->id == rt->asf_ctx->streams[pkt->stream_index]->id) {\n                pkt->stream_index = i;\n                return 1; // FIXME: return 0 if last packet\n            }\n        }\n        av_free_packet(pkt);\n    }\n\n    return res == 1 ? -1 : res;\n}",
        "func": "static int asfrtp_parse_packet(AVFormatContext *s, PayloadContext *asf,\n                               AVStream *st, AVPacket *pkt,\n                               uint32_t *timestamp,\n                               const uint8_t *buf, int len, int flags)\n{\n    AVIOContext *pb = &asf->pb;\n    int res, mflags, len_off;\n    RTSPState *rt = s->priv_data;\n\n    if (!rt->asf_ctx)\n        return -1;\n\n    if (len > 0) {\n        int off, out_len = 0;\n\n        if (len < 4)\n            return -1;\n\n        av_freep(&asf->buf);\n\n        ffio_init_context(pb, buf, len, 0, NULL, NULL, NULL, NULL);\n\n        while (avio_tell(pb) + 4 < len) {\n            int start_off = avio_tell(pb);\n\n            mflags = avio_r8(pb);\n            if (mflags & 0x80)\n                flags |= RTP_FLAG_KEY;\n            len_off = avio_rb24(pb);\n            if (mflags & 0x20)   /**< relative timestamp */\n                avio_skip(pb, 4);\n            if (mflags & 0x10)   /**< has duration */\n                avio_skip(pb, 4);\n            if (mflags & 0x8)    /**< has location ID */\n                avio_skip(pb, 4);\n            off = avio_tell(pb);\n\n            if (!(mflags & 0x40)) {\n                /**\n                 * If 0x40 is not set, the len_off field specifies an offset\n                 * of this packet's payload data in the complete (reassembled)\n                 * ASF packet. This is used to spread one ASF packet over\n                 * multiple RTP packets.\n                 */\n                if (asf->pktbuf && len_off != avio_tell(asf->pktbuf)) {\n                    uint8_t *p;\n                    avio_close_dyn_buf(asf->pktbuf, &p);\n                    asf->pktbuf = NULL;\n                    av_free(p);\n                }\n                if (!len_off && !asf->pktbuf &&\n                    (res = avio_open_dyn_buf(&asf->pktbuf)) < 0)\n                    return res;\n                if (!asf->pktbuf)\n                    return AVERROR(EIO);\n\n                avio_write(asf->pktbuf, buf + off, len - off);\n                avio_skip(pb, len - off);\n                if (!(flags & RTP_FLAG_MARKER))\n                    return -1;\n                out_len     = avio_close_dyn_buf(asf->pktbuf, &asf->buf);\n                asf->pktbuf = NULL;\n            } else {\n                /**\n                 * If 0x40 is set, the len_off field specifies the length of\n                 * the next ASF packet that can be read from this payload\n                 * data alone. This is commonly the same as the payload size,\n                 * but could be less in case of packet splitting (i.e.\n                 * multiple ASF packets in one RTP packet).\n                 */\n\n                int cur_len = start_off + len_off - off;\n                int prev_len = out_len;\n                out_len += cur_len;\n                asf->buf = av_realloc(asf->buf, out_len);\n                if(!asf->buf || FFMIN(cur_len, len - off)<0)\n                    return -1;\n                memcpy(asf->buf + prev_len, buf + off,\n                       FFMIN(cur_len, len - off));\n                avio_skip(pb, cur_len);\n            }\n        }\n\n        init_packetizer(pb, asf->buf, out_len);\n        pb->pos += rt->asf_pb_pos;\n        pb->eof_reached = 0;\n        rt->asf_ctx->pb = pb;\n    }\n\n    for (;;) {\n        int i;\n\n        res = av_read_packet(rt->asf_ctx, pkt);\n        rt->asf_pb_pos = avio_tell(pb);\n        if (res != 0)\n            break;\n        for (i = 0; i < s->nb_streams; i++) {\n            if (s->streams[i]->id == rt->asf_ctx->streams[pkt->stream_index]->id) {\n                pkt->stream_index = i;\n                return 1; // FIXME: return 0 if last packet\n            }\n        }\n        av_free_packet(pkt);\n    }\n\n    return res == 1 ? -1 : res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,6 +73,8 @@\n                 int prev_len = out_len;\n                 out_len += cur_len;\n                 asf->buf = av_realloc(asf->buf, out_len);\n+                if(!asf->buf || FFMIN(cur_len, len - off)<0)\n+                    return -1;\n                 memcpy(asf->buf + prev_len, buf + off,\n                        FFMIN(cur_len, len - off));\n                 avio_skip(pb, cur_len);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                if(!asf->buf || FFMIN(cur_len, len - off)<0)",
                "                    return -1;"
            ]
        }
    }
]