[
    {
        "cve_id": "CVE-2006-5331",
        "func_name": "torvalds/linux/altivec_unavailable_exception",
        "description": "The altivec_unavailable_exception function in arch/powerpc/kernel/traps.c in the Linux kernel before 2.6.19 on 64-bit systems mishandles the case where CONFIG_ALTIVEC is defined and the CPU actually supports Altivec, but the Altivec support was not detected by the kernel, which allows local users to cause a denial of service (panic) by triggering execution of an Altivec instruction.",
        "git_url": "https://github.com/torvalds/linux/commit/6c4841c2b6c32a134f9f36e5e08857138cc12b10",
        "commit_title": "[POWERPC] Never panic when taking altivec exceptions from userspace",
        "commit_text": " At the moment we rely on a cpu feature bit or a firmware property to detect altivec. If we dont have either of these and the cpu does in fact support altivec we can cause a panic from userspace.  It seems safer to always send a signal if we manage to get an 0xf20 exception from userspace. ",
        "func_before": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an altivec instruction,\n\t\t   but this kernel doesn't support altivec. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}",
        "func": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n\tif (user_mode(regs)) {\n\t\t/* A user program has executed an altivec instruction,\n\t\t   but this kernel doesn't support altivec. */\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,12 @@\n void altivec_unavailable_exception(struct pt_regs *regs)\n {\n-#if !defined(CONFIG_ALTIVEC)\n \tif (user_mode(regs)) {\n \t\t/* A user program has executed an altivec instruction,\n \t\t   but this kernel doesn't support altivec. */\n \t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n \t\treturn;\n \t}\n-#endif\n+\n \tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n \t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n \tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);",
        "diff_line_info": {
            "deleted_lines": [
                "#if !defined(CONFIG_ALTIVEC)",
                "#endif"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2085",
        "func_name": "torvalds/linux/evm_verify_hmac",
        "description": "The evm_verify_hmac function in security/integrity/evm/evm_main.c in the Linux kernel before 4.5 does not properly copy data, which makes it easier for local users to forge MAC values via a timing side-channel attack.",
        "git_url": "https://github.com/torvalds/linux/commit/613317bd212c585c20796c10afe5daaa95d4b0a1",
        "commit_title": "EVM: Use crypto_memneq() for digest comparisons",
        "commit_text": " This patch fixes vulnerability CVE-2016-2085.  The problem exists because the vm_verify_hmac() function includes a use of memcmp(). Unfortunately, this allows timing side channel attacks; specifically a MAC forgery complexity drop from 2^128 to 2^12.  This patch changes the memcmp() to the cryptographically safe crypto_memneq().  Cc: stable@vger.kernel.org",
        "func_before": "static enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = memcmp(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}",
        "func": "static enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,7 @@\n \t\t\t\t   xattr_value_len, calc.digest);\n \t\tif (rc)\n \t\t\tbreak;\n-\t\trc = memcmp(xattr_data->digest, calc.digest,\n+\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n \t\t\t    sizeof(calc.digest));\n \t\tif (rc)\n \t\t\trc = -EINVAL;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\trc = memcmp(xattr_data->digest, calc.digest,"
            ],
            "added_lines": [
                "\t\trc = crypto_memneq(xattr_data->digest, calc.digest,"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1573",
        "func_name": "torvalds/linux/nft_flush_table",
        "description": "The nft_flush_table function in net/netfilter/nf_tables_api.c in the Linux kernel before 3.18.5 mishandles the interaction between cross-chain jumps and ruleset flushes, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability.",
        "git_url": "https://github.com/torvalds/linux/commit/a2f18db0c68fec96631c10cad9384c196e9008ac",
        "commit_title": "netfilter: nf_tables: fix flush ruleset chain dependencies",
        "commit_text": " Jumping between chains doesn't mix well with flush ruleset. Rules from a different chain and set elements may still refer to us.  [  353.373791] ------------[ cut here ]------------ [  353.373845] kernel BUG at net/netfilter/nf_tables_api.c:1159! [  353.373896] invalid opcode: 0000 [#1] SMP [  353.373942] Modules linked in: intel_powerclamp uas iwldvm iwlwifi [  353.374017] CPU: 0 PID: 6445 Comm: 31c3.nft Not tainted 3.18.0 #98 [  353.374069] Hardware name: LENOVO 5129CTO/5129CTO, BIOS 6QET47WW (1.17 ) 07/14/2010 [...] [  353.375018] Call Trace: [  353.375046]  [<ffffffff81964c31>] ? nf_tables_commit+0x381/0x540 [  353.375101]  [<ffffffff81949118>] nfnetlink_rcv+0x3d8/0x4b0 [  353.375150]  [<ffffffff81943fc5>] netlink_unicast+0x105/0x1a0 [  353.375200]  [<ffffffff8194438e>] netlink_sendmsg+0x32e/0x790 [  353.375253]  [<ffffffff818f398e>] sock_sendmsg+0x8e/0xc0 [  353.375300]  [<ffffffff818f36b9>] ? move_addr_to_kernel.part.20+0x19/0x70 [  353.375357]  [<ffffffff818f44f9>] ? move_addr_to_kernel+0x19/0x30 [  353.375410]  [<ffffffff819016d2>] ? verify_iovec+0x42/0xd0 [  353.375459]  [<ffffffff818f3e10>] ___sys_sendmsg+0x3f0/0x400 [  353.375510]  [<ffffffff810615fa>] ? native_sched_clock+0x2a/0x90 [  353.375563]  [<ffffffff81176697>] ? acct_account_cputime+0x17/0x20 [  353.375616]  [<ffffffff8110dc78>] ? account_user_time+0x88/0xa0 [  353.375667]  [<ffffffff818f4bbd>] __sys_sendmsg+0x3d/0x80 [  353.375719]  [<ffffffff81b184f4>] ? int_check_syscall_exit_work+0x34/0x3d [  353.375776]  [<ffffffff818f4c0d>] SyS_sendmsg+0xd/0x20 [  353.375823]  [<ffffffff81b1826d>] system_call_fastpath+0x16/0x1b  Release objects in this order: rules -> sets -> chains -> tables, to make sure no references to chains are held anymore. ",
        "func_before": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}",
        "func": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\n\tlist_for_each_entry(chain, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,14 +4,10 @@\n \tstruct nft_chain *chain, *nc;\n \tstruct nft_set *set, *ns;\n \n-\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n+\tlist_for_each_entry(chain, &ctx->table->chains, list) {\n \t\tctx->chain = chain;\n \n \t\terr = nft_delrule_by_chain(ctx);\n-\t\tif (err < 0)\n-\t\t\tgoto out;\n-\n-\t\terr = nft_delchain(ctx);\n \t\tif (err < 0)\n \t\t\tgoto out;\n \t}\n@@ -26,6 +22,14 @@\n \t\t\tgoto out;\n \t}\n \n+\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n+\t\tctx->chain = chain;\n+\n+\t\terr = nft_delchain(ctx);\n+\t\tif (err < 0)\n+\t\t\tgoto out;\n+\t}\n+\n \terr = nft_deltable(ctx);\n out:\n \treturn err;",
        "diff_line_info": {
            "deleted_lines": [
                "\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {",
                "\t\tif (err < 0)",
                "\t\t\tgoto out;",
                "",
                "\t\terr = nft_delchain(ctx);"
            ],
            "added_lines": [
                "\tlist_for_each_entry(chain, &ctx->table->chains, list) {",
                "\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {",
                "\t\tctx->chain = chain;",
                "",
                "\t\terr = nft_delchain(ctx);",
                "\t\tif (err < 0)",
                "\t\t\tgoto out;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3554",
        "func_name": "facebook/wangle/AcceptRoutingHandler<Pipeline, R>::onRoutingData",
        "description": "Wangle's AcceptRoutingHandler incorrectly casts a socket when accepting a TLS 1.3 connection, leading to a potential denial of service attack against systems accepting such connections. This affects versions of Wangle prior to v2019.01.14.00",
        "git_url": "https://github.com/facebook/wangle/commit/3b17ba10a82c71e7808760e027ac6af687e06074",
        "commit_title": "AcceptRoutingHandler should not assume a folly::AsyncSocket",
        "commit_text": " Summary: There is no reason to perform a cast to folly::AsyncSocket, when all of the required behavior is in folly::AsyncTransportWrapper.  CVE-2019-3554  Reviewed By: avasylev  Differential Revision: D13599212  fbshipit-source-id: 3bb5475fe464c04cf5c04115f34e1bcf237cb4aa",
        "func_before": "void AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  // Get the routing pipeline corresponding to this connection\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n\n  // Fetch the socket from the pipeline and pause reading from the\n  // socket\n  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n      routingPipeline->getTransport());\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n\n  // Hash based on routing data to pick a new acceptor\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n\n  // Switch to the new acceptor's thread\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n\n        pipeline->transportActive();\n\n        // Pass in the buffered bytes to the pipeline\n        pipeline->read(routingData.bufQueue);\n      });\n}",
        "func": "void AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  // Get the routing pipeline corresponding to this connection\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n\n  // Fetch the socket from the pipeline and pause reading from the\n  // socket\n  auto socket = std::dynamic_pointer_cast<folly::AsyncTransportWrapper>(\n      routingPipeline->getTransport());\n  CHECK(socket);\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n\n  // Hash based on routing data to pick a new acceptor\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n\n  // Switch to the new acceptor's thread\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n\n        pipeline->transportActive();\n\n        // Pass in the buffered bytes to the pipeline\n        pipeline->read(routingData.bufQueue);\n      });\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,8 +13,9 @@\n \n   // Fetch the socket from the pipeline and pause reading from the\n   // socket\n-  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n+  auto socket = std::dynamic_pointer_cast<folly::AsyncTransportWrapper>(\n       routingPipeline->getTransport());\n+  CHECK(socket);\n   routingPipeline->transportInactive();\n   socket->detachEventBase();\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>("
            ],
            "added_lines": [
                "  auto socket = std::dynamic_pointer_cast<folly::AsyncTransportWrapper>(",
                "  CHECK(socket);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-5155",
        "func_name": "gnulib/parse_reg_exp",
        "description": "In the GNU C Library (aka glibc or libc6) before 2.28, parse_reg_exp in posix/regcomp.c misparses alternatives, which allows attackers to cause a denial of service (assertion failure and application exit) or trigger an incorrect result by attempting a regular-expression match.",
        "git_url": "http://git.savannah.gnu.org/cgit/gnulib.git/commit/?id=5513b40999149090987a0341c018d05d3eea1272",
        "commit_title": "Problem reported by Hanno BÃ¶ck in: http://bugs.gnu.org/21513",
        "commit_text": "* lib/regcomp.c (parse_reg_exp): While parsing alternatives, keep track of the set of previously-completed subexpressions available before the first alternative, and restore this set just before parsing each subsequent alternative.  This lets us diagnose the invalid back-reference in the ERE '()|\\1'. ",
        "func_before": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
        "func": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n {\n   re_dfa_t *dfa = preg->buffer;\n   bin_tree_t *tree, *branch = NULL;\n+  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n   tree = parse_branch (regexp, preg, token, syntax, nest, err);\n   if (BE (*err != REG_NOERROR && tree == NULL, 0))\n     return NULL;\n@@ -14,6 +15,8 @@\n       if (token->type != OP_ALT && token->type != END_OF_RE\n \t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n \t{\n+\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n+\t  dfa->completed_bkref_map = initial_bkref_map;\n \t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n \t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n \t    {\n@@ -21,6 +24,7 @@\n \t\tpostorder (tree, free_tree, NULL);\n \t      return NULL;\n \t    }\n+\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n \t}\n       else\n \tbranch = NULL;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;",
                "\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;",
                "\t  dfa->completed_bkref_map = initial_bkref_map;",
                "\t  dfa->completed_bkref_map |= accumulated_bkref_map;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7928",
        "func_name": "chromium/HOptimizedGraphBuilder::TryInlineBuiltinMethodCall",
        "description": "hydrogen.cc in Google V8, as used Google Chrome before 40.0.2214.91, does not properly handle arrays with holes, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted JavaScript code that triggers an array copy.",
        "git_url": "https://chromium.googlesource.com/v8/v8/+/3d58b82addcdc72755539631b1d5dc603a9b2135",
        "commit_title": "Fix for 435073: CHECK failure in CHECK(p->IsSmi()) failed.",
        "commit_text": " The bug was an error when copying arrays in crankshaft. If it's a holey smi array, the copy must be done as FAST_HOLEY_ELEMENTS to prevent representation changes from being inserted that deopt on encountering the hole.  Also, prevent inlining array pop() and shift() if the length is read-only.    ",
        "func_before": "bool HOptimizedGraphBuilder::TryInlineBuiltinMethodCall(\n    Call* expr, Handle<JSFunction> function, Handle<Map> receiver_map,\n    int args_count_no_receiver) {\n  if (!function->shared()->HasBuiltinFunctionId()) return false;\n  BuiltinFunctionId id = function->shared()->builtin_function_id();\n  int argument_count = args_count_no_receiver + 1;  // Plus receiver.\n\n  if (receiver_map.is_null()) {\n    HValue* receiver = environment()->ExpressionStackAt(args_count_no_receiver);\n    if (receiver->IsConstant() &&\n        HConstant::cast(receiver)->handle(isolate())->IsHeapObject()) {\n      receiver_map =\n          handle(Handle<HeapObject>::cast(\n                     HConstant::cast(receiver)->handle(isolate()))->map());\n    }\n  }\n  // Try to inline calls like Math.* as operations in the calling function.\n  switch (id) {\n    case kStringCharCodeAt:\n    case kStringCharAt:\n      if (argument_count == 2) {\n        HValue* index = Pop();\n        HValue* string = Pop();\n        Drop(1);  // Function.\n        HInstruction* char_code =\n            BuildStringCharCodeAt(string, index);\n        if (id == kStringCharCodeAt) {\n          ast_context()->ReturnInstruction(char_code, expr->id());\n          return true;\n        }\n        AddInstruction(char_code);\n        HInstruction* result = NewUncasted<HStringCharFromCode>(char_code);\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kStringFromCharCode:\n      if (argument_count == 2) {\n        HValue* argument = Pop();\n        Drop(2);  // Receiver and function.\n        HInstruction* result = NewUncasted<HStringCharFromCode>(argument);\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kMathExp:\n      if (!FLAG_fast_math) break;\n      // Fall through if FLAG_fast_math.\n    case kMathRound:\n    case kMathFround:\n    case kMathFloor:\n    case kMathAbs:\n    case kMathSqrt:\n    case kMathLog:\n    case kMathClz32:\n      if (argument_count == 2) {\n        HValue* argument = Pop();\n        Drop(2);  // Receiver and function.\n        HInstruction* op = NewUncasted<HUnaryMathOperation>(argument, id);\n        ast_context()->ReturnInstruction(op, expr->id());\n        return true;\n      }\n      break;\n    case kMathPow:\n      if (argument_count == 3) {\n        HValue* right = Pop();\n        HValue* left = Pop();\n        Drop(2);  // Receiver and function.\n        HInstruction* result = NULL;\n        // Use sqrt() if exponent is 0.5 or -0.5.\n        if (right->IsConstant() && HConstant::cast(right)->HasDoubleValue()) {\n          double exponent = HConstant::cast(right)->DoubleValue();\n          if (exponent == 0.5) {\n            result = NewUncasted<HUnaryMathOperation>(left, kMathPowHalf);\n          } else if (exponent == -0.5) {\n            HValue* one = graph()->GetConstant1();\n            HInstruction* sqrt = AddUncasted<HUnaryMathOperation>(\n                left, kMathPowHalf);\n            // MathPowHalf doesn't have side effects so there's no need for\n            // an environment simulation here.\n            DCHECK(!sqrt->HasObservableSideEffects());\n            result = NewUncasted<HDiv>(one, sqrt);\n          } else if (exponent == 2.0) {\n            result = NewUncasted<HMul>(left, left);\n          }\n        }\n\n        if (result == NULL) {\n          result = NewUncasted<HPower>(left, right);\n        }\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kMathMax:\n    case kMathMin:\n      if (argument_count == 3) {\n        HValue* right = Pop();\n        HValue* left = Pop();\n        Drop(2);  // Receiver and function.\n        HMathMinMax::Operation op = (id == kMathMin) ? HMathMinMax::kMathMin\n                                                     : HMathMinMax::kMathMax;\n        HInstruction* result = NewUncasted<HMathMinMax>(left, right, op);\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kMathImul:\n      if (argument_count == 3) {\n        HValue* right = Pop();\n        HValue* left = Pop();\n        Drop(2);  // Receiver and function.\n        HInstruction* result = HMul::NewImul(zone(), context(), left, right);\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kArrayPop: {\n      if (receiver_map.is_null()) return false;\n      if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n      ElementsKind elements_kind = receiver_map->elements_kind();\n      if (!IsFastElementsKind(elements_kind)) return false;\n      if (receiver_map->is_observed()) return false;\n      if (!receiver_map->is_extensible()) return false;\n\n      Drop(args_count_no_receiver);\n      HValue* result;\n      HValue* reduced_length;\n      HValue* receiver = Pop();\n\n      HValue* checked_object = AddCheckMap(receiver, receiver_map);\n      HValue* length = Add<HLoadNamedField>(\n          checked_object, static_cast<HValue*>(NULL),\n          HObjectAccess::ForArrayLength(elements_kind));\n\n      Drop(1);  // Function.\n\n      { NoObservableSideEffectsScope scope(this);\n        IfBuilder length_checker(this);\n\n        HValue* bounds_check = length_checker.If<HCompareNumericAndBranch>(\n            length, graph()->GetConstant0(), Token::EQ);\n        length_checker.Then();\n\n        if (!ast_context()->IsEffect()) Push(graph()->GetConstantUndefined());\n\n        length_checker.Else();\n        HValue* elements = AddLoadElements(checked_object);\n        // Ensure that we aren't popping from a copy-on-write array.\n        if (IsFastSmiOrObjectElementsKind(elements_kind)) {\n          elements = BuildCopyElementsOnWrite(checked_object, elements,\n                                              elements_kind, length);\n        }\n        reduced_length = AddUncasted<HSub>(length, graph()->GetConstant1());\n        result = AddElementAccess(elements, reduced_length, NULL,\n                                  bounds_check, elements_kind, LOAD);\n        Factory* factory = isolate()->factory();\n        double nan_double = FixedDoubleArray::hole_nan_as_double();\n        HValue* hole = IsFastSmiOrObjectElementsKind(elements_kind)\n            ? Add<HConstant>(factory->the_hole_value())\n            : Add<HConstant>(nan_double);\n        if (IsFastSmiOrObjectElementsKind(elements_kind)) {\n          elements_kind = FAST_HOLEY_ELEMENTS;\n        }\n        AddElementAccess(\n            elements, reduced_length, hole, bounds_check, elements_kind, STORE);\n        Add<HStoreNamedField>(\n            checked_object, HObjectAccess::ForArrayLength(elements_kind),\n            reduced_length, STORE_TO_INITIALIZED_ENTRY);\n\n        if (!ast_context()->IsEffect()) Push(result);\n\n        length_checker.End();\n      }\n      result = ast_context()->IsEffect() ? graph()->GetConstant0() : Top();\n      Add<HSimulate>(expr->id(), REMOVABLE_SIMULATE);\n      if (!ast_context()->IsEffect()) Drop(1);\n\n      ast_context()->ReturnValue(result);\n      return true;\n    }\n    case kArrayPush: {\n      if (receiver_map.is_null()) return false;\n      if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n      ElementsKind elements_kind = receiver_map->elements_kind();\n      if (!IsFastElementsKind(elements_kind)) return false;\n      if (receiver_map->is_observed()) return false;\n      if (JSArray::IsReadOnlyLengthDescriptor(receiver_map)) return false;\n      if (!receiver_map->is_extensible()) return false;\n\n      // If there may be elements accessors in the prototype chain, the fast\n      // inlined version can't be used.\n      if (receiver_map->DictionaryElementsInPrototypeChainOnly()) return false;\n      // If there currently can be no elements accessors on the prototype chain,\n      // it doesn't mean that there won't be any later. Install a full prototype\n      // chain check to trap element accessors being installed on the prototype\n      // chain, which would cause elements to go to dictionary mode and result\n      // in a map change.\n      Handle<JSObject> prototype(JSObject::cast(receiver_map->prototype()));\n      BuildCheckPrototypeMaps(prototype, Handle<JSObject>());\n\n      const int argc = args_count_no_receiver;\n      if (argc != 1) return false;\n\n      HValue* value_to_push = Pop();\n      HValue* array = Pop();\n      Drop(1);  // Drop function.\n\n      HInstruction* new_size = NULL;\n      HValue* length = NULL;\n\n      {\n        NoObservableSideEffectsScope scope(this);\n\n        length = Add<HLoadNamedField>(array, static_cast<HValue*>(NULL),\n          HObjectAccess::ForArrayLength(elements_kind));\n\n        new_size = AddUncasted<HAdd>(length, graph()->GetConstant1());\n\n        bool is_array = receiver_map->instance_type() == JS_ARRAY_TYPE;\n        BuildUncheckedMonomorphicElementAccess(array, length,\n                                               value_to_push, is_array,\n                                               elements_kind, STORE,\n                                               NEVER_RETURN_HOLE,\n                                               STORE_AND_GROW_NO_TRANSITION);\n\n        if (!ast_context()->IsEffect()) Push(new_size);\n        Add<HSimulate>(expr->id(), REMOVABLE_SIMULATE);\n        if (!ast_context()->IsEffect()) Drop(1);\n      }\n\n      ast_context()->ReturnValue(new_size);\n      return true;\n    }\n    case kArrayShift: {\n      if (receiver_map.is_null()) return false;\n      if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n      ElementsKind kind = receiver_map->elements_kind();\n      if (!IsFastElementsKind(kind)) return false;\n      if (receiver_map->is_observed()) return false;\n      if (!receiver_map->is_extensible()) return false;\n\n      // If there may be elements accessors in the prototype chain, the fast\n      // inlined version can't be used.\n      if (receiver_map->DictionaryElementsInPrototypeChainOnly()) return false;\n\n      // If there currently can be no elements accessors on the prototype chain,\n      // it doesn't mean that there won't be any later. Install a full prototype\n      // chain check to trap element accessors being installed on the prototype\n      // chain, which would cause elements to go to dictionary mode and result\n      // in a map change.\n      BuildCheckPrototypeMaps(\n          handle(JSObject::cast(receiver_map->prototype()), isolate()),\n          Handle<JSObject>::null());\n\n      // Threshold for fast inlined Array.shift().\n      HConstant* inline_threshold = Add<HConstant>(static_cast<int32_t>(16));\n\n      Drop(args_count_no_receiver);\n      HValue* receiver = Pop();\n      HValue* function = Pop();\n      HValue* result;\n\n      {\n        NoObservableSideEffectsScope scope(this);\n\n        HValue* length = Add<HLoadNamedField>(\n            receiver, static_cast<HValue*>(NULL),\n            HObjectAccess::ForArrayLength(kind));\n\n        IfBuilder if_lengthiszero(this);\n        HValue* lengthiszero = if_lengthiszero.If<HCompareNumericAndBranch>(\n            length, graph()->GetConstant0(), Token::EQ);\n        if_lengthiszero.Then();\n        {\n          if (!ast_context()->IsEffect()) Push(graph()->GetConstantUndefined());\n        }\n        if_lengthiszero.Else();\n        {\n          HValue* elements = AddLoadElements(receiver);\n\n          // Check if we can use the fast inlined Array.shift().\n          IfBuilder if_inline(this);\n          if_inline.If<HCompareNumericAndBranch>(\n              length, inline_threshold, Token::LTE);\n          if (IsFastSmiOrObjectElementsKind(kind)) {\n            // We cannot handle copy-on-write backing stores here.\n            if_inline.AndIf<HCompareMap>(\n                elements, isolate()->factory()->fixed_array_map());\n          }\n          if_inline.Then();\n          {\n            // Remember the result.\n            if (!ast_context()->IsEffect()) {\n              Push(AddElementAccess(elements, graph()->GetConstant0(), NULL,\n                                    lengthiszero, kind, LOAD));\n            }\n\n            // Compute the new length.\n            HValue* new_length = AddUncasted<HSub>(\n                length, graph()->GetConstant1());\n            new_length->ClearFlag(HValue::kCanOverflow);\n\n            // Copy the remaining elements.\n            LoopBuilder loop(this, context(), LoopBuilder::kPostIncrement);\n            {\n              HValue* new_key = loop.BeginBody(\n                  graph()->GetConstant0(), new_length, Token::LT);\n              HValue* key = AddUncasted<HAdd>(new_key, graph()->GetConstant1());\n              key->ClearFlag(HValue::kCanOverflow);\n              HValue* element = AddUncasted<HLoadKeyed>(\n                  elements, key, lengthiszero, kind, ALLOW_RETURN_HOLE);\n              HStoreKeyed* store = Add<HStoreKeyed>(\n                  elements, new_key, element, kind);\n              store->SetFlag(HValue::kAllowUndefinedAsNaN);\n            }\n            loop.EndBody();\n\n            // Put a hole at the end.\n            HValue* hole = IsFastSmiOrObjectElementsKind(kind)\n                ? Add<HConstant>(isolate()->factory()->the_hole_value())\n                : Add<HConstant>(FixedDoubleArray::hole_nan_as_double());\n            if (IsFastSmiOrObjectElementsKind(kind)) kind = FAST_HOLEY_ELEMENTS;\n            Add<HStoreKeyed>(\n                elements, new_length, hole, kind, INITIALIZING_STORE);\n\n            // Remember new length.\n            Add<HStoreNamedField>(\n                receiver, HObjectAccess::ForArrayLength(kind),\n                new_length, STORE_TO_INITIALIZED_ENTRY);\n          }\n          if_inline.Else();\n          {\n            Add<HPushArguments>(receiver);\n            result = Add<HCallJSFunction>(function, 1, true);\n            if (!ast_context()->IsEffect()) Push(result);\n          }\n          if_inline.End();\n        }\n        if_lengthiszero.End();\n      }\n      result = ast_context()->IsEffect() ? graph()->GetConstant0() : Top();\n      Add<HSimulate>(expr->id(), REMOVABLE_SIMULATE);\n      if (!ast_context()->IsEffect()) Drop(1);\n      ast_context()->ReturnValue(result);\n      return true;\n    }\n    case kArrayIndexOf:\n    case kArrayLastIndexOf: {\n      if (receiver_map.is_null()) return false;\n      if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n      ElementsKind kind = receiver_map->elements_kind();\n      if (!IsFastElementsKind(kind)) return false;\n      if (receiver_map->is_observed()) return false;\n      if (argument_count != 2) return false;\n      if (!receiver_map->is_extensible()) return false;\n\n      // If there may be elements accessors in the prototype chain, the fast\n      // inlined version can't be used.\n      if (receiver_map->DictionaryElementsInPrototypeChainOnly()) return false;\n\n      // If there currently can be no elements accessors on the prototype chain,\n      // it doesn't mean that there won't be any later. Install a full prototype\n      // chain check to trap element accessors being installed on the prototype\n      // chain, which would cause elements to go to dictionary mode and result\n      // in a map change.\n      BuildCheckPrototypeMaps(\n          handle(JSObject::cast(receiver_map->prototype()), isolate()),\n          Handle<JSObject>::null());\n\n      HValue* search_element = Pop();\n      HValue* receiver = Pop();\n      Drop(1);  // Drop function.\n\n      ArrayIndexOfMode mode = (id == kArrayIndexOf)\n          ? kFirstIndexOf : kLastIndexOf;\n      HValue* index = BuildArrayIndexOf(receiver, search_element, kind, mode);\n\n      if (!ast_context()->IsEffect()) Push(index);\n      Add<HSimulate>(expr->id(), REMOVABLE_SIMULATE);\n      if (!ast_context()->IsEffect()) Drop(1);\n      ast_context()->ReturnValue(index);\n      return true;\n    }\n    default:\n      // Not yet supported for inlining.\n      break;\n  }\n  return false;\n}",
        "func": "bool HOptimizedGraphBuilder::TryInlineBuiltinMethodCall(\n    Call* expr, Handle<JSFunction> function, Handle<Map> receiver_map,\n    int args_count_no_receiver) {\n  if (!function->shared()->HasBuiltinFunctionId()) return false;\n  BuiltinFunctionId id = function->shared()->builtin_function_id();\n  int argument_count = args_count_no_receiver + 1;  // Plus receiver.\n\n  if (receiver_map.is_null()) {\n    HValue* receiver = environment()->ExpressionStackAt(args_count_no_receiver);\n    if (receiver->IsConstant() &&\n        HConstant::cast(receiver)->handle(isolate())->IsHeapObject()) {\n      receiver_map =\n          handle(Handle<HeapObject>::cast(\n                     HConstant::cast(receiver)->handle(isolate()))->map());\n    }\n  }\n  // Try to inline calls like Math.* as operations in the calling function.\n  switch (id) {\n    case kStringCharCodeAt:\n    case kStringCharAt:\n      if (argument_count == 2) {\n        HValue* index = Pop();\n        HValue* string = Pop();\n        Drop(1);  // Function.\n        HInstruction* char_code =\n            BuildStringCharCodeAt(string, index);\n        if (id == kStringCharCodeAt) {\n          ast_context()->ReturnInstruction(char_code, expr->id());\n          return true;\n        }\n        AddInstruction(char_code);\n        HInstruction* result = NewUncasted<HStringCharFromCode>(char_code);\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kStringFromCharCode:\n      if (argument_count == 2) {\n        HValue* argument = Pop();\n        Drop(2);  // Receiver and function.\n        HInstruction* result = NewUncasted<HStringCharFromCode>(argument);\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kMathExp:\n      if (!FLAG_fast_math) break;\n      // Fall through if FLAG_fast_math.\n    case kMathRound:\n    case kMathFround:\n    case kMathFloor:\n    case kMathAbs:\n    case kMathSqrt:\n    case kMathLog:\n    case kMathClz32:\n      if (argument_count == 2) {\n        HValue* argument = Pop();\n        Drop(2);  // Receiver and function.\n        HInstruction* op = NewUncasted<HUnaryMathOperation>(argument, id);\n        ast_context()->ReturnInstruction(op, expr->id());\n        return true;\n      }\n      break;\n    case kMathPow:\n      if (argument_count == 3) {\n        HValue* right = Pop();\n        HValue* left = Pop();\n        Drop(2);  // Receiver and function.\n        HInstruction* result = NULL;\n        // Use sqrt() if exponent is 0.5 or -0.5.\n        if (right->IsConstant() && HConstant::cast(right)->HasDoubleValue()) {\n          double exponent = HConstant::cast(right)->DoubleValue();\n          if (exponent == 0.5) {\n            result = NewUncasted<HUnaryMathOperation>(left, kMathPowHalf);\n          } else if (exponent == -0.5) {\n            HValue* one = graph()->GetConstant1();\n            HInstruction* sqrt = AddUncasted<HUnaryMathOperation>(\n                left, kMathPowHalf);\n            // MathPowHalf doesn't have side effects so there's no need for\n            // an environment simulation here.\n            DCHECK(!sqrt->HasObservableSideEffects());\n            result = NewUncasted<HDiv>(one, sqrt);\n          } else if (exponent == 2.0) {\n            result = NewUncasted<HMul>(left, left);\n          }\n        }\n\n        if (result == NULL) {\n          result = NewUncasted<HPower>(left, right);\n        }\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kMathMax:\n    case kMathMin:\n      if (argument_count == 3) {\n        HValue* right = Pop();\n        HValue* left = Pop();\n        Drop(2);  // Receiver and function.\n        HMathMinMax::Operation op = (id == kMathMin) ? HMathMinMax::kMathMin\n                                                     : HMathMinMax::kMathMax;\n        HInstruction* result = NewUncasted<HMathMinMax>(left, right, op);\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kMathImul:\n      if (argument_count == 3) {\n        HValue* right = Pop();\n        HValue* left = Pop();\n        Drop(2);  // Receiver and function.\n        HInstruction* result = HMul::NewImul(zone(), context(), left, right);\n        ast_context()->ReturnInstruction(result, expr->id());\n        return true;\n      }\n      break;\n    case kArrayPop: {\n      if (receiver_map.is_null()) return false;\n      if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n      ElementsKind elements_kind = receiver_map->elements_kind();\n      if (JSArray::IsReadOnlyLengthDescriptor(receiver_map)) return false;\n      if (!IsFastElementsKind(elements_kind)) return false;\n      if (receiver_map->is_observed()) return false;\n      if (!receiver_map->is_extensible()) return false;\n\n      Drop(args_count_no_receiver);\n      HValue* result;\n      HValue* reduced_length;\n      HValue* receiver = Pop();\n\n      HValue* checked_object = AddCheckMap(receiver, receiver_map);\n      HValue* length = Add<HLoadNamedField>(\n          checked_object, static_cast<HValue*>(NULL),\n          HObjectAccess::ForArrayLength(elements_kind));\n\n      Drop(1);  // Function.\n\n      { NoObservableSideEffectsScope scope(this);\n        IfBuilder length_checker(this);\n\n        HValue* bounds_check = length_checker.If<HCompareNumericAndBranch>(\n            length, graph()->GetConstant0(), Token::EQ);\n        length_checker.Then();\n\n        if (!ast_context()->IsEffect()) Push(graph()->GetConstantUndefined());\n\n        length_checker.Else();\n        HValue* elements = AddLoadElements(checked_object);\n        // Ensure that we aren't popping from a copy-on-write array.\n        if (IsFastSmiOrObjectElementsKind(elements_kind)) {\n          elements = BuildCopyElementsOnWrite(checked_object, elements,\n                                              elements_kind, length);\n        }\n        reduced_length = AddUncasted<HSub>(length, graph()->GetConstant1());\n        result = AddElementAccess(elements, reduced_length, NULL,\n                                  bounds_check, elements_kind, LOAD);\n        Factory* factory = isolate()->factory();\n        double nan_double = FixedDoubleArray::hole_nan_as_double();\n        HValue* hole = IsFastSmiOrObjectElementsKind(elements_kind)\n            ? Add<HConstant>(factory->the_hole_value())\n            : Add<HConstant>(nan_double);\n        if (IsFastSmiOrObjectElementsKind(elements_kind)) {\n          elements_kind = FAST_HOLEY_ELEMENTS;\n        }\n        AddElementAccess(\n            elements, reduced_length, hole, bounds_check, elements_kind, STORE);\n        Add<HStoreNamedField>(\n            checked_object, HObjectAccess::ForArrayLength(elements_kind),\n            reduced_length, STORE_TO_INITIALIZED_ENTRY);\n\n        if (!ast_context()->IsEffect()) Push(result);\n\n        length_checker.End();\n      }\n      result = ast_context()->IsEffect() ? graph()->GetConstant0() : Top();\n      Add<HSimulate>(expr->id(), REMOVABLE_SIMULATE);\n      if (!ast_context()->IsEffect()) Drop(1);\n\n      ast_context()->ReturnValue(result);\n      return true;\n    }\n    case kArrayPush: {\n      if (receiver_map.is_null()) return false;\n      if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n      ElementsKind elements_kind = receiver_map->elements_kind();\n      if (!IsFastElementsKind(elements_kind)) return false;\n      if (receiver_map->is_observed()) return false;\n      if (JSArray::IsReadOnlyLengthDescriptor(receiver_map)) return false;\n      if (!receiver_map->is_extensible()) return false;\n\n      // If there may be elements accessors in the prototype chain, the fast\n      // inlined version can't be used.\n      if (receiver_map->DictionaryElementsInPrototypeChainOnly()) return false;\n      // If there currently can be no elements accessors on the prototype chain,\n      // it doesn't mean that there won't be any later. Install a full prototype\n      // chain check to trap element accessors being installed on the prototype\n      // chain, which would cause elements to go to dictionary mode and result\n      // in a map change.\n      Handle<JSObject> prototype(JSObject::cast(receiver_map->prototype()));\n      BuildCheckPrototypeMaps(prototype, Handle<JSObject>());\n\n      const int argc = args_count_no_receiver;\n      if (argc != 1) return false;\n\n      HValue* value_to_push = Pop();\n      HValue* array = Pop();\n      Drop(1);  // Drop function.\n\n      HInstruction* new_size = NULL;\n      HValue* length = NULL;\n\n      {\n        NoObservableSideEffectsScope scope(this);\n\n        length = Add<HLoadNamedField>(array, static_cast<HValue*>(NULL),\n          HObjectAccess::ForArrayLength(elements_kind));\n\n        new_size = AddUncasted<HAdd>(length, graph()->GetConstant1());\n\n        bool is_array = receiver_map->instance_type() == JS_ARRAY_TYPE;\n        BuildUncheckedMonomorphicElementAccess(array, length,\n                                               value_to_push, is_array,\n                                               elements_kind, STORE,\n                                               NEVER_RETURN_HOLE,\n                                               STORE_AND_GROW_NO_TRANSITION);\n\n        if (!ast_context()->IsEffect()) Push(new_size);\n        Add<HSimulate>(expr->id(), REMOVABLE_SIMULATE);\n        if (!ast_context()->IsEffect()) Drop(1);\n      }\n\n      ast_context()->ReturnValue(new_size);\n      return true;\n    }\n    case kArrayShift: {\n      if (receiver_map.is_null()) return false;\n      if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n      ElementsKind kind = receiver_map->elements_kind();\n      if (JSArray::IsReadOnlyLengthDescriptor(receiver_map)) return false;\n      if (!IsFastElementsKind(kind)) return false;\n      if (receiver_map->is_observed()) return false;\n      if (!receiver_map->is_extensible()) return false;\n\n      // If there may be elements accessors in the prototype chain, the fast\n      // inlined version can't be used.\n      if (receiver_map->DictionaryElementsInPrototypeChainOnly()) return false;\n\n      // If there currently can be no elements accessors on the prototype chain,\n      // it doesn't mean that there won't be any later. Install a full prototype\n      // chain check to trap element accessors being installed on the prototype\n      // chain, which would cause elements to go to dictionary mode and result\n      // in a map change.\n      BuildCheckPrototypeMaps(\n          handle(JSObject::cast(receiver_map->prototype()), isolate()),\n          Handle<JSObject>::null());\n\n      // Threshold for fast inlined Array.shift().\n      HConstant* inline_threshold = Add<HConstant>(static_cast<int32_t>(16));\n\n      Drop(args_count_no_receiver);\n      HValue* receiver = Pop();\n      HValue* function = Pop();\n      HValue* result;\n\n      {\n        NoObservableSideEffectsScope scope(this);\n\n        HValue* length = Add<HLoadNamedField>(\n            receiver, static_cast<HValue*>(NULL),\n            HObjectAccess::ForArrayLength(kind));\n\n        IfBuilder if_lengthiszero(this);\n        HValue* lengthiszero = if_lengthiszero.If<HCompareNumericAndBranch>(\n            length, graph()->GetConstant0(), Token::EQ);\n        if_lengthiszero.Then();\n        {\n          if (!ast_context()->IsEffect()) Push(graph()->GetConstantUndefined());\n        }\n        if_lengthiszero.Else();\n        {\n          HValue* elements = AddLoadElements(receiver);\n\n          // Check if we can use the fast inlined Array.shift().\n          IfBuilder if_inline(this);\n          if_inline.If<HCompareNumericAndBranch>(\n              length, inline_threshold, Token::LTE);\n          if (IsFastSmiOrObjectElementsKind(kind)) {\n            // We cannot handle copy-on-write backing stores here.\n            if_inline.AndIf<HCompareMap>(\n                elements, isolate()->factory()->fixed_array_map());\n          }\n          if_inline.Then();\n          {\n            // Remember the result.\n            if (!ast_context()->IsEffect()) {\n              Push(AddElementAccess(elements, graph()->GetConstant0(), NULL,\n                                    lengthiszero, kind, LOAD));\n            }\n\n            // Compute the new length.\n            HValue* new_length = AddUncasted<HSub>(\n                length, graph()->GetConstant1());\n            new_length->ClearFlag(HValue::kCanOverflow);\n\n            // Copy the remaining elements.\n            LoopBuilder loop(this, context(), LoopBuilder::kPostIncrement);\n            {\n              HValue* new_key = loop.BeginBody(\n                  graph()->GetConstant0(), new_length, Token::LT);\n              HValue* key = AddUncasted<HAdd>(new_key, graph()->GetConstant1());\n              key->ClearFlag(HValue::kCanOverflow);\n              ElementsKind copy_kind =\n                  kind == FAST_HOLEY_SMI_ELEMENTS ? FAST_HOLEY_ELEMENTS : kind;\n              HValue* element = AddUncasted<HLoadKeyed>(\n                  elements, key, lengthiszero, copy_kind, ALLOW_RETURN_HOLE);\n              HStoreKeyed* store =\n                  Add<HStoreKeyed>(elements, new_key, element, copy_kind);\n              store->SetFlag(HValue::kAllowUndefinedAsNaN);\n            }\n            loop.EndBody();\n\n            // Put a hole at the end.\n            HValue* hole = IsFastSmiOrObjectElementsKind(kind)\n                ? Add<HConstant>(isolate()->factory()->the_hole_value())\n                : Add<HConstant>(FixedDoubleArray::hole_nan_as_double());\n            if (IsFastSmiOrObjectElementsKind(kind)) kind = FAST_HOLEY_ELEMENTS;\n            Add<HStoreKeyed>(\n                elements, new_length, hole, kind, INITIALIZING_STORE);\n\n            // Remember new length.\n            Add<HStoreNamedField>(\n                receiver, HObjectAccess::ForArrayLength(kind),\n                new_length, STORE_TO_INITIALIZED_ENTRY);\n          }\n          if_inline.Else();\n          {\n            Add<HPushArguments>(receiver);\n            result = Add<HCallJSFunction>(function, 1, true);\n            if (!ast_context()->IsEffect()) Push(result);\n          }\n          if_inline.End();\n        }\n        if_lengthiszero.End();\n      }\n      result = ast_context()->IsEffect() ? graph()->GetConstant0() : Top();\n      Add<HSimulate>(expr->id(), REMOVABLE_SIMULATE);\n      if (!ast_context()->IsEffect()) Drop(1);\n      ast_context()->ReturnValue(result);\n      return true;\n    }\n    case kArrayIndexOf:\n    case kArrayLastIndexOf: {\n      if (receiver_map.is_null()) return false;\n      if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n      ElementsKind kind = receiver_map->elements_kind();\n      if (!IsFastElementsKind(kind)) return false;\n      if (receiver_map->is_observed()) return false;\n      if (argument_count != 2) return false;\n      if (!receiver_map->is_extensible()) return false;\n\n      // If there may be elements accessors in the prototype chain, the fast\n      // inlined version can't be used.\n      if (receiver_map->DictionaryElementsInPrototypeChainOnly()) return false;\n\n      // If there currently can be no elements accessors on the prototype chain,\n      // it doesn't mean that there won't be any later. Install a full prototype\n      // chain check to trap element accessors being installed on the prototype\n      // chain, which would cause elements to go to dictionary mode and result\n      // in a map change.\n      BuildCheckPrototypeMaps(\n          handle(JSObject::cast(receiver_map->prototype()), isolate()),\n          Handle<JSObject>::null());\n\n      HValue* search_element = Pop();\n      HValue* receiver = Pop();\n      Drop(1);  // Drop function.\n\n      ArrayIndexOfMode mode = (id == kArrayIndexOf)\n          ? kFirstIndexOf : kLastIndexOf;\n      HValue* index = BuildArrayIndexOf(receiver, search_element, kind, mode);\n\n      if (!ast_context()->IsEffect()) Push(index);\n      Add<HSimulate>(expr->id(), REMOVABLE_SIMULATE);\n      if (!ast_context()->IsEffect()) Drop(1);\n      ast_context()->ReturnValue(index);\n      return true;\n    }\n    default:\n      // Not yet supported for inlining.\n      break;\n  }\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -119,6 +119,7 @@\n       if (receiver_map.is_null()) return false;\n       if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n       ElementsKind elements_kind = receiver_map->elements_kind();\n+      if (JSArray::IsReadOnlyLengthDescriptor(receiver_map)) return false;\n       if (!IsFastElementsKind(elements_kind)) return false;\n       if (receiver_map->is_observed()) return false;\n       if (!receiver_map->is_extensible()) return false;\n@@ -236,6 +237,7 @@\n       if (receiver_map.is_null()) return false;\n       if (receiver_map->instance_type() != JS_ARRAY_TYPE) return false;\n       ElementsKind kind = receiver_map->elements_kind();\n+      if (JSArray::IsReadOnlyLengthDescriptor(receiver_map)) return false;\n       if (!IsFastElementsKind(kind)) return false;\n       if (receiver_map->is_observed()) return false;\n       if (!receiver_map->is_extensible()) return false;\n@@ -308,10 +310,12 @@\n                   graph()->GetConstant0(), new_length, Token::LT);\n               HValue* key = AddUncasted<HAdd>(new_key, graph()->GetConstant1());\n               key->ClearFlag(HValue::kCanOverflow);\n+              ElementsKind copy_kind =\n+                  kind == FAST_HOLEY_SMI_ELEMENTS ? FAST_HOLEY_ELEMENTS : kind;\n               HValue* element = AddUncasted<HLoadKeyed>(\n-                  elements, key, lengthiszero, kind, ALLOW_RETURN_HOLE);\n-              HStoreKeyed* store = Add<HStoreKeyed>(\n-                  elements, new_key, element, kind);\n+                  elements, key, lengthiszero, copy_kind, ALLOW_RETURN_HOLE);\n+              HStoreKeyed* store =\n+                  Add<HStoreKeyed>(elements, new_key, element, copy_kind);\n               store->SetFlag(HValue::kAllowUndefinedAsNaN);\n             }\n             loop.EndBody();",
        "diff_line_info": {
            "deleted_lines": [
                "                  elements, key, lengthiszero, kind, ALLOW_RETURN_HOLE);",
                "              HStoreKeyed* store = Add<HStoreKeyed>(",
                "                  elements, new_key, element, kind);"
            ],
            "added_lines": [
                "      if (JSArray::IsReadOnlyLengthDescriptor(receiver_map)) return false;",
                "      if (JSArray::IsReadOnlyLengthDescriptor(receiver_map)) return false;",
                "              ElementsKind copy_kind =",
                "                  kind == FAST_HOLEY_SMI_ELEMENTS ? FAST_HOLEY_ELEMENTS : kind;",
                "                  elements, key, lengthiszero, copy_kind, ALLOW_RETURN_HOLE);",
                "              HStoreKeyed* store =",
                "                  Add<HStoreKeyed>(elements, new_key, element, copy_kind);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-7928",
        "func_name": "chromium/HOptimizedGraphBuilder::BuildEmitFixedArray",
        "description": "hydrogen.cc in Google V8, as used Google Chrome before 40.0.2214.91, does not properly handle arrays with holes, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted JavaScript code that triggers an array copy.",
        "git_url": "https://chromium.googlesource.com/v8/v8/+/3d58b82addcdc72755539631b1d5dc603a9b2135",
        "commit_title": "Fix for 435073: CHECK failure in CHECK(p->IsSmi()) failed.",
        "commit_text": " The bug was an error when copying arrays in crankshaft. If it's a holey smi array, the copy must be done as FAST_HOLEY_ELEMENTS to prevent representation changes from being inserted that deopt on encountering the hole.  Also, prevent inlining array pop() and shift() if the length is read-only.    ",
        "func_before": "void HOptimizedGraphBuilder::BuildEmitFixedArray(\n    Handle<FixedArrayBase> elements,\n    ElementsKind kind,\n    HValue* object_elements,\n    AllocationSiteUsageContext* site_context) {\n  HInstruction* boilerplate_elements = Add<HConstant>(elements);\n  int elements_length = elements->length();\n  Handle<FixedArray> fast_elements = Handle<FixedArray>::cast(elements);\n  for (int i = 0; i < elements_length; i++) {\n    Handle<Object> value(fast_elements->get(i), isolate());\n    HValue* key_constant = Add<HConstant>(i);\n    if (value->IsJSObject()) {\n      Handle<JSObject> value_object = Handle<JSObject>::cast(value);\n      Handle<AllocationSite> current_site = site_context->EnterNewScope();\n      HInstruction* result =\n          BuildFastLiteral(value_object, site_context);\n      site_context->ExitScope(current_site, value_object);\n      Add<HStoreKeyed>(object_elements, key_constant, result, kind);\n    } else {\n      HInstruction* value_instruction =\n          Add<HLoadKeyed>(boilerplate_elements, key_constant,\n                          static_cast<HValue*>(NULL), kind,\n                          ALLOW_RETURN_HOLE);\n      Add<HStoreKeyed>(object_elements, key_constant, value_instruction, kind);\n    }\n  }\n}",
        "func": "void HOptimizedGraphBuilder::BuildEmitFixedArray(\n    Handle<FixedArrayBase> elements,\n    ElementsKind kind,\n    HValue* object_elements,\n    AllocationSiteUsageContext* site_context) {\n  HInstruction* boilerplate_elements = Add<HConstant>(elements);\n  int elements_length = elements->length();\n  Handle<FixedArray> fast_elements = Handle<FixedArray>::cast(elements);\n  for (int i = 0; i < elements_length; i++) {\n    Handle<Object> value(fast_elements->get(i), isolate());\n    HValue* key_constant = Add<HConstant>(i);\n    if (value->IsJSObject()) {\n      Handle<JSObject> value_object = Handle<JSObject>::cast(value);\n      Handle<AllocationSite> current_site = site_context->EnterNewScope();\n      HInstruction* result =\n          BuildFastLiteral(value_object, site_context);\n      site_context->ExitScope(current_site, value_object);\n      Add<HStoreKeyed>(object_elements, key_constant, result, kind);\n    } else {\n      ElementsKind copy_kind =\n          kind == FAST_HOLEY_SMI_ELEMENTS ? FAST_HOLEY_ELEMENTS : kind;\n      HInstruction* value_instruction = Add<HLoadKeyed>(\n          boilerplate_elements, key_constant, static_cast<HValue*>(NULL),\n          copy_kind, ALLOW_RETURN_HOLE);\n      Add<HStoreKeyed>(object_elements, key_constant, value_instruction,\n                       copy_kind);\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,11 +17,13 @@\n       site_context->ExitScope(current_site, value_object);\n       Add<HStoreKeyed>(object_elements, key_constant, result, kind);\n     } else {\n-      HInstruction* value_instruction =\n-          Add<HLoadKeyed>(boilerplate_elements, key_constant,\n-                          static_cast<HValue*>(NULL), kind,\n-                          ALLOW_RETURN_HOLE);\n-      Add<HStoreKeyed>(object_elements, key_constant, value_instruction, kind);\n+      ElementsKind copy_kind =\n+          kind == FAST_HOLEY_SMI_ELEMENTS ? FAST_HOLEY_ELEMENTS : kind;\n+      HInstruction* value_instruction = Add<HLoadKeyed>(\n+          boilerplate_elements, key_constant, static_cast<HValue*>(NULL),\n+          copy_kind, ALLOW_RETURN_HOLE);\n+      Add<HStoreKeyed>(object_elements, key_constant, value_instruction,\n+                       copy_kind);\n     }\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      HInstruction* value_instruction =",
                "          Add<HLoadKeyed>(boilerplate_elements, key_constant,",
                "                          static_cast<HValue*>(NULL), kind,",
                "                          ALLOW_RETURN_HOLE);",
                "      Add<HStoreKeyed>(object_elements, key_constant, value_instruction, kind);"
            ],
            "added_lines": [
                "      ElementsKind copy_kind =",
                "          kind == FAST_HOLEY_SMI_ELEMENTS ? FAST_HOLEY_ELEMENTS : kind;",
                "      HInstruction* value_instruction = Add<HLoadKeyed>(",
                "          boilerplate_elements, key_constant, static_cast<HValue*>(NULL),",
                "          copy_kind, ALLOW_RETURN_HOLE);",
                "      Add<HStoreKeyed>(object_elements, key_constant, value_instruction,",
                "                       copy_kind);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2190",
        "func_name": "wireshark/hfinfo_number_value_format_display64",
        "description": "epan/proto.c in Wireshark 1.12.x before 1.12.4 does not properly handle integer data types greater than 32 bits in size, which allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted packet that is improperly handled by the LLDP dissector.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d1865e000ebedf49fc0d9f221a11d6af74360837",
        "commit_title": "Make FT_{U}INT{40,48,56,64} handle BASE_CUSTOM.",
        "commit_text": " Finish the job of handling integral values > 32 bits similarly to who we handle values 32 bits or less.  In cases that \"should not happen\", and where we might *not* be executing in the context of a dissector (filling in the field label can be done lazily, being deferred to \"print\" time, and that doesn't happen in the context of a dissector), use g_assert_not_reached() rather than DISSECTOR_ASSERT_NOT_REACHED() - the latter throws an assertion that's not caught if we're not doing dissection, so we crash anyway.  Bug: 10983",
        "func_before": "static const char *\nhfinfo_number_value_format_display64(const header_field_info *hfinfo, int display, char buf[32], guint64 value)\n{\n\tchar *ptr = &buf[31];\n\tgboolean isint = IS_FT_INT(hfinfo->type);\n\n\t*ptr = '\\0';\n\t/* Properly format value */\n\t\tswitch (display) {\n\t\t\tcase BASE_DEC:\n\t\t\t\treturn isint ? int64_to_str_back(ptr, (gint64) value) : uint64_to_str_back(ptr, value);\n\n\t\t\tcase BASE_DEC_HEX:\n\t\t\t\t*(--ptr) = ')';\n\t\t\t\tptr = hex64_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\t\t\t\t*(--ptr) = '(';\n\t\t\t\t*(--ptr) = ' ';\n\t\t\t\tptr = isint ? int64_to_str_back(ptr, (gint64) value) : uint64_to_str_back(ptr, value);\n\t\t\t\treturn ptr;\n\n\t\t\tcase BASE_OCT:\n\t\t\t\treturn oct64_to_str_back(ptr, value);\n\n\t\t\tcase BASE_HEX:\n\t\t\t\treturn hex64_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\n\t\t\tcase BASE_HEX_DEC:\n\t\t\t\t*(--ptr) = ')';\n\t\t\t\tptr = isint ? int64_to_str_back(ptr, (gint64) value) : uint64_to_str_back(ptr, value);\n\t\t\t\t*(--ptr) = '(';\n\t\t\t\t*(--ptr) = ' ';\n\t\t\t\tptr = hex64_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\t\t\t\treturn ptr;\n\n\t\t\tdefault:\n\t\t\t\tDISSECTOR_ASSERT_NOT_REACHED();\n\t\t\t\t;\n\t\t}\n\treturn ptr;\n}",
        "func": "static const char *\nhfinfo_number_value_format_display64(const header_field_info *hfinfo, int display, char buf[32], guint64 value)\n{\n\tchar *ptr = &buf[31];\n\tgboolean isint = IS_FT_INT(hfinfo->type);\n\n\t*ptr = '\\0';\n\t/* Properly format value */\n\t\tswitch (display) {\n\t\t\tcase BASE_DEC:\n\t\t\t\treturn isint ? int64_to_str_back(ptr, (gint64) value) : uint64_to_str_back(ptr, value);\n\n\t\t\tcase BASE_DEC_HEX:\n\t\t\t\t*(--ptr) = ')';\n\t\t\t\tptr = hex64_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\t\t\t\t*(--ptr) = '(';\n\t\t\t\t*(--ptr) = ' ';\n\t\t\t\tptr = isint ? int64_to_str_back(ptr, (gint64) value) : uint64_to_str_back(ptr, value);\n\t\t\t\treturn ptr;\n\n\t\t\tcase BASE_OCT:\n\t\t\t\treturn oct64_to_str_back(ptr, value);\n\n\t\t\tcase BASE_HEX:\n\t\t\t\treturn hex64_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\n\t\t\tcase BASE_HEX_DEC:\n\t\t\t\t*(--ptr) = ')';\n\t\t\t\tptr = isint ? int64_to_str_back(ptr, (gint64) value) : uint64_to_str_back(ptr, value);\n\t\t\t\t*(--ptr) = '(';\n\t\t\t\t*(--ptr) = ' ';\n\t\t\t\tptr = hex64_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\t\t\t\treturn ptr;\n\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached();\n\t\t}\n\treturn ptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,8 +33,7 @@\n \t\t\t\treturn ptr;\n \n \t\t\tdefault:\n-\t\t\t\tDISSECTOR_ASSERT_NOT_REACHED();\n-\t\t\t\t;\n+\t\t\t\tg_assert_not_reached();\n \t\t}\n \treturn ptr;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tDISSECTOR_ASSERT_NOT_REACHED();",
                "\t\t\t\t;"
            ],
            "added_lines": [
                "\t\t\t\tg_assert_not_reached();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2190",
        "func_name": "wireshark/fill_label_number64",
        "description": "epan/proto.c in Wireshark 1.12.x before 1.12.4 does not properly handle integer data types greater than 32 bits in size, which allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted packet that is improperly handled by the LLDP dissector.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d1865e000ebedf49fc0d9f221a11d6af74360837",
        "commit_title": "Make FT_{U}INT{40,48,56,64} handle BASE_CUSTOM.",
        "commit_text": " Finish the job of handling integral values > 32 bits similarly to who we handle values 32 bits or less.  In cases that \"should not happen\", and where we might *not* be executing in the context of a dissector (filling in the field label can be done lazily, being deferred to \"print\" time, and that doesn't happen in the context of a dissector), use g_assert_not_reached() rather than DISSECTOR_ASSERT_NOT_REACHED() - the latter throws an assertion that's not caught if we're not doing dissection, so we crash anyway.  Bug: 10983",
        "func_before": "static void\nfill_label_number64(field_info *fi, gchar *label_str, gboolean is_signed)\n{\n\tconst char        *format = NULL;\n\theader_field_info *hfinfo = fi->hfinfo;\n\tguint64            value;\n\tchar               tmp[ITEM_LABEL_LENGTH+1];\n\n\t/* Pick the proper format string */\n\tif (is_signed) {\n\t\tformat = hfinfo_int64_format(hfinfo);\n\t\tvalue = fvalue_get_sinteger64(&fi->value);\n\t} else {\n\t\tformat = hfinfo_uint64_format(hfinfo);\n\t\tvalue = fvalue_get_uinteger64(&fi->value);\n\t}\n\n\t/* Format the temporary string */\n\tif (IS_BASE_DUAL(hfinfo->display))\n\t\tg_snprintf(tmp, ITEM_LABEL_LENGTH, format, value, value);\n\telse\n\t\tg_snprintf(tmp, ITEM_LABEL_LENGTH, format, value);\n\n\tif (hfinfo->strings) {\n\t\tconst char *val_str = hf_try_val64_to_str_const(value, hfinfo, \"Unknown\");\n\n\t\tif ((hfinfo->display & FIELD_DISPLAY_E_MASK) == BASE_NONE) {\n\t\t\tlabel_fill(label_str, 0, hfinfo, val_str);\n\t\t}\n\t\telse {\n\t\t\tlabel_fill_descr(label_str, 0, hfinfo, val_str, tmp);\n\t\t}\n\t}\n\telse {\n\t\tlabel_fill(label_str, 0, hfinfo, tmp);\n\t}\n}",
        "func": "static void\nfill_label_number64(field_info *fi, gchar *label_str, gboolean is_signed)\n{\n\theader_field_info *hfinfo = fi->hfinfo;\n\tguint64            value;\n\n\tchar               buf[32];\n\tconst char        *out;\n\n\tif (is_signed)\n\t\tvalue = fvalue_get_sinteger64(&fi->value);\n\telse\n\t\tvalue = fvalue_get_uinteger64(&fi->value);\n\n\t/* Fill in the textual info */\n\tif (hfinfo->display == BASE_CUSTOM) {\n\t\tgchar tmp[ITEM_LABEL_LENGTH];\n\t\tconst custom_fmt_func_64_t fmtfunc64 = (const custom_fmt_func_64_t)hfinfo->strings;\n\n\t\tDISSECTOR_ASSERT(fmtfunc64);\n\t\tfmtfunc64(tmp, value);\n\t\tlabel_fill(label_str, 0, hfinfo, tmp);\n\t}\n\telse if (hfinfo->strings) {\n\t\tconst char *val_str = hf_try_val64_to_str_const(value, hfinfo, \"Unknown\");\n\n\t\tout = hfinfo_number_vals_format64(hfinfo, buf, value);\n\t\tif (out == NULL) /* BASE_NONE so don't put integer in descr */\n\t\t\tlabel_fill(label_str, 0, hfinfo, val_str);\n\t\telse\n\t\t\tlabel_fill_descr(label_str, 0, hfinfo, val_str, out);\n\t}\n\telse {\n\t\tout = hfinfo_number_value_format64(hfinfo, buf, value);\n\n\t\tlabel_fill(label_str, 0, hfinfo, out);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,37 +1,38 @@\n static void\n fill_label_number64(field_info *fi, gchar *label_str, gboolean is_signed)\n {\n-\tconst char        *format = NULL;\n \theader_field_info *hfinfo = fi->hfinfo;\n \tguint64            value;\n-\tchar               tmp[ITEM_LABEL_LENGTH+1];\n \n-\t/* Pick the proper format string */\n-\tif (is_signed) {\n-\t\tformat = hfinfo_int64_format(hfinfo);\n+\tchar               buf[32];\n+\tconst char        *out;\n+\n+\tif (is_signed)\n \t\tvalue = fvalue_get_sinteger64(&fi->value);\n-\t} else {\n-\t\tformat = hfinfo_uint64_format(hfinfo);\n+\telse\n \t\tvalue = fvalue_get_uinteger64(&fi->value);\n+\n+\t/* Fill in the textual info */\n+\tif (hfinfo->display == BASE_CUSTOM) {\n+\t\tgchar tmp[ITEM_LABEL_LENGTH];\n+\t\tconst custom_fmt_func_64_t fmtfunc64 = (const custom_fmt_func_64_t)hfinfo->strings;\n+\n+\t\tDISSECTOR_ASSERT(fmtfunc64);\n+\t\tfmtfunc64(tmp, value);\n+\t\tlabel_fill(label_str, 0, hfinfo, tmp);\n \t}\n-\n-\t/* Format the temporary string */\n-\tif (IS_BASE_DUAL(hfinfo->display))\n-\t\tg_snprintf(tmp, ITEM_LABEL_LENGTH, format, value, value);\n-\telse\n-\t\tg_snprintf(tmp, ITEM_LABEL_LENGTH, format, value);\n-\n-\tif (hfinfo->strings) {\n+\telse if (hfinfo->strings) {\n \t\tconst char *val_str = hf_try_val64_to_str_const(value, hfinfo, \"Unknown\");\n \n-\t\tif ((hfinfo->display & FIELD_DISPLAY_E_MASK) == BASE_NONE) {\n+\t\tout = hfinfo_number_vals_format64(hfinfo, buf, value);\n+\t\tif (out == NULL) /* BASE_NONE so don't put integer in descr */\n \t\t\tlabel_fill(label_str, 0, hfinfo, val_str);\n-\t\t}\n-\t\telse {\n-\t\t\tlabel_fill_descr(label_str, 0, hfinfo, val_str, tmp);\n-\t\t}\n+\t\telse\n+\t\t\tlabel_fill_descr(label_str, 0, hfinfo, val_str, out);\n \t}\n \telse {\n-\t\tlabel_fill(label_str, 0, hfinfo, tmp);\n+\t\tout = hfinfo_number_value_format64(hfinfo, buf, value);\n+\n+\t\tlabel_fill(label_str, 0, hfinfo, out);\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tconst char        *format = NULL;",
                "\tchar               tmp[ITEM_LABEL_LENGTH+1];",
                "\t/* Pick the proper format string */",
                "\tif (is_signed) {",
                "\t\tformat = hfinfo_int64_format(hfinfo);",
                "\t} else {",
                "\t\tformat = hfinfo_uint64_format(hfinfo);",
                "",
                "\t/* Format the temporary string */",
                "\tif (IS_BASE_DUAL(hfinfo->display))",
                "\t\tg_snprintf(tmp, ITEM_LABEL_LENGTH, format, value, value);",
                "\telse",
                "\t\tg_snprintf(tmp, ITEM_LABEL_LENGTH, format, value);",
                "",
                "\tif (hfinfo->strings) {",
                "\t\tif ((hfinfo->display & FIELD_DISPLAY_E_MASK) == BASE_NONE) {",
                "\t\t}",
                "\t\telse {",
                "\t\t\tlabel_fill_descr(label_str, 0, hfinfo, val_str, tmp);",
                "\t\t}",
                "\t\tlabel_fill(label_str, 0, hfinfo, tmp);"
            ],
            "added_lines": [
                "\tchar               buf[32];",
                "\tconst char        *out;",
                "",
                "\tif (is_signed)",
                "\telse",
                "",
                "\t/* Fill in the textual info */",
                "\tif (hfinfo->display == BASE_CUSTOM) {",
                "\t\tgchar tmp[ITEM_LABEL_LENGTH];",
                "\t\tconst custom_fmt_func_64_t fmtfunc64 = (const custom_fmt_func_64_t)hfinfo->strings;",
                "",
                "\t\tDISSECTOR_ASSERT(fmtfunc64);",
                "\t\tfmtfunc64(tmp, value);",
                "\t\tlabel_fill(label_str, 0, hfinfo, tmp);",
                "\telse if (hfinfo->strings) {",
                "\t\tout = hfinfo_number_vals_format64(hfinfo, buf, value);",
                "\t\tif (out == NULL) /* BASE_NONE so don't put integer in descr */",
                "\t\telse",
                "\t\t\tlabel_fill_descr(label_str, 0, hfinfo, val_str, out);",
                "\t\tout = hfinfo_number_value_format64(hfinfo, buf, value);",
                "",
                "\t\tlabel_fill(label_str, 0, hfinfo, out);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2190",
        "func_name": "wireshark/hfinfo_number_value_format_display",
        "description": "epan/proto.c in Wireshark 1.12.x before 1.12.4 does not properly handle integer data types greater than 32 bits in size, which allows remote attackers to cause a denial of service (assertion failure and application exit) via a crafted packet that is improperly handled by the LLDP dissector.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d1865e000ebedf49fc0d9f221a11d6af74360837",
        "commit_title": "Make FT_{U}INT{40,48,56,64} handle BASE_CUSTOM.",
        "commit_text": " Finish the job of handling integral values > 32 bits similarly to who we handle values 32 bits or less.  In cases that \"should not happen\", and where we might *not* be executing in the context of a dissector (filling in the field label can be done lazily, being deferred to \"print\" time, and that doesn't happen in the context of a dissector), use g_assert_not_reached() rather than DISSECTOR_ASSERT_NOT_REACHED() - the latter throws an assertion that's not caught if we're not doing dissection, so we crash anyway.  Bug: 10983",
        "func_before": "static const char *\nhfinfo_number_value_format_display(const header_field_info *hfinfo, int display, char buf[32], guint32 value)\n{\n\tchar *ptr = &buf[31];\n\tgboolean isint = IS_FT_INT(hfinfo->type);\n\n\t*ptr = '\\0';\n\t/* Properly format value */\n\t\tswitch (display) {\n\t\t\tcase BASE_DEC:\n\t\t\t\treturn isint ? int_to_str_back(ptr, (gint32) value) : uint_to_str_back(ptr, value);\n\n\t\t\tcase BASE_DEC_HEX:\n\t\t\t\t*(--ptr) = ')';\n\t\t\t\tptr = hex_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\t\t\t\t*(--ptr) = '(';\n\t\t\t\t*(--ptr) = ' ';\n\t\t\t\tptr = isint ? int_to_str_back(ptr, (gint32) value) : uint_to_str_back(ptr, value);\n\t\t\t\treturn ptr;\n\n\t\t\tcase BASE_OCT:\n\t\t\t\treturn oct_to_str_back(ptr, value);\n\n\t\t\tcase BASE_HEX:\n\t\t\t\treturn hex_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\n\t\t\tcase BASE_HEX_DEC:\n\t\t\t\t*(--ptr) = ')';\n\t\t\t\tptr = isint ? int_to_str_back(ptr, (gint32) value) : uint_to_str_back(ptr, value);\n\t\t\t\t*(--ptr) = '(';\n\t\t\t\t*(--ptr) = ' ';\n\t\t\t\tptr = hex_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\t\t\t\treturn ptr;\n\n\t\t\tdefault:\n\t\t\t\tDISSECTOR_ASSERT_NOT_REACHED();\n\t\t\t\t;\n\t\t}\n\treturn ptr;\n}",
        "func": "static const char *\nhfinfo_number_value_format_display(const header_field_info *hfinfo, int display, char buf[32], guint32 value)\n{\n\tchar *ptr = &buf[31];\n\tgboolean isint = IS_FT_INT(hfinfo->type);\n\n\t*ptr = '\\0';\n\t/* Properly format value */\n\t\tswitch (display) {\n\t\t\tcase BASE_DEC:\n\t\t\t\treturn isint ? int_to_str_back(ptr, (gint32) value) : uint_to_str_back(ptr, value);\n\n\t\t\tcase BASE_DEC_HEX:\n\t\t\t\t*(--ptr) = ')';\n\t\t\t\tptr = hex_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\t\t\t\t*(--ptr) = '(';\n\t\t\t\t*(--ptr) = ' ';\n\t\t\t\tptr = isint ? int_to_str_back(ptr, (gint32) value) : uint_to_str_back(ptr, value);\n\t\t\t\treturn ptr;\n\n\t\t\tcase BASE_OCT:\n\t\t\t\treturn oct_to_str_back(ptr, value);\n\n\t\t\tcase BASE_HEX:\n\t\t\t\treturn hex_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\n\t\t\tcase BASE_HEX_DEC:\n\t\t\t\t*(--ptr) = ')';\n\t\t\t\tptr = isint ? int_to_str_back(ptr, (gint32) value) : uint_to_str_back(ptr, value);\n\t\t\t\t*(--ptr) = '(';\n\t\t\t\t*(--ptr) = ' ';\n\t\t\t\tptr = hex_to_str_back(ptr, _hfinfo_type_hex_octet(hfinfo->type), value);\n\t\t\t\treturn ptr;\n\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached();\n\t\t}\n\treturn ptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,8 +33,7 @@\n \t\t\t\treturn ptr;\n \n \t\t\tdefault:\n-\t\t\t\tDISSECTOR_ASSERT_NOT_REACHED();\n-\t\t\t\t;\n+\t\t\t\tg_assert_not_reached();\n \t\t}\n \treturn ptr;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tDISSECTOR_ASSERT_NOT_REACHED();",
                "\t\t\t\t;"
            ],
            "added_lines": [
                "\t\t\t\tg_assert_not_reached();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1229",
        "func_name": "chromium/SpdyProxyClientSocket::DoReadReplyComplete",
        "description": "net/http/proxy_client_socket.cc in Google Chrome before 41.0.2272.76 does not properly handle a 407 (aka Proxy Authentication Required) HTTP status code accompanied by a Set-Cookie header, which allows remote proxy servers to conduct cookie-injection attacks via a crafted response.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7933c117fd16b192e70609c331641e9112af5e42",
        "commit_title": "Sanitize headers in Proxy Authentication Required responses",
        "commit_text": "   ",
        "func_before": "int SpdyProxyClientSocket::DoReadReplyComplete(int result) {\n  // We enter this method directly from DoSendRequestComplete, since\n  // we are notified by a callback when the SYN_REPLY frame arrives\n\n  if (result < 0)\n    return result;\n\n  // Require the \"HTTP/1.x\" status line for SSL CONNECT.\n  if (response_.headers->GetParsedHttpVersion() < HttpVersion(1, 0))\n    return ERR_TUNNEL_CONNECTION_FAILED;\n\n  net_log_.AddEvent(\n      NetLog::TYPE_HTTP_TRANSACTION_READ_TUNNEL_RESPONSE_HEADERS,\n      base::Bind(&HttpResponseHeaders::NetLogCallback, response_.headers));\n\n  switch (response_.headers->response_code()) {\n    case 200:  // OK\n      next_state_ = STATE_OPEN;\n      return OK;\n\n    case 302:  // Found / Moved Temporarily\n      // Try to return a sanitized response so we can follow auth redirects.\n      // If we can't, fail the tunnel connection.\n      if (SanitizeProxyRedirect(&response_, request_.url)) {\n        redirect_has_load_timing_info_ =\n            spdy_stream_->GetLoadTimingInfo(&redirect_load_timing_info_);\n        // Note that this triggers a RST_STREAM_CANCEL.\n        spdy_stream_->DetachDelegate();\n        next_state_ = STATE_DISCONNECTED;\n        return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;\n      } else {\n        LogBlockedTunnelResponse();\n        return ERR_TUNNEL_CONNECTION_FAILED;\n      }\n\n    case 407:  // Proxy Authentication Required\n      next_state_ = STATE_OPEN;\n      return HandleProxyAuthChallenge(auth_.get(), &response_, net_log_);\n\n    default:\n      // Ignore response to avoid letting the proxy impersonate the target\n      // server.  (See http://crbug.com/137891.)\n      LogBlockedTunnelResponse();\n      return ERR_TUNNEL_CONNECTION_FAILED;\n  }\n}",
        "func": "int SpdyProxyClientSocket::DoReadReplyComplete(int result) {\n  // We enter this method directly from DoSendRequestComplete, since\n  // we are notified by a callback when the SYN_REPLY frame arrives\n\n  if (result < 0)\n    return result;\n\n  // Require the \"HTTP/1.x\" status line for SSL CONNECT.\n  if (response_.headers->GetParsedHttpVersion() < HttpVersion(1, 0))\n    return ERR_TUNNEL_CONNECTION_FAILED;\n\n  net_log_.AddEvent(\n      NetLog::TYPE_HTTP_TRANSACTION_READ_TUNNEL_RESPONSE_HEADERS,\n      base::Bind(&HttpResponseHeaders::NetLogCallback, response_.headers));\n\n  switch (response_.headers->response_code()) {\n    case 200:  // OK\n      next_state_ = STATE_OPEN;\n      return OK;\n\n    case 302:  // Found / Moved Temporarily\n      // Try to return a sanitized response so we can follow auth redirects.\n      // If we can't, fail the tunnel connection.\n      if (!SanitizeProxyRedirect(&response_)) {\n        LogBlockedTunnelResponse();\n        return ERR_TUNNEL_CONNECTION_FAILED;\n      }\n\n      redirect_has_load_timing_info_ =\n          spdy_stream_->GetLoadTimingInfo(&redirect_load_timing_info_);\n      // Note that this triggers a RST_STREAM_CANCEL.\n      spdy_stream_->DetachDelegate();\n      next_state_ = STATE_DISCONNECTED;\n      return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;\n\n    case 407:  // Proxy Authentication Required\n      next_state_ = STATE_OPEN;\n      if (!SanitizeProxyAuth(&response_)) {\n        LogBlockedTunnelResponse();\n        return ERR_TUNNEL_CONNECTION_FAILED;\n      }\n      return HandleProxyAuthChallenge(auth_.get(), &response_, net_log_);\n\n    default:\n      // Ignore response to avoid letting the proxy impersonate the target\n      // server.  (See http://crbug.com/137891.)\n      LogBlockedTunnelResponse();\n      return ERR_TUNNEL_CONNECTION_FAILED;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,20 +21,24 @@\n     case 302:  // Found / Moved Temporarily\n       // Try to return a sanitized response so we can follow auth redirects.\n       // If we can't, fail the tunnel connection.\n-      if (SanitizeProxyRedirect(&response_, request_.url)) {\n-        redirect_has_load_timing_info_ =\n-            spdy_stream_->GetLoadTimingInfo(&redirect_load_timing_info_);\n-        // Note that this triggers a RST_STREAM_CANCEL.\n-        spdy_stream_->DetachDelegate();\n-        next_state_ = STATE_DISCONNECTED;\n-        return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;\n-      } else {\n+      if (!SanitizeProxyRedirect(&response_)) {\n         LogBlockedTunnelResponse();\n         return ERR_TUNNEL_CONNECTION_FAILED;\n       }\n \n+      redirect_has_load_timing_info_ =\n+          spdy_stream_->GetLoadTimingInfo(&redirect_load_timing_info_);\n+      // Note that this triggers a RST_STREAM_CANCEL.\n+      spdy_stream_->DetachDelegate();\n+      next_state_ = STATE_DISCONNECTED;\n+      return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;\n+\n     case 407:  // Proxy Authentication Required\n       next_state_ = STATE_OPEN;\n+      if (!SanitizeProxyAuth(&response_)) {\n+        LogBlockedTunnelResponse();\n+        return ERR_TUNNEL_CONNECTION_FAILED;\n+      }\n       return HandleProxyAuthChallenge(auth_.get(), &response_, net_log_);\n \n     default:",
        "diff_line_info": {
            "deleted_lines": [
                "      if (SanitizeProxyRedirect(&response_, request_.url)) {",
                "        redirect_has_load_timing_info_ =",
                "            spdy_stream_->GetLoadTimingInfo(&redirect_load_timing_info_);",
                "        // Note that this triggers a RST_STREAM_CANCEL.",
                "        spdy_stream_->DetachDelegate();",
                "        next_state_ = STATE_DISCONNECTED;",
                "        return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;",
                "      } else {"
            ],
            "added_lines": [
                "      if (!SanitizeProxyRedirect(&response_)) {",
                "      redirect_has_load_timing_info_ =",
                "          spdy_stream_->GetLoadTimingInfo(&redirect_load_timing_info_);",
                "      // Note that this triggers a RST_STREAM_CANCEL.",
                "      spdy_stream_->DetachDelegate();",
                "      next_state_ = STATE_DISCONNECTED;",
                "      return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;",
                "",
                "      if (!SanitizeProxyAuth(&response_)) {",
                "        LogBlockedTunnelResponse();",
                "        return ERR_TUNNEL_CONNECTION_FAILED;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1229",
        "func_name": "chromium/ProxyClientSocket::SanitizeProxyRedirect",
        "description": "net/http/proxy_client_socket.cc in Google Chrome before 41.0.2272.76 does not properly handle a 407 (aka Proxy Authentication Required) HTTP status code accompanied by a Set-Cookie header, which allows remote proxy servers to conduct cookie-injection attacks via a crafted response.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7933c117fd16b192e70609c331641e9112af5e42",
        "commit_title": "Sanitize headers in Proxy Authentication Required responses",
        "commit_text": "   ",
        "func_before": "bool ProxyClientSocket::SanitizeProxyRedirect(HttpResponseInfo* response,\n                                              const GURL& url) {\n  DCHECK(response && response->headers.get());\n\n  std::string location;\n  if (!response->headers->IsRedirect(&location))\n    return false;\n\n  // Return minimal headers; set \"Content-length: 0\" to ignore response body.\n  std::string fake_response_headers =\n      base::StringPrintf(\"HTTP/1.0 302 Found\\n\"\n                         \"Location: %s\\n\"\n                         \"Content-length: 0\\n\"\n                         \"Connection: close\\n\"\n                         \"\\n\",\n                         location.c_str());\n  std::string raw_headers =\n      HttpUtil::AssembleRawHeaders(fake_response_headers.data(),\n                                   fake_response_headers.length());\n  response->headers = new HttpResponseHeaders(raw_headers);\n\n  return true;\n}",
        "func": "bool ProxyClientSocket::SanitizeProxyRedirect(HttpResponseInfo* response) {\n  DCHECK(response && response->headers.get());\n\n  std::string location;\n  if (!response->headers->IsRedirect(&location))\n    return false;\n\n  // Return minimal headers; set \"Content-Length: 0\" to ignore response body.\n  std::string fake_response_headers = base::StringPrintf(\n      \"HTTP/1.0 302 Found\\n\"\n      \"Location: %s\\n\"\n      \"Content-Length: 0\\n\"\n      \"Connection: close\\n\"\n      \"\\n\",\n      location.c_str());\n  std::string raw_headers =\n      HttpUtil::AssembleRawHeaders(fake_response_headers.data(),\n                                   fake_response_headers.length());\n  response->headers = new HttpResponseHeaders(raw_headers);\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,19 +1,18 @@\n-bool ProxyClientSocket::SanitizeProxyRedirect(HttpResponseInfo* response,\n-                                              const GURL& url) {\n+bool ProxyClientSocket::SanitizeProxyRedirect(HttpResponseInfo* response) {\n   DCHECK(response && response->headers.get());\n \n   std::string location;\n   if (!response->headers->IsRedirect(&location))\n     return false;\n \n-  // Return minimal headers; set \"Content-length: 0\" to ignore response body.\n-  std::string fake_response_headers =\n-      base::StringPrintf(\"HTTP/1.0 302 Found\\n\"\n-                         \"Location: %s\\n\"\n-                         \"Content-length: 0\\n\"\n-                         \"Connection: close\\n\"\n-                         \"\\n\",\n-                         location.c_str());\n+  // Return minimal headers; set \"Content-Length: 0\" to ignore response body.\n+  std::string fake_response_headers = base::StringPrintf(\n+      \"HTTP/1.0 302 Found\\n\"\n+      \"Location: %s\\n\"\n+      \"Content-Length: 0\\n\"\n+      \"Connection: close\\n\"\n+      \"\\n\",\n+      location.c_str());\n   std::string raw_headers =\n       HttpUtil::AssembleRawHeaders(fake_response_headers.data(),\n                                    fake_response_headers.length());",
        "diff_line_info": {
            "deleted_lines": [
                "bool ProxyClientSocket::SanitizeProxyRedirect(HttpResponseInfo* response,",
                "                                              const GURL& url) {",
                "  // Return minimal headers; set \"Content-length: 0\" to ignore response body.",
                "  std::string fake_response_headers =",
                "      base::StringPrintf(\"HTTP/1.0 302 Found\\n\"",
                "                         \"Location: %s\\n\"",
                "                         \"Content-length: 0\\n\"",
                "                         \"Connection: close\\n\"",
                "                         \"\\n\",",
                "                         location.c_str());"
            ],
            "added_lines": [
                "bool ProxyClientSocket::SanitizeProxyRedirect(HttpResponseInfo* response) {",
                "  // Return minimal headers; set \"Content-Length: 0\" to ignore response body.",
                "  std::string fake_response_headers = base::StringPrintf(",
                "      \"HTTP/1.0 302 Found\\n\"",
                "      \"Location: %s\\n\"",
                "      \"Content-Length: 0\\n\"",
                "      \"Connection: close\\n\"",
                "      \"\\n\",",
                "      location.c_str());"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1229",
        "func_name": "chromium/HttpProxyClientSocket::DoReadHeadersComplete",
        "description": "net/http/proxy_client_socket.cc in Google Chrome before 41.0.2272.76 does not properly handle a 407 (aka Proxy Authentication Required) HTTP status code accompanied by a Set-Cookie header, which allows remote proxy servers to conduct cookie-injection attacks via a crafted response.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7933c117fd16b192e70609c331641e9112af5e42",
        "commit_title": "Sanitize headers in Proxy Authentication Required responses",
        "commit_text": "   ",
        "func_before": "int HttpProxyClientSocket::DoReadHeadersComplete(int result) {\n  if (result < 0)\n    return result;\n\n  // Require the \"HTTP/1.x\" status line for SSL CONNECT.\n  if (response_.headers->GetParsedHttpVersion() < HttpVersion(1, 0))\n    return ERR_TUNNEL_CONNECTION_FAILED;\n\n  net_log_.AddEvent(\n      NetLog::TYPE_HTTP_TRANSACTION_READ_TUNNEL_RESPONSE_HEADERS,\n      base::Bind(&HttpResponseHeaders::NetLogCallback, response_.headers));\n\n  if (proxy_delegate_) {\n    proxy_delegate_->OnTunnelHeadersReceived(\n        HostPortPair::FromURL(request_.url),\n        proxy_server_,\n        *response_.headers);\n  }\n\n  switch (response_.headers->response_code()) {\n    case 200:  // OK\n      if (http_stream_parser_->IsMoreDataBuffered())\n        // The proxy sent extraneous data after the headers.\n        return ERR_TUNNEL_CONNECTION_FAILED;\n\n      next_state_ = STATE_DONE;\n      return OK;\n\n      // We aren't able to CONNECT to the remote host through the proxy.  We\n      // need to be very suspicious about the response because an active network\n      // attacker can force us into this state by masquerading as the proxy.\n      // The only safe thing to do here is to fail the connection because our\n      // client is expecting an SSL protected response.\n      // See http://crbug.com/7338.\n\n    case 302:  // Found / Moved Temporarily\n      // Attempt to follow redirects from HTTPS proxies, but only if we can\n      // sanitize the response.  This still allows a rogue HTTPS proxy to\n      // redirect an HTTPS site load to a similar-looking site, but no longer\n      // allows it to impersonate the site the user requested.\n      if (is_https_proxy_ && SanitizeProxyRedirect(&response_, request_.url)) {\n        bool is_connection_reused = http_stream_parser_->IsConnectionReused();\n        redirect_has_load_timing_info_ =\n            transport_->GetLoadTimingInfo(\n                is_connection_reused, &redirect_load_timing_info_);\n        transport_.reset();\n        http_stream_parser_.reset();\n        return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;\n      }\n\n      // We're not using an HTTPS proxy, or we couldn't sanitize the redirect.\n      LogBlockedTunnelResponse();\n      return ERR_TUNNEL_CONNECTION_FAILED;\n\n    case 407:  // Proxy Authentication Required\n      // We need this status code to allow proxy authentication.  Our\n      // authentication code is smart enough to avoid being tricked by an\n      // active network attacker.\n      // The next state is intentionally not set as it should be STATE_NONE;\n      return HandleProxyAuthChallenge(auth_.get(), &response_, net_log_);\n\n    default:\n      // Ignore response to avoid letting the proxy impersonate the target\n      // server.  (See http://crbug.com/137891.)\n      // We lose something by doing this.  We have seen proxy 403, 404, and\n      // 501 response bodies that contain a useful error message.  For\n      // example, Squid uses a 404 response to report the DNS error: \"The\n      // domain name does not exist.\"\n      LogBlockedTunnelResponse();\n      return ERR_TUNNEL_CONNECTION_FAILED;\n  }\n}",
        "func": "int HttpProxyClientSocket::DoReadHeadersComplete(int result) {\n  if (result < 0)\n    return result;\n\n  // Require the \"HTTP/1.x\" status line for SSL CONNECT.\n  if (response_.headers->GetParsedHttpVersion() < HttpVersion(1, 0))\n    return ERR_TUNNEL_CONNECTION_FAILED;\n\n  net_log_.AddEvent(\n      NetLog::TYPE_HTTP_TRANSACTION_READ_TUNNEL_RESPONSE_HEADERS,\n      base::Bind(&HttpResponseHeaders::NetLogCallback, response_.headers));\n\n  if (proxy_delegate_) {\n    proxy_delegate_->OnTunnelHeadersReceived(\n        HostPortPair::FromURL(request_.url),\n        proxy_server_,\n        *response_.headers);\n  }\n\n  switch (response_.headers->response_code()) {\n    case 200:  // OK\n      if (http_stream_parser_->IsMoreDataBuffered())\n        // The proxy sent extraneous data after the headers.\n        return ERR_TUNNEL_CONNECTION_FAILED;\n\n      next_state_ = STATE_DONE;\n      return OK;\n\n      // We aren't able to CONNECT to the remote host through the proxy.  We\n      // need to be very suspicious about the response because an active network\n      // attacker can force us into this state by masquerading as the proxy.\n      // The only safe thing to do here is to fail the connection because our\n      // client is expecting an SSL protected response.\n      // See http://crbug.com/7338.\n\n    case 302:  // Found / Moved Temporarily\n      // Attempt to follow redirects from HTTPS proxies, but only if we can\n      // sanitize the response.  This still allows a rogue HTTPS proxy to\n      // redirect an HTTPS site load to a similar-looking site, but no longer\n      // allows it to impersonate the site the user requested.\n      if (!is_https_proxy_ || !SanitizeProxyRedirect(&response_)) {\n        LogBlockedTunnelResponse();\n        return ERR_TUNNEL_CONNECTION_FAILED;\n      }\n\n      redirect_has_load_timing_info_ = transport_->GetLoadTimingInfo(\n          http_stream_parser_->IsConnectionReused(),\n          &redirect_load_timing_info_);\n      transport_.reset();\n      http_stream_parser_.reset();\n      return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;\n\n    case 407:  // Proxy Authentication Required\n      // We need this status code to allow proxy authentication.  Our\n      // authentication code is smart enough to avoid being tricked by an\n      // active network attacker.\n      // The next state is intentionally not set as it should be STATE_NONE;\n      if (!SanitizeProxyAuth(&response_)) {\n        LogBlockedTunnelResponse();\n        return ERR_TUNNEL_CONNECTION_FAILED;\n      }\n      return HandleProxyAuthChallenge(auth_.get(), &response_, net_log_);\n\n    default:\n      // Ignore response to avoid letting the proxy impersonate the target\n      // server.  (See http://crbug.com/137891.)\n      // We lose something by doing this.  We have seen proxy 403, 404, and\n      // 501 response bodies that contain a useful error message.  For\n      // example, Squid uses a 404 response to report the DNS error: \"The\n      // domain name does not exist.\"\n      LogBlockedTunnelResponse();\n      return ERR_TUNNEL_CONNECTION_FAILED;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,25 +38,27 @@\n       // sanitize the response.  This still allows a rogue HTTPS proxy to\n       // redirect an HTTPS site load to a similar-looking site, but no longer\n       // allows it to impersonate the site the user requested.\n-      if (is_https_proxy_ && SanitizeProxyRedirect(&response_, request_.url)) {\n-        bool is_connection_reused = http_stream_parser_->IsConnectionReused();\n-        redirect_has_load_timing_info_ =\n-            transport_->GetLoadTimingInfo(\n-                is_connection_reused, &redirect_load_timing_info_);\n-        transport_.reset();\n-        http_stream_parser_.reset();\n-        return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;\n+      if (!is_https_proxy_ || !SanitizeProxyRedirect(&response_)) {\n+        LogBlockedTunnelResponse();\n+        return ERR_TUNNEL_CONNECTION_FAILED;\n       }\n \n-      // We're not using an HTTPS proxy, or we couldn't sanitize the redirect.\n-      LogBlockedTunnelResponse();\n-      return ERR_TUNNEL_CONNECTION_FAILED;\n+      redirect_has_load_timing_info_ = transport_->GetLoadTimingInfo(\n+          http_stream_parser_->IsConnectionReused(),\n+          &redirect_load_timing_info_);\n+      transport_.reset();\n+      http_stream_parser_.reset();\n+      return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;\n \n     case 407:  // Proxy Authentication Required\n       // We need this status code to allow proxy authentication.  Our\n       // authentication code is smart enough to avoid being tricked by an\n       // active network attacker.\n       // The next state is intentionally not set as it should be STATE_NONE;\n+      if (!SanitizeProxyAuth(&response_)) {\n+        LogBlockedTunnelResponse();\n+        return ERR_TUNNEL_CONNECTION_FAILED;\n+      }\n       return HandleProxyAuthChallenge(auth_.get(), &response_, net_log_);\n \n     default:",
        "diff_line_info": {
            "deleted_lines": [
                "      if (is_https_proxy_ && SanitizeProxyRedirect(&response_, request_.url)) {",
                "        bool is_connection_reused = http_stream_parser_->IsConnectionReused();",
                "        redirect_has_load_timing_info_ =",
                "            transport_->GetLoadTimingInfo(",
                "                is_connection_reused, &redirect_load_timing_info_);",
                "        transport_.reset();",
                "        http_stream_parser_.reset();",
                "        return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;",
                "      // We're not using an HTTPS proxy, or we couldn't sanitize the redirect.",
                "      LogBlockedTunnelResponse();",
                "      return ERR_TUNNEL_CONNECTION_FAILED;"
            ],
            "added_lines": [
                "      if (!is_https_proxy_ || !SanitizeProxyRedirect(&response_)) {",
                "        LogBlockedTunnelResponse();",
                "        return ERR_TUNNEL_CONNECTION_FAILED;",
                "      redirect_has_load_timing_info_ = transport_->GetLoadTimingInfo(",
                "          http_stream_parser_->IsConnectionReused(),",
                "          &redirect_load_timing_info_);",
                "      transport_.reset();",
                "      http_stream_parser_.reset();",
                "      return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;",
                "      if (!SanitizeProxyAuth(&response_)) {",
                "        LogBlockedTunnelResponse();",
                "        return ERR_TUNNEL_CONNECTION_FAILED;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr_calc_size",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "STATIC int\nxfs_attr_calc_size(\n\tstruct xfs_inode \t*ip,\n\tint\t\t\tnamelen,\n\tint\t\t\tvaluelen,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount \t*mp = ip->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\t/*\n\t * Determine space new attribute will use, and if it would be\n\t * \"local\" or \"remote\" (note: local != inline).\n\t */\n\tsize = xfs_attr_leaf_newentsize(namelen, valuelen,\n\t\t\t\t\tmp->m_sb.sb_blocksize, local);\n\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (mp->m_sb.sb_blocksize >> 1)) {\n\t\t\t/* Double split possible */\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Out of line attribute, cannot double split, but\n\t\t * make room for the attribute value itself.\n\t\t */\n\t\tuint\tdblocks = XFS_B_TO_FSB(mp, valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}",
        "func": "STATIC int\nxfs_attr_calc_size(\n\tstruct xfs_inode \t*ip,\n\tint\t\t\tnamelen,\n\tint\t\t\tvaluelen,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount \t*mp = ip->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\t/*\n\t * Determine space new attribute will use, and if it would be\n\t * \"local\" or \"remote\" (note: local != inline).\n\t */\n\tsize = xfs_attr_leaf_newentsize(namelen, valuelen,\n\t\t\t\t\tmp->m_sb.sb_blocksize, local);\n\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (mp->m_sb.sb_blocksize >> 1)) {\n\t\t\t/* Double split possible */\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Out of line attribute, cannot double split, but\n\t\t * make room for the attribute value itself.\n\t\t */\n\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n \t\t * Out of line attribute, cannot double split, but\n \t\t * make room for the attribute value itself.\n \t\t */\n-\t\tuint\tdblocks = XFS_B_TO_FSB(mp, valuelen);\n+\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, valuelen);\n \t\tnblks += dblocks;\n \t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tuint\tdblocks = XFS_B_TO_FSB(mp, valuelen);"
            ],
            "added_lines": [
                "\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, valuelen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr_node_addname",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "STATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint committed, retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\tstate->blocksize = state->mp->m_sb.sb_blocksize;\n\tstate->node_ents = state->mp->m_attr_node_ents;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->blocksize = state->mp->m_sb.sb_blocksize;\n\t\tstate->node_ents = state->mp->m_attr_node_ents;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn(error);\n\treturn(retval);\n}",
        "func": "STATIC int\nxfs_attr_node_addname(xfs_da_args_t *args)\n{\n\txfs_da_state_t *state;\n\txfs_da_state_blk_t *blk;\n\txfs_inode_t *dp;\n\txfs_mount_t *mp;\n\tint committed, retval, error;\n\n\ttrace_xfs_attr_node_addname(args);\n\n\t/*\n\t * Fill in bucket of arguments/results/context to carry around.\n\t */\n\tdp = args->dp;\n\tmp = dp->i_mount;\nrestart:\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = mp;\n\tstate->blocksize = state->mp->m_sb.sb_blocksize;\n\tstate->node_ents = state->mp->m_attr_node_ents;\n\n\t/*\n\t * Search to see if name already exists, and get back a pointer\n\t * to where it should go.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &retval);\n\tif (error)\n\t\tgoto out;\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\tif ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {\n\t\tgoto out;\n\t} else if (retval == EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\tgoto out;\n\n\t\ttrace_xfs_attr_node_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n\tif (retval == ENOSPC) {\n\t\tif (state->path.active == 1) {\n\t\t\t/*\n\t\t\t * Its really a single leaf node, but it had\n\t\t\t * out-of-line values so it looked like it *might*\n\t\t\t * have been a b-tree.\n\t\t\t */\n\t\t\txfs_da_state_free(state);\n\t\t\tstate = NULL;\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_node(args);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t\t/*\n\t\t\t * Commit the node conversion and start the next\n\t\t\t * trans in the chain.\n\t\t\t */\n\t\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tgoto restart;\n\t\t}\n\n\t\t/*\n\t\t * Split as many Btree elements as required.\n\t\t * This code tracks the new and old attr's location\n\t\t * in the index/blkno/rmtblkno/rmtblkcnt fields and\n\t\t * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_da3_split(state);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t} else {\n\t\t/*\n\t\t * Addition succeeded, update Btree hashvals.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\n\t/*\n\t * Kill the state structure, we're done with it and need to\n\t * allow the buffers to come back later.\n\t */\n\txfs_da_state_free(state);\n\tstate = NULL;\n\n\t/*\n\t * Commit the leaf addition or btree split and start the next\n\t * trans in the chain.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * Re-find the \"old\" attribute entry after any split ops.\n\t\t * The INCOMPLETE flag means that we will find the \"old\"\n\t\t * attr, not the \"new\" one.\n\t\t */\n\t\targs->flags |= XFS_ATTR_INCOMPLETE;\n\t\tstate = xfs_da_state_alloc();\n\t\tstate->args = args;\n\t\tstate->mp = mp;\n\t\tstate->blocksize = state->mp->m_sb.sb_blocksize;\n\t\tstate->node_ents = state->mp->m_attr_node_ents;\n\t\tstate->inleaf = 0;\n\t\terror = xfs_da3_node_lookup_int(state, &retval);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Remove the name and update the hashvals in the tree.\n\t\t */\n\t\tblk = &state->path.blk[ state->path.active-1 ];\n\t\tASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\n\t\terror = xfs_attr3_leaf_remove(blk->bp, args);\n\t\txfs_da3_fixhashpath(state, &state->path);\n\n\t\t/*\n\t\t * Check to see if the tree needs to be collapsed.\n\t\t */\n\t\tif (retval && (state->path.active > 1)) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_da3_join(state);\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit and start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tretval = error = 0;\n\nout:\n\tif (state)\n\t\txfs_da_state_free(state);\n\tif (error)\n\t\treturn(error);\n\treturn(retval);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,13 +38,22 @@\n \n \t\ttrace_xfs_attr_node_replace(args);\n \n+\t\t/* save the attribute state for later removal*/\n \t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* atomic rename op */\n \t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n \t\targs->index2 = args->index;\n \t\targs->rmtblkno2 = args->rmtblkno;\n \t\targs->rmtblkcnt2 = args->rmtblkcnt;\n+\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n+\n+\t\t/*\n+\t\t * clear the remote attr state now that it is saved so that the\n+\t\t * values reflect the state of the attribute we are about to\n+\t\t * add, not the attribute we just found and will remove later.\n+\t\t */\n \t\targs->rmtblkno = 0;\n \t\targs->rmtblkcnt = 0;\n+\t\targs->rmtvaluelen = 0;\n \t}\n \n \tretval = xfs_attr3_leaf_add(blk->bp, state->args);\n@@ -172,6 +181,7 @@\n \t\targs->blkno = args->blkno2;\n \t\targs->rmtblkno = args->rmtblkno2;\n \t\targs->rmtblkcnt = args->rmtblkcnt2;\n+\t\targs->rmtvaluelen = args->rmtvaluelen2;\n \t\tif (args->rmtblkno) {\n \t\t\terror = xfs_attr_rmtval_remove(args);\n \t\t\tif (error)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/* save the attribute state for later removal*/",
                "\t\targs->rmtvaluelen2 = args->rmtvaluelen;",
                "",
                "\t\t/*",
                "\t\t * clear the remote attr state now that it is saved so that the",
                "\t\t * values reflect the state of the attribute we are about to",
                "\t\t * add, not the attribute we just found and will remove later.",
                "\t\t */",
                "\t\targs->rmtvaluelen = 0;",
                "\t\targs->rmtvaluelen = args->rmtvaluelen2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr_leaf_addname",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "STATIC int\nxfs_attr_leaf_addname(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_addname(args);\n\n\t/*\n\t * Read the (only) block in the attribute list in.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the given attribute in the leaf block.  Figure out if\n\t * the given flags produce an error or call for an atomic rename.\n\t */\n\tretval = xfs_attr3_leaf_lookup_int(bp, args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn retval;\n\t} else if (retval == EEXIST) {\n\t\tif (args->flags & ATTR_CREATE) {\t/* pure create op */\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t\t\treturn retval;\n\t\t}\n\n\t\ttrace_xfs_attr_leaf_replace(args);\n\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* an atomic rename */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t}\n\n\t/*\n\t * Add the attribute to the leaf block, transitioning to a Btree\n\t * if required.\n\t */\n\tretval = xfs_attr3_leaf_add(bp, args);\n\tif (retval == ENOSPC) {\n\t\t/*\n\t\t * Promote the attribute list to the Btree format, then\n\t\t * Commit that transaction so that the node_addname() call\n\t\t * can manage its own transactions.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the current trans (including the inode) and start\n\t\t * a new one.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * Fob the whole rest of the problem off on the Btree code.\n\t\t */\n\t\terror = xfs_attr_node_addname(args);\n\t\treturn(error);\n\t}\n\n\t/*\n\t * Commit the transaction that added the attr name so that\n\t * later routines can manage their own transactions.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\treturn (error);\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\treturn(error);\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * Read in the block containing the \"old\" attr, then\n\t\t * remove the \"old\" attr from that block (neat, huh!)\n\t\t */\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\n\t\t\t\t\t   -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_remove(bp, args);\n\n\t\t/*\n\t\t * If the result is small enough, shrink it all into the inode.\n\t\t */\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\treturn(error);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit the remove and start the next trans in series.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t}\n\treturn error;\n}",
        "func": "STATIC int\nxfs_attr_leaf_addname(xfs_da_args_t *args)\n{\n\txfs_inode_t *dp;\n\tstruct xfs_buf *bp;\n\tint retval, error, committed, forkoff;\n\n\ttrace_xfs_attr_leaf_addname(args);\n\n\t/*\n\t * Read the (only) block in the attribute list in.\n\t */\n\tdp = args->dp;\n\targs->blkno = 0;\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the given attribute in the leaf block.  Figure out if\n\t * the given flags produce an error or call for an atomic rename.\n\t */\n\tretval = xfs_attr3_leaf_lookup_int(bp, args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {\n\t\txfs_trans_brelse(args->trans, bp);\n\t\treturn retval;\n\t} else if (retval == EEXIST) {\n\t\tif (args->flags & ATTR_CREATE) {\t/* pure create op */\n\t\t\txfs_trans_brelse(args->trans, bp);\n\t\t\treturn retval;\n\t\t}\n\n\t\ttrace_xfs_attr_leaf_replace(args);\n\n\t\t/* save the attribute state for later removal*/\n\t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* an atomic rename */\n\t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n\t\targs->index2 = args->index;\n\t\targs->rmtblkno2 = args->rmtblkno;\n\t\targs->rmtblkcnt2 = args->rmtblkcnt;\n\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n\n\t\t/*\n\t\t * clear the remote attr state now that it is saved so that the\n\t\t * values reflect the state of the attribute we are about to\n\t\t * add, not the attribute we just found and will remove later.\n\t\t */\n\t\targs->rmtblkno = 0;\n\t\targs->rmtblkcnt = 0;\n\t\targs->rmtvaluelen = 0;\n\t}\n\n\t/*\n\t * Add the attribute to the leaf block, transitioning to a Btree\n\t * if required.\n\t */\n\tretval = xfs_attr3_leaf_add(bp, args);\n\tif (retval == ENOSPC) {\n\t\t/*\n\t\t * Promote the attribute list to the Btree format, then\n\t\t * Commit that transaction so that the node_addname() call\n\t\t * can manage its own transactions.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\terror = xfs_attr3_leaf_to_node(args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the current trans (including the inode) and start\n\t\t * a new one.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * Fob the whole rest of the problem off on the Btree code.\n\t\t */\n\t\terror = xfs_attr_node_addname(args);\n\t\treturn(error);\n\t}\n\n\t/*\n\t * Commit the transaction that added the attr name so that\n\t * later routines can manage their own transactions.\n\t */\n\terror = xfs_trans_roll(&args->trans, dp);\n\tif (error)\n\t\treturn (error);\n\n\t/*\n\t * If there was an out-of-line value, allocate the blocks we\n\t * identified for its storage and copy the value.  This is done\n\t * after we create the attribute so that we don't overflow the\n\t * maximum size of a transaction and/or hit a deadlock.\n\t */\n\tif (args->rmtblkno > 0) {\n\t\terror = xfs_attr_rmtval_set(args);\n\t\tif (error)\n\t\t\treturn(error);\n\t}\n\n\t/*\n\t * If this is an atomic rename operation, we must \"flip\" the\n\t * incomplete flags on the \"new\" and \"old\" attribute/value pairs\n\t * so that one disappears and one appears atomically.  Then we\n\t * must remove the \"old\" attribute/value pair.\n\t */\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\t/*\n\t\t * In a separate transaction, set the incomplete flag on the\n\t\t * \"old\" attr and clear the incomplete flag on the \"new\" attr.\n\t\t */\n\t\terror = xfs_attr3_leaf_flipflags(args);\n\t\tif (error)\n\t\t\treturn(error);\n\n\t\t/*\n\t\t * Dismantle the \"old\" attribute/value pair by removing\n\t\t * a \"remote\" value (if it exists).\n\t\t */\n\t\targs->index = args->index2;\n\t\targs->blkno = args->blkno2;\n\t\targs->rmtblkno = args->rmtblkno2;\n\t\targs->rmtblkcnt = args->rmtblkcnt2;\n\t\targs->rmtvaluelen = args->rmtvaluelen2;\n\t\tif (args->rmtblkno) {\n\t\t\terror = xfs_attr_rmtval_remove(args);\n\t\t\tif (error)\n\t\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * Read in the block containing the \"old\" attr, then\n\t\t * remove the \"old\" attr from that block (neat, huh!)\n\t\t */\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\n\t\t\t\t\t   -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_remove(bp, args);\n\n\t\t/*\n\t\t * If the result is small enough, shrink it all into the inode.\n\t\t */\n\t\tif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\n\t\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\t\terror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\n\t\t\t/* bp is gone due to xfs_da_shrink_inode */\n\t\t\tif (!error) {\n\t\t\t\terror = xfs_bmap_finish(&args->trans,\n\t\t\t\t\t\t\targs->flist,\n\t\t\t\t\t\t\t&committed);\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\tASSERT(committed);\n\t\t\t\targs->trans = NULL;\n\t\t\t\txfs_bmap_cancel(args->flist);\n\t\t\t\treturn(error);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * bmap_finish() may have committed the last trans\n\t\t\t * and started a new one.  We need the inode to be\n\t\t\t * in all transactions.\n\t\t\t */\n\t\t\tif (committed)\n\t\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\t\t}\n\n\t\t/*\n\t\t * Commit the remove and start the next trans in series.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\n\t} else if (args->rmtblkno > 0) {\n\t\t/*\n\t\t * Added a \"remote\" value, just clear the incomplete flag.\n\t\t */\n\t\terror = xfs_attr3_leaf_clearflag(args);\n\t}\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,11 +32,22 @@\n \n \t\ttrace_xfs_attr_leaf_replace(args);\n \n+\t\t/* save the attribute state for later removal*/\n \t\targs->op_flags |= XFS_DA_OP_RENAME;\t/* an atomic rename */\n \t\targs->blkno2 = args->blkno;\t\t/* set 2nd entry info*/\n \t\targs->index2 = args->index;\n \t\targs->rmtblkno2 = args->rmtblkno;\n \t\targs->rmtblkcnt2 = args->rmtblkcnt;\n+\t\targs->rmtvaluelen2 = args->rmtvaluelen;\n+\n+\t\t/*\n+\t\t * clear the remote attr state now that it is saved so that the\n+\t\t * values reflect the state of the attribute we are about to\n+\t\t * add, not the attribute we just found and will remove later.\n+\t\t */\n+\t\targs->rmtblkno = 0;\n+\t\targs->rmtblkcnt = 0;\n+\t\targs->rmtvaluelen = 0;\n \t}\n \n \t/*\n@@ -128,6 +139,7 @@\n \t\targs->blkno = args->blkno2;\n \t\targs->rmtblkno = args->rmtblkno2;\n \t\targs->rmtblkcnt = args->rmtblkcnt2;\n+\t\targs->rmtvaluelen = args->rmtvaluelen2;\n \t\tif (args->rmtblkno) {\n \t\t\terror = xfs_attr_rmtval_remove(args);\n \t\t\tif (error)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/* save the attribute state for later removal*/",
                "\t\targs->rmtvaluelen2 = args->rmtvaluelen;",
                "",
                "\t\t/*",
                "\t\t * clear the remote attr state now that it is saved so that the",
                "\t\t * values reflect the state of the attribute we are about to",
                "\t\t * add, not the attribute we just found and will remove later.",
                "\t\t */",
                "\t\targs->rmtblkno = 0;",
                "\t\targs->rmtblkcnt = 0;",
                "\t\targs->rmtvaluelen = 0;",
                "\t\targs->rmtvaluelen = args->rmtvaluelen2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr3_leaf_list_int",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "int\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}",
        "func": "int\nxfs_attr3_leaf_list_int(\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_attr_list_context\t*context)\n{\n\tstruct attrlist_cursor_kern\t*cursor;\n\tstruct xfs_attr_leafblock\t*leaf;\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tretval;\n\tint\t\t\t\ti;\n\n\ttrace_xfs_attr_list_leaf(context);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\tcursor = context->cursor;\n\tcursor->initted = 1;\n\n\t/*\n\t * Re-find our place in the leaf block if this is a new syscall.\n\t */\n\tif (context->resynch) {\n\t\tentry = &entries[0];\n\t\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\t\tif (be32_to_cpu(entry->hashval) == cursor->hashval) {\n\t\t\t\tif (cursor->offset == context->dupcnt) {\n\t\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontext->dupcnt++;\n\t\t\t} else if (be32_to_cpu(entry->hashval) >\n\t\t\t\t\tcursor->hashval) {\n\t\t\t\tcontext->dupcnt = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ichdr.count) {\n\t\t\ttrace_xfs_attr_list_notfound(context);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = &entries[0];\n\t\ti = 0;\n\t}\n\tcontext->resynch = 0;\n\n\t/*\n\t * We have found our place, start copying out the new attributes.\n\t */\n\tretval = 0;\n\tfor (; i < ichdr.count; entry++, i++) {\n\t\tif (be32_to_cpu(entry->hashval) != cursor->hashval) {\n\t\t\tcursor->hashval = be32_to_cpu(entry->hashval);\n\t\t\tcursor->offset = 0;\n\t\t}\n\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* skip incomplete entries */\n\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\txfs_attr_leaf_name_local_t *name_loc =\n\t\t\t\txfs_attr3_leaf_name_local(leaf, i);\n\n\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_loc->nameval,\n\t\t\t\t\t\t(int)name_loc->namelen,\n\t\t\t\t\t\tbe16_to_cpu(name_loc->valuelen),\n\t\t\t\t\t\t&name_loc->nameval[name_loc->namelen]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\txfs_attr_leaf_name_remote_t *name_rmt =\n\t\t\t\txfs_attr3_leaf_name_remote(leaf, i);\n\n\t\t\tint valuelen = be32_to_cpu(name_rmt->valuelen);\n\n\t\t\tif (context->put_value) {\n\t\t\t\txfs_da_args_t args;\n\n\t\t\t\tmemset((char *)&args, 0, sizeof(args));\n\t\t\t\targs.dp = context->dp;\n\t\t\t\targs.whichfork = XFS_ATTR_FORK;\n\t\t\t\targs.valuelen = valuelen;\n\t\t\t\targs.rmtvaluelen = valuelen;\n\t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n\t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs.dp->i_mount, valuelen);\n\t\t\t\tretval = xfs_attr_rmtval_get(&args);\n\t\t\t\tif (retval)\n\t\t\t\t\treturn retval;\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\targs.value);\n\t\t\t\tkmem_free(args.value);\n\t\t\t} else {\n\t\t\t\tretval = context->put_listent(context,\n\t\t\t\t\t\tentry->flags,\n\t\t\t\t\t\tname_rmt->name,\n\t\t\t\t\t\t(int)name_rmt->namelen,\n\t\t\t\t\t\tvaluelen,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\ttrace_xfs_attr_list_leaf_end(context);\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -86,6 +86,7 @@\n \t\t\t\targs.dp = context->dp;\n \t\t\t\targs.whichfork = XFS_ATTR_FORK;\n \t\t\t\targs.valuelen = valuelen;\n+\t\t\t\targs.rmtvaluelen = valuelen;\n \t\t\t\targs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\n \t\t\t\targs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\n \t\t\t\targs.rmtblkcnt = xfs_attr3_rmt_blocks(",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\targs.rmtvaluelen = valuelen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr3_leaf_add_work",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "STATIC int\nxfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < XFS_LBSIZE(mp));\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args->namelen, args->valuelen,\n\t\t\t\t\t mp->m_sb.sb_blocksize, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < XFS_LBSIZE(mp));\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -=\n\t\t\txfs_attr_leaf_newentsize(args->namelen, args->valuelen,\n\t\t\t\t\t\t mp->m_sb.sb_blocksize, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n\t\tname_rmt->valueblk = 0;\n\t\targs->rmtblkno = 1;\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}",
        "func": "STATIC int\nxfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < XFS_LBSIZE(mp));\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args->namelen, args->valuelen,\n\t\t\t\t\t mp->m_sb.sb_blocksize, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < XFS_LBSIZE(mp));\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -=\n\t\t\txfs_attr_leaf_newentsize(args->namelen, args->valuelen,\n\t\t\t\t\t\t mp->m_sb.sb_blocksize, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n\t\tname_rmt->valueblk = 0;\n\t\targs->rmtblkno = 1;\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\targs->rmtvaluelen = args->valuelen;\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -91,6 +91,7 @@\n \t\tname_rmt->valueblk = 0;\n \t\targs->rmtblkno = 1;\n \t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n+\t\targs->rmtvaluelen = args->valuelen;\n \t}\n \txfs_trans_log_buf(args->trans, bp,\n \t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\targs->rmtvaluelen = args->valuelen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr3_leaf_getvalue",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "int\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t}\n\treturn 0;\n}",
        "func": "int\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,19 +35,19 @@\n \t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n \t\tASSERT(name_rmt->namelen == args->namelen);\n \t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n-\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n+\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n \t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n \t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n-\t\t\t\t\t\t       valuelen);\n+\t\t\t\t\t\t       args->rmtvaluelen);\n \t\tif (args->flags & ATTR_KERNOVAL) {\n-\t\t\targs->valuelen = valuelen;\n+\t\t\targs->valuelen = args->rmtvaluelen;\n \t\t\treturn 0;\n \t\t}\n-\t\tif (args->valuelen < valuelen) {\n-\t\t\targs->valuelen = valuelen;\n+\t\tif (args->valuelen < args->rmtvaluelen) {\n+\t\t\targs->valuelen = args->rmtvaluelen;\n \t\t\treturn XFS_ERROR(ERANGE);\n \t\t}\n-\t\targs->valuelen = valuelen;\n+\t\targs->valuelen = args->rmtvaluelen;\n \t}\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);",
                "\t\t\t\t\t\t       valuelen);",
                "\t\t\targs->valuelen = valuelen;",
                "\t\tif (args->valuelen < valuelen) {",
                "\t\t\targs->valuelen = valuelen;",
                "\t\targs->valuelen = valuelen;"
            ],
            "added_lines": [
                "\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);",
                "\t\t\t\t\t\t       args->rmtvaluelen);",
                "\t\t\targs->valuelen = args->rmtvaluelen;",
                "\t\tif (args->valuelen < args->rmtvaluelen) {",
                "\t\t\targs->valuelen = args->rmtvaluelen;",
                "\t\targs->valuelen = args->rmtvaluelen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr3_leaf_lookup_int",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "int\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn XFS_ERROR(ENOATTR);\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn XFS_ERROR(EEXIST);\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->valuelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->valuelen);\n\t\t\treturn XFS_ERROR(EEXIST);\n\t\t}\n\t}\n\targs->index = probe;\n\treturn XFS_ERROR(ENOATTR);\n}",
        "func": "int\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tASSERT(probe >= 0 && (!ichdr.count || probe < ichdr.count));\n\tASSERT(span <= 4 || be32_to_cpu(entry->hashval) == hashval);\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn XFS_ERROR(ENOATTR);\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn XFS_ERROR(EEXIST);\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn XFS_ERROR(EEXIST);\n\t\t}\n\t}\n\targs->index = probe;\n\treturn XFS_ERROR(ENOATTR);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -92,11 +92,11 @@\n \t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n \t\t\t\tcontinue;\n \t\t\targs->index = probe;\n-\t\t\targs->valuelen = be32_to_cpu(name_rmt->valuelen);\n+\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n \t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n \t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n \t\t\t\t\t\t\targs->dp->i_mount,\n-\t\t\t\t\t\t\targs->valuelen);\n+\t\t\t\t\t\t\targs->rmtvaluelen);\n \t\t\treturn XFS_ERROR(EEXIST);\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\targs->valuelen = be32_to_cpu(name_rmt->valuelen);",
                "\t\t\t\t\t\t\targs->valuelen);"
            ],
            "added_lines": [
                "\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);",
                "\t\t\t\t\t\t\targs->rmtvaluelen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr3_leaf_flipflags",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "int\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}",
        "func": "int\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -87,7 +87,7 @@\n \t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n \t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n \t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n-\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n+\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n \t\txfs_trans_log_buf(args->trans, bp1,\n \t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);"
            ],
            "added_lines": [
                "\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr3_leaf_clearflag",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "int\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}",
        "func": "int\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,7 +53,7 @@\n \t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n \t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n \t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n-\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n+\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n \t\txfs_trans_log_buf(args->trans, bp,\n \t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);"
            ],
            "added_lines": [
                "\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr_rmtval_set",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "int\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->valuelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn(error);\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
        "func": "int\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn(error);\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n \t * attributes have headers, we can't just do a straight byte to FSB\n \t * conversion and have to take the header space into account.\n \t */\n-\tblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n+\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n \terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n \t\t\t\t\t\t   XFS_ATTR_FORK);\n \tif (error)\n@@ -87,7 +87,7 @@\n \t */\n \tlblkno = args->rmtblkno;\n \tblkcnt = args->rmtblkcnt;\n-\tvaluelen = args->valuelen;\n+\tvaluelen = args->rmtvaluelen;\n \twhile (valuelen > 0) {\n \t\tstruct xfs_buf\t*bp;\n \t\txfs_daddr_t\tdblkno;",
        "diff_line_info": {
            "deleted_lines": [
                "\tblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);",
                "\tvaluelen = args->valuelen;"
            ],
            "added_lines": [
                "\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);",
                "\tvaluelen = args->rmtvaluelen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0274",
        "func_name": "torvalds/linux/xfs_attr_rmtval_get",
        "description": "The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access.",
        "git_url": "https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59",
        "commit_title": "xfs: remote attribute overwrite causes transaction overrun",
        "commit_text": " Commit e461fcb (\"xfs: remote attribute lookups require the value length\") passes the remote attribute length in the xfs_da_args structure on lookup so that CRC calculations and validity checking can be performed correctly by related code. This, unfortunately has the side effect of changing the args->valuelen parameter in cases where it shouldn't.  That is, when we replace a remote attribute, the incoming replacement stores the value and length in args->value and args->valuelen, but then the lookup which finds the existing remote attribute overwrites args->valuelen with the length of the remote attribute being replaced. Hence when we go to create the new attribute, we create it of the size of the existing remote attribute, not the size it is supposed to be. When the new attribute is much smaller than the old attribute, this results in a transaction overrun and an ASSERT() failure on a debug kernel:  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, file: fs/xfs/xfs_trans.c, line: 331  Fix this by keeping the remote attribute value length separate to the attribute value length in the xfs_da_args structure. The enables us to pass the length of the remote attribute to be removed without overwriting the new attribute's length.  Also, ensure that when we save remote block contexts for a later rename we zero the original state variables so that we don't confuse the state of the attribute to be removes with the state of the new attribute that we just added. [Spotted by Brain Foster.] ",
        "func_before": "int\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen = args->valuelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
        "func": "int\nxfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_get(args);\n\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\tASSERT(args->rmtvaluelen == args->valuelen);\n\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/* roll attribute extent map forwards */\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \tstruct xfs_buf\t\t*bp;\n \txfs_dablk_t\t\tlblkno = args->rmtblkno;\n \t__uint8_t\t\t*dst = args->value;\n-\tint\t\t\tvaluelen = args->valuelen;\n+\tint\t\t\tvaluelen;\n \tint\t\t\tnmap;\n \tint\t\t\terror;\n \tint\t\t\tblkcnt = args->rmtblkcnt;\n@@ -17,7 +17,9 @@\n \ttrace_xfs_attr_rmtval_get(args);\n \n \tASSERT(!(args->flags & ATTR_KERNOVAL));\n+\tASSERT(args->rmtvaluelen == args->valuelen);\n \n+\tvaluelen = args->rmtvaluelen;\n \twhile (valuelen > 0) {\n \t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n \t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,",
        "diff_line_info": {
            "deleted_lines": [
                "\tint\t\t\tvaluelen = args->valuelen;"
            ],
            "added_lines": [
                "\tint\t\t\tvaluelen;",
                "\tASSERT(args->rmtvaluelen == args->valuelen);",
                "\tvaluelen = args->rmtvaluelen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/pcntl_signal_dispatch",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/be9b2a95adb504abd5acdc092d770444ad6f6854",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": "",
        "func_before": "void pcntl_signal_dispatch()\n{\n\tzval *param, **handle, *retval;\n\tstruct php_pcntl_pending_signal *queue, *next;\n\tsigset_t mask;\n\tsigset_t old_mask;\n\tTSRMLS_FETCH();\n\t\t\n\t/* Mask all signals */\n\tsigfillset(&mask);\n\tsigprocmask(SIG_BLOCK, &mask, &old_mask);\n\n\t/* Bail if the queue is empty or if we are already playing the queue*/\n\tif (! PCNTL_G(head) || PCNTL_G(processing_signal_queue)) {\n\t\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n\t\treturn;\n\t}\n\n\t/* Prevent reentrant handler calls */\n\tPCNTL_G(processing_signal_queue) = 1;\n\n\tqueue = PCNTL_G(head);\n\tPCNTL_G(head) = NULL; /* simple stores are atomic */\n\t\n\t/* Allocate */\n\n\twhile (queue) {\n\t\tif (zend_hash_index_find(&PCNTL_G(php_signal_table), queue->signo, (void **) &handle)==SUCCESS) {\n\t\t\tMAKE_STD_ZVAL(retval);\n\t\t\tMAKE_STD_ZVAL(param);\n\t\t\tZVAL_NULL(retval);\n\t\t\tZVAL_LONG(param, queue->signo);\n\n\t\t\t/* Call php signal handler - Note that we do not report errors, and we ignore the return value */\n\t\t\t/* FIXME: this is probably broken when multiple signals are handled in this while loop (retval) */\n\t\t\tcall_user_function(EG(function_table), NULL, *handle, retval, 1, &param TSRMLS_CC);\n\t\t\tzval_ptr_dtor(&param);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tnext = queue->next;\n\t\tqueue->next = PCNTL_G(spares);\n\t\tPCNTL_G(spares) = queue;\n\t\tqueue = next;\n\t}\n\n\t/* Re-enable queue */\n\tPCNTL_G(processing_signal_queue) = 0;\n\t\n\t/* return signal mask to previous state */\n\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n}",
        "func": "void pcntl_signal_dispatch()\n{\n\tzval *param, **handle, *retval;\n\tstruct php_pcntl_pending_signal *queue, *next;\n\tsigset_t mask;\n\tsigset_t old_mask;\n\tTSRMLS_FETCH();\n\n\t/* Mask all signals */\n\tsigfillset(&mask);\n\tsigprocmask(SIG_BLOCK, &mask, &old_mask);\n\n\t/* Bail if the queue is empty or if we are already playing the queue*/\n\tif (! PCNTL_G(head) || PCNTL_G(processing_signal_queue)) {\n\t\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n\t\treturn;\n\t}\n\n\t/* Prevent reentrant handler calls */\n\tPCNTL_G(processing_signal_queue) = 1;\n\n\tqueue = PCNTL_G(head);\n\tPCNTL_G(head) = NULL; /* simple stores are atomic */\n\n\t/* Allocate */\n\n\twhile (queue) {\n\t\tif (zend_hash_index_find(&PCNTL_G(php_signal_table), queue->signo, (void **) &handle)==SUCCESS) {\n\t\t\tMAKE_STD_ZVAL(retval);\n\t\t\tMAKE_STD_ZVAL(param);\n\t\t\tZVAL_NULL(retval);\n\t\t\tZVAL_LONG(param, queue->signo);\n\n\t\t\t/* Call php signal handler - Note that we do not report errors, and we ignore the return value */\n\t\t\t/* FIXME: this is probably broken when multiple signals are handled in this while loop (retval) */\n\t\t\tcall_user_function(EG(function_table), NULL, *handle, retval, 1, &param TSRMLS_CC);\n\t\t\tzval_ptr_dtor(&param);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tnext = queue->next;\n\t\tqueue->next = PCNTL_G(spares);\n\t\tPCNTL_G(spares) = queue;\n\t\tqueue = next;\n\t}\n\n\t/* Re-enable queue */\n\tPCNTL_G(processing_signal_queue) = 0;\n\n\t/* return signal mask to previous state */\n\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tsigset_t mask;\n \tsigset_t old_mask;\n \tTSRMLS_FETCH();\n-\t\t\n+\n \t/* Mask all signals */\n \tsigfillset(&mask);\n \tsigprocmask(SIG_BLOCK, &mask, &old_mask);\n@@ -21,7 +21,7 @@\n \n \tqueue = PCNTL_G(head);\n \tPCNTL_G(head) = NULL; /* simple stores are atomic */\n-\t\n+\n \t/* Allocate */\n \n \twhile (queue) {\n@@ -46,7 +46,7 @@\n \n \t/* Re-enable queue */\n \tPCNTL_G(processing_signal_queue) = 0;\n-\t\n+\n \t/* return signal mask to previous state */\n \tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t",
                "\t",
                "\t"
            ],
            "added_lines": [
                "",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/php_register_signal_constants",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/be9b2a95adb504abd5acdc092d770444ad6f6854",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": "",
        "func_before": "void php_register_signal_constants(INIT_FUNC_ARGS)\n{\n\n\t/* Wait Constants */\n#ifdef WNOHANG\n\tREGISTER_LONG_CONSTANT(\"WNOHANG\",  (long) WNOHANG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef WUNTRACED\n\tREGISTER_LONG_CONSTANT(\"WUNTRACED\",  (long) WUNTRACED, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* Signal Constants */\n\tREGISTER_LONG_CONSTANT(\"SIG_IGN\",  (long) SIG_IGN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_DFL\",  (long) SIG_DFL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_ERR\",  (long) SIG_ERR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGHUP\",   (long) SIGHUP,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGINT\",   (long) SIGINT,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGQUIT\",  (long) SIGQUIT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGILL\",   (long) SIGILL,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTRAP\",  (long) SIGTRAP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGABRT\",  (long) SIGABRT, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGIOT\n\tREGISTER_LONG_CONSTANT(\"SIGIOT\",   (long) SIGIOT,  CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGBUS\",   (long) SIGBUS,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGFPE\",   (long) SIGFPE,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGKILL\",  (long) SIGKILL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGUSR1\",  (long) SIGUSR1, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGSEGV\",  (long) SIGSEGV, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGUSR2\",  (long) SIGUSR2, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGPIPE\",  (long) SIGPIPE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGALRM\",  (long) SIGALRM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTERM\",  (long) SIGTERM, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGSTKFLT\n\tREGISTER_LONG_CONSTANT(\"SIGSTKFLT\",(long) SIGSTKFLT, CONST_CS | CONST_PERSISTENT);\n#endif \n#ifdef SIGCLD\n\tREGISTER_LONG_CONSTANT(\"SIGCLD\",   (long) SIGCLD, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGCHLD\n\tREGISTER_LONG_CONSTANT(\"SIGCHLD\",  (long) SIGCHLD, CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGCONT\",  (long) SIGCONT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGSTOP\",  (long) SIGSTOP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTSTP\",  (long) SIGTSTP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTTIN\",  (long) SIGTTIN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTTOU\",  (long) SIGTTOU, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGURG\",   (long) SIGURG , CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGXCPU\",  (long) SIGXCPU, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGXFSZ\",  (long) SIGXFSZ, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGVTALRM\",(long) SIGVTALRM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGPROF\",  (long) SIGPROF, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGWINCH\", (long) SIGWINCH, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGPOLL\n\tREGISTER_LONG_CONSTANT(\"SIGPOLL\",  (long) SIGPOLL, CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGIO\",    (long) SIGIO, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGPWR\n\tREGISTER_LONG_CONSTANT(\"SIGPWR\",   (long) SIGPWR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGSYS\n\tREGISTER_LONG_CONSTANT(\"SIGSYS\",   (long) SIGSYS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGBABY\",  (long) SIGSYS, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#if HAVE_GETPRIORITY || HAVE_SETPRIORITY\n\tREGISTER_LONG_CONSTANT(\"PRIO_PGRP\", PRIO_PGRP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PRIO_USER\", PRIO_USER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PRIO_PROCESS\", PRIO_PROCESS, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* {{{ \"how\" argument for sigprocmask */\n#ifdef HAVE_SIGPROCMASK\n\tREGISTER_LONG_CONSTANT(\"SIG_BLOCK\",   SIG_BLOCK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_UNBLOCK\", SIG_UNBLOCK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_SETMASK\", SIG_SETMASK, CONST_CS | CONST_PERSISTENT);\n#endif\n\t/* }}} */\n\n\t/* {{{ si_code */\n#if HAVE_SIGWAITINFO && HAVE_SIGTIMEDWAIT\n\tREGISTER_LONG_CONSTANT(\"SI_USER\",    SI_USER,    CONST_CS | CONST_PERSISTENT);\n#ifdef SI_NOINFO\n\tREGISTER_LONG_CONSTANT(\"SI_NOINFO\",  SI_NOINFO,  CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SI_KERNEL\n\tREGISTER_LONG_CONSTANT(\"SI_KERNEL\",  SI_KERNEL,  CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SI_QUEUE\",   SI_QUEUE,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_TIMER\",   SI_TIMER,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_MESGQ\",   SI_MESGQ,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_ASYNCIO\", SI_ASYNCIO, CONST_CS | CONST_PERSISTENT);\n#ifdef SI_SIGIO\n\tREGISTER_LONG_CONSTANT(\"SI_SIGIO\",   SI_SIGIO,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SI_TKILL\n\tREGISTER_LONG_CONSTANT(\"SI_TKILL\",   SI_TKILL,   CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGCHILD */\n#ifdef CLD_EXITED\n\tREGISTER_LONG_CONSTANT(\"CLD_EXITED\",    CLD_EXITED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_KILLED\n\tREGISTER_LONG_CONSTANT(\"CLD_KILLED\",    CLD_KILLED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_DUMPED\n\tREGISTER_LONG_CONSTANT(\"CLD_DUMPED\",    CLD_DUMPED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_TRAPPED\n\tREGISTER_LONG_CONSTANT(\"CLD_TRAPPED\",   CLD_TRAPPED,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_STOPPED\n\tREGISTER_LONG_CONSTANT(\"CLD_STOPPED\",   CLD_STOPPED,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_CONTINUED\n\tREGISTER_LONG_CONSTANT(\"CLD_CONTINUED\", CLD_CONTINUED, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGTRAP */\n#ifdef TRAP_BRKPT\n\tREGISTER_LONG_CONSTANT(\"TRAP_BRKPT\", TRAP_BRKPT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef TRAP_TRACE\n\tREGISTER_LONG_CONSTANT(\"TRAP_TRACE\", TRAP_TRACE, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGPOLL */\n#ifdef POLL_IN\n\tREGISTER_LONG_CONSTANT(\"POLL_IN\",  POLL_IN,  CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_OUT\n\tREGISTER_LONG_CONSTANT(\"POLL_OUT\", POLL_OUT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_MSG\n\tREGISTER_LONG_CONSTANT(\"POLL_MSG\", POLL_MSG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_ERR\n\tREGISTER_LONG_CONSTANT(\"POLL_ERR\", POLL_ERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_PRI\n\tREGISTER_LONG_CONSTANT(\"POLL_PRI\", POLL_PRI, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_HUP\n\tREGISTER_LONG_CONSTANT(\"POLL_HUP\", POLL_HUP, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef ILL_ILLOPC\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLOPC\", ILL_ILLOPC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLOPN\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLOPN\", ILL_ILLOPN, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLADR\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLADR\", ILL_ILLADR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLTRP\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLTRP\", ILL_ILLTRP, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_PRVOPC\n\tREGISTER_LONG_CONSTANT(\"ILL_PRVOPC\", ILL_PRVOPC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_PRVREG\n\tREGISTER_LONG_CONSTANT(\"ILL_PRVREG\", ILL_PRVREG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_COPROC\n\tREGISTER_LONG_CONSTANT(\"ILL_COPROC\", ILL_COPROC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_BADSTK\n\tREGISTER_LONG_CONSTANT(\"ILL_BADSTK\", ILL_BADSTK, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef FPE_INTDIV\n\tREGISTER_LONG_CONSTANT(\"FPE_INTDIV\", FPE_INTDIV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_INTOVF\n\tREGISTER_LONG_CONSTANT(\"FPE_INTOVF\", FPE_INTOVF, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTDIV\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTDIV\", FPE_FLTDIV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTOVF\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTOVF\", FPE_FLTOVF, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTUND\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTUND\", FPE_FLTINV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTRES\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTRES\", FPE_FLTRES, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTINV\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTINV\", FPE_FLTINV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTSUB\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTSUB\", FPE_FLTSUB, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef SEGV_MAPERR\n\tREGISTER_LONG_CONSTANT(\"SEGV_MAPERR\", SEGV_MAPERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SEGV_ACCERR\n\tREGISTER_LONG_CONSTANT(\"SEGV_ACCERR\", SEGV_ACCERR, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef BUS_ADRALN\n\tREGISTER_LONG_CONSTANT(\"BUS_ADRALN\", BUS_ADRALN, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef BUS_ADRERR\n\tREGISTER_LONG_CONSTANT(\"BUS_ADRERR\", BUS_ADRERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef BUS_OBJERR\n\tREGISTER_LONG_CONSTANT(\"BUS_OBJERR\", BUS_OBJERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#endif /* HAVE_SIGWAITINFO && HAVE_SIGTIMEDWAIT */\n\t/* }}} */\n}",
        "func": "void php_register_signal_constants(INIT_FUNC_ARGS)\n{\n\n\t/* Wait Constants */\n#ifdef WNOHANG\n\tREGISTER_LONG_CONSTANT(\"WNOHANG\",  (long) WNOHANG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef WUNTRACED\n\tREGISTER_LONG_CONSTANT(\"WUNTRACED\",  (long) WUNTRACED, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* Signal Constants */\n\tREGISTER_LONG_CONSTANT(\"SIG_IGN\",  (long) SIG_IGN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_DFL\",  (long) SIG_DFL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_ERR\",  (long) SIG_ERR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGHUP\",   (long) SIGHUP,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGINT\",   (long) SIGINT,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGQUIT\",  (long) SIGQUIT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGILL\",   (long) SIGILL,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTRAP\",  (long) SIGTRAP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGABRT\",  (long) SIGABRT, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGIOT\n\tREGISTER_LONG_CONSTANT(\"SIGIOT\",   (long) SIGIOT,  CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGBUS\",   (long) SIGBUS,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGFPE\",   (long) SIGFPE,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGKILL\",  (long) SIGKILL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGUSR1\",  (long) SIGUSR1, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGSEGV\",  (long) SIGSEGV, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGUSR2\",  (long) SIGUSR2, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGPIPE\",  (long) SIGPIPE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGALRM\",  (long) SIGALRM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTERM\",  (long) SIGTERM, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGSTKFLT\n\tREGISTER_LONG_CONSTANT(\"SIGSTKFLT\",(long) SIGSTKFLT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGCLD\n\tREGISTER_LONG_CONSTANT(\"SIGCLD\",   (long) SIGCLD, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGCHLD\n\tREGISTER_LONG_CONSTANT(\"SIGCHLD\",  (long) SIGCHLD, CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGCONT\",  (long) SIGCONT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGSTOP\",  (long) SIGSTOP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTSTP\",  (long) SIGTSTP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTTIN\",  (long) SIGTTIN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTTOU\",  (long) SIGTTOU, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGURG\",   (long) SIGURG , CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGXCPU\",  (long) SIGXCPU, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGXFSZ\",  (long) SIGXFSZ, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGVTALRM\",(long) SIGVTALRM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGPROF\",  (long) SIGPROF, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGWINCH\", (long) SIGWINCH, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGPOLL\n\tREGISTER_LONG_CONSTANT(\"SIGPOLL\",  (long) SIGPOLL, CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGIO\",    (long) SIGIO, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGPWR\n\tREGISTER_LONG_CONSTANT(\"SIGPWR\",   (long) SIGPWR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGSYS\n\tREGISTER_LONG_CONSTANT(\"SIGSYS\",   (long) SIGSYS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGBABY\",  (long) SIGSYS, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#if HAVE_GETPRIORITY || HAVE_SETPRIORITY\n\tREGISTER_LONG_CONSTANT(\"PRIO_PGRP\", PRIO_PGRP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PRIO_USER\", PRIO_USER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PRIO_PROCESS\", PRIO_PROCESS, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* {{{ \"how\" argument for sigprocmask */\n#ifdef HAVE_SIGPROCMASK\n\tREGISTER_LONG_CONSTANT(\"SIG_BLOCK\",   SIG_BLOCK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_UNBLOCK\", SIG_UNBLOCK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_SETMASK\", SIG_SETMASK, CONST_CS | CONST_PERSISTENT);\n#endif\n\t/* }}} */\n\n\t/* {{{ si_code */\n#if HAVE_SIGWAITINFO && HAVE_SIGTIMEDWAIT\n\tREGISTER_LONG_CONSTANT(\"SI_USER\",    SI_USER,    CONST_CS | CONST_PERSISTENT);\n#ifdef SI_NOINFO\n\tREGISTER_LONG_CONSTANT(\"SI_NOINFO\",  SI_NOINFO,  CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SI_KERNEL\n\tREGISTER_LONG_CONSTANT(\"SI_KERNEL\",  SI_KERNEL,  CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SI_QUEUE\",   SI_QUEUE,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_TIMER\",   SI_TIMER,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_MESGQ\",   SI_MESGQ,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_ASYNCIO\", SI_ASYNCIO, CONST_CS | CONST_PERSISTENT);\n#ifdef SI_SIGIO\n\tREGISTER_LONG_CONSTANT(\"SI_SIGIO\",   SI_SIGIO,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SI_TKILL\n\tREGISTER_LONG_CONSTANT(\"SI_TKILL\",   SI_TKILL,   CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGCHILD */\n#ifdef CLD_EXITED\n\tREGISTER_LONG_CONSTANT(\"CLD_EXITED\",    CLD_EXITED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_KILLED\n\tREGISTER_LONG_CONSTANT(\"CLD_KILLED\",    CLD_KILLED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_DUMPED\n\tREGISTER_LONG_CONSTANT(\"CLD_DUMPED\",    CLD_DUMPED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_TRAPPED\n\tREGISTER_LONG_CONSTANT(\"CLD_TRAPPED\",   CLD_TRAPPED,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_STOPPED\n\tREGISTER_LONG_CONSTANT(\"CLD_STOPPED\",   CLD_STOPPED,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_CONTINUED\n\tREGISTER_LONG_CONSTANT(\"CLD_CONTINUED\", CLD_CONTINUED, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGTRAP */\n#ifdef TRAP_BRKPT\n\tREGISTER_LONG_CONSTANT(\"TRAP_BRKPT\", TRAP_BRKPT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef TRAP_TRACE\n\tREGISTER_LONG_CONSTANT(\"TRAP_TRACE\", TRAP_TRACE, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGPOLL */\n#ifdef POLL_IN\n\tREGISTER_LONG_CONSTANT(\"POLL_IN\",  POLL_IN,  CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_OUT\n\tREGISTER_LONG_CONSTANT(\"POLL_OUT\", POLL_OUT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_MSG\n\tREGISTER_LONG_CONSTANT(\"POLL_MSG\", POLL_MSG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_ERR\n\tREGISTER_LONG_CONSTANT(\"POLL_ERR\", POLL_ERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_PRI\n\tREGISTER_LONG_CONSTANT(\"POLL_PRI\", POLL_PRI, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_HUP\n\tREGISTER_LONG_CONSTANT(\"POLL_HUP\", POLL_HUP, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef ILL_ILLOPC\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLOPC\", ILL_ILLOPC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLOPN\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLOPN\", ILL_ILLOPN, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLADR\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLADR\", ILL_ILLADR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLTRP\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLTRP\", ILL_ILLTRP, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_PRVOPC\n\tREGISTER_LONG_CONSTANT(\"ILL_PRVOPC\", ILL_PRVOPC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_PRVREG\n\tREGISTER_LONG_CONSTANT(\"ILL_PRVREG\", ILL_PRVREG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_COPROC\n\tREGISTER_LONG_CONSTANT(\"ILL_COPROC\", ILL_COPROC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_BADSTK\n\tREGISTER_LONG_CONSTANT(\"ILL_BADSTK\", ILL_BADSTK, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef FPE_INTDIV\n\tREGISTER_LONG_CONSTANT(\"FPE_INTDIV\", FPE_INTDIV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_INTOVF\n\tREGISTER_LONG_CONSTANT(\"FPE_INTOVF\", FPE_INTOVF, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTDIV\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTDIV\", FPE_FLTDIV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTOVF\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTOVF\", FPE_FLTOVF, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTUND\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTUND\", FPE_FLTINV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTRES\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTRES\", FPE_FLTRES, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTINV\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTINV\", FPE_FLTINV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTSUB\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTSUB\", FPE_FLTSUB, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef SEGV_MAPERR\n\tREGISTER_LONG_CONSTANT(\"SEGV_MAPERR\", SEGV_MAPERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SEGV_ACCERR\n\tREGISTER_LONG_CONSTANT(\"SEGV_ACCERR\", SEGV_ACCERR, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef BUS_ADRALN\n\tREGISTER_LONG_CONSTANT(\"BUS_ADRALN\", BUS_ADRALN, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef BUS_ADRERR\n\tREGISTER_LONG_CONSTANT(\"BUS_ADRERR\", BUS_ADRERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef BUS_OBJERR\n\tREGISTER_LONG_CONSTANT(\"BUS_OBJERR\", BUS_OBJERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#endif /* HAVE_SIGWAITINFO && HAVE_SIGTIMEDWAIT */\n\t/* }}} */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,7 @@\n \tREGISTER_LONG_CONSTANT(\"SIGTERM\",  (long) SIGTERM, CONST_CS | CONST_PERSISTENT);\n #ifdef SIGSTKFLT\n \tREGISTER_LONG_CONSTANT(\"SIGSTKFLT\",(long) SIGSTKFLT, CONST_CS | CONST_PERSISTENT);\n-#endif \n+#endif\n #ifdef SIGCLD\n \tREGISTER_LONG_CONSTANT(\"SIGCLD\",   (long) SIGCLD, CONST_CS | CONST_PERSISTENT);\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "#endif "
            ],
            "added_lines": [
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/pcntl_sigwaitinfo",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/be9b2a95adb504abd5acdc092d770444ad6f6854",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": "",
        "func_before": "static void pcntl_sigwaitinfo(INTERNAL_FUNCTION_PARAMETERS, int timedwait) /* {{{ */\n{\n\tzval            *user_set, **user_signo, *user_siginfo = NULL;\n\tlong             tv_sec = 0, tv_nsec = 0;\n\tsigset_t         set;\n\tHashPosition     pos;\n\tint              signo;\n\tsiginfo_t        siginfo;\n\tstruct timespec  timeout;\n\n\tif (timedwait) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|zll\", &user_set, &user_siginfo, &tv_sec, &tv_nsec) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|z\", &user_set, &user_siginfo) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sigemptyset(&set) != 0) {\n\t\tPCNTL_G(last_error) = errno;\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\tRETURN_FALSE;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(user_set), &pos);\n\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(user_set), (void **)&user_signo, &pos) == SUCCESS)\n\t{\n\t\tif (Z_TYPE_PP(user_signo) != IS_LONG) {\n\t\t\tSEPARATE_ZVAL(user_signo);\n\t\t\tconvert_to_long_ex(user_signo);\n\t\t}\n\t\tsigno = Z_LVAL_PP(user_signo);\n\t\tif (sigaddset(&set, signo) != 0) {\n\t\t\tPCNTL_G(last_error) = errno;\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(user_set), &pos);\n\t}\n\n\tif (timedwait) {\n\t\ttimeout.tv_sec  = (time_t) tv_sec;\n\t\ttimeout.tv_nsec = tv_nsec;\n\t\tsigno = sigtimedwait(&set, &siginfo, &timeout);\n\t} else {\n\t\tsigno = sigwaitinfo(&set, &siginfo);\n\t}\n\tif (signo == -1 && errno != EAGAIN) {\n\t\tPCNTL_G(last_error) = errno;\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t}\n\n\t/*\n\t * sigtimedwait and sigwaitinfo can return 0 on success on some \n\t * platforms, e.g. NetBSD\n\t */\n\tif (!signo && siginfo.si_signo) {\n\t\tsigno = siginfo.si_signo;\n\t}\n\n\tif (signo > 0 && user_siginfo) {\n\t\tif (Z_TYPE_P(user_siginfo) != IS_ARRAY) {\n\t\t\tzval_dtor(user_siginfo);\n\t\t\tarray_init(user_siginfo);\n\t\t} else {\n\t\t\tzend_hash_clean(Z_ARRVAL_P(user_siginfo));\n\t\t}\n\t\tadd_assoc_long_ex(user_siginfo, \"signo\", sizeof(\"signo\"), siginfo.si_signo);\n\t\tadd_assoc_long_ex(user_siginfo, \"errno\", sizeof(\"errno\"), siginfo.si_errno);\n\t\tadd_assoc_long_ex(user_siginfo, \"code\",  sizeof(\"code\"),  siginfo.si_code);\n\t\tswitch(signo) {\n#ifdef SIGCHLD\n\t\t\tcase SIGCHLD:\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"status\", sizeof(\"status\"), siginfo.si_status);\n# ifdef si_utime\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"utime\",  sizeof(\"utime\"),  siginfo.si_utime);\n# endif\n# ifdef si_stime\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"stime\",  sizeof(\"stime\"),  siginfo.si_stime);\n# endif\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"pid\",    sizeof(\"pid\"),    siginfo.si_pid);\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"uid\",    sizeof(\"uid\"),    siginfo.si_uid);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase SIGILL:\n\t\t\tcase SIGFPE:\n\t\t\tcase SIGSEGV:\n\t\t\tcase SIGBUS:\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"addr\", sizeof(\"addr\"), (long)siginfo.si_addr);\n\t\t\t\tbreak;\n#ifdef SIGPOLL\n\t\t\tcase SIGPOLL:\n\t\t\t\tadd_assoc_long_ex(user_siginfo, \"band\", sizeof(\"band\"), siginfo.si_band);\n# ifdef si_fd\n\t\t\t\tadd_assoc_long_ex(user_siginfo, \"fd\",   sizeof(\"fd\"),   siginfo.si_fd);\n# endif\n\t\t\t\tbreak;\n#endif\n\t\t\tEMPTY_SWITCH_DEFAULT_CASE();\n\t\t}\n\t}\n\t\n\tRETURN_LONG(signo);\n}",
        "func": "static void pcntl_sigwaitinfo(INTERNAL_FUNCTION_PARAMETERS, int timedwait) /* {{{ */\n{\n\tzval            *user_set, **user_signo, *user_siginfo = NULL;\n\tlong             tv_sec = 0, tv_nsec = 0;\n\tsigset_t         set;\n\tHashPosition     pos;\n\tint              signo;\n\tsiginfo_t        siginfo;\n\tstruct timespec  timeout;\n\n\tif (timedwait) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|zll\", &user_set, &user_siginfo, &tv_sec, &tv_nsec) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|z\", &user_set, &user_siginfo) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sigemptyset(&set) != 0) {\n\t\tPCNTL_G(last_error) = errno;\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\tRETURN_FALSE;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(user_set), &pos);\n\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(user_set), (void **)&user_signo, &pos) == SUCCESS)\n\t{\n\t\tif (Z_TYPE_PP(user_signo) != IS_LONG) {\n\t\t\tSEPARATE_ZVAL(user_signo);\n\t\t\tconvert_to_long_ex(user_signo);\n\t\t}\n\t\tsigno = Z_LVAL_PP(user_signo);\n\t\tif (sigaddset(&set, signo) != 0) {\n\t\t\tPCNTL_G(last_error) = errno;\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(user_set), &pos);\n\t}\n\n\tif (timedwait) {\n\t\ttimeout.tv_sec  = (time_t) tv_sec;\n\t\ttimeout.tv_nsec = tv_nsec;\n\t\tsigno = sigtimedwait(&set, &siginfo, &timeout);\n\t} else {\n\t\tsigno = sigwaitinfo(&set, &siginfo);\n\t}\n\tif (signo == -1 && errno != EAGAIN) {\n\t\tPCNTL_G(last_error) = errno;\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t}\n\n\t/*\n\t * sigtimedwait and sigwaitinfo can return 0 on success on some\n\t * platforms, e.g. NetBSD\n\t */\n\tif (!signo && siginfo.si_signo) {\n\t\tsigno = siginfo.si_signo;\n\t}\n\n\tif (signo > 0 && user_siginfo) {\n\t\tif (Z_TYPE_P(user_siginfo) != IS_ARRAY) {\n\t\t\tzval_dtor(user_siginfo);\n\t\t\tarray_init(user_siginfo);\n\t\t} else {\n\t\t\tzend_hash_clean(Z_ARRVAL_P(user_siginfo));\n\t\t}\n\t\tadd_assoc_long_ex(user_siginfo, \"signo\", sizeof(\"signo\"), siginfo.si_signo);\n\t\tadd_assoc_long_ex(user_siginfo, \"errno\", sizeof(\"errno\"), siginfo.si_errno);\n\t\tadd_assoc_long_ex(user_siginfo, \"code\",  sizeof(\"code\"),  siginfo.si_code);\n\t\tswitch(signo) {\n#ifdef SIGCHLD\n\t\t\tcase SIGCHLD:\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"status\", sizeof(\"status\"), siginfo.si_status);\n# ifdef si_utime\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"utime\",  sizeof(\"utime\"),  siginfo.si_utime);\n# endif\n# ifdef si_stime\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"stime\",  sizeof(\"stime\"),  siginfo.si_stime);\n# endif\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"pid\",    sizeof(\"pid\"),    siginfo.si_pid);\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"uid\",    sizeof(\"uid\"),    siginfo.si_uid);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase SIGILL:\n\t\t\tcase SIGFPE:\n\t\t\tcase SIGSEGV:\n\t\t\tcase SIGBUS:\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"addr\", sizeof(\"addr\"), (long)siginfo.si_addr);\n\t\t\t\tbreak;\n#ifdef SIGPOLL\n\t\t\tcase SIGPOLL:\n\t\t\t\tadd_assoc_long_ex(user_siginfo, \"band\", sizeof(\"band\"), siginfo.si_band);\n# ifdef si_fd\n\t\t\t\tadd_assoc_long_ex(user_siginfo, \"fd\",   sizeof(\"fd\"),   siginfo.si_fd);\n# endif\n\t\t\t\tbreak;\n#endif\n\t\t\tEMPTY_SWITCH_DEFAULT_CASE();\n\t\t}\n\t}\n\n\tRETURN_LONG(signo);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,7 +53,7 @@\n \t}\n \n \t/*\n-\t * sigtimedwait and sigwaitinfo can return 0 on success on some \n+\t * sigtimedwait and sigwaitinfo can return 0 on success on some\n \t * platforms, e.g. NetBSD\n \t */\n \tif (!signo && siginfo.si_signo) {\n@@ -101,6 +101,6 @@\n \t\t\tEMPTY_SWITCH_DEFAULT_CASE();\n \t\t}\n \t}\n-\t\n+\n \tRETURN_LONG(signo);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t * sigtimedwait and sigwaitinfo can return 0 on success on some ",
                "\t"
            ],
            "added_lines": [
                "\t * sigtimedwait and sigwaitinfo can return 0 on success on some",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/pcntl_signal_handler",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/be9b2a95adb504abd5acdc092d770444ad6f6854",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": "",
        "func_before": "static void pcntl_signal_handler(int signo)\n{\n\tstruct php_pcntl_pending_signal *psig;\n\tTSRMLS_FETCH();\n\t\n\tpsig = PCNTL_G(spares);\n\tif (!psig) {\n\t\t/* oops, too many signals for us to track, so we'll forget about this one */\n\t\treturn;\n\t}\n\tPCNTL_G(spares) = psig->next;\n\n\tpsig->signo = signo;\n\tpsig->next = NULL;\n\n\t/* the head check is important, as the tick handler cannot atomically clear both\n\t * the head and tail */\n\tif (PCNTL_G(head) && PCNTL_G(tail)) {\n\t\tPCNTL_G(tail)->next = psig;\n\t} else {\n\t\tPCNTL_G(head) = psig;\n\t}\n\tPCNTL_G(tail) = psig;\n}",
        "func": "static void pcntl_signal_handler(int signo)\n{\n\tstruct php_pcntl_pending_signal *psig;\n\tTSRMLS_FETCH();\n\n\tpsig = PCNTL_G(spares);\n\tif (!psig) {\n\t\t/* oops, too many signals for us to track, so we'll forget about this one */\n\t\treturn;\n\t}\n\tPCNTL_G(spares) = psig->next;\n\n\tpsig->signo = signo;\n\tpsig->next = NULL;\n\n\t/* the head check is important, as the tick handler cannot atomically clear both\n\t * the head and tail */\n\tif (PCNTL_G(head) && PCNTL_G(tail)) {\n\t\tPCNTL_G(tail)->next = psig;\n\t} else {\n\t\tPCNTL_G(head) = psig;\n\t}\n\tPCNTL_G(tail) = psig;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tstruct php_pcntl_pending_signal *psig;\n \tTSRMLS_FETCH();\n-\t\n+\n \tpsig = PCNTL_G(spares);\n \tif (!psig) {\n \t\t/* oops, too many signals for us to track, so we'll forget about this one */",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/php_set_default_dir",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/be9b2a95adb504abd5acdc092d770444ad6f6854",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": "",
        "func_before": "static void php_set_default_dir(int id TSRMLS_DC)\n{\n\tif (DIRG(default_dir)!=-1) {\n\t\tzend_list_delete(DIRG(default_dir));\n\t}\n\n\tif (id != -1) {\n\t\tzend_list_addref(id);\n\t}\n\t\n\tDIRG(default_dir) = id;\n}",
        "func": "static void php_set_default_dir(int id TSRMLS_DC)\n{\n\tif (DIRG(default_dir)!=-1) {\n\t\tzend_list_delete(DIRG(default_dir));\n\t}\n\n\tif (id != -1) {\n\t\tzend_list_addref(id);\n\t}\n\n\tDIRG(default_dir) = id;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,6 @@\n \tif (id != -1) {\n \t\tzend_list_addref(id);\n \t}\n-\t\n+\n \tDIRG(default_dir) = id;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/_php_do_opendir",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/be9b2a95adb504abd5acdc092d770444ad6f6854",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": "",
        "func_before": "static void _php_do_opendir(INTERNAL_FUNCTION_PARAMETERS, int createobject)\n{\n\tchar *dirname;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *dirp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|r\", &dirname, &dir_len, &zcontext) == FAILURE) {\n\t\tRETURN_NULL();\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\t\n\tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);\n\n\tif (dirp == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tdirp->flags |= PHP_STREAM_FLAG_NO_FCLOSE;\n\t\t\n\tphp_set_default_dir(dirp->rsrc_id TSRMLS_CC);\n\n\tif (createobject) {\n\t\tobject_init_ex(return_value, dir_class_entry_ptr);\n\t\tadd_property_stringl(return_value, \"path\", dirname, dir_len, 1);\n\t\tadd_property_resource(return_value, \"handle\", dirp->rsrc_id);\n\t\tphp_stream_auto_cleanup(dirp); /* so we don't get warnings under debug */\n\t} else {\n\t\tphp_stream_to_zval(dirp, return_value);\n\t}\n}",
        "func": "static void _php_do_opendir(INTERNAL_FUNCTION_PARAMETERS, int createobject)\n{\n\tchar *dirname;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *dirp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dirname, &dir_len, &zcontext) == FAILURE) {\n\t\tRETURN_NULL();\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);\n\n\tif (dirp == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tdirp->flags |= PHP_STREAM_FLAG_NO_FCLOSE;\n\n\tphp_set_default_dir(dirp->rsrc_id TSRMLS_CC);\n\n\tif (createobject) {\n\t\tobject_init_ex(return_value, dir_class_entry_ptr);\n\t\tadd_property_stringl(return_value, \"path\", dirname, dir_len, 1);\n\t\tadd_property_resource(return_value, \"handle\", dirp->rsrc_id);\n\t\tphp_stream_auto_cleanup(dirp); /* so we don't get warnings under debug */\n\t} else {\n\t\tphp_stream_to_zval(dirp, return_value);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,12 +6,12 @@\n \tphp_stream_context *context = NULL;\n \tphp_stream *dirp;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|r\", &dirname, &dir_len, &zcontext) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dirname, &dir_len, &zcontext) == FAILURE) {\n \t\tRETURN_NULL();\n \t}\n \n \tcontext = php_stream_context_from_zval(zcontext, 0);\n-\t\n+\n \tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);\n \n \tif (dirp == NULL) {\n@@ -19,7 +19,7 @@\n \t}\n \n \tdirp->flags |= PHP_STREAM_FLAG_NO_FCLOSE;\n-\t\t\n+\n \tphp_set_default_dir(dirp->rsrc_id TSRMLS_CC);\n \n \tif (createobject) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|r\", &dirname, &dir_len, &zcontext) == FAILURE) {",
                "\t",
                "\t\t"
            ],
            "added_lines": [
                "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dirname, &dir_len, &zcontext) == FAILURE) {",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/pcntl_signal_dispatch",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/bbe4b87e1d1fa858c208368a28c0fb17c7774fe0",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": " Conflicts: \text/pcntl/pcntl.c \text/standard/basic_functions.c",
        "func_before": "void pcntl_signal_dispatch()\n{\n\tzval *param, **handle, *retval;\n\tstruct php_pcntl_pending_signal *queue, *next;\n\tsigset_t mask;\n\tsigset_t old_mask;\n\tTSRMLS_FETCH();\n\n\tif(!PCNTL_G(pending_signals)) {\n\t\treturn;\n\t}\n\t\t\n\t/* Mask all signals */\n\tsigfillset(&mask);\n\tsigprocmask(SIG_BLOCK, &mask, &old_mask);\n\n\t/* Bail if the queue is empty or if we are already playing the queue*/\n\tif (! PCNTL_G(head) || PCNTL_G(processing_signal_queue)) {\n\t\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n\t\treturn;\n\t}\n\n\t/* Prevent reentrant handler calls */\n\tPCNTL_G(processing_signal_queue) = 1;\n\n\tqueue = PCNTL_G(head);\n\tPCNTL_G(head) = NULL; /* simple stores are atomic */\n\t\n\t/* Allocate */\n\n\twhile (queue) {\n\t\tif (zend_hash_index_find(&PCNTL_G(php_signal_table), queue->signo, (void **) &handle)==SUCCESS) {\n\t\t\tMAKE_STD_ZVAL(retval);\n\t\t\tMAKE_STD_ZVAL(param);\n\t\t\tZVAL_NULL(retval);\n\t\t\tZVAL_LONG(param, queue->signo);\n\n\t\t\t/* Call php signal handler - Note that we do not report errors, and we ignore the return value */\n\t\t\t/* FIXME: this is probably broken when multiple signals are handled in this while loop (retval) */\n\t\t\tcall_user_function(EG(function_table), NULL, *handle, retval, 1, &param TSRMLS_CC);\n\t\t\tzval_ptr_dtor(&param);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tnext = queue->next;\n\t\tqueue->next = PCNTL_G(spares);\n\t\tPCNTL_G(spares) = queue;\n\t\tqueue = next;\n\t}\n\n\tPCNTL_G(pending_signals) = 0;\n\n\t/* Re-enable queue */\n\tPCNTL_G(processing_signal_queue) = 0;\n\t\n\t/* return signal mask to previous state */\n\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n}",
        "func": "void pcntl_signal_dispatch()\n{\n\tzval *param, **handle, *retval;\n\tstruct php_pcntl_pending_signal *queue, *next;\n\tsigset_t mask;\n\tsigset_t old_mask;\n\tTSRMLS_FETCH();\n\n\tif(!PCNTL_G(pending_signals)) {\n\t\treturn;\n\t}\n\t\n\t/* Mask all signals */\n\tsigfillset(&mask);\n\tsigprocmask(SIG_BLOCK, &mask, &old_mask);\n\n\t/* Bail if the queue is empty or if we are already playing the queue*/\n\tif (! PCNTL_G(head) || PCNTL_G(processing_signal_queue)) {\n\t\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n\t\treturn;\n\t}\n\n\t/* Prevent reentrant handler calls */\n\tPCNTL_G(processing_signal_queue) = 1;\n\n\tqueue = PCNTL_G(head);\n\tPCNTL_G(head) = NULL; /* simple stores are atomic */\n\n\t/* Allocate */\n\n\twhile (queue) {\n\t\tif (zend_hash_index_find(&PCNTL_G(php_signal_table), queue->signo, (void **) &handle)==SUCCESS) {\n\t\t\tMAKE_STD_ZVAL(retval);\n\t\t\tMAKE_STD_ZVAL(param);\n\t\t\tZVAL_NULL(retval);\n\t\t\tZVAL_LONG(param, queue->signo);\n\n\t\t\t/* Call php signal handler - Note that we do not report errors, and we ignore the return value */\n\t\t\t/* FIXME: this is probably broken when multiple signals are handled in this while loop (retval) */\n\t\t\tcall_user_function(EG(function_table), NULL, *handle, retval, 1, &param TSRMLS_CC);\n\t\t\tzval_ptr_dtor(&param);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tnext = queue->next;\n\t\tqueue->next = PCNTL_G(spares);\n\t\tPCNTL_G(spares) = queue;\n\t\tqueue = next;\n\t}\n\n\tPCNTL_G(pending_signals) = 0;\n\n\t/* Re-enable queue */\n\tPCNTL_G(processing_signal_queue) = 0;\n\n\t/* return signal mask to previous state */\n\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \tif(!PCNTL_G(pending_signals)) {\n \t\treturn;\n \t}\n-\t\t\n+\t\n \t/* Mask all signals */\n \tsigfillset(&mask);\n \tsigprocmask(SIG_BLOCK, &mask, &old_mask);\n@@ -25,7 +25,7 @@\n \n \tqueue = PCNTL_G(head);\n \tPCNTL_G(head) = NULL; /* simple stores are atomic */\n-\t\n+\n \t/* Allocate */\n \n \twhile (queue) {\n@@ -52,7 +52,7 @@\n \n \t/* Re-enable queue */\n \tPCNTL_G(processing_signal_queue) = 0;\n-\t\n+\n \t/* return signal mask to previous state */\n \tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t",
                "\t",
                "\t"
            ],
            "added_lines": [
                "\t",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/php_register_signal_constants",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/bbe4b87e1d1fa858c208368a28c0fb17c7774fe0",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": " Conflicts: \text/pcntl/pcntl.c \text/standard/basic_functions.c",
        "func_before": "void php_register_signal_constants(INIT_FUNC_ARGS)\n{\n\n\t/* Wait Constants */\n#ifdef WNOHANG\n\tREGISTER_LONG_CONSTANT(\"WNOHANG\",  (long) WNOHANG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef WUNTRACED\n\tREGISTER_LONG_CONSTANT(\"WUNTRACED\",  (long) WUNTRACED, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* Signal Constants */\n\tREGISTER_LONG_CONSTANT(\"SIG_IGN\",  (long) SIG_IGN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_DFL\",  (long) SIG_DFL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_ERR\",  (long) SIG_ERR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGHUP\",   (long) SIGHUP,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGINT\",   (long) SIGINT,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGQUIT\",  (long) SIGQUIT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGILL\",   (long) SIGILL,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTRAP\",  (long) SIGTRAP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGABRT\",  (long) SIGABRT, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGIOT\n\tREGISTER_LONG_CONSTANT(\"SIGIOT\",   (long) SIGIOT,  CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGBUS\",   (long) SIGBUS,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGFPE\",   (long) SIGFPE,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGKILL\",  (long) SIGKILL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGUSR1\",  (long) SIGUSR1, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGSEGV\",  (long) SIGSEGV, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGUSR2\",  (long) SIGUSR2, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGPIPE\",  (long) SIGPIPE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGALRM\",  (long) SIGALRM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTERM\",  (long) SIGTERM, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGSTKFLT\n\tREGISTER_LONG_CONSTANT(\"SIGSTKFLT\",(long) SIGSTKFLT, CONST_CS | CONST_PERSISTENT);\n#endif \n#ifdef SIGCLD\n\tREGISTER_LONG_CONSTANT(\"SIGCLD\",   (long) SIGCLD, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGCHLD\n\tREGISTER_LONG_CONSTANT(\"SIGCHLD\",  (long) SIGCHLD, CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGCONT\",  (long) SIGCONT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGSTOP\",  (long) SIGSTOP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTSTP\",  (long) SIGTSTP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTTIN\",  (long) SIGTTIN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTTOU\",  (long) SIGTTOU, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGURG\",   (long) SIGURG , CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGXCPU\",  (long) SIGXCPU, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGXFSZ\",  (long) SIGXFSZ, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGVTALRM\",(long) SIGVTALRM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGPROF\",  (long) SIGPROF, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGWINCH\", (long) SIGWINCH, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGPOLL\n\tREGISTER_LONG_CONSTANT(\"SIGPOLL\",  (long) SIGPOLL, CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGIO\",    (long) SIGIO, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGPWR\n\tREGISTER_LONG_CONSTANT(\"SIGPWR\",   (long) SIGPWR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGSYS\n\tREGISTER_LONG_CONSTANT(\"SIGSYS\",   (long) SIGSYS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGBABY\",  (long) SIGSYS, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#if HAVE_GETPRIORITY || HAVE_SETPRIORITY\n\tREGISTER_LONG_CONSTANT(\"PRIO_PGRP\", PRIO_PGRP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PRIO_USER\", PRIO_USER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PRIO_PROCESS\", PRIO_PROCESS, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* {{{ \"how\" argument for sigprocmask */\n#ifdef HAVE_SIGPROCMASK\n\tREGISTER_LONG_CONSTANT(\"SIG_BLOCK\",   SIG_BLOCK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_UNBLOCK\", SIG_UNBLOCK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_SETMASK\", SIG_SETMASK, CONST_CS | CONST_PERSISTENT);\n#endif\n\t/* }}} */\n\n\t/* {{{ si_code */\n#if HAVE_SIGWAITINFO && HAVE_SIGTIMEDWAIT\n\tREGISTER_LONG_CONSTANT(\"SI_USER\",    SI_USER,    CONST_CS | CONST_PERSISTENT);\n#ifdef SI_NOINFO\n\tREGISTER_LONG_CONSTANT(\"SI_NOINFO\",  SI_NOINFO,  CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SI_KERNEL\n\tREGISTER_LONG_CONSTANT(\"SI_KERNEL\",  SI_KERNEL,  CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SI_QUEUE\",   SI_QUEUE,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_TIMER\",   SI_TIMER,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_MESGQ\",   SI_MESGQ,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_ASYNCIO\", SI_ASYNCIO, CONST_CS | CONST_PERSISTENT);\n#ifdef SI_SIGIO\n\tREGISTER_LONG_CONSTANT(\"SI_SIGIO\",   SI_SIGIO,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SI_TKILL\n\tREGISTER_LONG_CONSTANT(\"SI_TKILL\",   SI_TKILL,   CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGCHILD */\n#ifdef CLD_EXITED\n\tREGISTER_LONG_CONSTANT(\"CLD_EXITED\",    CLD_EXITED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_KILLED\n\tREGISTER_LONG_CONSTANT(\"CLD_KILLED\",    CLD_KILLED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_DUMPED\n\tREGISTER_LONG_CONSTANT(\"CLD_DUMPED\",    CLD_DUMPED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_TRAPPED\n\tREGISTER_LONG_CONSTANT(\"CLD_TRAPPED\",   CLD_TRAPPED,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_STOPPED\n\tREGISTER_LONG_CONSTANT(\"CLD_STOPPED\",   CLD_STOPPED,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_CONTINUED\n\tREGISTER_LONG_CONSTANT(\"CLD_CONTINUED\", CLD_CONTINUED, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGTRAP */\n#ifdef TRAP_BRKPT\n\tREGISTER_LONG_CONSTANT(\"TRAP_BRKPT\", TRAP_BRKPT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef TRAP_TRACE\n\tREGISTER_LONG_CONSTANT(\"TRAP_TRACE\", TRAP_TRACE, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGPOLL */\n#ifdef POLL_IN\n\tREGISTER_LONG_CONSTANT(\"POLL_IN\",  POLL_IN,  CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_OUT\n\tREGISTER_LONG_CONSTANT(\"POLL_OUT\", POLL_OUT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_MSG\n\tREGISTER_LONG_CONSTANT(\"POLL_MSG\", POLL_MSG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_ERR\n\tREGISTER_LONG_CONSTANT(\"POLL_ERR\", POLL_ERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_PRI\n\tREGISTER_LONG_CONSTANT(\"POLL_PRI\", POLL_PRI, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_HUP\n\tREGISTER_LONG_CONSTANT(\"POLL_HUP\", POLL_HUP, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef ILL_ILLOPC\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLOPC\", ILL_ILLOPC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLOPN\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLOPN\", ILL_ILLOPN, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLADR\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLADR\", ILL_ILLADR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLTRP\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLTRP\", ILL_ILLTRP, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_PRVOPC\n\tREGISTER_LONG_CONSTANT(\"ILL_PRVOPC\", ILL_PRVOPC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_PRVREG\n\tREGISTER_LONG_CONSTANT(\"ILL_PRVREG\", ILL_PRVREG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_COPROC\n\tREGISTER_LONG_CONSTANT(\"ILL_COPROC\", ILL_COPROC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_BADSTK\n\tREGISTER_LONG_CONSTANT(\"ILL_BADSTK\", ILL_BADSTK, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef FPE_INTDIV\n\tREGISTER_LONG_CONSTANT(\"FPE_INTDIV\", FPE_INTDIV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_INTOVF\n\tREGISTER_LONG_CONSTANT(\"FPE_INTOVF\", FPE_INTOVF, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTDIV\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTDIV\", FPE_FLTDIV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTOVF\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTOVF\", FPE_FLTOVF, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTUND\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTUND\", FPE_FLTINV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTRES\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTRES\", FPE_FLTRES, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTINV\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTINV\", FPE_FLTINV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTSUB\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTSUB\", FPE_FLTSUB, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef SEGV_MAPERR\n\tREGISTER_LONG_CONSTANT(\"SEGV_MAPERR\", SEGV_MAPERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SEGV_ACCERR\n\tREGISTER_LONG_CONSTANT(\"SEGV_ACCERR\", SEGV_ACCERR, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef BUS_ADRALN\n\tREGISTER_LONG_CONSTANT(\"BUS_ADRALN\", BUS_ADRALN, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef BUS_ADRERR\n\tREGISTER_LONG_CONSTANT(\"BUS_ADRERR\", BUS_ADRERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef BUS_OBJERR\n\tREGISTER_LONG_CONSTANT(\"BUS_OBJERR\", BUS_OBJERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#endif /* HAVE_SIGWAITINFO && HAVE_SIGTIMEDWAIT */\n\t/* }}} */\n}",
        "func": "void php_register_signal_constants(INIT_FUNC_ARGS)\n{\n\n\t/* Wait Constants */\n#ifdef WNOHANG\n\tREGISTER_LONG_CONSTANT(\"WNOHANG\",  (long) WNOHANG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef WUNTRACED\n\tREGISTER_LONG_CONSTANT(\"WUNTRACED\",  (long) WUNTRACED, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* Signal Constants */\n\tREGISTER_LONG_CONSTANT(\"SIG_IGN\",  (long) SIG_IGN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_DFL\",  (long) SIG_DFL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_ERR\",  (long) SIG_ERR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGHUP\",   (long) SIGHUP,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGINT\",   (long) SIGINT,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGQUIT\",  (long) SIGQUIT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGILL\",   (long) SIGILL,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTRAP\",  (long) SIGTRAP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGABRT\",  (long) SIGABRT, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGIOT\n\tREGISTER_LONG_CONSTANT(\"SIGIOT\",   (long) SIGIOT,  CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGBUS\",   (long) SIGBUS,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGFPE\",   (long) SIGFPE,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGKILL\",  (long) SIGKILL, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGUSR1\",  (long) SIGUSR1, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGSEGV\",  (long) SIGSEGV, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGUSR2\",  (long) SIGUSR2, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGPIPE\",  (long) SIGPIPE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGALRM\",  (long) SIGALRM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTERM\",  (long) SIGTERM, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGSTKFLT\n\tREGISTER_LONG_CONSTANT(\"SIGSTKFLT\",(long) SIGSTKFLT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGCLD\n\tREGISTER_LONG_CONSTANT(\"SIGCLD\",   (long) SIGCLD, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGCHLD\n\tREGISTER_LONG_CONSTANT(\"SIGCHLD\",  (long) SIGCHLD, CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGCONT\",  (long) SIGCONT, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGSTOP\",  (long) SIGSTOP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTSTP\",  (long) SIGTSTP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTTIN\",  (long) SIGTTIN, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGTTOU\",  (long) SIGTTOU, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGURG\",   (long) SIGURG , CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGXCPU\",  (long) SIGXCPU, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGXFSZ\",  (long) SIGXFSZ, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGVTALRM\",(long) SIGVTALRM, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGPROF\",  (long) SIGPROF, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGWINCH\", (long) SIGWINCH, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGPOLL\n\tREGISTER_LONG_CONSTANT(\"SIGPOLL\",  (long) SIGPOLL, CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SIGIO\",    (long) SIGIO, CONST_CS | CONST_PERSISTENT);\n#ifdef SIGPWR\n\tREGISTER_LONG_CONSTANT(\"SIGPWR\",   (long) SIGPWR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SIGSYS\n\tREGISTER_LONG_CONSTANT(\"SIGSYS\",   (long) SIGSYS, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIGBABY\",  (long) SIGSYS, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#if HAVE_GETPRIORITY || HAVE_SETPRIORITY\n\tREGISTER_LONG_CONSTANT(\"PRIO_PGRP\", PRIO_PGRP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PRIO_USER\", PRIO_USER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"PRIO_PROCESS\", PRIO_PROCESS, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* {{{ \"how\" argument for sigprocmask */\n#ifdef HAVE_SIGPROCMASK\n\tREGISTER_LONG_CONSTANT(\"SIG_BLOCK\",   SIG_BLOCK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_UNBLOCK\", SIG_UNBLOCK, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SIG_SETMASK\", SIG_SETMASK, CONST_CS | CONST_PERSISTENT);\n#endif\n\t/* }}} */\n\n\t/* {{{ si_code */\n#if HAVE_SIGWAITINFO && HAVE_SIGTIMEDWAIT\n\tREGISTER_LONG_CONSTANT(\"SI_USER\",    SI_USER,    CONST_CS | CONST_PERSISTENT);\n#ifdef SI_NOINFO\n\tREGISTER_LONG_CONSTANT(\"SI_NOINFO\",  SI_NOINFO,  CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SI_KERNEL\n\tREGISTER_LONG_CONSTANT(\"SI_KERNEL\",  SI_KERNEL,  CONST_CS | CONST_PERSISTENT);\n#endif\n\tREGISTER_LONG_CONSTANT(\"SI_QUEUE\",   SI_QUEUE,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_TIMER\",   SI_TIMER,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_MESGQ\",   SI_MESGQ,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SI_ASYNCIO\", SI_ASYNCIO, CONST_CS | CONST_PERSISTENT);\n#ifdef SI_SIGIO\n\tREGISTER_LONG_CONSTANT(\"SI_SIGIO\",   SI_SIGIO,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SI_TKILL\n\tREGISTER_LONG_CONSTANT(\"SI_TKILL\",   SI_TKILL,   CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGCHILD */\n#ifdef CLD_EXITED\n\tREGISTER_LONG_CONSTANT(\"CLD_EXITED\",    CLD_EXITED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_KILLED\n\tREGISTER_LONG_CONSTANT(\"CLD_KILLED\",    CLD_KILLED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_DUMPED\n\tREGISTER_LONG_CONSTANT(\"CLD_DUMPED\",    CLD_DUMPED,    CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_TRAPPED\n\tREGISTER_LONG_CONSTANT(\"CLD_TRAPPED\",   CLD_TRAPPED,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_STOPPED\n\tREGISTER_LONG_CONSTANT(\"CLD_STOPPED\",   CLD_STOPPED,   CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef CLD_CONTINUED\n\tREGISTER_LONG_CONSTANT(\"CLD_CONTINUED\", CLD_CONTINUED, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGTRAP */\n#ifdef TRAP_BRKPT\n\tREGISTER_LONG_CONSTANT(\"TRAP_BRKPT\", TRAP_BRKPT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef TRAP_TRACE\n\tREGISTER_LONG_CONSTANT(\"TRAP_TRACE\", TRAP_TRACE, CONST_CS | CONST_PERSISTENT);\n#endif\n\n\t/* si_code for SIGPOLL */\n#ifdef POLL_IN\n\tREGISTER_LONG_CONSTANT(\"POLL_IN\",  POLL_IN,  CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_OUT\n\tREGISTER_LONG_CONSTANT(\"POLL_OUT\", POLL_OUT, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_MSG\n\tREGISTER_LONG_CONSTANT(\"POLL_MSG\", POLL_MSG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_ERR\n\tREGISTER_LONG_CONSTANT(\"POLL_ERR\", POLL_ERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_PRI\n\tREGISTER_LONG_CONSTANT(\"POLL_PRI\", POLL_PRI, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef POLL_HUP\n\tREGISTER_LONG_CONSTANT(\"POLL_HUP\", POLL_HUP, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef ILL_ILLOPC\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLOPC\", ILL_ILLOPC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLOPN\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLOPN\", ILL_ILLOPN, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLADR\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLADR\", ILL_ILLADR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_ILLTRP\n\tREGISTER_LONG_CONSTANT(\"ILL_ILLTRP\", ILL_ILLTRP, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_PRVOPC\n\tREGISTER_LONG_CONSTANT(\"ILL_PRVOPC\", ILL_PRVOPC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_PRVREG\n\tREGISTER_LONG_CONSTANT(\"ILL_PRVREG\", ILL_PRVREG, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_COPROC\n\tREGISTER_LONG_CONSTANT(\"ILL_COPROC\", ILL_COPROC, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef ILL_BADSTK\n\tREGISTER_LONG_CONSTANT(\"ILL_BADSTK\", ILL_BADSTK, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef FPE_INTDIV\n\tREGISTER_LONG_CONSTANT(\"FPE_INTDIV\", FPE_INTDIV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_INTOVF\n\tREGISTER_LONG_CONSTANT(\"FPE_INTOVF\", FPE_INTOVF, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTDIV\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTDIV\", FPE_FLTDIV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTOVF\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTOVF\", FPE_FLTOVF, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTUND\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTUND\", FPE_FLTINV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTRES\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTRES\", FPE_FLTRES, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTINV\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTINV\", FPE_FLTINV, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef FPE_FLTSUB\n\tREGISTER_LONG_CONSTANT(\"FPE_FLTSUB\", FPE_FLTSUB, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef SEGV_MAPERR\n\tREGISTER_LONG_CONSTANT(\"SEGV_MAPERR\", SEGV_MAPERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef SEGV_ACCERR\n\tREGISTER_LONG_CONSTANT(\"SEGV_ACCERR\", SEGV_ACCERR, CONST_CS | CONST_PERSISTENT);\n#endif\n\n#ifdef BUS_ADRALN\n\tREGISTER_LONG_CONSTANT(\"BUS_ADRALN\", BUS_ADRALN, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef BUS_ADRERR\n\tREGISTER_LONG_CONSTANT(\"BUS_ADRERR\", BUS_ADRERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#ifdef BUS_OBJERR\n\tREGISTER_LONG_CONSTANT(\"BUS_OBJERR\", BUS_OBJERR, CONST_CS | CONST_PERSISTENT);\n#endif\n#endif /* HAVE_SIGWAITINFO && HAVE_SIGTIMEDWAIT */\n\t/* }}} */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,7 @@\n \tREGISTER_LONG_CONSTANT(\"SIGTERM\",  (long) SIGTERM, CONST_CS | CONST_PERSISTENT);\n #ifdef SIGSTKFLT\n \tREGISTER_LONG_CONSTANT(\"SIGSTKFLT\",(long) SIGSTKFLT, CONST_CS | CONST_PERSISTENT);\n-#endif \n+#endif\n #ifdef SIGCLD\n \tREGISTER_LONG_CONSTANT(\"SIGCLD\",   (long) SIGCLD, CONST_CS | CONST_PERSISTENT);\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "#endif "
            ],
            "added_lines": [
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/pcntl_sigwaitinfo",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/bbe4b87e1d1fa858c208368a28c0fb17c7774fe0",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": " Conflicts: \text/pcntl/pcntl.c \text/standard/basic_functions.c",
        "func_before": "static void pcntl_sigwaitinfo(INTERNAL_FUNCTION_PARAMETERS, int timedwait) /* {{{ */\n{\n\tzval            *user_set, **user_signo, *user_siginfo = NULL;\n\tlong             tv_sec = 0, tv_nsec = 0;\n\tsigset_t         set;\n\tHashPosition     pos;\n\tint              signo;\n\tsiginfo_t        siginfo;\n\tstruct timespec  timeout;\n\n\tif (timedwait) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|zll\", &user_set, &user_siginfo, &tv_sec, &tv_nsec) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|z\", &user_set, &user_siginfo) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sigemptyset(&set) != 0) {\n\t\tPCNTL_G(last_error) = errno;\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\tRETURN_FALSE;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(user_set), &pos);\n\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(user_set), (void **)&user_signo, &pos) == SUCCESS)\n\t{\n\t\tif (Z_TYPE_PP(user_signo) != IS_LONG) {\n\t\t\tSEPARATE_ZVAL(user_signo);\n\t\t\tconvert_to_long_ex(user_signo);\n\t\t}\n\t\tsigno = Z_LVAL_PP(user_signo);\n\t\tif (sigaddset(&set, signo) != 0) {\n\t\t\tPCNTL_G(last_error) = errno;\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(user_set), &pos);\n\t}\n\n\tif (timedwait) {\n\t\ttimeout.tv_sec  = (time_t) tv_sec;\n\t\ttimeout.tv_nsec = tv_nsec;\n\t\tsigno = sigtimedwait(&set, &siginfo, &timeout);\n\t} else {\n\t\tsigno = sigwaitinfo(&set, &siginfo);\n\t}\n\tif (signo == -1 && errno != EAGAIN) {\n\t\tPCNTL_G(last_error) = errno;\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t}\n\n\t/*\n\t * sigtimedwait and sigwaitinfo can return 0 on success on some \n\t * platforms, e.g. NetBSD\n\t */\n\tif (!signo && siginfo.si_signo) {\n\t\tsigno = siginfo.si_signo;\n\t}\n\n\tif (signo > 0 && user_siginfo) {\n\t\tif (Z_TYPE_P(user_siginfo) != IS_ARRAY) {\n\t\t\tzval_dtor(user_siginfo);\n\t\t\tarray_init(user_siginfo);\n\t\t} else {\n\t\t\tzend_hash_clean(Z_ARRVAL_P(user_siginfo));\n\t\t}\n\t\tadd_assoc_long_ex(user_siginfo, \"signo\", sizeof(\"signo\"), siginfo.si_signo);\n\t\tadd_assoc_long_ex(user_siginfo, \"errno\", sizeof(\"errno\"), siginfo.si_errno);\n\t\tadd_assoc_long_ex(user_siginfo, \"code\",  sizeof(\"code\"),  siginfo.si_code);\n\t\tswitch(signo) {\n#ifdef SIGCHLD\n\t\t\tcase SIGCHLD:\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"status\", sizeof(\"status\"), siginfo.si_status);\n# ifdef si_utime\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"utime\",  sizeof(\"utime\"),  siginfo.si_utime);\n# endif\n# ifdef si_stime\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"stime\",  sizeof(\"stime\"),  siginfo.si_stime);\n# endif\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"pid\",    sizeof(\"pid\"),    siginfo.si_pid);\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"uid\",    sizeof(\"uid\"),    siginfo.si_uid);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase SIGILL:\n\t\t\tcase SIGFPE:\n\t\t\tcase SIGSEGV:\n\t\t\tcase SIGBUS:\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"addr\", sizeof(\"addr\"), (long)siginfo.si_addr);\n\t\t\t\tbreak;\n#ifdef SIGPOLL\n\t\t\tcase SIGPOLL:\n\t\t\t\tadd_assoc_long_ex(user_siginfo, \"band\", sizeof(\"band\"), siginfo.si_band);\n# ifdef si_fd\n\t\t\t\tadd_assoc_long_ex(user_siginfo, \"fd\",   sizeof(\"fd\"),   siginfo.si_fd);\n# endif\n\t\t\t\tbreak;\n#endif\n\t\t\tEMPTY_SWITCH_DEFAULT_CASE();\n\t\t}\n\t}\n\t\n\tRETURN_LONG(signo);\n}",
        "func": "static void pcntl_sigwaitinfo(INTERNAL_FUNCTION_PARAMETERS, int timedwait) /* {{{ */\n{\n\tzval            *user_set, **user_signo, *user_siginfo = NULL;\n\tlong             tv_sec = 0, tv_nsec = 0;\n\tsigset_t         set;\n\tHashPosition     pos;\n\tint              signo;\n\tsiginfo_t        siginfo;\n\tstruct timespec  timeout;\n\n\tif (timedwait) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|zll\", &user_set, &user_siginfo, &tv_sec, &tv_nsec) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|z\", &user_set, &user_siginfo) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sigemptyset(&set) != 0) {\n\t\tPCNTL_G(last_error) = errno;\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\tRETURN_FALSE;\n\t}\n\n\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(user_set), &pos);\n\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(user_set), (void **)&user_signo, &pos) == SUCCESS)\n\t{\n\t\tif (Z_TYPE_PP(user_signo) != IS_LONG) {\n\t\t\tSEPARATE_ZVAL(user_signo);\n\t\t\tconvert_to_long_ex(user_signo);\n\t\t}\n\t\tsigno = Z_LVAL_PP(user_signo);\n\t\tif (sigaddset(&set, signo) != 0) {\n\t\t\tPCNTL_G(last_error) = errno;\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(user_set), &pos);\n\t}\n\n\tif (timedwait) {\n\t\ttimeout.tv_sec  = (time_t) tv_sec;\n\t\ttimeout.tv_nsec = tv_nsec;\n\t\tsigno = sigtimedwait(&set, &siginfo, &timeout);\n\t} else {\n\t\tsigno = sigwaitinfo(&set, &siginfo);\n\t}\n\tif (signo == -1 && errno != EAGAIN) {\n\t\tPCNTL_G(last_error) = errno;\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t}\n\n\t/*\n\t * sigtimedwait and sigwaitinfo can return 0 on success on some\n\t * platforms, e.g. NetBSD\n\t */\n\tif (!signo && siginfo.si_signo) {\n\t\tsigno = siginfo.si_signo;\n\t}\n\n\tif (signo > 0 && user_siginfo) {\n\t\tif (Z_TYPE_P(user_siginfo) != IS_ARRAY) {\n\t\t\tzval_dtor(user_siginfo);\n\t\t\tarray_init(user_siginfo);\n\t\t} else {\n\t\t\tzend_hash_clean(Z_ARRVAL_P(user_siginfo));\n\t\t}\n\t\tadd_assoc_long_ex(user_siginfo, \"signo\", sizeof(\"signo\"), siginfo.si_signo);\n\t\tadd_assoc_long_ex(user_siginfo, \"errno\", sizeof(\"errno\"), siginfo.si_errno);\n\t\tadd_assoc_long_ex(user_siginfo, \"code\",  sizeof(\"code\"),  siginfo.si_code);\n\t\tswitch(signo) {\n#ifdef SIGCHLD\n\t\t\tcase SIGCHLD:\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"status\", sizeof(\"status\"), siginfo.si_status);\n# ifdef si_utime\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"utime\",  sizeof(\"utime\"),  siginfo.si_utime);\n# endif\n# ifdef si_stime\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"stime\",  sizeof(\"stime\"),  siginfo.si_stime);\n# endif\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"pid\",    sizeof(\"pid\"),    siginfo.si_pid);\n\t\t\t\tadd_assoc_long_ex(user_siginfo,   \"uid\",    sizeof(\"uid\"),    siginfo.si_uid);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase SIGILL:\n\t\t\tcase SIGFPE:\n\t\t\tcase SIGSEGV:\n\t\t\tcase SIGBUS:\n\t\t\t\tadd_assoc_double_ex(user_siginfo, \"addr\", sizeof(\"addr\"), (long)siginfo.si_addr);\n\t\t\t\tbreak;\n#ifdef SIGPOLL\n\t\t\tcase SIGPOLL:\n\t\t\t\tadd_assoc_long_ex(user_siginfo, \"band\", sizeof(\"band\"), siginfo.si_band);\n# ifdef si_fd\n\t\t\t\tadd_assoc_long_ex(user_siginfo, \"fd\",   sizeof(\"fd\"),   siginfo.si_fd);\n# endif\n\t\t\t\tbreak;\n#endif\n\t\t\tEMPTY_SWITCH_DEFAULT_CASE();\n\t\t}\n\t}\n\n\tRETURN_LONG(signo);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,7 +53,7 @@\n \t}\n \n \t/*\n-\t * sigtimedwait and sigwaitinfo can return 0 on success on some \n+\t * sigtimedwait and sigwaitinfo can return 0 on success on some\n \t * platforms, e.g. NetBSD\n \t */\n \tif (!signo && siginfo.si_signo) {\n@@ -101,6 +101,6 @@\n \t\t\tEMPTY_SWITCH_DEFAULT_CASE();\n \t\t}\n \t}\n-\t\n+\n \tRETURN_LONG(signo);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t * sigtimedwait and sigwaitinfo can return 0 on success on some ",
                "\t"
            ],
            "added_lines": [
                "\t * sigtimedwait and sigwaitinfo can return 0 on success on some",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/pcntl_signal_handler",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/bbe4b87e1d1fa858c208368a28c0fb17c7774fe0",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": " Conflicts: \text/pcntl/pcntl.c \text/standard/basic_functions.c",
        "func_before": "static void pcntl_signal_handler(int signo)\n{\n\tstruct php_pcntl_pending_signal *psig;\n\tTSRMLS_FETCH();\n\t\n\tpsig = PCNTL_G(spares);\n\tif (!psig) {\n\t\t/* oops, too many signals for us to track, so we'll forget about this one */\n\t\treturn;\n\t}\n\tPCNTL_G(spares) = psig->next;\n\n\tpsig->signo = signo;\n\tpsig->next = NULL;\n\n\t/* the head check is important, as the tick handler cannot atomically clear both\n\t * the head and tail */\n\tif (PCNTL_G(head) && PCNTL_G(tail)) {\n\t\tPCNTL_G(tail)->next = psig;\n\t} else {\n\t\tPCNTL_G(head) = psig;\n\t}\n\tPCNTL_G(tail) = psig;\n\tPCNTL_G(pending_signals) = 1;\n}",
        "func": "static void pcntl_signal_handler(int signo)\n{\n\tstruct php_pcntl_pending_signal *psig;\n\tTSRMLS_FETCH();\n\n\tpsig = PCNTL_G(spares);\n\tif (!psig) {\n\t\t/* oops, too many signals for us to track, so we'll forget about this one */\n\t\treturn;\n\t}\n\tPCNTL_G(spares) = psig->next;\n\n\tpsig->signo = signo;\n\tpsig->next = NULL;\n\n\t/* the head check is important, as the tick handler cannot atomically clear both\n\t * the head and tail */\n\tif (PCNTL_G(head) && PCNTL_G(tail)) {\n\t\tPCNTL_G(tail)->next = psig;\n\t} else {\n\t\tPCNTL_G(head) = psig;\n\t}\n\tPCNTL_G(tail) = psig;\n\tPCNTL_G(pending_signals) = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tstruct php_pcntl_pending_signal *psig;\n \tTSRMLS_FETCH();\n-\t\n+\n \tpsig = PCNTL_G(spares);\n \tif (!psig) {\n \t\t/* oops, too many signals for us to track, so we'll forget about this one */",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/php_set_default_dir",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/bbe4b87e1d1fa858c208368a28c0fb17c7774fe0",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": " Conflicts: \text/pcntl/pcntl.c \text/standard/basic_functions.c",
        "func_before": "static void php_set_default_dir(int id TSRMLS_DC)\n{\n\tif (DIRG(default_dir)!=-1) {\n\t\tzend_list_delete(DIRG(default_dir));\n\t}\n\n\tif (id != -1) {\n\t\tzend_list_addref(id);\n\t}\n\t\n\tDIRG(default_dir) = id;\n}",
        "func": "static void php_set_default_dir(int id TSRMLS_DC)\n{\n\tif (DIRG(default_dir)!=-1) {\n\t\tzend_list_delete(DIRG(default_dir));\n\t}\n\n\tif (id != -1) {\n\t\tzend_list_addref(id);\n\t}\n\n\tDIRG(default_dir) = id;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,6 @@\n \tif (id != -1) {\n \t\tzend_list_addref(id);\n \t}\n-\t\n+\n \tDIRG(default_dir) = id;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-4025",
        "func_name": "php/php-src/_php_do_opendir",
        "description": "PHP before 5.4.41, 5.5.x before 5.5.25, and 5.6.x before 5.6.9 truncates a pathname upon encountering a \\x00 character in certain situations, which allows remote attackers to bypass intended extension restrictions and access files or directories with unexpected names via a crafted argument to (1) set_include_path, (2) tempnam, (3) rmdir, or (4) readlink.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2006-7243.",
        "git_url": "https://github.com/php/php-src/commit/bbe4b87e1d1fa858c208368a28c0fb17c7774fe0",
        "commit_title": "Fixed bug #69418 - more s->p fixes for filenames",
        "commit_text": " Conflicts: \text/pcntl/pcntl.c \text/standard/basic_functions.c",
        "func_before": "static void _php_do_opendir(INTERNAL_FUNCTION_PARAMETERS, int createobject)\n{\n\tchar *dirname;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *dirp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|r\", &dirname, &dir_len, &zcontext) == FAILURE) {\n\t\tRETURN_NULL();\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\t\n\tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);\n\n\tif (dirp == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tdirp->flags |= PHP_STREAM_FLAG_NO_FCLOSE;\n\t\t\n\tphp_set_default_dir(dirp->rsrc_id TSRMLS_CC);\n\n\tif (createobject) {\n\t\tobject_init_ex(return_value, dir_class_entry_ptr);\n\t\tadd_property_stringl(return_value, \"path\", dirname, dir_len, 1);\n\t\tadd_property_resource(return_value, \"handle\", dirp->rsrc_id);\n\t\tphp_stream_auto_cleanup(dirp); /* so we don't get warnings under debug */\n\t} else {\n\t\tphp_stream_to_zval(dirp, return_value);\n\t}\n}",
        "func": "static void _php_do_opendir(INTERNAL_FUNCTION_PARAMETERS, int createobject)\n{\n\tchar *dirname;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *dirp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dirname, &dir_len, &zcontext) == FAILURE) {\n\t\tRETURN_NULL();\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);\n\n\tif (dirp == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tdirp->flags |= PHP_STREAM_FLAG_NO_FCLOSE;\n\n\tphp_set_default_dir(dirp->rsrc_id TSRMLS_CC);\n\n\tif (createobject) {\n\t\tobject_init_ex(return_value, dir_class_entry_ptr);\n\t\tadd_property_stringl(return_value, \"path\", dirname, dir_len, 1);\n\t\tadd_property_resource(return_value, \"handle\", dirp->rsrc_id);\n\t\tphp_stream_auto_cleanup(dirp); /* so we don't get warnings under debug */\n\t} else {\n\t\tphp_stream_to_zval(dirp, return_value);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,12 +6,12 @@\n \tphp_stream_context *context = NULL;\n \tphp_stream *dirp;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|r\", &dirname, &dir_len, &zcontext) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dirname, &dir_len, &zcontext) == FAILURE) {\n \t\tRETURN_NULL();\n \t}\n \n \tcontext = php_stream_context_from_zval(zcontext, 0);\n-\t\n+\n \tdirp = php_stream_opendir(dirname, REPORT_ERRORS, context);\n \n \tif (dirp == NULL) {\n@@ -19,7 +19,7 @@\n \t}\n \n \tdirp->flags |= PHP_STREAM_FLAG_NO_FCLOSE;\n-\t\t\n+\n \tphp_set_default_dir(dirp->rsrc_id TSRMLS_CC);\n \n \tif (createobject) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|r\", &dirname, &dir_len, &zcontext) == FAILURE) {",
                "\t",
                "\t\t"
            ],
            "added_lines": [
                "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dirname, &dir_len, &zcontext) == FAILURE) {",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9803",
        "func_name": "torvalds/linux/do_page_fault",
        "description": "arch/arm64/include/asm/pgtable.h in the Linux kernel before 3.15-rc5-next-20140519, as used in Android before 2016-07-05 on Nexus 5X and 6P devices, mishandles execute-only pages, which allows attackers to gain privileges via a crafted application, aka Android internal bug 28557020.",
        "git_url": "https://github.com/torvalds/linux/commit/5a0fdfada3a2aa50d7b947a2e958bf00cbe0d830",
        "commit_title": "Revert \"arm64: Introduce execute-only page access permissions\"",
        "commit_text": " This reverts commit bc07c2c6e9ed125d362af0214b6313dca180cb08.  While the aim is increased security for --x memory maps, it does not protect against kernel level reads. Until SECCOMP is implemented for arm64, revert this patch to avoid giving a false idea of execute-only mappings. ",
        "func_before": "static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tint fault, sig, code;\n\tunsigned long vm_flags = VM_READ | VM_WRITE;\n\tunsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\n\n\ttsk = current;\n\tmm  = tsk->mm;\n\n\t/* Enable interrupts if they were enabled in the parent context. */\n\tif (interrupts_enabled(regs))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * If we're in an interrupt or have no user context, we must not take\n\t * the fault.\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\tif (user_mode(regs))\n\t\tmm_flags |= FAULT_FLAG_USER;\n\n\tif (esr & ESR_LNX_EXEC) {\n\t\tvm_flags = VM_EXEC;\n\t} else if ((esr & ESR_EL1_WRITE) && !(esr & ESR_EL1_CM)) {\n\t\tvm_flags = VM_WRITE;\n\t\tmm_flags |= FAULT_FLAG_WRITE;\n\t}\n\n\t/*\n\t * As per x86, we may deadlock here. However, since the kernel only\n\t * validly references user space from well defined areas of the code,\n\t * we can bug out early if this is from code which shouldn't.\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->pc))\n\t\t\tgoto no_context;\nretry:\n\t\tdown_read(&mm->mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in which\n\t\t * case, we'll have missed the might_sleep() from down_read().\n\t\t */\n\t\tmight_sleep();\n#ifdef CONFIG_DEBUG_VM\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->pc))\n\t\t\tgoto no_context;\n#endif\n\t}\n\n\tfault = __do_page_fault(mm, addr, mm_flags, vm_flags, tsk);\n\n\t/*\n\t * If we need to retry but a fatal signal is pending, handle the\n\t * signal first. We do not need to release the mmap_sem because it\n\t * would already be released in __lock_page_or_retry in mm/filemap.c.\n\t */\n\tif ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))\n\t\treturn 0;\n\n\t/*\n\t * Major/minor page fault accounting is only done on the initial\n\t * attempt. If we go through a retry, it is extremely likely that the\n\t * page will be found in page cache at that point.\n\t */\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);\n\tif (mm_flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault & VM_FAULT_MAJOR) {\n\t\t\ttsk->maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs,\n\t\t\t\t      addr);\n\t\t} else {\n\t\t\ttsk->min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs,\n\t\t\t\t      addr);\n\t\t}\n\t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t/*\n\t\t\t * Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk of\n\t\t\t * starvation.\n\t\t\t */\n\t\t\tmm_flags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tup_read(&mm->mmap_sem);\n\n\t/*\n\t * Handle the \"normal\" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR\n\t */\n\tif (likely(!(fault & (VM_FAULT_ERROR | VM_FAULT_BADMAP |\n\t\t\t      VM_FAULT_BADACCESS))))\n\t\treturn 0;\n\n\t/*\n\t * If we are in kernel mode at this point, we have no context to\n\t * handle this fault with.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\n\tif (fault & VM_FAULT_OOM) {\n\t\t/*\n\t\t * We ran out of memory, call the OOM killer, and return to\n\t\t * userspace (which will retry the fault, or kill us if we got\n\t\t * oom-killed).\n\t\t */\n\t\tpagefault_out_of_memory();\n\t\treturn 0;\n\t}\n\n\tif (fault & VM_FAULT_SIGBUS) {\n\t\t/*\n\t\t * We had some memory, but were unable to successfully fix up\n\t\t * this page fault.\n\t\t */\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRERR;\n\t} else {\n\t\t/*\n\t\t * Something tried to access memory that isn't in our memory\n\t\t * map.\n\t\t */\n\t\tsig = SIGSEGV;\n\t\tcode = fault == VM_FAULT_BADACCESS ?\n\t\t\tSEGV_ACCERR : SEGV_MAPERR;\n\t}\n\n\t__do_user_fault(tsk, addr, esr, sig, code, regs);\n\treturn 0;\n\nno_context:\n\t__do_kernel_fault(mm, addr, esr, regs);\n\treturn 0;\n}",
        "func": "static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tint fault, sig, code;\n\tunsigned long vm_flags = VM_READ | VM_WRITE | VM_EXEC;\n\tunsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\n\n\ttsk = current;\n\tmm  = tsk->mm;\n\n\t/* Enable interrupts if they were enabled in the parent context. */\n\tif (interrupts_enabled(regs))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * If we're in an interrupt or have no user context, we must not take\n\t * the fault.\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\tif (user_mode(regs))\n\t\tmm_flags |= FAULT_FLAG_USER;\n\n\tif (esr & ESR_LNX_EXEC) {\n\t\tvm_flags = VM_EXEC;\n\t} else if ((esr & ESR_EL1_WRITE) && !(esr & ESR_EL1_CM)) {\n\t\tvm_flags = VM_WRITE;\n\t\tmm_flags |= FAULT_FLAG_WRITE;\n\t}\n\n\t/*\n\t * As per x86, we may deadlock here. However, since the kernel only\n\t * validly references user space from well defined areas of the code,\n\t * we can bug out early if this is from code which shouldn't.\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->pc))\n\t\t\tgoto no_context;\nretry:\n\t\tdown_read(&mm->mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in which\n\t\t * case, we'll have missed the might_sleep() from down_read().\n\t\t */\n\t\tmight_sleep();\n#ifdef CONFIG_DEBUG_VM\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->pc))\n\t\t\tgoto no_context;\n#endif\n\t}\n\n\tfault = __do_page_fault(mm, addr, mm_flags, vm_flags, tsk);\n\n\t/*\n\t * If we need to retry but a fatal signal is pending, handle the\n\t * signal first. We do not need to release the mmap_sem because it\n\t * would already be released in __lock_page_or_retry in mm/filemap.c.\n\t */\n\tif ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))\n\t\treturn 0;\n\n\t/*\n\t * Major/minor page fault accounting is only done on the initial\n\t * attempt. If we go through a retry, it is extremely likely that the\n\t * page will be found in page cache at that point.\n\t */\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);\n\tif (mm_flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault & VM_FAULT_MAJOR) {\n\t\t\ttsk->maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs,\n\t\t\t\t      addr);\n\t\t} else {\n\t\t\ttsk->min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs,\n\t\t\t\t      addr);\n\t\t}\n\t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t/*\n\t\t\t * Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk of\n\t\t\t * starvation.\n\t\t\t */\n\t\t\tmm_flags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tup_read(&mm->mmap_sem);\n\n\t/*\n\t * Handle the \"normal\" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR\n\t */\n\tif (likely(!(fault & (VM_FAULT_ERROR | VM_FAULT_BADMAP |\n\t\t\t      VM_FAULT_BADACCESS))))\n\t\treturn 0;\n\n\t/*\n\t * If we are in kernel mode at this point, we have no context to\n\t * handle this fault with.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\n\tif (fault & VM_FAULT_OOM) {\n\t\t/*\n\t\t * We ran out of memory, call the OOM killer, and return to\n\t\t * userspace (which will retry the fault, or kill us if we got\n\t\t * oom-killed).\n\t\t */\n\t\tpagefault_out_of_memory();\n\t\treturn 0;\n\t}\n\n\tif (fault & VM_FAULT_SIGBUS) {\n\t\t/*\n\t\t * We had some memory, but were unable to successfully fix up\n\t\t * this page fault.\n\t\t */\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRERR;\n\t} else {\n\t\t/*\n\t\t * Something tried to access memory that isn't in our memory\n\t\t * map.\n\t\t */\n\t\tsig = SIGSEGV;\n\t\tcode = fault == VM_FAULT_BADACCESS ?\n\t\t\tSEGV_ACCERR : SEGV_MAPERR;\n\t}\n\n\t__do_user_fault(tsk, addr, esr, sig, code, regs);\n\treturn 0;\n\nno_context:\n\t__do_kernel_fault(mm, addr, esr, regs);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \tstruct task_struct *tsk;\n \tstruct mm_struct *mm;\n \tint fault, sig, code;\n-\tunsigned long vm_flags = VM_READ | VM_WRITE;\n+\tunsigned long vm_flags = VM_READ | VM_WRITE | VM_EXEC;\n \tunsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\n \n \ttsk = current;",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned long vm_flags = VM_READ | VM_WRITE;"
            ],
            "added_lines": [
                "\tunsigned long vm_flags = VM_READ | VM_WRITE | VM_EXEC;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9803",
        "func_name": "torvalds/linux/__do_page_fault",
        "description": "arch/arm64/include/asm/pgtable.h in the Linux kernel before 3.15-rc5-next-20140519, as used in Android before 2016-07-05 on Nexus 5X and 6P devices, mishandles execute-only pages, which allows attackers to gain privileges via a crafted application, aka Android internal bug 28557020.",
        "git_url": "https://github.com/torvalds/linux/commit/5a0fdfada3a2aa50d7b947a2e958bf00cbe0d830",
        "commit_title": "Revert \"arm64: Introduce execute-only page access permissions\"",
        "commit_text": " This reverts commit bc07c2c6e9ed125d362af0214b6313dca180cb08.  While the aim is increased security for --x memory maps, it does not protect against kernel level reads. Until SECCOMP is implemented for arm64, revert this patch to avoid giving a false idea of execute-only mappings. ",
        "func_before": "static int __do_page_fault(struct mm_struct *mm, unsigned long addr,\n\t\t\t   unsigned int mm_flags, unsigned long vm_flags,\n\t\t\t   struct task_struct *tsk)\n{\n\tstruct vm_area_struct *vma;\n\tint fault;\n\n\tvma = find_vma(mm, addr);\n\tfault = VM_FAULT_BADMAP;\n\tif (unlikely(!vma))\n\t\tgoto out;\n\tif (unlikely(vma->vm_start > addr))\n\t\tgoto check_stack;\n\n\t/*\n\t * Ok, we have a good vm_area for this memory access, so we can handle\n\t * it.\n\t */\ngood_area:\n\t/*\n\t * Check that the permissions on the VMA allow for the fault which\n\t * occurred.\n\t */\n\tif (!(vma->vm_flags & vm_flags)) {\n\t\tfault = VM_FAULT_BADACCESS;\n\t\tgoto out;\n\t}\n\n\treturn handle_mm_fault(mm, vma, addr & PAGE_MASK, mm_flags);\n\ncheck_stack:\n\tif (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr))\n\t\tgoto good_area;\nout:\n\treturn fault;\n}",
        "func": "static int __do_page_fault(struct mm_struct *mm, unsigned long addr,\n\t\t\t   unsigned int mm_flags, unsigned long vm_flags,\n\t\t\t   struct task_struct *tsk)\n{\n\tstruct vm_area_struct *vma;\n\tint fault;\n\n\tvma = find_vma(mm, addr);\n\tfault = VM_FAULT_BADMAP;\n\tif (unlikely(!vma))\n\t\tgoto out;\n\tif (unlikely(vma->vm_start > addr))\n\t\tgoto check_stack;\n\n\t/*\n\t * Ok, we have a good vm_area for this memory access, so we can handle\n\t * it.\n\t */\ngood_area:\n\t/*\n\t * Check that the permissions on the VMA allow for the fault which\n\t * occurred. If we encountered a write or exec fault, we must have\n\t * appropriate permissions, otherwise we allow any permission.\n\t */\n\tif (!(vma->vm_flags & vm_flags)) {\n\t\tfault = VM_FAULT_BADACCESS;\n\t\tgoto out;\n\t}\n\n\treturn handle_mm_fault(mm, vma, addr & PAGE_MASK, mm_flags);\n\ncheck_stack:\n\tif (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr))\n\t\tgoto good_area;\nout:\n\treturn fault;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,8 @@\n good_area:\n \t/*\n \t * Check that the permissions on the VMA allow for the fault which\n-\t * occurred.\n+\t * occurred. If we encountered a write or exec fault, we must have\n+\t * appropriate permissions, otherwise we allow any permission.\n \t */\n \tif (!(vma->vm_flags & vm_flags)) {\n \t\tfault = VM_FAULT_BADACCESS;",
        "diff_line_info": {
            "deleted_lines": [
                "\t * occurred."
            ],
            "added_lines": [
                "\t * occurred. If we encountered a write or exec fault, we must have",
                "\t * appropriate permissions, otherwise we allow any permission."
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9803",
        "func_name": "torvalds/linux/set_pte_at",
        "description": "arch/arm64/include/asm/pgtable.h in the Linux kernel before 3.15-rc5-next-20140519, as used in Android before 2016-07-05 on Nexus 5X and 6P devices, mishandles execute-only pages, which allows attackers to gain privileges via a crafted application, aka Android internal bug 28557020.",
        "git_url": "https://github.com/torvalds/linux/commit/5a0fdfada3a2aa50d7b947a2e958bf00cbe0d830",
        "commit_title": "Revert \"arm64: Introduce execute-only page access permissions\"",
        "commit_text": " This reverts commit bc07c2c6e9ed125d362af0214b6313dca180cb08.  While the aim is increased security for --x memory maps, it does not protect against kernel level reads. Until SECCOMP is implemented for arm64, revert this patch to avoid giving a false idea of execute-only mappings. ",
        "func_before": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\n\tset_pte(ptep, pte);\n}",
        "func": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_user(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\n\tset_pte(ptep, pte);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n \t\t\t      pte_t *ptep, pte_t pte)\n {\n-\tif (pte_valid_ng(pte)) {\n+\tif (pte_valid_user(pte)) {\n \t\tif (!pte_special(pte) && pte_exec(pte))\n \t\t\t__sync_icache_dcache(pte, addr);\n \t\tif (pte_dirty(pte) && pte_write(pte))",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (pte_valid_ng(pte)) {"
            ],
            "added_lines": [
                "\tif (pte_valid_user(pte)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/ElementAnimations::NotifyPlayersAnimationStarted",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/66cb1320242db9ce2954a539dc2d5410bf033dbd",
        "commit_title": "ElementAnimations should hold an ObservableList of AnimationPlayers.",
        "commit_text": " Before this, the AnimationPlayers were held in a linked list, and modifying the list while iterating could cause undefined behavior.  CQ_INCLUDE_TRYBOTS=master.tryserver.blink:linux_precise_blink_rel  Review-Url: https://codereview.chromium.org/2189813002 ",
        "func_before": "void ElementAnimations::NotifyPlayersAnimationStarted(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    int group) {\n  for (PlayersListNode* node = players_list_->head();\n       node != players_list_->end(); node = node->next()) {\n    AnimationPlayer* player = node->value();\n    player->NotifyAnimationStarted(monotonic_time, target_property, group);\n  }\n}",
        "func": "void ElementAnimations::NotifyPlayersAnimationStarted(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    int group) {\n  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n  AnimationPlayer* player;\n  // TODO(crbug.com/634916): Shouldn't manually iterate through the list if\n  // base::ObserverList has a callback mechanism.\n  while ((player = it.GetNext()) != nullptr)\n    player->NotifyAnimationStarted(monotonic_time, target_property, group);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,10 @@\n     base::TimeTicks monotonic_time,\n     TargetProperty::Type target_property,\n     int group) {\n-  for (PlayersListNode* node = players_list_->head();\n-       node != players_list_->end(); node = node->next()) {\n-    AnimationPlayer* player = node->value();\n+  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n+  AnimationPlayer* player;\n+  // TODO(crbug.com/634916): Shouldn't manually iterate through the list if\n+  // base::ObserverList has a callback mechanism.\n+  while ((player = it.GetNext()) != nullptr)\n     player->NotifyAnimationStarted(monotonic_time, target_property, group);\n-  }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  for (PlayersListNode* node = players_list_->head();",
                "       node != players_list_->end(); node = node->next()) {",
                "    AnimationPlayer* player = node->value();",
                "  }"
            ],
            "added_lines": [
                "  ElementAnimations::PlayersList::Iterator it(players_list_.get());",
                "  AnimationPlayer* player;",
                "  // TODO(crbug.com/634916): Shouldn't manually iterate through the list if",
                "  // base::ObserverList has a callback mechanism.",
                "  while ((player = it.GetNext()) != nullptr)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/ElementAnimations::RemovePlayer",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/66cb1320242db9ce2954a539dc2d5410bf033dbd",
        "commit_title": "ElementAnimations should hold an ObservableList of AnimationPlayers.",
        "commit_text": " Before this, the AnimationPlayers were held in a linked list, and modifying the list while iterating could cause undefined behavior.  CQ_INCLUDE_TRYBOTS=master.tryserver.blink:linux_precise_blink_rel  Review-Url: https://codereview.chromium.org/2189813002 ",
        "func_before": "void ElementAnimations::RemovePlayer(AnimationPlayer* player) {\n  for (PlayersListNode* node = players_list_->head();\n       node != players_list_->end(); node = node->next()) {\n    if (node->value() == player) {\n      node->RemoveFromList();\n      return;\n    }\n  }\n}",
        "func": "void ElementAnimations::RemovePlayer(AnimationPlayer* player) {\n  players_list_->RemoveObserver(player);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,3 @@\n void ElementAnimations::RemovePlayer(AnimationPlayer* player) {\n-  for (PlayersListNode* node = players_list_->head();\n-       node != players_list_->end(); node = node->next()) {\n-    if (node->value() == player) {\n-      node->RemoveFromList();\n-      return;\n-    }\n-  }\n+  players_list_->RemoveObserver(player);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  for (PlayersListNode* node = players_list_->head();",
                "       node != players_list_->end(); node = node->next()) {",
                "    if (node->value() == player) {",
                "      node->RemoveFromList();",
                "      return;",
                "    }",
                "  }"
            ],
            "added_lines": [
                "  players_list_->RemoveObserver(player);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/ElementAnimations::NotifyPlayersAnimationTakeover",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/66cb1320242db9ce2954a539dc2d5410bf033dbd",
        "commit_title": "ElementAnimations should hold an ObservableList of AnimationPlayers.",
        "commit_text": " Before this, the AnimationPlayers were held in a linked list, and modifying the list while iterating could cause undefined behavior.  CQ_INCLUDE_TRYBOTS=master.tryserver.blink:linux_precise_blink_rel  Review-Url: https://codereview.chromium.org/2189813002 ",
        "func_before": "void ElementAnimations::NotifyPlayersAnimationTakeover(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    double animation_start_time,\n    std::unique_ptr<AnimationCurve> curve) {\n  DCHECK(curve);\n  for (PlayersListNode* node = players_list_->head();\n       node != players_list_->end(); node = node->next()) {\n    std::unique_ptr<AnimationCurve> animation_curve = curve->Clone();\n    AnimationPlayer* player = node->value();\n    player->NotifyAnimationTakeover(monotonic_time, target_property,\n                                    animation_start_time,\n                                    std::move(animation_curve));\n  }\n}",
        "func": "void ElementAnimations::NotifyPlayersAnimationTakeover(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    double animation_start_time,\n    std::unique_ptr<AnimationCurve> curve) {\n  DCHECK(curve);\n  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n  AnimationPlayer* player;\n  while ((player = it.GetNext()) != nullptr) {\n    std::unique_ptr<AnimationCurve> animation_curve = curve->Clone();\n    player->NotifyAnimationTakeover(monotonic_time, target_property,\n                                    animation_start_time,\n                                    std::move(animation_curve));\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,10 +4,10 @@\n     double animation_start_time,\n     std::unique_ptr<AnimationCurve> curve) {\n   DCHECK(curve);\n-  for (PlayersListNode* node = players_list_->head();\n-       node != players_list_->end(); node = node->next()) {\n+  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n+  AnimationPlayer* player;\n+  while ((player = it.GetNext()) != nullptr) {\n     std::unique_ptr<AnimationCurve> animation_curve = curve->Clone();\n-    AnimationPlayer* player = node->value();\n     player->NotifyAnimationTakeover(monotonic_time, target_property,\n                                     animation_start_time,\n                                     std::move(animation_curve));",
        "diff_line_info": {
            "deleted_lines": [
                "  for (PlayersListNode* node = players_list_->head();",
                "       node != players_list_->end(); node = node->next()) {",
                "    AnimationPlayer* player = node->value();"
            ],
            "added_lines": [
                "  ElementAnimations::PlayersList::Iterator it(players_list_.get());",
                "  AnimationPlayer* player;",
                "  while ((player = it.GetNext()) != nullptr) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/ElementAnimations::AddPlayer",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/66cb1320242db9ce2954a539dc2d5410bf033dbd",
        "commit_title": "ElementAnimations should hold an ObservableList of AnimationPlayers.",
        "commit_text": " Before this, the AnimationPlayers were held in a linked list, and modifying the list while iterating could cause undefined behavior.  CQ_INCLUDE_TRYBOTS=master.tryserver.blink:linux_precise_blink_rel  Review-Url: https://codereview.chromium.org/2189813002 ",
        "func_before": "void ElementAnimations::AddPlayer(AnimationPlayer* player) {\n  players_list_->Append(player);\n}",
        "func": "void ElementAnimations::AddPlayer(AnimationPlayer* player) {\n  players_list_->AddObserver(player);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,3 @@\n void ElementAnimations::AddPlayer(AnimationPlayer* player) {\n-  players_list_->Append(player);\n+  players_list_->AddObserver(player);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  players_list_->Append(player);"
            ],
            "added_lines": [
                "  players_list_->AddObserver(player);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/ElementAnimations::NotifyAnimationTakeover",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/66cb1320242db9ce2954a539dc2d5410bf033dbd",
        "commit_title": "ElementAnimations should hold an ObservableList of AnimationPlayers.",
        "commit_text": " Before this, the AnimationPlayers were held in a linked list, and modifying the list while iterating could cause undefined behavior.  CQ_INCLUDE_TRYBOTS=master.tryserver.blink:linux_precise_blink_rel  Review-Url: https://codereview.chromium.org/2189813002 ",
        "func_before": "void ElementAnimations::NotifyAnimationTakeover(const AnimationEvent& event) {\n  DCHECK(event.target_property == TargetProperty::SCROLL_OFFSET);\n  if (!players_list_->empty()) {\n    std::unique_ptr<AnimationCurve> animation_curve = event.curve->Clone();\n    NotifyPlayersAnimationTakeover(event.monotonic_time, event.target_property,\n                                   event.animation_start_time,\n                                   std::move(animation_curve));\n  }\n}",
        "func": "void ElementAnimations::NotifyAnimationTakeover(const AnimationEvent& event) {\n  DCHECK(event.target_property == TargetProperty::SCROLL_OFFSET);\n  if (!IsEmpty()) {\n    std::unique_ptr<AnimationCurve> animation_curve = event.curve->Clone();\n    NotifyPlayersAnimationTakeover(event.monotonic_time, event.target_property,\n                                   event.animation_start_time,\n                                   std::move(animation_curve));\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n void ElementAnimations::NotifyAnimationTakeover(const AnimationEvent& event) {\n   DCHECK(event.target_property == TargetProperty::SCROLL_OFFSET);\n-  if (!players_list_->empty()) {\n+  if (!IsEmpty()) {\n     std::unique_ptr<AnimationCurve> animation_curve = event.curve->Clone();\n     NotifyPlayersAnimationTakeover(event.monotonic_time, event.target_property,\n                                    event.animation_start_time,",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!players_list_->empty()) {"
            ],
            "added_lines": [
                "  if (!IsEmpty()) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/ElementAnimations::IsEmpty",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/66cb1320242db9ce2954a539dc2d5410bf033dbd",
        "commit_title": "ElementAnimations should hold an ObservableList of AnimationPlayers.",
        "commit_text": " Before this, the AnimationPlayers were held in a linked list, and modifying the list while iterating could cause undefined behavior.  CQ_INCLUDE_TRYBOTS=master.tryserver.blink:linux_precise_blink_rel  Review-Url: https://codereview.chromium.org/2189813002 ",
        "func_before": "bool ElementAnimations::IsEmpty() const {\n  return players_list_->empty();\n}",
        "func": "bool ElementAnimations::IsEmpty() const {\n  return !players_list_->might_have_observers();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,3 @@\n bool ElementAnimations::IsEmpty() const {\n-  return players_list_->empty();\n+  return !players_list_->might_have_observers();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return players_list_->empty();"
            ],
            "added_lines": [
                "  return !players_list_->might_have_observers();"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/ElementAnimations::NotifyPlayersAnimationAborted",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/66cb1320242db9ce2954a539dc2d5410bf033dbd",
        "commit_title": "ElementAnimations should hold an ObservableList of AnimationPlayers.",
        "commit_text": " Before this, the AnimationPlayers were held in a linked list, and modifying the list while iterating could cause undefined behavior.  CQ_INCLUDE_TRYBOTS=master.tryserver.blink:linux_precise_blink_rel  Review-Url: https://codereview.chromium.org/2189813002 ",
        "func_before": "void ElementAnimations::NotifyPlayersAnimationAborted(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    int group) {\n  for (PlayersListNode* node = players_list_->head();\n       node != players_list_->end(); node = node->next()) {\n    AnimationPlayer* player = node->value();\n    player->NotifyAnimationAborted(monotonic_time, target_property, group);\n  }\n}",
        "func": "void ElementAnimations::NotifyPlayersAnimationAborted(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    int group) {\n  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n  AnimationPlayer* player;\n  while ((player = it.GetNext()) != nullptr)\n    player->NotifyAnimationAborted(monotonic_time, target_property, group);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,8 @@\n     base::TimeTicks monotonic_time,\n     TargetProperty::Type target_property,\n     int group) {\n-  for (PlayersListNode* node = players_list_->head();\n-       node != players_list_->end(); node = node->next()) {\n-    AnimationPlayer* player = node->value();\n+  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n+  AnimationPlayer* player;\n+  while ((player = it.GetNext()) != nullptr)\n     player->NotifyAnimationAborted(monotonic_time, target_property, group);\n-  }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  for (PlayersListNode* node = players_list_->head();",
                "       node != players_list_->end(); node = node->next()) {",
                "    AnimationPlayer* player = node->value();",
                "  }"
            ],
            "added_lines": [
                "  ElementAnimations::PlayersList::Iterator it(players_list_.get());",
                "  AnimationPlayer* player;",
                "  while ((player = it.GetNext()) != nullptr)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/ElementAnimations::NotifyPlayersAnimationFinished",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/66cb1320242db9ce2954a539dc2d5410bf033dbd",
        "commit_title": "ElementAnimations should hold an ObservableList of AnimationPlayers.",
        "commit_text": " Before this, the AnimationPlayers were held in a linked list, and modifying the list while iterating could cause undefined behavior.  CQ_INCLUDE_TRYBOTS=master.tryserver.blink:linux_precise_blink_rel  Review-Url: https://codereview.chromium.org/2189813002 ",
        "func_before": "void ElementAnimations::NotifyPlayersAnimationFinished(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    int group) {\n  for (PlayersListNode* node = players_list_->head();\n       node != players_list_->end(); node = node->next()) {\n    AnimationPlayer* player = node->value();\n    player->NotifyAnimationFinished(monotonic_time, target_property, group);\n  }\n}",
        "func": "void ElementAnimations::NotifyPlayersAnimationFinished(\n    base::TimeTicks monotonic_time,\n    TargetProperty::Type target_property,\n    int group) {\n  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n  AnimationPlayer* player;\n  while ((player = it.GetNext()) != nullptr)\n    player->NotifyAnimationFinished(monotonic_time, target_property, group);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,8 @@\n     base::TimeTicks monotonic_time,\n     TargetProperty::Type target_property,\n     int group) {\n-  for (PlayersListNode* node = players_list_->head();\n-       node != players_list_->end(); node = node->next()) {\n-    AnimationPlayer* player = node->value();\n+  ElementAnimations::PlayersList::Iterator it(players_list_.get());\n+  AnimationPlayer* player;\n+  while ((player = it.GetNext()) != nullptr)\n     player->NotifyAnimationFinished(monotonic_time, target_property, group);\n-  }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  for (PlayersListNode* node = players_list_->head();",
                "       node != players_list_->end(); node = node->next()) {",
                "    AnimationPlayer* player = node->value();",
                "  }"
            ],
            "added_lines": [
                "  ElementAnimations::PlayersList::Iterator it(players_list_.get());",
                "  AnimationPlayer* player;",
                "  while ((player = it.GetNext()) != nullptr)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/Animation::createCompositorPlayer",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7fec064b3a37032605f091ba1ba52846c0e05824",
        "commit_title": "Add pre finalizer to Animation to ensure compositor handles get cleaned up",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2188623006 ",
        "func_before": "void Animation::createCompositorPlayer()\n{\n    if (Platform::current()->isThreadedAnimationEnabled() && !m_compositorPlayer) {\n        ASSERT(Platform::current()->compositorSupport());\n        m_compositorPlayer = CompositorAnimationPlayer::create();\n        ASSERT(m_compositorPlayer);\n        m_compositorPlayer->setAnimationDelegate(this);\n        attachCompositorTimeline();\n    }\n\n    attachCompositedLayers();\n}",
        "func": "void Animation::createCompositorPlayer()\n{\n    if (Platform::current()->isThreadedAnimationEnabled() && !m_compositorPlayer) {\n        // We only need to pre-finalize if we are running animations on the compositor.\n        if (!m_preFinalizerRegistered) {\n            ThreadState::current()->registerPreFinalizer(this);\n            m_preFinalizerRegistered = true;\n        }\n\n        ASSERT(Platform::current()->compositorSupport());\n        m_compositorPlayer = CompositorAnimationPlayer::create();\n        ASSERT(m_compositorPlayer);\n        m_compositorPlayer->setAnimationDelegate(this);\n        attachCompositorTimeline();\n    }\n\n    attachCompositedLayers();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,12 @@\n void Animation::createCompositorPlayer()\n {\n     if (Platform::current()->isThreadedAnimationEnabled() && !m_compositorPlayer) {\n+        // We only need to pre-finalize if we are running animations on the compositor.\n+        if (!m_preFinalizerRegistered) {\n+            ThreadState::current()->registerPreFinalizer(this);\n+            m_preFinalizerRegistered = true;\n+        }\n+\n         ASSERT(Platform::current()->compositorSupport());\n         m_compositorPlayer = CompositorAnimationPlayer::create();\n         ASSERT(m_compositorPlayer);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        // We only need to pre-finalize if we are running animations on the compositor.",
                "        if (!m_preFinalizerRegistered) {",
                "            ThreadState::current()->registerPreFinalizer(this);",
                "            m_preFinalizerRegistered = true;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5153",
        "func_name": "chromium/Animation::Animation",
        "description": "The Web Animations implementation in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, improperly relies on list iteration, which allows remote attackers to cause a denial of service (use-after-destruction) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7fec064b3a37032605f091ba1ba52846c0e05824",
        "commit_title": "Add pre finalizer to Animation to ensure compositor handles get cleaned up",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2188623006 ",
        "func_before": "Animation::Animation(ExecutionContext* executionContext, AnimationTimeline& timeline, AnimationEffect* content)\n    : ActiveScriptWrappable(this)\n    , ActiveDOMObject(executionContext)\n    , m_playState(Idle)\n    , m_playbackRate(1)\n    , m_startTime(nullValue())\n    , m_holdTime(0)\n    , m_sequenceNumber(nextSequenceNumber())\n    , m_content(content)\n    , m_timeline(&timeline)\n    , m_paused(false)\n    , m_held(false)\n    , m_isPausedForTesting(false)\n    , m_isCompositedAnimationDisabledForTesting(false)\n    , m_outdated(false)\n    , m_finished(true)\n    , m_compositorState(nullptr)\n    , m_compositorPending(false)\n    , m_compositorGroup(0)\n    , m_currentTimePending(false)\n    , m_stateIsBeingUpdated(false)\n    , m_effectSuppressed(false)\n{\n    if (m_content) {\n        if (m_content->animation()) {\n            m_content->animation()->cancel();\n            m_content->animation()->setEffect(0);\n        }\n        m_content->attach(this);\n    }\n    InspectorInstrumentation::didCreateAnimation(m_timeline->document(), m_sequenceNumber);\n}",
        "func": "Animation::Animation(ExecutionContext* executionContext, AnimationTimeline& timeline, AnimationEffect* content)\n    : ActiveScriptWrappable(this)\n    , ActiveDOMObject(executionContext)\n    , m_playState(Idle)\n    , m_playbackRate(1)\n    , m_startTime(nullValue())\n    , m_holdTime(0)\n    , m_sequenceNumber(nextSequenceNumber())\n    , m_content(content)\n    , m_timeline(&timeline)\n    , m_paused(false)\n    , m_held(false)\n    , m_isPausedForTesting(false)\n    , m_isCompositedAnimationDisabledForTesting(false)\n    , m_outdated(false)\n    , m_finished(true)\n    , m_compositorState(nullptr)\n    , m_compositorPending(false)\n    , m_compositorGroup(0)\n    , m_preFinalizerRegistered(false)\n    , m_currentTimePending(false)\n    , m_stateIsBeingUpdated(false)\n    , m_effectSuppressed(false)\n{\n    if (m_content) {\n        if (m_content->animation()) {\n            m_content->animation()->cancel();\n            m_content->animation()->setEffect(0);\n        }\n        m_content->attach(this);\n    }\n    InspectorInstrumentation::didCreateAnimation(m_timeline->document(), m_sequenceNumber);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n     , m_compositorState(nullptr)\n     , m_compositorPending(false)\n     , m_compositorGroup(0)\n+    , m_preFinalizerRegistered(false)\n     , m_currentTimePending(false)\n     , m_stateIsBeingUpdated(false)\n     , m_effectSuppressed(false)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    , m_preFinalizerRegistered(false)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7395",
        "func_name": "skia/tangent_cubic",
        "description": "SkPath.cpp in Skia, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, does not properly validate the return values of ChopMonoAtY calls, which allows remote attackers to cause a denial of service (uninitialized memory access and application crash) or possibly have unspecified other impact via crafted graphics data.",
        "git_url": "https://skia.googlesource.com/skia/+/276e63361c73fed6c6528b322400ece81fd1d067",
        "commit_title": "Check results from calls to SkCubicClipper::ChopMonoAtY.",
        "commit_text": " GOLD_TRYBOT_URL= https://gold.skia.org/search?issue=2006143009  Review-Url: https://codereview.chromium.org/2006143009 ",
        "func_before": "static void tangent_cubic(const SkPoint pts[], SkScalar x, SkScalar y,\n        SkTDArray<SkVector>* tangents) {\n    if (!between(pts[0].fY, y, pts[1].fY) && !between(pts[1].fY, y, pts[2].fY)\n             && !between(pts[2].fY, y, pts[3].fY)) {\n        return;\n    }\n    if (!between(pts[0].fX, x, pts[1].fX) && !between(pts[1].fX, x, pts[2].fX)\n             && !between(pts[2].fX, x, pts[3].fX)) {\n        return;\n    }\n    SkPoint dst[10];\n    int n = SkChopCubicAtYExtrema(pts, dst);\n    for (int i = 0; i <= n; ++i) {\n        SkPoint* c = &dst[i * 3];\n        SkScalar t;\n        SkAssertResult(SkCubicClipper::ChopMonoAtY(c, y, &t));\n        SkScalar xt = eval_cubic_pts(c[0].fX, c[1].fX, c[2].fX, c[3].fX, t);\n        if (!SkScalarNearlyEqual(x, xt)) {\n            continue;\n        }\n        SkVector tangent;\n        SkEvalCubicAt(c, t, nullptr, &tangent, nullptr);\n        tangents->push(tangent);\n    }\n}",
        "func": "static void tangent_cubic(const SkPoint pts[], SkScalar x, SkScalar y,\n        SkTDArray<SkVector>* tangents) {\n    if (!between(pts[0].fY, y, pts[1].fY) && !between(pts[1].fY, y, pts[2].fY)\n             && !between(pts[2].fY, y, pts[3].fY)) {\n        return;\n    }\n    if (!between(pts[0].fX, x, pts[1].fX) && !between(pts[1].fX, x, pts[2].fX)\n             && !between(pts[2].fX, x, pts[3].fX)) {\n        return;\n    }\n    SkPoint dst[10];\n    int n = SkChopCubicAtYExtrema(pts, dst);\n    for (int i = 0; i <= n; ++i) {\n        SkPoint* c = &dst[i * 3];\n        SkScalar t;\n        if (!SkCubicClipper::ChopMonoAtY(c, y, &t)) {\n          continue;\n        }\n        SkScalar xt = eval_cubic_pts(c[0].fX, c[1].fX, c[2].fX, c[3].fX, t);\n        if (!SkScalarNearlyEqual(x, xt)) {\n            continue;\n        }\n        SkVector tangent;\n        SkEvalCubicAt(c, t, nullptr, &tangent, nullptr);\n        tangents->push(tangent);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,9 @@\n     for (int i = 0; i <= n; ++i) {\n         SkPoint* c = &dst[i * 3];\n         SkScalar t;\n-        SkAssertResult(SkCubicClipper::ChopMonoAtY(c, y, &t));\n+        if (!SkCubicClipper::ChopMonoAtY(c, y, &t)) {\n+          continue;\n+        }\n         SkScalar xt = eval_cubic_pts(c[0].fX, c[1].fX, c[2].fX, c[3].fX, t);\n         if (!SkScalarNearlyEqual(x, xt)) {\n             continue;",
        "diff_line_info": {
            "deleted_lines": [
                "        SkAssertResult(SkCubicClipper::ChopMonoAtY(c, y, &t));"
            ],
            "added_lines": [
                "        if (!SkCubicClipper::ChopMonoAtY(c, y, &t)) {",
                "          continue;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7395",
        "func_name": "skia/winding_mono_cubic",
        "description": "SkPath.cpp in Skia, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, does not properly validate the return values of ChopMonoAtY calls, which allows remote attackers to cause a denial of service (uninitialized memory access and application crash) or possibly have unspecified other impact via crafted graphics data.",
        "git_url": "https://skia.googlesource.com/skia/+/276e63361c73fed6c6528b322400ece81fd1d067",
        "commit_title": "Check results from calls to SkCubicClipper::ChopMonoAtY.",
        "commit_text": " GOLD_TRYBOT_URL= https://gold.skia.org/search?issue=2006143009  Review-Url: https://codereview.chromium.org/2006143009 ",
        "func_before": "static int winding_mono_cubic(const SkPoint pts[], SkScalar x, SkScalar y, int* onCurveCount) {\n    SkScalar y0 = pts[0].fY;\n    SkScalar y3 = pts[3].fY;\n\n    int dir = 1;\n    if (y0 > y3) {\n        SkTSwap(y0, y3);\n        dir = -1;\n    }\n    if (y < y0 || y > y3) {\n        return 0;\n    }\n    if (checkOnCurve(x, y, pts[0], pts[3])) {\n        *onCurveCount += 1;\n        return 0;\n    }\n    if (y == y3) {\n        return 0;\n    }\n\n    // quickreject or quickaccept\n    SkScalar min, max;\n    find_minmax<4>(pts, &min, &max);\n    if (x < min) {\n        return 0;\n    }\n    if (x > max) {\n        return dir;\n    }\n\n    // compute the actual x(t) value\n    SkScalar t;\n    SkAssertResult(SkCubicClipper::ChopMonoAtY(pts, y, &t));\n    SkScalar xt = eval_cubic_pts(pts[0].fX, pts[1].fX, pts[2].fX, pts[3].fX, t);\n    if (SkScalarNearlyEqual(xt, x)) {\n        if (x != pts[3].fX || y != pts[3].fY) {  // don't test end points; they're start points\n            *onCurveCount += 1;\n            return 0;\n        }\n    }\n    return xt < x ? dir : 0;\n}",
        "func": "static int winding_mono_cubic(const SkPoint pts[], SkScalar x, SkScalar y, int* onCurveCount) {\n    SkScalar y0 = pts[0].fY;\n    SkScalar y3 = pts[3].fY;\n\n    int dir = 1;\n    if (y0 > y3) {\n        SkTSwap(y0, y3);\n        dir = -1;\n    }\n    if (y < y0 || y > y3) {\n        return 0;\n    }\n    if (checkOnCurve(x, y, pts[0], pts[3])) {\n        *onCurveCount += 1;\n        return 0;\n    }\n    if (y == y3) {\n        return 0;\n    }\n\n    // quickreject or quickaccept\n    SkScalar min, max;\n    find_minmax<4>(pts, &min, &max);\n    if (x < min) {\n        return 0;\n    }\n    if (x > max) {\n        return dir;\n    }\n\n    // compute the actual x(t) value\n    SkScalar t;\n    if (!SkCubicClipper::ChopMonoAtY(pts, y, &t)) {\n      return 0;\n    }\n    SkScalar xt = eval_cubic_pts(pts[0].fX, pts[1].fX, pts[2].fX, pts[3].fX, t);\n    if (SkScalarNearlyEqual(xt, x)) {\n        if (x != pts[3].fX || y != pts[3].fY) {  // don't test end points; they're start points\n            *onCurveCount += 1;\n            return 0;\n        }\n    }\n    return xt < x ? dir : 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,9 @@\n \n     // compute the actual x(t) value\n     SkScalar t;\n-    SkAssertResult(SkCubicClipper::ChopMonoAtY(pts, y, &t));\n+    if (!SkCubicClipper::ChopMonoAtY(pts, y, &t)) {\n+      return 0;\n+    }\n     SkScalar xt = eval_cubic_pts(pts[0].fX, pts[1].fX, pts[2].fX, pts[3].fX, t);\n     if (SkScalarNearlyEqual(xt, x)) {\n         if (x != pts[3].fX || y != pts[3].fY) {  // don't test end points; they're start points",
        "diff_line_info": {
            "deleted_lines": [
                "    SkAssertResult(SkCubicClipper::ChopMonoAtY(pts, y, &t));"
            ],
            "added_lines": [
                "    if (!SkCubicClipper::ChopMonoAtY(pts, y, &t)) {",
                "      return 0;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7117",
        "func_name": "torvalds/linux/__sys_recvmmsg",
        "description": "Use-after-free vulnerability in the __sys_recvmmsg function in net/socket.c in the Linux kernel before 4.5.2 allows remote attackers to execute arbitrary code via vectors involving a recvmmsg system call that is mishandled during error processing.",
        "git_url": "https://github.com/torvalds/linux/commit/34b88a68f26a75e4fded796f1a49c40f82234b7d",
        "commit_title": "net: Fix use after free in the recvmmsg exit path",
        "commit_text": " The syzkaller fuzzer hit the following use-after-free:    Call Trace:    [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295    [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261    [<     inline     >] SYSC_recvmmsg net/socket.c:2281    [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270    [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a   arch/x86/entry/entry_64.S:185  And, as Dmitry rightly assessed, that is because we can drop the reference and then touch it when the underlying recvmsg calls return some packets and then hit an error, which will make recvmmsg to set sock->sk->sk_err, oops, fix it.  Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com> Cc: Alexander Potapenko <glider@google.com> Cc: Eric Dumazet <edumazet@google.com> Cc: Kostya Serebryany <kcc@google.com> Cc: Sasha Levin <sasha.levin@oracle.com> http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com",
        "func_before": "int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, struct timespec *timeout)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct timespec end_time;\n\n\tif (timeout &&\n\t    poll_select_set_timeout(&end_time, timeout->tv_sec,\n\t\t\t\t    timeout->tv_nsec))\n\t\treturn -EINVAL;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\terr = sock_error(sock->sk);\n\tif (err)\n\t\tgoto out_put;\n\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\n\twhile (datagrams < vlen) {\n\t\t/*\n\t\t * No need to ask LSM for more than the first datagram.\n\t\t */\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_recvmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\n\t\t/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */\n\t\tif (flags & MSG_WAITFORONE)\n\t\t\tflags |= MSG_DONTWAIT;\n\n\t\tif (timeout) {\n\t\t\tktime_get_ts(timeout);\n\t\t\t*timeout = timespec_sub(end_time, *timeout);\n\t\t\tif (timeout->tv_sec < 0) {\n\t\t\t\ttimeout->tv_sec = timeout->tv_nsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Timeout, return less than vlen datagrams */\n\t\t\tif (timeout->tv_nsec == 0 && timeout->tv_sec == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Out of band data, return right away */\n\t\tif (msg_sys.msg_flags & MSG_OOB)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\nout_put:\n\tfput_light(sock->file, fput_needed);\n\n\tif (err == 0)\n\t\treturn datagrams;\n\n\tif (datagrams != 0) {\n\t\t/*\n\t\t * We may return less entries than requested (vlen) if the\n\t\t * sock is non block and there aren't enough datagrams...\n\t\t */\n\t\tif (err != -EAGAIN) {\n\t\t\t/*\n\t\t\t * ... or  if recvmsg returns an error after we\n\t\t\t * received some datagrams, where we record the\n\t\t\t * error to return on the next call or if the\n\t\t\t * app asks about it using getsockopt(SO_ERROR).\n\t\t\t */\n\t\t\tsock->sk->sk_err = -err;\n\t\t}\n\n\t\treturn datagrams;\n\t}\n\n\treturn err;\n}",
        "func": "int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, struct timespec *timeout)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct timespec end_time;\n\n\tif (timeout &&\n\t    poll_select_set_timeout(&end_time, timeout->tv_sec,\n\t\t\t\t    timeout->tv_nsec))\n\t\treturn -EINVAL;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\terr = sock_error(sock->sk);\n\tif (err)\n\t\tgoto out_put;\n\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\n\twhile (datagrams < vlen) {\n\t\t/*\n\t\t * No need to ask LSM for more than the first datagram.\n\t\t */\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_recvmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\n\t\t/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */\n\t\tif (flags & MSG_WAITFORONE)\n\t\t\tflags |= MSG_DONTWAIT;\n\n\t\tif (timeout) {\n\t\t\tktime_get_ts(timeout);\n\t\t\t*timeout = timespec_sub(end_time, *timeout);\n\t\t\tif (timeout->tv_sec < 0) {\n\t\t\t\ttimeout->tv_sec = timeout->tv_nsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Timeout, return less than vlen datagrams */\n\t\t\tif (timeout->tv_nsec == 0 && timeout->tv_sec == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Out of band data, return right away */\n\t\tif (msg_sys.msg_flags & MSG_OOB)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tif (err == 0)\n\t\tgoto out_put;\n\n\tif (datagrams == 0) {\n\t\tdatagrams = err;\n\t\tgoto out_put;\n\t}\n\n\t/*\n\t * We may return less entries than requested (vlen) if the\n\t * sock is non block and there aren't enough datagrams...\n\t */\n\tif (err != -EAGAIN) {\n\t\t/*\n\t\t * ... or  if recvmsg returns an error after we\n\t\t * received some datagrams, where we record the\n\t\t * error to return on the next call or if the\n\t\t * app asks about it using getsockopt(SO_ERROR).\n\t\t */\n\t\tsock->sk->sk_err = -err;\n\t}\nout_put:\n\tfput_light(sock->file, fput_needed);\n\n\treturn datagrams;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,29 +76,29 @@\n \t\tcond_resched();\n \t}\n \n+\tif (err == 0)\n+\t\tgoto out_put;\n+\n+\tif (datagrams == 0) {\n+\t\tdatagrams = err;\n+\t\tgoto out_put;\n+\t}\n+\n+\t/*\n+\t * We may return less entries than requested (vlen) if the\n+\t * sock is non block and there aren't enough datagrams...\n+\t */\n+\tif (err != -EAGAIN) {\n+\t\t/*\n+\t\t * ... or  if recvmsg returns an error after we\n+\t\t * received some datagrams, where we record the\n+\t\t * error to return on the next call or if the\n+\t\t * app asks about it using getsockopt(SO_ERROR).\n+\t\t */\n+\t\tsock->sk->sk_err = -err;\n+\t}\n out_put:\n \tfput_light(sock->file, fput_needed);\n \n-\tif (err == 0)\n-\t\treturn datagrams;\n-\n-\tif (datagrams != 0) {\n-\t\t/*\n-\t\t * We may return less entries than requested (vlen) if the\n-\t\t * sock is non block and there aren't enough datagrams...\n-\t\t */\n-\t\tif (err != -EAGAIN) {\n-\t\t\t/*\n-\t\t\t * ... or  if recvmsg returns an error after we\n-\t\t\t * received some datagrams, where we record the\n-\t\t\t * error to return on the next call or if the\n-\t\t\t * app asks about it using getsockopt(SO_ERROR).\n-\t\t\t */\n-\t\t\tsock->sk->sk_err = -err;\n-\t\t}\n-\n-\t\treturn datagrams;\n-\t}\n-\n-\treturn err;\n+\treturn datagrams;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (err == 0)",
                "\t\treturn datagrams;",
                "",
                "\tif (datagrams != 0) {",
                "\t\t/*",
                "\t\t * We may return less entries than requested (vlen) if the",
                "\t\t * sock is non block and there aren't enough datagrams...",
                "\t\t */",
                "\t\tif (err != -EAGAIN) {",
                "\t\t\t/*",
                "\t\t\t * ... or  if recvmsg returns an error after we",
                "\t\t\t * received some datagrams, where we record the",
                "\t\t\t * error to return on the next call or if the",
                "\t\t\t * app asks about it using getsockopt(SO_ERROR).",
                "\t\t\t */",
                "\t\t\tsock->sk->sk_err = -err;",
                "\t\t}",
                "",
                "\t\treturn datagrams;",
                "\t}",
                "",
                "\treturn err;"
            ],
            "added_lines": [
                "\tif (err == 0)",
                "\t\tgoto out_put;",
                "",
                "\tif (datagrams == 0) {",
                "\t\tdatagrams = err;",
                "\t\tgoto out_put;",
                "\t}",
                "",
                "\t/*",
                "\t * We may return less entries than requested (vlen) if the",
                "\t * sock is non block and there aren't enough datagrams...",
                "\t */",
                "\tif (err != -EAGAIN) {",
                "\t\t/*",
                "\t\t * ... or  if recvmsg returns an error after we",
                "\t\t * received some datagrams, where we record the",
                "\t\t * error to return on the next call or if the",
                "\t\t * app asks about it using getsockopt(SO_ERROR).",
                "\t\t */",
                "\t\tsock->sk->sk_err = -err;",
                "\t}",
                "\treturn datagrams;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0808",
        "func_name": "android/readU16",
        "description": "Integer overflow in the getCoverageFormat12 function in CmapCoverage.cpp in the Minikin library in Android 5.x before 5.1.1 LMY49G and 6.x before 2016-02-01 allows attackers to cause a denial of service (continuous rebooting) via an application that triggers loading of a crafted TTF font, aka internal bug 25645298.",
        "git_url": "https://android.googlesource.com/platform/frameworks/minikin/+/ed4c8d79153baab7f26562afb8930652dfbf853b",
        "commit_title": "Avoid integer overflows in parsing fonts",
        "commit_text": " A malformed TTF can cause size calculations to overflow. This patch checks the maximum reasonable value so that the total size fits in 32 bits. It also adds some explicit casting to avoid possible technical undefined behavior when parsing sized unsigned values.  Bug: 25645298 (cherry picked from commit 183c9ec2800baa2ce099ee260c6cbc6121cf1274) ",
        "func_before": "static uint32_t readU16(const uint8_t* data, size_t offset) {\n    return data[offset] << 8 | data[offset + 1];\n}",
        "func": "static uint32_t readU16(const uint8_t* data, size_t offset) {\n    return ((uint32_t)data[offset]) << 8 | ((uint32_t)data[offset + 1]);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,3 @@\n static uint32_t readU16(const uint8_t* data, size_t offset) {\n-    return data[offset] << 8 | data[offset + 1];\n+    return ((uint32_t)data[offset]) << 8 | ((uint32_t)data[offset + 1]);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return data[offset] << 8 | data[offset + 1];"
            ],
            "added_lines": [
                "    return ((uint32_t)data[offset]) << 8 | ((uint32_t)data[offset + 1]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0808",
        "func_name": "android/getCoverageFormat12",
        "description": "Integer overflow in the getCoverageFormat12 function in CmapCoverage.cpp in the Minikin library in Android 5.x before 5.1.1 LMY49G and 6.x before 2016-02-01 allows attackers to cause a denial of service (continuous rebooting) via an application that triggers loading of a crafted TTF font, aka internal bug 25645298.",
        "git_url": "https://android.googlesource.com/platform/frameworks/minikin/+/ed4c8d79153baab7f26562afb8930652dfbf853b",
        "commit_title": "Avoid integer overflows in parsing fonts",
        "commit_text": " A malformed TTF can cause size calculations to overflow. This patch checks the maximum reasonable value so that the total size fits in 32 bits. It also adds some explicit casting to avoid possible technical undefined behavior when parsing sized unsigned values.  Bug: 25645298 (cherry picked from commit 183c9ec2800baa2ce099ee260c6cbc6121cf1274) ",
        "func_before": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n    const size_t kNGroupsOffset = 12;\n    const size_t kFirstGroupOffset = 16;\n    const size_t kGroupSize = 12;\n    const size_t kStartCharCodeOffset = 0;\n    const size_t kEndCharCodeOffset = 4;\n    if (kFirstGroupOffset > size) {\n        return false;\n    }\n    uint32_t nGroups = readU32(data, kNGroupsOffset);\n    if (kFirstGroupOffset + nGroups * kGroupSize > size) {\n        return false;\n    }\n    for (uint32_t i = 0; i < nGroups; i++) {\n        uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n        uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n        uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n        addRange(coverage, start, end + 1);  // file is inclusive, vector is exclusive\n    }\n    return true;\n}",
        "func": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n    const size_t kNGroupsOffset = 12;\n    const size_t kFirstGroupOffset = 16;\n    const size_t kGroupSize = 12;\n    const size_t kStartCharCodeOffset = 0;\n    const size_t kEndCharCodeOffset = 4;\n    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow\n    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.\n    if (kFirstGroupOffset > size) {\n        return false;\n    }\n    uint32_t nGroups = readU32(data, kNGroupsOffset);\n    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {\n        return false;\n    }\n    for (uint32_t i = 0; i < nGroups; i++) {\n        uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n        uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n        uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n        addRange(coverage, start, end + 1);  // file is inclusive, vector is exclusive\n    }\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,11 +4,13 @@\n     const size_t kGroupSize = 12;\n     const size_t kStartCharCodeOffset = 0;\n     const size_t kEndCharCodeOffset = 4;\n+    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow\n+    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.\n     if (kFirstGroupOffset > size) {\n         return false;\n     }\n     uint32_t nGroups = readU32(data, kNGroupsOffset);\n-    if (kFirstGroupOffset + nGroups * kGroupSize > size) {\n+    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {\n         return false;\n     }\n     for (uint32_t i = 0; i < nGroups; i++) {",
        "diff_line_info": {
            "deleted_lines": [
                "    if (kFirstGroupOffset + nGroups * kGroupSize > size) {"
            ],
            "added_lines": [
                "    const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;  // protection against overflow",
                "    // For all values < kMaxNGroups, kFirstGroupOffset + nGroups * kGroupSize fits in 32 bits.",
                "    if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0808",
        "func_name": "android/readU32",
        "description": "Integer overflow in the getCoverageFormat12 function in CmapCoverage.cpp in the Minikin library in Android 5.x before 5.1.1 LMY49G and 6.x before 2016-02-01 allows attackers to cause a denial of service (continuous rebooting) via an application that triggers loading of a crafted TTF font, aka internal bug 25645298.",
        "git_url": "https://android.googlesource.com/platform/frameworks/minikin/+/ed4c8d79153baab7f26562afb8930652dfbf853b",
        "commit_title": "Avoid integer overflows in parsing fonts",
        "commit_text": " A malformed TTF can cause size calculations to overflow. This patch checks the maximum reasonable value so that the total size fits in 32 bits. It also adds some explicit casting to avoid possible technical undefined behavior when parsing sized unsigned values.  Bug: 25645298 (cherry picked from commit 183c9ec2800baa2ce099ee260c6cbc6121cf1274) ",
        "func_before": "static uint32_t readU32(const uint8_t* data, size_t offset) {\n    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];\n}",
        "func": "static uint32_t readU32(const uint8_t* data, size_t offset) {\n    return ((uint32_t)data[offset]) << 24 | ((uint32_t)data[offset + 1]) << 16 |\n        ((uint32_t)data[offset + 2]) << 8 | ((uint32_t)data[offset + 3]);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,4 @@\n static uint32_t readU32(const uint8_t* data, size_t offset) {\n-    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];\n+    return ((uint32_t)data[offset]) << 24 | ((uint32_t)data[offset + 1]) << 16 |\n+        ((uint32_t)data[offset + 2]) << 8 | ((uint32_t)data[offset + 3]);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];"
            ],
            "added_lines": [
                "    return ((uint32_t)data[offset]) << 24 | ((uint32_t)data[offset + 1]) << 16 |",
                "        ((uint32_t)data[offset + 2]) << 8 | ((uint32_t)data[offset + 3]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0560",
        "func_name": "wireshark/dissect_wccp2r1_address_table_info",
        "description": "The dissect_wccp2r1_address_table_info function in epan/dissectors/packet-wccp.c in the WCCP dissector in Wireshark 1.10.x before 1.10.12 and 1.12.x before 1.12.3 does not initialize certain data structures, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/a442a1c0e815fd61416cf408bd74d85a042ccc6a",
        "commit_title": "WCCP: initialize address table to 0",
        "commit_text": " It prevents an uninitialized access later on if an exception is triggered before filling the table  Bug: 10806",
        "func_before": "static gint\ndissect_wccp2r1_address_table_info(tvbuff_t *tvb, int offset,\n                                   int length, packet_info *pinfo, proto_tree *info_tree)\n{\n  guint16 address_length;\n  guint32 i;\n  proto_tree *element_tree=NULL;\n  proto_item *tf=NULL;\n\n  wccp_wccp_address_table.in_use = TRUE;\n\n  if (length < 2*4)\n    return length - 2*4;\n\n\n  wccp_wccp_address_table.family = tvb_get_ntohs(tvb,offset);\n\n  proto_tree_add_item(info_tree, hf_address_table_family, tvb,\n                        offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  address_length = tvb_get_ntohs(tvb,offset);\n  proto_tree_add_item(info_tree, hf_address_table_address_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  wccp_wccp_address_table.table_length =  tvb_get_ntohl(tvb,offset);\n  tf = proto_tree_add_item(info_tree, hf_address_table_length, tvb, offset, 4, ENC_BIG_ENDIAN);\n  element_tree = proto_item_add_subtree(tf, ett_table_element);\n\n  EAT(4);\n\n  /* check if the length is valid and allocate the tables if needed*/\n  switch (wccp_wccp_address_table.family) {\n  case 1:\n    if (wccp_wccp_address_table.table_ipv4 == NULL)\n      wccp_wccp_address_table.table_ipv4 = (guint32 *)\n        wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);\n    if (address_length != 4) {\n      expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                             \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",\n                             address_length);\n      address_length = 4;\n    }\n    break;\n  case 2:\n    if (wccp_wccp_address_table.table_ipv6 == NULL)\n      wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)\n        wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));\n    if (address_length != 16) {\n      expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                             \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",\n                             address_length);\n      address_length=16;\n    }\n    break;\n  default:\n    expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,\n                    \"Unknown address family: %d\", wccp_wccp_address_table.family);\n  };\n\n  /* now read the addresses and print/store them */\n\n  for(i=0; i<wccp_wccp_address_table.table_length; i++) {\n    const gchar* addr;\n\n    /* do we have space? */\n    if (length < address_length) {\n      expert_add_info_format(pinfo, tf, &ei_wccp_length_bad, \"Ran out of space to decode\");\n\n      /* first clean up: */\n      wccp_wccp_address_table.in_use = FALSE;\n      wccp_wccp_address_table.family = -1;\n      wccp_wccp_address_table.version = -1;\n      wccp_wccp_address_table.table_length = 0;\n      wccp_wccp_address_table.table_ipv4 = (guint32 *) NULL;\n      wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)NULL;\n\n      /* ABORT The decode */\n      return length - address_length;\n    }\n\n    switch (wccp_wccp_address_table.family) {\n    case 1:\n      /* IPv4 */\n      addr  =  tvb_ip_to_str(tvb, offset);\n      if (wccp_wccp_address_table.table_ipv4 != NULL)\n        wccp_wccp_address_table.table_ipv4[i] = tvb_get_ntohl(tvb,offset);\n      break;\n    case 2:\n      /* IPv6 */\n      addr = tvb_ip6_to_str(tvb,offset);\n      if (wccp_wccp_address_table.table_ipv6 != NULL)\n        tvb_get_ipv6(tvb, offset, &(wccp_wccp_address_table.table_ipv6[i]));\n      break;\n    default:\n      addr = wmem_strdup_printf(wmem_packet_scope(), \"unknown family\");\n    };\n\n    if (element_tree) {\n      proto_tree_add_string_format_value(element_tree, hf_address_table_element, tvb,\n                                         offset, address_length, addr,\n                                         \"%d: %s\", i+1, addr);\n    }\n    EAT(address_length);\n  }\n  return length;\n}",
        "func": "static gint\ndissect_wccp2r1_address_table_info(tvbuff_t *tvb, int offset,\n                                   int length, packet_info *pinfo, proto_tree *info_tree)\n{\n  guint16 address_length;\n  guint32 i;\n  proto_tree *element_tree=NULL;\n  proto_item *tf=NULL;\n\n  wccp_wccp_address_table.in_use = TRUE;\n\n  if (length < 2*4)\n    return length - 2*4;\n\n\n  wccp_wccp_address_table.family = tvb_get_ntohs(tvb,offset);\n\n  proto_tree_add_item(info_tree, hf_address_table_family, tvb,\n                        offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  address_length = tvb_get_ntohs(tvb,offset);\n  proto_tree_add_item(info_tree, hf_address_table_address_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  wccp_wccp_address_table.table_length =  tvb_get_ntohl(tvb,offset);\n  tf = proto_tree_add_item(info_tree, hf_address_table_length, tvb, offset, 4, ENC_BIG_ENDIAN);\n  element_tree = proto_item_add_subtree(tf, ett_table_element);\n\n  EAT(4);\n\n  /* check if the length is valid and allocate the tables if needed*/\n  switch (wccp_wccp_address_table.family) {\n  case 1:\n    if (wccp_wccp_address_table.table_ipv4 == NULL)\n      wccp_wccp_address_table.table_ipv4 = (guint32 *)\n        wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);\n    if (address_length != 4) {\n      expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                             \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",\n                             address_length);\n      address_length = 4;\n    }\n    break;\n  case 2:\n    if (wccp_wccp_address_table.table_ipv6 == NULL)\n      wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)\n        wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));\n    if (address_length != 16) {\n      expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                             \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",\n                             address_length);\n      address_length=16;\n    }\n    break;\n  default:\n    expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,\n                    \"Unknown address family: %d\", wccp_wccp_address_table.family);\n  };\n\n  /* now read the addresses and print/store them */\n\n  for(i=0; i<wccp_wccp_address_table.table_length; i++) {\n    const gchar* addr;\n\n    /* do we have space? */\n    if (length < address_length) {\n      expert_add_info_format(pinfo, tf, &ei_wccp_length_bad, \"Ran out of space to decode\");\n\n      /* first clean up: */\n      wccp_wccp_address_table.in_use = FALSE;\n      wccp_wccp_address_table.family = -1;\n      wccp_wccp_address_table.version = -1;\n      wccp_wccp_address_table.table_length = 0;\n      wccp_wccp_address_table.table_ipv4 = (guint32 *) NULL;\n      wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)NULL;\n\n      /* ABORT The decode */\n      return length - address_length;\n    }\n\n    switch (wccp_wccp_address_table.family) {\n    case 1:\n      /* IPv4 */\n      addr  =  tvb_ip_to_str(tvb, offset);\n      if (wccp_wccp_address_table.table_ipv4 != NULL)\n        wccp_wccp_address_table.table_ipv4[i] = tvb_get_ntohl(tvb,offset);\n      break;\n    case 2:\n      /* IPv6 */\n      addr = tvb_ip6_to_str(tvb,offset);\n      if (wccp_wccp_address_table.table_ipv6 != NULL)\n        tvb_get_ipv6(tvb, offset, &(wccp_wccp_address_table.table_ipv6[i]));\n      break;\n    default:\n      addr = wmem_strdup_printf(wmem_packet_scope(), \"unknown family\");\n    };\n\n    if (element_tree) {\n      proto_tree_add_string_format_value(element_tree, hf_address_table_element, tvb,\n                                         offset, address_length, addr,\n                                         \"%d: %s\", i+1, addr);\n    }\n    EAT(address_length);\n  }\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,7 @@\n   case 1:\n     if (wccp_wccp_address_table.table_ipv4 == NULL)\n       wccp_wccp_address_table.table_ipv4 = (guint32 *)\n-        wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);\n+        wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);\n     if (address_length != 4) {\n       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",\n@@ -45,7 +45,7 @@\n   case 2:\n     if (wccp_wccp_address_table.table_ipv6 == NULL)\n       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)\n-        wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));\n+        wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));\n     if (address_length != 16) {\n       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,\n                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
        "diff_line_info": {
            "deleted_lines": [
                "        wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
                "        wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));"
            ],
            "added_lines": [
                "        wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
                "        wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7540",
        "func_name": "ImageMagick/WriteRGFImage",
        "description": "coders/rgf.c in ImageMagick before 6.9.4-10 allows remote attackers to cause a denial of service (assertion failure) by converting an image to rgf format.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a0108a892f9ea3c2bb1e7a49b7d71376c2ecbff7",
        "commit_title": "Fix abort when writing to rgf format",
        "commit_text": " The rgf format (LEGO MINDSTORMS EV3 images) caused a software abort because exception == NULL. When WriteRGFImage is called from WriteImage, it is only passed two parameters, not three. So, removed the extra parameter and use image->exception instead as in other coders.",
        "func_before": "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  int\n    bit;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  unsigned char\n    byte;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if((image->columns > 255L) || (image->rows > 255L))\n    ThrowWriterException(ImageError,\"Dimensions must be less than 255x255\");\n  /*\n    Write header (just the image dimensions)\n  */\n  (void) WriteBlobByte(image,image->columns & 0xff);\n  (void) WriteBlobByte(image,image->rows & 0xff);\n  /*\n    Convert MIFF to bit pixels.\n  */\n  (void) SetImageType(image,BilevelType);\n  x=0;\n  y=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      byte>>=1;\n      if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n        byte|=0x80;\n      bit++;\n      if (bit == 8)\n        {\n          /*\n            Write a bitmap byte to the image file.\n          */\n       \t  (void) WriteBlobByte(image,byte);\n          bit=0;\n          byte=0;\n        }\n      p++;\n    }\n    if (bit != 0)\n      (void) WriteBlobByte(image,byte);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    status;\n\n  int\n    bit;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  unsigned char\n    byte;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if((image->columns > 255L) || (image->rows > 255L))\n    ThrowWriterException(ImageError,\"Dimensions must be less than 255x255\");\n  /*\n    Write header (just the image dimensions)\n  */\n  (void) WriteBlobByte(image,image->columns & 0xff);\n  (void) WriteBlobByte(image,image->rows & 0xff);\n  /*\n    Convert MIFF to bit pixels.\n  */\n  (void) SetImageType(image,BilevelType);\n  x=0;\n  y=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      byte>>=1;\n      if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n        byte|=0x80;\n      bit++;\n      if (bit == 8)\n        {\n          /*\n            Write a bitmap byte to the image file.\n          */\n       \t  (void) WriteBlobByte(image,byte);\n          bit=0;\n          byte=0;\n        }\n      p++;\n    }\n    if (bit != 0)\n      (void) WriteBlobByte(image,byte);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,4 @@\n-static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,\n-  ExceptionInfo *exception)\n+static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)\n {\n   MagickBooleanType\n     status;\n@@ -28,9 +27,7 @@\n   assert(image->signature == MagickSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n-  assert(exception != (ExceptionInfo *) NULL);\n-  assert(exception->signature == MagickSignature);\n-  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n+  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n   if (status == MagickFalse)\n     return(status);\n   (void) TransformImageColorspace(image,sRGBColorspace);\n@@ -49,7 +46,7 @@\n   y=0;\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n-    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n+    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n     if (p == (const PixelPacket *) NULL)\n       break;\n     bit=0;",
        "diff_line_info": {
            "deleted_lines": [
                "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,",
                "  ExceptionInfo *exception)",
                "  assert(exception != (ExceptionInfo *) NULL);",
                "  assert(exception->signature == MagickSignature);",
                "  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);",
                "    p=GetVirtualPixels(image,0,y,image->columns,1,exception);"
            ],
            "added_lines": [
                "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)",
                "  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);",
                "    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-7971",
        "func_name": "xen-project/xen/do_xenpmu_op",
        "description": "Xen 3.2.x through 4.6.x does not limit the number of printk console messages when logging certain pmu and profiling hypercalls, which allows local guests to cause a denial of service via a sequence of crafted (1) HYPERCALL_xenoprof_op hypercalls, which are not properly handled in the do_xenoprof_op function in common/xenoprof.c, or (2) HYPERVISOR_xenpmu_op hypercalls, which are not properly handled in the do_xenpmu_op function in arch/x86/cpu/vpmu.c.",
        "git_url": "https://github.com/xen-project/xen/commit/95e7415843b94c346e5ba8682665f508f220e04b",
        "commit_title": "x86: rate-limit logging in do_xen{oprof,pmu}_op()",
        "commit_text": " Some of the sub-ops are acessible to all guests, and hence should be rate-limited. In the xenoprof case, just like for XSA-146, include them only in debug builds. Since the vPMU code is rather new, allow them to be always present, but downgrade them to (rate limited) guest messages.  This is CVE-2015-7971 / XSA-152. ",
        "func_before": "long do_xenpmu_op(unsigned int op, XEN_GUEST_HANDLE_PARAM(xen_pmu_params_t) arg)\n{\n    int ret;\n    struct vcpu *curr;\n    struct xen_pmu_params pmu_params = {.val = 0};\n    struct xen_pmu_data *xenpmu_data;\n    struct vpmu_struct *vpmu;\n\n    if ( !opt_vpmu_enabled )\n        return -EOPNOTSUPP;\n\n    ret = xsm_pmu_op(XSM_OTHER, current->domain, op);\n    if ( ret )\n        return ret;\n\n    /* Check major version when parameters are specified */\n    switch ( op )\n    {\n    case XENPMU_mode_set:\n    case XENPMU_feature_set:\n    case XENPMU_init:\n    case XENPMU_finish:\n        if ( copy_from_guest(&pmu_params, arg, 1) )\n            return -EFAULT;\n\n        if ( pmu_params.version.maj != XENPMU_VER_MAJ )\n            return -EINVAL;\n    }\n\n    switch ( op )\n    {\n    case XENPMU_mode_set:\n    {\n        if ( (pmu_params.val &\n              ~(XENPMU_MODE_SELF | XENPMU_MODE_HV | XENPMU_MODE_ALL)) ||\n             (hweight64(pmu_params.val) > 1) )\n            return -EINVAL;\n\n        /* 32-bit dom0 can only sample itself. */\n        if ( is_pv_32bit_vcpu(current) &&\n             (pmu_params.val & (XENPMU_MODE_HV | XENPMU_MODE_ALL)) )\n            return -EINVAL;\n\n        spin_lock(&vpmu_lock);\n\n        /*\n         * We can always safely switch between XENPMU_MODE_SELF and\n         * XENPMU_MODE_HV while other VPMUs are active.\n         */\n        if ( (vpmu_count == 0) ||\n             ((vpmu_mode ^ pmu_params.val) ==\n              (XENPMU_MODE_SELF | XENPMU_MODE_HV)) )\n            vpmu_mode = pmu_params.val;\n        else if ( vpmu_mode != pmu_params.val )\n        {\n            printk(XENLOG_WARNING\n                   \"VPMU: Cannot change mode while active VPMUs exist\\n\");\n            ret = -EBUSY;\n        }\n\n        spin_unlock(&vpmu_lock);\n\n        break;\n    }\n\n    case XENPMU_mode_get:\n        memset(&pmu_params, 0, sizeof(pmu_params));\n        pmu_params.val = vpmu_mode;\n\n        pmu_params.version.maj = XENPMU_VER_MAJ;\n        pmu_params.version.min = XENPMU_VER_MIN;\n\n        if ( copy_to_guest(arg, &pmu_params, 1) )\n            ret = -EFAULT;\n\n        break;\n\n    case XENPMU_feature_set:\n        if ( pmu_params.val & ~XENPMU_FEATURE_INTEL_BTS )\n            return -EINVAL;\n\n        spin_lock(&vpmu_lock);\n\n        if ( (vpmu_count == 0) || (vpmu_features == pmu_params.val) )\n            vpmu_features = pmu_params.val;\n        else\n        {\n            printk(XENLOG_WARNING \"VPMU: Cannot change features while\"\n                                  \" active VPMUs exist\\n\");\n            ret = -EBUSY;\n        }\n\n        spin_unlock(&vpmu_lock);\n\n        break;\n\n    case XENPMU_feature_get:\n        pmu_params.val = vpmu_features;\n        if ( copy_field_to_guest(arg, &pmu_params, val) )\n            ret = -EFAULT;\n\n        break;\n\n    case XENPMU_init:\n        ret = pvpmu_init(current->domain, &pmu_params);\n        break;\n\n    case XENPMU_finish:\n        pvpmu_finish(current->domain, &pmu_params);\n        break;\n\n    case XENPMU_lvtpc_set:\n        xenpmu_data = current->arch.vpmu.xenpmu_data;\n        if ( xenpmu_data != NULL )\n            vpmu_lvtpc_update(xenpmu_data->pmu.l.lapic_lvtpc);\n        else\n            ret = -EINVAL;\n        break;\n\n    case XENPMU_flush:\n        curr = current;\n        vpmu = vcpu_vpmu(curr);\n        xenpmu_data = curr->arch.vpmu.xenpmu_data;\n        if ( xenpmu_data == NULL )\n            return -EINVAL;\n        xenpmu_data->pmu.pmu_flags &= ~PMU_CACHED;\n        vpmu_reset(vpmu, VPMU_CACHED);\n        vpmu_lvtpc_update(xenpmu_data->pmu.l.lapic_lvtpc);\n        if ( vpmu_load(curr, 1) )\n        {\n            xenpmu_data->pmu.pmu_flags |= PMU_CACHED;\n            vpmu_set(vpmu, VPMU_CACHED);\n            ret = -EIO;\n        }\n        break ;\n\n    default:\n        ret = -EINVAL;\n    }\n\n    return ret;\n}",
        "func": "long do_xenpmu_op(unsigned int op, XEN_GUEST_HANDLE_PARAM(xen_pmu_params_t) arg)\n{\n    int ret;\n    struct vcpu *curr;\n    struct xen_pmu_params pmu_params = {.val = 0};\n    struct xen_pmu_data *xenpmu_data;\n    struct vpmu_struct *vpmu;\n\n    if ( !opt_vpmu_enabled )\n        return -EOPNOTSUPP;\n\n    ret = xsm_pmu_op(XSM_OTHER, current->domain, op);\n    if ( ret )\n        return ret;\n\n    /* Check major version when parameters are specified */\n    switch ( op )\n    {\n    case XENPMU_mode_set:\n    case XENPMU_feature_set:\n    case XENPMU_init:\n    case XENPMU_finish:\n        if ( copy_from_guest(&pmu_params, arg, 1) )\n            return -EFAULT;\n\n        if ( pmu_params.version.maj != XENPMU_VER_MAJ )\n            return -EINVAL;\n    }\n\n    switch ( op )\n    {\n    case XENPMU_mode_set:\n    {\n        if ( (pmu_params.val &\n              ~(XENPMU_MODE_SELF | XENPMU_MODE_HV | XENPMU_MODE_ALL)) ||\n             (hweight64(pmu_params.val) > 1) )\n            return -EINVAL;\n\n        /* 32-bit dom0 can only sample itself. */\n        if ( is_pv_32bit_vcpu(current) &&\n             (pmu_params.val & (XENPMU_MODE_HV | XENPMU_MODE_ALL)) )\n            return -EINVAL;\n\n        spin_lock(&vpmu_lock);\n\n        /*\n         * We can always safely switch between XENPMU_MODE_SELF and\n         * XENPMU_MODE_HV while other VPMUs are active.\n         */\n        if ( (vpmu_count == 0) ||\n             ((vpmu_mode ^ pmu_params.val) ==\n              (XENPMU_MODE_SELF | XENPMU_MODE_HV)) )\n            vpmu_mode = pmu_params.val;\n        else if ( vpmu_mode != pmu_params.val )\n        {\n            gprintk(XENLOG_WARNING,\n                    \"VPMU: Cannot change mode while active VPMUs exist\\n\");\n            ret = -EBUSY;\n        }\n\n        spin_unlock(&vpmu_lock);\n\n        break;\n    }\n\n    case XENPMU_mode_get:\n        memset(&pmu_params, 0, sizeof(pmu_params));\n        pmu_params.val = vpmu_mode;\n\n        pmu_params.version.maj = XENPMU_VER_MAJ;\n        pmu_params.version.min = XENPMU_VER_MIN;\n\n        if ( copy_to_guest(arg, &pmu_params, 1) )\n            ret = -EFAULT;\n\n        break;\n\n    case XENPMU_feature_set:\n        if ( pmu_params.val & ~XENPMU_FEATURE_INTEL_BTS )\n            return -EINVAL;\n\n        spin_lock(&vpmu_lock);\n\n        if ( (vpmu_count == 0) || (vpmu_features == pmu_params.val) )\n            vpmu_features = pmu_params.val;\n        else\n        {\n            gprintk(XENLOG_WARNING,\n                    \"VPMU: Cannot change features while active VPMUs exist\\n\");\n            ret = -EBUSY;\n        }\n\n        spin_unlock(&vpmu_lock);\n\n        break;\n\n    case XENPMU_feature_get:\n        pmu_params.val = vpmu_features;\n        if ( copy_field_to_guest(arg, &pmu_params, val) )\n            ret = -EFAULT;\n\n        break;\n\n    case XENPMU_init:\n        ret = pvpmu_init(current->domain, &pmu_params);\n        break;\n\n    case XENPMU_finish:\n        pvpmu_finish(current->domain, &pmu_params);\n        break;\n\n    case XENPMU_lvtpc_set:\n        xenpmu_data = current->arch.vpmu.xenpmu_data;\n        if ( xenpmu_data != NULL )\n            vpmu_lvtpc_update(xenpmu_data->pmu.l.lapic_lvtpc);\n        else\n            ret = -EINVAL;\n        break;\n\n    case XENPMU_flush:\n        curr = current;\n        vpmu = vcpu_vpmu(curr);\n        xenpmu_data = curr->arch.vpmu.xenpmu_data;\n        if ( xenpmu_data == NULL )\n            return -EINVAL;\n        xenpmu_data->pmu.pmu_flags &= ~PMU_CACHED;\n        vpmu_reset(vpmu, VPMU_CACHED);\n        vpmu_lvtpc_update(xenpmu_data->pmu.l.lapic_lvtpc);\n        if ( vpmu_load(curr, 1) )\n        {\n            xenpmu_data->pmu.pmu_flags |= PMU_CACHED;\n            vpmu_set(vpmu, VPMU_CACHED);\n            ret = -EIO;\n        }\n        break ;\n\n    default:\n        ret = -EINVAL;\n    }\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,8 +53,8 @@\n             vpmu_mode = pmu_params.val;\n         else if ( vpmu_mode != pmu_params.val )\n         {\n-            printk(XENLOG_WARNING\n-                   \"VPMU: Cannot change mode while active VPMUs exist\\n\");\n+            gprintk(XENLOG_WARNING,\n+                    \"VPMU: Cannot change mode while active VPMUs exist\\n\");\n             ret = -EBUSY;\n         }\n \n@@ -85,8 +85,8 @@\n             vpmu_features = pmu_params.val;\n         else\n         {\n-            printk(XENLOG_WARNING \"VPMU: Cannot change features while\"\n-                                  \" active VPMUs exist\\n\");\n+            gprintk(XENLOG_WARNING,\n+                    \"VPMU: Cannot change features while active VPMUs exist\\n\");\n             ret = -EBUSY;\n         }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "            printk(XENLOG_WARNING",
                "                   \"VPMU: Cannot change mode while active VPMUs exist\\n\");",
                "            printk(XENLOG_WARNING \"VPMU: Cannot change features while\"",
                "                                  \" active VPMUs exist\\n\");"
            ],
            "added_lines": [
                "            gprintk(XENLOG_WARNING,",
                "                    \"VPMU: Cannot change mode while active VPMUs exist\\n\");",
                "            gprintk(XENLOG_WARNING,",
                "                    \"VPMU: Cannot change features while active VPMUs exist\\n\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-7971",
        "func_name": "xen-project/xen/do_xenoprof_op",
        "description": "Xen 3.2.x through 4.6.x does not limit the number of printk console messages when logging certain pmu and profiling hypercalls, which allows local guests to cause a denial of service via a sequence of crafted (1) HYPERCALL_xenoprof_op hypercalls, which are not properly handled in the do_xenoprof_op function in common/xenoprof.c, or (2) HYPERVISOR_xenpmu_op hypercalls, which are not properly handled in the do_xenpmu_op function in arch/x86/cpu/vpmu.c.",
        "git_url": "https://github.com/xen-project/xen/commit/95e7415843b94c346e5ba8682665f508f220e04b",
        "commit_title": "x86: rate-limit logging in do_xen{oprof,pmu}_op()",
        "commit_text": " Some of the sub-ops are acessible to all guests, and hence should be rate-limited. In the xenoprof case, just like for XSA-146, include them only in debug builds. Since the vPMU code is rather new, allow them to be always present, but downgrade them to (rate limited) guest messages.  This is CVE-2015-7971 / XSA-152. ",
        "func_before": "ret_t do_xenoprof_op(int op, XEN_GUEST_HANDLE_PARAM(void) arg)\n{\n    int ret = 0;\n    \n    if ( (op < 0) || (op > XENOPROF_last_op) )\n    {\n        printk(\"xenoprof: invalid operation %d for domain %d\\n\",\n               op, current->domain->domain_id);\n        return -EINVAL;\n    }\n\n    if ( !NONPRIV_OP(op) && (current->domain != xenoprof_primary_profiler) )\n    {\n        printk(\"xenoprof: dom %d denied privileged operation %d\\n\",\n               current->domain->domain_id, op);\n        return -EPERM;\n    }\n\n    ret = xsm_profile(XSM_HOOK, current->domain, op);\n    if ( ret )\n        return ret;\n\n    spin_lock(&xenoprof_lock);\n    \n    switch ( op )\n    {\n    case XENOPROF_init:\n        ret = xenoprof_op_init(arg);\n        if ( (ret == 0) &&\n             (current->domain == xenoprof_primary_profiler) )\n            xenoprof_state = XENOPROF_INITIALIZED;\n        break;\n\n    case XENOPROF_get_buffer:\n        if ( !acquire_pmu_ownership(PMU_OWNER_XENOPROF) )\n        {\n            ret = -EBUSY;\n            break;\n        }\n        ret = xenoprof_op_get_buffer(arg);\n        break;\n\n    case XENOPROF_reset_active_list:\n        reset_active_list();\n        ret = 0;\n        break;\n\n    case XENOPROF_reset_passive_list:\n        reset_passive_list();\n        ret = 0;\n        break;\n\n    case XENOPROF_set_active:\n    {\n        domid_t domid;\n        if ( xenoprof_state != XENOPROF_INITIALIZED )\n        {\n            ret = -EPERM;\n            break;\n        }\n        if ( copy_from_guest(&domid, arg, 1) )\n        {\n            ret = -EFAULT;\n            break;\n        }\n        ret = add_active_list(domid);\n        break;\n    }\n\n    case XENOPROF_set_passive:\n        if ( xenoprof_state != XENOPROF_INITIALIZED )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = add_passive_list(arg);\n        break;\n\n    case XENOPROF_reserve_counters:\n        if ( xenoprof_state != XENOPROF_INITIALIZED )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = xenoprof_arch_reserve_counters();\n        if ( !ret )\n            xenoprof_state = XENOPROF_COUNTERS_RESERVED;\n        break;\n\n    case XENOPROF_counter:\n        if ( (xenoprof_state != XENOPROF_COUNTERS_RESERVED) ||\n             (adomains == 0) )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = xenoprof_arch_counter(arg);\n        break;\n\n    case XENOPROF_setup_events:\n        if ( xenoprof_state != XENOPROF_COUNTERS_RESERVED )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = xenoprof_arch_setup_events();\n        if ( !ret )\n            xenoprof_state = XENOPROF_READY;\n        break;\n\n    case XENOPROF_enable_virq:\n    {\n        int i;\n\n        if ( current->domain == xenoprof_primary_profiler )\n        {\n            if ( xenoprof_state != XENOPROF_READY )\n            {\n                ret = -EPERM;\n                break;\n            }\n            xenoprof_arch_enable_virq();\n            xenoprof_reset_stat();\n            for ( i = 0; i < pdomains; i++ )\n                xenoprof_reset_buf(passive_domains[i]);\n        }\n        xenoprof_reset_buf(current->domain);\n        ret = set_active(current->domain);\n        break;\n    }\n\n    case XENOPROF_start:\n        ret = -EPERM;\n        if ( (xenoprof_state == XENOPROF_READY) &&\n             (activated == adomains) )\n            ret = xenoprof_arch_start();\n        if ( ret == 0 )\n            xenoprof_state = XENOPROF_PROFILING;\n        break;\n\n    case XENOPROF_stop:\n    {\n        struct domain *d;\n        struct vcpu *v;\n        int i;\n\n        if ( xenoprof_state != XENOPROF_PROFILING )\n        {\n            ret = -EPERM;\n            break;\n        }\n        xenoprof_arch_stop();\n\n        /* Flush remaining samples. */\n        for ( i = 0; i < adomains; i++ )\n        {\n            if ( !active_ready[i] )\n                continue;\n            d = active_domains[i];\n            for_each_vcpu(d, v)\n                send_guest_vcpu_virq(v, VIRQ_XENOPROF);\n        }\n        xenoprof_state = XENOPROF_READY;\n        break;\n    }\n\n    case XENOPROF_disable_virq:\n    {\n        struct xenoprof *x;\n        if ( (xenoprof_state == XENOPROF_PROFILING) && \n             (is_active(current->domain)) )\n        {\n            ret = -EPERM;\n            break;\n        }\n        if ( (ret = reset_active(current->domain)) != 0 )\n            break;\n        x = current->domain->xenoprof;\n        unshare_xenoprof_page_with_guest(x);\n        release_pmu_ownship(PMU_OWNER_XENOPROF);\n        break;\n    }\n\n    case XENOPROF_release_counters:\n        ret = -EPERM;\n        if ( (xenoprof_state == XENOPROF_COUNTERS_RESERVED) ||\n             (xenoprof_state == XENOPROF_READY) )\n        {\n            xenoprof_state = XENOPROF_INITIALIZED;\n            xenoprof_arch_release_counters();\n            xenoprof_arch_disable_virq();\n            reset_passive_list();\n            ret = 0;\n        }\n        break;\n\n    case XENOPROF_shutdown:\n        ret = -EPERM;\n        if ( xenoprof_state == XENOPROF_INITIALIZED )\n        {\n            activated = 0;\n            adomains=0;\n            xenoprof_primary_profiler = NULL;\n            backtrace_depth=0;\n            ret = 0;\n        }\n        break;\n                \n    case XENOPROF_set_backtrace:\n        ret = 0;\n        if ( !xenoprof_backtrace_supported() )\n            ret = -EINVAL;\n        else if ( copy_from_guest(&backtrace_depth, arg, 1) )\n            ret = -EFAULT;\n        break;\n\n    case XENOPROF_ibs_counter:\n        if ( (xenoprof_state != XENOPROF_COUNTERS_RESERVED) ||\n             (adomains == 0) )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = xenoprof_arch_ibs_counter(arg);\n        break;\n\n    case XENOPROF_get_ibs_caps:\n        ret = ibs_caps;\n        break;\n\n    default:\n        ret = -ENOSYS;\n    }\n\n    spin_unlock(&xenoprof_lock);\n\n    if ( ret < 0 )\n        printk(\"xenoprof: operation %d failed for dom %d (status : %d)\\n\",\n               op, current->domain->domain_id, ret);\n\n    return ret;\n}",
        "func": "ret_t do_xenoprof_op(int op, XEN_GUEST_HANDLE_PARAM(void) arg)\n{\n    int ret = 0;\n    \n    if ( (op < 0) || (op > XENOPROF_last_op) )\n    {\n        gdprintk(XENLOG_DEBUG, \"invalid operation %d\\n\", op);\n        return -EINVAL;\n    }\n\n    if ( !NONPRIV_OP(op) && (current->domain != xenoprof_primary_profiler) )\n    {\n        gdprintk(XENLOG_DEBUG, \"denied privileged operation %d\\n\", op);\n        return -EPERM;\n    }\n\n    ret = xsm_profile(XSM_HOOK, current->domain, op);\n    if ( ret )\n        return ret;\n\n    spin_lock(&xenoprof_lock);\n    \n    switch ( op )\n    {\n    case XENOPROF_init:\n        ret = xenoprof_op_init(arg);\n        if ( (ret == 0) &&\n             (current->domain == xenoprof_primary_profiler) )\n            xenoprof_state = XENOPROF_INITIALIZED;\n        break;\n\n    case XENOPROF_get_buffer:\n        if ( !acquire_pmu_ownership(PMU_OWNER_XENOPROF) )\n        {\n            ret = -EBUSY;\n            break;\n        }\n        ret = xenoprof_op_get_buffer(arg);\n        break;\n\n    case XENOPROF_reset_active_list:\n        reset_active_list();\n        ret = 0;\n        break;\n\n    case XENOPROF_reset_passive_list:\n        reset_passive_list();\n        ret = 0;\n        break;\n\n    case XENOPROF_set_active:\n    {\n        domid_t domid;\n        if ( xenoprof_state != XENOPROF_INITIALIZED )\n        {\n            ret = -EPERM;\n            break;\n        }\n        if ( copy_from_guest(&domid, arg, 1) )\n        {\n            ret = -EFAULT;\n            break;\n        }\n        ret = add_active_list(domid);\n        break;\n    }\n\n    case XENOPROF_set_passive:\n        if ( xenoprof_state != XENOPROF_INITIALIZED )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = add_passive_list(arg);\n        break;\n\n    case XENOPROF_reserve_counters:\n        if ( xenoprof_state != XENOPROF_INITIALIZED )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = xenoprof_arch_reserve_counters();\n        if ( !ret )\n            xenoprof_state = XENOPROF_COUNTERS_RESERVED;\n        break;\n\n    case XENOPROF_counter:\n        if ( (xenoprof_state != XENOPROF_COUNTERS_RESERVED) ||\n             (adomains == 0) )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = xenoprof_arch_counter(arg);\n        break;\n\n    case XENOPROF_setup_events:\n        if ( xenoprof_state != XENOPROF_COUNTERS_RESERVED )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = xenoprof_arch_setup_events();\n        if ( !ret )\n            xenoprof_state = XENOPROF_READY;\n        break;\n\n    case XENOPROF_enable_virq:\n    {\n        int i;\n\n        if ( current->domain == xenoprof_primary_profiler )\n        {\n            if ( xenoprof_state != XENOPROF_READY )\n            {\n                ret = -EPERM;\n                break;\n            }\n            xenoprof_arch_enable_virq();\n            xenoprof_reset_stat();\n            for ( i = 0; i < pdomains; i++ )\n                xenoprof_reset_buf(passive_domains[i]);\n        }\n        xenoprof_reset_buf(current->domain);\n        ret = set_active(current->domain);\n        break;\n    }\n\n    case XENOPROF_start:\n        ret = -EPERM;\n        if ( (xenoprof_state == XENOPROF_READY) &&\n             (activated == adomains) )\n            ret = xenoprof_arch_start();\n        if ( ret == 0 )\n            xenoprof_state = XENOPROF_PROFILING;\n        break;\n\n    case XENOPROF_stop:\n    {\n        struct domain *d;\n        struct vcpu *v;\n        int i;\n\n        if ( xenoprof_state != XENOPROF_PROFILING )\n        {\n            ret = -EPERM;\n            break;\n        }\n        xenoprof_arch_stop();\n\n        /* Flush remaining samples. */\n        for ( i = 0; i < adomains; i++ )\n        {\n            if ( !active_ready[i] )\n                continue;\n            d = active_domains[i];\n            for_each_vcpu(d, v)\n                send_guest_vcpu_virq(v, VIRQ_XENOPROF);\n        }\n        xenoprof_state = XENOPROF_READY;\n        break;\n    }\n\n    case XENOPROF_disable_virq:\n    {\n        struct xenoprof *x;\n        if ( (xenoprof_state == XENOPROF_PROFILING) && \n             (is_active(current->domain)) )\n        {\n            ret = -EPERM;\n            break;\n        }\n        if ( (ret = reset_active(current->domain)) != 0 )\n            break;\n        x = current->domain->xenoprof;\n        unshare_xenoprof_page_with_guest(x);\n        release_pmu_ownship(PMU_OWNER_XENOPROF);\n        break;\n    }\n\n    case XENOPROF_release_counters:\n        ret = -EPERM;\n        if ( (xenoprof_state == XENOPROF_COUNTERS_RESERVED) ||\n             (xenoprof_state == XENOPROF_READY) )\n        {\n            xenoprof_state = XENOPROF_INITIALIZED;\n            xenoprof_arch_release_counters();\n            xenoprof_arch_disable_virq();\n            reset_passive_list();\n            ret = 0;\n        }\n        break;\n\n    case XENOPROF_shutdown:\n        ret = -EPERM;\n        if ( xenoprof_state == XENOPROF_INITIALIZED )\n        {\n            activated = 0;\n            adomains=0;\n            xenoprof_primary_profiler = NULL;\n            backtrace_depth=0;\n            ret = 0;\n        }\n        break;\n                \n    case XENOPROF_set_backtrace:\n        ret = 0;\n        if ( !xenoprof_backtrace_supported() )\n            ret = -EINVAL;\n        else if ( copy_from_guest(&backtrace_depth, arg, 1) )\n            ret = -EFAULT;\n        break;\n\n    case XENOPROF_ibs_counter:\n        if ( (xenoprof_state != XENOPROF_COUNTERS_RESERVED) ||\n             (adomains == 0) )\n        {\n            ret = -EPERM;\n            break;\n        }\n        ret = xenoprof_arch_ibs_counter(arg);\n        break;\n\n    case XENOPROF_get_ibs_caps:\n        ret = ibs_caps;\n        break;\n\n    default:\n        ret = -ENOSYS;\n    }\n\n    spin_unlock(&xenoprof_lock);\n\n    if ( ret < 0 )\n        gdprintk(XENLOG_DEBUG, \"operation %d failed: %d\\n\", op, ret);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,15 +4,13 @@\n     \n     if ( (op < 0) || (op > XENOPROF_last_op) )\n     {\n-        printk(\"xenoprof: invalid operation %d for domain %d\\n\",\n-               op, current->domain->domain_id);\n+        gdprintk(XENLOG_DEBUG, \"invalid operation %d\\n\", op);\n         return -EINVAL;\n     }\n \n     if ( !NONPRIV_OP(op) && (current->domain != xenoprof_primary_profiler) )\n     {\n-        printk(\"xenoprof: dom %d denied privileged operation %d\\n\",\n-               current->domain->domain_id, op);\n+        gdprintk(XENLOG_DEBUG, \"denied privileged operation %d\\n\", op);\n         return -EPERM;\n     }\n \n@@ -235,8 +233,7 @@\n     spin_unlock(&xenoprof_lock);\n \n     if ( ret < 0 )\n-        printk(\"xenoprof: operation %d failed for dom %d (status : %d)\\n\",\n-               op, current->domain->domain_id, ret);\n+        gdprintk(XENLOG_DEBUG, \"operation %d failed: %d\\n\", op, ret);\n \n     return ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        printk(\"xenoprof: invalid operation %d for domain %d\\n\",",
                "               op, current->domain->domain_id);",
                "        printk(\"xenoprof: dom %d denied privileged operation %d\\n\",",
                "               current->domain->domain_id, op);",
                "        printk(\"xenoprof: operation %d failed for dom %d (status : %d)\\n\",",
                "               op, current->domain->domain_id, ret);"
            ],
            "added_lines": [
                "        gdprintk(XENLOG_DEBUG, \"invalid operation %d\\n\", op);",
                "        gdprintk(XENLOG_DEBUG, \"denied privileged operation %d\\n\", op);",
                "        gdprintk(XENLOG_DEBUG, \"operation %d failed: %d\\n\", op, ret);"
            ]
        }
    }
]