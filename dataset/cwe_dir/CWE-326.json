[
    {
        "cve_id": "CVE-2019-10638",
        "func_name": "torvalds/linux/net_hash_mix",
        "description": "In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses.",
        "git_url": "https://github.com/torvalds/linux/commit/355b98553789b646ed97ad801a619ff898471b92",
        "commit_title": "netns: provide pure entropy for net_hash_mix()",
        "commit_text": " net_hash_mix() currently uses kernel address of a struct net, and is used in many places that could be used to reveal this address to a patient attacker, thus defeating KASLR, for the typical case (initial net namespace, &init_net is not dynamically allocated)  I believe the original implementation tried to avoid spending too many cycles in this function, but security comes first.  Also provide entropy regardless of CONFIG_NET_NS.  Cc: Pavel Emelyanov <xemul@openvz.org>",
        "func_before": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}",
        "func": "static inline u32 net_hash_mix(const struct net *net)\n{\n\treturn net->hash_mix;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,4 @@\n static inline u32 net_hash_mix(const struct net *net)\n {\n-#ifdef CONFIG_NET_NS\n-\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n-#else\n-\treturn 0;\n-#endif\n+\treturn net->hash_mix;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef CONFIG_NET_NS",
                "\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));",
                "#else",
                "\treturn 0;",
                "#endif"
            ],
            "added_lines": [
                "\treturn net->hash_mix;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10638",
        "func_name": "torvalds/linux/setup_net",
        "description": "In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses.",
        "git_url": "https://github.com/torvalds/linux/commit/355b98553789b646ed97ad801a619ff898471b92",
        "commit_title": "netns: provide pure entropy for net_hash_mix()",
        "commit_text": " net_hash_mix() currently uses kernel address of a struct net, and is used in many places that could be used to reveal this address to a patient attacker, thus defeating KASLR, for the typical case (initial net namespace, &init_net is not dynamically allocated)  I believe the original implementation tried to avoid spending too many cycles in this function, but security comes first.  Also provide entropy regardless of CONFIG_NET_NS.  Cc: Pavel Emelyanov <xemul@openvz.org>",
        "func_before": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\t/* Must be called with pernet_ops_rwsem held */\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n\n\trefcount_set(&net->count, 1);\n\trefcount_set(&net->passive, 1);\n\tnet->dev_base_seq = 1;\n\tnet->user_ns = user_ns;\n\tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\n\nout_undo:\n\t/* Walk through the list backwards calling the exit functions\n\t * for the pernet modules whose init functions did not fail.\n\t */\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\n\trcu_barrier();\n\tgoto out;\n}",
        "func": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\t/* Must be called with pernet_ops_rwsem held */\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n\n\trefcount_set(&net->count, 1);\n\trefcount_set(&net->passive, 1);\n\tget_random_bytes(&net->hash_mix, sizeof(u32));\n\tnet->dev_base_seq = 1;\n\tnet->user_ns = user_ns;\n\tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\n\nout_undo:\n\t/* Walk through the list backwards calling the exit functions\n\t * for the pernet modules whose init functions did not fail.\n\t */\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\n\trcu_barrier();\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n \n \trefcount_set(&net->count, 1);\n \trefcount_set(&net->passive, 1);\n+\tget_random_bytes(&net->hash_mix, sizeof(u32));\n \tnet->dev_base_seq = 1;\n \tnet->user_ns = user_ns;\n \tidr_init(&net->netns_ids);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tget_random_bytes(&net->hash_mix, sizeof(u32));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10638",
        "func_name": "torvalds/linux/ipv6_select_ident",
        "description": "In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses.",
        "git_url": "https://github.com/torvalds/linux/commit/55f0fc7a02de8f12757f4937143d8d5091b2e40b",
        "commit_title": "inet: update the IP ID generation algorithm to higher standards.",
        "commit_text": " Commit 355b98553789 (\"netns: provide pure entropy for net_hash_mix()\") makes net_hash_mix() return a true 32 bits of entropy.  When used in the IP ID generation algorithm, this has the effect of extending the IP ID generation key from 32 bits to 64 bits.  However, net_hash_mix() is only used for IP ID generation starting with kernel version 4.1.  Therefore, earlier kernels remain with 32-bit key no matter what the net_hash_mix() return value is.  This change addresses the issue by explicitly extending the key to 64 bits for kernels older than 4.1.  Cc: Ben Hutchings <ben@decadent.org.uk>",
        "func_before": "static void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\n\thash = __ipv6_addr_jhash(&rt->rt6i_dst.addr, ip6_idents_hashrnd);\n\thash = __ipv6_addr_jhash(&rt->rt6i_src.addr, hash);\n\n\tid = ip_idents_reserve(hash, 1);\n\tfhdr->identification = htonl(id);\n}",
        "func": "static void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tstatic u32 ip6_idents_hashrnd_extra __read_mostly;\n\tu32 hash, id;\n\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\tnet_get_random_once(&ip6_idents_hashrnd_extra, sizeof(ip6_idents_hashrnd_extra));\n\n\thash = __ipv6_addr_jhash(&rt->rt6i_dst.addr, ip6_idents_hashrnd);\n\thash = __ipv6_addr_jhash(&rt->rt6i_src.addr, hash);\n\thash = jhash_1word(hash, ip6_idents_hashrnd_extra);\n\n\tid = ip_idents_reserve(hash, 1);\n\tfhdr->identification = htonl(id);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,15 @@\n static void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\n {\n \tstatic u32 ip6_idents_hashrnd __read_mostly;\n+\tstatic u32 ip6_idents_hashrnd_extra __read_mostly;\n \tu32 hash, id;\n \n \tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n+\tnet_get_random_once(&ip6_idents_hashrnd_extra, sizeof(ip6_idents_hashrnd_extra));\n \n \thash = __ipv6_addr_jhash(&rt->rt6i_dst.addr, ip6_idents_hashrnd);\n \thash = __ipv6_addr_jhash(&rt->rt6i_src.addr, hash);\n+\thash = jhash_1word(hash, ip6_idents_hashrnd_extra);\n \n \tid = ip_idents_reserve(hash, 1);\n \tfhdr->identification = htonl(id);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tstatic u32 ip6_idents_hashrnd_extra __read_mostly;",
                "\tnet_get_random_once(&ip6_idents_hashrnd_extra, sizeof(ip6_idents_hashrnd_extra));",
                "\thash = jhash_1word(hash, ip6_idents_hashrnd_extra);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10638",
        "func_name": "torvalds/linux/__ip_select_ident",
        "description": "In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses.",
        "git_url": "https://github.com/torvalds/linux/commit/55f0fc7a02de8f12757f4937143d8d5091b2e40b",
        "commit_title": "inet: update the IP ID generation algorithm to higher standards.",
        "commit_text": " Commit 355b98553789 (\"netns: provide pure entropy for net_hash_mix()\") makes net_hash_mix() return a true 32 bits of entropy.  When used in the IP ID generation algorithm, this has the effect of extending the IP ID generation key from 32 bits to 64 bits.  However, net_hash_mix() is only used for IP ID generation starting with kernel version 4.1.  Therefore, earlier kernels remain with 32-bit key no matter what the net_hash_mix() return value is.  This change addresses the issue by explicitly extending the key to 64 bits for kernels older than 4.1.  Cc: Ben Hutchings <ben@decadent.org.uk>",
        "func_before": "void __ip_select_ident(struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol,\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}",
        "func": "void __ip_select_ident(struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tstatic u32 ip_idents_hashrnd_extra __read_mostly;\n\tu32 hash, id;\n\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\tnet_get_random_once(&ip_idents_hashrnd_extra, sizeof(ip_idents_hashrnd_extra));\n\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ ip_idents_hashrnd_extra,\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,15 @@\n void __ip_select_ident(struct iphdr *iph, int segs)\n {\n \tstatic u32 ip_idents_hashrnd __read_mostly;\n+\tstatic u32 ip_idents_hashrnd_extra __read_mostly;\n \tu32 hash, id;\n \n \tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n+\tnet_get_random_once(&ip_idents_hashrnd_extra, sizeof(ip_idents_hashrnd_extra));\n \n \thash = jhash_3words((__force u32)iph->daddr,\n \t\t\t    (__force u32)iph->saddr,\n-\t\t\t    iph->protocol,\n+\t\t\t    iph->protocol ^ ip_idents_hashrnd_extra,\n \t\t\t    ip_idents_hashrnd);\n \tid = ip_idents_reserve(hash, segs);\n \tiph->id = htons(id);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t    iph->protocol,"
            ],
            "added_lines": [
                "\tstatic u32 ip_idents_hashrnd_extra __read_mostly;",
                "\tnet_get_random_once(&ip_idents_hashrnd_extra, sizeof(ip_idents_hashrnd_extra));",
                "\t\t\t    iph->protocol ^ ip_idents_hashrnd_extra,"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10638",
        "func_name": "torvalds/linux/__ipv6_select_ident",
        "description": "In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses.",
        "git_url": "https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702",
        "commit_title": "inet: switch IP ID generator to siphash",
        "commit_text": " According to Amit Klein and Benny Pinkas, IP ID generation is too weak and might be used by attackers.  Even with recent net_hash_mix() fix (netns: provide pure entropy for net_hash_mix()) having 64bit key and Jenkins hash is risky.  It is time to switch to siphash and its 128bit keys. ",
        "func_before": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\n\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n\t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t */\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}",
        "func": "static u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tconst struct {\n\t\tstruct in6_addr dst;\n\t\tstruct in6_addr src;\n\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n\t\t.dst = *dst,\n\t\t.src = *src,\n\t};\n\tu32 hash, id;\n\n\t/* Note the following code is not safe, but this is okay. */\n\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n\t\tget_random_bytes(&net->ipv4.ip_id_key,\n\t\t\t\t sizeof(net->ipv4.ip_id_key));\n\n\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);\n\n\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n\t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t */\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,22 @@\n-static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n+static u32 __ipv6_select_ident(struct net *net,\n \t\t\t       const struct in6_addr *dst,\n \t\t\t       const struct in6_addr *src)\n {\n+\tconst struct {\n+\t\tstruct in6_addr dst;\n+\t\tstruct in6_addr src;\n+\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n+\t\t.dst = *dst,\n+\t\t.src = *src,\n+\t};\n \tu32 hash, id;\n \n-\thash = __ipv6_addr_jhash(dst, hashrnd);\n-\thash = __ipv6_addr_jhash(src, hash);\n-\thash ^= net_hash_mix(net);\n+\t/* Note the following code is not safe, but this is okay. */\n+\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n+\t\tget_random_bytes(&net->ipv4.ip_id_key,\n+\t\t\t\t sizeof(net->ipv4.ip_id_key));\n+\n+\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);\n \n \t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n \t * set the hight order instead thus minimizing possible future",
        "diff_line_info": {
            "deleted_lines": [
                "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,",
                "\thash = __ipv6_addr_jhash(dst, hashrnd);",
                "\thash = __ipv6_addr_jhash(src, hash);",
                "\thash ^= net_hash_mix(net);"
            ],
            "added_lines": [
                "static u32 __ipv6_select_ident(struct net *net,",
                "\tconst struct {",
                "\t\tstruct in6_addr dst;",
                "\t\tstruct in6_addr src;",
                "\t} __aligned(SIPHASH_ALIGNMENT) combined = {",
                "\t\t.dst = *dst,",
                "\t\t.src = *src,",
                "\t};",
                "\t/* Note the following code is not safe, but this is okay. */",
                "\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))",
                "\t\tget_random_bytes(&net->ipv4.ip_id_key,",
                "\t\t\t\t sizeof(net->ipv4.ip_id_key));",
                "",
                "\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10638",
        "func_name": "torvalds/linux/ipv6_select_ident",
        "description": "In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses.",
        "git_url": "https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702",
        "commit_title": "inet: switch IP ID generator to siphash",
        "commit_text": " According to Amit Klein and Benny Pinkas, IP ID generation is too weak and might be used by attackers.  Even with recent net_hash_mix() fix (netns: provide pure entropy for net_hash_mix()) having 64bit key and Jenkins hash is risky.  It is time to switch to siphash and its 128bit keys. ",
        "func_before": "__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 id;\n\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n\treturn htonl(id);\n}",
        "func": "__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tu32 id;\n\n\tid = __ipv6_select_ident(net, daddr, saddr);\n\treturn htonl(id);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,11 +2,8 @@\n \t\t\t const struct in6_addr *daddr,\n \t\t\t const struct in6_addr *saddr)\n {\n-\tstatic u32 ip6_idents_hashrnd __read_mostly;\n \tu32 id;\n \n-\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n-\n-\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n+\tid = __ipv6_select_ident(net, daddr, saddr);\n \treturn htonl(id);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstatic u32 ip6_idents_hashrnd __read_mostly;",
                "\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));",
                "",
                "\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);"
            ],
            "added_lines": [
                "\tid = __ipv6_select_ident(net, daddr, saddr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10638",
        "func_name": "torvalds/linux/ipv6_proxy_select_ident",
        "description": "In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses.",
        "git_url": "https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702",
        "commit_title": "inet: switch IP ID generator to siphash",
        "commit_text": " According to Amit Klein and Benny Pinkas, IP ID generation is too weak and might be used by attackers.  Even with recent net_hash_mix() fix (netns: provide pure entropy for net_hash_mix()) having 64bit key and Jenkins hash is risky.  It is time to switch to siphash and its 128bit keys. ",
        "func_before": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}",
        "func": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tid = __ipv6_select_ident(net, &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n __be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n {\n-\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n \tstruct in6_addr buf[2];\n \tstruct in6_addr *addrs;\n \tu32 id;\n@@ -12,10 +11,6 @@\n \tif (!addrs)\n \t\treturn 0;\n \n-\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n-\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n-\n-\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n-\t\t\t\t &addrs[1], &addrs[0]);\n+\tid = __ipv6_select_ident(net, &addrs[1], &addrs[0]);\n \treturn htonl(id);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;",
                "\tnet_get_random_once(&ip6_proxy_idents_hashrnd,",
                "\t\t\t    sizeof(ip6_proxy_idents_hashrnd));",
                "",
                "\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,",
                "\t\t\t\t &addrs[1], &addrs[0]);"
            ],
            "added_lines": [
                "\tid = __ipv6_select_ident(net, &addrs[1], &addrs[0]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10638",
        "func_name": "torvalds/linux/__ip_select_ident",
        "description": "In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses.",
        "git_url": "https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702",
        "commit_title": "inet: switch IP ID generator to siphash",
        "commit_text": " According to Amit Klein and Benny Pinkas, IP ID generation is too weak and might be used by attackers.  Even with recent net_hash_mix() fix (netns: provide pure entropy for net_hash_mix()) having 64bit key and Jenkins hash is risky.  It is time to switch to siphash and its 128bit keys. ",
        "func_before": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}",
        "func": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tu32 hash, id;\n\n\t/* Note the following code is not safe, but this is okay. */\n\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n\t\tget_random_bytes(&net->ipv4.ip_id_key,\n\t\t\t\t sizeof(net->ipv4.ip_id_key));\n\n\thash = siphash_3u32((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol,\n\t\t\t    &net->ipv4.ip_id_key);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,14 +1,16 @@\n void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n {\n-\tstatic u32 ip_idents_hashrnd __read_mostly;\n \tu32 hash, id;\n \n-\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n+\t/* Note the following code is not safe, but this is okay. */\n+\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n+\t\tget_random_bytes(&net->ipv4.ip_id_key,\n+\t\t\t\t sizeof(net->ipv4.ip_id_key));\n \n-\thash = jhash_3words((__force u32)iph->daddr,\n+\thash = siphash_3u32((__force u32)iph->daddr,\n \t\t\t    (__force u32)iph->saddr,\n-\t\t\t    iph->protocol ^ net_hash_mix(net),\n-\t\t\t    ip_idents_hashrnd);\n+\t\t\t    iph->protocol,\n+\t\t\t    &net->ipv4.ip_id_key);\n \tid = ip_idents_reserve(hash, segs);\n \tiph->id = htons(id);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstatic u32 ip_idents_hashrnd __read_mostly;",
                "\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));",
                "\thash = jhash_3words((__force u32)iph->daddr,",
                "\t\t\t    iph->protocol ^ net_hash_mix(net),",
                "\t\t\t    ip_idents_hashrnd);"
            ],
            "added_lines": [
                "\t/* Note the following code is not safe, but this is okay. */",
                "\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))",
                "\t\tget_random_bytes(&net->ipv4.ip_id_key,",
                "\t\t\t\t sizeof(net->ipv4.ip_id_key));",
                "\thash = siphash_3u32((__force u32)iph->daddr,",
                "\t\t\t    iph->protocol,",
                "\t\t\t    &net->ipv4.ip_id_key);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-0224",
        "func_name": "openssl/ssl3_accept",
        "description": "OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the \"CCS Injection\" vulnerability.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=bc8923b1ec9c467755cd86f7848c50ee8812e441",
        "commit_title": "",
        "commit_text": "Fix for CVE-2014-0224  Only accept change cipher spec when it is expected instead of at any time. This prevents premature setting of session keys before the master secret is determined which an attacker could use as a MITM attack.  Thanks to KIKUCHI Masashi (Lepidum Co. Ltd.) for reporting this issue and providing the initial fix this patch is based on. ",
        "func_before": "int ssl3_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long alg_k,Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\n\t/* init things to blank */\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version>>8) != 3)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\ts->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t\t */\n\t\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\t\t\t\t\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse if (!s->s3->send_connection_binding &&\n\t\t\t\t!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\t\t{\n\t\t\t\t/* Server attempting to renegotiate with\n\t\t\t\t * client that doesn't support secure\n\t\t\t\t * renegotiation.\n\t\t\t\t */\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* s->state == SSL_ST_RENEGOTIATE,\n\t\t\t\t * we will just send a HelloRequest */\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\ts->shutdown=0;\n\t\t\tif (s->rwstate != SSL_X509_LOOKUP)\n\t\t\t{\n\t\t\t\tret=ssl3_get_client_hello(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t}\n#ifndef OPENSSL_NO_SRP\n\t\t\t{\n\t\t\tint al;\n\t\t\tif ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)\n\t\t\t\t\t{\n\t\t\t\t\t/* callback indicates firther work to be done */\n\t\t\t\t\ts->rwstate=SSL_X509_LOOKUP;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\tif (ret != SSL_ERROR_NONE)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\t\n\t\t\t\t/* This is not really an error but the only means to\n                                   for a client to detect whether srp is supported. */\n \t\t\t\t   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) \t\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);\t\t\t\n\t\t\t\tret = SSL_TLSEXT_ERR_ALERT_FATAL;\t\t\t\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\t\n\t\t\t\t}\n\t\t\t}\n#endif\t\t\n\t\t\t\n\t\t\ts->renegotiate = 2;\n\t\t\ts->state=SSL3_ST_SW_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\t\t}\n#else\n\t\t\tif (s->hit)\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH or anon ECDH, */\n\t\t\t/* normal PSK or KRB5 or SRP */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n\t\t\t/* clear this, it may get reset by\n\t\t\t * send_server_key_exchange */\n\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n#ifndef OPENSSL_NO_KRB5\n\t\t\t\t&& !(alg_k & SSL_kKRB5)\n#endif /* OPENSSL_NO_KRB5 */\n\t\t\t\t)\n\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n\t\t\t\t * even when forbidden by protocol specs\n\t\t\t\t * (handshake may fail as clients are not required to\n\t\t\t\t * be able to handle this) */\n\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n\t\t\telse\n\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\n\t\t\t/* only send if a DH key exchange, fortezza or\n\t\t\t * RSA but we have a sign only certificate\n\t\t\t *\n\t\t\t * PSK: may send PSK identity hints\n\t\t\t *\n\t\t\t * For ECC ciphersuites, we send a serverKeyExchange\n\t\t\t * message only if the cipher suite is either\n\t\t\t * ECDH-anon or ECDHE. In other cases, the\n\t\t\t * server certificate contains the server's\n\t\t\t * public key for key exchange.\n\t\t\t */\n\t\t\tif (s->s3->tmp.use_rsa_tmp\n\t\t\t/* PSK: send ServerKeyExchange if PSK identity\n\t\t\t * hint if provided */\n#ifndef OPENSSL_NO_PSK\n\t\t\t    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n#ifndef OPENSSL_NO_SRP\n\t\t\t    /* SRP: send ServerKeyExchange */\n\t\t\t    || (alg_k & SSL_kSRP)\n#endif\n\t\t\t    || (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kEDH))\n\t\t\t    || (alg_k & SSL_kEECDH)\n\t\t\t    || ((alg_k & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n\t\t\t\t /* never request cert in Kerberos ciphersuites */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)\n\t\t\t\t/* With normal PSK Certificates and\n\t\t\t\t * Certificate Requests are omitted */\n\t\t\t\t|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\n\t\t\t/* This code originally checked to see if\n\t\t\t * any data was pending using BIO_CTRL_INFO\n\t\t\t * and then flushed. This caused problems\n\t\t\t * as documented in PR#1939. The proposed\n\t\t\t * fix doesn't completely resolve this issue\n\t\t\t * as buggy implementations of BIO_CTRL_PENDING\n\t\t\t * still exist. So instead we just flush\n\t\t\t * unconditionally.\n\t\t\t */\n\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\t/* Check for second client hello (MS SGC) */\n\t\t\tret = ssl3_check_client_hello(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\ts->state = SSL3_ST_SR_CLNT_HELLO_C;\n\t\t\telse {\n\t\t\t\tif (s->s3->tmp.cert_request)\n\t\t\t\t\t{\n\t\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_num=0;\n\t\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\t/* For the ECDH ciphersuites when\n\t\t\t\t * the client sends its ECDH pub key in\n\t\t\t\t * a certificate, the CertificateVerify\n\t\t\t\t * message is not sent.\n\t\t\t\t * Also for GOST ciphersuites when\n\t\t\t\t * the client uses its key from the certificate\n\t\t\t\t * for key exchange.\n\t\t\t\t */\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\ts->init_num = 0;\n\t\t\t\t}\n\t\t\telse if (TLS1_get_version(s) >= TLS1_2_VERSION)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tif (!s->session->peer)\n\t\t\t\t\tbreak;\n\t\t\t\t/* For TLS v1.2 freeze the handshake buffer\n\t\t\t\t * at this point and digest cached records.\n\t\t\t\t */\n\t\t\t\tif (!s->s3->handshake_buffer)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\ts->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tint offset=0;\n\t\t\t\tint dgst_num;\n\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\n\t\t\t\t/* We need to get hashes here so if there is\n\t\t\t\t * a client cert, it can be verified\n\t\t\t\t * FIXME - digest processing for CertificateVerify\n\t\t\t\t * should be generalized. But it is next step\n\t\t\t\t */\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\tfor (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)\t\n\t\t\t\t\tif (s->s3->handshake_dgst[dgst_num]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tint dgst_size;\n\n\t\t\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));\n\t\t\t\t\t\tdgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);\n\t\t\t\t\t\tif (dgst_size < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\toffset+=dgst_size;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_SR_NEXT_PROTO_A:\n\t\tcase SSL3_ST_SR_NEXT_PROTO_B:\n\t\t\tret=ssl3_get_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->init_num = 0;\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (s->tlsext_ticket_expected)\n\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SESSION_TICKET_A:\n\t\tcase SSL3_ST_SW_SESSION_TICKET_B:\n\t\t\tret=ssl3_send_newsession_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_STATUS_A:\n\t\tcase SSL3_ST_SW_CERT_STATUS_B:\n\t\t\tret=ssl3_send_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#endif\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\t{\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */\n\t\t\t\t{\n\t\t\t\ts->renegotiate=0;\n\t\t\t\ts->new_session=0;\n\t\t\t\t\n\t\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\t\t\t\t\n\t\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t\t/* s->server=1; */\n\t\t\t\ts->handshake_func=ssl3_accept;\n\n\t\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\t\t\t\t}\n\t\t\t\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\ts->in_handshake--;\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\treturn(ret);\n\t}",
        "func": "int ssl3_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long alg_k,Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\n\t/* init things to blank */\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version>>8) != 3)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\ts->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t\t */\n\t\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\t\t\t\t\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse if (!s->s3->send_connection_binding &&\n\t\t\t\t!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\t\t{\n\t\t\t\t/* Server attempting to renegotiate with\n\t\t\t\t * client that doesn't support secure\n\t\t\t\t * renegotiation.\n\t\t\t\t */\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* s->state == SSL_ST_RENEGOTIATE,\n\t\t\t\t * we will just send a HelloRequest */\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\ts->shutdown=0;\n\t\t\tif (s->rwstate != SSL_X509_LOOKUP)\n\t\t\t{\n\t\t\t\tret=ssl3_get_client_hello(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t}\n#ifndef OPENSSL_NO_SRP\n\t\t\t{\n\t\t\tint al;\n\t\t\tif ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)\n\t\t\t\t\t{\n\t\t\t\t\t/* callback indicates firther work to be done */\n\t\t\t\t\ts->rwstate=SSL_X509_LOOKUP;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\tif (ret != SSL_ERROR_NONE)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\t\n\t\t\t\t/* This is not really an error but the only means to\n                                   for a client to detect whether srp is supported. */\n \t\t\t\t   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) \t\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);\t\t\t\n\t\t\t\tret = SSL_TLSEXT_ERR_ALERT_FATAL;\t\t\t\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\t\n\t\t\t\t}\n\t\t\t}\n#endif\t\t\n\t\t\t\n\t\t\ts->renegotiate = 2;\n\t\t\ts->state=SSL3_ST_SW_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\t\t}\n#else\n\t\t\tif (s->hit)\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH or anon ECDH, */\n\t\t\t/* normal PSK or KRB5 or SRP */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n\t\t\t/* clear this, it may get reset by\n\t\t\t * send_server_key_exchange */\n\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n#ifndef OPENSSL_NO_KRB5\n\t\t\t\t&& !(alg_k & SSL_kKRB5)\n#endif /* OPENSSL_NO_KRB5 */\n\t\t\t\t)\n\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n\t\t\t\t * even when forbidden by protocol specs\n\t\t\t\t * (handshake may fail as clients are not required to\n\t\t\t\t * be able to handle this) */\n\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n\t\t\telse\n\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\n\t\t\t/* only send if a DH key exchange, fortezza or\n\t\t\t * RSA but we have a sign only certificate\n\t\t\t *\n\t\t\t * PSK: may send PSK identity hints\n\t\t\t *\n\t\t\t * For ECC ciphersuites, we send a serverKeyExchange\n\t\t\t * message only if the cipher suite is either\n\t\t\t * ECDH-anon or ECDHE. In other cases, the\n\t\t\t * server certificate contains the server's\n\t\t\t * public key for key exchange.\n\t\t\t */\n\t\t\tif (s->s3->tmp.use_rsa_tmp\n\t\t\t/* PSK: send ServerKeyExchange if PSK identity\n\t\t\t * hint if provided */\n#ifndef OPENSSL_NO_PSK\n\t\t\t    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n#ifndef OPENSSL_NO_SRP\n\t\t\t    /* SRP: send ServerKeyExchange */\n\t\t\t    || (alg_k & SSL_kSRP)\n#endif\n\t\t\t    || (alg_k & (SSL_kDHr|SSL_kDHd|SSL_kEDH))\n\t\t\t    || (alg_k & SSL_kEECDH)\n\t\t\t    || ((alg_k & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n\t\t\t\t /* never request cert in Kerberos ciphersuites */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)\n\t\t\t\t/* With normal PSK Certificates and\n\t\t\t\t * Certificate Requests are omitted */\n\t\t\t\t|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\n\t\t\t/* This code originally checked to see if\n\t\t\t * any data was pending using BIO_CTRL_INFO\n\t\t\t * and then flushed. This caused problems\n\t\t\t * as documented in PR#1939. The proposed\n\t\t\t * fix doesn't completely resolve this issue\n\t\t\t * as buggy implementations of BIO_CTRL_PENDING\n\t\t\t * still exist. So instead we just flush\n\t\t\t * unconditionally.\n\t\t\t */\n\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\t/* Check for second client hello (MS SGC) */\n\t\t\tret = ssl3_check_client_hello(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\ts->state = SSL3_ST_SR_CLNT_HELLO_C;\n\t\t\telse {\n\t\t\t\tif (s->s3->tmp.cert_request)\n\t\t\t\t\t{\n\t\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_num=0;\n\t\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\t/* For the ECDH ciphersuites when\n\t\t\t\t * the client sends its ECDH pub key in\n\t\t\t\t * a certificate, the CertificateVerify\n\t\t\t\t * message is not sent.\n\t\t\t\t * Also for GOST ciphersuites when\n\t\t\t\t * the client uses its key from the certificate\n\t\t\t\t * for key exchange.\n\t\t\t\t */\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\ts->init_num = 0;\n\t\t\t\t}\n\t\t\telse if (TLS1_get_version(s) >= TLS1_2_VERSION)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tif (!s->session->peer)\n\t\t\t\t\tbreak;\n\t\t\t\t/* For TLS v1.2 freeze the handshake buffer\n\t\t\t\t * at this point and digest cached records.\n\t\t\t\t */\n\t\t\t\tif (!s->s3->handshake_buffer)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\ts->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tint offset=0;\n\t\t\t\tint dgst_num;\n\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\n\t\t\t\t/* We need to get hashes here so if there is\n\t\t\t\t * a client cert, it can be verified\n\t\t\t\t * FIXME - digest processing for CertificateVerify\n\t\t\t\t * should be generalized. But it is next step\n\t\t\t\t */\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\tfor (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)\t\n\t\t\t\t\tif (s->s3->handshake_dgst[dgst_num]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tint dgst_size;\n\n\t\t\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));\n\t\t\t\t\t\tdgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);\n\t\t\t\t\t\tif (dgst_size < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\toffset+=dgst_size;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\n\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_SR_NEXT_PROTO_A:\n\t\tcase SSL3_ST_SR_NEXT_PROTO_B:\n\t\t\tret=ssl3_get_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->init_num = 0;\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (s->tlsext_ticket_expected)\n\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SESSION_TICKET_A:\n\t\tcase SSL3_ST_SW_SESSION_TICKET_B:\n\t\t\tret=ssl3_send_newsession_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_STATUS_A:\n\t\tcase SSL3_ST_SW_CERT_STATUS_B:\n\t\t\tret=ssl3_send_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#endif\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\t{\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\t{\n\t\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */\n\t\t\t\t{\n\t\t\t\ts->renegotiate=0;\n\t\t\t\ts->new_session=0;\n\t\t\t\t\n\t\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\t\t\t\t\n\t\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t\t/* s->server=1; */\n\t\t\t\ts->handshake_func=ssl3_accept;\n\n\t\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\t\t\t\t}\n\t\t\t\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\ts->in_handshake--;\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -461,6 +461,7 @@\n \t\tcase SSL3_ST_SR_CERT_VRFY_A:\n \t\tcase SSL3_ST_SR_CERT_VRFY_B:\n \n+\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n \t\t\t/* we should decide if we expected this one */\n \t\t\tret=ssl3_get_cert_verify(s);\n \t\t\tif (ret <= 0) goto end;\n@@ -488,6 +489,7 @@\n \n \t\tcase SSL3_ST_SR_FINISHED_A:\n \t\tcase SSL3_ST_SR_FINISHED_B:\n+\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n \t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n \t\t\t\tSSL3_ST_SR_FINISHED_B);\n \t\t\tif (ret <= 0) goto end;\n@@ -558,7 +560,10 @@\n \t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n #else\n \t\t\t\tif (s->s3->next_proto_neg_seen)\n+\t\t\t\t\t{\n+\t\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n \t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;\n+\t\t\t\t\t}\n \t\t\t\telse\n \t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n #endif",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;",
                "\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;",
                "\t\t\t\t\t{",
                "\t\t\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;",
                "\t\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-0224",
        "func_name": "openssl/ssl3_read_bytes",
        "description": "OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the \"CCS Injection\" vulnerability.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=bc8923b1ec9c467755cd86f7848c50ee8812e441",
        "commit_title": "",
        "commit_text": "Fix for CVE-2014-0224  Only accept change cipher spec when it is expected instead of at any time. This prevents premature setting of session keys before the master secret is determined which an attacker could use as a MITM attack.  Thanks to KIKUCHI Masashi (Lepidum Co. Ltd.) for reporting this issue and providing the initial fix this patch is based on. ",
        "func_before": "int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\n\t{\n\tint al,i,j,ret;\n\tunsigned int n;\n\tSSL3_RECORD *rr;\n\tvoid (*cb)(const SSL *ssl,int type2,int val)=NULL;\n\n\tif (s->s3->rbuf.buf == NULL) /* Not initialized yet */\n\t\tif (!ssl3_setup_read_buffer(s))\n\t\t\treturn(-1);\n\n\tif ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE) && type) ||\n\t    (peek && (type != SSL3_RT_APPLICATION_DATA)))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n\t\treturn -1;\n\t\t}\n\n\tif ((type == SSL3_RT_HANDSHAKE) && (s->s3->handshake_fragment_len > 0))\n\t\t/* (partially) satisfy request from storage */\n\t\t{\n\t\tunsigned char *src = s->s3->handshake_fragment;\n\t\tunsigned char *dst = buf;\n\t\tunsigned int k;\n\n\t\t/* peek == 0 */\n\t\tn = 0;\n\t\twhile ((len > 0) && (s->s3->handshake_fragment_len > 0))\n\t\t\t{\n\t\t\t*dst++ = *src++;\n\t\t\tlen--; s->s3->handshake_fragment_len--;\n\t\t\tn++;\n\t\t\t}\n\t\t/* move any remaining fragment bytes: */\n\t\tfor (k = 0; k < s->s3->handshake_fragment_len; k++)\n\t\t\ts->s3->handshake_fragment[k] = *src++;\n\t\treturn n;\n\t}\n\n\t/* Now s->s3->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */\n\n\tif (!s->in_handshake && SSL_in_init(s))\n\t\t{\n\t\t/* type == SSL3_RT_APPLICATION_DATA */\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\t\t}\nstart:\n\ts->rwstate=SSL_NOTHING;\n\n\t/* s->s3->rrec.type\t    - is the type of record\n\t * s->s3->rrec.data,    - data\n\t * s->s3->rrec.off,     - offset into 'data' for next read\n\t * s->s3->rrec.length,  - number of bytes. */\n\trr = &(s->s3->rrec);\n\n\t/* get new packet if necessary */\n\tif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))\n\t\t{\n\t\tret=ssl3_get_record(s);\n\t\tif (ret <= 0) return(ret);\n\t\t}\n\n\t/* we now have a packet which can be read and processed */\n\n\tif (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n\t                               * reset by ssl3_get_finished */\n\t\t&& (rr->type != SSL3_RT_HANDSHAKE))\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n\t\tgoto f_err;\n\t\t}\n\n\t/* If the other end has shut down, throw anything we read away\n\t * (even in 'peek' mode) */\n\tif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\n\t\t{\n\t\trr->length=0;\n\t\ts->rwstate=SSL_NOTHING;\n\t\treturn(0);\n\t\t}\n\n\n\tif (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */\n\t\t{\n\t\t/* make sure that we are not getting application data when we\n\t\t * are doing a handshake for the first time */\n\t\tif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n\t\t\t(s->enc_read_ctx == NULL))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (len <= 0) return(len);\n\n\t\tif ((unsigned int)len > rr->length)\n\t\t\tn = rr->length;\n\t\telse\n\t\t\tn = (unsigned int)len;\n\n\t\tmemcpy(buf,&(rr->data[rr->off]),n);\n\t\tif (!peek)\n\t\t\t{\n\t\t\trr->length-=n;\n\t\t\trr->off+=n;\n\t\t\tif (rr->length == 0)\n\t\t\t\t{\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t\trr->off=0;\n\t\t\t\tif (s->mode & SSL_MODE_RELEASE_BUFFERS && s->s3->rbuf.left == 0)\n\t\t\t\t\tssl3_release_read_buffer(s);\n\t\t\t\t}\n\t\t\t}\n\t\treturn(n);\n\t\t}\n\n\n\t/* If we get here, then type != rr->type; if we have a handshake\n\t * message, then it was unexpected (Hello Request or Client Hello). */\n\n\t/* In case of record types for which we have 'fragment' storage,\n\t * fill that so that we can process the data at a fixed place.\n\t */\n\t\t{\n\t\tunsigned int dest_maxlen = 0;\n\t\tunsigned char *dest = NULL;\n\t\tunsigned int *dest_len = NULL;\n\n\t\tif (rr->type == SSL3_RT_HANDSHAKE)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof s->s3->handshake_fragment;\n\t\t\tdest = s->s3->handshake_fragment;\n\t\t\tdest_len = &s->s3->handshake_fragment_len;\n\t\t\t}\n\t\telse if (rr->type == SSL3_RT_ALERT)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof s->s3->alert_fragment;\n\t\t\tdest = s->s3->alert_fragment;\n\t\t\tdest_len = &s->s3->alert_fragment_len;\n\t\t\t}\n#ifndef OPENSSL_NO_HEARTBEATS\n\t\telse if (rr->type == TLS1_RT_HEARTBEAT)\n\t\t\t{\n\t\t\ttls1_process_heartbeat(s);\n\n\t\t\t/* Exit and notify application to read again */\n\t\t\trr->length = 0;\n\t\t\ts->rwstate=SSL_READING;\n\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\treturn(-1);\n\t\t\t}\n#endif\n\n\t\tif (dest_maxlen > 0)\n\t\t\t{\n\t\t\tn = dest_maxlen - *dest_len; /* available space in 'dest' */\n\t\t\tif (rr->length < n)\n\t\t\t\tn = rr->length; /* available bytes */\n\n\t\t\t/* now move 'n' bytes: */\n\t\t\twhile (n-- > 0)\n\t\t\t\t{\n\t\t\t\tdest[(*dest_len)++] = rr->data[rr->off++];\n\t\t\t\trr->length--;\n\t\t\t\t}\n\n\t\t\tif (*dest_len < dest_maxlen)\n\t\t\t\tgoto start; /* fragment was too small */\n\t\t\t}\n\t\t}\n\n\t/* s->s3->handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;\n\t * s->s3->alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.\n\t * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) */\n\n\t/* If we are a client, check for an incoming 'Hello Request': */\n\tif ((!s->server) &&\n\t\t(s->s3->handshake_fragment_len >= 4) &&\n\t\t(s->s3->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n\t\t(s->session != NULL) && (s->session->cipher != NULL))\n\t\t{\n\t\ts->s3->handshake_fragment_len = 0;\n\n\t\tif ((s->s3->handshake_fragment[1] != 0) ||\n\t\t\t(s->s3->handshake_fragment[2] != 0) ||\n\t\t\t(s->s3->handshake_fragment[3] != 0))\n\t\t\t{\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->s3->handshake_fragment, 4, s, s->msg_callback_arg);\n\n\t\tif (SSL_is_init_finished(s) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n\t\t\t!s->s3->renegotiate)\n\t\t\t{\n\t\t\tssl3_renegotiate(s);\n\t\t\tif (ssl3_renegotiate_check(s))\n\t\t\t\t{\n\t\t\t\ti=s->handshake_func(s);\n\t\t\t\tif (i < 0) return(i);\n\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\t\t\treturn(-1);\n\t\t\t\t\t}\n\n\t\t\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t\t\t{\n\t\t\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t\t\t{\n\t\t\t\t\t\tBIO *bio;\n\t\t\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t/* we either finished a handshake or ignored the request,\n\t\t * now try again to obtain the (application) data we were asked for */\n\t\tgoto start;\n\t\t}\n\t/* If we are a server and get a client hello when renegotiation isn't\n\t * allowed send back a no renegotiation alert and carry on.\n\t * WARNING: experimental code, needs reviewing (steve)\n\t */\n\tif (s->server &&\n\t\tSSL_is_init_finished(s) &&\n    \t\t!s->s3->send_connection_binding &&\n\t\t(s->version > SSL3_VERSION) &&\n\t\t(s->s3->handshake_fragment_len >= 4) &&\n\t\t(s->s3->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n\t\t(s->session != NULL) && (s->session->cipher != NULL) &&\n\t\t!(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\n\t\t{\n\t\t/*s->s3->handshake_fragment_len = 0;*/\n\t\trr->length = 0;\n\t\tssl3_send_alert(s,SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n\t\tgoto start;\n\t\t}\n\tif (s->s3->alert_fragment_len >= 2)\n\t\t{\n\t\tint alert_level = s->s3->alert_fragment[0];\n\t\tint alert_descr = s->s3->alert_fragment[1];\n\n\t\ts->s3->alert_fragment_len = 0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_ALERT, s->s3->alert_fragment, 2, s, s->msg_callback_arg);\n\n\t\tif (s->info_callback != NULL)\n\t\t\tcb=s->info_callback;\n\t\telse if (s->ctx->info_callback != NULL)\n\t\t\tcb=s->ctx->info_callback;\n\n\t\tif (cb != NULL)\n\t\t\t{\n\t\t\tj = (alert_level << 8) | alert_descr;\n\t\t\tcb(s, SSL_CB_READ_ALERT, j);\n\t\t\t}\n\n\t\tif (alert_level == 1) /* warning */\n\t\t\t{\n\t\t\ts->s3->warn_alert = alert_descr;\n\t\t\tif (alert_descr == SSL_AD_CLOSE_NOTIFY)\n\t\t\t\t{\n\t\t\t\ts->shutdown |= SSL_RECEIVED_SHUTDOWN;\n\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t/* This is a warning but we receive it if we requested\n\t\t\t * renegotiation and the peer denied it. Terminate with\n\t\t\t * a fatal alert because if application tried to\n\t\t\t * renegotiatie it presumably had a good reason and\n\t\t\t * expects it to succeed.\n\t\t\t *\n\t\t\t * In future we might have a renegotiation where we\n\t\t\t * don't care if the peer refused it where we carry on.\n\t\t\t */\n\t\t\telse if (alert_descr == SSL_AD_NO_RENEGOTIATION)\n\t\t\t\t{\n\t\t\t\tal = SSL_AD_HANDSHAKE_FAILURE;\n\t\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_NO_RENEGOTIATION);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_AD_MISSING_SRP_USERNAME\n\t\t\telse if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n\t\t\t\treturn(0);\n#endif\n\t\t\t}\n\t\telse if (alert_level == 2) /* fatal */\n\t\t\t{\n\t\t\tchar tmp[16];\n\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->s3->fatal_alert = alert_descr;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n\t\t\tBIO_snprintf(tmp,sizeof tmp,\"%d\",alert_descr);\n\t\t\tERR_add_error_data(2,\"SSL alert number \",tmp);\n\t\t\ts->shutdown|=SSL_RECEIVED_SHUTDOWN;\n\t\t\tSSL_CTX_remove_session(s->ctx,s->session);\n\t\t\treturn(0);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tgoto start;\n\t\t}\n\n\tif (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */\n\t\t{\n\t\ts->rwstate=SSL_NOTHING;\n\t\trr->length=0;\n\t\treturn(0);\n\t\t}\n\n\tif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\t{\n\t\t/* 'Change Cipher Spec' is just a single byte, so we know\n\t\t * exactly what the record payload has to look like */\n\t\tif (\t(rr->length != 1) || (rr->off != 0) ||\n\t\t\t(rr->data[0] != SSL3_MT_CCS))\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\t/* Check we have a cipher to change to */\n\t\tif (s->s3->tmp.new_cipher == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\trr->length=0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, rr->data, 1, s, s->msg_callback_arg);\n\n\t\ts->s3->change_cipher_spec=1;\n\t\tif (!ssl3_do_change_cipher_spec(s))\n\t\t\tgoto err;\n\t\telse\n\t\t\tgoto start;\n\t\t}\n\n\t/* Unexpected handshake message (Client Hello, or protocol violation) */\n\tif ((s->s3->handshake_fragment_len >= 4) &&\t!s->in_handshake)\n\t\t{\n\t\tif (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))\n\t\t\t{\n#if 0 /* worked only because C operator preferences are not as expected (and\n       * because this is not really needed for clients except for detecting\n       * protocol violations): */\n\t\t\ts->state=SSL_ST_BEFORE|(s->server)\n\t\t\t\t?SSL_ST_ACCEPT\n\t\t\t\t:SSL_ST_CONNECT;\n#else\n\t\t\ts->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#endif\n\t\t\ts->renegotiate=1;\n\t\t\ts->new_session=1;\n\t\t\t}\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\n\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t{\n\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t{\n\t\t\t\tBIO *bio;\n\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\t\tgoto start;\n\t\t}\n\n\tswitch (rr->type)\n\t\t{\n\tdefault:\n#ifndef OPENSSL_NO_TLS\n\t\t/* TLS up to v1.1 just ignores unknown message types:\n\t\t * TLS v1.2 give an unexpected message alert.\n\t\t */\n\t\tif (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n#endif\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\tgoto f_err;\n\tcase SSL3_RT_CHANGE_CIPHER_SPEC:\n\tcase SSL3_RT_ALERT:\n\tcase SSL3_RT_HANDSHAKE:\n\t\t/* we already handled all of these, with the possible exception\n\t\t * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that\n\t\t * should not happen when type != rr->type */\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES,ERR_R_INTERNAL_ERROR);\n\t\tgoto f_err;\n\tcase SSL3_RT_APPLICATION_DATA:\n\t\t/* At this point, we were expecting handshake data,\n\t\t * but have application data.  If the library was\n\t\t * running inside ssl3_read() (i.e. in_read_app_data\n\t\t * is set) and it makes sense to read application data\n\t\t * at this point (session renegotiation not yet started),\n\t\t * we will indulge it.\n\t\t */\n\t\tif (s->s3->in_read_app_data &&\n\t\t\t(s->s3->total_renegotiations != 0) &&\n\t\t\t((\n\t\t\t\t(s->state & SSL_ST_CONNECT) &&\n\t\t\t\t(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\n\t\t\t\t(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\n\t\t\t\t) || (\n\t\t\t\t\t(s->state & SSL_ST_ACCEPT) &&\n\t\t\t\t\t(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\n\t\t\t\t\t(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t{\n\t\t\ts->s3->in_read_app_data=2;\n\t\t\treturn(-1);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\t/* not reached */\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(-1);\n\t}",
        "func": "int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\n\t{\n\tint al,i,j,ret;\n\tunsigned int n;\n\tSSL3_RECORD *rr;\n\tvoid (*cb)(const SSL *ssl,int type2,int val)=NULL;\n\n\tif (s->s3->rbuf.buf == NULL) /* Not initialized yet */\n\t\tif (!ssl3_setup_read_buffer(s))\n\t\t\treturn(-1);\n\n\tif ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE) && type) ||\n\t    (peek && (type != SSL3_RT_APPLICATION_DATA)))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n\t\treturn -1;\n\t\t}\n\n\tif ((type == SSL3_RT_HANDSHAKE) && (s->s3->handshake_fragment_len > 0))\n\t\t/* (partially) satisfy request from storage */\n\t\t{\n\t\tunsigned char *src = s->s3->handshake_fragment;\n\t\tunsigned char *dst = buf;\n\t\tunsigned int k;\n\n\t\t/* peek == 0 */\n\t\tn = 0;\n\t\twhile ((len > 0) && (s->s3->handshake_fragment_len > 0))\n\t\t\t{\n\t\t\t*dst++ = *src++;\n\t\t\tlen--; s->s3->handshake_fragment_len--;\n\t\t\tn++;\n\t\t\t}\n\t\t/* move any remaining fragment bytes: */\n\t\tfor (k = 0; k < s->s3->handshake_fragment_len; k++)\n\t\t\ts->s3->handshake_fragment[k] = *src++;\n\t\treturn n;\n\t}\n\n\t/* Now s->s3->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */\n\n\tif (!s->in_handshake && SSL_in_init(s))\n\t\t{\n\t\t/* type == SSL3_RT_APPLICATION_DATA */\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\t\t}\nstart:\n\ts->rwstate=SSL_NOTHING;\n\n\t/* s->s3->rrec.type\t    - is the type of record\n\t * s->s3->rrec.data,    - data\n\t * s->s3->rrec.off,     - offset into 'data' for next read\n\t * s->s3->rrec.length,  - number of bytes. */\n\trr = &(s->s3->rrec);\n\n\t/* get new packet if necessary */\n\tif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))\n\t\t{\n\t\tret=ssl3_get_record(s);\n\t\tif (ret <= 0) return(ret);\n\t\t}\n\n\t/* we now have a packet which can be read and processed */\n\n\tif (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n\t                               * reset by ssl3_get_finished */\n\t\t&& (rr->type != SSL3_RT_HANDSHAKE))\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n\t\tgoto f_err;\n\t\t}\n\n\t/* If the other end has shut down, throw anything we read away\n\t * (even in 'peek' mode) */\n\tif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\n\t\t{\n\t\trr->length=0;\n\t\ts->rwstate=SSL_NOTHING;\n\t\treturn(0);\n\t\t}\n\n\n\tif (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */\n\t\t{\n\t\t/* make sure that we are not getting application data when we\n\t\t * are doing a handshake for the first time */\n\t\tif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n\t\t\t(s->enc_read_ctx == NULL))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (len <= 0) return(len);\n\n\t\tif ((unsigned int)len > rr->length)\n\t\t\tn = rr->length;\n\t\telse\n\t\t\tn = (unsigned int)len;\n\n\t\tmemcpy(buf,&(rr->data[rr->off]),n);\n\t\tif (!peek)\n\t\t\t{\n\t\t\trr->length-=n;\n\t\t\trr->off+=n;\n\t\t\tif (rr->length == 0)\n\t\t\t\t{\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t\trr->off=0;\n\t\t\t\tif (s->mode & SSL_MODE_RELEASE_BUFFERS && s->s3->rbuf.left == 0)\n\t\t\t\t\tssl3_release_read_buffer(s);\n\t\t\t\t}\n\t\t\t}\n\t\treturn(n);\n\t\t}\n\n\n\t/* If we get here, then type != rr->type; if we have a handshake\n\t * message, then it was unexpected (Hello Request or Client Hello). */\n\n\t/* In case of record types for which we have 'fragment' storage,\n\t * fill that so that we can process the data at a fixed place.\n\t */\n\t\t{\n\t\tunsigned int dest_maxlen = 0;\n\t\tunsigned char *dest = NULL;\n\t\tunsigned int *dest_len = NULL;\n\n\t\tif (rr->type == SSL3_RT_HANDSHAKE)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof s->s3->handshake_fragment;\n\t\t\tdest = s->s3->handshake_fragment;\n\t\t\tdest_len = &s->s3->handshake_fragment_len;\n\t\t\t}\n\t\telse if (rr->type == SSL3_RT_ALERT)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof s->s3->alert_fragment;\n\t\t\tdest = s->s3->alert_fragment;\n\t\t\tdest_len = &s->s3->alert_fragment_len;\n\t\t\t}\n#ifndef OPENSSL_NO_HEARTBEATS\n\t\telse if (rr->type == TLS1_RT_HEARTBEAT)\n\t\t\t{\n\t\t\ttls1_process_heartbeat(s);\n\n\t\t\t/* Exit and notify application to read again */\n\t\t\trr->length = 0;\n\t\t\ts->rwstate=SSL_READING;\n\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\treturn(-1);\n\t\t\t}\n#endif\n\n\t\tif (dest_maxlen > 0)\n\t\t\t{\n\t\t\tn = dest_maxlen - *dest_len; /* available space in 'dest' */\n\t\t\tif (rr->length < n)\n\t\t\t\tn = rr->length; /* available bytes */\n\n\t\t\t/* now move 'n' bytes: */\n\t\t\twhile (n-- > 0)\n\t\t\t\t{\n\t\t\t\tdest[(*dest_len)++] = rr->data[rr->off++];\n\t\t\t\trr->length--;\n\t\t\t\t}\n\n\t\t\tif (*dest_len < dest_maxlen)\n\t\t\t\tgoto start; /* fragment was too small */\n\t\t\t}\n\t\t}\n\n\t/* s->s3->handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;\n\t * s->s3->alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.\n\t * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) */\n\n\t/* If we are a client, check for an incoming 'Hello Request': */\n\tif ((!s->server) &&\n\t\t(s->s3->handshake_fragment_len >= 4) &&\n\t\t(s->s3->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n\t\t(s->session != NULL) && (s->session->cipher != NULL))\n\t\t{\n\t\ts->s3->handshake_fragment_len = 0;\n\n\t\tif ((s->s3->handshake_fragment[1] != 0) ||\n\t\t\t(s->s3->handshake_fragment[2] != 0) ||\n\t\t\t(s->s3->handshake_fragment[3] != 0))\n\t\t\t{\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->s3->handshake_fragment, 4, s, s->msg_callback_arg);\n\n\t\tif (SSL_is_init_finished(s) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n\t\t\t!s->s3->renegotiate)\n\t\t\t{\n\t\t\tssl3_renegotiate(s);\n\t\t\tif (ssl3_renegotiate_check(s))\n\t\t\t\t{\n\t\t\t\ti=s->handshake_func(s);\n\t\t\t\tif (i < 0) return(i);\n\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\t\t\treturn(-1);\n\t\t\t\t\t}\n\n\t\t\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t\t\t{\n\t\t\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t\t\t{\n\t\t\t\t\t\tBIO *bio;\n\t\t\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t/* we either finished a handshake or ignored the request,\n\t\t * now try again to obtain the (application) data we were asked for */\n\t\tgoto start;\n\t\t}\n\t/* If we are a server and get a client hello when renegotiation isn't\n\t * allowed send back a no renegotiation alert and carry on.\n\t * WARNING: experimental code, needs reviewing (steve)\n\t */\n\tif (s->server &&\n\t\tSSL_is_init_finished(s) &&\n    \t\t!s->s3->send_connection_binding &&\n\t\t(s->version > SSL3_VERSION) &&\n\t\t(s->s3->handshake_fragment_len >= 4) &&\n\t\t(s->s3->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n\t\t(s->session != NULL) && (s->session->cipher != NULL) &&\n\t\t!(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\n\t\t{\n\t\t/*s->s3->handshake_fragment_len = 0;*/\n\t\trr->length = 0;\n\t\tssl3_send_alert(s,SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n\t\tgoto start;\n\t\t}\n\tif (s->s3->alert_fragment_len >= 2)\n\t\t{\n\t\tint alert_level = s->s3->alert_fragment[0];\n\t\tint alert_descr = s->s3->alert_fragment[1];\n\n\t\ts->s3->alert_fragment_len = 0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_ALERT, s->s3->alert_fragment, 2, s, s->msg_callback_arg);\n\n\t\tif (s->info_callback != NULL)\n\t\t\tcb=s->info_callback;\n\t\telse if (s->ctx->info_callback != NULL)\n\t\t\tcb=s->ctx->info_callback;\n\n\t\tif (cb != NULL)\n\t\t\t{\n\t\t\tj = (alert_level << 8) | alert_descr;\n\t\t\tcb(s, SSL_CB_READ_ALERT, j);\n\t\t\t}\n\n\t\tif (alert_level == 1) /* warning */\n\t\t\t{\n\t\t\ts->s3->warn_alert = alert_descr;\n\t\t\tif (alert_descr == SSL_AD_CLOSE_NOTIFY)\n\t\t\t\t{\n\t\t\t\ts->shutdown |= SSL_RECEIVED_SHUTDOWN;\n\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t/* This is a warning but we receive it if we requested\n\t\t\t * renegotiation and the peer denied it. Terminate with\n\t\t\t * a fatal alert because if application tried to\n\t\t\t * renegotiatie it presumably had a good reason and\n\t\t\t * expects it to succeed.\n\t\t\t *\n\t\t\t * In future we might have a renegotiation where we\n\t\t\t * don't care if the peer refused it where we carry on.\n\t\t\t */\n\t\t\telse if (alert_descr == SSL_AD_NO_RENEGOTIATION)\n\t\t\t\t{\n\t\t\t\tal = SSL_AD_HANDSHAKE_FAILURE;\n\t\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_NO_RENEGOTIATION);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_AD_MISSING_SRP_USERNAME\n\t\t\telse if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n\t\t\t\treturn(0);\n#endif\n\t\t\t}\n\t\telse if (alert_level == 2) /* fatal */\n\t\t\t{\n\t\t\tchar tmp[16];\n\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->s3->fatal_alert = alert_descr;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n\t\t\tBIO_snprintf(tmp,sizeof tmp,\"%d\",alert_descr);\n\t\t\tERR_add_error_data(2,\"SSL alert number \",tmp);\n\t\t\ts->shutdown|=SSL_RECEIVED_SHUTDOWN;\n\t\t\tSSL_CTX_remove_session(s->ctx,s->session);\n\t\t\treturn(0);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tgoto start;\n\t\t}\n\n\tif (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */\n\t\t{\n\t\ts->rwstate=SSL_NOTHING;\n\t\trr->length=0;\n\t\treturn(0);\n\t\t}\n\n\tif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\t{\n\t\t/* 'Change Cipher Spec' is just a single byte, so we know\n\t\t * exactly what the record payload has to look like */\n\t\tif (\t(rr->length != 1) || (rr->off != 0) ||\n\t\t\t(rr->data[0] != SSL3_MT_CCS))\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\t/* Check we have a cipher to change to */\n\t\tif (s->s3->tmp.new_cipher == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (!(s->s3->flags & SSL3_FLAGS_CCS_OK))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\ts->s3->flags &= ~SSL3_FLAGS_CCS_OK;\n\n\t\trr->length=0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, rr->data, 1, s, s->msg_callback_arg);\n\n\t\ts->s3->change_cipher_spec=1;\n\t\tif (!ssl3_do_change_cipher_spec(s))\n\t\t\tgoto err;\n\t\telse\n\t\t\tgoto start;\n\t\t}\n\n\t/* Unexpected handshake message (Client Hello, or protocol violation) */\n\tif ((s->s3->handshake_fragment_len >= 4) &&\t!s->in_handshake)\n\t\t{\n\t\tif (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))\n\t\t\t{\n#if 0 /* worked only because C operator preferences are not as expected (and\n       * because this is not really needed for clients except for detecting\n       * protocol violations): */\n\t\t\ts->state=SSL_ST_BEFORE|(s->server)\n\t\t\t\t?SSL_ST_ACCEPT\n\t\t\t\t:SSL_ST_CONNECT;\n#else\n\t\t\ts->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#endif\n\t\t\ts->renegotiate=1;\n\t\t\ts->new_session=1;\n\t\t\t}\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\n\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t{\n\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t{\n\t\t\t\tBIO *bio;\n\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\t\tgoto start;\n\t\t}\n\n\tswitch (rr->type)\n\t\t{\n\tdefault:\n#ifndef OPENSSL_NO_TLS\n\t\t/* TLS up to v1.1 just ignores unknown message types:\n\t\t * TLS v1.2 give an unexpected message alert.\n\t\t */\n\t\tif (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n#endif\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\tgoto f_err;\n\tcase SSL3_RT_CHANGE_CIPHER_SPEC:\n\tcase SSL3_RT_ALERT:\n\tcase SSL3_RT_HANDSHAKE:\n\t\t/* we already handled all of these, with the possible exception\n\t\t * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that\n\t\t * should not happen when type != rr->type */\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES,ERR_R_INTERNAL_ERROR);\n\t\tgoto f_err;\n\tcase SSL3_RT_APPLICATION_DATA:\n\t\t/* At this point, we were expecting handshake data,\n\t\t * but have application data.  If the library was\n\t\t * running inside ssl3_read() (i.e. in_read_app_data\n\t\t * is set) and it makes sense to read application data\n\t\t * at this point (session renegotiation not yet started),\n\t\t * we will indulge it.\n\t\t */\n\t\tif (s->s3->in_read_app_data &&\n\t\t\t(s->s3->total_renegotiations != 0) &&\n\t\t\t((\n\t\t\t\t(s->state & SSL_ST_CONNECT) &&\n\t\t\t\t(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\n\t\t\t\t(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\n\t\t\t\t) || (\n\t\t\t\t\t(s->state & SSL_ST_ACCEPT) &&\n\t\t\t\t\t(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\n\t\t\t\t\t(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t{\n\t\t\ts->s3->in_read_app_data=2;\n\t\t\treturn(-1);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\t/* not reached */\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(-1);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -356,6 +356,15 @@\n \t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);\n \t\t\tgoto f_err;\n \t\t\t}\n+\n+\t\tif (!(s->s3->flags & SSL3_FLAGS_CCS_OK))\n+\t\t\t{\n+\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n+\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);\n+\t\t\tgoto f_err;\n+\t\t\t}\n+\n+\t\ts->s3->flags &= ~SSL3_FLAGS_CCS_OK;\n \n \t\trr->length=0;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\tif (!(s->s3->flags & SSL3_FLAGS_CCS_OK))",
                "\t\t\t{",
                "\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;",
                "\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);",
                "\t\t\tgoto f_err;",
                "\t\t\t}",
                "",
                "\t\ts->s3->flags &= ~SSL3_FLAGS_CCS_OK;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-0224",
        "func_name": "openssl/ssl3_get_server_hello",
        "description": "OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the \"CCS Injection\" vulnerability.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=bc8923b1ec9c467755cd86f7848c50ee8812e441",
        "commit_title": "",
        "commit_text": "Fix for CVE-2014-0224  Only accept change cipher spec when it is expected instead of at any time. This prevents premature setting of session keys before the master secret is determined which an attacker could use as a MITM attack.  Thanks to KIKUCHI Masashi (Lepidum Co. Ltd.) for reporting this issue and providing the initial fix this patch is based on. ",
        "func_before": "int ssl3_get_server_hello(SSL *s)\n\t{\n\tSTACK_OF(SSL_CIPHER) *sk;\n\tconst SSL_CIPHER *c;\n\tunsigned char *p,*d;\n\tint i,al,ok;\n\tunsigned int j;\n\tlong n;\n#ifndef OPENSSL_NO_COMP\n\tSSL_COMP *comp;\n#endif\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_SRVR_HELLO_A,\n\t\tSSL3_ST_CR_SRVR_HELLO_B,\n\t\t-1,\n\t\t20000, /* ?? */\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\n\tif ( SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)\n\t\t{\n\t\tif ( s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST)\n\t\t\t{\n\t\t\tif ( s->d1->send_cookie == 0)\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.reuse_message = 1;\n\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\telse /* already sent a cookie */\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tif ( s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);\n\t\tgoto f_err;\n\t\t}\n\n\td=p=(unsigned char *)s->init_msg;\n\n\tif ((p[0] != (s->version>>8)) || (p[1] != (s->version&0xff)))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_SSL_VERSION);\n\t\ts->version=(s->version&0xff00)|p[1];\n\t\tal=SSL_AD_PROTOCOL_VERSION;\n\t\tgoto f_err;\n\t\t}\n\tp+=2;\n\n\t/* load the server hello data */\n\t/* load the server random */\n\tmemcpy(s->s3->server_random,p,SSL3_RANDOM_SIZE);\n\tp+=SSL3_RANDOM_SIZE;\n\n\t/* get the session-id */\n\tj= *(p++);\n\n\tif ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_LONG);\n\t\tgoto f_err;\n\t\t}\n\n#ifndef OPENSSL_NO_TLSEXT\n\t/* check if we want to resume the session based on external pre-shared secret */\n\tif (s->version >= TLS1_VERSION && s->tls_session_secret_cb)\n\t\t{\n\t\tSSL_CIPHER *pref_cipher=NULL;\n\t\ts->session->master_key_length=sizeof(s->session->master_key);\n\t\tif (s->tls_session_secret_cb(s, s->session->master_key,\n\t\t\t\t\t     &s->session->master_key_length,\n\t\t\t\t\t     NULL, &pref_cipher,\n\t\t\t\t\t     s->tls_session_secret_cb_arg))\n\t\t\t{\n\t\t\ts->session->cipher = pref_cipher ?\n\t\t\t\tpref_cipher : ssl_get_cipher_by_char(s, p+j);\n\t\t\t}\n\t\t}\n#endif /* OPENSSL_NO_TLSEXT */\n\n\tif (j != 0 && j == s->session->session_id_length\n\t    && memcmp(p,s->session->session_id,j) == 0)\n\t    {\n\t    if(s->sid_ctx_length != s->session->sid_ctx_length\n\t       || memcmp(s->session->sid_ctx,s->sid_ctx,s->sid_ctx_length))\n\t\t{\n\t\t/* actually a client application bug */\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\n\t\tgoto f_err;\n\t\t}\n\t    s->hit=1;\n\t    }\n\telse\t/* a miss or crap from the other end */\n\t\t{\n\t\t/* If we were trying for session-id reuse, make a new\n\t\t * SSL_SESSION so we don't stuff up other people */\n\t\ts->hit=0;\n\t\tif (s->session->session_id_length > 0)\n\t\t\t{\n\t\t\tif (!ssl_get_new_session(s,0))\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\ts->session->session_id_length=j;\n\t\tmemcpy(s->session->session_id,p,j); /* j could be 0 */\n\t\t}\n\tp+=j;\n\tc=ssl_get_cipher_by_char(s,p);\n\tif (c == NULL)\n\t\t{\n\t\t/* unknown cipher */\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNKNOWN_CIPHER_RETURNED);\n\t\tgoto f_err;\n\t\t}\n\t/* TLS v1.2 only ciphersuites require v1.2 or later */\n\tif ((c->algorithm_ssl & SSL_TLSV1_2) && \n\t\t(TLS1_get_version(s) < TLS1_2_VERSION))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);\n\t\tgoto f_err;\n\t\t}\n\tp+=ssl_put_cipher_by_char(s,NULL,NULL);\n\n\tsk=ssl_get_ciphers_by_id(s);\n\ti=sk_SSL_CIPHER_find(sk,c);\n\tif (i < 0)\n\t\t{\n\t\t/* we did not say we would use this cipher */\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);\n\t\tgoto f_err;\n\t\t}\n\n\t/* Depending on the session caching (internal/external), the cipher\n\t   and/or cipher_id values may not be set. Make sure that\n\t   cipher_id is set and use it for comparison. */\n\tif (s->session->cipher)\n\t\ts->session->cipher_id = s->session->cipher->id;\n\tif (s->hit && (s->session->cipher_id != c->id))\n\t\t{\n/* Workaround is now obsolete */\n#if 0\n\t\tif (!(s->options &\n\t\t\tSSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))\n#endif\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\ts->s3->tmp.new_cipher=c;\n\t/* Don't digest cached records if TLS v1.2: we may need them for\n\t * client authentication.\n\t */\n\tif (TLS1_get_version(s) < TLS1_2_VERSION && !ssl3_digest_cached_records(s))\n\t\t{\n\t\tal = SSL_AD_INTERNAL_ERROR;\n\t\tgoto f_err;\n\t\t}\n\t/* lets get the compression algorithm */\n\t/* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n\tif (*(p++) != 0)\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n\t\tgoto f_err;\n\t\t}\n\t/* If compression is disabled we'd better not try to resume a session\n\t * using compression.\n\t */\n\tif (s->session->compress_meth != 0)\n\t\t{\n\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_INCONSISTENT_COMPRESSION);\n\t\tgoto f_err;\n\t\t}\n#else\n\tj= *(p++);\n\tif (s->hit && j != s->session->compress_meth)\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);\n\t\tgoto f_err;\n\t\t}\n\tif (j == 0)\n\t\tcomp=NULL;\n\telse if (s->options & SSL_OP_NO_COMPRESSION)\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_COMPRESSION_DISABLED);\n\t\tgoto f_err;\n\t\t}\n\telse\n\t\tcomp=ssl3_comp_find(s->ctx->comp_methods,j);\n\t\n\tif ((j != 0) && (comp == NULL))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n\t\tgoto f_err;\n\t\t}\n\telse\n\t\t{\n\t\ts->s3->tmp.new_compression=comp;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_TLSEXT\n\t/* TLS extensions*/\n\tif (s->version >= SSL3_VERSION)\n\t\t{\n\t\tif (!ssl_parse_serverhello_tlsext(s,&p,d,n, &al))\n\t\t\t{\n\t\t\t/* 'al' set by ssl_parse_serverhello_tlsext */\n\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_PARSE_TLSEXT);\n\t\t\tgoto f_err; \n\t\t\t}\n\t\tif (ssl_check_serverhello_tlsext(s) <= 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\n\tif (p != (d+n))\n\t\t{\n\t\t/* wrong packet length */\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_PACKET_LENGTH);\n\t\tgoto f_err;\n\t\t}\n\n\treturn(1);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(-1);\n\t}",
        "func": "int ssl3_get_server_hello(SSL *s)\n\t{\n\tSTACK_OF(SSL_CIPHER) *sk;\n\tconst SSL_CIPHER *c;\n\tunsigned char *p,*d;\n\tint i,al,ok;\n\tunsigned int j;\n\tlong n;\n#ifndef OPENSSL_NO_COMP\n\tSSL_COMP *comp;\n#endif\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_SRVR_HELLO_A,\n\t\tSSL3_ST_CR_SRVR_HELLO_B,\n\t\t-1,\n\t\t20000, /* ?? */\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\n\tif ( SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)\n\t\t{\n\t\tif ( s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST)\n\t\t\t{\n\t\t\tif ( s->d1->send_cookie == 0)\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.reuse_message = 1;\n\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\telse /* already sent a cookie */\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\tif ( s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);\n\t\tgoto f_err;\n\t\t}\n\n\td=p=(unsigned char *)s->init_msg;\n\n\tif ((p[0] != (s->version>>8)) || (p[1] != (s->version&0xff)))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_SSL_VERSION);\n\t\ts->version=(s->version&0xff00)|p[1];\n\t\tal=SSL_AD_PROTOCOL_VERSION;\n\t\tgoto f_err;\n\t\t}\n\tp+=2;\n\n\t/* load the server hello data */\n\t/* load the server random */\n\tmemcpy(s->s3->server_random,p,SSL3_RANDOM_SIZE);\n\tp+=SSL3_RANDOM_SIZE;\n\n\t/* get the session-id */\n\tj= *(p++);\n\n\tif ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_LONG);\n\t\tgoto f_err;\n\t\t}\n\n#ifndef OPENSSL_NO_TLSEXT\n\t/* check if we want to resume the session based on external pre-shared secret */\n\tif (s->version >= TLS1_VERSION && s->tls_session_secret_cb)\n\t\t{\n\t\tSSL_CIPHER *pref_cipher=NULL;\n\t\ts->session->master_key_length=sizeof(s->session->master_key);\n\t\tif (s->tls_session_secret_cb(s, s->session->master_key,\n\t\t\t\t\t     &s->session->master_key_length,\n\t\t\t\t\t     NULL, &pref_cipher,\n\t\t\t\t\t     s->tls_session_secret_cb_arg))\n\t\t\t{\n\t\t\ts->session->cipher = pref_cipher ?\n\t\t\t\tpref_cipher : ssl_get_cipher_by_char(s, p+j);\n\t\t\t}\n\t\t}\n#endif /* OPENSSL_NO_TLSEXT */\n\n\tif (j != 0 && j == s->session->session_id_length\n\t    && memcmp(p,s->session->session_id,j) == 0)\n\t    {\n\t    if(s->sid_ctx_length != s->session->sid_ctx_length\n\t       || memcmp(s->session->sid_ctx,s->sid_ctx,s->sid_ctx_length))\n\t\t{\n\t\t/* actually a client application bug */\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\n\t\tgoto f_err;\n\t\t}\n\t    s->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t    s->hit=1;\n\t    }\n\telse\t/* a miss or crap from the other end */\n\t\t{\n\t\t/* If we were trying for session-id reuse, make a new\n\t\t * SSL_SESSION so we don't stuff up other people */\n\t\ts->hit=0;\n\t\tif (s->session->session_id_length > 0)\n\t\t\t{\n\t\t\tif (!ssl_get_new_session(s,0))\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t}\n\t\ts->session->session_id_length=j;\n\t\tmemcpy(s->session->session_id,p,j); /* j could be 0 */\n\t\t}\n\tp+=j;\n\tc=ssl_get_cipher_by_char(s,p);\n\tif (c == NULL)\n\t\t{\n\t\t/* unknown cipher */\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNKNOWN_CIPHER_RETURNED);\n\t\tgoto f_err;\n\t\t}\n\t/* TLS v1.2 only ciphersuites require v1.2 or later */\n\tif ((c->algorithm_ssl & SSL_TLSV1_2) && \n\t\t(TLS1_get_version(s) < TLS1_2_VERSION))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);\n\t\tgoto f_err;\n\t\t}\n\tp+=ssl_put_cipher_by_char(s,NULL,NULL);\n\n\tsk=ssl_get_ciphers_by_id(s);\n\ti=sk_SSL_CIPHER_find(sk,c);\n\tif (i < 0)\n\t\t{\n\t\t/* we did not say we would use this cipher */\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);\n\t\tgoto f_err;\n\t\t}\n\n\t/* Depending on the session caching (internal/external), the cipher\n\t   and/or cipher_id values may not be set. Make sure that\n\t   cipher_id is set and use it for comparison. */\n\tif (s->session->cipher)\n\t\ts->session->cipher_id = s->session->cipher->id;\n\tif (s->hit && (s->session->cipher_id != c->id))\n\t\t{\n/* Workaround is now obsolete */\n#if 0\n\t\tif (!(s->options &\n\t\t\tSSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))\n#endif\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\ts->s3->tmp.new_cipher=c;\n\t/* Don't digest cached records if TLS v1.2: we may need them for\n\t * client authentication.\n\t */\n\tif (TLS1_get_version(s) < TLS1_2_VERSION && !ssl3_digest_cached_records(s))\n\t\t{\n\t\tal = SSL_AD_INTERNAL_ERROR;\n\t\tgoto f_err;\n\t\t}\n\t/* lets get the compression algorithm */\n\t/* COMPRESSION */\n#ifdef OPENSSL_NO_COMP\n\tif (*(p++) != 0)\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n\t\tgoto f_err;\n\t\t}\n\t/* If compression is disabled we'd better not try to resume a session\n\t * using compression.\n\t */\n\tif (s->session->compress_meth != 0)\n\t\t{\n\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_INCONSISTENT_COMPRESSION);\n\t\tgoto f_err;\n\t\t}\n#else\n\tj= *(p++);\n\tif (s->hit && j != s->session->compress_meth)\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);\n\t\tgoto f_err;\n\t\t}\n\tif (j == 0)\n\t\tcomp=NULL;\n\telse if (s->options & SSL_OP_NO_COMPRESSION)\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_COMPRESSION_DISABLED);\n\t\tgoto f_err;\n\t\t}\n\telse\n\t\tcomp=ssl3_comp_find(s->ctx->comp_methods,j);\n\t\n\tif ((j != 0) && (comp == NULL))\n\t\t{\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n\t\tgoto f_err;\n\t\t}\n\telse\n\t\t{\n\t\ts->s3->tmp.new_compression=comp;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_TLSEXT\n\t/* TLS extensions*/\n\tif (s->version >= SSL3_VERSION)\n\t\t{\n\t\tif (!ssl_parse_serverhello_tlsext(s,&p,d,n, &al))\n\t\t\t{\n\t\t\t/* 'al' set by ssl_parse_serverhello_tlsext */\n\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_PARSE_TLSEXT);\n\t\t\tgoto f_err; \n\t\t\t}\n\t\tif (ssl_check_serverhello_tlsext(s) <= 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\n\tif (p != (d+n))\n\t\t{\n\t\t/* wrong packet length */\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_PACKET_LENGTH);\n\t\tgoto f_err;\n\t\t}\n\n\treturn(1);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(-1);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -98,6 +98,7 @@\n \t\tSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\n \t\tgoto f_err;\n \t\t}\n+\t    s->s3->flags |= SSL3_FLAGS_CCS_OK;\n \t    s->hit=1;\n \t    }\n \telse\t/* a miss or crap from the other end */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    s->s3->flags |= SSL3_FLAGS_CCS_OK;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-0224",
        "func_name": "openssl/ssl3_connect",
        "description": "OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the \"CCS Injection\" vulnerability.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=bc8923b1ec9c467755cd86f7848c50ee8812e441",
        "commit_title": "",
        "commit_text": "Fix for CVE-2014-0224  Only accept change cipher spec when it is expected instead of at any time. This prevents premature setting of session keys before the master secret is determined which an attacker could use as a MITM attack.  Thanks to KIKUCHI Masashi (Lepidum Co. Ltd.) for reporting this issue and providing the initial fix this patch is based on. ",
        "func_before": "int ssl3_connect(SSL *s)\n\t{\n\tBUF_MEM *buf=NULL;\n\tunsigned long Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\t\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); \n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch(s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\ts->state=SSL_ST_CONNECT;\n\t\t\ts->ctx->stats.sess_connect_renegotiate++;\n\t\t\t/* break */\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_CONNECT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_CONNECT:\n\t\tcase SSL_ST_OK|SSL_ST_CONNECT:\n\n\t\t\ts->server=0;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version & 0xff00 ) != 0x0300)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t/* s->version=SSL3_VERSION; */\n\t\t\ts->type=SSL_ST_CONNECT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\tbuf=NULL;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s)) { ret= -1; goto end; }\n\n\t\t\t/* setup buffing BIO */\n\t\t\tif (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }\n\n\t\t\t/* don't push the buffering BIO quite yet */\n\n\t\t\tssl3_init_finished_mac(s);\n\n\t\t\ts->state=SSL3_ST_CW_CLNT_HELLO_A;\n\t\t\ts->ctx->stats.sess_connect++;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CLNT_HELLO_A:\n\t\tcase SSL3_ST_CW_CLNT_HELLO_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_client_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\n\t\t\t/* turn on buffering for the next lot of output */\n\t\t\tif (s->bbio != s->wbio)\n\t\t\t\ts->wbio=BIO_push(s->bbio,s->wbio);\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_SRVR_HELLO_A:\n\t\tcase SSL3_ST_CR_SRVR_HELLO_B:\n\t\t\tret=ssl3_get_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CR_FINISHED_A;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\t{\n\t\t\t\t\t/* receive renewed session ticket */\n\t\t\t\t\ts->state=SSL3_ST_CR_SESSION_TICKET_A;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_CR_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_CERT_A:\n\t\tcase SSL3_ST_CR_CERT_B:\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tret=ssl3_check_finished(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\ts->hit = 1;\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_CR_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_CR_FINISHED_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t/* Check if it is anon DH/ECDH */\n\t\t\t/* or PSK */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\tret=ssl3_get_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_CR_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_KEY_EXCH_A:\n\t\tcase SSL3_ST_CR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\n\t\t\t/* at this point we check that we have the\n\t\t\t * required stuff from the server */\n\t\t\tif (!ssl3_check_cert_and_algorithm(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_CERT_REQ_A:\n\t\tcase SSL3_ST_CR_CERT_REQ_B:\n\t\t\tret=ssl3_get_certificate_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_SRVR_DONE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_SRVR_DONE_A:\n\t\tcase SSL3_ST_CR_SRVR_DONE_B:\n\t\t\tret=ssl3_get_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_SRP\n\t\t\tif (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP)\n\t\t\t\t{\n\t\t\t\tif ((ret = SRP_Calc_A_param(s))<=0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_CONNECT,SSL_R_SRP_A_CALC);\n\t\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_INTERNAL_ERROR);\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\tif (s->s3->tmp.cert_req)\n\t\t\t\ts->state=SSL3_ST_CW_CERT_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_CW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CERT_A:\n\t\tcase SSL3_ST_CW_CERT_B:\n\t\tcase SSL3_ST_CW_CERT_C:\n\t\tcase SSL3_ST_CW_CERT_D:\n\t\t\tret=ssl3_send_client_certificate(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_KEY_EXCH_A:\n\t\tcase SSL3_ST_CW_KEY_EXCH_B:\n\t\t\tret=ssl3_send_client_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\t/* EAY EAY EAY need to check for DH fix cert\n\t\t\t * sent back */\n\t\t\t/* For TLS, cert_req is set to 2, so a cert chain\n\t\t\t * of nothing is sent, but no verify packet is sent */\n\t\t\t/* XXX: For now, we do not support client \n\t\t\t * authentication in ECDH cipher suites with\n\t\t\t * ECDH (rather than ECDSA) certificates.\n\t\t\t * We need to skip the certificate verify \n\t\t\t * message when client's ECDH public key is sent \n\t\t\t * inside the client certificate.\n\t\t\t */\n\t\t\tif (s->s3->tmp.cert_req == 1)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CW_CERT_VRFY_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\t\ts->s3->change_cipher_spec=0;\n\t\t\t\t}\n\t\t\tif (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\t\ts->s3->change_cipher_spec=0;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CERT_VRFY_A:\n\t\tcase SSL3_ST_CW_CERT_VRFY_B:\n\t\t\tret=ssl3_send_client_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\ts->s3->change_cipher_spec=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CHANGE_A:\n\t\tcase SSL3_ST_CW_CHANGE_B:\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_CW_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_CW_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_CW_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n#ifdef OPENSSL_NO_COMP\n\t\t\ts->session->compress_meth=0;\n#else\n\t\t\tif (s->s3->tmp.new_compression == NULL)\n\t\t\t\ts->session->compress_meth=0;\n\t\t\telse\n\t\t\t\ts->session->compress_meth=\n\t\t\t\t\ts->s3->tmp.new_compression->id;\n#endif\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_CLIENT_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_CW_NEXT_PROTO_A:\n\t\tcase SSL3_ST_CW_NEXT_PROTO_B:\n\t\t\tret=ssl3_send_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_CW_FINISHED_A:\n\t\tcase SSL3_ST_CW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->client_finished_label,\n\t\t\t\ts->method->ssl3_enc->client_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_FLUSH;\n\n\t\t\t/* clear flags */\n\t\t\ts->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\t\tif (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)\n\t\t\t\t\t{\n\t\t\t\t\ts->state=SSL_ST_OK;\n\t\t\t\t\ts->s3->flags|=SSL3_FLAGS_POP_BUFFER;\n\t\t\t\t\ts->s3->delay_buf_pop_ret=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\t/* Allow NewSessionTicket if ticket expected */\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;\n\t\t\t\telse\n#endif\n\t\t\t\t\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;\n\t\t\t\t}\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_CR_SESSION_TICKET_A:\n\t\tcase SSL3_ST_CR_SESSION_TICKET_B:\n\t\t\tret=ssl3_get_new_session_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_FINISHED_A;\n\t\t\ts->init_num=0;\n\t\tbreak;\n\n\t\tcase SSL3_ST_CR_CERT_STATUS_A:\n\t\tcase SSL3_ST_CR_CERT_STATUS_B:\n\t\t\tret=ssl3_get_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_CR_FINISHED_A:\n\t\tcase SSL3_ST_CR_FINISHED_B:\n\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,\n\t\t\t\tSSL3_ST_CR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\telse\n\t\t\t\ts->state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_FLUSH:\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tif (s->init_buf != NULL)\n\t\t\t\t{\n\t\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\t\ts->init_buf=NULL;\n\t\t\t\t}\n\n\t\t\t/* If we are not 'joining' the last two packets,\n\t\t\t * remove the buffering now */\n\t\t\tif (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))\n\t\t\t\tssl_free_wbio_buffer(s);\n\t\t\t/* else do it later in ssl3_write */\n\n\t\t\ts->init_num=0;\n\t\t\ts->renegotiate=0;\n\t\t\ts->new_session=0;\n\n\t\t\tssl_update_cache(s,SSL_SESS_CACHE_CLIENT);\n\t\t\tif (s->hit) s->ctx->stats.sess_hit++;\n\n\t\t\tret=1;\n\t\t\t/* s->server=0; */\n\t\t\ts->handshake_func=ssl3_connect;\n\t\t\ts->ctx->stats.sess_connect_good++;\n\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\n\t\t/* did we do anything */\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_CONNECT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\ts->in_handshake--;\n\tif (buf != NULL)\n\t\tBUF_MEM_free(buf);\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_CONNECT_EXIT,ret);\n\treturn(ret);\n\t}",
        "func": "int ssl3_connect(SSL *s)\n\t{\n\tBUF_MEM *buf=NULL;\n\tunsigned long Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\t\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); \n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch(s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\ts->state=SSL_ST_CONNECT;\n\t\t\ts->ctx->stats.sess_connect_renegotiate++;\n\t\t\t/* break */\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_CONNECT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_CONNECT:\n\t\tcase SSL_ST_OK|SSL_ST_CONNECT:\n\n\t\t\ts->server=0;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version & 0xff00 ) != 0x0300)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t/* s->version=SSL3_VERSION; */\n\t\t\ts->type=SSL_ST_CONNECT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\tbuf=NULL;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s)) { ret= -1; goto end; }\n\n\t\t\t/* setup buffing BIO */\n\t\t\tif (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }\n\n\t\t\t/* don't push the buffering BIO quite yet */\n\n\t\t\tssl3_init_finished_mac(s);\n\n\t\t\ts->state=SSL3_ST_CW_CLNT_HELLO_A;\n\t\t\ts->ctx->stats.sess_connect++;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CLNT_HELLO_A:\n\t\tcase SSL3_ST_CW_CLNT_HELLO_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_client_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\n\t\t\t/* turn on buffering for the next lot of output */\n\t\t\tif (s->bbio != s->wbio)\n\t\t\t\ts->wbio=BIO_push(s->bbio,s->wbio);\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_SRVR_HELLO_A:\n\t\tcase SSL3_ST_CR_SRVR_HELLO_B:\n\t\t\tret=ssl3_get_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CR_FINISHED_A;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\t{\n\t\t\t\t\t/* receive renewed session ticket */\n\t\t\t\t\ts->state=SSL3_ST_CR_SESSION_TICKET_A;\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_CR_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_CERT_A:\n\t\tcase SSL3_ST_CR_CERT_B:\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tret=ssl3_check_finished(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\ts->hit = 1;\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_CR_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_CR_FINISHED_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t/* Check if it is anon DH/ECDH */\n\t\t\t/* or PSK */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t    !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\tret=ssl3_get_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_CR_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_KEY_EXCH_A:\n\t\tcase SSL3_ST_CR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\n\t\t\t/* at this point we check that we have the\n\t\t\t * required stuff from the server */\n\t\t\tif (!ssl3_check_cert_and_algorithm(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_CERT_REQ_A:\n\t\tcase SSL3_ST_CR_CERT_REQ_B:\n\t\t\tret=ssl3_get_certificate_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_SRVR_DONE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CR_SRVR_DONE_A:\n\t\tcase SSL3_ST_CR_SRVR_DONE_B:\n\t\t\tret=ssl3_get_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_SRP\n\t\t\tif (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP)\n\t\t\t\t{\n\t\t\t\tif ((ret = SRP_Calc_A_param(s))<=0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_CONNECT,SSL_R_SRP_A_CALC);\n\t\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_INTERNAL_ERROR);\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\tif (s->s3->tmp.cert_req)\n\t\t\t\ts->state=SSL3_ST_CW_CERT_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_CW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CERT_A:\n\t\tcase SSL3_ST_CW_CERT_B:\n\t\tcase SSL3_ST_CW_CERT_C:\n\t\tcase SSL3_ST_CW_CERT_D:\n\t\t\tret=ssl3_send_client_certificate(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_KEY_EXCH_A:\n\t\tcase SSL3_ST_CW_KEY_EXCH_B:\n\t\t\tret=ssl3_send_client_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\t/* EAY EAY EAY need to check for DH fix cert\n\t\t\t * sent back */\n\t\t\t/* For TLS, cert_req is set to 2, so a cert chain\n\t\t\t * of nothing is sent, but no verify packet is sent */\n\t\t\t/* XXX: For now, we do not support client \n\t\t\t * authentication in ECDH cipher suites with\n\t\t\t * ECDH (rather than ECDSA) certificates.\n\t\t\t * We need to skip the certificate verify \n\t\t\t * message when client's ECDH public key is sent \n\t\t\t * inside the client certificate.\n\t\t\t */\n\t\t\tif (s->s3->tmp.cert_req == 1)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CW_CERT_VRFY_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\t\ts->s3->change_cipher_spec=0;\n\t\t\t\t}\n\t\t\tif (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\t\ts->s3->change_cipher_spec=0;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CERT_VRFY_A:\n\t\tcase SSL3_ST_CW_CERT_VRFY_B:\n\t\t\tret=ssl3_send_client_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\ts->s3->change_cipher_spec=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_CHANGE_A:\n\t\tcase SSL3_ST_CW_CHANGE_B:\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_CW_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_CW_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_CW_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n#ifdef OPENSSL_NO_COMP\n\t\t\ts->session->compress_meth=0;\n#else\n\t\t\tif (s->s3->tmp.new_compression == NULL)\n\t\t\t\ts->session->compress_meth=0;\n\t\t\telse\n\t\t\t\ts->session->compress_meth=\n\t\t\t\t\ts->s3->tmp.new_compression->id;\n#endif\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_CLIENT_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_CW_NEXT_PROTO_A:\n\t\tcase SSL3_ST_CW_NEXT_PROTO_B:\n\t\t\tret=ssl3_send_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_CW_FINISHED_A:\n\t\tcase SSL3_ST_CW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->client_finished_label,\n\t\t\t\ts->method->ssl3_enc->client_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CW_FLUSH;\n\n\t\t\t/* clear flags */\n\t\t\ts->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\t\tif (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)\n\t\t\t\t\t{\n\t\t\t\t\ts->state=SSL_ST_OK;\n\t\t\t\t\ts->s3->flags|=SSL3_FLAGS_POP_BUFFER;\n\t\t\t\t\ts->s3->delay_buf_pop_ret=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\t/* Allow NewSessionTicket if ticket expected */\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;\n\t\t\t\telse\n#endif\n\t\t\t\t\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;\n\t\t\t\t}\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_CR_SESSION_TICKET_A:\n\t\tcase SSL3_ST_CR_SESSION_TICKET_B:\n\t\t\tret=ssl3_get_new_session_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_FINISHED_A;\n\t\t\ts->init_num=0;\n\t\tbreak;\n\n\t\tcase SSL3_ST_CR_CERT_STATUS_A:\n\t\tcase SSL3_ST_CR_CERT_STATUS_B:\n\t\t\tret=ssl3_get_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_CR_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_CR_FINISHED_A:\n\t\tcase SSL3_ST_CR_FINISHED_B:\n\n\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,\n\t\t\t\tSSL3_ST_CR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL3_ST_CW_CHANGE_A;\n\t\t\telse\n\t\t\t\ts->state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_CW_FLUSH:\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tif (s->init_buf != NULL)\n\t\t\t\t{\n\t\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\t\ts->init_buf=NULL;\n\t\t\t\t}\n\n\t\t\t/* If we are not 'joining' the last two packets,\n\t\t\t * remove the buffering now */\n\t\t\tif (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))\n\t\t\t\tssl_free_wbio_buffer(s);\n\t\t\t/* else do it later in ssl3_write */\n\n\t\t\ts->init_num=0;\n\t\t\ts->renegotiate=0;\n\t\t\ts->new_session=0;\n\n\t\t\tssl_update_cache(s,SSL_SESS_CACHE_CLIENT);\n\t\t\tif (s->hit) s->ctx->stats.sess_hit++;\n\n\t\t\tret=1;\n\t\t\t/* s->server=0; */\n\t\t\ts->handshake_func=ssl3_connect;\n\t\t\ts->ctx->stats.sess_connect_good++;\n\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\n\t\t/* did we do anything */\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_CONNECT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\ts->in_handshake--;\n\tif (buf != NULL)\n\t\tBUF_MEM_free(buf);\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_CONNECT_EXIT,ret);\n\treturn(ret);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -374,6 +374,7 @@\n \t\tcase SSL3_ST_CR_FINISHED_A:\n \t\tcase SSL3_ST_CR_FINISHED_B:\n \n+\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;\n \t\t\tret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,\n \t\t\t\tSSL3_ST_CR_FINISHED_B);\n \t\t\tif (ret <= 0) goto end;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\ts->s3->flags |= SSL3_FLAGS_CCS_OK;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7798",
        "func_name": "ruby/openssl/Init_ossl_cipher",
        "description": "The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",
        "git_url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062",
        "commit_title": "cipher: don't set dummy encryption key in Cipher#initialize",
        "commit_text": " Remove the encryption key initialization from Cipher#initialize. This is effectively a revert of r32723 (\"Avoid possible SEGV from AES encryption/decryption\", 2011-07-28).  r32723, which added the key initialization, was a workaround for Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate() before setting an encryption key caused segfault. It was not a problem until OpenSSL implemented GCM mode - the encryption key could be overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the case for AES-GCM ciphers. Setting a key, an IV, a key, in this order causes the IV to be reset to an all-zero IV.  The problem of Bug #2768 persists on the current versions of OpenSSL. So, make Cipher#update raise an exception if a key is not yet set by the user. Since encrypting or decrypting without key does not make any sense, this should not break existing applications.  Users can still call Cipher#key= and Cipher#iv= multiple times with their own responsibility.  Reference: https://bugs.ruby-lang.org/issues/2768 Reference: https://bugs.ruby-lang.org/issues/8221 Reference: https://github.com/ruby/openssl/issues/49",
        "func_before": "void\nInit_ossl_cipher(void)\n{\n#if 0\n    mOSSL = rb_define_module(\"OpenSSL\");\n    eOSSLError = rb_define_class_under(mOSSL, \"OpenSSLError\", rb_eStandardError);\n#endif\n\n    /* Document-class: OpenSSL::Cipher\n     *\n     * Provides symmetric algorithms for encryption and decryption. The\n     * algorithms that are available depend on the particular version\n     * of OpenSSL that is installed.\n     *\n     * === Listing all supported algorithms\n     *\n     * A list of supported algorithms can be obtained by\n     *\n     *   puts OpenSSL::Cipher.ciphers\n     *\n     * === Instantiating a Cipher\n     *\n     * There are several ways to create a Cipher instance. Generally, a\n     * Cipher algorithm is categorized by its name, the key length in bits\n     * and the cipher mode to be used. The most generic way to create a\n     * Cipher is the following\n     *\n     *   cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')\n     *\n     * That is, a string consisting of the hyphenated concatenation of the\n     * individual components name, key length and mode. Either all uppercase\n     * or all lowercase strings may be used, for example:\n     *\n     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')\n     *\n     * For each algorithm supported, there is a class defined under the\n     * Cipher class that goes by the name of the cipher, e.g. to obtain an\n     * instance of AES, you could also use\n     *\n     *   # these are equivalent\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher = OpenSSL::Cipher::AES.new(128, 'CBC')\n     *   cipher = OpenSSL::Cipher::AES.new('128-CBC')\n     *\n     * Finally, due to its wide-spread use, there are also extra classes\n     * defined for the different key sizes of AES\n     *\n     *   cipher = OpenSSL::Cipher::AES128.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES192.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES256.new(:CBC)\n     *\n     * === Choosing either encryption or decryption mode\n     *\n     * Encryption and decryption are often very similar operations for\n     * symmetric algorithms, this is reflected by not having to choose\n     * different classes for either operation, both can be done using the\n     * same class. Still, after obtaining a Cipher instance, we need to\n     * tell the instance what it is that we intend to do with it, so we\n     * need to call either\n     *\n     *   cipher.encrypt\n     *\n     * or\n     *\n     *   cipher.decrypt\n     *\n     * on the Cipher instance. This should be the first call after creating\n     * the instance, otherwise configuration that has already been set could\n     * get lost in the process.\n     *\n     * === Choosing a key\n     *\n     * Symmetric encryption requires a key that is the same for the encrypting\n     * and for the decrypting party and after initial key establishment should\n     * be kept as private information. There are a lot of ways to create\n     * insecure keys, the most notable is to simply take a password as the key\n     * without processing the password further. A simple and secure way to\n     * create a key for a particular Cipher is\n     *\n     *  cipher = OpenSSL::AES256.new(:CFB)\n     *  cipher.encrypt\n     *  key = cipher.random_key # also sets the generated key on the Cipher\n     *\n     * If you absolutely need to use passwords as encryption keys, you\n     * should use Password-Based Key Derivation Function 2 (PBKDF2) by\n     * generating the key with the help of the functionality provided by\n     * OpenSSL::PKCS5.pbkdf2_hmac_sha1 or OpenSSL::PKCS5.pbkdf2_hmac.\n     *\n     * Although there is Cipher#pkcs5_keyivgen, its use is deprecated and\n     * it should only be used in legacy applications because it does not use\n     * the newer PKCS#5 v2 algorithms.\n     *\n     * === Choosing an IV\n     *\n     * The cipher modes CBC, CFB, OFB and CTR all need an \"initialization\n     * vector\", or short, IV. ECB mode is the only mode that does not require\n     * an IV, but there is almost no legitimate use case for this mode\n     * because of the fact that it does not sufficiently hide plaintext\n     * patterns. Therefore\n     *\n     * <b>You should never use ECB mode unless you are absolutely sure that\n     * you absolutely need it</b>\n     *\n     * Because of this, you will end up with a mode that explicitly requires\n     * an IV in any case. Note that for backwards compatibility reasons,\n     * setting an IV is not explicitly mandated by the Cipher API. If not\n     * set, OpenSSL itself defaults to an all-zeroes IV (\"\\\\0\", not the\n     * character). Although the IV can be seen as public information, i.e.\n     * it may be transmitted in public once generated, it should still stay\n     * unpredictable to prevent certain kinds of attacks. Therefore, ideally\n     *\n     * <b>Always create a secure random IV for every encryption of your\n     * Cipher</b>\n     *\n     * A new, random IV should be created for every encryption of data. Think\n     * of the IV as a nonce (number used once) - it's public but random and\n     * unpredictable. A secure random IV can be created as follows\n     *\n     *   cipher = ...\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv # also sets the generated IV on the Cipher\n     *\n     * Although the key is generally a random value, too, it is a bad choice\n     * as an IV. There are elaborate ways how an attacker can take advantage\n     * of such an IV. As a general rule of thumb, exposing the key directly\n     * or indirectly should be avoided at all cost and exceptions only be\n     * made with good reason.\n     *\n     * === Calling Cipher#final\n     *\n     * ECB (which should not be used) and CBC are both block-based modes.\n     * This means that unlike for the other streaming-based modes, they\n     * operate on fixed-size blocks of data, and therefore they require a\n     * \"finalization\" step to produce or correctly decrypt the last block of\n     * data by appropriately handling some form of padding. Therefore it is\n     * essential to add the output of OpenSSL::Cipher#final to your\n     * encryption/decryption buffer or you will end up with decryption errors\n     * or truncated data.\n     *\n     * Although this is not really necessary for streaming-mode ciphers, it is\n     * still recommended to apply the same pattern of adding the output of\n     * Cipher#final there as well - it also enables you to switch between\n     * modes more easily in the future.\n     *\n     * === Encrypting and decrypting some data\n     *\n     *   data = \"Very, very confidential data\"\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   ...\n     *   decipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   decipher.decrypt\n     *   decipher.key = key\n     *   decipher.iv = iv\n     *\n     *   plain = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == plain #=> true\n     *\n     * === Authenticated Encryption and Associated Data (AEAD)\n     *\n     * If the OpenSSL version used supports it, an Authenticated Encryption\n     * mode (such as GCM or CCM) should always be preferred over any\n     * unauthenticated mode. Currently, OpenSSL supports AE only in combination\n     * with Associated Data (AEAD) where additional associated data is included\n     * in the encryption process to compute a tag at the end of the encryption.\n     * This tag will also be used in the decryption process and by verifying\n     * its validity, the authenticity of a given ciphertext is established.\n     *\n     * This is superior to unauthenticated modes in that it allows to detect\n     * if somebody effectively changed the ciphertext after it had been\n     * encrypted. This prevents malicious modifications of the ciphertext that\n     * could otherwise be exploited to modify ciphertexts in ways beneficial to\n     * potential attackers.\n     *\n     * An associated data is used where there is additional information, such as\n     * headers or some metadata, that must be also authenticated but not\n     * necessarily need to be encrypted. If no associated data is needed for\n     * encryption and later decryption, the OpenSSL library still requires a\n     * value to be set - \"\" may be used in case none is available.\n     *\n     * An example using the GCM (Galois/Counter Mode). You have 16 bytes +key+,\n     * 12 bytes (96 bits) +nonce+ and the associated data +auth_data+. Be sure\n     * not to reuse the +key+ and +nonce+ pair. Reusing an nonce ruins the\n     * security gurantees of GCM mode.\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :GCM).encrypt\n     *   cipher.key = key\n     *   cipher.iv = nonce\n     *   cipher.auth_data = auth_data\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   tag = cipher.auth_tag # produces 16 bytes tag by default\n     *\n     * Now you are the receiver. You know the +key+ and have received +nonce+,\n     * +auth_data+, +encrypted+ and +tag+ through an untrusted network. Note\n     * that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may\n     * additionally need to check that the received tag has the correct length,\n     * or you allow attackers to forge a valid single byte tag for the tampered\n     * ciphertext with a probability of 1/256.\n     *\n     *   raise \"tag is truncated!\" unless tag.bytesize == 16\n     *   decipher = OpenSSL::Cipher::AES.new(128, :GCM).decrypt\n     *   decipher.key = key\n     *   decipher.iv = nonce\n     *   decipher.auth_tag = tag\n     *   decipher.auth_data = auth_data\n     *\n     *   decrypted = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == decrypted #=> true\n     */\n    cCipher = rb_define_class_under(mOSSL, \"Cipher\", rb_cObject);\n    eCipherError = rb_define_class_under(cCipher, \"CipherError\", eOSSLError);\n\n    rb_define_alloc_func(cCipher, ossl_cipher_alloc);\n    rb_define_copy_func(cCipher, ossl_cipher_copy);\n    rb_define_module_function(cCipher, \"ciphers\", ossl_s_ciphers, 0);\n    rb_define_method(cCipher, \"initialize\", ossl_cipher_initialize, 1);\n    rb_define_method(cCipher, \"reset\", ossl_cipher_reset, 0);\n    rb_define_method(cCipher, \"encrypt\", ossl_cipher_encrypt, -1);\n    rb_define_method(cCipher, \"decrypt\", ossl_cipher_decrypt, -1);\n    rb_define_method(cCipher, \"pkcs5_keyivgen\", ossl_cipher_pkcs5_keyivgen, -1);\n    rb_define_method(cCipher, \"update\", ossl_cipher_update, -1);\n    rb_define_method(cCipher, \"final\", ossl_cipher_final, 0);\n    rb_define_method(cCipher, \"name\", ossl_cipher_name, 0);\n    rb_define_method(cCipher, \"key=\", ossl_cipher_set_key, 1);\n    rb_define_method(cCipher, \"auth_data=\", ossl_cipher_set_auth_data, 1);\n    rb_define_method(cCipher, \"auth_tag=\", ossl_cipher_set_auth_tag, 1);\n    rb_define_method(cCipher, \"auth_tag\", ossl_cipher_get_auth_tag, -1);\n    rb_define_method(cCipher, \"auth_tag_len=\", ossl_cipher_set_auth_tag_len, 1);\n    rb_define_method(cCipher, \"authenticated?\", ossl_cipher_is_authenticated, 0);\n    rb_define_method(cCipher, \"key_len=\", ossl_cipher_set_key_length, 1);\n    rb_define_method(cCipher, \"key_len\", ossl_cipher_key_length, 0);\n    rb_define_method(cCipher, \"iv=\", ossl_cipher_set_iv, 1);\n    rb_define_method(cCipher, \"iv_len=\", ossl_cipher_set_iv_length, 1);\n    rb_define_method(cCipher, \"iv_len\", ossl_cipher_iv_length, 0);\n    rb_define_method(cCipher, \"block_size\", ossl_cipher_block_size, 0);\n    rb_define_method(cCipher, \"padding=\", ossl_cipher_set_padding, 1);\n\n    id_auth_tag_len = rb_intern_const(\"auth_tag_len\");\n}",
        "func": "void\nInit_ossl_cipher(void)\n{\n#if 0\n    mOSSL = rb_define_module(\"OpenSSL\");\n    eOSSLError = rb_define_class_under(mOSSL, \"OpenSSLError\", rb_eStandardError);\n#endif\n\n    /* Document-class: OpenSSL::Cipher\n     *\n     * Provides symmetric algorithms for encryption and decryption. The\n     * algorithms that are available depend on the particular version\n     * of OpenSSL that is installed.\n     *\n     * === Listing all supported algorithms\n     *\n     * A list of supported algorithms can be obtained by\n     *\n     *   puts OpenSSL::Cipher.ciphers\n     *\n     * === Instantiating a Cipher\n     *\n     * There are several ways to create a Cipher instance. Generally, a\n     * Cipher algorithm is categorized by its name, the key length in bits\n     * and the cipher mode to be used. The most generic way to create a\n     * Cipher is the following\n     *\n     *   cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')\n     *\n     * That is, a string consisting of the hyphenated concatenation of the\n     * individual components name, key length and mode. Either all uppercase\n     * or all lowercase strings may be used, for example:\n     *\n     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')\n     *\n     * For each algorithm supported, there is a class defined under the\n     * Cipher class that goes by the name of the cipher, e.g. to obtain an\n     * instance of AES, you could also use\n     *\n     *   # these are equivalent\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher = OpenSSL::Cipher::AES.new(128, 'CBC')\n     *   cipher = OpenSSL::Cipher::AES.new('128-CBC')\n     *\n     * Finally, due to its wide-spread use, there are also extra classes\n     * defined for the different key sizes of AES\n     *\n     *   cipher = OpenSSL::Cipher::AES128.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES192.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES256.new(:CBC)\n     *\n     * === Choosing either encryption or decryption mode\n     *\n     * Encryption and decryption are often very similar operations for\n     * symmetric algorithms, this is reflected by not having to choose\n     * different classes for either operation, both can be done using the\n     * same class. Still, after obtaining a Cipher instance, we need to\n     * tell the instance what it is that we intend to do with it, so we\n     * need to call either\n     *\n     *   cipher.encrypt\n     *\n     * or\n     *\n     *   cipher.decrypt\n     *\n     * on the Cipher instance. This should be the first call after creating\n     * the instance, otherwise configuration that has already been set could\n     * get lost in the process.\n     *\n     * === Choosing a key\n     *\n     * Symmetric encryption requires a key that is the same for the encrypting\n     * and for the decrypting party and after initial key establishment should\n     * be kept as private information. There are a lot of ways to create\n     * insecure keys, the most notable is to simply take a password as the key\n     * without processing the password further. A simple and secure way to\n     * create a key for a particular Cipher is\n     *\n     *  cipher = OpenSSL::AES256.new(:CFB)\n     *  cipher.encrypt\n     *  key = cipher.random_key # also sets the generated key on the Cipher\n     *\n     * If you absolutely need to use passwords as encryption keys, you\n     * should use Password-Based Key Derivation Function 2 (PBKDF2) by\n     * generating the key with the help of the functionality provided by\n     * OpenSSL::PKCS5.pbkdf2_hmac_sha1 or OpenSSL::PKCS5.pbkdf2_hmac.\n     *\n     * Although there is Cipher#pkcs5_keyivgen, its use is deprecated and\n     * it should only be used in legacy applications because it does not use\n     * the newer PKCS#5 v2 algorithms.\n     *\n     * === Choosing an IV\n     *\n     * The cipher modes CBC, CFB, OFB and CTR all need an \"initialization\n     * vector\", or short, IV. ECB mode is the only mode that does not require\n     * an IV, but there is almost no legitimate use case for this mode\n     * because of the fact that it does not sufficiently hide plaintext\n     * patterns. Therefore\n     *\n     * <b>You should never use ECB mode unless you are absolutely sure that\n     * you absolutely need it</b>\n     *\n     * Because of this, you will end up with a mode that explicitly requires\n     * an IV in any case. Note that for backwards compatibility reasons,\n     * setting an IV is not explicitly mandated by the Cipher API. If not\n     * set, OpenSSL itself defaults to an all-zeroes IV (\"\\\\0\", not the\n     * character). Although the IV can be seen as public information, i.e.\n     * it may be transmitted in public once generated, it should still stay\n     * unpredictable to prevent certain kinds of attacks. Therefore, ideally\n     *\n     * <b>Always create a secure random IV for every encryption of your\n     * Cipher</b>\n     *\n     * A new, random IV should be created for every encryption of data. Think\n     * of the IV as a nonce (number used once) - it's public but random and\n     * unpredictable. A secure random IV can be created as follows\n     *\n     *   cipher = ...\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv # also sets the generated IV on the Cipher\n     *\n     * Although the key is generally a random value, too, it is a bad choice\n     * as an IV. There are elaborate ways how an attacker can take advantage\n     * of such an IV. As a general rule of thumb, exposing the key directly\n     * or indirectly should be avoided at all cost and exceptions only be\n     * made with good reason.\n     *\n     * === Calling Cipher#final\n     *\n     * ECB (which should not be used) and CBC are both block-based modes.\n     * This means that unlike for the other streaming-based modes, they\n     * operate on fixed-size blocks of data, and therefore they require a\n     * \"finalization\" step to produce or correctly decrypt the last block of\n     * data by appropriately handling some form of padding. Therefore it is\n     * essential to add the output of OpenSSL::Cipher#final to your\n     * encryption/decryption buffer or you will end up with decryption errors\n     * or truncated data.\n     *\n     * Although this is not really necessary for streaming-mode ciphers, it is\n     * still recommended to apply the same pattern of adding the output of\n     * Cipher#final there as well - it also enables you to switch between\n     * modes more easily in the future.\n     *\n     * === Encrypting and decrypting some data\n     *\n     *   data = \"Very, very confidential data\"\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   ...\n     *   decipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   decipher.decrypt\n     *   decipher.key = key\n     *   decipher.iv = iv\n     *\n     *   plain = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == plain #=> true\n     *\n     * === Authenticated Encryption and Associated Data (AEAD)\n     *\n     * If the OpenSSL version used supports it, an Authenticated Encryption\n     * mode (such as GCM or CCM) should always be preferred over any\n     * unauthenticated mode. Currently, OpenSSL supports AE only in combination\n     * with Associated Data (AEAD) where additional associated data is included\n     * in the encryption process to compute a tag at the end of the encryption.\n     * This tag will also be used in the decryption process and by verifying\n     * its validity, the authenticity of a given ciphertext is established.\n     *\n     * This is superior to unauthenticated modes in that it allows to detect\n     * if somebody effectively changed the ciphertext after it had been\n     * encrypted. This prevents malicious modifications of the ciphertext that\n     * could otherwise be exploited to modify ciphertexts in ways beneficial to\n     * potential attackers.\n     *\n     * An associated data is used where there is additional information, such as\n     * headers or some metadata, that must be also authenticated but not\n     * necessarily need to be encrypted. If no associated data is needed for\n     * encryption and later decryption, the OpenSSL library still requires a\n     * value to be set - \"\" may be used in case none is available.\n     *\n     * An example using the GCM (Galois/Counter Mode). You have 16 bytes +key+,\n     * 12 bytes (96 bits) +nonce+ and the associated data +auth_data+. Be sure\n     * not to reuse the +key+ and +nonce+ pair. Reusing an nonce ruins the\n     * security gurantees of GCM mode.\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :GCM).encrypt\n     *   cipher.key = key\n     *   cipher.iv = nonce\n     *   cipher.auth_data = auth_data\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   tag = cipher.auth_tag # produces 16 bytes tag by default\n     *\n     * Now you are the receiver. You know the +key+ and have received +nonce+,\n     * +auth_data+, +encrypted+ and +tag+ through an untrusted network. Note\n     * that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may\n     * additionally need to check that the received tag has the correct length,\n     * or you allow attackers to forge a valid single byte tag for the tampered\n     * ciphertext with a probability of 1/256.\n     *\n     *   raise \"tag is truncated!\" unless tag.bytesize == 16\n     *   decipher = OpenSSL::Cipher::AES.new(128, :GCM).decrypt\n     *   decipher.key = key\n     *   decipher.iv = nonce\n     *   decipher.auth_tag = tag\n     *   decipher.auth_data = auth_data\n     *\n     *   decrypted = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == decrypted #=> true\n     */\n    cCipher = rb_define_class_under(mOSSL, \"Cipher\", rb_cObject);\n    eCipherError = rb_define_class_under(cCipher, \"CipherError\", eOSSLError);\n\n    rb_define_alloc_func(cCipher, ossl_cipher_alloc);\n    rb_define_copy_func(cCipher, ossl_cipher_copy);\n    rb_define_module_function(cCipher, \"ciphers\", ossl_s_ciphers, 0);\n    rb_define_method(cCipher, \"initialize\", ossl_cipher_initialize, 1);\n    rb_define_method(cCipher, \"reset\", ossl_cipher_reset, 0);\n    rb_define_method(cCipher, \"encrypt\", ossl_cipher_encrypt, -1);\n    rb_define_method(cCipher, \"decrypt\", ossl_cipher_decrypt, -1);\n    rb_define_method(cCipher, \"pkcs5_keyivgen\", ossl_cipher_pkcs5_keyivgen, -1);\n    rb_define_method(cCipher, \"update\", ossl_cipher_update, -1);\n    rb_define_method(cCipher, \"final\", ossl_cipher_final, 0);\n    rb_define_method(cCipher, \"name\", ossl_cipher_name, 0);\n    rb_define_method(cCipher, \"key=\", ossl_cipher_set_key, 1);\n    rb_define_method(cCipher, \"auth_data=\", ossl_cipher_set_auth_data, 1);\n    rb_define_method(cCipher, \"auth_tag=\", ossl_cipher_set_auth_tag, 1);\n    rb_define_method(cCipher, \"auth_tag\", ossl_cipher_get_auth_tag, -1);\n    rb_define_method(cCipher, \"auth_tag_len=\", ossl_cipher_set_auth_tag_len, 1);\n    rb_define_method(cCipher, \"authenticated?\", ossl_cipher_is_authenticated, 0);\n    rb_define_method(cCipher, \"key_len=\", ossl_cipher_set_key_length, 1);\n    rb_define_method(cCipher, \"key_len\", ossl_cipher_key_length, 0);\n    rb_define_method(cCipher, \"iv=\", ossl_cipher_set_iv, 1);\n    rb_define_method(cCipher, \"iv_len=\", ossl_cipher_set_iv_length, 1);\n    rb_define_method(cCipher, \"iv_len\", ossl_cipher_iv_length, 0);\n    rb_define_method(cCipher, \"block_size\", ossl_cipher_block_size, 0);\n    rb_define_method(cCipher, \"padding=\", ossl_cipher_set_padding, 1);\n\n    id_auth_tag_len = rb_intern_const(\"auth_tag_len\");\n    id_key_set = rb_intern_const(\"key_set\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -245,4 +245,5 @@\n     rb_define_method(cCipher, \"padding=\", ossl_cipher_set_padding, 1);\n \n     id_auth_tag_len = rb_intern_const(\"auth_tag_len\");\n+    id_key_set = rb_intern_const(\"key_set\");\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    id_key_set = rb_intern_const(\"key_set\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7798",
        "func_name": "ruby/openssl/ossl_cipher_pkcs5_keyivgen",
        "description": "The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",
        "git_url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062",
        "commit_title": "cipher: don't set dummy encryption key in Cipher#initialize",
        "commit_text": " Remove the encryption key initialization from Cipher#initialize. This is effectively a revert of r32723 (\"Avoid possible SEGV from AES encryption/decryption\", 2011-07-28).  r32723, which added the key initialization, was a workaround for Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate() before setting an encryption key caused segfault. It was not a problem until OpenSSL implemented GCM mode - the encryption key could be overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the case for AES-GCM ciphers. Setting a key, an IV, a key, in this order causes the IV to be reset to an all-zero IV.  The problem of Bug #2768 persists on the current versions of OpenSSL. So, make Cipher#update raise an exception if a key is not yet set by the user. Since encrypting or decrypting without key does not make any sense, this should not break existing applications.  Users can still call Cipher#key= and Cipher#iv= multiple times with their own responsibility.  Reference: https://bugs.ruby-lang.org/issues/2768 Reference: https://bugs.ruby-lang.org/issues/8221 Reference: https://github.com/ruby/openssl/issues/49",
        "func_before": "static VALUE\nossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_MD *digest;\n    VALUE vpass, vsalt, viter, vdigest;\n    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;\n    int iter;\n\n    rb_scan_args(argc, argv, \"13\", &vpass, &vsalt, &viter, &vdigest);\n    StringValue(vpass);\n    if(!NIL_P(vsalt)){\n\tStringValue(vsalt);\n\tif(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)\n\t    ossl_raise(eCipherError, \"salt must be an 8-octet string\");\n\tsalt = (unsigned char *)RSTRING_PTR(vsalt);\n    }\n    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);\n    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);\n    GetCipher(self, ctx);\n    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,\n\t\t   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    OPENSSL_cleanse(key, sizeof key);\n    OPENSSL_cleanse(iv, sizeof iv);\n\n    return Qnil;\n}",
        "func": "static VALUE\nossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_MD *digest;\n    VALUE vpass, vsalt, viter, vdigest;\n    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;\n    int iter;\n\n    rb_scan_args(argc, argv, \"13\", &vpass, &vsalt, &viter, &vdigest);\n    StringValue(vpass);\n    if(!NIL_P(vsalt)){\n\tStringValue(vsalt);\n\tif(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)\n\t    ossl_raise(eCipherError, \"salt must be an 8-octet string\");\n\tsalt = (unsigned char *)RSTRING_PTR(vsalt);\n    }\n    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);\n    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);\n    GetCipher(self, ctx);\n    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,\n\t\t   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    OPENSSL_cleanse(key, sizeof key);\n    OPENSSL_cleanse(iv, sizeof iv);\n\n    rb_ivar_set(self, id_key_set, Qtrue);\n\n    return Qnil;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,5 +25,7 @@\n     OPENSSL_cleanse(key, sizeof key);\n     OPENSSL_cleanse(iv, sizeof iv);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return Qnil;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    rb_ivar_set(self, id_key_set, Qtrue);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7798",
        "func_name": "ruby/openssl/ossl_cipher_initialize",
        "description": "The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",
        "git_url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062",
        "commit_title": "cipher: don't set dummy encryption key in Cipher#initialize",
        "commit_text": " Remove the encryption key initialization from Cipher#initialize. This is effectively a revert of r32723 (\"Avoid possible SEGV from AES encryption/decryption\", 2011-07-28).  r32723, which added the key initialization, was a workaround for Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate() before setting an encryption key caused segfault. It was not a problem until OpenSSL implemented GCM mode - the encryption key could be overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the case for AES-GCM ciphers. Setting a key, an IV, a key, in this order causes the IV to be reset to an all-zero IV.  The problem of Bug #2768 persists on the current versions of OpenSSL. So, make Cipher#update raise an exception if a key is not yet set by the user. Since encrypting or decrypting without key does not make any sense, this should not break existing applications.  Users can still call Cipher#key= and Cipher#iv= multiple times with their own responsibility.  Reference: https://bugs.ruby-lang.org/issues/2768 Reference: https://bugs.ruby-lang.org/issues/8221 Reference: https://github.com/ruby/openssl/issues/49",
        "func_before": "static VALUE\nossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    /*\n     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n     *\n     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n     * uninitialized key, but other EVPs (such as AES) does not allow it.\n     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n     * set the data filled with \"\\0\" as the key by default.\n     */\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}",
        "func": "static VALUE\nossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,6 @@\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n-    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n@@ -15,16 +14,7 @@\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n     }\n-    /*\n-     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n-     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n-     *\n-     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n-     * uninitialized key, but other EVPs (such as AES) does not allow it.\n-     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n-     * set the data filled with \"\\0\" as the key by default.\n-     */\n-    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n+    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;",
        "diff_line_info": {
            "deleted_lines": [
                "    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };",
                "    /*",
                "     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some",
                "     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]",
                "     *",
                "     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows",
                "     * uninitialized key, but other EVPs (such as AES) does not allow it.",
                "     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we",
                "     * set the data filled with \"\\0\" as the key by default.",
                "     */",
                "    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)"
            ],
            "added_lines": [
                "    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7798",
        "func_name": "ruby/openssl/ossl_cipher_update",
        "description": "The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",
        "git_url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062",
        "commit_title": "cipher: don't set dummy encryption key in Cipher#initialize",
        "commit_text": " Remove the encryption key initialization from Cipher#initialize. This is effectively a revert of r32723 (\"Avoid possible SEGV from AES encryption/decryption\", 2011-07-28).  r32723, which added the key initialization, was a workaround for Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate() before setting an encryption key caused segfault. It was not a problem until OpenSSL implemented GCM mode - the encryption key could be overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the case for AES-GCM ciphers. Setting a key, an IV, a key, in this order causes the IV to be reset to an all-zero IV.  The problem of Bug #2768 persists on the current versions of OpenSSL. So, make Cipher#update raise an exception if a key is not yet set by the user. Since encrypting or decrypting without key does not make any sense, this should not break existing applications.  Users can still call Cipher#key= and Cipher#iv= multiple times with their own responsibility.  Reference: https://bugs.ruby-lang.org/issues/2768 Reference: https://bugs.ruby-lang.org/issues/8221 Reference: https://github.com/ruby/openssl/issues/49",
        "func_before": "static VALUE\nossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n\n    return str;\n}",
        "func": "static VALUE\nossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n\n    return str;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,9 @@\n     VALUE data, str;\n \n     rb_scan_args(argc, argv, \"11\", &data, &str);\n+\n+    if (!RTEST(rb_attr_get(self, id_key_set)))\n+\tossl_raise(eCipherError, \"key not set\");\n \n     StringValue(data);\n     in = (unsigned char *)RSTRING_PTR(data);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (!RTEST(rb_attr_get(self, id_key_set)))",
                "\tossl_raise(eCipherError, \"key not set\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7798",
        "func_name": "ruby/openssl/ossl_cipher_set_key",
        "description": "The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",
        "git_url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062",
        "commit_title": "cipher: don't set dummy encryption key in Cipher#initialize",
        "commit_text": " Remove the encryption key initialization from Cipher#initialize. This is effectively a revert of r32723 (\"Avoid possible SEGV from AES encryption/decryption\", 2011-07-28).  r32723, which added the key initialization, was a workaround for Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate() before setting an encryption key caused segfault. It was not a problem until OpenSSL implemented GCM mode - the encryption key could be overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the case for AES-GCM ciphers. Setting a key, an IV, a key, in this order causes the IV to be reset to an all-zero IV.  The problem of Bug #2768 persists on the current versions of OpenSSL. So, make Cipher#update raise an exception if a key is not yet set by the user. Since encrypting or decrypting without key does not make any sense, this should not break existing applications.  Users can still call Cipher#key= and Cipher#iv= multiple times with their own responsibility.  Reference: https://bugs.ruby-lang.org/issues/2768 Reference: https://bugs.ruby-lang.org/issues/8221 Reference: https://github.com/ruby/openssl/issues/49",
        "func_before": "static VALUE\nossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n\n    StringValue(key);\n    GetCipher(self, ctx);\n\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return key;\n}",
        "func": "static VALUE\nossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n\n    StringValue(key);\n    GetCipher(self, ctx);\n\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    rb_ivar_set(self, id_key_set, Qtrue);\n\n    return key;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,5 +14,7 @@\n     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n+    rb_ivar_set(self, id_key_set, Qtrue);\n+\n     return key;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    rb_ivar_set(self, id_key_set, Qtrue);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7798",
        "func_name": "ruby/openssl/ossl_cipher_init",
        "description": "The openssl gem for Ruby uses the same initialization vector (IV) in GCM Mode (aes-*-gcm) when the IV is set before the key, which makes it easier for context-dependent attackers to bypass the encryption protection mechanism.",
        "git_url": "https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062",
        "commit_title": "cipher: don't set dummy encryption key in Cipher#initialize",
        "commit_text": " Remove the encryption key initialization from Cipher#initialize. This is effectively a revert of r32723 (\"Avoid possible SEGV from AES encryption/decryption\", 2011-07-28).  r32723, which added the key initialization, was a workaround for Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate() before setting an encryption key caused segfault. It was not a problem until OpenSSL implemented GCM mode - the encryption key could be overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the case for AES-GCM ciphers. Setting a key, an IV, a key, in this order causes the IV to be reset to an all-zero IV.  The problem of Bug #2768 persists on the current versions of OpenSSL. So, make Cipher#update raise an exception if a key is not yet set by the user. Since encrypting or decrypting without key does not make any sense, this should not break existing applications.  Users can still call Cipher#key= and Cipher#iv= multiple times with their own responsibility.  Reference: https://bugs.ruby-lang.org/issues/2768 Reference: https://bugs.ruby-lang.org/issues/8221 Reference: https://github.com/ruby/openssl/issues/49",
        "func_before": "static VALUE\nossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;\n    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;\n    VALUE pass, init_v;\n\n    if(rb_scan_args(argc, argv, \"02\", &pass, &init_v) > 0){\n\t/*\n\t * oops. this code mistakes salt for IV.\n\t * We deprecated the arguments for this method, but we decided\n\t * keeping this behaviour for backward compatibility.\n\t */\n\tVALUE cname  = rb_class_path(rb_obj_class(self));\n\trb_warn(\"arguments for %\"PRIsVALUE\"#encrypt and %\"PRIsVALUE\"#decrypt were deprecated; \"\n                \"use %\"PRIsVALUE\"#pkcs5_keyivgen to derive key and IV\",\n                cname, cname, cname);\n\tStringValue(pass);\n\tGetCipher(self, ctx);\n\tif (NIL_P(init_v)) memcpy(iv, \"OpenSSL for Ruby rulez!\", sizeof(iv));\n\telse{\n\t    StringValue(init_v);\n\t    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {\n\t\tmemset(iv, 0, EVP_MAX_IV_LENGTH);\n\t\tmemcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));\n\t    }\n\t    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));\n\t}\n\tEVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,\n\t\t       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);\n\tp_key = key;\n\tp_iv = iv;\n    }\n    else {\n\tGetCipher(self, ctx);\n    }\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {\n\tossl_raise(eCipherError, NULL);\n    }\n\n    return self;\n}",
        "func": "static VALUE\nossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;\n    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;\n    VALUE pass, init_v;\n\n    if(rb_scan_args(argc, argv, \"02\", &pass, &init_v) > 0){\n\t/*\n\t * oops. this code mistakes salt for IV.\n\t * We deprecated the arguments for this method, but we decided\n\t * keeping this behaviour for backward compatibility.\n\t */\n\tVALUE cname  = rb_class_path(rb_obj_class(self));\n\trb_warn(\"arguments for %\"PRIsVALUE\"#encrypt and %\"PRIsVALUE\"#decrypt were deprecated; \"\n                \"use %\"PRIsVALUE\"#pkcs5_keyivgen to derive key and IV\",\n                cname, cname, cname);\n\tStringValue(pass);\n\tGetCipher(self, ctx);\n\tif (NIL_P(init_v)) memcpy(iv, \"OpenSSL for Ruby rulez!\", sizeof(iv));\n\telse{\n\t    StringValue(init_v);\n\t    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {\n\t\tmemset(iv, 0, EVP_MAX_IV_LENGTH);\n\t\tmemcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));\n\t    }\n\t    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));\n\t}\n\tEVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,\n\t\t       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);\n\tp_key = key;\n\tp_iv = iv;\n    }\n    else {\n\tGetCipher(self, ctx);\n    }\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {\n\tossl_raise(eCipherError, NULL);\n    }\n\n    if (p_key)\n\trb_ivar_set(self, id_key_set, Qtrue);\n\n    return self;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,5 +39,8 @@\n \tossl_raise(eCipherError, NULL);\n     }\n \n+    if (p_key)\n+\trb_ivar_set(self, id_key_set, Qtrue);\n+\n     return self;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (p_key)",
                "\trb_ivar_set(self, id_key_set, Qtrue);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27208",
        "func_name": "solokeys/solo1/flash_option_bytes_init",
        "description": "The flash read-out protection (RDP) level is not enforced during the device initialization phase of the SoloKeys Solo 4.0.0 & Somu and the Nitrokey FIDO2 token. This allows an adversary to downgrade the RDP level and access secrets such as private ECC keys from SRAM via the debug interface.",
        "git_url": "https://github.com/solokeys/solo1/commit/a9c02cd354f34b48195a342c7f524abdef5cbcec",
        "commit_title": "patches to improve resistance to fault injection",
        "commit_text": "",
        "func_before": "void flash_option_bytes_init(int boot_from_dfu)\n{\n    uint32_t val = 0xfffff8aa;\n\n    if (boot_from_dfu){\n        val &= ~(1<<27); // nBOOT0 = 0  (boot from system rom)\n    }\n    else {\n        if (solo_is_locked())\n        {\n            val = 0xfffff8cc;\n        }\n    }\n\n    val &= ~(1<<26); // nSWBOOT0 = 0  (boot from nBoot0)\n    val &= ~(1<<25); // SRAM2_RST = 1 (erase sram on reset)\n    val &= ~(1<<24); // SRAM2_PE = 1 (parity check en)\n\n    if (FLASH->OPTR == val)\n    {\n        return;\n    }\n\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n    if (FLASH->CR & (1<<30))\n    {\n        FLASH->OPTKEYR = 0x08192A3B;\n        FLASH->OPTKEYR = 0x4C5D6E7F;\n    }\n\n    FLASH->OPTR =val;\n    FLASH->CR |= (1<<17);\n\n    while (FLASH->SR & (1<<16))\n        ;\n\n    flash_lock();\n\n    __enable_irq();\n}",
        "func": "void flash_option_bytes_init(int boot_from_dfu)\n{\n    uint32_t val = 0xfffff8aa;\n\n    if (boot_from_dfu){\n        val &= ~(1<<27); // nBOOT0 = 0  (boot from system rom)\n    }\n    else {\n        if (solo_is_locked())\n        {\n            val = 0xfffff8cc;\n        }\n    }\n\n    val &= ~(1<<26); // nSWBOOT0 = 0  (boot from nBoot0)\n    val &= ~(1<<25); // SRAM2_RST = 1 (erase sram on reset)\n    val &= ~(1<<24); // SRAM2_PE = 1 (parity check en)\n\n    if (FLASH->OPTR == val)\n    {\n        return;\n    }\n\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n    if (FLASH->CR & (1<<30))\n    {\n        FLASH->OPTKEYR = 0x08192A3B;\n        FLASH->OPTKEYR = 0x4C5D6E7F;\n    }\n\n    FLASH->OPTR =val;\n    FLASH->CR |= (1<<17);\n\n    while (FLASH->SR & (1<<16))\n        ;\n\n    flash_lock();\n\n\n    /* Perform option byte loading which triggers a device reset. */\n    FLASH->CR |= FLASH_CR_OBL_LAUNCH;\n\n    while (true);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,5 +39,9 @@\n \n     flash_lock();\n \n-    __enable_irq();\n+\n+    /* Perform option byte loading which triggers a device reset. */\n+    FLASH->CR |= FLASH_CR_OBL_LAUNCH;\n+\n+    while (true);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    __enable_irq();"
            ],
            "added_lines": [
                "",
                "    /* Perform option byte loading which triggers a device reset. */",
                "    FLASH->CR |= FLASH_CR_OBL_LAUNCH;",
                "",
                "    while (true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27208",
        "func_name": "solokeys/solo1/device_init",
        "description": "The flash read-out protection (RDP) level is not enforced during the device initialization phase of the SoloKeys Solo 4.0.0 & Somu and the Nitrokey FIDO2 token. This allows an adversary to downgrade the RDP level and access secrets such as private ECC keys from SRAM via the debug interface.",
        "git_url": "https://github.com/solokeys/solo1/commit/a9c02cd354f34b48195a342c7f524abdef5cbcec",
        "commit_title": "patches to improve resistance to fault injection",
        "commit_text": "",
        "func_before": "void device_init()\n{\n\n    hw_init(LOW_FREQUENCY);\n\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n\n    device_migrate();\n\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n\n\n}",
        "func": "void device_init()\n{\n\n    hw_init(LOW_FREQUENCY);\n\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n\n    device_migrate();\n\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,12 @@\n {\n \n     hw_init(LOW_FREQUENCY);\n+\n+#if BOOT_TO_DFU\n+    flash_option_bytes_init(1);\n+#else\n+    flash_option_bytes_init(0);\n+#endif\n \n     if (! tsc_sensor_exists())\n     {\n@@ -28,11 +34,5 @@\n \n     device_migrate();\n \n-#if BOOT_TO_DFU\n-    flash_option_bytes_init(1);\n-#else\n-    flash_option_bytes_init(0);\n-#endif\n-\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "#if BOOT_TO_DFU",
                "    flash_option_bytes_init(1);",
                "#else",
                "    flash_option_bytes_init(0);",
                "#endif",
                ""
            ],
            "added_lines": [
                "",
                "#if BOOT_TO_DFU",
                "    flash_option_bytes_init(1);",
                "#else",
                "    flash_option_bytes_init(0);",
                "#endif"
            ]
        }
    }
]