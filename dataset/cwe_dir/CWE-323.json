[
    {
        "cve_id": "CVE-2023-28997",
        "func_name": "nextcloud/desktop/PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived",
        "description": "The Nextcloud Desktop Client is a tool to synchronize files from Nextcloud Server. Starting with version 3.0.0 and prior to version 3.6.5, a malicious server administrator can recover and modify the contents of end-to-end encrypted files. Users should upgrade the Nextcloud Desktop client to 3.6.5 to receive a patch. No known workarounds are available.",
        "git_url": "https://github.com/nextcloud/desktop/commit/75fd1d21be5ae03834209bc1fcf9fb8221b97e7b",
        "commit_title": "Always generate random initialization vector when uploading encrypted file.",
        "commit_text": "",
        "func_before": "void PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived(const QJsonDocument &json, int statusCode)\n{\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata Received, Preparing it for the new file.\" << json.toVariant();\n\n  // Encrypt File!\n  _metadata.reset(new FolderMetadata(_propagator->account(), json.toJson(QJsonDocument::Compact), statusCode));\n\n  if (!_metadata->isMetadataSetup()) {\n      if (_isFolderLocked) {\n          connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n          unlockFolder();\n      } else {\n          emit error();\n      }\n      return;\n  }\n\n  QFileInfo info(_propagator->fullLocalPath(_item->_file));\n  const QString fileName = info.fileName();\n\n  // Find existing metadata for this file\n  bool found = false;\n  EncryptedFile encryptedFile;\n  const QVector<EncryptedFile> files = _metadata->files();\n\n  for(const EncryptedFile &file : files) {\n    if (file.originalFilename == fileName) {\n      encryptedFile = file;\n      found = true;\n    }\n  }\n\n\n\n  // New encrypted file so set it all up!\n  if (!found) {\n      encryptedFile.encryptionKey = EncryptionHelper::generateRandom(16);\n      encryptedFile.encryptedFilename = EncryptionHelper::generateRandomFilename();\n      encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);\n      encryptedFile.fileVersion = 1;\n      encryptedFile.metadataKey = 1;\n      encryptedFile.originalFilename = fileName;\n\n      QMimeDatabase mdb;\n      encryptedFile.mimetype = mdb.mimeTypeForFile(info).name().toLocal8Bit();\n\n      // Other clients expect \"httpd/unix-directory\" instead of \"inode/directory\"\n      // Doesn't matter much for us since we don't do much about that mimetype anyway\n      if (encryptedFile.mimetype == QByteArrayLiteral(\"inode/directory\")) {\n          encryptedFile.mimetype = QByteArrayLiteral(\"httpd/unix-directory\");\n      }\n  }\n\n  _item->_encryptedFileName = _remoteParentPath + QLatin1Char('/') + encryptedFile.encryptedFilename;\n  _item->_isEncrypted = true;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the encrypted file.\";\n\n  if (info.isDir()) {\n      _completeFileName = encryptedFile.encryptedFilename;\n  } else {\n      QFile input(info.absoluteFilePath());\n      QFile output(QDir::tempPath() + QDir::separator() + encryptedFile.encryptedFilename);\n\n      QByteArray tag;\n      bool encryptionResult = EncryptionHelper::fileEncryption(\n        encryptedFile.encryptionKey,\n        encryptedFile.initializationVector,\n        &input, &output, tag);\n\n      if (!encryptionResult) {\n        qCDebug(lcPropagateUploadEncrypted()) << \"There was an error encrypting the file, aborting upload.\";\n        connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n        unlockFolder();\n        return;\n      }\n\n      encryptedFile.authenticationTag = tag;\n      _completeFileName = output.fileName();\n  }\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the metadata for the encrypted file.\";\n\n  _metadata->addEncryptedFile(encryptedFile);\n  _encryptedFile = encryptedFile;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata created, sending to the server.\";\n\n  if (statusCode == 404) {\n    auto job = new StoreMetaDataApiJob(_propagator->account(),\n                                       _folderId,\n                                       _metadata->encryptedMetadata());\n    connect(job, &StoreMetaDataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &StoreMetaDataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  } else {\n    auto job = new UpdateMetadataApiJob(_propagator->account(),\n                                      _folderId,\n                                      _metadata->encryptedMetadata(),\n                                      _folderToken);\n\n    connect(job, &UpdateMetadataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &UpdateMetadataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  }\n}",
        "func": "void PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived(const QJsonDocument &json, int statusCode)\n{\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata Received, Preparing it for the new file.\" << json.toVariant();\n\n  // Encrypt File!\n  _metadata.reset(new FolderMetadata(_propagator->account(), json.toJson(QJsonDocument::Compact), statusCode));\n\n  if (!_metadata->isMetadataSetup()) {\n      if (_isFolderLocked) {\n          connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n          unlockFolder();\n      } else {\n          emit error();\n      }\n      return;\n  }\n\n  QFileInfo info(_propagator->fullLocalPath(_item->_file));\n  const QString fileName = info.fileName();\n\n  // Find existing metadata for this file\n  bool found = false;\n  EncryptedFile encryptedFile;\n  const QVector<EncryptedFile> files = _metadata->files();\n\n  for(const EncryptedFile &file : files) {\n    if (file.originalFilename == fileName) {\n      encryptedFile = file;\n      found = true;\n    }\n  }\n\n\n\n  // New encrypted file so set it all up!\n  if (!found) {\n      encryptedFile.encryptionKey = EncryptionHelper::generateRandom(16);\n      encryptedFile.encryptedFilename = EncryptionHelper::generateRandomFilename();\n      encryptedFile.fileVersion = 1;\n      encryptedFile.metadataKey = 1;\n      encryptedFile.originalFilename = fileName;\n\n      QMimeDatabase mdb;\n      encryptedFile.mimetype = mdb.mimeTypeForFile(info).name().toLocal8Bit();\n\n      // Other clients expect \"httpd/unix-directory\" instead of \"inode/directory\"\n      // Doesn't matter much for us since we don't do much about that mimetype anyway\n      if (encryptedFile.mimetype == QByteArrayLiteral(\"inode/directory\")) {\n          encryptedFile.mimetype = QByteArrayLiteral(\"httpd/unix-directory\");\n      }\n  }\n  \n  encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);\n\n  _item->_encryptedFileName = _remoteParentPath + QLatin1Char('/') + encryptedFile.encryptedFilename;\n  _item->_isEncrypted = true;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the encrypted file.\";\n\n  if (info.isDir()) {\n      _completeFileName = encryptedFile.encryptedFilename;\n  } else {\n      QFile input(info.absoluteFilePath());\n      QFile output(QDir::tempPath() + QDir::separator() + encryptedFile.encryptedFilename);\n\n      QByteArray tag;\n      bool encryptionResult = EncryptionHelper::fileEncryption(\n        encryptedFile.encryptionKey,\n        encryptedFile.initializationVector,\n        &input, &output, tag);\n\n      if (!encryptionResult) {\n        qCDebug(lcPropagateUploadEncrypted()) << \"There was an error encrypting the file, aborting upload.\";\n        connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error);\n        unlockFolder();\n        return;\n      }\n\n      encryptedFile.authenticationTag = tag;\n      _completeFileName = output.fileName();\n  }\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Creating the metadata for the encrypted file.\";\n\n  _metadata->addEncryptedFile(encryptedFile);\n  _encryptedFile = encryptedFile;\n\n  qCDebug(lcPropagateUploadEncrypted) << \"Metadata created, sending to the server.\";\n\n  if (statusCode == 404) {\n    auto job = new StoreMetaDataApiJob(_propagator->account(),\n                                       _folderId,\n                                       _metadata->encryptedMetadata());\n    connect(job, &StoreMetaDataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &StoreMetaDataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  } else {\n    auto job = new UpdateMetadataApiJob(_propagator->account(),\n                                      _folderId,\n                                      _metadata->encryptedMetadata(),\n                                      _folderToken);\n\n    connect(job, &UpdateMetadataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess);\n    connect(job, &UpdateMetadataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError);\n    job->start();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,6 @@\n   if (!found) {\n       encryptedFile.encryptionKey = EncryptionHelper::generateRandom(16);\n       encryptedFile.encryptedFilename = EncryptionHelper::generateRandomFilename();\n-      encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);\n       encryptedFile.fileVersion = 1;\n       encryptedFile.metadataKey = 1;\n       encryptedFile.originalFilename = fileName;\n@@ -50,6 +49,8 @@\n           encryptedFile.mimetype = QByteArrayLiteral(\"httpd/unix-directory\");\n       }\n   }\n+  \n+  encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);\n \n   _item->_encryptedFileName = _remoteParentPath + QLatin1Char('/') + encryptedFile.encryptedFilename;\n   _item->_isEncrypted = true;",
        "diff_line_info": {
            "deleted_lines": [
                "      encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);"
            ],
            "added_lines": [
                "  ",
                "  encryptedFile.initializationVector = EncryptionHelper::generateRandom(16);"
            ]
        }
    }
]