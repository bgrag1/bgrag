[
    {
        "cve_id": "CVE-2017-14170",
        "func_name": "ffmpeg/mxf_read_index_entry_array",
        "description": "In libavformat/mxfdec.c in FFmpeg 3.3.3 -> 2.4, a DoS in mxf_read_index_entry_array() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted MXF file, which claims a large \"nb_index_entries\" field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU resources, since there is no EOF check inside the loop. Moreover, this big loop can be invoked multiple times if there is more than one applicable data segment in the crafted MXF file.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/900f39692ca0337a98a7cf047e4e2611071810c2",
        "commit_title": "avformat/mxfdec: Fix DoS issues in mxf_read_index_entry_array()",
        "commit_text": "  Co-Author: 张洪亮(望初)\" <wangchu.zhl@alibaba-inc.com>",
        "func_before": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}",
        "func": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n     segment->nb_index_entries = avio_rb32(pb);\n \n     length = avio_rb32(pb);\n+    if(segment->nb_index_entries && length < 11)\n+        return AVERROR_INVALIDDATA;\n \n     if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n         !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n@@ -15,6 +17,8 @@\n     }\n \n     for (i = 0; i < segment->nb_index_entries; i++) {\n+        if(avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n         segment->temporal_offset_entries[i] = avio_r8(pb);\n         avio_r8(pb);                                        /* KeyFrameOffset */\n         segment->flag_entries[i] = avio_r8(pb);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if(segment->nb_index_entries && length < 11)",
                "        return AVERROR_INVALIDDATA;",
                "        if(avio_feof(pb))",
                "            return AVERROR_INVALIDDATA;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14171",
        "func_name": "ffmpeg/nsv_parse_NSVf_header",
        "description": "In libavformat/nsvdec.c in FFmpeg 2.4 and 3.3.3, a DoS in nsv_parse_NSVf_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted NSV file, which claims a large \"table_entries_used\" field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/c24bcb553650b91e9eff15ef6e54ca73de2453b7",
        "commit_title": "avformat/nsvdec: Fix DoS due to lack of eof check in nsvs_file_offset loop.",
        "commit_text": "  Co-Author: 张洪亮(望初)\" <wangchu.zhl@alibaba-inc.com>",
        "func_before": "static int nsv_parse_NSVf_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int av_unused file_size;\n    unsigned int size;\n    int64_t duration;\n    int strings_size;\n    int table_entries;\n    int table_entries_used;\n\n    nsv->state = NSV_UNSYNC; /* in case we fail */\n\n    size = avio_rl32(pb);\n    if (size < 28)\n        return -1;\n    nsv->NSVf_end = size;\n\n    file_size = (uint32_t)avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf chunk_size %u\\n\", size);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf file_size %u\\n\", file_size);\n\n    nsv->duration = duration = avio_rl32(pb); /* in ms */\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf duration %\"PRId64\" ms\\n\", duration);\n    // XXX: store it in AVStreams\n\n    strings_size = avio_rl32(pb);\n    table_entries = avio_rl32(pb);\n    table_entries_used = avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\",\n            strings_size, table_entries, table_entries_used);\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got header; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (strings_size > 0) {\n        char *strings; /* last byte will be '\\0' to play safe with str*() */\n        char *p, *endp;\n        char *token, *value;\n        char quote;\n\n        p = strings = av_mallocz((size_t)strings_size + 1);\n        if (!p)\n            return AVERROR(ENOMEM);\n        endp = strings + strings_size;\n        avio_read(pb, strings, strings_size);\n        while (p < endp) {\n            while (*p == ' ')\n                p++; /* strip out spaces */\n            if (p >= endp-2)\n                break;\n            token = p;\n            p = strchr(p, '=');\n            if (!p || p >= endp-2)\n                break;\n            *p++ = '\\0';\n            quote = *p++;\n            value = p;\n            p = strchr(p, quote);\n            if (!p || p >= endp)\n                break;\n            *p++ = '\\0';\n            av_log(s, AV_LOG_TRACE, \"NSV NSVf INFO: %s='%s'\\n\", token, value);\n            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got infos; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n        if (!nsv->nsvs_file_offset)\n            return AVERROR(ENOMEM);\n\n        for(i=0;i<table_entries_used;i++)\n            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n\n        if(table_entries > table_entries_used &&\n           avio_rl32(pb) == MKTAG('T','O','C','2')) {\n            nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n            if (!nsv->nsvs_timestamps)\n                return AVERROR(ENOMEM);\n            for(i=0;i<table_entries_used;i++) {\n                nsv->nsvs_timestamps[i] = avio_rl32(pb);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_TRACE, \"NSV got index; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */\n\n    if (avio_feof(pb))\n        return -1;\n    nsv->state = NSV_HAS_READ_NSVF;\n    return 0;\n}",
        "func": "static int nsv_parse_NSVf_header(AVFormatContext *s)\n{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int av_unused file_size;\n    unsigned int size;\n    int64_t duration;\n    int strings_size;\n    int table_entries;\n    int table_entries_used;\n\n    nsv->state = NSV_UNSYNC; /* in case we fail */\n\n    size = avio_rl32(pb);\n    if (size < 28)\n        return -1;\n    nsv->NSVf_end = size;\n\n    file_size = (uint32_t)avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf chunk_size %u\\n\", size);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf file_size %u\\n\", file_size);\n\n    nsv->duration = duration = avio_rl32(pb); /* in ms */\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf duration %\"PRId64\" ms\\n\", duration);\n    // XXX: store it in AVStreams\n\n    strings_size = avio_rl32(pb);\n    table_entries = avio_rl32(pb);\n    table_entries_used = avio_rl32(pb);\n    av_log(s, AV_LOG_TRACE, \"NSV NSVf info-strings size: %d, table entries: %d, bis %d\\n\",\n            strings_size, table_entries, table_entries_used);\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got header; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (strings_size > 0) {\n        char *strings; /* last byte will be '\\0' to play safe with str*() */\n        char *p, *endp;\n        char *token, *value;\n        char quote;\n\n        p = strings = av_mallocz((size_t)strings_size + 1);\n        if (!p)\n            return AVERROR(ENOMEM);\n        endp = strings + strings_size;\n        avio_read(pb, strings, strings_size);\n        while (p < endp) {\n            while (*p == ' ')\n                p++; /* strip out spaces */\n            if (p >= endp-2)\n                break;\n            token = p;\n            p = strchr(p, '=');\n            if (!p || p >= endp-2)\n                break;\n            *p++ = '\\0';\n            quote = *p++;\n            value = p;\n            p = strchr(p, quote);\n            if (!p || p >= endp)\n                break;\n            *p++ = '\\0';\n            av_log(s, AV_LOG_TRACE, \"NSV NSVf INFO: %s='%s'\\n\", token, value);\n            av_dict_set(&s->metadata, token, value, 0);\n        }\n        av_free(strings);\n    }\n    if (avio_feof(pb))\n        return -1;\n\n    av_log(s, AV_LOG_TRACE, \"NSV got infos; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    if (table_entries_used > 0) {\n        int i;\n        nsv->index_entries = table_entries_used;\n        if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t))\n            return -1;\n        nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n        if (!nsv->nsvs_file_offset)\n            return AVERROR(ENOMEM);\n\n        for(i=0;i<table_entries_used;i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n            nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n        }\n\n        if(table_entries > table_entries_used &&\n           avio_rl32(pb) == MKTAG('T','O','C','2')) {\n            nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t));\n            if (!nsv->nsvs_timestamps)\n                return AVERROR(ENOMEM);\n            for(i=0;i<table_entries_used;i++) {\n                nsv->nsvs_timestamps[i] = avio_rl32(pb);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_TRACE, \"NSV got index; filepos %\"PRId64\"\\n\", avio_tell(pb));\n\n    avio_seek(pb, nsv->base_offset + size, SEEK_SET); /* required for dumbdriving-271.nsv (2 extra bytes) */\n\n    if (avio_feof(pb))\n        return -1;\n    nsv->state = NSV_HAS_READ_NSVF;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,8 +80,11 @@\n         if (!nsv->nsvs_file_offset)\n             return AVERROR(ENOMEM);\n \n-        for(i=0;i<table_entries_used;i++)\n+        for(i=0;i<table_entries_used;i++) {\n+            if (avio_feof(pb))\n+                return AVERROR_INVALIDDATA;\n             nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n+        }\n \n         if(table_entries > table_entries_used &&\n            avio_rl32(pb) == MKTAG('T','O','C','2')) {",
        "diff_line_info": {
            "deleted_lines": [
                "        for(i=0;i<table_entries_used;i++)"
            ],
            "added_lines": [
                "        for(i=0;i<table_entries_used;i++) {",
                "            if (avio_feof(pb))",
                "                return AVERROR_INVALIDDATA;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14172",
        "func_name": "ImageMagick/ReadPSImage",
        "description": "In coders/ps.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSImage() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large \"extent\" field in the header but does not contain sufficient backing data, is provided, the loop over \"length\" would consume huge CPU resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/bdbbb13f1fe9b7e2465502c500561720f7456aac",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/715",
        "commit_text": "",
        "func_before": "static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"BoundingBox:\"\n#define BeginDocument  \"BeginDocument:\"\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define ICCProfile \"BeginICCProfile:\"\n#define CMYKCustomColor  \"CMYKCustomColor:\"\n#define CMYKProcessColor  \"CMYKProcessColor:\"\n#define DocumentMedia  \"DocumentMedia:\"\n#define DocumentCustomColors  \"DocumentCustomColors:\"\n#define DocumentProcessColors  \"DocumentProcessColors:\"\n#define EndDocument  \"EndDocument:\"\n#define HiResBoundingBox  \"HiResBoundingBox:\"\n#define ImageData  \"ImageData:\"\n#define PageBoundingBox  \"PageBoundingBox:\"\n#define LanguageLevel  \"LanguageLevel:\"\n#define PageMedia  \"PageMedia:\"\n#define Pages  \"Pages:\"\n#define PhotoshopProfile  \"BeginPhotoshop:\"\n#define PostscriptLevel  \"!PS-\"\n#define RenderPostscriptText  \"  Rendering Postscript...  \"\n#define SpotColor  \"+ \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    priority;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) ResetMagickMemory(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution=image->resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));\n  (void) ResetMagickMemory(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) ResetMagickMemory(&hires_bounds,0,sizeof(hires_bounds));\n  columns=0;\n  rows=0;\n  priority=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  pages=(~0UL);\n  skip=MagickFalse;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4,exception);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MagickPathExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\"icc\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *q;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \" %lu\",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n        profile=BlobToStringInfo((const void *) NULL,length);\n        if (profile != (StringInfo *) NULL)\n          {\n            q=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *q++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\"8bim\",profile,exception);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,i+1);\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,i);\n        (void) SetImageProfile(image,\"xmp\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\"*Cyan*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Magenta*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Yellow*\",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MagickPathExtent],\n          *value;\n\n        register char\n          *q;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\"ps:SpotColor-%.20g\",\n          (double) (spotcolor++));\n        for (q=command; *q != '\\0'; q++)\n          if (isspace((int) (unsigned char) *q) != 0)\n            break;\n        value=AcquireString(q);\n        (void) SubstituteString(&value,\"(\",\"\");\n        (void) SubstituteString(&value,\")\",\"\");\n        (void) StripString(value);\n        (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i ==  (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) && \n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"ps:HiResBoundingBox\",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"eps:fit-page\");\n  if (option != (char *) NULL)\n  {\n    char\n      *page_geometry;\n\n    page_geometry=GetPageGeometry(option);\n    flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n      &page.height);\n    if (flags == NoValue)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"InvalidGeometry\",\"`%s'\",option);\n        image=DestroyImage(image);\n        return((Image *) NULL);\n      }\n    page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n      -0.5);\n    page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n      delta.y) -0.5);\n    page_geometry=DestroyString(page_geometry);\n    fitPage=MagickTrue;\n  }\n  (void) CloseBlob(image);\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\"/setpagedevice {pop} bind 1 index where {\"\n    \"dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\"\n    \"<</UseCIEColor true>>setpagedevice\\n\",MagickPathExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MagickPathExtent];\n\n      (void) FormatLocaleString(translate_geometry,MagickPathExtent,\n        \"%g %g translate\\n\",-bounds.x1,-bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g \",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\"eps:use-cropbox\");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\"-dEPSCrop \",MagickPathExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",MagickPathExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename,exception);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\" -c showpage\",MagickPathExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          DelegateError,\"PostscriptDelegateFailed\",\"`%s'\",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,\n      MagickPathExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MagickPathExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}",
        "func": "static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"BoundingBox:\"\n#define BeginDocument  \"BeginDocument:\"\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define ICCProfile \"BeginICCProfile:\"\n#define CMYKCustomColor  \"CMYKCustomColor:\"\n#define CMYKProcessColor  \"CMYKProcessColor:\"\n#define DocumentMedia  \"DocumentMedia:\"\n#define DocumentCustomColors  \"DocumentCustomColors:\"\n#define DocumentProcessColors  \"DocumentProcessColors:\"\n#define EndDocument  \"EndDocument:\"\n#define HiResBoundingBox  \"HiResBoundingBox:\"\n#define ImageData  \"ImageData:\"\n#define PageBoundingBox  \"PageBoundingBox:\"\n#define LanguageLevel  \"LanguageLevel:\"\n#define PageMedia  \"PageMedia:\"\n#define Pages  \"Pages:\"\n#define PhotoshopProfile  \"BeginPhotoshop:\"\n#define PostscriptLevel  \"!PS-\"\n#define RenderPostscriptText  \"  Rendering Postscript...  \"\n#define SpotColor  \"+ \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    priority;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) ResetMagickMemory(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution=image->resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));\n  (void) ResetMagickMemory(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) ResetMagickMemory(&hires_bounds,0,sizeof(hires_bounds));\n  columns=0;\n  rows=0;\n  priority=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  pages=(~0UL);\n  skip=MagickFalse;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4,exception);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MagickPathExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\"icc\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *q;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \" %lu\",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        profile=BlobToStringInfo((const void *) NULL,length);\n        if (profile != (StringInfo *) NULL)\n          {\n            q=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *q++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\"8bim\",profile,exception);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,i+1);\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,i);\n        (void) SetImageProfile(image,\"xmp\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\"*Cyan*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Magenta*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Yellow*\",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MagickPathExtent],\n          *value;\n\n        register char\n          *q;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\n          \"ps:SpotColor-%.20g\",(double) (spotcolor++));\n        for (q=command; *q != '\\0'; q++)\n          if (isspace((int) (unsigned char) *q) != 0)\n            break;\n        value=AcquireString(q);\n        (void) SubstituteString(&value,\"(\",\"\");\n        (void) SubstituteString(&value,\")\",\"\");\n        (void) StripString(value);\n        (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i ==  (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) && \n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"ps:HiResBoundingBox\",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"eps:fit-page\");\n  if (option != (char *) NULL)\n  {\n    char\n      *page_geometry;\n\n    page_geometry=GetPageGeometry(option);\n    flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n      &page.height);\n    if (flags == NoValue)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"InvalidGeometry\",\"`%s'\",option);\n        image=DestroyImage(image);\n        return((Image *) NULL);\n      }\n    page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n      -0.5);\n    page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n      delta.y) -0.5);\n    page_geometry=DestroyString(page_geometry);\n    fitPage=MagickTrue;\n  }\n  (void) CloseBlob(image);\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\"/setpagedevice {pop} bind 1 index where {\"\n    \"dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\"\n    \"<</UseCIEColor true>>setpagedevice\\n\",MagickPathExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MagickPathExtent];\n\n      (void) FormatLocaleString(translate_geometry,MagickPathExtent,\n        \"%g %g translate\\n\",-bounds.x1,-bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g \",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\"eps:use-cropbox\");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\"-dEPSCrop \",MagickPathExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",\n          MagickPathExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename,exception);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\" -c showpage\",MagickPathExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          DelegateError,\"PostscriptDelegateFailed\",\"`%s'\",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,\n      MagickPathExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MagickPathExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -264,6 +264,8 @@\n         if (count != 1)\n           continue;\n         length=extent;\n+        if (length > GetBlobSize(image))\n+          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         profile=BlobToStringInfo((const void *) NULL,length);\n         if (profile != (StringInfo *) NULL)\n           {\n@@ -331,8 +333,8 @@\n         /*\n           Note spot names.\n         */\n-        (void) FormatLocaleString(property,MagickPathExtent,\"ps:SpotColor-%.20g\",\n-          (double) (spotcolor++));\n+        (void) FormatLocaleString(property,MagickPathExtent,\n+          \"ps:SpotColor-%.20g\",(double) (spotcolor++));\n         for (q=command; *q != '\\0'; q++)\n           if (isspace((int) (unsigned char) *q) != 0)\n             break;\n@@ -502,7 +504,8 @@\n           (IsStringTrue(option) != MagickFalse))\n         (void) ConcatenateMagickString(options,\"-dEPSCrop \",MagickPathExtent);\n       if (fitPage != MagickFalse)\n-        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",MagickPathExtent);\n+        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",\n+          MagickPathExtent);\n     }\n   (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n   (void) AcquireUniqueFilename(filename);",
        "diff_line_info": {
            "deleted_lines": [
                "        (void) FormatLocaleString(property,MagickPathExtent,\"ps:SpotColor-%.20g\",",
                "          (double) (spotcolor++));",
                "        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",MagickPathExtent);"
            ],
            "added_lines": [
                "        if (length > GetBlobSize(image))",
                "          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");",
                "        (void) FormatLocaleString(property,MagickPathExtent,",
                "          \"ps:SpotColor-%.20g\",(double) (spotcolor++));",
                "        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",",
                "          MagickPathExtent);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14172",
        "func_name": "ImageMagick/RegisterPSImage",
        "description": "In coders/ps.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSImage() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large \"extent\" field in the header but does not contain sufficient backing data, is provided, the loop over \"length\" would consume huge CPU resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/bdbbb13f1fe9b7e2465502c500561720f7456aac",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/715",
        "commit_text": "",
        "func_before": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "func": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   entry->flags^=CoderAdjoinFlag;\n   entry->flags^=CoderBlobSupportFlag;\n   entry->mime_type=ConstantString(\"application/postscript\");\n@@ -16,6 +17,7 @@\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   entry->flags^=CoderAdjoinFlag;\n   entry->flags^=CoderBlobSupportFlag;\n   entry->mime_type=ConstantString(\"application/postscript\");\n@@ -24,6 +26,7 @@\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   entry->flags^=CoderAdjoinFlag;\n   entry->flags^=CoderBlobSupportFlag;\n   entry->mime_type=ConstantString(\"application/postscript\");\n@@ -33,6 +36,7 @@\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   entry->flags^=CoderAdjoinFlag;\n   entry->flags^=CoderBlobSupportFlag;\n   entry->mime_type=ConstantString(\"application/postscript\");\n@@ -42,6 +46,7 @@\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->mime_type=ConstantString(\"application/postscript\");\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   entry->flags^=CoderBlobSupportFlag;\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  entry->flags|=CoderDecoderSeekableStreamFlag;",
                "  entry->flags|=CoderDecoderSeekableStreamFlag;",
                "  entry->flags|=CoderDecoderSeekableStreamFlag;",
                "  entry->flags|=CoderDecoderSeekableStreamFlag;",
                "  entry->flags|=CoderDecoderSeekableStreamFlag;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14174",
        "func_name": "ImageMagick/ReadPSDLayersInternal",
        "description": "In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large \"length\" field in the header but does not contain sufficient backing data, is provided, the loop over \"length\" would consume huge CPU resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/f68a98a9d385838a1c73ec960a14102949940a64",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/714",
        "commit_text": "",
        "func_before": "static MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->matte=MagickTrue;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                if (length > GetBlobSize(image))\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"InsufficientImageDataInFile\",image->filename);\n                  }\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}",
        "func": "static MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->matte=MagickTrue;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (EOFBlob(image) != MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"InsufficientImageDataInFile\",image->filename);\n                    }\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                if (length > GetBlobSize(image))\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"InsufficientImageDataInFile\",image->filename);\n                  }\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -223,6 +223,12 @@\n                 {\n                   size_t blend_source=ReadBlobLong(image);\n                   size_t blend_dest=ReadBlobLong(image);\n+                  if (EOFBlob(image) != MagickFalse)\n+                    {\n+                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n+                      ThrowBinaryException(CorruptImageError,\n+                        \"InsufficientImageDataInFile\",image->filename);\n+                    }\n                   if (image->debug != MagickFalse)\n                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"        source(%x), dest(%x)\",(unsigned int)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                  if (EOFBlob(image) != MagickFalse)",
                "                    {",
                "                      layer_info=DestroyLayerInfo(layer_info,number_layers);",
                "                      ThrowBinaryException(CorruptImageError,",
                "                        \"InsufficientImageDataInFile\",image->filename);",
                "                    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14174",
        "func_name": "ImageMagick/ReadPSDLayersInternal",
        "description": "In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large \"length\" field in the header but does not contain sufficient backing data, is provided, the loop over \"length\" would consume huge CPU resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/04a567494786d5bb50894fc8bb8fea0cf496bea8",
        "commit_title": "Slightly different fix for #714",
        "commit_text": "",
        "func_before": "static MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->alpha_trait=BlendPixelTrait;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double)\n                    layer_info[i].mask.page.width,(double)\n                    layer_info[i].mask.page.height,(double) ((MagickOffsetType)\n                    length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (EOFBlob(image) != MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"InsufficientImageDataInFile\",image->filename);\n                    }\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                if (length > GetBlobSize(image))\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"InsufficientImageDataInFile\",image->filename);\n                  }\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) || (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info,exception);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}",
        "func": "static MagickBooleanType ReadPSDLayersInternal(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->alpha_trait=BlendPixelTrait;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double)\n                    layer_info[i].mask.page.width,(double)\n                    layer_info[i].mask.page.height,(double) ((MagickOffsetType)\n                    length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            /*\n              Layer name.\n            */\n            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                if (length > GetBlobSize(image))\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"InsufficientImageDataInFile\",image->filename);\n                  }\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) || (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info,exception);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -217,24 +217,12 @@\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"      layer blending ranges: length=%.20g\",(double)\n                     ((MagickOffsetType) length));\n-                /*\n-                  We read it, but don't use it...\n-                */\n-                for (j=0; j < (ssize_t) length; j+=8)\n-                {\n-                  size_t blend_source=ReadBlobLong(image);\n-                  size_t blend_dest=ReadBlobLong(image);\n-                  if (EOFBlob(image) != MagickFalse)\n-                    {\n-                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n-                      ThrowBinaryException(CorruptImageError,\n-                        \"InsufficientImageDataInFile\",image->filename);\n-                    }\n-                  if (image->debug != MagickFalse)\n-                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n-                      \"        source(%x), dest(%x)\",(unsigned int)\n-                      blend_source,(unsigned int) blend_dest);\n-                }\n+                if (DiscardBlobBytes(image,length) == MagickFalse)\n+                  {\n+                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n+                    ThrowBinaryException(CorruptImageError,\n+                      \"UnexpectedEndOfFile\",image->filename);\n+                  }\n               }\n             /*\n               Layer name.",
        "diff_line_info": {
            "deleted_lines": [
                "                /*",
                "                  We read it, but don't use it...",
                "                */",
                "                for (j=0; j < (ssize_t) length; j+=8)",
                "                {",
                "                  size_t blend_source=ReadBlobLong(image);",
                "                  size_t blend_dest=ReadBlobLong(image);",
                "                  if (EOFBlob(image) != MagickFalse)",
                "                    {",
                "                      layer_info=DestroyLayerInfo(layer_info,number_layers);",
                "                      ThrowBinaryException(CorruptImageError,",
                "                        \"InsufficientImageDataInFile\",image->filename);",
                "                    }",
                "                  if (image->debug != MagickFalse)",
                "                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),",
                "                      \"        source(%x), dest(%x)\",(unsigned int)",
                "                      blend_source,(unsigned int) blend_dest);",
                "                }"
            ],
            "added_lines": [
                "                if (DiscardBlobBytes(image,length) == MagickFalse)",
                "                  {",
                "                    layer_info=DestroyLayerInfo(layer_info,number_layers);",
                "                    ThrowBinaryException(CorruptImageError,",
                "                      \"UnexpectedEndOfFile\",image->filename);",
                "                  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14174",
        "func_name": "ImageMagick/ReadPSDChannel",
        "description": "In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large \"length\" field in the header but does not contain sufficient backing data, is provided, the loop over \"length\" would consume huge CPU resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/04a567494786d5bb50894fc8bb8fea0cf496bea8",
        "commit_title": "Slightly different fix for #714",
        "commit_text": "",
        "func_before": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if ((layer_info->channel_info[channel].type < -1) &&\n      (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))\n    {\n      const char\n        *option;\n\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n      {\n        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n        return(MagickTrue);\n      }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          SetImageType(mask,GrayscaleType,exception);\n          channel_image=mask;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickFalse;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}",
        "func": "static MagickBooleanType ReadPSDChannel(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,\n  const size_t channel,const PSDCompressionType compression,\n  ExceptionInfo *exception)\n{\n  Image\n    *channel_image,\n    *mask;\n\n  MagickOffsetType\n    offset;\n\n  MagickBooleanType\n    status;\n\n  channel_image=image;\n  mask=(Image *) NULL;\n  if ((layer_info->channel_info[channel].type < -1) &&\n      (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))\n    {\n      const char\n        *option;\n\n      /*\n        Ignore mask that is not a user supplied layer mask, if the mask is\n        disabled or if the flags have unsupported values.\n      */\n      option=GetImageOption(image_info,\"psd:preserve-opacity-mask\");\n      if ((layer_info->channel_info[channel].type != -2) ||\n          (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n           (IsStringTrue(option) == MagickFalse)))\n        {\n          SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n          return(MagickTrue);\n        }\n      mask=CloneImage(image,layer_info->mask.page.width,\n        layer_info->mask.page.height,MagickFalse,exception);\n      if (mask != (Image *) NULL)\n        {\n          SetImageType(mask,GrayscaleType,exception);\n          channel_image=mask;\n        }\n    }\n\n  offset=TellBlob(image);\n  status=MagickFalse;\n  switch(compression)\n  {\n    case Raw:\n      status=ReadPSDChannelRaw(channel_image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception);\n      break;\n    case RLE:\n      {\n        MagickOffsetType\n          *sizes;\n\n        sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);\n        if (sizes == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(channel_image,psd_info,\n          layer_info->channel_info[channel].type,sizes,exception);\n        sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(channel_image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n  if (status == MagickFalse)\n    {\n      if (mask != (Image *) NULL)\n        DestroyImage(mask);\n      ThrowBinaryException(CoderError,\"UnableToDecompressImage\",\n        image->filename);\n    }\n  layer_info->mask.image=mask;\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,10 +29,10 @@\n       if ((layer_info->channel_info[channel].type != -2) ||\n           (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n            (IsStringTrue(option) == MagickFalse)))\n-      {\n-        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n-        return(MagickTrue);\n-      }\n+        {\n+          SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n+          return(MagickTrue);\n+        }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n       if (mask != (Image *) NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "      {",
                "        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);",
                "        return(MagickTrue);",
                "      }"
            ],
            "added_lines": [
                "        {",
                "          SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);",
                "          return(MagickTrue);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14175",
        "func_name": "ImageMagick/XBMInteger",
        "description": "In coders/xbm.c in ImageMagick 7.0.6-1 Q16, a DoS in ReadXBMImage() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted XBM file, which claims large rows and columns fields in the header but does not contain sufficient backing data, is provided, the loop over the rows would consume huge CPU resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/712",
        "commit_text": "",
        "func_before": "static unsigned int XBMInteger(Image *image,short int *hex_digits)\n{ \n  int\n    c;\n  \n  unsigned int\n    value;\n  \n  /*\n    Skip any leading whitespace.\n  */\n  do\n  { \n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n  } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n  /*\n    Evaluate number.\n  */\n  value=0;\n  do\n  { \n    if (value > (unsigned int) (INT_MAX/10))\n      break;\n    value*=16;\n    c&=0xff;\n    if (value > (unsigned int) (INT_MAX-hex_digits[c]))\n      break;\n    value+=hex_digits[c];\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(0);\n  } while (hex_digits[c] >= 0);\n  return(value);\n}",
        "func": "static int XBMInteger(Image *image,short int *hex_digits)\n{ \n  int\n    c;\n  \n  unsigned int\n    value;\n  \n  /*\n    Skip any leading whitespace.\n  */\n  do\n  { \n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(-1);\n  } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n  /*\n    Evaluate number.\n  */\n  value=0;\n  do\n  { \n    if (value > (unsigned int) (INT_MAX/10))\n      break;\n    value*=16;\n    c&=0xff;\n    if (value > (unsigned int) (INT_MAX-hex_digits[c]))\n      break;\n    value+=hex_digits[c];\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      return(-1);\n  } while (hex_digits[c] >= 0);\n  return((int) value);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static unsigned int XBMInteger(Image *image,short int *hex_digits)\n+static int XBMInteger(Image *image,short int *hex_digits)\n { \n   int\n     c;\n@@ -13,7 +13,7 @@\n   { \n     c=ReadBlobByte(image);\n     if (c == EOF)\n-      return(0);\n+      return(-1);\n   } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n   /*\n     Evaluate number.\n@@ -30,7 +30,7 @@\n     value+=hex_digits[c];\n     c=ReadBlobByte(image);\n     if (c == EOF)\n-      return(0);\n+      return(-1);\n   } while (hex_digits[c] >= 0);\n-  return(value);\n+  return((int) value);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static unsigned int XBMInteger(Image *image,short int *hex_digits)",
                "      return(0);",
                "      return(0);",
                "  return(value);"
            ],
            "added_lines": [
                "static int XBMInteger(Image *image,short int *hex_digits)",
                "      return(-1);",
                "      return(-1);",
                "  return((int) value);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14175",
        "func_name": "ImageMagick/ReadXBMImage",
        "description": "In coders/xbm.c in ImageMagick 7.0.6-1 Q16, a DoS in ReadXBMImage() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted XBM file, which claims large rows and columns fields in the header but does not contain sufficient backing data, is provided, the loop over the rows would consume huge CPU resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/712",
        "commit_text": "",
        "func_before": "static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    name[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  short int\n    hex_digits[256];\n\n  ssize_t\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned int\n    bit,\n    byte,\n    bytes_per_line,\n    height,\n    length,\n    padding,\n    value,\n    version,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read X bitmap header.\n  */\n  width=0;\n  height=0;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\"#define %32s %u\",name,&width) == 2)\n      if ((strlen(name) >= 6) &&\n          (LocaleCompare(name+strlen(name)-6,\"_width\") == 0))\n        break;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\"#define %32s %u\",name,&height) == 2)\n      if ((strlen(name) >= 7) &&\n          (LocaleCompare(name+strlen(name)-7,\"_height\") == 0))\n        break;\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  image->colors=2;\n  /*\n    Scan until hex digits.\n  */\n  version=11;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n  {\n    if (sscanf(buffer,\"static short %32s = {\",name) == 1)\n      version=10;\n    else\n      if (sscanf(buffer,\"static unsigned char %32s = {\",name) == 1)\n        version=11;\n      else\n        if (sscanf(buffer,\"static char %32s = {\",name) == 1)\n          version=11;\n        else\n          continue;\n    p=(unsigned char *) strrchr(name,'_');\n    if (p == (unsigned char *) NULL)\n      p=(unsigned char *) name;\n    else\n      p++;\n    if (LocaleCompare(\"bits[]\",(char *) p) == 0)\n      break;\n  }\n  if ((image->columns == 0) || (image->rows == 0) ||\n      (EOFBlob(image) != MagickFalse))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Initialize colormap.\n  */\n  image->colormap[0].red=QuantumRange;\n  image->colormap[0].green=QuantumRange;\n  image->colormap[0].blue=QuantumRange;\n  image->colormap[1].red=(Quantum) 0;\n  image->colormap[1].green=(Quantum) 0;\n  image->colormap[1].blue=(Quantum) 0;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Initialize hex values.\n  */\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'x']=0;\n  hex_digits[(int) ' ']=(-1);\n  hex_digits[(int) ',']=(-1);\n  hex_digits[(int) '}']=(-1);\n  hex_digits[(int) '\\n']=(-1);\n  hex_digits[(int) '\\t']=(-1);\n  /*\n    Read hex image data.\n  */\n  padding=0;\n  if (((image->columns % 16) != 0) && ((image->columns % 16) < 9) &&\n      (version == 10))\n    padding=1;\n  bytes_per_line=(unsigned int) (image->columns+7)/8+padding;\n  length=(unsigned int) image->rows;\n  data=(unsigned char *) AcquireQuantumMemory(length,bytes_per_line*\n    sizeof(*data));\n  if (data == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  p=data;\n  if (version == 10)\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))\n    {\n      value=XBMInteger(image,hex_digits);\n      *p++=(unsigned char) value;\n      if ((padding == 0) || (((i+2) % bytes_per_line) != 0))\n        *p++=(unsigned char) (value >> 8);\n    }\n  else\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)\n    {\n      value=XBMInteger(image,hex_digits);\n      *p++=(unsigned char) value;\n    }\n  /*\n    Convert X bitmap image to pixel packets.\n  */\n  p=data;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (bit == 0)\n        byte=(size_t) (*p++);\n      SetPixelIndex(image,(Quantum) ((byte & 0x01) != 0 ? 0x01 : 0x00),q);\n      bit++;\n      byte>>=1;\n      if (bit == 8)\n        bit=0;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  data=(unsigned char *) RelinquishMagickMemory(data);\n  (void) SyncImage(image,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    name[MagickPathExtent];\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  short int\n    hex_digits[256];\n\n  ssize_t\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned int\n    bit,\n    byte,\n    bytes_per_line,\n    height,\n    length,\n    padding,\n    version,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read X bitmap header.\n  */\n  width=0;\n  height=0;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\"#define %32s %u\",name,&width) == 2)\n      if ((strlen(name) >= 6) &&\n          (LocaleCompare(name+strlen(name)-6,\"_width\") == 0))\n        break;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n    if (sscanf(buffer,\"#define %32s %u\",name,&height) == 2)\n      if ((strlen(name) >= 7) &&\n          (LocaleCompare(name+strlen(name)-7,\"_height\") == 0))\n        break;\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  image->colors=2;\n  /*\n    Scan until hex digits.\n  */\n  version=11;\n  while (ReadBlobString(image,buffer) != (char *) NULL)\n  {\n    if (sscanf(buffer,\"static short %32s = {\",name) == 1)\n      version=10;\n    else\n      if (sscanf(buffer,\"static unsigned char %32s = {\",name) == 1)\n        version=11;\n      else\n        if (sscanf(buffer,\"static char %32s = {\",name) == 1)\n          version=11;\n        else\n          continue;\n    p=(unsigned char *) strrchr(name,'_');\n    if (p == (unsigned char *) NULL)\n      p=(unsigned char *) name;\n    else\n      p++;\n    if (LocaleCompare(\"bits[]\",(char *) p) == 0)\n      break;\n  }\n  if ((image->columns == 0) || (image->rows == 0) ||\n      (EOFBlob(image) != MagickFalse))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Initialize colormap.\n  */\n  image->colormap[0].red=(MagickRealType) QuantumRange;\n  image->colormap[0].green=(MagickRealType) QuantumRange;\n  image->colormap[0].blue=(MagickRealType) QuantumRange;\n  image->colormap[1].red=0.0;\n  image->colormap[1].green=0.0;\n  image->colormap[1].blue=0.0;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Initialize hex values.\n  */\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'x']=0;\n  hex_digits[(int) ' ']=(-1);\n  hex_digits[(int) ',']=(-1);\n  hex_digits[(int) '}']=(-1);\n  hex_digits[(int) '\\n']=(-1);\n  hex_digits[(int) '\\t']=(-1);\n  /*\n    Read hex image data.\n  */\n  padding=0;\n  if (((image->columns % 16) != 0) && ((image->columns % 16) < 9) &&\n      (version == 10))\n    padding=1;\n  bytes_per_line=(unsigned int) (image->columns+7)/8+padding;\n  length=(unsigned int) image->rows;\n  data=(unsigned char *) AcquireQuantumMemory(length,bytes_per_line*\n    sizeof(*data));\n  if (data == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  p=data;\n  if (version == 10)\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))\n    {\n      c=XBMInteger(image,hex_digits);\n      if (c < 0)\n        break;\n      *p++=(unsigned char) c;\n      if ((padding == 0) || (((i+2) % bytes_per_line) != 0))\n        *p++=(unsigned char) (c >> 8);\n    }\n  else\n    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)\n    {\n      c=XBMInteger(image,hex_digits);\n      if (c < 0)\n        break;\n      *p++=(unsigned char) c;\n    }\n  if (EOFBlob(image) != MagickFalse)\n    {\n      data=(unsigned char *) RelinquishMagickMemory(data);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Convert X bitmap image to pixel packets.\n  */\n  p=data;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (bit == 0)\n        byte=(unsigned int) (*p++);\n      SetPixelIndex(image,(Quantum) ((byte & 0x01) != 0 ? 0x01 : 0x00),q);\n      bit++;\n      byte>>=1;\n      if (bit == 8)\n        bit=0;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  data=(unsigned char *) RelinquishMagickMemory(data);\n  (void) SyncImage(image,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,9 @@\n \n   Image\n     *image;\n+\n+  int\n+    c;\n \n   MagickBooleanType\n     status;\n@@ -36,7 +39,6 @@\n     height,\n     length,\n     padding,\n-    value,\n     version,\n     width;\n \n@@ -112,12 +114,12 @@\n   /*\n     Initialize colormap.\n   */\n-  image->colormap[0].red=QuantumRange;\n-  image->colormap[0].green=QuantumRange;\n-  image->colormap[0].blue=QuantumRange;\n-  image->colormap[1].red=(Quantum) 0;\n-  image->colormap[1].green=(Quantum) 0;\n-  image->colormap[1].blue=(Quantum) 0;\n+  image->colormap[0].red=(MagickRealType) QuantumRange;\n+  image->colormap[0].green=(MagickRealType) QuantumRange;\n+  image->colormap[0].blue=(MagickRealType) QuantumRange;\n+  image->colormap[1].red=0.0;\n+  image->colormap[1].green=0.0;\n+  image->colormap[1].blue=0.0;\n   if (image_info->ping != MagickFalse)\n     {\n       (void) CloseBlob(image);\n@@ -174,16 +176,25 @@\n   if (version == 10)\n     for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))\n     {\n-      value=XBMInteger(image,hex_digits);\n-      *p++=(unsigned char) value;\n+      c=XBMInteger(image,hex_digits);\n+      if (c < 0)\n+        break;\n+      *p++=(unsigned char) c;\n       if ((padding == 0) || (((i+2) % bytes_per_line) != 0))\n-        *p++=(unsigned char) (value >> 8);\n+        *p++=(unsigned char) (c >> 8);\n     }\n   else\n     for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)\n     {\n-      value=XBMInteger(image,hex_digits);\n-      *p++=(unsigned char) value;\n+      c=XBMInteger(image,hex_digits);\n+      if (c < 0)\n+        break;\n+      *p++=(unsigned char) c;\n+    }\n+  if (EOFBlob(image) != MagickFalse)\n+    {\n+      data=(unsigned char *) RelinquishMagickMemory(data);\n+      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n     }\n   /*\n     Convert X bitmap image to pixel packets.\n@@ -199,7 +210,7 @@\n     for (x=0; x < (ssize_t) image->columns; x++)\n     {\n       if (bit == 0)\n-        byte=(size_t) (*p++);\n+        byte=(unsigned int) (*p++);\n       SetPixelIndex(image,(Quantum) ((byte & 0x01) != 0 ? 0x01 : 0x00),q);\n       bit++;\n       byte>>=1;",
        "diff_line_info": {
            "deleted_lines": [
                "    value,",
                "  image->colormap[0].red=QuantumRange;",
                "  image->colormap[0].green=QuantumRange;",
                "  image->colormap[0].blue=QuantumRange;",
                "  image->colormap[1].red=(Quantum) 0;",
                "  image->colormap[1].green=(Quantum) 0;",
                "  image->colormap[1].blue=(Quantum) 0;",
                "      value=XBMInteger(image,hex_digits);",
                "      *p++=(unsigned char) value;",
                "        *p++=(unsigned char) (value >> 8);",
                "      value=XBMInteger(image,hex_digits);",
                "      *p++=(unsigned char) value;",
                "        byte=(size_t) (*p++);"
            ],
            "added_lines": [
                "",
                "  int",
                "    c;",
                "  image->colormap[0].red=(MagickRealType) QuantumRange;",
                "  image->colormap[0].green=(MagickRealType) QuantumRange;",
                "  image->colormap[0].blue=(MagickRealType) QuantumRange;",
                "  image->colormap[1].red=0.0;",
                "  image->colormap[1].green=0.0;",
                "  image->colormap[1].blue=0.0;",
                "      c=XBMInteger(image,hex_digits);",
                "      if (c < 0)",
                "        break;",
                "      *p++=(unsigned char) c;",
                "        *p++=(unsigned char) (c >> 8);",
                "      c=XBMInteger(image,hex_digits);",
                "      if (c < 0)",
                "        break;",
                "      *p++=(unsigned char) c;",
                "    }",
                "  if (EOFBlob(image) != MagickFalse)",
                "    {",
                "      data=(unsigned char *) RelinquishMagickMemory(data);",
                "      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");",
                "        byte=(unsigned int) (*p++);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14222",
        "func_name": "ffmpeg/read_tfra",
        "description": "In libavformat/mov.c in FFmpeg 3.3.3, a DoS in read_tfra() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MOV file, which claims a large \"item_count\" field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/9cb4eb772839c5e1de2855d126bf74ff16d13382",
        "commit_title": "avformat/mov: Fix DoS in read_tfra()",
        "commit_text": " No testcase ",
        "func_before": "static int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < index->item_count; i++) {\n        int64_t time, offset;\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}",
        "func": "static int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < index->item_count; i++) {\n        int64_t time, offset;\n\n        if (avio_feof(f)) {\n            index->item_count = 0;\n            av_freep(&index->items);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,13 @@\n     }\n     for (i = 0; i < index->item_count; i++) {\n         int64_t time, offset;\n+\n+        if (avio_feof(f)) {\n+            index->item_count = 0;\n+            av_freep(&index->items);\n+            return AVERROR_INVALIDDATA;\n+        }\n+\n         if (version == 1) {\n             time   = avio_rb64(f);\n             offset = avio_rb64(f);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        if (avio_feof(f)) {",
                "            index->item_count = 0;",
                "            av_freep(&index->items);",
                "            return AVERROR_INVALIDDATA;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-30226",
        "func_name": "rizinorg/rizin/get_gnu_verneed",
        "description": "An issue was discovered in function get_gnu_verneed in rizinorg Rizin prior to 0.5.0 verneed_entry allows attackers to cause a denial of service via crafted elf file.",
        "git_url": "https://github.com/rizinorg/rizin/commit/a6d89de0d44e776f9bccc3a168fdc79f604e14ed",
        "commit_title": "ELF: added vn_next break condition (#3214)",
        "commit_text": " if the dynamic section's verneednum mismatches the true number of entries then the for loop in get_gnu_verneed will continue to iterate on the last entry since vn_next will be 0 on the last entry. If verneednum is set to all 0xff's it will take a very long time to finish this loop naturally drastically hindering binary load time. The solution is simple, to check for when vn_next == 0 and break out of the loop since all entries have been iterated over regardless of what verneednum indicates.",
        "func_before": "static Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(sdb_version);\n\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\n\treturn sdb;\n}",
        "func": "static Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsdb_free(sdb_version);\n\n\t\tif (!verneed_entry.vn_next) {\n\t\t\tbreak;\n\t\t}\n\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\n\treturn sdb;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,6 +46,10 @@\n \n \t\tsdb_free(sdb_version);\n \n+\t\tif (!verneed_entry.vn_next) {\n+\t\t\tbreak;\n+\t\t}\n+\n \t\tverneed_offset += verneed_entry.vn_next;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (!verneed_entry.vn_next) {",
                "\t\t\tbreak;",
                "\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3817",
        "func_name": "openssl/DH_check",
        "description": "Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=9002fd07327a91f35ba6c1307e71fa6fd4409b7f",
        "commit_title": "",
        "commit_text": "DH_check(): Do not try checking q properties if it is obviously invalid  If  |q| >= |p| then the q value is obviously wrong as q is supposed to be a prime divisor of p-1.  We check if p is overly large so this added test implies that q is not large either when performing subsequent tests using that q value.  Otherwise if it is too large these additional checks of the q value such as the primality test can then trigger DoS by doing overly long computations.  Fixes CVE-2023-3817  (Merged from https://github.com/openssl/openssl/pull/21550)  (cherry picked from commit 1c16253f3c3a8d1e25918c3f404aae6a5b0893de) (cherry picked from commit 6a1eb62c29db6cb5eec707f9338aee00f44e26f5) ",
        "func_before": "int DH_check(const DH *dh, int *ret)\n{\n#ifdef FIPS_MODULE\n    return DH_check_params(dh, ret);\n#else\n    int ok = 0, r;\n    BN_CTX *ctx = NULL;\n    BIGNUM *t1 = NULL, *t2 = NULL;\n    int nid = DH_get_nid((DH *)dh);\n\n    *ret = 0;\n    if (nid != NID_undef)\n        return 1;\n\n    /* Don't do any checks at all with an excessively large modulus */\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;\n        return 0;\n    }\n\n    if (!DH_check_params(dh, ret))\n        return 0;\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (dh->params.q != NULL) {\n        if (BN_cmp(dh->params.g, BN_value_one()) <= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else if (BN_cmp(dh->params.g, dh->params.p) >= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else {\n            /* Check g^q == 1 mod p */\n            if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))\n                goto err;\n            if (!BN_is_one(t1))\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n        }\n        r = BN_check_prime(dh->params.q, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n        if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))\n            goto err;\n        if (!BN_is_one(t2))\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n        if (dh->params.j != NULL\n            && BN_cmp(dh->params.j, t1))\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n    }\n\n    r = BN_check_prime(dh->params.p, ctx, NULL);\n    if (r < 0)\n        goto err;\n    if (!r)\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    else if (dh->params.q == NULL) {\n        if (!BN_rshift1(t1, dh->params.p))\n            goto err;\n        r = BN_check_prime(t1, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n    }\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n#endif /* FIPS_MODULE */\n}",
        "func": "int DH_check(const DH *dh, int *ret)\n{\n#ifdef FIPS_MODULE\n    return DH_check_params(dh, ret);\n#else\n    int ok = 0, r, q_good = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *t1 = NULL, *t2 = NULL;\n    int nid = DH_get_nid((DH *)dh);\n\n    *ret = 0;\n    if (nid != NID_undef)\n        return 1;\n\n    /* Don't do any checks at all with an excessively large modulus */\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;\n        return 0;\n    }\n\n    if (!DH_check_params(dh, ret))\n        return 0;\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (dh->params.q != NULL) {\n        if (BN_ucmp(dh->params.p, dh->params.q) > 0)\n            q_good = 1;\n        else\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n    }\n\n    if (q_good) {\n        if (BN_cmp(dh->params.g, BN_value_one()) <= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else if (BN_cmp(dh->params.g, dh->params.p) >= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else {\n            /* Check g^q == 1 mod p */\n            if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))\n                goto err;\n            if (!BN_is_one(t1))\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n        }\n        r = BN_check_prime(dh->params.q, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n        if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))\n            goto err;\n        if (!BN_is_one(t2))\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n        if (dh->params.j != NULL\n            && BN_cmp(dh->params.j, t1))\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n    }\n\n    r = BN_check_prime(dh->params.p, ctx, NULL);\n    if (r < 0)\n        goto err;\n    if (!r)\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    else if (dh->params.q == NULL) {\n        if (!BN_rshift1(t1, dh->params.p))\n            goto err;\n        r = BN_check_prime(t1, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n    }\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n#endif /* FIPS_MODULE */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n #ifdef FIPS_MODULE\n     return DH_check_params(dh, ret);\n #else\n-    int ok = 0, r;\n+    int ok = 0, r, q_good = 0;\n     BN_CTX *ctx = NULL;\n     BIGNUM *t1 = NULL, *t2 = NULL;\n     int nid = DH_get_nid((DH *)dh);\n@@ -32,6 +32,13 @@\n         goto err;\n \n     if (dh->params.q != NULL) {\n+        if (BN_ucmp(dh->params.p, dh->params.q) > 0)\n+            q_good = 1;\n+        else\n+            *ret |= DH_CHECK_INVALID_Q_VALUE;\n+    }\n+\n+    if (q_good) {\n         if (BN_cmp(dh->params.g, BN_value_one()) <= 0)\n             *ret |= DH_NOT_SUITABLE_GENERATOR;\n         else if (BN_cmp(dh->params.g, dh->params.p) >= 0)",
        "diff_line_info": {
            "deleted_lines": [
                "    int ok = 0, r;"
            ],
            "added_lines": [
                "    int ok = 0, r, q_good = 0;",
                "        if (BN_ucmp(dh->params.p, dh->params.q) > 0)",
                "            q_good = 1;",
                "        else",
                "            *ret |= DH_CHECK_INVALID_Q_VALUE;",
                "    }",
                "",
                "    if (q_good) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3817",
        "func_name": "openssl/DH_check",
        "description": "Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=6a1eb62c29db6cb5eec707f9338aee00f44e26f5",
        "commit_title": "",
        "commit_text": "DH_check(): Do not try checking q properties if it is obviously invalid  If  |q| >= |p| then the q value is obviously wrong as q is supposed to be a prime divisor of p-1.  We check if p is overly large so this added test implies that q is not large either when performing subsequent tests using that q value.  Otherwise if it is too large these additional checks of the q value such as the primality test can then trigger DoS by doing overly long computations.  Fixes CVE-2023-3817  (Merged from https://github.com/openssl/openssl/pull/21550)  (cherry picked from commit 1c16253f3c3a8d1e25918c3f404aae6a5b0893de) ",
        "func_before": "int DH_check(const DH *dh, int *ret)\n{\n#ifdef FIPS_MODULE\n    return DH_check_params(dh, ret);\n#else\n    int ok = 0, r;\n    BN_CTX *ctx = NULL;\n    BIGNUM *t1 = NULL, *t2 = NULL;\n    int nid = DH_get_nid((DH *)dh);\n\n    *ret = 0;\n    if (nid != NID_undef)\n        return 1;\n\n    /* Don't do any checks at all with an excessively large modulus */\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;\n        return 0;\n    }\n\n    if (!DH_check_params(dh, ret))\n        return 0;\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (dh->params.q != NULL) {\n        if (BN_cmp(dh->params.g, BN_value_one()) <= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else if (BN_cmp(dh->params.g, dh->params.p) >= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else {\n            /* Check g^q == 1 mod p */\n            if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))\n                goto err;\n            if (!BN_is_one(t1))\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n        }\n        r = BN_check_prime(dh->params.q, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n        if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))\n            goto err;\n        if (!BN_is_one(t2))\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n        if (dh->params.j != NULL\n            && BN_cmp(dh->params.j, t1))\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n    }\n\n    r = BN_check_prime(dh->params.p, ctx, NULL);\n    if (r < 0)\n        goto err;\n    if (!r)\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    else if (dh->params.q == NULL) {\n        if (!BN_rshift1(t1, dh->params.p))\n            goto err;\n        r = BN_check_prime(t1, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n    }\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n#endif /* FIPS_MODULE */\n}",
        "func": "int DH_check(const DH *dh, int *ret)\n{\n#ifdef FIPS_MODULE\n    return DH_check_params(dh, ret);\n#else\n    int ok = 0, r, q_good = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *t1 = NULL, *t2 = NULL;\n    int nid = DH_get_nid((DH *)dh);\n\n    *ret = 0;\n    if (nid != NID_undef)\n        return 1;\n\n    /* Don't do any checks at all with an excessively large modulus */\n    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);\n        *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;\n        return 0;\n    }\n\n    if (!DH_check_params(dh, ret))\n        return 0;\n\n    ctx = BN_CTX_new_ex(dh->libctx);\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (dh->params.q != NULL) {\n        if (BN_ucmp(dh->params.p, dh->params.q) > 0)\n            q_good = 1;\n        else\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n    }\n\n    if (q_good) {\n        if (BN_cmp(dh->params.g, BN_value_one()) <= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else if (BN_cmp(dh->params.g, dh->params.p) >= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else {\n            /* Check g^q == 1 mod p */\n            if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))\n                goto err;\n            if (!BN_is_one(t1))\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n        }\n        r = BN_check_prime(dh->params.q, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n        if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))\n            goto err;\n        if (!BN_is_one(t2))\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n        if (dh->params.j != NULL\n            && BN_cmp(dh->params.j, t1))\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n    }\n\n    r = BN_check_prime(dh->params.p, ctx, NULL);\n    if (r < 0)\n        goto err;\n    if (!r)\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    else if (dh->params.q == NULL) {\n        if (!BN_rshift1(t1, dh->params.p))\n            goto err;\n        r = BN_check_prime(t1, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n    }\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n#endif /* FIPS_MODULE */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n #ifdef FIPS_MODULE\n     return DH_check_params(dh, ret);\n #else\n-    int ok = 0, r;\n+    int ok = 0, r, q_good = 0;\n     BN_CTX *ctx = NULL;\n     BIGNUM *t1 = NULL, *t2 = NULL;\n     int nid = DH_get_nid((DH *)dh);\n@@ -32,6 +32,13 @@\n         goto err;\n \n     if (dh->params.q != NULL) {\n+        if (BN_ucmp(dh->params.p, dh->params.q) > 0)\n+            q_good = 1;\n+        else\n+            *ret |= DH_CHECK_INVALID_Q_VALUE;\n+    }\n+\n+    if (q_good) {\n         if (BN_cmp(dh->params.g, BN_value_one()) <= 0)\n             *ret |= DH_NOT_SUITABLE_GENERATOR;\n         else if (BN_cmp(dh->params.g, dh->params.p) >= 0)",
        "diff_line_info": {
            "deleted_lines": [
                "    int ok = 0, r;"
            ],
            "added_lines": [
                "    int ok = 0, r, q_good = 0;",
                "        if (BN_ucmp(dh->params.p, dh->params.q) > 0)",
                "            q_good = 1;",
                "        else",
                "            *ret |= DH_CHECK_INVALID_Q_VALUE;",
                "    }",
                "",
                "    if (q_good) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3817",
        "func_name": "openssl/DH_check",
        "description": "Issue summary: Checking excessively long DH keys or parameters may be very slow.\n\nImpact summary: Applications that use the functions DH_check(), DH_check_ex()\nor EVP_PKEY_param_check() to check a DH key or DH parameters may experience long\ndelays. Where the key or parameters that are being checked have been obtained\nfrom an untrusted source this may lead to a Denial of Service.\n\nThe function DH_check() performs various checks on DH parameters. After fixing\nCVE-2023-3446 it was discovered that a large q parameter value can also trigger\nan overly long computation during some of these checks. A correct q value,\nif present, cannot be larger than the modulus p parameter, thus it is\nunnecessary to perform these checks if q is larger than p.\n\nAn application that calls DH_check() and supplies a key or parameters obtained\nfrom an untrusted source could be vulnerable to a Denial of Service attack.\n\nThe function DH_check() is itself called by a number of other OpenSSL functions.\nAn application calling any of those other functions may similarly be affected.\nThe other functions affected by this are DH_check_ex() and\nEVP_PKEY_param_check().\n\nAlso vulnerable are the OpenSSL dhparam and pkeyparam command line applications\nwhen using the \"-check\" option.\n\nThe OpenSSL SSL/TLS implementation is not affected by this issue.\n\nThe OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=91ddeba0f2269b017dc06c46c993a788974b1aa5",
        "commit_title": "",
        "commit_text": "DH_check(): Do not try checking q properties if it is obviously invalid  If  |q| >= |p| then the q value is obviously wrong as q is supposed to be a prime divisor of p-1.  We check if p is overly large so this added test implies that q is not large either when performing subsequent tests using that q value.  Otherwise if it is too large these additional checks of the q value such as the primality test can then trigger DoS by doing overly long computations.  Fixes CVE-2023-3817  (Merged from https://github.com/openssl/openssl/pull/21551) ",
        "func_before": "int DH_check(const DH *dh, int *ret)\n{\n    int ok = 0, r;\n    BN_CTX *ctx = NULL;\n    BIGNUM *t1 = NULL, *t2 = NULL;\n\n    /* Don't do any checks at all with an excessively large modulus */\n    if (BN_num_bits(dh->p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {\n        DHerr(DH_F_DH_CHECK, DH_R_MODULUS_TOO_LARGE);\n        *ret = DH_CHECK_P_NOT_PRIME;\n        return 0;\n    }\n\n    if (!DH_check_params(dh, ret))\n        return 0;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (dh->q) {\n        if (BN_cmp(dh->g, BN_value_one()) <= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else if (BN_cmp(dh->g, dh->p) >= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else {\n            /* Check g^q == 1 mod p */\n            if (!BN_mod_exp(t1, dh->g, dh->q, dh->p, ctx))\n                goto err;\n            if (!BN_is_one(t1))\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n        }\n        r = BN_is_prime_ex(dh->q, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n        if (!BN_div(t1, t2, dh->p, dh->q, ctx))\n            goto err;\n        if (!BN_is_one(t2))\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n        if (dh->j && BN_cmp(dh->j, t1))\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n    }\n\n    r = BN_is_prime_ex(dh->p, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);\n    if (r < 0)\n        goto err;\n    if (!r)\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    else if (!dh->q) {\n        if (!BN_rshift1(t1, dh->p))\n            goto err;\n        r = BN_is_prime_ex(t1, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n    }\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n}",
        "func": "int DH_check(const DH *dh, int *ret)\n{\n    int ok = 0, r, q_good = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *t1 = NULL, *t2 = NULL;\n\n    /* Don't do any checks at all with an excessively large modulus */\n    if (BN_num_bits(dh->p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {\n        DHerr(DH_F_DH_CHECK, DH_R_MODULUS_TOO_LARGE);\n        *ret = DH_CHECK_P_NOT_PRIME;\n        return 0;\n    }\n\n    if (!DH_check_params(dh, ret))\n        return 0;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (dh->q != NULL) {\n        if (BN_ucmp(dh->p, dh->q) > 0)\n            q_good = 1;\n        else\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n    }\n\n    if (q_good) {\n        if (BN_cmp(dh->g, BN_value_one()) <= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else if (BN_cmp(dh->g, dh->p) >= 0)\n            *ret |= DH_NOT_SUITABLE_GENERATOR;\n        else {\n            /* Check g^q == 1 mod p */\n            if (!BN_mod_exp(t1, dh->g, dh->q, dh->p, ctx))\n                goto err;\n            if (!BN_is_one(t1))\n                *ret |= DH_NOT_SUITABLE_GENERATOR;\n        }\n        r = BN_is_prime_ex(dh->q, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_Q_NOT_PRIME;\n        /* Check p == 1 mod q  i.e. q divides p - 1 */\n        if (!BN_div(t1, t2, dh->p, dh->q, ctx))\n            goto err;\n        if (!BN_is_one(t2))\n            *ret |= DH_CHECK_INVALID_Q_VALUE;\n        if (dh->j && BN_cmp(dh->j, t1))\n            *ret |= DH_CHECK_INVALID_J_VALUE;\n    }\n\n    r = BN_is_prime_ex(dh->p, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);\n    if (r < 0)\n        goto err;\n    if (!r)\n        *ret |= DH_CHECK_P_NOT_PRIME;\n    else if (!dh->q) {\n        if (!BN_rshift1(t1, dh->p))\n            goto err;\n        r = BN_is_prime_ex(t1, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);\n        if (r < 0)\n            goto err;\n        if (!r)\n            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;\n    }\n    ok = 1;\n err:\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n int DH_check(const DH *dh, int *ret)\n {\n-    int ok = 0, r;\n+    int ok = 0, r, q_good = 0;\n     BN_CTX *ctx = NULL;\n     BIGNUM *t1 = NULL, *t2 = NULL;\n \n@@ -23,7 +23,14 @@\n     if (t2 == NULL)\n         goto err;\n \n-    if (dh->q) {\n+    if (dh->q != NULL) {\n+        if (BN_ucmp(dh->p, dh->q) > 0)\n+            q_good = 1;\n+        else\n+            *ret |= DH_CHECK_INVALID_Q_VALUE;\n+    }\n+\n+    if (q_good) {\n         if (BN_cmp(dh->g, BN_value_one()) <= 0)\n             *ret |= DH_NOT_SUITABLE_GENERATOR;\n         else if (BN_cmp(dh->g, dh->p) >= 0)",
        "diff_line_info": {
            "deleted_lines": [
                "    int ok = 0, r;",
                "    if (dh->q) {"
            ],
            "added_lines": [
                "    int ok = 0, r, q_good = 0;",
                "    if (dh->q != NULL) {",
                "        if (BN_ucmp(dh->p, dh->q) > 0)",
                "            q_good = 1;",
                "        else",
                "            *ret |= DH_CHECK_INVALID_Q_VALUE;",
                "    }",
                "",
                "    if (q_good) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/display_extension_block",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/2fd04b6ba9d830cd1324572530237b6fea58f96e",
        "commit_title": "bpv6: Fix possible infinite loop",
        "commit_text": " display_extension_block is supposed to return the current offset, not the number of bytes remaining. The number of bytes remaining can be less than the current offset and cause an infinite loop.  In the case of an error, set lastheader and return the current offset in order to break out of the main processing loop.  Fix #18711. ",
        "func_before": "static int\ndisplay_extension_block(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, gchar *bundle_custodian, gboolean *lastheader)\n{\n    proto_item   *block_item, *ti, *block_flag_replicate_item, *block_flag_eid_reference_item;\n    proto_tree   *block_tree;\n    int           sdnv_length;\n    int           block_length;\n    int           block_overhead;\n    int           bundle_age;\n    guint8        type;\n    unsigned int  control_flags;\n    proto_tree   *block_flag_tree;\n    proto_item   *block_flag_item;\n\n    type = tvb_get_guint8(tvb, offset);\n    block_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_metadata_hdr, &block_item, \"Extension Block\");\n\n    proto_tree_add_item(block_tree, hf_bundle_block_type_code, tvb, offset, 1, ENC_BIG_ENDIAN);\n    ++offset;\n    block_overhead = 1;\n\n    control_flags = (unsigned int)evaluate_sdnv(tvb, offset, &sdnv_length);\n    if (control_flags & BLOCK_CONTROL_LAST_BLOCK) {\n        *lastheader = TRUE;\n    } else {\n        *lastheader = FALSE;\n    }\n    block_flag_item = proto_tree_add_uint(block_tree, hf_block_control_flags_sdnv, tvb,\n                                            offset, sdnv_length, control_flags);\n    block_flag_tree = proto_item_add_subtree(block_flag_item, ett_block_flags);\n    block_flag_replicate_item = proto_tree_add_boolean(block_flag_tree, hf_block_control_replicate,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_transmit_status,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_delete_bundle,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_last_block,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_discard_block,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_not_processed,\n                           tvb, offset, sdnv_length, control_flags);\n    block_flag_eid_reference_item = proto_tree_add_boolean(block_flag_tree, hf_block_control_eid_reference,\n                           tvb, offset, sdnv_length, control_flags);\n    offset += sdnv_length;\n    block_overhead += sdnv_length;\n\n    /* TODO: if this block has EID references, add them to display tree */\n    if (control_flags & BLOCK_CONTROL_EID_REFERENCE) {\n        int i;\n        int num_eid_ref;\n\n        num_eid_ref = evaluate_sdnv(tvb, offset, &sdnv_length);\n        offset += sdnv_length;\n        block_overhead += sdnv_length;\n\n        for (i = 0; i < num_eid_ref; i++)\n        {\n            if (evaluate_sdnv(tvb, offset, &sdnv_length) < 0)\n                break;\n            offset += sdnv_length;\n            block_overhead += sdnv_length;\n\n            if (evaluate_sdnv(tvb, offset, &sdnv_length) < 0)\n                break;\n            offset += sdnv_length;\n            block_overhead += sdnv_length;\n        }\n    }\n\n    block_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n    ti = proto_tree_add_int(block_tree, hf_block_control_block_length, tvb, offset, sdnv_length, block_length);\n    if (block_length < 0) {\n        expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, \"Metadata Block Length Error\");\n        /* Force quitting */\n        *lastheader = TRUE;\n        return offset;\n    }\n    offset += sdnv_length;\n    block_overhead += sdnv_length;\n\n    /* now we have enough info to know total length of metadata block */\n    proto_item_set_len(block_item, block_overhead + block_length);\n\n    switch (type)\n    {\n    case BUNDLE_BLOCK_TYPE_AUTHENTICATION:\n    case BUNDLE_BLOCK_TYPE_METADATA_EXTENSION:\n    case BUNDLE_BLOCK_TYPE_EXTENSION_SECURITY:\n    {\n        proto_tree_add_string(block_tree, hf_bundle_unprocessed_block_data, tvb, offset, block_length, \"Block data\");\n        /* not yet dissected, skip past data */\n        offset += block_length;\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_BUNDLE_AGE:\n    {\n        bundle_age = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_age_extension_block_code, tvb, offset, sdnv_length, bundle_age/1000000);\n        offset += block_length;\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_PREVIOUS_HOP_INSERT:\n    {\n        int scheme_length;\n\n        proto_tree_add_item_ret_length(block_tree, hf_bundle_block_previous_hop_scheme, tvb, offset, 4, ENC_ASCII, &scheme_length);\n        offset += scheme_length;\n        proto_tree_add_item(block_tree, hf_bundle_block_previous_hop_eid, tvb, offset, block_length-scheme_length, ENC_ASCII);\n        if (block_length - scheme_length < 1) {\n            expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, \"Metadata Block Length Error\");\n            *lastheader = TRUE;\n            return offset;\n        }\n        offset += block_length - scheme_length;\n\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_INTEGRITY:\n    case BUNDLE_BLOCK_TYPE_CONFIDENTIALITY:\n    {\n        int target_block_type;\n        int target_block_occurrence;\n        int ciphersuite_type;\n        unsigned int ciphersuite_flags;\n\n        target_block_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_target_block_type, tvb, offset, sdnv_length, target_block_type);\n        offset += sdnv_length;\n\n        target_block_occurrence = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_target_block_occurrence, tvb, offset, sdnv_length, target_block_occurrence);\n        offset += sdnv_length;\n\n        ciphersuite_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_ciphersuite_type, tvb, offset, sdnv_length, ciphersuite_type);\n        offset += sdnv_length;\n\n        ciphersuite_flags = (unsigned int)evaluate_sdnv(tvb, offset, &sdnv_length);\n        block_flag_item = proto_tree_add_uint(block_tree, hf_bundle_ciphersuite_flags, tvb, offset, sdnv_length, ciphersuite_flags);\n        block_flag_tree = proto_item_add_subtree(block_flag_item, ett_block_flags);\n        proto_tree_add_boolean(block_flag_tree, hf_block_ciphersuite_params, tvb, offset, sdnv_length, ciphersuite_flags);\n        offset += sdnv_length;\n\n        int range_offset;\n        int range_length;\n        if (ciphersuite_flags & BLOCK_CIPHERSUITE_PARAMS) {\n            /* Decode cipher suite parameters */\n            int params_length;\n            int param_type;\n            int item_length;\n            proto_tree   *param_tree;\n            expert_field *ei = NULL;\n\n            params_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei);\n            if (ei) {\n                proto_tree_add_expert(block_tree, pinfo, ei, tvb, offset, -1);\n                *lastheader = TRUE;\n                return offset;\n            }\n            param_tree = proto_tree_add_subtree(block_tree, tvb, offset, params_length+1, ett_sec_block_param_data, NULL, \"Ciphersuite Parameters Data\");\n            proto_tree_add_int(param_tree, hf_block_ciphersuite_params_length, tvb, offset, sdnv_length, params_length);\n            offset += sdnv_length;\n\n            for(int i = 0; i < params_length; i+=item_length+2)\n            {\n                param_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n                proto_tree_add_int(param_tree, hf_block_ciphersuite_param_type, tvb, offset, sdnv_length, param_type);\n                offset += sdnv_length;\n\n                ei = NULL;\n                item_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei);\n                proto_tree_add_int(param_tree, hf_block_ciphersuite_params_item_length, tvb, offset, sdnv_length, item_length);\n                if (ei) {\n                    proto_tree_add_expert(param_tree, pinfo, ei, tvb, offset, -1);\n                    *lastheader = TRUE;\n                    return offset;\n                }\n\n                offset += sdnv_length;\n\n                //display item data\n                switch (param_type)\n                {\n                case 1:\n                case 3:\n                case 5:\n                case 7:\n                case 8:\n                    proto_tree_add_item(param_tree, hf_block_ciphersuite_param_data, tvb, offset, item_length, ENC_NA);\n                    offset += item_length;\n                    break;\n                case 4:\n                    //pair of sdnvs offset and length\n                    range_offset = evaluate_sdnv(tvb, offset, &sdnv_length);\n                    proto_tree_add_int(param_tree, hf_block_ciphersuite_range_offset, tvb, offset, sdnv_length, range_offset);\n                    offset += sdnv_length;\n\n                    range_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n                    proto_tree_add_int(param_tree, hf_block_ciphersuite_range_length, tvb, offset, sdnv_length, range_length);\n                    offset += sdnv_length;\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n        /* Decode cipher suite results */\n        int result_length;\n        int result_type;\n        int result_item_length;\n        proto_tree   *result_tree;\n\n        result_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n        result_tree = proto_tree_add_subtree(block_tree, tvb, offset, result_length+1, ett_sec_block_param_data, NULL, \"Security Results Data\");\n        proto_tree_add_int(result_tree, hf_block_ciphersuite_result_length, tvb, offset, sdnv_length, result_length);\n        offset += sdnv_length;\n\n        for(int i = 0; i < result_length; i+=result_item_length+2)\n        {\n            result_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n            proto_tree_add_int(result_tree, hf_block_ciphersuite_result_type, tvb, offset, sdnv_length, result_type);\n            offset += sdnv_length;\n\n            expert_field *ei = NULL;\n            result_item_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei);\n            proto_tree_add_int(result_tree, hf_block_ciphersuite_result_item_length, tvb, offset, sdnv_length, result_item_length);\n            if (ei) {\n                proto_tree_add_expert(result_tree, pinfo, ei, tvb, offset, -1);\n                offset = tvb_reported_length_remaining(tvb, offset);\n                break;\n            }\n            offset += sdnv_length;\n\n            //display item data\n            switch (result_type)\n            {\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n            case 8:\n                proto_tree_add_item(result_tree, hf_block_ciphersuite_result_data, tvb, offset, result_item_length, ENC_NA);\n                offset += result_item_length;\n                break;\n            case 4:\n                //pair of sdnvs offset and length\n                range_offset = evaluate_sdnv(tvb, offset, &sdnv_length);\n                proto_tree_add_int(result_tree, hf_block_ciphersuite_range_offset, tvb, offset, sdnv_length, range_offset);\n                offset += sdnv_length;\n\n                range_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n                proto_tree_add_int(result_tree, hf_block_ciphersuite_range_length, tvb, offset, sdnv_length, range_length);\n                offset += sdnv_length;\n                break;\n            default:\n                break;\n            }\n\n        }\n        break;\n\n    }\n    case BUNDLE_BLOCK_TYPE_CUSTODY_TRANSFER:\n    {\n        int custody_id;\n        const guint8 *cteb_creator_custodian_eid;\n        int cteb_creator_custodian_eid_length;\n\n        /* check requirements for Block Processing Control Flags */\n        if ((control_flags & BLOCK_CONTROL_REPLICATE) != 0) {\n            expert_add_info_format(pinfo, block_flag_replicate_item, &ei_bundle_block_control_flags, \"ERROR: Replicate must be clear for CTEB\");\n        }\n        if ((control_flags & BLOCK_CONTROL_EID_REFERENCE) != 0) {\n            expert_add_info_format(pinfo, block_flag_eid_reference_item, &ei_bundle_block_control_flags, \"ERROR: EID-Reference must be clear for CTEB\");\n        }\n\n        /* there are two elements in a CTEB, first is the custody ID */\n        custody_id = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_block_control_block_cteb_custody_id, tvb, offset, sdnv_length, custody_id);\n        offset += sdnv_length;\n\n        /* and second is the creator custodian EID */\n        if (block_length - sdnv_length < 1) {\n            expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, \"Metadata Block Length Error\");\n            *lastheader = TRUE;\n            return offset;\n        }\n        cteb_creator_custodian_eid_length = block_length - sdnv_length;\n        ti = proto_tree_add_item_ret_string(block_tree, hf_block_control_block_cteb_creator_custodian_eid, tvb, offset,\n                                cteb_creator_custodian_eid_length, ENC_ASCII, pinfo->pool, &cteb_creator_custodian_eid);\n\n        /* also check if CTEB is valid, i.e. custodians match */\n        if (bundle_custodian == NULL) {\n            expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid,\n                                \"CTEB Is NOT Valid (Bundle Custodian NULL)\");\n        }\n        else if (strlen(cteb_creator_custodian_eid) != strlen(bundle_custodian)) {\n            expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid,\n                                \"CTEB Is NOT Valid (Bundle Custodian [%s] != CTEB Custodian [%s])\",\n                                bundle_custodian, cteb_creator_custodian_eid);\n        }\n        else if (memcmp(cteb_creator_custodian_eid, bundle_custodian, strlen(bundle_custodian)) != 0) {\n            expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid,\n                                \"CTEB Is NOT Valid (Bundle Custodian [%s] != CTEB Custodian [%s])\",\n                                bundle_custodian, cteb_creator_custodian_eid);\n        }\n        else {\n            expert_add_info(pinfo, ti, &ei_block_control_block_cteb_valid);\n        }\n        offset += cteb_creator_custodian_eid_length;\n\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_EXTENDED_COS:\n    {\n        int flags;\n        static int * const ecos_flags_fields[] = {\n            &hf_ecos_flags_critical,\n            &hf_ecos_flags_streaming,\n            &hf_ecos_flags_flowlabel,\n            &hf_ecos_flags_reliable,\n            NULL\n        };\n\n        /* check requirements for Block Processing Control Flags */\n        if ((control_flags & BLOCK_CONTROL_REPLICATE) == 0) {\n            expert_add_info_format(pinfo, block_flag_replicate_item, &ei_bundle_block_control_flags, \"ERROR: Replicate must be set for ECOS\");\n        }\n        if ((control_flags & BLOCK_CONTROL_EID_REFERENCE) != 0) {\n            expert_add_info_format(pinfo, block_flag_eid_reference_item, &ei_bundle_block_control_flags, \"ERROR: EID-Reference must be clear for ECOS\");\n        }\n\n        /* flags byte */\n        flags = (int)tvb_get_guint8(tvb, offset);\n        proto_tree_add_bitmask(block_tree, tvb, offset, hf_ecos_flags, ett_block_flags, ecos_flags_fields, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* ordinal byte */\n        proto_tree_add_item(block_tree, hf_ecos_ordinal, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* optional flow label sdnv */\n        if ((flags & ECOS_FLAGS_FLOWLABEL) != 0) {\n            int flow_label;\n            flow_label = evaluate_sdnv(tvb, offset, &sdnv_length);\n            ti = proto_tree_add_int(block_tree, hf_ecos_flow_label, tvb, offset, sdnv_length, flow_label);\n            if (flow_label < 0) {\n                expert_add_info_format(pinfo, ti, &ei_bundle_sdnv_length, \"ECOS Flow Label Error\");\n                /* Force quitting */\n                *lastheader = TRUE;\n                return offset;\n            }\n            offset += sdnv_length;\n        }\n\n        break;\n    }\n    default:\n    {\n        proto_tree_add_string(block_tree, hf_bundle_unprocessed_block_data, tvb, offset, block_length, \"Block data\");\n        /* unknown bundle type, skip past data */\n        offset += block_length;\n        break;\n    }\n    }\n\n    return offset;\n}",
        "func": "static int\ndisplay_extension_block(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, gchar *bundle_custodian, gboolean *lastheader)\n{\n    proto_item   *block_item, *ti, *block_flag_replicate_item, *block_flag_eid_reference_item;\n    proto_tree   *block_tree;\n    int           sdnv_length;\n    int           block_length;\n    int           block_overhead;\n    int           bundle_age;\n    guint8        type;\n    unsigned int  control_flags;\n    proto_tree   *block_flag_tree;\n    proto_item   *block_flag_item;\n\n    type = tvb_get_guint8(tvb, offset);\n    block_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_metadata_hdr, &block_item, \"Extension Block\");\n\n    proto_tree_add_item(block_tree, hf_bundle_block_type_code, tvb, offset, 1, ENC_BIG_ENDIAN);\n    ++offset;\n    block_overhead = 1;\n\n    control_flags = (unsigned int)evaluate_sdnv(tvb, offset, &sdnv_length);\n    if (control_flags & BLOCK_CONTROL_LAST_BLOCK) {\n        *lastheader = TRUE;\n    } else {\n        *lastheader = FALSE;\n    }\n    block_flag_item = proto_tree_add_uint(block_tree, hf_block_control_flags_sdnv, tvb,\n                                            offset, sdnv_length, control_flags);\n    block_flag_tree = proto_item_add_subtree(block_flag_item, ett_block_flags);\n    block_flag_replicate_item = proto_tree_add_boolean(block_flag_tree, hf_block_control_replicate,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_transmit_status,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_delete_bundle,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_last_block,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_discard_block,\n                           tvb, offset, sdnv_length, control_flags);\n    proto_tree_add_boolean(block_flag_tree, hf_block_control_not_processed,\n                           tvb, offset, sdnv_length, control_flags);\n    block_flag_eid_reference_item = proto_tree_add_boolean(block_flag_tree, hf_block_control_eid_reference,\n                           tvb, offset, sdnv_length, control_flags);\n    offset += sdnv_length;\n    block_overhead += sdnv_length;\n\n    /* TODO: if this block has EID references, add them to display tree */\n    if (control_flags & BLOCK_CONTROL_EID_REFERENCE) {\n        int i;\n        int num_eid_ref;\n\n        num_eid_ref = evaluate_sdnv(tvb, offset, &sdnv_length);\n        offset += sdnv_length;\n        block_overhead += sdnv_length;\n\n        for (i = 0; i < num_eid_ref; i++)\n        {\n            if (evaluate_sdnv(tvb, offset, &sdnv_length) < 0)\n                break;\n            offset += sdnv_length;\n            block_overhead += sdnv_length;\n\n            if (evaluate_sdnv(tvb, offset, &sdnv_length) < 0)\n                break;\n            offset += sdnv_length;\n            block_overhead += sdnv_length;\n        }\n    }\n\n    block_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n    ti = proto_tree_add_int(block_tree, hf_block_control_block_length, tvb, offset, sdnv_length, block_length);\n    if (block_length < 0) {\n        expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, \"Metadata Block Length Error\");\n        /* Force quitting */\n        *lastheader = TRUE;\n        return offset;\n    }\n    offset += sdnv_length;\n    block_overhead += sdnv_length;\n\n    /* now we have enough info to know total length of metadata block */\n    proto_item_set_len(block_item, block_overhead + block_length);\n\n    switch (type)\n    {\n    case BUNDLE_BLOCK_TYPE_AUTHENTICATION:\n    case BUNDLE_BLOCK_TYPE_METADATA_EXTENSION:\n    case BUNDLE_BLOCK_TYPE_EXTENSION_SECURITY:\n    {\n        proto_tree_add_string(block_tree, hf_bundle_unprocessed_block_data, tvb, offset, block_length, \"Block data\");\n        /* not yet dissected, skip past data */\n        offset += block_length;\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_BUNDLE_AGE:\n    {\n        bundle_age = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_age_extension_block_code, tvb, offset, sdnv_length, bundle_age/1000000);\n        offset += block_length;\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_PREVIOUS_HOP_INSERT:\n    {\n        int scheme_length;\n\n        proto_tree_add_item_ret_length(block_tree, hf_bundle_block_previous_hop_scheme, tvb, offset, 4, ENC_ASCII, &scheme_length);\n        offset += scheme_length;\n        proto_tree_add_item(block_tree, hf_bundle_block_previous_hop_eid, tvb, offset, block_length-scheme_length, ENC_ASCII);\n        if (block_length - scheme_length < 1) {\n            expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, \"Metadata Block Length Error\");\n            *lastheader = TRUE;\n            return offset;\n        }\n        offset += block_length - scheme_length;\n\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_INTEGRITY:\n    case BUNDLE_BLOCK_TYPE_CONFIDENTIALITY:\n    {\n        int target_block_type;\n        int target_block_occurrence;\n        int ciphersuite_type;\n        unsigned int ciphersuite_flags;\n\n        target_block_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_target_block_type, tvb, offset, sdnv_length, target_block_type);\n        offset += sdnv_length;\n\n        target_block_occurrence = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_target_block_occurrence, tvb, offset, sdnv_length, target_block_occurrence);\n        offset += sdnv_length;\n\n        ciphersuite_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_bundle_ciphersuite_type, tvb, offset, sdnv_length, ciphersuite_type);\n        offset += sdnv_length;\n\n        ciphersuite_flags = (unsigned int)evaluate_sdnv(tvb, offset, &sdnv_length);\n        block_flag_item = proto_tree_add_uint(block_tree, hf_bundle_ciphersuite_flags, tvb, offset, sdnv_length, ciphersuite_flags);\n        block_flag_tree = proto_item_add_subtree(block_flag_item, ett_block_flags);\n        proto_tree_add_boolean(block_flag_tree, hf_block_ciphersuite_params, tvb, offset, sdnv_length, ciphersuite_flags);\n        offset += sdnv_length;\n\n        int range_offset;\n        int range_length;\n        if (ciphersuite_flags & BLOCK_CIPHERSUITE_PARAMS) {\n            /* Decode cipher suite parameters */\n            int params_length;\n            int param_type;\n            int item_length;\n            proto_tree   *param_tree;\n            expert_field *ei = NULL;\n\n            params_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei);\n            if (ei) {\n                proto_tree_add_expert(block_tree, pinfo, ei, tvb, offset, -1);\n                *lastheader = TRUE;\n                return offset;\n            }\n            param_tree = proto_tree_add_subtree(block_tree, tvb, offset, params_length+1, ett_sec_block_param_data, NULL, \"Ciphersuite Parameters Data\");\n            proto_tree_add_int(param_tree, hf_block_ciphersuite_params_length, tvb, offset, sdnv_length, params_length);\n            offset += sdnv_length;\n\n            for(int i = 0; i < params_length; i+=item_length+2)\n            {\n                param_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n                proto_tree_add_int(param_tree, hf_block_ciphersuite_param_type, tvb, offset, sdnv_length, param_type);\n                offset += sdnv_length;\n\n                ei = NULL;\n                item_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei);\n                proto_tree_add_int(param_tree, hf_block_ciphersuite_params_item_length, tvb, offset, sdnv_length, item_length);\n                if (ei) {\n                    proto_tree_add_expert(param_tree, pinfo, ei, tvb, offset, -1);\n                    *lastheader = TRUE;\n                    return offset;\n                }\n\n                offset += sdnv_length;\n\n                //display item data\n                switch (param_type)\n                {\n                case 1:\n                case 3:\n                case 5:\n                case 7:\n                case 8:\n                    proto_tree_add_item(param_tree, hf_block_ciphersuite_param_data, tvb, offset, item_length, ENC_NA);\n                    offset += item_length;\n                    break;\n                case 4:\n                    //pair of sdnvs offset and length\n                    range_offset = evaluate_sdnv(tvb, offset, &sdnv_length);\n                    proto_tree_add_int(param_tree, hf_block_ciphersuite_range_offset, tvb, offset, sdnv_length, range_offset);\n                    offset += sdnv_length;\n\n                    range_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n                    proto_tree_add_int(param_tree, hf_block_ciphersuite_range_length, tvb, offset, sdnv_length, range_length);\n                    offset += sdnv_length;\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n        /* Decode cipher suite results */\n        int result_length;\n        int result_type;\n        int result_item_length;\n        proto_tree   *result_tree;\n\n        result_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n        result_tree = proto_tree_add_subtree(block_tree, tvb, offset, result_length+1, ett_sec_block_param_data, NULL, \"Security Results Data\");\n        proto_tree_add_int(result_tree, hf_block_ciphersuite_result_length, tvb, offset, sdnv_length, result_length);\n        offset += sdnv_length;\n\n        for(int i = 0; i < result_length; i+=result_item_length+2)\n        {\n            result_type = evaluate_sdnv(tvb, offset, &sdnv_length);\n            proto_tree_add_int(result_tree, hf_block_ciphersuite_result_type, tvb, offset, sdnv_length, result_type);\n            offset += sdnv_length;\n\n            expert_field *ei = NULL;\n            result_item_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei);\n            proto_tree_add_int(result_tree, hf_block_ciphersuite_result_item_length, tvb, offset, sdnv_length, result_item_length);\n            if (ei) {\n                proto_tree_add_expert(result_tree, pinfo, ei, tvb, offset, -1);\n                *lastheader = TRUE;\n                return offset;\n            }\n            offset += sdnv_length;\n\n            //display item data\n            switch (result_type)\n            {\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n            case 8:\n                proto_tree_add_item(result_tree, hf_block_ciphersuite_result_data, tvb, offset, result_item_length, ENC_NA);\n                offset += result_item_length;\n                break;\n            case 4:\n                //pair of sdnvs offset and length\n                range_offset = evaluate_sdnv(tvb, offset, &sdnv_length);\n                proto_tree_add_int(result_tree, hf_block_ciphersuite_range_offset, tvb, offset, sdnv_length, range_offset);\n                offset += sdnv_length;\n\n                range_length = evaluate_sdnv(tvb, offset, &sdnv_length);\n                proto_tree_add_int(result_tree, hf_block_ciphersuite_range_length, tvb, offset, sdnv_length, range_length);\n                offset += sdnv_length;\n                break;\n            default:\n                break;\n            }\n\n        }\n        break;\n\n    }\n    case BUNDLE_BLOCK_TYPE_CUSTODY_TRANSFER:\n    {\n        int custody_id;\n        const guint8 *cteb_creator_custodian_eid;\n        int cteb_creator_custodian_eid_length;\n\n        /* check requirements for Block Processing Control Flags */\n        if ((control_flags & BLOCK_CONTROL_REPLICATE) != 0) {\n            expert_add_info_format(pinfo, block_flag_replicate_item, &ei_bundle_block_control_flags, \"ERROR: Replicate must be clear for CTEB\");\n        }\n        if ((control_flags & BLOCK_CONTROL_EID_REFERENCE) != 0) {\n            expert_add_info_format(pinfo, block_flag_eid_reference_item, &ei_bundle_block_control_flags, \"ERROR: EID-Reference must be clear for CTEB\");\n        }\n\n        /* there are two elements in a CTEB, first is the custody ID */\n        custody_id = evaluate_sdnv(tvb, offset, &sdnv_length);\n        proto_tree_add_int(block_tree, hf_block_control_block_cteb_custody_id, tvb, offset, sdnv_length, custody_id);\n        offset += sdnv_length;\n\n        /* and second is the creator custodian EID */\n        if (block_length - sdnv_length < 1) {\n            expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, \"Metadata Block Length Error\");\n            *lastheader = TRUE;\n            return offset;\n        }\n        cteb_creator_custodian_eid_length = block_length - sdnv_length;\n        ti = proto_tree_add_item_ret_string(block_tree, hf_block_control_block_cteb_creator_custodian_eid, tvb, offset,\n                                cteb_creator_custodian_eid_length, ENC_ASCII, pinfo->pool, &cteb_creator_custodian_eid);\n\n        /* also check if CTEB is valid, i.e. custodians match */\n        if (bundle_custodian == NULL) {\n            expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid,\n                                \"CTEB Is NOT Valid (Bundle Custodian NULL)\");\n        }\n        else if (strlen(cteb_creator_custodian_eid) != strlen(bundle_custodian)) {\n            expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid,\n                                \"CTEB Is NOT Valid (Bundle Custodian [%s] != CTEB Custodian [%s])\",\n                                bundle_custodian, cteb_creator_custodian_eid);\n        }\n        else if (memcmp(cteb_creator_custodian_eid, bundle_custodian, strlen(bundle_custodian)) != 0) {\n            expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid,\n                                \"CTEB Is NOT Valid (Bundle Custodian [%s] != CTEB Custodian [%s])\",\n                                bundle_custodian, cteb_creator_custodian_eid);\n        }\n        else {\n            expert_add_info(pinfo, ti, &ei_block_control_block_cteb_valid);\n        }\n        offset += cteb_creator_custodian_eid_length;\n\n        break;\n    }\n    case BUNDLE_BLOCK_TYPE_EXTENDED_COS:\n    {\n        int flags;\n        static int * const ecos_flags_fields[] = {\n            &hf_ecos_flags_critical,\n            &hf_ecos_flags_streaming,\n            &hf_ecos_flags_flowlabel,\n            &hf_ecos_flags_reliable,\n            NULL\n        };\n\n        /* check requirements for Block Processing Control Flags */\n        if ((control_flags & BLOCK_CONTROL_REPLICATE) == 0) {\n            expert_add_info_format(pinfo, block_flag_replicate_item, &ei_bundle_block_control_flags, \"ERROR: Replicate must be set for ECOS\");\n        }\n        if ((control_flags & BLOCK_CONTROL_EID_REFERENCE) != 0) {\n            expert_add_info_format(pinfo, block_flag_eid_reference_item, &ei_bundle_block_control_flags, \"ERROR: EID-Reference must be clear for ECOS\");\n        }\n\n        /* flags byte */\n        flags = (int)tvb_get_guint8(tvb, offset);\n        proto_tree_add_bitmask(block_tree, tvb, offset, hf_ecos_flags, ett_block_flags, ecos_flags_fields, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* ordinal byte */\n        proto_tree_add_item(block_tree, hf_ecos_ordinal, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n\n        /* optional flow label sdnv */\n        if ((flags & ECOS_FLAGS_FLOWLABEL) != 0) {\n            int flow_label;\n            flow_label = evaluate_sdnv(tvb, offset, &sdnv_length);\n            ti = proto_tree_add_int(block_tree, hf_ecos_flow_label, tvb, offset, sdnv_length, flow_label);\n            if (flow_label < 0) {\n                expert_add_info_format(pinfo, ti, &ei_bundle_sdnv_length, \"ECOS Flow Label Error\");\n                /* Force quitting */\n                *lastheader = TRUE;\n                return offset;\n            }\n            offset += sdnv_length;\n        }\n\n        break;\n    }\n    default:\n    {\n        proto_tree_add_string(block_tree, hf_bundle_unprocessed_block_data, tvb, offset, block_length, \"Block data\");\n        /* unknown bundle type, skip past data */\n        offset += block_length;\n        break;\n    }\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -227,8 +227,8 @@\n             proto_tree_add_int(result_tree, hf_block_ciphersuite_result_item_length, tvb, offset, sdnv_length, result_item_length);\n             if (ei) {\n                 proto_tree_add_expert(result_tree, pinfo, ei, tvb, offset, -1);\n-                offset = tvb_reported_length_remaining(tvb, offset);\n-                break;\n+                *lastheader = TRUE;\n+                return offset;\n             }\n             offset += sdnv_length;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                offset = tvb_reported_length_remaining(tvb, offset);",
                "                break;"
            ],
            "added_lines": [
                "                *lastheader = TRUE;",
                "                return offset;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/dissect_parametrized_serialized_data",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static void dissect_parametrized_serialized_data(proto_tree *tree, tvbuff_t *tvb,\n                       gint offset_input, int size, const guint encoding)\n{\n  guint32 member_id, member_length;\n  proto_item * ti;\n  proto_tree * data_tree, * member_tree;\n  gint offset = offset_input;\n  gint deserialized_size = 0;\n  data_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,\n          ett_rtps_serialized_data, &ti, \"serializedData\");\n  while (deserialized_size < size) {\n    ALIGN_ZERO(offset, 2, offset_input);\n    member_id = tvb_get_guint16(tvb, offset, encoding);\n    member_length = tvb_get_guint16(tvb, offset+2, encoding);\n\n    if ((member_id & PID_EXTENDED) == PID_EXTENDED) {\n      member_id = tvb_get_guint32(tvb, offset+4, encoding);\n      member_length = tvb_get_guint32(tvb, offset+8, encoding);\n      member_tree = proto_tree_add_subtree_format(data_tree, tvb, offset, member_length + 12,\n              ett_rtps_data_member, NULL, \"Member (id = %u, len = %u)\", member_id, member_length);\n      proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member_id_ext, tvb, offset+4, 4, encoding);\n      proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member_length_ext, tvb, offset+8, 4, encoding);\n      offset += 12;\n      deserialized_size += 12;\n    } else if ((member_id & PID_LIST_END) == PID_LIST_END){\n      /* If this is the end of the list, don't add a tree.\n       * If we add more logic here in the future, take into account that\n       * offset is incremented by 4 */\n      deserialized_size += 4;\n      break;\n    } else {\n        member_tree = proto_tree_add_subtree_format(data_tree, tvb, offset, member_length + 4,\n              ett_rtps_data_member, NULL, \"Member (id = %u, len = %u)\", member_id, member_length);\n      proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member_id, tvb, offset, 2, encoding);\n      proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member_length, tvb, offset+2, 2, encoding);\n      offset += 4;\n      deserialized_size += 4;\n    }\n\n    proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member, tvb, offset,\n            member_length, encoding);\n    offset += member_length;\n    deserialized_size += member_length;\n  }\n  proto_item_set_len(ti, deserialized_size);\n}",
        "func": "static void dissect_parametrized_serialized_data(proto_tree *tree, tvbuff_t *tvb,\n                       gint offset_input, int size, const guint encoding)\n{\n  guint32 member_id, member_length;\n  proto_item * ti;\n  proto_tree * data_tree, * member_tree;\n  gint offset = offset_input;\n  gint deserialized_size = 0;\n  data_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,\n          ett_rtps_serialized_data, &ti, \"serializedData\");\n  while (deserialized_size < size) {\n    ALIGN_ZERO(offset, 2, offset_input);\n    member_id = tvb_get_guint16(tvb, offset, encoding);\n    member_length = tvb_get_guint16(tvb, offset+2, encoding);\n\n    if ((member_id & PID_EXTENDED) == PID_EXTENDED) {\n      member_id = tvb_get_guint32(tvb, offset+4, encoding);\n      member_length = tvb_get_guint32(tvb, offset+8, encoding);\n      member_tree = proto_tree_add_subtree_format(data_tree, tvb, offset, member_length + 12,\n              ett_rtps_data_member, NULL, \"Member (id = %u, len = %u)\", member_id, member_length);\n      proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member_id_ext, tvb, offset+4, 4, encoding);\n      proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member_length_ext, tvb, offset+8, 4, encoding);\n      offset += 12;\n      deserialized_size += 12;\n    } else if ((member_id & PID_LIST_END) == PID_LIST_END){\n      /* If this is the end of the list, don't add a tree.\n       * If we add more logic here in the future, take into account that\n       * offset is incremented by 4 */\n      deserialized_size += 4;\n      break;\n    } else {\n        member_tree = proto_tree_add_subtree_format(data_tree, tvb, offset, member_length + 4,\n              ett_rtps_data_member, NULL, \"Member (id = %u, len = %u)\", member_id, member_length);\n      proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member_id, tvb, offset, 2, encoding);\n      proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member_length, tvb, offset+2, 2, encoding);\n      offset += 4;\n      deserialized_size += 4;\n    }\n\n    proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member, tvb, offset,\n            member_length, encoding);\n    offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n    deserialized_size += member_length;\n  }\n  proto_item_set_len(ti, deserialized_size);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \n     proto_tree_add_item(member_tree, hf_rtps_pl_cdr_member, tvb, offset,\n             member_length, encoding);\n-    offset += member_length;\n+    offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n     deserialized_size += member_length;\n   }\n   proto_item_set_len(ti, deserialized_size);",
        "diff_line_info": {
            "deleted_lines": [
                "    offset += member_length;"
            ],
            "added_lines": [
                "    offset = check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_type_union_member",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint rtps_util_add_type_union_member(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, guint64 union_type_id,\n        gboolean is_discriminator, dissection_info * info _U_) {\n  proto_tree * labels;\n  gint long_number, i;\n  gint offset_tmp;\n  guint32 member_id = 0, member_length = 0;\n  dissection_element object;\n  offset = rtps_util_add_type_member(tree, tvb, offset, encoding, NULL, &object); //&(info->elements[i])\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n\n  labels = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n          ett_rtps_type_enum_constant, NULL, \"Labels (%u elements)\", long_number);\n  offset_tmp += 4;\n  if ((object.flags & 8) == 8) {\n    union_member_mapping * mapping = NULL;\n\n    mapping = wmem_new(wmem_file_scope(), union_member_mapping);\n    (void) g_strlcpy(mapping->member_name, object.member_name, 256);\n    mapping->member_type_id = object.type_id;\n    mapping->discriminator = HASHMAP_DISCRIMINATOR_CONSTANT;\n    mapping->union_type_id = union_type_id + mapping->discriminator;\n\n    wmem_map_insert(union_member_mappings, &(mapping->union_type_id), (void *) mapping);\n    proto_item_append_text(labels, \" Added mapping for discriminator (0x%016\" PRIx64 \") name = %s\",\n    mapping->union_type_id, mapping->member_name);\n  }\n  if (is_discriminator) {\n    union_member_mapping * mapping = NULL;\n\n    mapping = wmem_new(wmem_file_scope(), union_member_mapping);\n    (void) g_strlcpy(mapping->member_name, object.member_name, 256);\n    mapping->member_type_id = object.type_id;\n    mapping->discriminator = -1;\n    mapping->union_type_id = union_type_id + mapping->discriminator;\n\n    wmem_map_insert(union_member_mappings, &(mapping->union_type_id), (void *) mapping);\n    proto_item_append_text(labels, \" Added mapping for discriminator (0x%016\" PRIx64 \") name = %s\",\n    mapping->union_type_id, mapping->member_name);\n  }\n  for (i = 0; i < long_number; i++) {\n    proto_item * ti;\n    union_member_mapping * mapping = NULL;\n    guint32 discriminator_case;\n\n    mapping = wmem_new(wmem_file_scope(), union_member_mapping);\n\n    discriminator_case = tvb_get_guint32(tvb, offset_tmp, encoding);\n    ti = proto_tree_add_item(labels, hf_rtps_type_object_union_label, tvb, offset_tmp, 4, encoding);\n    offset_tmp += 4;\n\n    (void) g_strlcpy(mapping->member_name, object.member_name, 256);\n    mapping->member_type_id = object.type_id;\n    mapping->discriminator = discriminator_case;\n    mapping->union_type_id = union_type_id + discriminator_case;\n\n    wmem_map_insert(union_member_mappings, &(mapping->union_type_id), (void *) mapping);\n    proto_item_append_text(ti, \" Added mapping for discriminator (0x%016\" PRIx64 \") name = %s\",\n        mapping->union_type_id, mapping->member_name);\n  }\n\n  offset += member_length;\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n\n  if ((long_number & PID_LIST_END) == PID_LIST_END) {\n    offset += 4;\n  }\n\n  return offset;\n}",
        "func": "static gint rtps_util_add_type_union_member(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, guint64 union_type_id,\n        gboolean is_discriminator, dissection_info * info _U_) {\n  proto_tree * labels;\n  gint long_number, i;\n  gint offset_tmp;\n  guint32 member_id = 0, member_length = 0;\n  dissection_element object;\n  offset = rtps_util_add_type_member(tree, tvb, offset, encoding, NULL, &object); //&(info->elements[i])\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n\n  labels = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n          ett_rtps_type_enum_constant, NULL, \"Labels (%u elements)\", long_number);\n  offset_tmp += 4;\n  if ((object.flags & 8) == 8) {\n    union_member_mapping * mapping = NULL;\n\n    mapping = wmem_new(wmem_file_scope(), union_member_mapping);\n    (void) g_strlcpy(mapping->member_name, object.member_name, 256);\n    mapping->member_type_id = object.type_id;\n    mapping->discriminator = HASHMAP_DISCRIMINATOR_CONSTANT;\n    mapping->union_type_id = union_type_id + mapping->discriminator;\n\n    wmem_map_insert(union_member_mappings, &(mapping->union_type_id), (void *) mapping);\n    proto_item_append_text(labels, \" Added mapping for discriminator (0x%016\" PRIx64 \") name = %s\",\n    mapping->union_type_id, mapping->member_name);\n  }\n  if (is_discriminator) {\n    union_member_mapping * mapping = NULL;\n\n    mapping = wmem_new(wmem_file_scope(), union_member_mapping);\n    (void) g_strlcpy(mapping->member_name, object.member_name, 256);\n    mapping->member_type_id = object.type_id;\n    mapping->discriminator = -1;\n    mapping->union_type_id = union_type_id + mapping->discriminator;\n\n    wmem_map_insert(union_member_mappings, &(mapping->union_type_id), (void *) mapping);\n    proto_item_append_text(labels, \" Added mapping for discriminator (0x%016\" PRIx64 \") name = %s\",\n    mapping->union_type_id, mapping->member_name);\n  }\n  for (i = 0; i < long_number; i++) {\n    proto_item * ti;\n    union_member_mapping * mapping = NULL;\n    guint32 discriminator_case;\n\n    mapping = wmem_new(wmem_file_scope(), union_member_mapping);\n\n    discriminator_case = tvb_get_guint32(tvb, offset_tmp, encoding);\n    ti = proto_tree_add_item(labels, hf_rtps_type_object_union_label, tvb, offset_tmp, 4, encoding);\n    offset_tmp += 4;\n\n    (void) g_strlcpy(mapping->member_name, object.member_name, 256);\n    mapping->member_type_id = object.type_id;\n    mapping->discriminator = discriminator_case;\n    mapping->union_type_id = union_type_id + discriminator_case;\n\n    wmem_map_insert(union_member_mappings, &(mapping->union_type_id), (void *) mapping);\n    proto_item_append_text(ti, \" Added mapping for discriminator (0x%016\" PRIx64 \") name = %s\",\n        mapping->union_type_id, mapping->member_name);\n  }\n\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n\n  if ((long_number & PID_LIST_END) == PID_LIST_END) {\n    offset += 4;\n  }\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -63,7 +63,7 @@\n         mapping->union_type_id, mapping->member_name);\n   }\n \n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n   long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n \n   if ((long_number & PID_LIST_END) == PID_LIST_END) {",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += member_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_type_element_enumeration",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static void rtps_util_add_type_element_enumeration(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info) {\n  proto_tree * enumerated_constant;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number, i;\n  gint enum_size, offset_tmp;\n\n  offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  /* dissect Bound */\n  proto_tree_add_item(tree, hf_rtps_type_object_bound, tvb, offset, 4, encoding);\n  offset += member_length;\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  /* dissect constant seq */\n  offset_tmp = offset;\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  offset_tmp += 4;\n  for (i = 0; i < long_number; i++) {\n    gchar * name = NULL;\n    guint32 size, value;\n    enum_size = offset_tmp;\n    size = tvb_get_guint32(tvb, offset_tmp + 4, encoding);\n    name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset_tmp + 8, size, ENC_ASCII);\n    value = tvb_get_guint32(tvb, offset_tmp, encoding);\n    enumerated_constant = proto_tree_add_subtree_format(tree, tvb, offset_tmp, 0,\n          ett_rtps_type_enum_constant, NULL, \"%s (%u)\", name, value);\n    proto_tree_add_item(enumerated_constant, hf_rtps_type_object_enum_constant_value, tvb, offset_tmp, 4, encoding);\n    offset_tmp += 4;\n    offset_tmp = rtps_util_add_string(enumerated_constant, tvb, offset_tmp, hf_rtps_type_object_enum_constant_name, encoding);\n    proto_item_set_len(enumerated_constant, offset_tmp - enum_size);\n  }\n\n  info->num_elements = 0;\n}",
        "func": "static void rtps_util_add_type_element_enumeration(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info) {\n  proto_tree * enumerated_constant;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number, i;\n  gint enum_size, offset_tmp;\n\n  offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  /* dissect Bound */\n  proto_tree_add_item(tree, hf_rtps_type_object_bound, tvb, offset, 4, encoding);\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  /* dissect constant seq */\n  offset_tmp = offset;\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  offset_tmp += 4;\n  for (i = 0; i < long_number; i++) {\n    gchar * name = NULL;\n    guint32 size, value;\n    enum_size = offset_tmp;\n    size = tvb_get_guint32(tvb, offset_tmp + 4, encoding);\n    name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset_tmp + 8, size, ENC_ASCII);\n    value = tvb_get_guint32(tvb, offset_tmp, encoding);\n    enumerated_constant = proto_tree_add_subtree_format(tree, tvb, offset_tmp, 0,\n          ett_rtps_type_enum_constant, NULL, \"%s (%u)\", name, value);\n    proto_tree_add_item(enumerated_constant, hf_rtps_type_object_enum_constant_value, tvb, offset_tmp, 4, encoding);\n    offset_tmp += 4;\n    offset_tmp = rtps_util_add_string(enumerated_constant, tvb, offset_tmp, hf_rtps_type_object_enum_constant_name, encoding);\n    proto_item_set_len(enumerated_constant, offset_tmp - enum_size);\n  }\n\n  info->num_elements = 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   /* dissect Bound */\n   proto_tree_add_item(tree, hf_rtps_type_object_bound, tvb, offset, 4, encoding);\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n \n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   /* dissect constant seq */",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += member_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_typeobject",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static void rtps_util_add_typeobject(proto_tree *tree, packet_info * pinfo,\n        tvbuff_t * tvb, gint offset, const guint encoding, guint32 size,\n        type_mapping * type_mapping_object ) {\n  proto_tree * typeobject_tree;\n  gint offset_tmp = 0;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number;\n  guint64 type_id;\n\n  typeobject_tree = proto_tree_add_subtree(tree, tvb, offset, size,\n          ett_rtps_type_object, NULL, \"Type Object\");\n  /* --- This is the standard parameterized serialization --- */\n  /*                       TypeLibrary                        */\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  /* Dissect the member */\n  rtps_util_add_type_library(typeobject_tree, pinfo, tvb, offset_tmp, encoding, member_length);\n  offset += member_length;\n  /*                    End TypeLibrary                       */\n\n  /*                         _TypeId                          */\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  /* Dissect the member. In this case, the typeid is an union with a short\n   * as a discriminator*/\n  rtps_util_add_type_id(typeobject_tree, tvb, offset_tmp, encoding, offset, -1, NULL, &type_id);\n  if (type_mapping_object) type_mapping_object->type_id = type_id;\n  offset = offset + member_length;\n  /*                      End _TypeId                          */\n\n  long_number = tvb_get_guint32(tvb, offset, encoding);\n  if ((long_number & PID_LIST_END) != PID_LIST_END) {\n      expert_add_info_format(pinfo, typeobject_tree, &ei_rtps_parameter_value_invalid,\n              \"This should be PID_LIST_END and it is not\"); \\\n  }\n\n}",
        "func": "static void rtps_util_add_typeobject(proto_tree *tree, packet_info * pinfo,\n        tvbuff_t * tvb, gint offset, const guint encoding, guint32 size,\n        type_mapping * type_mapping_object ) {\n  proto_tree * typeobject_tree;\n  gint offset_tmp = 0;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number;\n  guint64 type_id;\n\n  typeobject_tree = proto_tree_add_subtree(tree, tvb, offset, size,\n          ett_rtps_type_object, NULL, \"Type Object\");\n  /* --- This is the standard parameterized serialization --- */\n  /*                       TypeLibrary                        */\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  /* Dissect the member */\n  rtps_util_add_type_library(typeobject_tree, pinfo, tvb, offset_tmp, encoding, member_length);\n  offset = check_offset_addition(offset, member_length, tree, pinfo, tvb);\n  /*                    End TypeLibrary                       */\n\n  /*                         _TypeId                          */\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  /* Dissect the member. In this case, the typeid is an union with a short\n   * as a discriminator*/\n  rtps_util_add_type_id(typeobject_tree, tvb, offset_tmp, encoding, offset, -1, NULL, &type_id);\n  if (type_mapping_object) type_mapping_object->type_id = type_id;\n  offset = check_offset_addition(offset, member_length, tree, pinfo, tvb);\n  /*                      End _TypeId                          */\n\n  long_number = tvb_get_guint32(tvb, offset, encoding);\n  if ((long_number & PID_LIST_END) != PID_LIST_END) {\n      expert_add_info_format(pinfo, typeobject_tree, &ei_rtps_parameter_value_invalid,\n              \"This should be PID_LIST_END and it is not\"); \\\n  }\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n   offset_tmp = offset;\n   /* Dissect the member */\n   rtps_util_add_type_library(typeobject_tree, pinfo, tvb, offset_tmp, encoding, member_length);\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, pinfo, tvb);\n   /*                    End TypeLibrary                       */\n \n   /*                         _TypeId                          */\n@@ -25,7 +25,7 @@\n    * as a discriminator*/\n   rtps_util_add_type_id(typeobject_tree, tvb, offset_tmp, encoding, offset, -1, NULL, &type_id);\n   if (type_mapping_object) type_mapping_object->type_id = type_id;\n-  offset = offset + member_length;\n+  offset = check_offset_addition(offset, member_length, tree, pinfo, tvb);\n   /*                      End _TypeId                          */\n \n   long_number = tvb_get_guint32(tvb, offset, encoding);",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += member_length;",
                "  offset = offset + member_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, member_length, tree, pinfo, tvb);",
                "  offset = check_offset_addition(offset, member_length, tree, pinfo, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_type_library_type",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint rtps_util_add_type_library_type(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info *info) {\n  proto_tree * annotation_tree;\n  guint32 member_id = 0, member_length = 0, long_number, i;\n  gint offset_tmp;\n  guint16 short_number;\n  gchar * name = NULL;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n\n  /* dissect property */\n  short_number = tvb_get_guint16(tvb, offset_tmp, encoding);\n  proto_tree_add_bitmask_value(tree, tvb, offset_tmp, hf_rtps_type_object_flags,\n          ett_rtps_flags, TYPE_FLAG_FLAGS, short_number);\n  if (info) {\n    if (short_number & 0x02)\n      info->extensibility = EXTENSIBILITY_MUTABLE;\n    else if (short_number & 0x01)\n      info->extensibility = EXTENSIBILITY_FINAL;\n    else\n      info->extensibility = EXTENSIBILITY_EXTENSIBLE;\n  }\n  offset_tmp += 2;\n  if (info)\n    offset_tmp = rtps_util_add_type_id(tree, tvb, offset_tmp, encoding, offset, -1, tree, &(info->type_id));\n  else\n    offset_tmp = rtps_util_add_type_id(tree, tvb, offset_tmp, encoding, offset, -1, tree, NULL);\n  rtps_util_add_string(tree, tvb, offset_tmp, hf_rtps_type_object_type_property_name,\n          encoding);\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset_tmp+4, long_number, ENC_ASCII);\n  if (info)\n    (void) g_strlcpy(info->member_name, name, long_number);\n\n  proto_item_append_text(tree, \" %s\", name);\n  offset += member_length;\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n\n  /* dissect annotation_seq */\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  annotation_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n            ett_rtps_type_annotation_usage_list, NULL, \"Annotation Usage Member List (%d elements)\",\n            long_number);\n  offset_tmp += 4;\n  for (i = 0; i < long_number ; i++) {\n      offset_tmp = rtps_util_add_type_annotation_usage(annotation_tree, tvb, offset_tmp,\n              encoding, offset);\n  }\n  offset += member_length;\n\n  return offset;\n}",
        "func": "static gint rtps_util_add_type_library_type(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info *info) {\n  proto_tree * annotation_tree;\n  guint32 member_id = 0, member_length = 0, long_number, i;\n  gint offset_tmp;\n  guint16 short_number;\n  gchar * name = NULL;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n\n  /* dissect property */\n  short_number = tvb_get_guint16(tvb, offset_tmp, encoding);\n  proto_tree_add_bitmask_value(tree, tvb, offset_tmp, hf_rtps_type_object_flags,\n          ett_rtps_flags, TYPE_FLAG_FLAGS, short_number);\n  if (info) {\n    if (short_number & 0x02)\n      info->extensibility = EXTENSIBILITY_MUTABLE;\n    else if (short_number & 0x01)\n      info->extensibility = EXTENSIBILITY_FINAL;\n    else\n      info->extensibility = EXTENSIBILITY_EXTENSIBLE;\n  }\n  offset_tmp += 2;\n  if (info)\n    offset_tmp = rtps_util_add_type_id(tree, tvb, offset_tmp, encoding, offset, -1, tree, &(info->type_id));\n  else\n    offset_tmp = rtps_util_add_type_id(tree, tvb, offset_tmp, encoding, offset, -1, tree, NULL);\n  rtps_util_add_string(tree, tvb, offset_tmp, hf_rtps_type_object_type_property_name,\n          encoding);\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset_tmp+4, long_number, ENC_ASCII);\n  if (info)\n    (void) g_strlcpy(info->member_name, name, long_number);\n\n  proto_item_append_text(tree, \" %s\", name);\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n\n  /* dissect annotation_seq */\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  annotation_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n            ett_rtps_type_annotation_usage_list, NULL, \"Annotation Usage Member List (%d elements)\",\n            long_number);\n  offset_tmp += 4;\n  for (i = 0; i < long_number ; i++) {\n      offset_tmp = rtps_util_add_type_annotation_usage(annotation_tree, tvb, offset_tmp,\n              encoding, offset);\n  }\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,7 @@\n     (void) g_strlcpy(info->member_name, name, long_number);\n \n   proto_item_append_text(tree, \" %s\", name);\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n \n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   offset_tmp = offset;\n@@ -48,7 +48,7 @@\n       offset_tmp = rtps_util_add_type_annotation_usage(annotation_tree, tvb, offset_tmp,\n               encoding, offset);\n   }\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n \n   return offset;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += member_length;",
                "  offset += member_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);",
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_type_member",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint rtps_util_add_type_member(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding,\n        dissection_info * info, dissection_element * member_object) {\n  proto_tree * member_property, *annotation_tree;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number, i;\n  guint16 short_number;\n  guint64 member_type_id;\n  gint offset_tmp;\n  gchar * name = NULL;\n\n  member_property = proto_tree_add_subtree(tree, tvb, offset, 0,\n                ett_rtps_type_element, NULL, \"Member Property\");\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  short_number = tvb_get_guint16(tvb, offset_tmp, encoding);\n  proto_tree_add_bitmask_value(member_property, tvb, offset_tmp, hf_rtps_type_object_flags,\n          ett_rtps_flags, MEMBER_FLAGS, short_number);\n  if (member_object) member_object->flags = short_number;\n  offset_tmp += 2;\n  ALIGN_ZERO(offset_tmp, 4, offset);\n  proto_tree_add_item(member_property, hf_rtps_type_object_member_id, tvb, offset_tmp, 4, encoding);\n  member_id = tvb_get_guint32(tvb, offset_tmp, encoding);\n  offset_tmp += 4;\n  offset_tmp = rtps_util_add_type_id(member_property, tvb, offset_tmp, encoding,\n          offset, -1, tree, &member_type_id);\n  rtps_util_add_string(member_property, tvb, offset_tmp, hf_rtps_type_object_name, encoding);\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset_tmp+4, long_number, ENC_ASCII);\n  proto_item_append_text(tree, \" %s (ID: %d)\", name, member_id);\n  if (member_object) {\n    member_object->member_id = member_id;\n    (void) g_strlcpy(member_object->member_name, name, long_number < 256 ? long_number : 256);\n    member_object->type_id = member_type_id;\n  }\n  if (info && info->extensibility == EXTENSIBILITY_MUTABLE) {\n      mutable_member_mapping * mutable_mapping = NULL;\n      mutable_mapping = wmem_new(wmem_file_scope(), mutable_member_mapping);\n      (void) g_strlcpy(mutable_mapping->member_name, name, long_number < 256 ? long_number : 256);\n      mutable_mapping->struct_type_id = info->type_id;\n      mutable_mapping->member_type_id = member_type_id;\n      mutable_mapping->member_id = member_id;\n      mutable_mapping->key = (mutable_mapping->struct_type_id + mutable_mapping->struct_type_id * mutable_mapping->member_id);\n      proto_item_append_text(tree, \"(Inserted 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\", mutable_mapping->key, mutable_mapping->struct_type_id);\n      wmem_map_insert(mutable_member_mappings, &(mutable_mapping->key), (void *) mutable_mapping);\n\n  }\n\n  offset += member_length;\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  annotation_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n              ett_rtps_type_annotation_usage_list, NULL, \"Annotation Usage Member List (%d elements)\",\n              long_number);\n  offset_tmp += 4;\n  for (i = 0; i < long_number ; i++) {\n        offset_tmp = rtps_util_add_type_annotation_usage(annotation_tree, tvb, offset_tmp,\n                encoding, offset);\n  }\n  offset += member_length;\n\n  long_number = tvb_get_guint32(tvb, offset, encoding);\n  if ((long_number & PID_LIST_END) == PID_LIST_END) {\n    offset += 4;\n  }\n\n  return offset;\n}",
        "func": "static gint rtps_util_add_type_member(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding,\n        dissection_info * info, dissection_element * member_object) {\n  proto_tree * member_property, *annotation_tree;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number, i;\n  guint16 short_number;\n  guint64 member_type_id;\n  gint offset_tmp;\n  gchar * name = NULL;\n\n  member_property = proto_tree_add_subtree(tree, tvb, offset, 0,\n                ett_rtps_type_element, NULL, \"Member Property\");\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  short_number = tvb_get_guint16(tvb, offset_tmp, encoding);\n  proto_tree_add_bitmask_value(member_property, tvb, offset_tmp, hf_rtps_type_object_flags,\n          ett_rtps_flags, MEMBER_FLAGS, short_number);\n  if (member_object) member_object->flags = short_number;\n  offset_tmp += 2;\n  ALIGN_ZERO(offset_tmp, 4, offset);\n  proto_tree_add_item(member_property, hf_rtps_type_object_member_id, tvb, offset_tmp, 4, encoding);\n  member_id = tvb_get_guint32(tvb, offset_tmp, encoding);\n  offset_tmp += 4;\n  offset_tmp = rtps_util_add_type_id(member_property, tvb, offset_tmp, encoding,\n          offset, -1, tree, &member_type_id);\n  rtps_util_add_string(member_property, tvb, offset_tmp, hf_rtps_type_object_name, encoding);\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset_tmp+4, long_number, ENC_ASCII);\n  proto_item_append_text(tree, \" %s (ID: %d)\", name, member_id);\n  if (member_object) {\n    member_object->member_id = member_id;\n    (void) g_strlcpy(member_object->member_name, name, long_number < 256 ? long_number : 256);\n    member_object->type_id = member_type_id;\n  }\n  if (info && info->extensibility == EXTENSIBILITY_MUTABLE) {\n      mutable_member_mapping * mutable_mapping = NULL;\n      mutable_mapping = wmem_new(wmem_file_scope(), mutable_member_mapping);\n      (void) g_strlcpy(mutable_mapping->member_name, name, long_number < 256 ? long_number : 256);\n      mutable_mapping->struct_type_id = info->type_id;\n      mutable_mapping->member_type_id = member_type_id;\n      mutable_mapping->member_id = member_id;\n      mutable_mapping->key = (mutable_mapping->struct_type_id + mutable_mapping->struct_type_id * mutable_mapping->member_id);\n      proto_item_append_text(tree, \"(Inserted 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\", mutable_mapping->key, mutable_mapping->struct_type_id);\n      wmem_map_insert(mutable_member_mappings, &(mutable_mapping->key), (void *) mutable_mapping);\n\n  }\n\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  offset_tmp = offset;\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  annotation_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n              ett_rtps_type_annotation_usage_list, NULL, \"Annotation Usage Member List (%d elements)\",\n              long_number);\n  offset_tmp += 4;\n  for (i = 0; i < long_number ; i++) {\n        offset_tmp = rtps_util_add_type_annotation_usage(annotation_tree, tvb, offset_tmp,\n                encoding, offset);\n  }\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n\n  long_number = tvb_get_guint32(tvb, offset, encoding);\n  if ((long_number & PID_LIST_END) == PID_LIST_END) {\n    offset += 4;\n  }\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,7 +46,7 @@\n \n   }\n \n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n \n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   offset_tmp = offset;\n@@ -59,7 +59,7 @@\n         offset_tmp = rtps_util_add_type_annotation_usage(annotation_tree, tvb, offset_tmp,\n                 encoding, offset);\n   }\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n \n   long_number = tvb_get_guint32(tvb, offset, encoding);\n   if ((long_number & PID_LIST_END) == PID_LIST_END) {",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += member_length;",
                "  offset += member_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);",
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_type_library_element",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint rtps_util_add_type_library_element(proto_tree *tree, packet_info * pinfo,\n        tvbuff_t * tvb, gint offset, const guint encoding) {\n  proto_tree * element_tree;\n  guint32 long_number;\n  guint32 member_id = 0, member_length = 0;\n  gint initial_offset = offset;\n  dissection_info * info;\n  gboolean add_info = TRUE;\n\n  info = wmem_new(wmem_file_scope(), dissection_info);\n  info->elements = NULL;\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  long_number = tvb_get_guint32(tvb, offset, encoding);\n  info->member_kind = long_number;\n\n  element_tree = proto_tree_add_subtree(tree, tvb, offset, 0,\n                    ett_rtps_type_element, NULL, \"\");\n  offset += member_length;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  proto_item_set_len(element_tree, member_length + offset - initial_offset);\n  switch (long_number) {\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ENUMERATION_TYPE: /*ENUMERATION */\n      rtps_util_add_type_element_enumeration(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ALIAS_TYPE: /* ALIAS */\n      rtps_util_add_type_element_alias(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ARRAY_TYPE: /* ARRAY */\n      rtps_util_add_type_element_array(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_SEQUENCE_TYPE: /* SEQUENCE */\n      rtps_util_add_type_element_sequence(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_STRING_TYPE: /* STRING : COLLECTION */\n      rtps_util_add_type_element_string(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UNION_TYPE:\n      rtps_util_add_type_element_union(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_STRUCTURE_TYPE: /* STRUCT */\n      rtps_util_add_type_element_struct(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_MODULE:\n      /* This does *not* fill in the info structure, so do *not* add it. */\n      add_info = FALSE;\n      rtps_util_add_type_element_module(element_tree, pinfo, tvb, offset, encoding);\n      break;\n    default:\n      /* We have *not* filled in the info structure, so do *not* add it. */\n      add_info = FALSE;\n      proto_item_append_text(element_tree, \"Kind: %u\", long_number);\n      proto_tree_add_item(element_tree, hf_rtps_type_object_element_raw, tvb, offset,\n                          member_length, encoding);\n      break;\n  }\n  offset += member_length;\n  LONG_ALIGN(offset);\n  long_number = tvb_get_guint32(tvb, offset, encoding);\n  if ((long_number & PID_LIST_END) != PID_LIST_END) {\n      expert_add_info_format(pinfo, element_tree, &ei_rtps_parameter_value_invalid,\n              \"Now it should be PID_LIST_END and it is not\"); \\\n  }\n  offset += 4;\n  proto_item_set_len(element_tree, offset - initial_offset);\n\n  if (add_info) {\n    wmem_map_insert(dissection_infos, &(info->type_id), (void *) info);\n  }\n\n  return offset;\n}",
        "func": "static gint rtps_util_add_type_library_element(proto_tree *tree, packet_info * pinfo,\n        tvbuff_t * tvb, gint offset, const guint encoding) {\n  proto_tree * element_tree;\n  guint32 long_number;\n  guint32 member_id = 0, member_length = 0;\n  gint initial_offset = offset;\n  dissection_info * info;\n  gboolean add_info = TRUE;\n\n  info = wmem_new(wmem_file_scope(), dissection_info);\n  info->elements = NULL;\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  long_number = tvb_get_guint32(tvb, offset, encoding);\n  info->member_kind = long_number;\n\n  element_tree = proto_tree_add_subtree(tree, tvb, offset, 0,\n                    ett_rtps_type_element, NULL, \"\");\n  offset = check_offset_addition(offset, member_length, tree, pinfo, tvb);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  proto_item_set_len(element_tree, member_length + offset - initial_offset);\n  switch (long_number) {\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ENUMERATION_TYPE: /*ENUMERATION */\n      rtps_util_add_type_element_enumeration(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ALIAS_TYPE: /* ALIAS */\n      rtps_util_add_type_element_alias(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ARRAY_TYPE: /* ARRAY */\n      rtps_util_add_type_element_array(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_SEQUENCE_TYPE: /* SEQUENCE */\n      rtps_util_add_type_element_sequence(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_STRING_TYPE: /* STRING : COLLECTION */\n      rtps_util_add_type_element_string(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UNION_TYPE:\n      rtps_util_add_type_element_union(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_STRUCTURE_TYPE: /* STRUCT */\n      rtps_util_add_type_element_struct(element_tree, tvb, offset, encoding, info);\n      break;\n    case RTI_CDR_TYPE_OBJECT_TYPE_KIND_MODULE:\n      /* This does *not* fill in the info structure, so do *not* add it. */\n      add_info = FALSE;\n      rtps_util_add_type_element_module(element_tree, pinfo, tvb, offset, encoding);\n      break;\n    default:\n      /* We have *not* filled in the info structure, so do *not* add it. */\n      add_info = FALSE;\n      proto_item_append_text(element_tree, \"Kind: %u\", long_number);\n      proto_tree_add_item(element_tree, hf_rtps_type_object_element_raw, tvb, offset,\n                          member_length, encoding);\n      break;\n  }\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  LONG_ALIGN(offset);\n  long_number = tvb_get_guint32(tvb, offset, encoding);\n  if ((long_number & PID_LIST_END) != PID_LIST_END) {\n      expert_add_info_format(pinfo, element_tree, &ei_rtps_parameter_value_invalid,\n              \"Now it should be PID_LIST_END and it is not\"); \\\n  }\n  offset += 4;\n  proto_item_set_len(element_tree, offset - initial_offset);\n\n  if (add_info) {\n    wmem_map_insert(dissection_infos, &(info->type_id), (void *) info);\n  }\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \n   element_tree = proto_tree_add_subtree(tree, tvb, offset, 0,\n                     ett_rtps_type_element, NULL, \"\");\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, pinfo, tvb);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   proto_item_set_len(element_tree, member_length + offset - initial_offset);\n   switch (long_number) {\n@@ -54,7 +54,7 @@\n                           member_length, encoding);\n       break;\n   }\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n   LONG_ALIGN(offset);\n   long_number = tvb_get_guint32(tvb, offset, encoding);\n   if ((long_number & PID_LIST_END) != PID_LIST_END) {",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += member_length;",
                "  offset += member_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, member_length, tree, pinfo, tvb);",
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_typecode",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint rtps_util_add_typecode(proto_tree *tree, tvbuff_t *tvb, gint offset, const guint encoding,\n                        int      indent_level, int is_pointer, guint16 bitfield, int is_key, const gint offset_begin,\n                        char    *name,\n                        int      seq_max_len,   /* -1 = not a sequence field */\n                        guint32 *arr_dimension, /* if !NULL: array of 10 int */\n                        int      ndds_40_hack) {\n  const gint    original_offset = offset;\n  guint32       tk_id;\n  guint16       tk_size;\n  unsigned int  i;\n  char         *indent_string;\n  gint          retVal;\n  char          type_name[40];\n\n    /* Structure of the typecode data:\n     *  Offset   | Size  | Field                        | Notes\n     * ----------|-------|------------------------------|---------------------\n     *       ?   |    ?  | pad?                         |\n     *       0   |    4  | RTI_CDR_TK_XXXXX             | 4 bytes aligned\n     *       4   |    2  | length the struct            |\n     */\n\n  /* Calc indent string */\n  indent_string = (char *)wmem_alloc(wmem_epan_scope(), (indent_level*2)+1);\n  memset(indent_string, ' ', (indent_level*2)+1);\n  indent_string[indent_level*2] = '\\0';\n\n  /* Gets TK ID */\n  LONG_ALIGN(offset);\n  tk_id = tvb_get_guint32(tvb, offset, encoding);\n  offset += 4;\n\n  /* Gets TK size */\n  tk_size = tvb_get_guint16(tvb, offset, encoding);\n  offset += 2;\n\n  retVal = tk_size + 6; /* 6 = 4 (typecode ID) + 2 (size) */\n\n  /* The first bit of typecode is set to 1, clear it */\n  tk_id &= 0x7fffffff;\n\n  /* HACK: NDDS 4.0 and NDDS 4.1 has different typecode ID list.\n   * The ID listed in the RTI_CDR_TK_XXXXX are the one from NDDS 4.1\n   * In order to correctly dissect NDDS 4.0 packets containing typecode\n   * information, we check if the ID of the element at level zero is a\n   * struct or union. If not, it means we are dissecting a ndds 4.0 packet\n   * (and we can decrement the ID to match the correct values).\n   */\n  if (indent_level == 0) {\n    if (tk_id == RTI_CDR_TK_OCTET) {\n      ndds_40_hack = 1;\n    }\n  }\n  if (ndds_40_hack) {\n    ++tk_id;\n  }\n\n  (void) g_strlcpy(type_name, rtps_util_typecode_id_to_string(tk_id), 40);\n\n    /* Structure of the typecode data:\n     *\n     * <type_code_header> ::=\n     *          <kind>\n     *          <type_code_length>\n     *\n     * <kind> ::= long (0=TK_NULL, 1=TK_SHORT...)\n     * <type_code_length> ::= unsugned short\n     *\n     */\n  switch(tk_id) {\n\n    /* Structure of the typecode data:\n     *\n     * <union_type_code> ::=\n     *          <type_code_header>\n     *          <name>\n     *          <default_index>\n     *          <discriminator_type_code>\n     *          <member_count>\n     *          <union_member>+\n     * <union_member> ::= <member_length><name><union_member_detail>\n     * <member_length> ::= unsigned short\n     * <name>   ::= <string>\n     * <string> ::= <length>char+<eol>\n     * <length> ::= unsigned long\n     * <eol>    ::= (char)0\n     *\n     * <union_member_detail> ::= <is_pointer>\n     *          <labels_count>\n     *          <label>+\n     *          <type_code>\n     * <labels_count> ::= unsigned long\n     * <label> ::= long\n     *\n     */\n    case RTI_CDR_TK_UNION: {\n        guint32     struct_name_len;\n        guint8      *struct_name;\n        const char *discriminator_name      = \"<unknown>\"; /* for unions */\n        char       *discriminator_enum_name = NULL;        /* for unions with enum discriminator */\n        /*guint32 defaultIdx;*/ /* Currently is ignored */\n        guint32     disc_id;                               /* Used temporarily to populate 'discriminator_name' */\n        guint16     disc_size;                             /* Currently is ignored */\n        guint32     disc_offset_begin, num_members, member_name_len;\n        guint16     member_length;\n        guint8     *member_name             = NULL;\n        guint32     next_offset, field_offset_begin, member_label_count, discriminator_enum_name_length;\n        gint32      member_label;\n        guint       j;\n\n        /* - - - - - - -      Union name      - - - - - - - */\n        /* Pad-align */\n        LONG_ALIGN(offset);\n\n        /* Get structure name length */\n        struct_name_len = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n        struct_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, struct_name_len, ENC_ASCII);\n        offset += struct_name_len;\n\n        /* - - - - - - -      Default index      - - - - - - - */\n        LONG_ALIGN(offset);\n        /*defaultIdx = NEXT_guint32(tvb, offset, encoding);*/\n        offset += 4;\n\n        /* - - - - - - -      Discriminator type code     - - - - - - - */\n        /* We don't recursively dissect everything, instead we just read the type */\n        disc_id = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        disc_size = tvb_get_guint16(tvb, offset, encoding);\n        offset += 2;\n        disc_offset_begin = offset;\n        disc_id &= 0x7fffffff;\n        discriminator_name = rtps_util_typecode_id_to_string(disc_id);\n        if (disc_id == RTI_CDR_TK_ENUM) {\n          /* Enums has also a name that we should print */\n          LONG_ALIGN(offset);\n          discriminator_enum_name_length = tvb_get_guint32(tvb, offset, encoding);\n          discriminator_enum_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset+4, discriminator_enum_name_length, ENC_ASCII);\n        }\n        offset = disc_offset_begin + disc_size;\n#if 0\n        field_offset_begin = offset;\n        offset += rtps_util_add_typecode(\n                          tree,\n                          tvb,\n                          offset,\n                          encoding,\n                          indent_level+1,\n                          0,\n                          0,\n                          0,\n                          field_offset_begin,\n                          member_name,\n                          -1,\n                          NULL,\n                          ndds_40_hack);\n#endif\n\n        /* Add the entry of the union in the tree */\n        proto_tree_add_string_format(tree, hf_rtps_union, tvb, original_offset, retVal, struct_name, \"%sunion %s (%s%s%s) {\",\n                    indent_string, struct_name, discriminator_name,\n                    (discriminator_enum_name ? \" \" : \"\"),\n                    (discriminator_enum_name ? discriminator_enum_name : \"\"));\n\n        if (seq_max_len != -1) {\n          /* We're dissecting a sequence of struct, bypass the seq definition */\n          snprintf(type_name, 40, \"%s\", struct_name);\n          break;\n        }\n\n        /* - - - - - - -      Number of members     - - - - - - - */\n        LONG_ALIGN(offset);\n        num_members = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        /* - - - - - - -      <union_member>+     - - - - - - - */\n        next_offset = offset;\n\n        for (i = 0; i < num_members; ++i) {\n          guint8  member_is_pointer;\n          /* Safety: this theoretically should be the same already */\n          field_offset_begin = offset = next_offset;\n\n          SHORT_ALIGN(offset);\n\n          /* member's length */\n          member_length = tvb_get_guint16(tvb, offset, encoding);\n          offset += 2;\n          next_offset = offset + member_length;\n\n          /* Name length */\n          LONG_ALIGN(offset);\n          member_name_len = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n\n          /* Name */\n          member_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, member_name_len, ENC_ASCII);\n          offset += member_name_len;\n\n          /* is Pointer ? */\n          member_is_pointer = tvb_get_guint8(tvb, offset);\n          offset++;\n\n          /* Label count */\n          LONG_ALIGN(offset);\n          member_label_count = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n\n          for (j = 0; j < member_label_count; ++j) {\n            proto_item* case_item;\n            /* Label count */\n            LONG_ALIGN(offset);\n            member_label = tvb_get_guint32(tvb, offset, encoding);\n            offset += 4;\n\n            /* Add the entry of the union in the tree */\n            case_item = proto_tree_add_uint_format(tree, hf_rtps_union_case, tvb, field_offset_begin, 1, member_label,\n                                                    \"%s  case %d:\", indent_string, member_label);\n            proto_item_set_len(case_item, retVal);\n          }\n\n          offset += rtps_util_add_typecode(tree, tvb, offset, encoding,\n                    indent_level+2, member_is_pointer, 0, 0, field_offset_begin,\n                    member_name, -1, NULL, ndds_40_hack);\n        }\n        /* Finally prints the name of the struct (if provided) */\n        (void) g_strlcpy(type_name, \"}\", 40);\n        break;\n\n    } /* end of case UNION */\n\n\n    case RTI_CDR_TK_ENUM:\n    case RTI_CDR_TK_STRUCT: {\n    /* Structure of the typecode data:\n     *\n     * <union_type_code> ::=\n     *          <type_code_header>\n     *          <name>\n     *          <default_index>\n     *          <discriminator_type_code>\n     *          <member_count>\n     *          <member>+\n     *\n     * <struct_type_code> ::=\n     *          <type_code_header>\n     *          <name>\n     *          <member_count>\n     *          <member>+\n     *\n     * <name>   ::= <string>\n     * <string> ::= <length>char+<eol>\n     * <length> ::= unsigned long\n     * <eol>    ::= (char)0\n     * <member_count> ::= unsigned long\n     *\n     * STRUCT / UNION:\n     *     Foreach member {\n     *          - A2: 2: member length\n     *          - A4: 4: member name length\n     *          -     n: member name\n     *          -     1: isPointer?\n     *          - A2  2: bitfield bits (-1=none)\n     *          -     1: isKey?\n     *          - A4  4: Typecode ID\n     *          - A2  2: length\n     * }\n     *\n     * ENUM:\n     *     Foreach member {\n     *          - A2: 2: member length\n     *          - A4: 4: member name length\n     *          -     n: member name\n     *          - A4: 4: ordinal number\n     *\n     * -> ----------------------------------------------------- <-\n     * -> The alignment pad bytes belong to the FOLLOWING field <-\n     * ->    A4 = 4 bytes alignment, A2 = 2 bytes alignment     <-\n     * -> ----------------------------------------------------- <-\n     */\n        gint8  *struct_name;\n        guint32 struct_name_len, num_members;\n        guint32 next_offset;\n        const char *typecode_name;\n\n        /* Pad-align */\n        LONG_ALIGN(offset);\n\n        /* Get structure name length */\n        struct_name_len = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        /* struct name */\n        struct_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, struct_name_len, ENC_ASCII);\n        offset += struct_name_len;\n\n\n        if (tk_id == RTI_CDR_TK_ENUM) {\n          typecode_name = \"enum\";\n        } else if (tk_id == RTI_CDR_TK_VALUE_PARAM) {\n          /* guint16 type_modifier; */\n          /* guint32 baseTypeCodeKind; */\n          guint32 baseTypeCodeLength;\n\n          /* Need to read the type modifier and the base type code */\n          typecode_name = \"<sparse type>\";\n          SHORT_ALIGN(offset);\n          /* type_modifier = */ tvb_get_guint16(tvb, offset, encoding);\n          offset += 2;\n\n          LONG_ALIGN(offset);\n          /* baseTypeCodeKind = */ tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n\n          baseTypeCodeLength = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n          offset += baseTypeCodeLength;\n        } else {\n          typecode_name = \"struct\";\n        }\n\n        if (seq_max_len != -1) {\n          /* We're dissecting a sequence of struct, bypass the seq definition */\n          snprintf(type_name, 40, \"%s\", struct_name);\n          break;\n        }\n        /* Prints it */\n        proto_tree_add_string_format(tree, hf_rtps_struct, tvb, original_offset, retVal, struct_name,\n                                     \"%s%s %s {\", indent_string, typecode_name, struct_name);\n\n        /* PAD align */\n        LONG_ALIGN(offset);\n\n        /* number of members */\n        num_members = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        next_offset = offset;\n        for (i = 0; i < num_members; ++i) {\n          guint8  *member_name;\n          guint32  member_name_len;\n          guint16  member_length;\n          guint32  field_offset_begin;\n\n          /* Safety: this theoretically should be the same already */\n          field_offset_begin = offset = next_offset;\n\n          SHORT_ALIGN(offset);\n\n          /* member's length */\n          member_length = tvb_get_guint16(tvb, offset, encoding);\n          offset += 2;\n          next_offset = offset + member_length;\n\n          /* Name length */\n          LONG_ALIGN(offset);\n          member_name_len = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n\n          /* Name */\n          member_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, member_name_len, ENC_ASCII);\n          offset += member_name_len;\n\n          if (tk_id == RTI_CDR_TK_ENUM) {\n            /* ordinal number */\n            guint32 ordinal_number;\n            LONG_ALIGN(offset);\n            ordinal_number = tvb_get_guint32(tvb, offset, encoding);\n            offset += 4;\n\n            proto_tree_add_string_format(tree, hf_rtps_member_name, tvb, field_offset_begin, (offset-field_offset_begin), member_name,\n                                            \"%s  %s = %d;\", indent_string, member_name, ordinal_number);\n          } else {\n            /* Structs */\n            guint16 member_bitfield;\n            guint8  member_is_pointer;\n            guint8  member_is_key;\n\n            /* is Pointer ? */\n            member_is_pointer = tvb_get_guint8(tvb, offset);\n            offset++;\n\n            /* Bitfield */\n            SHORT_ALIGN(offset);\n            member_bitfield = tvb_get_guint16(tvb, offset, encoding);\n            offset += 2; /* pad will be added by typecode dissector */\n\n            /* is Key ? */\n            member_is_key = tvb_get_guint8(tvb, offset);\n            offset++;\n\n            offset += rtps_util_add_typecode(tree, tvb, offset, encoding,\n                          indent_level+1, member_is_pointer, member_bitfield, member_is_key,\n                          field_offset_begin, member_name, -1, NULL, ndds_40_hack);\n          }\n        }\n        /* Finally prints the name of the struct (if provided) */\n        (void) g_strlcpy(type_name, \"}\", 40);\n        break;\n      }\n\n    case RTI_CDR_TK_WSTRING:\n    case RTI_CDR_TK_STRING: {\n    /* Structure of the typecode data:\n     *  Offset   | Size  | Field                        | Notes\n     * ----------|-------|------------------------------|---------------------\n     *     6     |   2   | pad                          |\n     *     8     |   4   | String length                | 4-bytes aligned\n     */\n        guint32 string_length;\n\n        LONG_ALIGN(offset);\n        string_length = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n        snprintf(type_name, 40, \"%s<%d>\",\n                (tk_id == RTI_CDR_TK_STRING) ? \"string\" : \"wstring\",\n                string_length);\n        break;\n    }\n\n    case RTI_CDR_TK_SEQUENCE: {\n    /* Structure of the typecode data:\n     *\n     * - A4: 4: Sequence max length\n     * - the sequence typecode\n     */\n        guint32 seq_max_len2;\n        LONG_ALIGN(offset);\n        seq_max_len2 = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        /* Recursive decode seq typecode */\n        /*offset += */rtps_util_add_typecode(tree, tvb, offset, encoding, indent_level,\n                          is_pointer, bitfield, is_key, offset_begin, name,\n                          seq_max_len2, NULL, ndds_40_hack);\n        /* Differently from the other typecodes, the line has been already printed */\n        return retVal;\n    }\n\n    case RTI_CDR_TK_ARRAY: {\n    /* Structure of the typecode data:\n     *\n     * - A4: 4: number of dimensions\n     * - A4: 4: dim1\n     * - <A4: 4: dim2>\n     * - ...\n     * - the array typecode\n     */\n        guint32 size[MAX_ARRAY_DIMENSION]; /* Max dimensions */\n        guint32 dim_max;\n\n        LONG_ALIGN(offset);\n        dim_max = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        if (dim_max > MAX_ARRAY_DIMENSION) {\n            /* We don't have a tree item to add expert info to... */\n            dim_max = MAX_ARRAY_DIMENSION;\n        }\n\n        for (i = 0; i < MAX_ARRAY_DIMENSION; ++i) size[i] = 0;\n        for (i = 0; i < dim_max; ++i) {\n          size[i] = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n        }\n\n        /* Recursive decode seq typecode */\n        /*offset += */rtps_util_add_typecode(tree, tvb, offset, encoding,\n                          indent_level, is_pointer, bitfield, is_key, offset_begin,\n                          name, -1, size, ndds_40_hack);\n        /* Differently from the other typecodes, the line has been already printed */\n        return retVal;\n    }\n\n    case RTI_CDR_TK_ALIAS: {\n    /* Structure of the typecode data:\n     *\n     * - A4: 4: alias name size\n     * - A4: 4: alias name\n     * - A4: 4: the alias typecode\n     */\n        guint32 alias_name_length;\n        guint8 *alias_name;\n\n        LONG_ALIGN(offset);\n        alias_name_length = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n        alias_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, alias_name_length, ENC_ASCII);\n        offset += alias_name_length;\n        (void) g_strlcpy(type_name, alias_name, 40);\n        break;\n    }\n\n\n    /*\n     * VALUETYPES:\n     * - A4: 4: name length\n     * -     n: name\n     * - A2: type modifier\n     * - A4: base type code\n     * - A4: number of members\n     * Foreach member: (it's just like a struct)\n     *\n     */\n    case RTI_CDR_TK_VALUE_PARAM:\n    case RTI_CDR_TK_VALUE: {\n        /* Not fully dissected for now */\n        /* Pad-align */\n        guint32 value_name_len;\n        gint8 *value_name;\n        const char *type_id_name = \"valuetype\";\n        LONG_ALIGN(offset);\n\n        /* Get structure name length */\n        value_name_len = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        /* value name */\n        value_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, value_name_len, ENC_ASCII);\n        offset += value_name_len;\n\n        if (tk_id == RTI_CDR_TK_VALUE_PARAM) {\n          type_id_name = \"valueparam\";\n        }\n        snprintf(type_name, 40, \"%s '%s'\", type_id_name, value_name);\n        break;\n    }\n  } /* switch(tk_id) */\n\n  /* Sequence print */\n  if (seq_max_len != -1) {\n    proto_tree_add_string_format(tree, hf_rtps_sequence, tvb, offset_begin, (offset-offset_begin), type_name,\n                  \"%ssequence<%s, %d> %s%s;%s\", indent_string, type_name, seq_max_len,\n                  is_pointer ? \"*\" : \"\",\n                  name ? name : \"\",\n                  is_key ? KEY_COMMENT : \"\");\n    return retVal;\n  }\n\n  /* Array print */\n  if (arr_dimension != NULL) {\n    /* Printing an array */\n    wmem_strbuf_t *dim_str = wmem_strbuf_create(wmem_packet_scope());\n    for (i = 0; i < MAX_ARRAY_DIMENSION; ++i) {\n      if (arr_dimension[i] != 0) {\n        wmem_strbuf_append_printf(dim_str, \"[%d]\", arr_dimension[i]);\n      } else {\n        break;\n      }\n    }\n    proto_tree_add_string_format(tree, hf_rtps_array, tvb, offset_begin, (offset-offset_begin), type_name,\n                  \"%s%s %s%s;%s\", indent_string, type_name, name ? name : \"\",\n                  wmem_strbuf_get_str(dim_str), is_key ? KEY_COMMENT : \"\");\n    return retVal;\n  }\n\n  /* Bitfield print */\n  if (bitfield != 0xffff && name != NULL && is_pointer == 0) {\n    proto_tree_add_string_format(tree, hf_rtps_bitfield, tvb, offset_begin, (offset-offset_begin), type_name,\n                  \"%s%s %s:%d;%s\", indent_string, type_name, name,\n                  bitfield, is_key ? KEY_COMMENT : \"\");\n    return retVal;\n  }\n\n  /* Everything else */\n  proto_tree_add_string_format(tree, hf_rtps_datatype, tvb, offset_begin, (offset-offset_begin), type_name,\n                  \"%s%s%s%s%s;%s\", indent_string, type_name,\n                  name ? \" \" : \"\",\n                  is_pointer ? \"*\" : \"\",\n                  name ? name : \"\",\n                  is_key ? KEY_COMMENT : \"\");\n  return retVal;\n}",
        "func": "static gint rtps_util_add_typecode(proto_tree *tree, tvbuff_t *tvb, gint offset, const guint encoding,\n                        int      indent_level, int is_pointer, guint16 bitfield, int is_key, const gint offset_begin,\n                        char    *name,\n                        int      seq_max_len,   /* -1 = not a sequence field */\n                        guint32 *arr_dimension, /* if !NULL: array of 10 int */\n                        int      ndds_40_hack) {\n  const gint    original_offset = offset;\n  guint32       tk_id;\n  guint16       tk_size;\n  unsigned int  i;\n  char         *indent_string;\n  gint          retVal;\n  char          type_name[40];\n\n    /* Structure of the typecode data:\n     *  Offset   | Size  | Field                        | Notes\n     * ----------|-------|------------------------------|---------------------\n     *       ?   |    ?  | pad?                         |\n     *       0   |    4  | RTI_CDR_TK_XXXXX             | 4 bytes aligned\n     *       4   |    2  | length the struct            |\n     */\n\n  /* Calc indent string */\n  indent_string = (char *)wmem_alloc(wmem_epan_scope(), (indent_level*2)+1);\n  memset(indent_string, ' ', (indent_level*2)+1);\n  indent_string[indent_level*2] = '\\0';\n\n  /* Gets TK ID */\n  LONG_ALIGN(offset);\n  tk_id = tvb_get_guint32(tvb, offset, encoding);\n  offset += 4;\n\n  /* Gets TK size */\n  tk_size = tvb_get_guint16(tvb, offset, encoding);\n  offset += 2;\n\n  retVal = tk_size + 6; /* 6 = 4 (typecode ID) + 2 (size) */\n\n  /* The first bit of typecode is set to 1, clear it */\n  tk_id &= 0x7fffffff;\n\n  /* HACK: NDDS 4.0 and NDDS 4.1 has different typecode ID list.\n   * The ID listed in the RTI_CDR_TK_XXXXX are the one from NDDS 4.1\n   * In order to correctly dissect NDDS 4.0 packets containing typecode\n   * information, we check if the ID of the element at level zero is a\n   * struct or union. If not, it means we are dissecting a ndds 4.0 packet\n   * (and we can decrement the ID to match the correct values).\n   */\n  if (indent_level == 0) {\n    if (tk_id == RTI_CDR_TK_OCTET) {\n      ndds_40_hack = 1;\n    }\n  }\n  if (ndds_40_hack) {\n    ++tk_id;\n  }\n\n  (void) g_strlcpy(type_name, rtps_util_typecode_id_to_string(tk_id), 40);\n\n    /* Structure of the typecode data:\n     *\n     * <type_code_header> ::=\n     *          <kind>\n     *          <type_code_length>\n     *\n     * <kind> ::= long (0=TK_NULL, 1=TK_SHORT...)\n     * <type_code_length> ::= unsugned short\n     *\n     */\n  switch(tk_id) {\n\n    /* Structure of the typecode data:\n     *\n     * <union_type_code> ::=\n     *          <type_code_header>\n     *          <name>\n     *          <default_index>\n     *          <discriminator_type_code>\n     *          <member_count>\n     *          <union_member>+\n     * <union_member> ::= <member_length><name><union_member_detail>\n     * <member_length> ::= unsigned short\n     * <name>   ::= <string>\n     * <string> ::= <length>char+<eol>\n     * <length> ::= unsigned long\n     * <eol>    ::= (char)0\n     *\n     * <union_member_detail> ::= <is_pointer>\n     *          <labels_count>\n     *          <label>+\n     *          <type_code>\n     * <labels_count> ::= unsigned long\n     * <label> ::= long\n     *\n     */\n    case RTI_CDR_TK_UNION: {\n        guint32     struct_name_len;\n        guint8      *struct_name;\n        const char *discriminator_name      = \"<unknown>\"; /* for unions */\n        char       *discriminator_enum_name = NULL;        /* for unions with enum discriminator */\n        /*guint32 defaultIdx;*/ /* Currently is ignored */\n        guint32     disc_id;                               /* Used temporarily to populate 'discriminator_name' */\n        guint16     disc_size;                             /* Currently is ignored */\n        guint32     disc_offset_begin, num_members, member_name_len;\n        guint16     member_length;\n        guint8     *member_name             = NULL;\n        guint32     next_offset, field_offset_begin, member_label_count, discriminator_enum_name_length;\n        gint32      member_label;\n        guint       j;\n\n        /* - - - - - - -      Union name      - - - - - - - */\n        /* Pad-align */\n        LONG_ALIGN(offset);\n\n        /* Get structure name length */\n        struct_name_len = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n        struct_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, struct_name_len, ENC_ASCII);\n        offset = check_offset_addition(offset, struct_name_len, tree, NULL, tvb);\n\n        /* - - - - - - -      Default index      - - - - - - - */\n        LONG_ALIGN(offset);\n        /*defaultIdx = NEXT_guint32(tvb, offset, encoding);*/\n        offset += 4;\n\n        /* - - - - - - -      Discriminator type code     - - - - - - - */\n        /* We don't recursively dissect everything, instead we just read the type */\n        disc_id = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        disc_size = tvb_get_guint16(tvb, offset, encoding);\n        offset += 2;\n        disc_offset_begin = offset;\n        disc_id &= 0x7fffffff;\n        discriminator_name = rtps_util_typecode_id_to_string(disc_id);\n        if (disc_id == RTI_CDR_TK_ENUM) {\n          /* Enums has also a name that we should print */\n          LONG_ALIGN(offset);\n          discriminator_enum_name_length = tvb_get_guint32(tvb, offset, encoding);\n          discriminator_enum_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset+4, discriminator_enum_name_length, ENC_ASCII);\n        }\n        offset = disc_offset_begin + disc_size;\n#if 0\n        field_offset_begin = offset;\n        offset += rtps_util_add_typecode(\n                          tree,\n                          tvb,\n                          offset,\n                          encoding,\n                          indent_level+1,\n                          0,\n                          0,\n                          0,\n                          field_offset_begin,\n                          member_name,\n                          -1,\n                          NULL,\n                          ndds_40_hack);\n#endif\n\n        /* Add the entry of the union in the tree */\n        proto_tree_add_string_format(tree, hf_rtps_union, tvb, original_offset, retVal, struct_name, \"%sunion %s (%s%s%s) {\",\n                    indent_string, struct_name, discriminator_name,\n                    (discriminator_enum_name ? \" \" : \"\"),\n                    (discriminator_enum_name ? discriminator_enum_name : \"\"));\n\n        if (seq_max_len != -1) {\n          /* We're dissecting a sequence of struct, bypass the seq definition */\n          snprintf(type_name, 40, \"%s\", struct_name);\n          break;\n        }\n\n        /* - - - - - - -      Number of members     - - - - - - - */\n        LONG_ALIGN(offset);\n        num_members = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        /* - - - - - - -      <union_member>+     - - - - - - - */\n        next_offset = offset;\n\n        for (i = 0; i < num_members; ++i) {\n          guint8  member_is_pointer;\n          /* Safety: this theoretically should be the same already */\n          field_offset_begin = offset = next_offset;\n\n          SHORT_ALIGN(offset);\n\n          /* member's length */\n          member_length = tvb_get_guint16(tvb, offset, encoding);\n          offset += 2;\n          next_offset = offset + member_length;\n\n          /* Name length */\n          LONG_ALIGN(offset);\n          member_name_len = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n\n          /* Name */\n          member_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, member_name_len, ENC_ASCII);\n          offset = check_offset_addition(offset, member_name_len, tree, NULL, tvb);\n\n          /* is Pointer ? */\n          member_is_pointer = tvb_get_guint8(tvb, offset);\n          offset++;\n\n          /* Label count */\n          LONG_ALIGN(offset);\n          member_label_count = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n\n          for (j = 0; j < member_label_count; ++j) {\n            proto_item* case_item;\n            /* Label count */\n            LONG_ALIGN(offset);\n            member_label = tvb_get_guint32(tvb, offset, encoding);\n            offset += 4;\n\n            /* Add the entry of the union in the tree */\n            case_item = proto_tree_add_uint_format(tree, hf_rtps_union_case, tvb, field_offset_begin, 1, member_label,\n                                                    \"%s  case %d:\", indent_string, member_label);\n            proto_item_set_len(case_item, retVal);\n          }\n\n          offset += rtps_util_add_typecode(tree, tvb, offset, encoding,\n                    indent_level+2, member_is_pointer, 0, 0, field_offset_begin,\n                    member_name, -1, NULL, ndds_40_hack);\n        }\n        /* Finally prints the name of the struct (if provided) */\n        (void) g_strlcpy(type_name, \"}\", 40);\n        break;\n\n    } /* end of case UNION */\n\n\n    case RTI_CDR_TK_ENUM:\n    case RTI_CDR_TK_STRUCT: {\n    /* Structure of the typecode data:\n     *\n     * <union_type_code> ::=\n     *          <type_code_header>\n     *          <name>\n     *          <default_index>\n     *          <discriminator_type_code>\n     *          <member_count>\n     *          <member>+\n     *\n     * <struct_type_code> ::=\n     *          <type_code_header>\n     *          <name>\n     *          <member_count>\n     *          <member>+\n     *\n     * <name>   ::= <string>\n     * <string> ::= <length>char+<eol>\n     * <length> ::= unsigned long\n     * <eol>    ::= (char)0\n     * <member_count> ::= unsigned long\n     *\n     * STRUCT / UNION:\n     *     Foreach member {\n     *          - A2: 2: member length\n     *          - A4: 4: member name length\n     *          -     n: member name\n     *          -     1: isPointer?\n     *          - A2  2: bitfield bits (-1=none)\n     *          -     1: isKey?\n     *          - A4  4: Typecode ID\n     *          - A2  2: length\n     * }\n     *\n     * ENUM:\n     *     Foreach member {\n     *          - A2: 2: member length\n     *          - A4: 4: member name length\n     *          -     n: member name\n     *          - A4: 4: ordinal number\n     *\n     * -> ----------------------------------------------------- <-\n     * -> The alignment pad bytes belong to the FOLLOWING field <-\n     * ->    A4 = 4 bytes alignment, A2 = 2 bytes alignment     <-\n     * -> ----------------------------------------------------- <-\n     */\n        gint8  *struct_name;\n        guint32 struct_name_len, num_members;\n        guint32 next_offset;\n        const char *typecode_name;\n\n        /* Pad-align */\n        LONG_ALIGN(offset);\n\n        /* Get structure name length */\n        struct_name_len = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        /* struct name */\n        struct_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, struct_name_len, ENC_ASCII);\n        offset = check_offset_addition(offset, struct_name_len, tree, NULL, tvb);\n\n\n        if (tk_id == RTI_CDR_TK_ENUM) {\n          typecode_name = \"enum\";\n        } else if (tk_id == RTI_CDR_TK_VALUE_PARAM) {\n          /* guint16 type_modifier; */\n          /* guint32 baseTypeCodeKind; */\n          guint32 baseTypeCodeLength;\n\n          /* Need to read the type modifier and the base type code */\n          typecode_name = \"<sparse type>\";\n          SHORT_ALIGN(offset);\n          /* type_modifier = */ tvb_get_guint16(tvb, offset, encoding);\n          offset += 2;\n\n          LONG_ALIGN(offset);\n          /* baseTypeCodeKind = */ tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n\n          baseTypeCodeLength = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n          offset = check_offset_addition(offset, baseTypeCodeLength, tree, NULL, tvb);\n        } else {\n          typecode_name = \"struct\";\n        }\n\n        if (seq_max_len != -1) {\n          /* We're dissecting a sequence of struct, bypass the seq definition */\n          snprintf(type_name, 40, \"%s\", struct_name);\n          break;\n        }\n        /* Prints it */\n        proto_tree_add_string_format(tree, hf_rtps_struct, tvb, original_offset, retVal, struct_name,\n                                     \"%s%s %s {\", indent_string, typecode_name, struct_name);\n\n        /* PAD align */\n        LONG_ALIGN(offset);\n\n        /* number of members */\n        num_members = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        next_offset = offset;\n        for (i = 0; i < num_members; ++i) {\n          guint8  *member_name;\n          guint32  member_name_len;\n          guint16  member_length;\n          guint32  field_offset_begin;\n\n          /* Safety: this theoretically should be the same already */\n          field_offset_begin = offset = next_offset;\n\n          SHORT_ALIGN(offset);\n\n          /* member's length */\n          member_length = tvb_get_guint16(tvb, offset, encoding);\n          offset += 2;\n          next_offset = offset + member_length;\n\n          /* Name length */\n          LONG_ALIGN(offset);\n          member_name_len = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n\n          /* Name */\n          member_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, member_name_len, ENC_ASCII);\n          offset += member_name_len;\n\n          if (tk_id == RTI_CDR_TK_ENUM) {\n            /* ordinal number */\n            guint32 ordinal_number;\n            LONG_ALIGN(offset);\n            ordinal_number = tvb_get_guint32(tvb, offset, encoding);\n            offset += 4;\n\n            proto_tree_add_string_format(tree, hf_rtps_member_name, tvb, field_offset_begin, (offset-field_offset_begin), member_name,\n                                            \"%s  %s = %d;\", indent_string, member_name, ordinal_number);\n          } else {\n            /* Structs */\n            guint16 member_bitfield;\n            guint8  member_is_pointer;\n            guint8  member_is_key;\n\n            /* is Pointer ? */\n            member_is_pointer = tvb_get_guint8(tvb, offset);\n            offset++;\n\n            /* Bitfield */\n            SHORT_ALIGN(offset);\n            member_bitfield = tvb_get_guint16(tvb, offset, encoding);\n            offset += 2; /* pad will be added by typecode dissector */\n\n            /* is Key ? */\n            member_is_key = tvb_get_guint8(tvb, offset);\n            offset++;\n\n            offset += rtps_util_add_typecode(tree, tvb, offset, encoding,\n                          indent_level+1, member_is_pointer, member_bitfield, member_is_key,\n                          field_offset_begin, member_name, -1, NULL, ndds_40_hack);\n          }\n        }\n        /* Finally prints the name of the struct (if provided) */\n        (void) g_strlcpy(type_name, \"}\", 40);\n        break;\n      }\n\n    case RTI_CDR_TK_WSTRING:\n    case RTI_CDR_TK_STRING: {\n    /* Structure of the typecode data:\n     *  Offset   | Size  | Field                        | Notes\n     * ----------|-------|------------------------------|---------------------\n     *     6     |   2   | pad                          |\n     *     8     |   4   | String length                | 4-bytes aligned\n     */\n        guint32 string_length;\n\n        LONG_ALIGN(offset);\n        string_length = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n        snprintf(type_name, 40, \"%s<%d>\",\n                (tk_id == RTI_CDR_TK_STRING) ? \"string\" : \"wstring\",\n                string_length);\n        break;\n    }\n\n    case RTI_CDR_TK_SEQUENCE: {\n    /* Structure of the typecode data:\n     *\n     * - A4: 4: Sequence max length\n     * - the sequence typecode\n     */\n        guint32 seq_max_len2;\n        LONG_ALIGN(offset);\n        seq_max_len2 = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        /* Recursive decode seq typecode */\n        /*offset += */rtps_util_add_typecode(tree, tvb, offset, encoding, indent_level,\n                          is_pointer, bitfield, is_key, offset_begin, name,\n                          seq_max_len2, NULL, ndds_40_hack);\n        /* Differently from the other typecodes, the line has been already printed */\n        return retVal;\n    }\n\n    case RTI_CDR_TK_ARRAY: {\n    /* Structure of the typecode data:\n     *\n     * - A4: 4: number of dimensions\n     * - A4: 4: dim1\n     * - <A4: 4: dim2>\n     * - ...\n     * - the array typecode\n     */\n        guint32 size[MAX_ARRAY_DIMENSION]; /* Max dimensions */\n        guint32 dim_max;\n\n        LONG_ALIGN(offset);\n        dim_max = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        if (dim_max > MAX_ARRAY_DIMENSION) {\n            /* We don't have a tree item to add expert info to... */\n            dim_max = MAX_ARRAY_DIMENSION;\n        }\n\n        for (i = 0; i < MAX_ARRAY_DIMENSION; ++i) size[i] = 0;\n        for (i = 0; i < dim_max; ++i) {\n          size[i] = tvb_get_guint32(tvb, offset, encoding);\n          offset += 4;\n        }\n\n        /* Recursive decode seq typecode */\n        /*offset += */rtps_util_add_typecode(tree, tvb, offset, encoding,\n                          indent_level, is_pointer, bitfield, is_key, offset_begin,\n                          name, -1, size, ndds_40_hack);\n        /* Differently from the other typecodes, the line has been already printed */\n        return retVal;\n    }\n\n    case RTI_CDR_TK_ALIAS: {\n    /* Structure of the typecode data:\n     *\n     * - A4: 4: alias name size\n     * - A4: 4: alias name\n     * - A4: 4: the alias typecode\n     */\n        guint32 alias_name_length;\n        guint8 *alias_name;\n\n        LONG_ALIGN(offset);\n        alias_name_length = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n        alias_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, alias_name_length, ENC_ASCII);\n        offset = check_offset_addition(offset, alias_name_length, tree, NULL, tvb);\n        (void) g_strlcpy(type_name, alias_name, 40);\n        break;\n    }\n\n\n    /*\n     * VALUETYPES:\n     * - A4: 4: name length\n     * -     n: name\n     * - A2: type modifier\n     * - A4: base type code\n     * - A4: number of members\n     * Foreach member: (it's just like a struct)\n     *\n     */\n    case RTI_CDR_TK_VALUE_PARAM:\n    case RTI_CDR_TK_VALUE: {\n        /* Not fully dissected for now */\n        /* Pad-align */\n        guint32 value_name_len;\n        gint8 *value_name;\n        const char *type_id_name = \"valuetype\";\n        LONG_ALIGN(offset);\n\n        /* Get structure name length */\n        value_name_len = tvb_get_guint32(tvb, offset, encoding);\n        offset += 4;\n\n        /* value name */\n        value_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, value_name_len, ENC_ASCII);\n        offset = check_offset_addition(offset, value_name_len, tree, NULL, tvb);\n\n        if (tk_id == RTI_CDR_TK_VALUE_PARAM) {\n          type_id_name = \"valueparam\";\n        }\n        snprintf(type_name, 40, \"%s '%s'\", type_id_name, value_name);\n        break;\n    }\n  } /* switch(tk_id) */\n\n  /* Sequence print */\n  if (seq_max_len != -1) {\n    proto_tree_add_string_format(tree, hf_rtps_sequence, tvb, offset_begin, (offset-offset_begin), type_name,\n                  \"%ssequence<%s, %d> %s%s;%s\", indent_string, type_name, seq_max_len,\n                  is_pointer ? \"*\" : \"\",\n                  name ? name : \"\",\n                  is_key ? KEY_COMMENT : \"\");\n    return retVal;\n  }\n\n  /* Array print */\n  if (arr_dimension != NULL) {\n    /* Printing an array */\n    wmem_strbuf_t *dim_str = wmem_strbuf_create(wmem_packet_scope());\n    for (i = 0; i < MAX_ARRAY_DIMENSION; ++i) {\n      if (arr_dimension[i] != 0) {\n        wmem_strbuf_append_printf(dim_str, \"[%d]\", arr_dimension[i]);\n      } else {\n        break;\n      }\n    }\n    proto_tree_add_string_format(tree, hf_rtps_array, tvb, offset_begin, (offset-offset_begin), type_name,\n                  \"%s%s %s%s;%s\", indent_string, type_name, name ? name : \"\",\n                  wmem_strbuf_get_str(dim_str), is_key ? KEY_COMMENT : \"\");\n    return retVal;\n  }\n\n  /* Bitfield print */\n  if (bitfield != 0xffff && name != NULL && is_pointer == 0) {\n    proto_tree_add_string_format(tree, hf_rtps_bitfield, tvb, offset_begin, (offset-offset_begin), type_name,\n                  \"%s%s %s:%d;%s\", indent_string, type_name, name,\n                  bitfield, is_key ? KEY_COMMENT : \"\");\n    return retVal;\n  }\n\n  /* Everything else */\n  proto_tree_add_string_format(tree, hf_rtps_datatype, tvb, offset_begin, (offset-offset_begin), type_name,\n                  \"%s%s%s%s%s;%s\", indent_string, type_name,\n                  name ? \" \" : \"\",\n                  is_pointer ? \"*\" : \"\",\n                  name ? name : \"\",\n                  is_key ? KEY_COMMENT : \"\");\n  return retVal;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -116,7 +116,7 @@\n         struct_name_len = tvb_get_guint32(tvb, offset, encoding);\n         offset += 4;\n         struct_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, struct_name_len, ENC_ASCII);\n-        offset += struct_name_len;\n+        offset = check_offset_addition(offset, struct_name_len, tree, NULL, tvb);\n \n         /* - - - - - - -      Default index      - - - - - - - */\n         LONG_ALIGN(offset);\n@@ -197,7 +197,7 @@\n \n           /* Name */\n           member_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, member_name_len, ENC_ASCII);\n-          offset += member_name_len;\n+          offset = check_offset_addition(offset, member_name_len, tree, NULL, tvb);\n \n           /* is Pointer ? */\n           member_is_pointer = tvb_get_guint8(tvb, offset);\n@@ -294,7 +294,7 @@\n \n         /* struct name */\n         struct_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, struct_name_len, ENC_ASCII);\n-        offset += struct_name_len;\n+        offset = check_offset_addition(offset, struct_name_len, tree, NULL, tvb);\n \n \n         if (tk_id == RTI_CDR_TK_ENUM) {\n@@ -316,7 +316,7 @@\n \n           baseTypeCodeLength = tvb_get_guint32(tvb, offset, encoding);\n           offset += 4;\n-          offset += baseTypeCodeLength;\n+          offset = check_offset_addition(offset, baseTypeCodeLength, tree, NULL, tvb);\n         } else {\n           typecode_name = \"struct\";\n         }\n@@ -488,7 +488,7 @@\n         alias_name_length = tvb_get_guint32(tvb, offset, encoding);\n         offset += 4;\n         alias_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, alias_name_length, ENC_ASCII);\n-        offset += alias_name_length;\n+        offset = check_offset_addition(offset, alias_name_length, tree, NULL, tvb);\n         (void) g_strlcpy(type_name, alias_name, 40);\n         break;\n     }\n@@ -519,7 +519,7 @@\n \n         /* value name */\n         value_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, value_name_len, ENC_ASCII);\n-        offset += value_name_len;\n+        offset = check_offset_addition(offset, value_name_len, tree, NULL, tvb);\n \n         if (tk_id == RTI_CDR_TK_VALUE_PARAM) {\n           type_id_name = \"valueparam\";",
        "diff_line_info": {
            "deleted_lines": [
                "        offset += struct_name_len;",
                "          offset += member_name_len;",
                "        offset += struct_name_len;",
                "          offset += baseTypeCodeLength;",
                "        offset += alias_name_length;",
                "        offset += value_name_len;"
            ],
            "added_lines": [
                "        offset = check_offset_addition(offset, struct_name_len, tree, NULL, tvb);",
                "          offset = check_offset_addition(offset, member_name_len, tree, NULL, tvb);",
                "        offset = check_offset_addition(offset, struct_name_len, tree, NULL, tvb);",
                "          offset = check_offset_addition(offset, baseTypeCodeLength, tree, NULL, tvb);",
                "        offset = check_offset_addition(offset, alias_name_length, tree, NULL, tvb);",
                "        offset = check_offset_addition(offset, value_name_len, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/dissect_mutable_member",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint dissect_mutable_member(proto_tree *tree , tvbuff_t * tvb, gint offset, guint encoding, guint encoding_version,\n        dissection_info * info, gboolean * is_end, gboolean show) {\n\n    proto_tree * member;\n    guint32 member_id, member_length;\n    mutable_member_mapping * mapping;\n    gint64 key;\n\n    rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n    if ((member_id & PID_LIST_END) == PID_LIST_END){\n    /* If this is the end of the list, don't add a tree.\n    * If we add more logic here in the future, take into account that\n    * offset is incremented by 4 */\n        offset += 0;\n        *is_end = TRUE;\n        return offset;\n    }\n    if (member_length == 0){\n        return offset;\n    }\n    member = proto_tree_add_subtree_format(tree, tvb, offset, member_length, ett_rtps_dissection_tree,\n        NULL, \"ID: %d, Length: %d\", member_id, member_length);\n\n    {\n        if (info->base_type_id > 0) {\n            key = (info->base_type_id + info->base_type_id * member_id);\n            mapping = (mutable_member_mapping *) wmem_map_lookup(mutable_member_mappings, &(key));\n            if (mapping) { /* the library knows how to dissect this */\n                proto_item_append_text(member, \"(base found 0x%016\" PRIx64 \")\", key);\n                dissect_user_defined(tree, tvb, offset, encoding, encoding_version, NULL, mapping->member_type_id,\n                    mapping->member_name, EXTENSIBILITY_INVALID, offset, 0, mapping->member_id, show);\n                proto_item_set_hidden(member);\n                return offset + member_length;\n            } else\n                proto_item_append_text(member, \"(base not found 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\",\n                  key, info->base_type_id);\n        }\n    }\n\n    key = (info->type_id + info->type_id * member_id);\n    mapping = (mutable_member_mapping *) wmem_map_lookup(mutable_member_mappings, &(key));\n    if (mapping) { /* the library knows how to dissect this */\n        proto_item_append_text(member, \"(found 0x%016\" PRIx64 \")\", key);\n        dissect_user_defined(tree, tvb, offset, encoding, encoding_version, NULL, mapping->member_type_id,\n            mapping->member_name, EXTENSIBILITY_INVALID, offset, 0, mapping->member_id, show);\n\n    } else\n        proto_item_append_text(member, \"(not found 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\",\n                  key, info->type_id);\n    proto_item_set_hidden(member);\n    return offset + member_length;\n}",
        "func": "static gint dissect_mutable_member(proto_tree *tree , tvbuff_t * tvb, gint offset, guint encoding, guint encoding_version,\n        dissection_info * info, gboolean * is_end, gboolean show) {\n\n    proto_tree * member;\n    guint32 member_id, member_length;\n    mutable_member_mapping * mapping;\n    gint64 key;\n\n    rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n    if ((member_id & PID_LIST_END) == PID_LIST_END){\n    /* If this is the end of the list, don't add a tree.\n    * If we add more logic here in the future, take into account that\n    * offset is incremented by 4 */\n        offset += 0;\n        *is_end = TRUE;\n        return offset;\n    }\n    if (member_length == 0){\n        return offset;\n    }\n    member = proto_tree_add_subtree_format(tree, tvb, offset, member_length, ett_rtps_dissection_tree,\n        NULL, \"ID: %d, Length: %d\", member_id, member_length);\n\n    {\n        if (info->base_type_id > 0) {\n            key = (info->base_type_id + info->base_type_id * member_id);\n            mapping = (mutable_member_mapping *) wmem_map_lookup(mutable_member_mappings, &(key));\n            if (mapping) { /* the library knows how to dissect this */\n                proto_item_append_text(member, \"(base found 0x%016\" PRIx64 \")\", key);\n                dissect_user_defined(tree, tvb, offset, encoding, encoding_version, NULL, mapping->member_type_id,\n                    mapping->member_name, EXTENSIBILITY_INVALID, offset, 0, mapping->member_id, show);\n                proto_item_set_hidden(member);\n                return check_offset_addition(offset, member_length, tree, NULL, tvb);\n            } else\n                proto_item_append_text(member, \"(base not found 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\",\n                  key, info->base_type_id);\n        }\n    }\n\n    key = (info->type_id + info->type_id * member_id);\n    mapping = (mutable_member_mapping *) wmem_map_lookup(mutable_member_mappings, &(key));\n    if (mapping) { /* the library knows how to dissect this */\n        proto_item_append_text(member, \"(found 0x%016\" PRIx64 \")\", key);\n        dissect_user_defined(tree, tvb, offset, encoding, encoding_version, NULL, mapping->member_type_id,\n            mapping->member_name, EXTENSIBILITY_INVALID, offset, 0, mapping->member_id, show);\n\n    } else\n        proto_item_append_text(member, \"(not found 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\",\n                  key, info->type_id);\n    proto_item_set_hidden(member);\n    return check_offset_addition(offset, member_length, tree, NULL, tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n                 dissect_user_defined(tree, tvb, offset, encoding, encoding_version, NULL, mapping->member_type_id,\n                     mapping->member_name, EXTENSIBILITY_INVALID, offset, 0, mapping->member_id, show);\n                 proto_item_set_hidden(member);\n-                return offset + member_length;\n+                return check_offset_addition(offset, member_length, tree, NULL, tvb);\n             } else\n                 proto_item_append_text(member, \"(base not found 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\",\n                   key, info->base_type_id);\n@@ -48,5 +48,5 @@\n         proto_item_append_text(member, \"(not found 0x%016\" PRIx64 \" from 0x%016\" PRIx64 \")\",\n                   key, info->type_id);\n     proto_item_set_hidden(member);\n-    return offset + member_length;\n+    return check_offset_addition(offset, member_length, tree, NULL, tvb);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                return offset + member_length;",
                "    return offset + member_length;"
            ],
            "added_lines": [
                "                return check_offset_addition(offset, member_length, tree, NULL, tvb);",
                "    return check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_type_element_string",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static void rtps_util_add_type_element_string(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info _U_) {\n  guint32 member_id = 0, member_length = 0;\n  gint zero_alignment;\n  offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  zero_alignment = offset;\n  rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1, NULL, NULL);\n  offset += member_length;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n  offset += member_length;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  /* dissect Bound */\n  proto_tree_add_item(tree, hf_rtps_type_object_bound, tvb, offset, 4, encoding);\n  offset += member_length;\n}",
        "func": "static void rtps_util_add_type_element_string(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info _U_) {\n  guint32 member_id = 0, member_length = 0;\n  gint zero_alignment;\n  offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  zero_alignment = offset;\n  rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1, NULL, NULL);\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  /* dissect Bound */\n  proto_tree_add_item(tree, hf_rtps_type_object_bound, tvb, offset, 4, encoding);\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,12 +7,12 @@\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   zero_alignment = offset;\n   rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1, NULL, NULL);\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   /* dissect Bound */\n   proto_tree_add_item(tree, hf_rtps_type_object_bound, tvb, offset, 4, encoding);\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += member_length;",
                "  offset += member_length;",
                "  offset += member_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);",
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);",
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_type_element_sequence",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static void rtps_util_add_type_element_sequence(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info) {\n  guint32 member_id = 0, member_length = 0;\n  gint zero_alignment;\n  offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  zero_alignment = offset;\n  rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1 , NULL, &(info->base_type_id));\n  offset += member_length;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n  offset += member_length;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  /* dissect Bound */\n  proto_tree_add_item(tree, hf_rtps_type_object_bound, tvb, offset, 4, encoding);\n  if (info)\n    info->bound = tvb_get_gint32(tvb, offset, encoding);\n}",
        "func": "static void rtps_util_add_type_element_sequence(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info) {\n  guint32 member_id = 0, member_length = 0;\n  gint zero_alignment;\n  offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info);\n\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  zero_alignment = offset;\n  rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1 , NULL, &(info->base_type_id));\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  /* dissect Bound */\n  proto_tree_add_item(tree, hf_rtps_type_object_bound, tvb, offset, 4, encoding);\n  if (info)\n    info->bound = tvb_get_gint32(tvb, offset, encoding);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,10 +7,10 @@\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   zero_alignment = offset;\n   rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1 , NULL, &(info->base_type_id));\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   /* dissect Bound */\n   proto_tree_add_item(tree, hf_rtps_type_object_bound, tvb, offset, 4, encoding);",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += member_length;",
                "  offset += member_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);",
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/get_native_type_cdr_length",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint get_native_type_cdr_length(guint64 member_kind) {\n  guint length = 0;\n\n  switch (member_kind) {\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BOOLEAN_TYPE: {\n          length = 1;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_CHAR_8_TYPE:\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BYTE_TYPE: {\n          length = 1;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_16_TYPE: {\n          length = 2;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_16_TYPE: {\n          length = 2;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ENUMERATION_TYPE:\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_32_TYPE: {\n          length = 4;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_32_TYPE: {\n          length = 4;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_64_TYPE: {\n          length = 8;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_64_TYPE: {\n          length = 8;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_32_TYPE: {\n          length = 4;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_64_TYPE: {\n          length = 8;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_128_TYPE: {\n          length = 16;\n          break;\n      }\n      default: {\n          length = -1;\n          break;\n      }\n  }\n  return length;\n}",
        "func": "static gint get_native_type_cdr_length(guint64 member_kind) {\n  guint length = 0;\n\n  switch (member_kind) {\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BOOLEAN_TYPE: {\n          length = 1;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_CHAR_8_TYPE:\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BYTE_TYPE: {\n          length = 1;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_16_TYPE: {\n          length = 2;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_16_TYPE: {\n          length = 2;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ENUMERATION_TYPE:\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_32_TYPE: {\n          length = 4;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_32_TYPE: {\n          length = 4;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_64_TYPE: {\n          length = 8;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_64_TYPE: {\n          length = 8;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_32_TYPE: {\n          length = 4;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_64_TYPE: {\n          length = 8;\n          break;\n      }\n      case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_128_TYPE: {\n          length = 16;\n          break;\n      }\n      default: {\n          /* XXX We should probably add expert info, but make sure our offset advances for now. */\n          length = 1;\n          break;\n      }\n  }\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,8 @@\n           break;\n       }\n       default: {\n-          length = -1;\n+          /* XXX We should probably add expert info, but make sure our offset advances for now. */\n+          length = 1;\n           break;\n       }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "          length = -1;"
            ],
            "added_lines": [
                "          /* XXX We should probably add expert info, but make sure our offset advances for now. */",
                "          length = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/get_native_type_cdr_alignment",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint get_native_type_cdr_alignment(guint64 member_kind, gint encapsulation_version) {\n  guint align = 0;\n\n  switch (member_kind) {\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BOOLEAN_TYPE: {\n    align = 1;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_CHAR_8_TYPE:\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BYTE_TYPE: {\n    align = 1;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_16_TYPE: {\n    align = 2;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_16_TYPE: {\n    align = 2;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ENUMERATION_TYPE:\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_32_TYPE: {\n    align = 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_32_TYPE: {\n    align = 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_64_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_64_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_32_TYPE: {\n    align = 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_64_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_128_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  default: {\n    align = -1;\n    break;\n  }\n  }\n  return align;\n}",
        "func": "static gint get_native_type_cdr_alignment(guint64 member_kind, gint encapsulation_version) {\n  guint align = 0;\n\n  switch (member_kind) {\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BOOLEAN_TYPE: {\n    align = 1;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_CHAR_8_TYPE:\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_BYTE_TYPE: {\n    align = 1;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_16_TYPE: {\n    align = 2;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_16_TYPE: {\n    align = 2;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_ENUMERATION_TYPE:\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_32_TYPE: {\n    align = 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_32_TYPE: {\n    align = 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_INT_64_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_UINT_64_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_32_TYPE: {\n    align = 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_64_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  case RTI_CDR_TYPE_OBJECT_TYPE_KIND_FLOAT_128_TYPE: {\n    align = (encapsulation_version == 1) ? 8 : 4;\n    break;\n  }\n  default: {\n    align = 1;\n    break;\n  }\n  }\n  return align;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n     break;\n   }\n   default: {\n-    align = -1;\n+    align = 1;\n     break;\n   }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "    align = -1;"
            ],
            "added_lines": [
                "    align = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_type_element_array",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static void rtps_util_add_type_element_array(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info _U_) {\n  proto_tree * bound_tree;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number, i;\n  gint zero_alignment, offset_tmp;\n  offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info);\n\n  /* Dissect Collection Type */\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  zero_alignment = offset;\n  rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1, NULL, &(info->base_type_id));\n  offset += member_length;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n  offset += member_length;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n\n  /* dissect Bound sequence */\n\n  offset_tmp = offset;\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  bound_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n              ett_rtps_type_bound_list, NULL, \"Bounds (%d elements)\",\n              long_number);\n  offset_tmp += 4;\n  for (i = 0; i < long_number ; i++) {\n    proto_tree_add_item(bound_tree, hf_rtps_type_object_bound, tvb, offset_tmp, 4, encoding);\n    if (info) info->bound = tvb_get_gint32(tvb, offset_tmp, encoding);\n    if (info) info->num_elements = tvb_get_gint32(tvb, offset_tmp, encoding);\n\n    offset_tmp += 4;\n  }\n}",
        "func": "static void rtps_util_add_type_element_array(proto_tree *tree,\n        tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info _U_) {\n  proto_tree * bound_tree;\n  guint32 member_id = 0, member_length = 0;\n  guint32 long_number, i;\n  gint zero_alignment, offset_tmp;\n  offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info);\n\n  /* Dissect Collection Type */\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  zero_alignment = offset;\n  rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1, NULL, &(info->base_type_id));\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n  proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n\n  /* dissect Bound sequence */\n\n  offset_tmp = offset;\n  long_number = tvb_get_guint32(tvb, offset_tmp, encoding);\n  bound_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length,\n              ett_rtps_type_bound_list, NULL, \"Bounds (%d elements)\",\n              long_number);\n  offset_tmp += 4;\n  for (i = 0; i < long_number ; i++) {\n    proto_tree_add_item(bound_tree, hf_rtps_type_object_bound, tvb, offset_tmp, 4, encoding);\n    if (info) info->bound = tvb_get_gint32(tvb, offset_tmp, encoding);\n    if (info) info->num_elements = tvb_get_gint32(tvb, offset_tmp, encoding);\n\n    offset_tmp += 4;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,10 +10,10 @@\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   zero_alignment = offset;\n   rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1, NULL, &(info->base_type_id));\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n   proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding);\n-  offset += member_length;\n+  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length);\n \n   /* dissect Bound sequence */",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += member_length;",
                "  offset += member_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);",
                "  offset = check_offset_addition(offset, member_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_rti_service_request",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint rtps_util_add_rti_service_request(proto_tree * tree, packet_info *pinfo, tvbuff_t * tvb,\n        gint offset, const guint encoding, guint32 service_id) {\n  switch (service_id) {\n    case RTI_SERVICE_REQUEST_ID_TOPIC_QUERY:\n      offset = rtps_util_add_rti_topic_query_service_request(tree, tvb, offset + 4,\n                  encoding);\n      break;\n    case RTI_SERVICE_REQUEST_ID_LOCATOR_REACHABILITY:\n      offset = rtps_util_add_rti_locator_reachability_service_request(tree, pinfo, tvb, offset + 4,\n                  encoding);\n      break;\n    case RTI_SERVICE_REQUEST_ID_UNKNOWN: {\n      guint32 seq_length;\n      seq_length = tvb_get_guint32(tvb, offset, encoding);\n      proto_tree_add_item(tree, hf_rtps_srm_request_body,\n                    tvb, offset + 4, seq_length, ENC_NA);\n      offset += (seq_length + 4);\n      break;\n    }\n  }\n  return offset;\n}",
        "func": "static gint rtps_util_add_rti_service_request(proto_tree * tree, packet_info *pinfo, tvbuff_t * tvb,\n        gint offset, const guint encoding, guint32 service_id) {\n  switch (service_id) {\n    case RTI_SERVICE_REQUEST_ID_TOPIC_QUERY:\n      offset = rtps_util_add_rti_topic_query_service_request(tree, tvb, offset + 4,\n                  encoding);\n      break;\n    case RTI_SERVICE_REQUEST_ID_LOCATOR_REACHABILITY:\n      offset = rtps_util_add_rti_locator_reachability_service_request(tree, pinfo, tvb, offset + 4,\n                  encoding);\n      break;\n    case RTI_SERVICE_REQUEST_ID_UNKNOWN: {\n      guint32 seq_length;\n      seq_length = tvb_get_guint32(tvb, offset, encoding);\n      proto_tree_add_item(tree, hf_rtps_srm_request_body,\n                    tvb, offset + 4, seq_length, ENC_NA);\n      offset = check_offset_addition(offset, seq_length, tree, NULL, tvb);\n      offset = check_offset_addition(offset, 4, tree, NULL, tvb);\n      break;\n    }\n  }\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,8 @@\n       seq_length = tvb_get_guint32(tvb, offset, encoding);\n       proto_tree_add_item(tree, hf_rtps_srm_request_body,\n                     tvb, offset + 4, seq_length, ENC_NA);\n-      offset += (seq_length + 4);\n+      offset = check_offset_addition(offset, seq_length, tree, NULL, tvb);\n+      offset = check_offset_addition(offset, 4, tree, NULL, tvb);\n       break;\n     }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "      offset += (seq_length + 4);"
            ],
            "added_lines": [
                "      offset = check_offset_addition(offset, seq_length, tree, NULL, tvb);",
                "      offset = check_offset_addition(offset, 4, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0411",
        "func_name": "wireshark/rtps_util_add_rti_topic_query_service_request",
        "description": "Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b0cf030b30a9b63e678fee294321642beb42b724",
        "commit_title": "RTPS: Add offset overflow checking.",
        "commit_text": " Add and use check_offset_addition, which adds an expert item and throws an exception if we're about to overflow our offset.  Fixes #18737 ",
        "func_before": "static gint rtps_util_add_rti_topic_query_service_request(proto_tree * tree,\n        tvbuff_t * tvb, gint offset, guint encoding) {\n    /*\n    struct TopicQuerySelection {\n        string filter_class_name; //@Optional 0\n        string filter_expression; // 1\n        sequence<string> filter_parameters;\n    }; //@top-level false\n    //@Extensibility MUTABLE_EXTENSIBILITY\n\n    struct TopicQueryData {\n        TopicQuerySelection topic_query_selection;\n        SequenceNumber_t sync_sequence_number;\n        string topic_name;\n        GUID_t original_related_reader_guid;\n    }; //@top-level false\n    //@Extensibility MUTABLE_EXTENSIBILITY\n    */\n  proto_tree * topic_query_tree, * topic_query_selection_tree, *topic_query_filter_params_tree;\n  proto_item * ti;\n  guint16 encapsulation_id, encapsulation_opt;\n  guint32 param_id, param_length, param_length_2, num_filter_params;\n  gint alignment_zero, tmp_offset;\n  guint32 i;\n  topic_query_tree = proto_tree_add_subtree(tree, tvb, offset,\n      0 /* To be defined */, ett_rtps_topic_query_tree, &ti, \"Topic Query Data\");\n\n  /* Encapsulation Id */\n  encapsulation_id =  tvb_get_ntohs(tvb, offset);   /* Always big endian */\n  proto_tree_add_uint(topic_query_tree, hf_rtps_encapsulation_id,\n        tvb, offset, 2, encapsulation_id);\n  offset += 2;\n  encoding = get_encapsulation_endianness(encapsulation_id);\n  /* Encapsulation length (or option) */\n  encapsulation_opt =  tvb_get_ntohs(tvb, offset);    /* Always big endian */\n  proto_tree_add_uint(topic_query_tree, hf_rtps_encapsulation_options, tvb,\n        offset, 2, encapsulation_opt);\n  offset += 2;\n  alignment_zero = offset;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n  tmp_offset = offset;\n  {\n    /* TopicQuerySelection */\n    topic_query_selection_tree = proto_tree_add_subtree(topic_query_tree, tvb, tmp_offset,\n            0 /* To be defined */, ett_rtps_topic_query_selection_tree, &ti, \"Topic Query Selection\");\n\n    SHORT_ALIGN_ZERO(tmp_offset,alignment_zero);\n    rtps_util_dissect_parameter_header(tvb, &tmp_offset, encoding, &param_id, &param_length_2);\n    if (param_id == 0) { /* Optional string filter_class_name */\n      LONG_ALIGN_ZERO(tmp_offset, alignment_zero);\n      rtps_util_add_string(topic_query_selection_tree, tvb, tmp_offset,\n                           hf_rtps_topic_query_selection_filter_class_name, encoding);\n    }\n    tmp_offset += param_length_2;\n\n    SHORT_ALIGN_ZERO(tmp_offset,alignment_zero);\n    rtps_util_dissect_parameter_header(tvb, &tmp_offset, encoding, &param_id, &param_length_2);\n\n    LONG_ALIGN_ZERO(tmp_offset, alignment_zero);\n    tmp_offset = rtps_util_add_string(topic_query_selection_tree, tvb, tmp_offset,\n            hf_rtps_topic_query_selection_filter_expression, encoding);\n\n    SHORT_ALIGN_ZERO(tmp_offset,alignment_zero);\n    rtps_util_dissect_parameter_header(tvb, &tmp_offset, encoding, &param_id, &param_length_2);\n\n    num_filter_params = tvb_get_guint32(tvb, tmp_offset, encoding);\n    proto_tree_add_item(topic_query_selection_tree, hf_rtps_topic_query_selection_num_parameters,\n                tvb, tmp_offset, 4, encoding);\n    topic_query_filter_params_tree = proto_tree_add_subtree_format(topic_query_selection_tree, tvb,\n                tmp_offset + 4, 0 /* To be defined */, ett_rtps_topic_query_filter_params_tree, &ti,\n                \"Filter Parameters (size = %u)\", num_filter_params);\n    tmp_offset += 4;\n    for (i = 0; i < num_filter_params; ++i) {\n      guint32 string_size;\n      gchar * retVal;\n      LONG_ALIGN_ZERO(tmp_offset, alignment_zero);\n      string_size = tvb_get_guint32(tvb, tmp_offset, encoding);\n      retVal = tvb_get_string_enc(wmem_packet_scope(), tvb, tmp_offset+4, string_size, ENC_ASCII);\n\n      proto_tree_add_string_format(topic_query_filter_params_tree,\n            hf_rtps_topic_query_selection_filter_parameter, tvb,\n            tmp_offset, string_size+4, retVal, \"%s[%d]: %s\", \"Filter Parameter\", i, retVal);\n\n      tmp_offset += (4 + string_size);\n    }\n  }\n  offset += param_length;\n  SHORT_ALIGN_ZERO(offset,alignment_zero);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n\n  rtps_util_add_seq_number(topic_query_tree, tvb, offset, encoding, \"Sync Sequence Number\");\n  offset += param_length;\n\n  SHORT_ALIGN_ZERO(offset,alignment_zero);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n\n  LONG_ALIGN_ZERO(offset, alignment_zero);\n  rtps_util_add_string(topic_query_tree, tvb, offset,\n            hf_rtps_topic_query_topic_name, encoding);\n  offset += param_length;\n\n  SHORT_ALIGN_ZERO(offset,alignment_zero);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n\n  rtps_util_add_generic_guid_v2(topic_query_tree, tvb, offset,\n          hf_rtps_topic_query_original_related_reader_guid,\n          hf_rtps_param_host_id, hf_rtps_param_app_id, hf_rtps_param_instance_id,\n          hf_rtps_param_entity, hf_rtps_param_entity_key, hf_rtps_param_hf_entity_kind,\n          NULL);\n\n  offset += param_length;\n\n  return offset;\n}",
        "func": "static gint rtps_util_add_rti_topic_query_service_request(proto_tree * tree,\n        tvbuff_t * tvb, gint offset, guint encoding) {\n    /*\n    struct TopicQuerySelection {\n        string filter_class_name; //@Optional 0\n        string filter_expression; // 1\n        sequence<string> filter_parameters;\n    }; //@top-level false\n    //@Extensibility MUTABLE_EXTENSIBILITY\n\n    struct TopicQueryData {\n        TopicQuerySelection topic_query_selection;\n        SequenceNumber_t sync_sequence_number;\n        string topic_name;\n        GUID_t original_related_reader_guid;\n    }; //@top-level false\n    //@Extensibility MUTABLE_EXTENSIBILITY\n    */\n  proto_tree * topic_query_tree, * topic_query_selection_tree, *topic_query_filter_params_tree;\n  proto_item * ti;\n  guint16 encapsulation_id, encapsulation_opt;\n  guint32 param_id, param_length, param_length_2, num_filter_params;\n  gint alignment_zero, tmp_offset;\n  guint32 i;\n  topic_query_tree = proto_tree_add_subtree(tree, tvb, offset,\n      0 /* To be defined */, ett_rtps_topic_query_tree, &ti, \"Topic Query Data\");\n\n  /* Encapsulation Id */\n  encapsulation_id =  tvb_get_ntohs(tvb, offset);   /* Always big endian */\n  proto_tree_add_uint(topic_query_tree, hf_rtps_encapsulation_id,\n        tvb, offset, 2, encapsulation_id);\n  offset += 2;\n  encoding = get_encapsulation_endianness(encapsulation_id);\n  /* Encapsulation length (or option) */\n  encapsulation_opt =  tvb_get_ntohs(tvb, offset);    /* Always big endian */\n  proto_tree_add_uint(topic_query_tree, hf_rtps_encapsulation_options, tvb,\n        offset, 2, encapsulation_opt);\n  offset += 2;\n  alignment_zero = offset;\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n  tmp_offset = offset;\n  {\n    /* TopicQuerySelection */\n    topic_query_selection_tree = proto_tree_add_subtree(topic_query_tree, tvb, tmp_offset,\n            0 /* To be defined */, ett_rtps_topic_query_selection_tree, &ti, \"Topic Query Selection\");\n\n    SHORT_ALIGN_ZERO(tmp_offset,alignment_zero);\n    rtps_util_dissect_parameter_header(tvb, &tmp_offset, encoding, &param_id, &param_length_2);\n    if (param_id == 0) { /* Optional string filter_class_name */\n      LONG_ALIGN_ZERO(tmp_offset, alignment_zero);\n      rtps_util_add_string(topic_query_selection_tree, tvb, tmp_offset,\n                           hf_rtps_topic_query_selection_filter_class_name, encoding);\n    }\n    tmp_offset += param_length_2;\n\n    SHORT_ALIGN_ZERO(tmp_offset,alignment_zero);\n    rtps_util_dissect_parameter_header(tvb, &tmp_offset, encoding, &param_id, &param_length_2);\n\n    LONG_ALIGN_ZERO(tmp_offset, alignment_zero);\n    tmp_offset = rtps_util_add_string(topic_query_selection_tree, tvb, tmp_offset,\n            hf_rtps_topic_query_selection_filter_expression, encoding);\n\n    SHORT_ALIGN_ZERO(tmp_offset,alignment_zero);\n    rtps_util_dissect_parameter_header(tvb, &tmp_offset, encoding, &param_id, &param_length_2);\n\n    num_filter_params = tvb_get_guint32(tvb, tmp_offset, encoding);\n    proto_tree_add_item(topic_query_selection_tree, hf_rtps_topic_query_selection_num_parameters,\n                tvb, tmp_offset, 4, encoding);\n    topic_query_filter_params_tree = proto_tree_add_subtree_format(topic_query_selection_tree, tvb,\n                tmp_offset + 4, 0 /* To be defined */, ett_rtps_topic_query_filter_params_tree, &ti,\n                \"Filter Parameters (size = %u)\", num_filter_params);\n    tmp_offset += 4;\n    for (i = 0; i < num_filter_params; ++i) {\n      guint32 string_size;\n      gchar * retVal;\n      LONG_ALIGN_ZERO(tmp_offset, alignment_zero);\n      string_size = tvb_get_guint32(tvb, tmp_offset, encoding);\n      retVal = tvb_get_string_enc(wmem_packet_scope(), tvb, tmp_offset+4, string_size, ENC_ASCII);\n\n      proto_tree_add_string_format(topic_query_filter_params_tree,\n            hf_rtps_topic_query_selection_filter_parameter, tvb,\n            tmp_offset, string_size+4, retVal, \"%s[%d]: %s\", \"Filter Parameter\", i, retVal);\n\n      tmp_offset += (4 + string_size);\n    }\n  }\n  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);\n  SHORT_ALIGN_ZERO(offset,alignment_zero);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n\n  rtps_util_add_seq_number(topic_query_tree, tvb, offset, encoding, \"Sync Sequence Number\");\n  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);\n\n  SHORT_ALIGN_ZERO(offset,alignment_zero);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n\n  LONG_ALIGN_ZERO(offset, alignment_zero);\n  rtps_util_add_string(topic_query_tree, tvb, offset,\n            hf_rtps_topic_query_topic_name, encoding);\n  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);\n\n  SHORT_ALIGN_ZERO(offset,alignment_zero);\n  rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n\n  rtps_util_add_generic_guid_v2(topic_query_tree, tvb, offset,\n          hf_rtps_topic_query_original_related_reader_guid,\n          hf_rtps_param_host_id, hf_rtps_param_app_id, hf_rtps_param_instance_id,\n          hf_rtps_param_entity, hf_rtps_param_entity_key, hf_rtps_param_hf_entity_kind,\n          NULL);\n\n  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -84,12 +84,12 @@\n       tmp_offset += (4 + string_size);\n     }\n   }\n-  offset += param_length;\n+  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);\n   SHORT_ALIGN_ZERO(offset,alignment_zero);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n \n   rtps_util_add_seq_number(topic_query_tree, tvb, offset, encoding, \"Sync Sequence Number\");\n-  offset += param_length;\n+  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);\n \n   SHORT_ALIGN_ZERO(offset,alignment_zero);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n@@ -97,7 +97,7 @@\n   LONG_ALIGN_ZERO(offset, alignment_zero);\n   rtps_util_add_string(topic_query_tree, tvb, offset,\n             hf_rtps_topic_query_topic_name, encoding);\n-  offset += param_length;\n+  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);\n \n   SHORT_ALIGN_ZERO(offset,alignment_zero);\n   rtps_util_dissect_parameter_header(tvb, &offset, encoding, &param_id, &param_length);\n@@ -108,7 +108,7 @@\n           hf_rtps_param_entity, hf_rtps_param_entity_key, hf_rtps_param_hf_entity_kind,\n           NULL);\n \n-  offset += param_length;\n+  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);\n \n   return offset;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  offset += param_length;",
                "  offset += param_length;",
                "  offset += param_length;",
                "  offset += param_length;"
            ],
            "added_lines": [
                "  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);",
                "  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);",
                "  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);",
                "  offset = check_offset_addition(offset, param_length, tree, NULL, tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7321",
        "func_name": "wireshark/dissect_thrift_map",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thrift.c had a large loop that was addressed by not proceeding with dissection after encountering an unexpected type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c784d551ad50864de1035ce54e72837301cf6aca",
        "commit_title": "Thrift: stop dissection when encountering an unknown/unexpected type",
        "commit_text": " Let's add an expert info, and set offset to the end of the current tvb.  Bug: 14379 (cherry picked from commit 8ab3060aace7b20c2845f2f725d4f306cca61dd4)  Conflicts: \tepan/dissectors/packet-thrift.c (cherry picked from commit 57e218cdb2729aebecb6494a786de31ba4a3698b)",
        "func_before": "static int\ndissect_thrift_map(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int offset, int length)\n{\n    proto_tree *sub_tree;\n    proto_item *ti;\n    guint32 ktype;\n    guint32 vtype;\n    guint32 map_len;\n    int start_offset = offset, i;\n\n    sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, &ti, \"Map\");\n    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &ktype);\n    offset++;\n    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &vtype);\n    offset++;\n    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_num_map_item, tvb, offset, 4, ENC_BIG_ENDIAN, &map_len);\n    offset += 4;\n\n    for (i = 0; i < (int)map_len; ++i) {\n        offset = dissect_thrift_type(tvb, pinfo, sub_tree, ktype, offset, length);\n        offset = dissect_thrift_type(tvb, pinfo, sub_tree, vtype, offset, length);\n    }\n    map_len = offset - start_offset;\n    proto_item_set_len(ti, map_len);\n\n    return offset;\n}",
        "func": "static int\ndissect_thrift_map(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int offset, int length)\n{\n    proto_tree *sub_tree;\n    proto_item *ti, *ktype_pi, *vtype_pi;\n    guint32 ktype;\n    guint32 vtype;\n    guint32 map_len;\n    int start_offset = offset, i;\n\n    sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, &ti, \"Map\");\n    ktype_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &ktype);\n    offset++;\n    vtype_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &vtype);\n    offset++;\n    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_num_map_item, tvb, offset, 4, ENC_BIG_ENDIAN, &map_len);\n    offset += 4;\n\n    for (i = 0; i < (int)map_len; ++i) {\n        if (dissect_thrift_type(tvb, pinfo, sub_tree, ktype_pi, ktype, &offset, length) < 0) {\n            break;\n        }\n        if (dissect_thrift_type(tvb, pinfo, sub_tree, vtype_pi, vtype, &offset, length) < 0) {\n            break;\n        }\n    }\n    map_len = offset - start_offset;\n    proto_item_set_len(ti, map_len);\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,23 +2,27 @@\n dissect_thrift_map(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int offset, int length)\n {\n     proto_tree *sub_tree;\n-    proto_item *ti;\n+    proto_item *ti, *ktype_pi, *vtype_pi;\n     guint32 ktype;\n     guint32 vtype;\n     guint32 map_len;\n     int start_offset = offset, i;\n \n     sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, &ti, \"Map\");\n-    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &ktype);\n+    ktype_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &ktype);\n     offset++;\n-    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &vtype);\n+    vtype_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &vtype);\n     offset++;\n     proto_tree_add_item_ret_uint(sub_tree, hf_thrift_num_map_item, tvb, offset, 4, ENC_BIG_ENDIAN, &map_len);\n     offset += 4;\n \n     for (i = 0; i < (int)map_len; ++i) {\n-        offset = dissect_thrift_type(tvb, pinfo, sub_tree, ktype, offset, length);\n-        offset = dissect_thrift_type(tvb, pinfo, sub_tree, vtype, offset, length);\n+        if (dissect_thrift_type(tvb, pinfo, sub_tree, ktype_pi, ktype, &offset, length) < 0) {\n+            break;\n+        }\n+        if (dissect_thrift_type(tvb, pinfo, sub_tree, vtype_pi, vtype, &offset, length) < 0) {\n+            break;\n+        }\n     }\n     map_len = offset - start_offset;\n     proto_item_set_len(ti, map_len);",
        "diff_line_info": {
            "deleted_lines": [
                "    proto_item *ti;",
                "    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &ktype);",
                "    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &vtype);",
                "        offset = dissect_thrift_type(tvb, pinfo, sub_tree, ktype, offset, length);",
                "        offset = dissect_thrift_type(tvb, pinfo, sub_tree, vtype, offset, length);"
            ],
            "added_lines": [
                "    proto_item *ti, *ktype_pi, *vtype_pi;",
                "    ktype_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &ktype);",
                "    vtype_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &vtype);",
                "        if (dissect_thrift_type(tvb, pinfo, sub_tree, ktype_pi, ktype, &offset, length) < 0) {",
                "            break;",
                "        }",
                "        if (dissect_thrift_type(tvb, pinfo, sub_tree, vtype_pi, vtype, &offset, length) < 0) {",
                "            break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7321",
        "func_name": "wireshark/dissect_thrift_list",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thrift.c had a large loop that was addressed by not proceeding with dissection after encountering an unexpected type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c784d551ad50864de1035ce54e72837301cf6aca",
        "commit_title": "Thrift: stop dissection when encountering an unknown/unexpected type",
        "commit_text": " Let's add an expert info, and set offset to the end of the current tvb.  Bug: 14379 (cherry picked from commit 8ab3060aace7b20c2845f2f725d4f306cca61dd4)  Conflicts: \tepan/dissectors/packet-thrift.c (cherry picked from commit 57e218cdb2729aebecb6494a786de31ba4a3698b)",
        "func_before": "static int\ndissect_thrift_list(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int offset, int length)\n{\n    proto_tree *sub_tree;\n    proto_item *ti;\n    guint32 type;\n    int start_offset = offset, i;\n    guint32 list_len;\n\n    sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, &ti, \"List\");\n    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);\n    offset++;\n    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_num_list_item, tvb, offset, 4, ENC_BIG_ENDIAN, &list_len);\n    offset += 4;\n\n    for (i = 0; i < (int)list_len; ++i) {\n        offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length);\n    }\n    list_len = offset - start_offset;\n    proto_item_set_len(ti, list_len);\n\n    return offset;\n\n}",
        "func": "static int\ndissect_thrift_list(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int offset, int length)\n{\n    proto_tree *sub_tree;\n    proto_item *ti, *type_pi;\n    guint32 type;\n    int start_offset = offset, i;\n    guint32 list_len;\n\n    sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, &ti, \"List\");\n    type_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);\n    offset++;\n    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_num_list_item, tvb, offset, 4, ENC_BIG_ENDIAN, &list_len);\n    offset += 4;\n\n    for (i = 0; i < (int)list_len; ++i) {\n        if (dissect_thrift_type(tvb, pinfo, sub_tree, type_pi, type, &offset, length) < 0) {\n            break;\n        }\n    }\n    list_len = offset - start_offset;\n    proto_item_set_len(ti, list_len);\n\n    return offset;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,19 +2,21 @@\n dissect_thrift_list(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int offset, int length)\n {\n     proto_tree *sub_tree;\n-    proto_item *ti;\n+    proto_item *ti, *type_pi;\n     guint32 type;\n     int start_offset = offset, i;\n     guint32 list_len;\n \n     sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, &ti, \"List\");\n-    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);\n+    type_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);\n     offset++;\n     proto_tree_add_item_ret_uint(sub_tree, hf_thrift_num_list_item, tvb, offset, 4, ENC_BIG_ENDIAN, &list_len);\n     offset += 4;\n \n     for (i = 0; i < (int)list_len; ++i) {\n-        offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length);\n+        if (dissect_thrift_type(tvb, pinfo, sub_tree, type_pi, type, &offset, length) < 0) {\n+            break;\n+        }\n     }\n     list_len = offset - start_offset;\n     proto_item_set_len(ti, list_len);",
        "diff_line_info": {
            "deleted_lines": [
                "    proto_item *ti;",
                "    proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);",
                "        offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length);"
            ],
            "added_lines": [
                "    proto_item *ti, *type_pi;",
                "    type_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);",
                "        if (dissect_thrift_type(tvb, pinfo, sub_tree, type_pi, type, &offset, length) < 0) {",
                "            break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7321",
        "func_name": "wireshark/dissect_thrift_struct",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thrift.c had a large loop that was addressed by not proceeding with dissection after encountering an unexpected type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c784d551ad50864de1035ce54e72837301cf6aca",
        "commit_title": "Thrift: stop dissection when encountering an unknown/unexpected type",
        "commit_text": " Let's add an expert info, and set offset to the end of the current tvb.  Bug: 14379 (cherry picked from commit 8ab3060aace7b20c2845f2f725d4f306cca61dd4)  Conflicts: \tepan/dissectors/packet-thrift.c (cherry picked from commit 57e218cdb2729aebecb6494a786de31ba4a3698b)",
        "func_before": "static int\ndissect_thrift_struct(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int offset, int length)\n{\n    proto_tree *sub_tree;\n    proto_item *ti;\n    guint8 type;\n    int start_offset = offset, struct_len;\n\n    sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, &ti, \"Struct\");\n\n    if (offset >= length) {\n        /* ensure this function is never a non-op */\n        return length;\n    }\n\n    while (offset < length) {\n        /* Read type and field id */\n        type = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n        if (type == 0){\n            /* T_STOP */\n            struct_len = offset - start_offset;\n            proto_item_set_len(ti, struct_len);\n            break;\n        }\n        proto_tree_add_item(sub_tree, hf_thrift_fid, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length);\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_thrift_struct(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int offset, int length)\n{\n    proto_tree *sub_tree;\n    proto_item *ti, *type_pi;\n    guint32 type;\n    int start_offset = offset, struct_len;\n\n    sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, &ti, \"Struct\");\n\n    if (offset >= length) {\n        /* ensure this function is never a non-op */\n        return length;\n    }\n\n    while (offset < length) {\n        /* Read type and field id */\n        type_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);\n        offset++;\n        if (type == 0){\n            /* T_STOP */\n            struct_len = offset - start_offset;\n            proto_item_set_len(ti, struct_len);\n            break;\n        }\n        proto_tree_add_item(sub_tree, hf_thrift_fid, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        if (dissect_thrift_type(tvb, pinfo, sub_tree, type_pi, type, &offset, length) < 0) {\n            break;\n        }\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,8 @@\n dissect_thrift_struct(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int offset, int length)\n {\n     proto_tree *sub_tree;\n-    proto_item *ti;\n-    guint8 type;\n+    proto_item *ti, *type_pi;\n+    guint32 type;\n     int start_offset = offset, struct_len;\n \n     sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, &ti, \"Struct\");\n@@ -15,8 +15,7 @@\n \n     while (offset < length) {\n         /* Read type and field id */\n-        type = tvb_get_guint8(tvb, offset);\n-        proto_tree_add_item(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n+        type_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);\n         offset++;\n         if (type == 0){\n             /* T_STOP */\n@@ -26,7 +25,9 @@\n         }\n         proto_tree_add_item(sub_tree, hf_thrift_fid, tvb, offset, 2, ENC_BIG_ENDIAN);\n         offset += 2;\n-        offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length);\n+        if (dissect_thrift_type(tvb, pinfo, sub_tree, type_pi, type, &offset, length) < 0) {\n+            break;\n+        }\n     }\n \n     return offset;",
        "diff_line_info": {
            "deleted_lines": [
                "    proto_item *ti;",
                "    guint8 type;",
                "        type = tvb_get_guint8(tvb, offset);",
                "        proto_tree_add_item(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
                "        offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length);"
            ],
            "added_lines": [
                "    proto_item *ti, *type_pi;",
                "    guint32 type;",
                "        type_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);",
                "        if (dissect_thrift_type(tvb, pinfo, sub_tree, type_pi, type, &offset, length) < 0) {",
                "            break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7321",
        "func_name": "wireshark/proto_register_thrift",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thrift.c had a large loop that was addressed by not proceeding with dissection after encountering an unexpected type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c784d551ad50864de1035ce54e72837301cf6aca",
        "commit_title": "Thrift: stop dissection when encountering an unknown/unexpected type",
        "commit_text": " Let's add an expert info, and set offset to the end of the current tvb.  Bug: 14379 (cherry picked from commit 8ab3060aace7b20c2845f2f725d4f306cca61dd4)  Conflicts: \tepan/dissectors/packet-thrift.c (cherry picked from commit 57e218cdb2729aebecb6494a786de31ba4a3698b)",
        "func_before": "void proto_register_thrift(void) {\n\n    static hf_register_info hf[] = {\n        { &hf_thrift_version,\n        { \"Version\", \"thrift.version\",\n        FT_UINT16, BASE_HEX, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_mtype,\n        { \"Message type\", \"thrift.mtype\",\n        FT_UINT8, BASE_DEC, VALS(thrift_mtype_vals), 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_str_len,\n        { \"Length\", \"thrift.str_len\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_method,\n        { \"Method\", \"thrift.method\",\n        FT_STRING, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_seq_id,\n        { \"Sequence Id\", \"thrift.seq_id\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_type,\n        { \"Type\", \"thrift.type\",\n        FT_UINT8, BASE_DEC, VALS(thrift_type_vals), 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_fid,\n        { \"Field Id\", \"thrift.fid\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_i16,\n        { \"Integer16\", \"thrift.i16\",\n        FT_INT16, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_i32,\n        { \"Integer32\", \"thrift.i32\",\n        FT_INT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_utf7str,\n        { \"UTF7 String\", \"thrift.utf7str\",\n        FT_STRING, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_num_list_item,\n        { \"Number of List Items\", \"thrift.num_list_item\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_num_map_item,\n        { \"Number of Map Items\", \"thrift.num_map_item\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_bool,\n        { \"Boolean\", \"thrift.bool\",\n        FT_UINT8, BASE_DEC, VALS(thrift_bool_vals), 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_byte,\n        { \"Byte\", \"thrift.byte\",\n        FT_UINT8, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_i64,\n        { \"Integer64\", \"thrift.i64\",\n        FT_INT64, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_u64,\n        { \"Integer64\", \"thrift.u64\",\n        FT_UINT64, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_double,\n        { \"Double\", \"thrift.double\",\n        FT_DOUBLE, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n        },\n    };\n\n\n    /* setup protocol subtree arrays */\n    static gint* ett[] = {\n        &ett_thrift,\n    };\n\n    /* Register protocol name and description */\n    proto_thrift = proto_register_protocol(\"Thrift Protocol\", \"Thrift\", \"thrift\");\n\n    /* register field array */\n    proto_register_field_array(proto_thrift, hf, array_length(hf));\n\n    /* register subtree array */\n    proto_register_subtree_array(ett, array_length(ett));\n\n    /* register dissector */\n    /*register_dissector(\"thrift\", dissect_thrift, proto_thrift); */\n}",
        "func": "void proto_register_thrift(void) {\n\n    static hf_register_info hf[] = {\n        { &hf_thrift_version,\n        { \"Version\", \"thrift.version\",\n        FT_UINT16, BASE_HEX, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_mtype,\n        { \"Message type\", \"thrift.mtype\",\n        FT_UINT8, BASE_DEC, VALS(thrift_mtype_vals), 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_str_len,\n        { \"Length\", \"thrift.str_len\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_method,\n        { \"Method\", \"thrift.method\",\n        FT_STRING, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_seq_id,\n        { \"Sequence Id\", \"thrift.seq_id\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_type,\n        { \"Type\", \"thrift.type\",\n        FT_UINT8, BASE_DEC, VALS(thrift_type_vals), 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_fid,\n        { \"Field Id\", \"thrift.fid\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_i16,\n        { \"Integer16\", \"thrift.i16\",\n        FT_INT16, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_i32,\n        { \"Integer32\", \"thrift.i32\",\n        FT_INT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_utf7str,\n        { \"UTF7 String\", \"thrift.utf7str\",\n        FT_STRING, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_num_list_item,\n        { \"Number of List Items\", \"thrift.num_list_item\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_num_map_item,\n        { \"Number of Map Items\", \"thrift.num_map_item\",\n        FT_UINT32, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_bool,\n        { \"Boolean\", \"thrift.bool\",\n        FT_UINT8, BASE_DEC, VALS(thrift_bool_vals), 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_byte,\n        { \"Byte\", \"thrift.byte\",\n        FT_UINT8, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_i64,\n        { \"Integer64\", \"thrift.i64\",\n        FT_INT64, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_u64,\n        { \"Integer64\", \"thrift.u64\",\n        FT_UINT64, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n        },\n        { &hf_thrift_double,\n        { \"Double\", \"thrift.double\",\n        FT_DOUBLE, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n        },\n    };\n\n\n    /* setup protocol subtree arrays */\n    static gint* ett[] = {\n        &ett_thrift,\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_thrift_wrong_type,{ \"thrift.wrong_type\", PI_PROTOCOL, PI_ERROR, \"Type value not expected\", EXPFILL } }\n    };\n\n    expert_module_t* expert_thrift;\n\n    /* Register protocol name and description */\n    proto_thrift = proto_register_protocol(\"Thrift Protocol\", \"Thrift\", \"thrift\");\n\n    expert_thrift = expert_register_protocol(proto_thrift);\n    expert_register_field_array(expert_thrift, ei, array_length(ei));\n\n    /* register field array */\n    proto_register_field_array(proto_thrift, hf, array_length(hf));\n\n    /* register subtree array */\n    proto_register_subtree_array(ett, array_length(ett));\n\n    /* register dissector */\n    /*register_dissector(\"thrift\", dissect_thrift, proto_thrift); */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -94,8 +94,17 @@\n         &ett_thrift,\n     };\n \n+    static ei_register_info ei[] = {\n+        { &ei_thrift_wrong_type,{ \"thrift.wrong_type\", PI_PROTOCOL, PI_ERROR, \"Type value not expected\", EXPFILL } }\n+    };\n+\n+    expert_module_t* expert_thrift;\n+\n     /* Register protocol name and description */\n     proto_thrift = proto_register_protocol(\"Thrift Protocol\", \"Thrift\", \"thrift\");\n+\n+    expert_thrift = expert_register_protocol(proto_thrift);\n+    expert_register_field_array(expert_thrift, ei, array_length(ei));\n \n     /* register field array */\n     proto_register_field_array(proto_thrift, hf, array_length(hf));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    static ei_register_info ei[] = {",
                "        { &ei_thrift_wrong_type,{ \"thrift.wrong_type\", PI_PROTOCOL, PI_ERROR, \"Type value not expected\", EXPFILL } }",
                "    };",
                "",
                "    expert_module_t* expert_thrift;",
                "",
                "",
                "    expert_thrift = expert_register_protocol(proto_thrift);",
                "    expert_register_field_array(expert_thrift, ei, array_length(ei));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7321",
        "func_name": "wireshark/dissect_thrift_type",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thrift.c had a large loop that was addressed by not proceeding with dissection after encountering an unexpected type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c784d551ad50864de1035ce54e72837301cf6aca",
        "commit_title": "Thrift: stop dissection when encountering an unknown/unexpected type",
        "commit_text": " Let's add an expert info, and set offset to the end of the current tvb.  Bug: 14379 (cherry picked from commit 8ab3060aace7b20c2845f2f725d4f306cca61dd4)  Conflicts: \tepan/dissectors/packet-thrift.c (cherry picked from commit 57e218cdb2729aebecb6494a786de31ba4a3698b)",
        "func_before": "static int\ndissect_thrift_type(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int type, int offset, int length)\n{\n    switch (type){\n    case 2:\n        /*T_BOOL*/\n        proto_tree_add_item(tree, hf_thrift_bool, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n        break;\n    case 3:\n        /*T_BYTE , T_I08*/\n        proto_tree_add_item(tree, hf_thrift_byte, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n        break;\n    case 4:\n        /*T_DOUBLE*/\n        proto_tree_add_item(tree, hf_thrift_double, tvb, offset, 8, ENC_BIG_ENDIAN);\n        offset += 8;\n        break;\n    case 6:\n        /*T_I16 Integer 16*/\n        proto_tree_add_item(tree, hf_thrift_i16, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        break;\n    case 8:\n        /*T_I32 Integer 32*/\n        proto_tree_add_item(tree, hf_thrift_i32, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset += 4;\n        break;\n    case 9:\n        /*T_U64 Integer 64*/\n        proto_tree_add_item(tree, hf_thrift_u64, tvb, offset, 8, ENC_BIG_ENDIAN);\n        offset += 8;\n        break;\n    case 10:\n        /*T_I64 Integer 64*/\n        proto_tree_add_item(tree, hf_thrift_i64, tvb, offset, 8, ENC_BIG_ENDIAN);\n        offset += 8;\n        break;\n    case 11:\n        /* T_UTF7 */\n        offset = dissect_thrift_utf7(tvb, pinfo, tree, offset, length);\n        break;\n    case 12:\n        /* T_STRUCT */\n        offset = dissect_thrift_struct(tvb, pinfo, tree, offset, length);\n        break;\n    case 13:\n        /* T_MAP */\n        offset = dissect_thrift_map(tvb, pinfo, tree, offset, length);\n        break;\n    case 15:\n        /* T_LIST */\n        offset = dissect_thrift_list(tvb, pinfo, tree, offset, length);\n        break;\n    default:\n        /* Bail out */\n        return length;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_thrift_type(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree,\n                    proto_item* pi, int type, int* offset, int length)\n{\n    switch (type){\n    case 2:\n        /*T_BOOL*/\n        proto_tree_add_item(tree, hf_thrift_bool, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n        break;\n    case 3:\n        /*T_BYTE , T_I08*/\n        proto_tree_add_item(tree, hf_thrift_byte, tvb, *offset, 1, ENC_BIG_ENDIAN);\n        *offset += 1;\n        break;\n    case 4:\n        /*T_DOUBLE*/\n        proto_tree_add_item(tree, hf_thrift_double, tvb, *offset, 8, ENC_BIG_ENDIAN);\n        *offset += 8;\n        break;\n    case 6:\n        /*T_I16 Integer 16*/\n        proto_tree_add_item(tree, hf_thrift_i16, tvb, *offset, 2, ENC_BIG_ENDIAN);\n        *offset += 2;\n        break;\n    case 8:\n        /*T_I32 Integer 32*/\n        proto_tree_add_item(tree, hf_thrift_i32, tvb, *offset, 4, ENC_BIG_ENDIAN);\n        *offset += 4;\n        break;\n    case 9:\n        /*T_U64 Integer 64*/\n        proto_tree_add_item(tree, hf_thrift_u64, tvb, *offset, 8, ENC_BIG_ENDIAN);\n        *offset += 8;\n        break;\n    case 10:\n        /*T_I64 Integer 64*/\n        proto_tree_add_item(tree, hf_thrift_i64, tvb, *offset, 8, ENC_BIG_ENDIAN);\n        *offset += 8;\n        break;\n    case 11:\n        /* T_UTF7 */\n        *offset = dissect_thrift_utf7(tvb, pinfo, tree, *offset, length);\n        break;\n    case 12:\n        /* T_STRUCT */\n        *offset = dissect_thrift_struct(tvb, pinfo, tree, *offset, length);\n        break;\n    case 13:\n        /* T_MAP */\n        *offset = dissect_thrift_map(tvb, pinfo, tree, *offset, length);\n        break;\n    case 15:\n        /* T_LIST */\n        *offset = dissect_thrift_list(tvb, pinfo, tree, *offset, length);\n        break;\n    default:\n        /* Bail out */\n        expert_add_info(pinfo, pi, &ei_thrift_wrong_type);\n        *offset = tvb_reported_length(tvb);\n        return -1;\n    }\n\n    return *offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,62 +1,65 @@\n static int\n-dissect_thrift_type(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int type, int offset, int length)\n+dissect_thrift_type(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree,\n+                    proto_item* pi, int type, int* offset, int length)\n {\n     switch (type){\n     case 2:\n         /*T_BOOL*/\n-        proto_tree_add_item(tree, hf_thrift_bool, tvb, offset, 1, ENC_BIG_ENDIAN);\n-        offset += 1;\n+        proto_tree_add_item(tree, hf_thrift_bool, tvb, *offset, 1, ENC_BIG_ENDIAN);\n+        *offset += 1;\n         break;\n     case 3:\n         /*T_BYTE , T_I08*/\n-        proto_tree_add_item(tree, hf_thrift_byte, tvb, offset, 1, ENC_BIG_ENDIAN);\n-        offset += 1;\n+        proto_tree_add_item(tree, hf_thrift_byte, tvb, *offset, 1, ENC_BIG_ENDIAN);\n+        *offset += 1;\n         break;\n     case 4:\n         /*T_DOUBLE*/\n-        proto_tree_add_item(tree, hf_thrift_double, tvb, offset, 8, ENC_BIG_ENDIAN);\n-        offset += 8;\n+        proto_tree_add_item(tree, hf_thrift_double, tvb, *offset, 8, ENC_BIG_ENDIAN);\n+        *offset += 8;\n         break;\n     case 6:\n         /*T_I16 Integer 16*/\n-        proto_tree_add_item(tree, hf_thrift_i16, tvb, offset, 2, ENC_BIG_ENDIAN);\n-        offset += 2;\n+        proto_tree_add_item(tree, hf_thrift_i16, tvb, *offset, 2, ENC_BIG_ENDIAN);\n+        *offset += 2;\n         break;\n     case 8:\n         /*T_I32 Integer 32*/\n-        proto_tree_add_item(tree, hf_thrift_i32, tvb, offset, 4, ENC_BIG_ENDIAN);\n-        offset += 4;\n+        proto_tree_add_item(tree, hf_thrift_i32, tvb, *offset, 4, ENC_BIG_ENDIAN);\n+        *offset += 4;\n         break;\n     case 9:\n         /*T_U64 Integer 64*/\n-        proto_tree_add_item(tree, hf_thrift_u64, tvb, offset, 8, ENC_BIG_ENDIAN);\n-        offset += 8;\n+        proto_tree_add_item(tree, hf_thrift_u64, tvb, *offset, 8, ENC_BIG_ENDIAN);\n+        *offset += 8;\n         break;\n     case 10:\n         /*T_I64 Integer 64*/\n-        proto_tree_add_item(tree, hf_thrift_i64, tvb, offset, 8, ENC_BIG_ENDIAN);\n-        offset += 8;\n+        proto_tree_add_item(tree, hf_thrift_i64, tvb, *offset, 8, ENC_BIG_ENDIAN);\n+        *offset += 8;\n         break;\n     case 11:\n         /* T_UTF7 */\n-        offset = dissect_thrift_utf7(tvb, pinfo, tree, offset, length);\n+        *offset = dissect_thrift_utf7(tvb, pinfo, tree, *offset, length);\n         break;\n     case 12:\n         /* T_STRUCT */\n-        offset = dissect_thrift_struct(tvb, pinfo, tree, offset, length);\n+        *offset = dissect_thrift_struct(tvb, pinfo, tree, *offset, length);\n         break;\n     case 13:\n         /* T_MAP */\n-        offset = dissect_thrift_map(tvb, pinfo, tree, offset, length);\n+        *offset = dissect_thrift_map(tvb, pinfo, tree, *offset, length);\n         break;\n     case 15:\n         /* T_LIST */\n-        offset = dissect_thrift_list(tvb, pinfo, tree, offset, length);\n+        *offset = dissect_thrift_list(tvb, pinfo, tree, *offset, length);\n         break;\n     default:\n         /* Bail out */\n-        return length;\n+        expert_add_info(pinfo, pi, &ei_thrift_wrong_type);\n+        *offset = tvb_reported_length(tvb);\n+        return -1;\n     }\n \n-    return offset;\n+    return *offset;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "dissect_thrift_type(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int type, int offset, int length)",
                "        proto_tree_add_item(tree, hf_thrift_bool, tvb, offset, 1, ENC_BIG_ENDIAN);",
                "        offset += 1;",
                "        proto_tree_add_item(tree, hf_thrift_byte, tvb, offset, 1, ENC_BIG_ENDIAN);",
                "        offset += 1;",
                "        proto_tree_add_item(tree, hf_thrift_double, tvb, offset, 8, ENC_BIG_ENDIAN);",
                "        offset += 8;",
                "        proto_tree_add_item(tree, hf_thrift_i16, tvb, offset, 2, ENC_BIG_ENDIAN);",
                "        offset += 2;",
                "        proto_tree_add_item(tree, hf_thrift_i32, tvb, offset, 4, ENC_BIG_ENDIAN);",
                "        offset += 4;",
                "        proto_tree_add_item(tree, hf_thrift_u64, tvb, offset, 8, ENC_BIG_ENDIAN);",
                "        offset += 8;",
                "        proto_tree_add_item(tree, hf_thrift_i64, tvb, offset, 8, ENC_BIG_ENDIAN);",
                "        offset += 8;",
                "        offset = dissect_thrift_utf7(tvb, pinfo, tree, offset, length);",
                "        offset = dissect_thrift_struct(tvb, pinfo, tree, offset, length);",
                "        offset = dissect_thrift_map(tvb, pinfo, tree, offset, length);",
                "        offset = dissect_thrift_list(tvb, pinfo, tree, offset, length);",
                "        return length;",
                "    return offset;"
            ],
            "added_lines": [
                "dissect_thrift_type(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree,",
                "                    proto_item* pi, int type, int* offset, int length)",
                "        proto_tree_add_item(tree, hf_thrift_bool, tvb, *offset, 1, ENC_BIG_ENDIAN);",
                "        *offset += 1;",
                "        proto_tree_add_item(tree, hf_thrift_byte, tvb, *offset, 1, ENC_BIG_ENDIAN);",
                "        *offset += 1;",
                "        proto_tree_add_item(tree, hf_thrift_double, tvb, *offset, 8, ENC_BIG_ENDIAN);",
                "        *offset += 8;",
                "        proto_tree_add_item(tree, hf_thrift_i16, tvb, *offset, 2, ENC_BIG_ENDIAN);",
                "        *offset += 2;",
                "        proto_tree_add_item(tree, hf_thrift_i32, tvb, *offset, 4, ENC_BIG_ENDIAN);",
                "        *offset += 4;",
                "        proto_tree_add_item(tree, hf_thrift_u64, tvb, *offset, 8, ENC_BIG_ENDIAN);",
                "        *offset += 8;",
                "        proto_tree_add_item(tree, hf_thrift_i64, tvb, *offset, 8, ENC_BIG_ENDIAN);",
                "        *offset += 8;",
                "        *offset = dissect_thrift_utf7(tvb, pinfo, tree, *offset, length);",
                "        *offset = dissect_thrift_struct(tvb, pinfo, tree, *offset, length);",
                "        *offset = dissect_thrift_map(tvb, pinfo, tree, *offset, length);",
                "        *offset = dissect_thrift_list(tvb, pinfo, tree, *offset, length);",
                "        expert_add_info(pinfo, pi, &ei_thrift_wrong_type);",
                "        *offset = tvb_reported_length(tvb);",
                "        return -1;",
                "    return *offset;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7321",
        "func_name": "wireshark/dissect_thrift_common",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thrift.c had a large loop that was addressed by not proceeding with dissection after encountering an unexpected type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c784d551ad50864de1035ce54e72837301cf6aca",
        "commit_title": "Thrift: stop dissection when encountering an unknown/unexpected type",
        "commit_text": " Let's add an expert info, and set offset to the end of the current tvb.  Bug: 14379 (cherry picked from commit 8ab3060aace7b20c2845f2f725d4f306cca61dd4)  Conflicts: \tepan/dissectors/packet-thrift.c (cherry picked from commit 57e218cdb2729aebecb6494a786de31ba4a3698b)",
        "func_before": "static void\ndissect_thrift_common(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree)\n{\n    proto_tree *sub_tree;\n    int offset = 0;\n    guint32 str_len;\n    guint8 mtype;\n    guint16 version;\n    guint32 seq_id;\n    guint8 *method_str;\n    int length = tvb_reported_length(tvb);\n    guint8 type;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"THRIFT\");\n    col_clear(pinfo->cinfo, COL_INFO);\n\n    version = tvb_get_ntohs(tvb, 0);\n    mtype = tvb_get_guint8(tvb, 3);\n    str_len = tvb_get_ntohl(tvb, 4);\n    seq_id = tvb_get_ntohl(tvb, str_len + 8);\n    method_str = tvb_get_string_enc(wmem_packet_scope(), tvb, 8, str_len, ENC_UTF_8);\n\n    proto_tree_add_item(tree, proto_thrift, tvb, 0, -1, ENC_NA);\n    sub_tree = proto_tree_add_subtree_format(tree, tvb, 0, -1, ett_thrift, NULL, \"%s[ version:0x%x, seqid:%d, method:%s]\",\n        val_to_str(mtype, thrift_mtype_vals, \"%d\"),\n        version,\n        seq_id,\n        method_str);\n\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"%s %s\", val_to_str(mtype, thrift_mtype_vals, \"%d\"), method_str);\n\n    if (tree){\n        proto_tree_add_item(sub_tree, hf_thrift_version, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        /* Not used byte ?*/\n        offset++;\n        proto_tree_add_item(sub_tree, hf_thrift_mtype, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n        proto_tree_add_item(sub_tree, hf_thrift_str_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset += 4;\n        proto_tree_add_item(sub_tree, hf_thrift_method, tvb, offset, str_len, ENC_ASCII | ENC_NA);\n        offset = offset + str_len;\n        proto_tree_add_item(sub_tree, hf_thrift_seq_id, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset += 4;\n\n    }\n    else{\n        offset = 12 + str_len;\n    }\n\n    /* Call method dissector here using dissector_try_string()*/\n    sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, NULL, \"Data\");\n    if (tree){\n        while (offset < length){\n            /*Read type and field id */\n            type = tvb_get_guint8(tvb, offset);\n            proto_tree_add_item(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n            if (type == 0){\n                return;\n            }\n            offset++;\n            proto_tree_add_item(sub_tree, hf_thrift_fid, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n\n            offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length);\n        }\n    }\n}",
        "func": "static void\ndissect_thrift_common(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree)\n{\n    proto_tree *sub_tree;\n    proto_item *type_pi;\n    int offset = 0;\n    guint32 str_len;\n    guint8 mtype;\n    guint16 version;\n    guint32 seq_id;\n    guint8 *method_str;\n    int length = tvb_reported_length(tvb);\n    guint32 type;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"THRIFT\");\n    col_clear(pinfo->cinfo, COL_INFO);\n\n    version = tvb_get_ntohs(tvb, 0);\n    mtype = tvb_get_guint8(tvb, 3);\n    str_len = tvb_get_ntohl(tvb, 4);\n    seq_id = tvb_get_ntohl(tvb, str_len + 8);\n    method_str = tvb_get_string_enc(wmem_packet_scope(), tvb, 8, str_len, ENC_UTF_8);\n\n    proto_tree_add_item(tree, proto_thrift, tvb, 0, -1, ENC_NA);\n    sub_tree = proto_tree_add_subtree_format(tree, tvb, 0, -1, ett_thrift, NULL, \"%s[ version:0x%x, seqid:%d, method:%s]\",\n        val_to_str(mtype, thrift_mtype_vals, \"%d\"),\n        version,\n        seq_id,\n        method_str);\n\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"%s %s\", val_to_str(mtype, thrift_mtype_vals, \"%d\"), method_str);\n\n    if (tree){\n        proto_tree_add_item(sub_tree, hf_thrift_version, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n        /* Not used byte ?*/\n        offset++;\n        proto_tree_add_item(sub_tree, hf_thrift_mtype, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset += 1;\n        proto_tree_add_item(sub_tree, hf_thrift_str_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset += 4;\n        proto_tree_add_item(sub_tree, hf_thrift_method, tvb, offset, str_len, ENC_ASCII | ENC_NA);\n        offset = offset + str_len;\n        proto_tree_add_item(sub_tree, hf_thrift_seq_id, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset += 4;\n\n    }\n    else{\n        offset = 12 + str_len;\n    }\n\n    /* Call method dissector here using dissector_try_string()*/\n    sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, NULL, \"Data\");\n    if (tree){\n        while (offset < length){\n            /*Read type and field id */\n            type_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);\n            if (type == 0){\n                return;\n            }\n            offset++;\n            proto_tree_add_item(sub_tree, hf_thrift_fid, tvb, offset, 2, ENC_BIG_ENDIAN);\n            offset += 2;\n\n            if (dissect_thrift_type(tvb, pinfo, sub_tree, type_pi, type, &offset, length) < 0) {\n                break;\n            }\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n dissect_thrift_common(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree)\n {\n     proto_tree *sub_tree;\n+    proto_item *type_pi;\n     int offset = 0;\n     guint32 str_len;\n     guint8 mtype;\n@@ -9,7 +10,7 @@\n     guint32 seq_id;\n     guint8 *method_str;\n     int length = tvb_reported_length(tvb);\n-    guint8 type;\n+    guint32 type;\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"THRIFT\");\n     col_clear(pinfo->cinfo, COL_INFO);\n@@ -53,8 +54,7 @@\n     if (tree){\n         while (offset < length){\n             /*Read type and field id */\n-            type = tvb_get_guint8(tvb, offset);\n-            proto_tree_add_item(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n+            type_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);\n             if (type == 0){\n                 return;\n             }\n@@ -62,7 +62,9 @@\n             proto_tree_add_item(sub_tree, hf_thrift_fid, tvb, offset, 2, ENC_BIG_ENDIAN);\n             offset += 2;\n \n-            offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length);\n+            if (dissect_thrift_type(tvb, pinfo, sub_tree, type_pi, type, &offset, length) < 0) {\n+                break;\n+            }\n         }\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    guint8 type;",
                "            type = tvb_get_guint8(tvb, offset);",
                "            proto_tree_add_item(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
                "            offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length);"
            ],
            "added_lines": [
                "    proto_item *type_pi;",
                "    guint32 type;",
                "            type_pi = proto_tree_add_item_ret_uint(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN, &type);",
                "            if (dissect_thrift_type(tvb, pinfo, sub_tree, type_pi, type, &offset, length) < 0) {",
                "                break;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_alternate_mask_value_set_element",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint\ndissect_wccp2_alternate_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, guint el_index, packet_info *pinfo,\n                    proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_item *tl, *header;\n  proto_tree *element_tree, *value_tree;\n  guint number_of_elements;\n  gint new_length, total_length;\n  guint i;\n\n  element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 0,\n                               ett_alternate_mask_value_set_element, &header,\n                               \"Alternate Mask/Value Set Element(%d)\", el_index);\n\n  total_length = 0;\n\n  new_length=dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree);\n  total_length += length - new_length;\n  NOTE_EATEN_LENGTH(new_length);\n\n  if (length < 4)\n    return length - 4;\n\n  number_of_elements  = tvb_get_ntohl(tvb, offset);\n  tl = proto_tree_add_uint(element_tree, hf_alt_assignment_mask_value_set_element_num_wc_value_elements, tvb, offset, 4, number_of_elements);\n  value_tree = proto_item_add_subtree(tl, ett_alternate_mv_set_element_list);\n  total_length += 4;\n  EAT(4);\n\n  for (i=0; i < number_of_elements; i++) {\n    new_length=dissect_wccp2_web_cache_value_element(tvb, offset, length, pinfo, value_tree, addr_table);\n    total_length += length - new_length;\n    if (total_length < 0)\n        return length;\n    NOTE_EATEN_LENGTH(new_length);\n  }\n  proto_item_set_len(header, total_length);\n\n  return length;\n}",
        "func": "static gint\ndissect_wccp2_alternate_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, guint el_index, packet_info *pinfo,\n                    proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_item *tl, *header;\n  proto_tree *element_tree, *value_tree;\n  guint number_of_elements;\n  gint new_length, total_length;\n  guint i;\n\n  element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 0,\n                               ett_alternate_mask_value_set_element, &header,\n                               \"Alternate Mask/Value Set Element(%d)\", el_index);\n\n  total_length = 0;\n\n  new_length=dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree);\n  total_length += length - new_length;\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  if (length < 4)\n    return length - 4;\n\n  number_of_elements  = tvb_get_ntohl(tvb, offset);\n  tl = proto_tree_add_uint(element_tree, hf_alt_assignment_mask_value_set_element_num_wc_value_elements, tvb, offset, 4, number_of_elements);\n  value_tree = proto_item_add_subtree(tl, ett_alternate_mv_set_element_list);\n  total_length += 4;\n  EAT(4);\n\n  /* XXX Add a bounds check for number_of_elements? */\n  for (i=0; i < number_of_elements; i++) {\n    new_length=dissect_wccp2_web_cache_value_element(tvb, offset, length, pinfo, value_tree, addr_table);\n    total_length += length - new_length;\n    CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n  }\n  proto_item_set_len(header, total_length);\n\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \n   new_length=dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree);\n   total_length += length - new_length;\n-  NOTE_EATEN_LENGTH(new_length);\n+  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n \n   if (length < 4)\n     return length - 4;\n@@ -27,12 +27,11 @@\n   total_length += 4;\n   EAT(4);\n \n+  /* XXX Add a bounds check for number_of_elements? */\n   for (i=0; i < number_of_elements; i++) {\n     new_length=dissect_wccp2_web_cache_value_element(tvb, offset, length, pinfo, value_tree, addr_table);\n     total_length += length - new_length;\n-    if (total_length < 0)\n-        return length;\n-    NOTE_EATEN_LENGTH(new_length);\n+    CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n   }\n   proto_item_set_len(header, total_length);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  NOTE_EATEN_LENGTH(new_length);",
                "    if (total_length < 0)",
                "        return length;",
                "    NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "  CHECK_LENGTH_ADVANCE_OFFSET(new_length);",
                "  /* XXX Add a bounds check for number_of_elements? */",
                "    CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_mask_value_set_list",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint\ndissect_wccp2_mask_value_set_list(tvbuff_t *tvb, int offset,\n                                  int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint num_of_elem;\n  guint i;\n  proto_item *te;\n  proto_tree *element_tree;\n  guint start;\n\n\n  if (length < 4)\n    return length - 4;\n\n  element_tree = proto_tree_add_subtree(info_tree, tvb, offset, 4, ett_mv_set_list, &te, \"Mask/Value Set List\");\n  start = offset;\n\n\n  num_of_elem = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_item(element_tree, hf_mask_value_set_list_num_elements,\n                      tvb, offset, 4, ENC_BIG_ENDIAN);\n  /*  proto_tree_add_uint(element_tree, , tvb, offset, 4, num_of_elem); */\n  EAT(4);\n\n  for (i = 0; i < num_of_elem; i++)\n    {\n      gint new_length;\n\n      new_length=dissect_wccp2_mask_value_set_element(tvb, offset, length, i, pinfo, element_tree, addr_table);\n\n      NOTE_EATEN_LENGTH(new_length);\n    }\n\n  proto_item_set_len(te, offset-start);\n  return length;\n}",
        "func": "static gint\ndissect_wccp2_mask_value_set_list(tvbuff_t *tvb, int offset,\n                                  int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint num_of_elem;\n  guint i;\n  proto_item *te;\n  proto_tree *element_tree;\n  guint start;\n\n\n  if (length < 4)\n    return length - 4;\n\n  element_tree = proto_tree_add_subtree(info_tree, tvb, offset, 4, ett_mv_set_list, &te, \"Mask/Value Set List\");\n  start = offset;\n\n\n  num_of_elem = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_item(element_tree, hf_mask_value_set_list_num_elements,\n                      tvb, offset, 4, ENC_BIG_ENDIAN);\n  /*  proto_tree_add_uint(element_tree, , tvb, offset, 4, num_of_elem); */\n  EAT(4);\n\n  for (i = 0; i < num_of_elem; i++)\n    {\n      gint new_length;\n\n      new_length=dissect_wccp2_mask_value_set_element(tvb, offset, length, i, pinfo, element_tree, addr_table);\n\n      CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n    }\n\n  proto_item_set_len(te, offset-start);\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \n       new_length=dissect_wccp2_mask_value_set_element(tvb, offset, length, i, pinfo, element_tree, addr_table);\n \n-      NOTE_EATEN_LENGTH(new_length);\n+      CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n     }\n \n   proto_item_set_len(te, offset-start);",
        "diff_line_info": {
            "deleted_lines": [
                "      NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "      CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_alternate_mask_value_set_list",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint dissect_wccp2_alternate_mask_value_set_list(tvbuff_t *tvb, int offset,\n                                                        int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_tree *list_tree;\n  guint num_of_val_elements;\n  guint i;\n\n  if (length < 4)\n    return length - 4;\n\n  list_tree = proto_tree_add_subtree(info_tree, tvb, offset, length,\n                               ett_alternate_mask_value_set, NULL, \"Alternate Mask/Value Set List\");\n\n  num_of_val_elements = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(list_tree, hf_alt_assignment_mask_value_set_list_num_elements, tvb, offset, 4, num_of_val_elements);\n  EAT(4);\n\n  for(i=0;i<num_of_val_elements;i++) {\n    gint new_length;\n\n    new_length=dissect_wccp2_alternate_mask_value_set_element(tvb, offset, length, i, pinfo, list_tree, addr_table);\n\n    NOTE_EATEN_LENGTH(new_length);\n  }\n  return length;\n}",
        "func": "static gint dissect_wccp2_alternate_mask_value_set_list(tvbuff_t *tvb, int offset,\n                                                        int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_tree *list_tree;\n  guint num_of_val_elements;\n  guint i;\n\n  if (length < 4)\n    return length - 4;\n\n  list_tree = proto_tree_add_subtree(info_tree, tvb, offset, length,\n                               ett_alternate_mask_value_set, NULL, \"Alternate Mask/Value Set List\");\n\n  num_of_val_elements = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(list_tree, hf_alt_assignment_mask_value_set_list_num_elements, tvb, offset, 4, num_of_val_elements);\n  EAT(4);\n\n  for(i=0;i<num_of_val_elements;i++) {\n    gint new_length;\n\n    new_length=dissect_wccp2_alternate_mask_value_set_element(tvb, offset, length, i, pinfo, list_tree, addr_table);\n\n    CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n  }\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n \n     new_length=dissect_wccp2_alternate_mask_value_set_element(tvb, offset, length, i, pinfo, list_tree, addr_table);\n \n-    NOTE_EATEN_LENGTH(new_length);\n+    CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n   }\n   return length;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "    CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_router_view_info",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint\ndissect_wccp2_router_view_info(tvbuff_t *tvb, int offset, gint length,\n                               packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint32 n_routers;\n  guint32 n_web_caches;\n  guint i;\n  proto_item *te;\n  proto_tree *element_tree;\n  gint new_length;\n\n  if (length < ROUTER_VIEW_INFO_MIN_LEN)\n    return length - ROUTER_VIEW_INFO_MIN_LEN;\n\n  proto_tree_add_item(info_tree, hf_router_view_member_change_num, tvb, offset, 4, ENC_BIG_ENDIAN);\n  EAT(4);\n\n  new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo, info_tree, addr_table);\n  NOTE_EATEN_LENGTH(new_length);\n\n  n_routers = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(info_tree, hf_router_router_num, tvb, offset, 4, n_routers);\n  EAT(4);\n\n  for (i = 0; i < n_routers; i++) {\n    if (length < 4)\n      return length - (n_routers-i)*4 - 4;\n\n    wccp_add_ipaddress_item(info_tree, hf_router_view_ip_index, hf_router_view_ipv4, hf_router_view_ipv6, tvb, offset, 4, addr_table);\n    EAT(4);\n  }\n\n  if (length < 4)\n    return length - 4;\n\n  n_web_caches = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(info_tree, hf_wc_view_wc_num, tvb, offset, 4, n_web_caches);\n  EAT(4);\n\n  for (i = 0; i < n_web_caches; i++) {\n    gint old_length;\n    old_length = length;\n\n    if (length < 4)\n      return length - 4*(n_web_caches-i);\n\n    te = wccp_add_ipaddress_item(info_tree, hf_router_query_info_ip_index, hf_router_query_info_ipv4, hf_router_query_info_ipv6, tvb, offset, 4, addr_table);\n\n    element_tree = proto_item_add_subtree(te, ett_wc_identity_element);\n    length = dissect_wccp2_web_cache_identity_element(tvb,\n                                                      offset, length, pinfo,\n                                                      element_tree, addr_table);\n    if (length < 0)\n      return length;\n\n    offset += old_length - length;\n  }\n  return length;\n}",
        "func": "static gint\ndissect_wccp2_router_view_info(tvbuff_t *tvb, int offset, gint length,\n                               packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint32 n_routers;\n  guint32 n_web_caches;\n  guint i;\n  proto_item *te;\n  proto_tree *element_tree;\n  gint new_length;\n\n  if (length < ROUTER_VIEW_INFO_MIN_LEN)\n    return length - ROUTER_VIEW_INFO_MIN_LEN;\n\n  proto_tree_add_item(info_tree, hf_router_view_member_change_num, tvb, offset, 4, ENC_BIG_ENDIAN);\n  EAT(4);\n\n  new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo, info_tree, addr_table);\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  n_routers = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(info_tree, hf_router_router_num, tvb, offset, 4, n_routers);\n  EAT(4);\n\n  for (i = 0; i < n_routers; i++) {\n    if (length < 4)\n      return length - (n_routers-i)*4 - 4;\n\n    wccp_add_ipaddress_item(info_tree, hf_router_view_ip_index, hf_router_view_ipv4, hf_router_view_ipv6, tvb, offset, 4, addr_table);\n    EAT(4);\n  }\n\n  if (length < 4)\n    return length - 4;\n\n  n_web_caches = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(info_tree, hf_wc_view_wc_num, tvb, offset, 4, n_web_caches);\n  EAT(4);\n\n  for (i = 0; i < n_web_caches; i++) {\n    gint old_length;\n    old_length = length;\n\n    if (length < 4)\n      return length - 4*(n_web_caches-i);\n\n    te = wccp_add_ipaddress_item(info_tree, hf_router_query_info_ip_index, hf_router_query_info_ipv4, hf_router_query_info_ipv6, tvb, offset, 4, addr_table);\n\n    element_tree = proto_item_add_subtree(te, ett_wc_identity_element);\n    length = dissect_wccp2_web_cache_identity_element(tvb,\n                                                      offset, length, pinfo,\n                                                      element_tree, addr_table);\n    if (length < 0)\n      return length;\n\n    offset += old_length - length;\n  }\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n   EAT(4);\n \n   new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo, info_tree, addr_table);\n-  NOTE_EATEN_LENGTH(new_length);\n+  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n \n   n_routers = tvb_get_ntohl(tvb, offset);\n   proto_tree_add_uint(info_tree, hf_router_router_num, tvb, offset, 4, n_routers);",
        "diff_line_info": {
            "deleted_lines": [
                "  NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "  CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_alternate_mask_assignment_data_element",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint\ndissect_wccp2_alternate_mask_assignment_data_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,\n                                                     proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_tree *mask_tree;\n\n  mask_tree = proto_tree_add_subtree(info_tree, tvb, offset, length,\n                                  ett_alternate_mask_assignment_data_element, NULL, \"Alternate Mask Assignment Data\");\n\n  if (length < 4)\n    return length-4;\n\n  if (length > 4)\n    for (;length >4;)\n      {\n        gint new_length;\n\n        new_length=dissect_wccp2_alternate_mask_value_set_list(tvb, offset, length, pinfo, mask_tree, addr_table);\n\n        NOTE_EATEN_LENGTH(new_length);\n      }\n\n  if (length < 2)\n    return -2;\n\n  return  dissect_wccp2_assignment_weight_and_status_element(tvb, offset, length, pinfo, info_tree);\n}",
        "func": "static gint\ndissect_wccp2_alternate_mask_assignment_data_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,\n                                                     proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_tree *mask_tree;\n\n  mask_tree = proto_tree_add_subtree(info_tree, tvb, offset, length,\n                                  ett_alternate_mask_assignment_data_element, NULL, \"Alternate Mask Assignment Data\");\n\n  if (length < 4)\n    return length-4;\n\n  if (length > 4)\n    for (;length >4;)\n      {\n        gint new_length;\n\n        new_length=dissect_wccp2_alternate_mask_value_set_list(tvb, offset, length, pinfo, mask_tree, addr_table);\n\n        CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n      }\n\n  if (length < 2)\n    return -2;\n\n  return  dissect_wccp2_assignment_weight_and_status_element(tvb, offset, length, pinfo, info_tree);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \n         new_length=dissect_wccp2_alternate_mask_value_set_list(tvb, offset, length, pinfo, mask_tree, addr_table);\n \n-        NOTE_EATEN_LENGTH(new_length);\n+        CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n       }\n \n   if (length < 2)",
        "diff_line_info": {
            "deleted_lines": [
                "        NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "        CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_assignment_map",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint dissect_wccp2_assignment_map(tvbuff_t *tvb, int offset,\n                                         int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  gint new_length;\n\n  new_length=dissect_wccp2_mask_value_set_list(tvb, offset, length, pinfo, info_tree, addr_table);\n\n  NOTE_EATEN_LENGTH(new_length);\n\n  return length;\n}",
        "func": "static gint dissect_wccp2_assignment_map(tvbuff_t *tvb, int offset,\n                                         int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  gint new_length;\n\n  new_length=dissect_wccp2_mask_value_set_list(tvb, offset, length, pinfo, info_tree, addr_table);\n\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \n   new_length=dissect_wccp2_mask_value_set_list(tvb, offset, length, pinfo, info_tree, addr_table);\n \n-  NOTE_EATEN_LENGTH(new_length);\n+  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n \n   return length;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "  CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_mask_assignment_data_element",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint\ndissect_wccp2_mask_assignment_data_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,\n                                           proto_tree *info_tree, wccp_address_table* addr_table)\n\n{\n  proto_item *mask_item;\n  proto_tree *mask_tree;\n  gint new_length,start;\n\n\n  mask_tree = proto_tree_add_subtree(info_tree, tvb, offset, 4,\n                                  ett_mask_assignment_data_element, &mask_item, \"Mask Assignment Data\");\n  start = offset;\n\n  new_length=dissect_wccp2_mask_value_set_list(tvb, offset, length, pinfo, mask_tree, addr_table);\n\n  NOTE_EATEN_LENGTH(new_length);\n\n  if (length < 2)\n    return length-4;\n\n  new_length =  dissect_wccp2_assignment_weight_and_status_element(tvb, offset, length, pinfo, info_tree);\n  NOTE_EATEN_LENGTH(new_length);\n\n  proto_item_set_len(mask_item, offset-start);\n  return length;\n}",
        "func": "static gint\ndissect_wccp2_mask_assignment_data_element(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo,\n                                           proto_tree *info_tree, wccp_address_table* addr_table)\n\n{\n  proto_item *mask_item;\n  proto_tree *mask_tree;\n  gint new_length,start;\n\n\n  mask_tree = proto_tree_add_subtree(info_tree, tvb, offset, 4,\n                                  ett_mask_assignment_data_element, &mask_item, \"Mask Assignment Data\");\n  start = offset;\n\n  new_length=dissect_wccp2_mask_value_set_list(tvb, offset, length, pinfo, mask_tree, addr_table);\n\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  if (length < 2)\n    return length-4;\n\n  new_length =  dissect_wccp2_assignment_weight_and_status_element(tvb, offset, length, pinfo, info_tree);\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  proto_item_set_len(mask_item, offset-start);\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,13 +14,13 @@\n \n   new_length=dissect_wccp2_mask_value_set_list(tvb, offset, length, pinfo, mask_tree, addr_table);\n \n-  NOTE_EATEN_LENGTH(new_length);\n+  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n \n   if (length < 2)\n     return length-4;\n \n   new_length =  dissect_wccp2_assignment_weight_and_status_element(tvb, offset, length, pinfo, info_tree);\n-  NOTE_EATEN_LENGTH(new_length);\n+  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n \n   proto_item_set_len(mask_item, offset-start);\n   return length;",
        "diff_line_info": {
            "deleted_lines": [
                "  NOTE_EATEN_LENGTH(new_length);",
                "  NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "  CHECK_LENGTH_ADVANCE_OFFSET(new_length);",
                "  CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_capability_info",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint\ndissect_wccp2_capability_info(tvbuff_t *tvb, int offset, gint length,\n                              packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table _U_)\n{\n  gint capability_length;\n\n  while (length >= 8) {\n    capability_length = dissect_wccp2_capability_element(tvb,offset,length,pinfo,info_tree);\n\n    NOTE_EATEN_LENGTH(capability_length);\n  }\n  return length;\n}",
        "func": "static gint\ndissect_wccp2_capability_info(tvbuff_t *tvb, int offset, gint length,\n                              packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table _U_)\n{\n  gint capability_length;\n\n  while (length >= 8) {\n    capability_length = dissect_wccp2_capability_element(tvb,offset,length,pinfo,info_tree);\n\n    CHECK_LENGTH_ADVANCE_OFFSET(capability_length);\n  }\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n   while (length >= 8) {\n     capability_length = dissect_wccp2_capability_element(tvb,offset,length,pinfo,info_tree);\n \n-    NOTE_EATEN_LENGTH(capability_length);\n+    CHECK_LENGTH_ADVANCE_OFFSET(capability_length);\n   }\n   return length;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    NOTE_EATEN_LENGTH(capability_length);"
            ],
            "added_lines": [
                "    CHECK_LENGTH_ADVANCE_OFFSET(capability_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_mask_value_set_element",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint\ndissect_wccp2_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, int idx, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_item *tl, *te;\n  proto_tree *element_tree, *value_tree;\n  guint num_of_val_elements;\n  guint i;\n  gint new_length;\n\n  element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 0,\n                           ett_mv_set_element, &tl, \"Mask/Value Set Element(%d)\", idx);\n\n  new_length = dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree);\n  NOTE_EATEN_LENGTH(new_length);\n\n  if (length < 4)\n    return length-4;\n\n  num_of_val_elements = tvb_get_ntohl(tvb, offset);\n  te = proto_tree_add_uint(element_tree, hf_mask_value_set_element_value_element_num, tvb, offset, 4, num_of_val_elements);\n\n  value_tree = proto_item_add_subtree(te, ett_mv_set_value_list);\n  EAT(4);\n\n  for (i = 0; i < num_of_val_elements; i++)\n    {\n      new_length=dissect_wccp2_value_element(tvb, offset, length, i, pinfo,  value_tree, addr_table);\n\n      NOTE_EATEN_LENGTH(new_length);\n    }\n\n  proto_item_set_len(tl, 16+num_of_val_elements*16);\n\n  return length;\n}",
        "func": "static gint\ndissect_wccp2_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, int idx, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_item *tl, *te;\n  proto_tree *element_tree, *value_tree;\n  guint num_of_val_elements;\n  guint i;\n  gint new_length;\n\n  element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 0,\n                           ett_mv_set_element, &tl, \"Mask/Value Set Element(%d)\", idx);\n\n  new_length = dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree);\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  if (length < 4)\n    return length-4;\n\n  num_of_val_elements = tvb_get_ntohl(tvb, offset);\n  te = proto_tree_add_uint(element_tree, hf_mask_value_set_element_value_element_num, tvb, offset, 4, num_of_val_elements);\n\n  value_tree = proto_item_add_subtree(te, ett_mv_set_value_list);\n  EAT(4);\n\n  for (i = 0; i < num_of_val_elements; i++)\n    {\n      new_length=dissect_wccp2_value_element(tvb, offset, length, i, pinfo,  value_tree, addr_table);\n\n      CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n    }\n\n  proto_item_set_len(tl, 16+num_of_val_elements*16);\n\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n                            ett_mv_set_element, &tl, \"Mask/Value Set Element(%d)\", idx);\n \n   new_length = dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree);\n-  NOTE_EATEN_LENGTH(new_length);\n+  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n \n   if (length < 4)\n     return length-4;\n@@ -26,7 +26,7 @@\n     {\n       new_length=dissect_wccp2_value_element(tvb, offset, length, i, pinfo,  value_tree, addr_table);\n \n-      NOTE_EATEN_LENGTH(new_length);\n+      CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n     }\n \n   proto_item_set_len(tl, 16+num_of_val_elements*16);",
        "diff_line_info": {
            "deleted_lines": [
                "  NOTE_EATEN_LENGTH(new_length);",
                "      NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "  CHECK_LENGTH_ADVANCE_OFFSET(new_length);",
                "      CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_assignment_info",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint\ndissect_wccp2_assignment_info(tvbuff_t *tvb, int offset, gint length,\n                              packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint32 n_routers;\n  guint i;\n  proto_item *te;\n  proto_tree *element_tree;\n  gint new_length;\n\n  if (length < ASSIGNMENT_INFO_MIN_LEN)\n    return length - ASSIGNMENT_INFO_MIN_LEN;\n\n\n  new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo, info_tree, addr_table);\n  NOTE_EATEN_LENGTH(new_length);\n\n  n_routers = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(info_tree, hf_assignment_info_router_num, tvb, offset, 4, n_routers);\n  EAT(4);\n\n  for (i = 0; i < n_routers; i++) {\n    if (length < 12)\n      return length - 12*(n_routers-i)-4-256;\n\n    te = wccp_add_ipaddress_item(info_tree, hf_assignment_info_router_ip_index, hf_assignment_info_router_ipv4, hf_assignment_info_router_ipv6, tvb, offset, 4, addr_table);\n\n    element_tree = proto_item_add_subtree(te, ett_router_assignment_element);\n    dissect_wccp2_router_assignment_element(tvb, offset, length , pinfo,\n                                            element_tree, addr_table);\n    EAT(12);\n  }\n\n  new_length = dissect_wccp2_hash_buckets_assignment_element(tvb, offset, length, pinfo, info_tree, addr_table);\n  NOTE_EATEN_LENGTH(new_length);\n  return length;\n}",
        "func": "static gint\ndissect_wccp2_assignment_info(tvbuff_t *tvb, int offset, gint length,\n                              packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint32 n_routers;\n  guint i;\n  proto_item *te;\n  proto_tree *element_tree;\n  gint new_length;\n\n  if (length < ASSIGNMENT_INFO_MIN_LEN)\n    return length - ASSIGNMENT_INFO_MIN_LEN;\n\n\n  new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo, info_tree, addr_table);\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  n_routers = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(info_tree, hf_assignment_info_router_num, tvb, offset, 4, n_routers);\n  EAT(4);\n\n  for (i = 0; i < n_routers; i++) {\n    if (length < 12)\n      return length - 12*(n_routers-i)-4-256;\n\n    te = wccp_add_ipaddress_item(info_tree, hf_assignment_info_router_ip_index, hf_assignment_info_router_ipv4, hf_assignment_info_router_ipv6, tvb, offset, 4, addr_table);\n\n    element_tree = proto_item_add_subtree(te, ett_router_assignment_element);\n    dissect_wccp2_router_assignment_element(tvb, offset, length , pinfo,\n                                            element_tree, addr_table);\n    EAT(12);\n  }\n\n  new_length = dissect_wccp2_hash_buckets_assignment_element(tvb, offset, length, pinfo, info_tree, addr_table);\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \n \n   new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo, info_tree, addr_table);\n-  NOTE_EATEN_LENGTH(new_length);\n+  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n \n   n_routers = tvb_get_ntohl(tvb, offset);\n   proto_tree_add_uint(info_tree, hf_assignment_info_router_num, tvb, offset, 4, n_routers);\n@@ -32,6 +32,6 @@\n   }\n \n   new_length = dissect_wccp2_hash_buckets_assignment_element(tvb, offset, length, pinfo, info_tree, addr_table);\n-  NOTE_EATEN_LENGTH(new_length);\n+  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n   return length;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  NOTE_EATEN_LENGTH(new_length);",
                "  NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "  CHECK_LENGTH_ADVANCE_OFFSET(new_length);",
                "  CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_alternate_assignment_info",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5d45b69b590cabc5127282d1ade3bca1598e5f5c",
        "commit_title": "WCCP: Make sure our offset increases.",
        "commit_text": " Make sure we advance our offset in various places. Clarify a macro name.  Bug: 14412",
        "func_before": "static gint\ndissect_wccp2_alternate_assignment_info(tvbuff_t *tvb, int offset, gint length,\n                                        packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint16 assignment_type;\n  guint16 assignment_length;\n  proto_item *tf=NULL;\n\n  guint32 n_routers;\n  guint i;\n  proto_tree *element_tree;\n  gint new_length;\n\n\n  if (length < ALT_ASSIGNMENT_INFO_MIN_LEN)\n    return length - ALT_ASSIGNMENT_INFO_MIN_LEN;\n\n\n  assignment_type = tvb_get_ntohs(tvb, offset);\n  proto_tree_add_item(info_tree, hf_alt_assignment_info_assignment_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  assignment_length = tvb_get_ntohs(tvb, offset);\n  tf=proto_tree_add_item(info_tree, hf_alt_assignment_info_assignment_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT(2);\n\n  if (length < assignment_length)\n    expert_add_info_format(pinfo, tf, &ei_wccp_assignment_length_bad,\n                           \"Assignment length is %d but only %d remain in the packet. Ignoring this for now\",\n                           assignment_length, length);\n\n  if (length > assignment_length)  {\n    expert_add_info_format(pinfo, tf, &ei_wccp_assignment_length_bad,\n                           \"Assignment length is %d but %d remain in the packet. Assuming that the assignment length is wrong and setting it to %d.\",\n                           assignment_length, length, length);\n  }\n\n  new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo,  info_tree, addr_table);\n  NOTE_EATEN_LENGTH(new_length);\n\n  n_routers = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(info_tree, hf_alt_assignment_info_num_routers, tvb, offset, 4, n_routers);\n  EAT(4);\n\n  for (i = 0; i < n_routers; i++) {\n    if (length < 12)\n      return length - 12*(n_routers-i);\n\n    element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 12,\n                             ett_router_alt_assignment_element, NULL,\n                             \"Router %d Assignment Element: IP address %s\", i,\n                             decode_wccp_encoded_address(tvb, offset, pinfo, info_tree, addr_table));\n\n    dissect_wccp2_router_assignment_element(tvb, offset, length , pinfo, element_tree, addr_table);\n    EAT(12);\n  }\n\n  switch (assignment_type) {\n  case WCCP2_HASH_ASSIGNMENT_TYPE:\n    return dissect_wccp2_hash_assignment_info(tvb, offset, length,\n                                              pinfo, info_tree, addr_table);\n  case WCCP2_MASK_ASSIGNMENT_TYPE:\n    return dissect_wccp2_mask_value_set_list(tvb, offset, length,\n                                             pinfo, info_tree, addr_table);\n  case WCCP2r1_ALT_MASK_ASSIGNMENT_TYPE:\n    return dissect_wccp2_alternate_mask_value_set_list(tvb, offset, length,\n                                                       pinfo, info_tree, addr_table);\n  default:\n    return length;\n  }\n}",
        "func": "static gint\ndissect_wccp2_alternate_assignment_info(tvbuff_t *tvb, int offset, gint length,\n                                        packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  guint16 assignment_type;\n  guint16 assignment_length;\n  proto_item *tf=NULL;\n\n  guint32 n_routers;\n  guint i;\n  proto_tree *element_tree;\n  gint new_length;\n\n\n  if (length < ALT_ASSIGNMENT_INFO_MIN_LEN)\n    return length - ALT_ASSIGNMENT_INFO_MIN_LEN;\n\n\n  assignment_type = tvb_get_ntohs(tvb, offset);\n  proto_tree_add_item(info_tree, hf_alt_assignment_info_assignment_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT_AND_CHECK(2,2);\n\n  assignment_length = tvb_get_ntohs(tvb, offset);\n  tf=proto_tree_add_item(info_tree, hf_alt_assignment_info_assignment_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n  EAT(2);\n\n  if (length < assignment_length)\n    expert_add_info_format(pinfo, tf, &ei_wccp_assignment_length_bad,\n                           \"Assignment length is %d but only %d remain in the packet. Ignoring this for now\",\n                           assignment_length, length);\n\n  if (length > assignment_length)  {\n    expert_add_info_format(pinfo, tf, &ei_wccp_assignment_length_bad,\n                           \"Assignment length is %d but %d remain in the packet. Assuming that the assignment length is wrong and setting it to %d.\",\n                           assignment_length, length, length);\n  }\n\n  new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo,  info_tree, addr_table);\n  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n\n  n_routers = tvb_get_ntohl(tvb, offset);\n  proto_tree_add_uint(info_tree, hf_alt_assignment_info_num_routers, tvb, offset, 4, n_routers);\n  EAT(4);\n\n  for (i = 0; i < n_routers; i++) {\n    if (length < 12)\n      return length - 12*(n_routers-i);\n\n    element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 12,\n                             ett_router_alt_assignment_element, NULL,\n                             \"Router %d Assignment Element: IP address %s\", i,\n                             decode_wccp_encoded_address(tvb, offset, pinfo, info_tree, addr_table));\n\n    dissect_wccp2_router_assignment_element(tvb, offset, length , pinfo, element_tree, addr_table);\n    EAT(12);\n  }\n\n  switch (assignment_type) {\n  case WCCP2_HASH_ASSIGNMENT_TYPE:\n    return dissect_wccp2_hash_assignment_info(tvb, offset, length,\n                                              pinfo, info_tree, addr_table);\n  case WCCP2_MASK_ASSIGNMENT_TYPE:\n    return dissect_wccp2_mask_value_set_list(tvb, offset, length,\n                                             pinfo, info_tree, addr_table);\n  case WCCP2r1_ALT_MASK_ASSIGNMENT_TYPE:\n    return dissect_wccp2_alternate_mask_value_set_list(tvb, offset, length,\n                                                       pinfo, info_tree, addr_table);\n  default:\n    return length;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,7 @@\n   }\n \n   new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo,  info_tree, addr_table);\n-  NOTE_EATEN_LENGTH(new_length);\n+  CHECK_LENGTH_ADVANCE_OFFSET(new_length);\n \n   n_routers = tvb_get_ntohl(tvb, offset);\n   proto_tree_add_uint(info_tree, hf_alt_assignment_info_num_routers, tvb, offset, 4, n_routers);",
        "diff_line_info": {
            "deleted_lines": [
                "  NOTE_EATEN_LENGTH(new_length);"
            ],
            "added_lines": [
                "  CHECK_LENGTH_ADVANCE_OFFSET(new_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7323",
        "func_name": "wireshark/dissect_wccp2_alternate_mask_value_set_element",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.",
        "git_url": "https://github.com/wireshark/wireshark/commit/4f9199ea8cff56c6704e9828c3d80360b27c4565",
        "commit_title": "WCCP: Prevent very long loop in dissect_wccp2_alternate_mask_value_set_element",
        "commit_text": " Sanity check the total_length to make sure it doesn't go negative.  Bug: 14412 (cherry picked from commit ba3cfb403a403647241062b933ff82808ac62a59)",
        "func_before": "static gint\ndissect_wccp2_alternate_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, guint el_index, packet_info *pinfo,\n                    proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_item *tl, *header;\n  proto_tree *element_tree, *value_tree;\n  guint number_of_elements;\n  gint new_length, total_length;\n  guint i;\n\n  element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 0,\n                               ett_alternate_mask_value_set_element, &header,\n                               \"Alternate Mask/Value Set Element(%d)\", el_index);\n\n  total_length = 0;\n\n  new_length=dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree);\n  total_length += length - new_length;\n  NOTE_EATEN_LENGTH(new_length);\n\n  if (length < 4)\n    return length - 4;\n\n  number_of_elements  = tvb_get_ntohl(tvb, offset);\n  tl = proto_tree_add_uint(element_tree, hf_alt_assignment_mask_value_set_element_num_wc_value_elements, tvb, offset, 4, number_of_elements);\n  value_tree = proto_item_add_subtree(tl, ett_alternate_mv_set_element_list);\n  total_length += 4;\n  EAT(4);\n\n  for (i=0; i < number_of_elements; i++) {\n    new_length=dissect_wccp2_web_cache_value_element(tvb, offset, length, pinfo, value_tree, addr_table);\n    total_length += length - new_length;\n    NOTE_EATEN_LENGTH(new_length);\n  }\n  proto_item_set_len(header, total_length);\n\n  return length;\n}",
        "func": "static gint\ndissect_wccp2_alternate_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, guint el_index, packet_info *pinfo,\n                    proto_tree *info_tree, wccp_address_table* addr_table)\n{\n  proto_item *tl, *header;\n  proto_tree *element_tree, *value_tree;\n  guint number_of_elements;\n  gint new_length, total_length;\n  guint i;\n\n  element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 0,\n                               ett_alternate_mask_value_set_element, &header,\n                               \"Alternate Mask/Value Set Element(%d)\", el_index);\n\n  total_length = 0;\n\n  new_length=dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree);\n  total_length += length - new_length;\n  NOTE_EATEN_LENGTH(new_length);\n\n  if (length < 4)\n    return length - 4;\n\n  number_of_elements  = tvb_get_ntohl(tvb, offset);\n  tl = proto_tree_add_uint(element_tree, hf_alt_assignment_mask_value_set_element_num_wc_value_elements, tvb, offset, 4, number_of_elements);\n  value_tree = proto_item_add_subtree(tl, ett_alternate_mv_set_element_list);\n  total_length += 4;\n  EAT(4);\n\n  for (i=0; i < number_of_elements; i++) {\n    new_length=dissect_wccp2_web_cache_value_element(tvb, offset, length, pinfo, value_tree, addr_table);\n    total_length += length - new_length;\n    if (total_length < 0)\n        return length;\n    NOTE_EATEN_LENGTH(new_length);\n  }\n  proto_item_set_len(header, total_length);\n\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,8 @@\n   for (i=0; i < number_of_elements; i++) {\n     new_length=dissect_wccp2_web_cache_value_element(tvb, offset, length, pinfo, value_tree, addr_table);\n     total_length += length - new_length;\n+    if (total_length < 0)\n+        return length;\n     NOTE_EATEN_LENGTH(new_length);\n   }\n   proto_item_set_len(header, total_length);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (total_length < 0)",
                "        return length;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7421",
        "func_name": "qemu/pvscsi_ring_pop_req_descr",
        "description": "The pvscsi_ring_pop_req_descr function in hw/scsi/vmw_pvscsi.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) by leveraging failure to limit process IO loop to the ring size.",
        "git_url": "https://github.com/qemu/qemu/commit/d251157ac1928191af851d199a9ff255d330bec9",
        "commit_title": "scsi: pvscsi: limit process IO loop to ring size",
        "commit_text": " Vmware Paravirtual SCSI emulator while processing IO requests could run into an infinite loop if 'pvscsi_ring_pop_req_descr' always returned positive value. Limit IO loop to the ring size.  Cc: qemu-stable@nongnu.org Message-Id: <1473845952-30785-1-git-send-email-ppandit@redhat.com>",
        "func_before": "static hwaddr\npvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n{\n    uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n\n    if (ready_ptr != mgr->consumed_ptr) {\n        uint32_t next_ready_ptr =\n            mgr->consumed_ptr++ & mgr->txr_len_mask;\n        uint32_t next_ready_page =\n            next_ready_ptr / PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n        uint32_t inpage_idx =\n            next_ready_ptr % PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}",
        "func": "static hwaddr\npvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n{\n    uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n    uint32_t ring_size = PVSCSI_MAX_NUM_PAGES_REQ_RING\n                            * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n\n    if (ready_ptr != mgr->consumed_ptr\n        && ready_ptr - mgr->consumed_ptr < ring_size) {\n        uint32_t next_ready_ptr =\n            mgr->consumed_ptr++ & mgr->txr_len_mask;\n        uint32_t next_ready_page =\n            next_ready_ptr / PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n        uint32_t inpage_idx =\n            next_ready_ptr % PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,11 @@\n pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n {\n     uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n+    uint32_t ring_size = PVSCSI_MAX_NUM_PAGES_REQ_RING\n+                            * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n \n-    if (ready_ptr != mgr->consumed_ptr) {\n+    if (ready_ptr != mgr->consumed_ptr\n+        && ready_ptr - mgr->consumed_ptr < ring_size) {\n         uint32_t next_ready_ptr =\n             mgr->consumed_ptr++ & mgr->txr_len_mask;\n         uint32_t next_ready_page =",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ready_ptr != mgr->consumed_ptr) {"
            ],
            "added_lines": [
                "    uint32_t ring_size = PVSCSI_MAX_NUM_PAGES_REQ_RING",
                "                            * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;",
                "    if (ready_ptr != mgr->consumed_ptr",
                "        && ready_ptr - mgr->consumed_ptr < ring_size) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11188",
        "func_name": "ImageMagick/ReadDPXImage",
        "description": "The ReadDPXImage function in coders\\dpx.c in ImageMagick 7.0.6-0 has a large loop vulnerability that can cause CPU exhaustion via a crafted DPX file, related to lack of an EOF check.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/42ceb8ee940a4c0bddeaf22e5a9c20cea2e85a8f",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/509",
        "commit_text": "",
        "func_before": "static Image *ReadDPXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[4],\n    value[MaxTextExtent];\n\n  DPXInfo\n    dpx;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent,\n    samples_per_pixel;\n\n  ssize_t\n    count,\n    n,\n    row,\n    y;\n\n  unsigned char\n    component_type;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read DPX file header.\n  */\n  offset=0;\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  offset+=count;\n  if ((count != 4) || ((LocaleNCompare(magick,\"SDPX\",4) != 0) &&\n      (LocaleNCompare((char *) magick,\"XPDS\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->endian=LSBEndian;\n  if (LocaleNCompare(magick,\"SDPX\",4) == 0)\n    image->endian=MSBEndian;\n  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));\n  dpx.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.version),(unsigned char *)\n    dpx.file.version);\n  (void) FormatImageProperty(image,\"dpx:file.version\",\"%.8s\",dpx.file.version);\n  dpx.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.ditto_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.ditto_key != ~0U)\n    (void) FormatImageProperty(image,\"dpx:file.ditto.key\",\"%u\",\n      dpx.file.ditto_key);\n  dpx.file.generic_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.industry_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.user_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.filename),(unsigned char *)\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\"dpx:file.filename\",\"%.100s\",\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\"document\",\"%.100s\",dpx.file.filename);\n  offset+=ReadBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)\n    dpx.file.timestamp);\n  if (*dpx.file.timestamp != '\\0')\n    (void) FormatImageProperty(image,\"dpx:file.timestamp\",\"%.24s\",\n      dpx.file.timestamp);\n  offset+=ReadBlob(image,sizeof(dpx.file.creator),(unsigned char *)\n    dpx.file.creator);\n  if (*dpx.file.creator == '\\0')\n    {\n      char\n        *url;\n\n      url=GetMagickHomeURL();\n      (void) FormatImageProperty(image,\"dpx:file.creator\",\"%.100s\",url);\n      (void) FormatImageProperty(image,\"software\",\"%.100s\",url);\n      url=DestroyString(url);\n    }\n  else\n    {\n      (void) FormatImageProperty(image,\"dpx:file.creator\",\"%.100s\",\n        dpx.file.creator);\n      (void) FormatImageProperty(image,\"software\",\"%.100s\",dpx.file.creator);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.project),(unsigned char *)\n    dpx.file.project);\n  if (*dpx.file.project != '\\0')\n    {\n      (void) FormatImageProperty(image,\"dpx:file.project\",\"%.200s\",\n        dpx.file.project);\n      (void) FormatImageProperty(image,\"comment\",\"%.100s\",dpx.file.project);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.copyright),(unsigned char *)\n    dpx.file.copyright);\n  if (*dpx.file.copyright != '\\0')\n    {\n      (void) FormatImageProperty(image,\"dpx:file.copyright\",\"%.200s\",\n        dpx.file.copyright);\n      (void) FormatImageProperty(image,\"copyright\",\"%.100s\",\n        dpx.file.copyright);\n    }\n  dpx.file.encrypt_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.encrypt_key != ~0U)\n    (void) FormatImageProperty(image,\"dpx:file.encrypt_key\",\"%u\",\n      dpx.file.encrypt_key);\n  offset+=ReadBlob(image,sizeof(dpx.file.reserve),(unsigned char *)\n    dpx.file.reserve);\n  /*\n    Read DPX image header.\n  */\n  dpx.image.orientation=ReadBlobShort(image);\n  if (dpx.image.orientation > 7)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=2;\n  if (dpx.image.orientation != (unsigned short) ~0)\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      dpx.image.orientation);\n  switch (dpx.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  dpx.image.number_elements=ReadBlobShort(image);\n  if (dpx.image.number_elements > MaxNumberImageElements)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=2;\n  dpx.image.pixels_per_line=ReadBlobLong(image);\n  offset+=4;\n  image->columns=dpx.image.pixels_per_line;\n  dpx.image.lines_per_element=ReadBlobLong(image);\n  offset+=4;\n  image->rows=dpx.image.lines_per_element;\n  for (i=0; i < 8; i++)\n  {\n    char\n      property[MaxTextExtent];\n\n    dpx.image.image_element[i].data_sign=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].high_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].high_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].descriptor=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].transfer_characteristic=(unsigned char)\n      ReadBlobByte(image);\n    (void) FormatLocaleString(property,MaxTextExtent,\n      \"dpx:image.element[%lu].transfer-characteristic\",(long) i);\n    (void) FormatImageProperty(image,property,\"%s\",\n      GetImageTransferCharacteristic((DPXTransferCharacteristic)\n      dpx.image.image_element[i].transfer_characteristic));\n    offset++;\n    dpx.image.image_element[i].colorimetric=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].bit_size=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].packing=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].encoding=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].data_offset=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_line_padding=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_image_padding=ReadBlobLong(image);\n    offset+=4;\n    offset+=ReadBlob(image,sizeof(dpx.image.image_element[i].description),\n      (unsigned char *) dpx.image.image_element[i].description);\n  }\n  (void) SetImageColorspace(image,RGBColorspace);\n  offset+=ReadBlob(image,sizeof(dpx.image.reserve),(unsigned char *)\n    dpx.image.reserve);\n  if (dpx.file.image_offset >= 1664U)\n    {\n      /*\n        Read DPX orientation header.\n      */\n      dpx.orientation.x_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_offset != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_offset\",\"%u\",\n          dpx.orientation.x_offset);\n      dpx.orientation.y_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_offset != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_offset\",\"%u\",\n          dpx.orientation.y_offset);\n      dpx.orientation.x_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.x_center) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_center\",\"%g\",\n          dpx.orientation.x_center);\n      dpx.orientation.y_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.y_center) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_center\",\"%g\",\n          dpx.orientation.y_center);\n      dpx.orientation.x_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_size != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_size\",\"%u\",\n          dpx.orientation.x_size);\n      dpx.orientation.y_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_size != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_size\",\"%u\",\n          dpx.orientation.y_size);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)\n        dpx.orientation.filename);\n      if (*dpx.orientation.filename != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.filename\",\"%.100s\",\n          dpx.orientation.filename);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)\n        dpx.orientation.timestamp);\n      if (*dpx.orientation.timestamp != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.timestamp\",\"%.24s\",\n          dpx.orientation.timestamp);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.device),(unsigned char *)\n        dpx.orientation.device);\n      if (*dpx.orientation.device != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.device\",\"%.32s\",\n          dpx.orientation.device);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)\n        dpx.orientation.serial);\n      if (*dpx.orientation.serial != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.serial\",\"%.32s\",\n          dpx.orientation.serial);\n      for (i=0; i < 4; i++)\n      {\n        dpx.orientation.border[i]=ReadBlobShort(image);\n        offset+=2;\n      }\n      if ((dpx.orientation.border[0] != (unsigned short) (~0)) &&\n          (dpx.orientation.border[1] != (unsigned short) (~0)))\n        (void) FormatImageProperty(image,\"dpx:orientation.border\",\"%dx%d%+d%+d\",          dpx.orientation.border[0],dpx.orientation.border[1],\n          dpx.orientation.border[2],dpx.orientation.border[3]);\n      for (i=0; i < 2; i++)\n      {\n        dpx.orientation.aspect_ratio[i]=ReadBlobLong(image);\n        offset+=4;\n      }\n      if ((dpx.orientation.aspect_ratio[0] != ~0U) &&\n          (dpx.orientation.aspect_ratio[1] != ~0U))\n        (void) FormatImageProperty(image,\"dpx:orientation.aspect_ratio\",\n          \"%ux%u\",dpx.orientation.aspect_ratio[0],\n          dpx.orientation.aspect_ratio[1]);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)\n        dpx.orientation.reserve);\n    }\n  if (dpx.file.image_offset >= 1920U)\n    {\n      /*\n        Read DPX film header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);\n      if (*dpx.film.id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%.2s\",dpx.film.id);\n      offset+=ReadBlob(image,sizeof(dpx.film.type),(unsigned char *)\n        dpx.film.type);\n      if (*dpx.film.type != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%.2s\",dpx.film.type);\n      offset+=ReadBlob(image,sizeof(dpx.film.offset),(unsigned char *)\n        dpx.film.offset);\n      if (*dpx.film.offset != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%.2s\",\n          dpx.film.offset);\n      offset+=ReadBlob(image,sizeof(dpx.film.prefix),(unsigned char *)\n        dpx.film.prefix);\n      if (*dpx.film.prefix != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.6s\",\n          dpx.film.prefix);\n      offset+=ReadBlob(image,sizeof(dpx.film.count),(unsigned char *)\n        dpx.film.count);\n      if (*dpx.film.count != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.count\",\"%.4s\",\n          dpx.film.count);\n      offset+=ReadBlob(image,sizeof(dpx.film.format),(unsigned char *)\n        dpx.film.format);\n      if (*dpx.film.format != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.format\",\"%.4s\",\n          dpx.film.format);\n      dpx.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.frame_position != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%u\",\n          dpx.film.frame_position);\n      dpx.film.sequence_extent=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.sequence_extent != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.sequence_extent\",\"%u\",\n          dpx.film.sequence_extent);\n      dpx.film.held_count=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.held_count != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.held_count\",\"%u\",\n          dpx.film.held_count);\n      dpx.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          dpx.film.frame_rate);\n      dpx.film.shutter_angle=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.shutter_angle) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.shutter_angle\",\"%g\",\n          dpx.film.shutter_angle);\n      offset+=ReadBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)\n        dpx.film.frame_id);\n      if (*dpx.film.frame_id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.frame_id\",\"%.32s\",\n          dpx.film.frame_id);\n      offset+=ReadBlob(image,sizeof(dpx.film.slate),(unsigned char *)\n        dpx.film.slate);\n      if (*dpx.film.slate != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.slate\",\"%.100s\",\n          dpx.film.slate);\n      offset+=ReadBlob(image,sizeof(dpx.film.reserve),(unsigned char *)\n        dpx.film.reserve);\n    }\n  if (dpx.file.image_offset >= 2048U)\n    {\n      /*\n        Read DPX television header.\n      */\n      dpx.television.time_code=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.time_code,value);\n      (void) SetImageProperty(image,\"dpx:television.time.code\",value);\n      dpx.television.user_bits=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.user_bits,value);\n      (void) SetImageProperty(image,\"dpx:television.user.bits\",value);\n      dpx.television.interlace=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.interlace != 0)\n        (void) FormatImageProperty(image,\"dpx:television.interlace\",\"%.20g\",\n          (double) dpx.television.interlace);\n      dpx.television.field_number=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.field_number != 0)\n        (void) FormatImageProperty(image,\"dpx:television.field_number\",\"%.20g\",\n          (double) dpx.television.field_number);\n      dpx.television.video_signal=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.video_signal != 0)\n        (void) FormatImageProperty(image,\"dpx:television.video_signal\",\"%.20g\",\n          (double) dpx.television.video_signal);\n      dpx.television.padding=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.padding != 0)\n        (void) FormatImageProperty(image,\"dpx:television.padding\",\"%d\",\n          dpx.television.padding);\n      dpx.television.horizontal_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.horizontal_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\n          \"dpx:television.horizontal_sample_rate\",\"%g\",\n          dpx.television.horizontal_sample_rate);\n      dpx.television.vertical_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.vertical_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.vertical_sample_rate\",\n          \"%g\",dpx.television.vertical_sample_rate);\n      dpx.television.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.frame_rate\",\"%g\",\n          dpx.television.frame_rate);\n      dpx.television.time_offset=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.time_offset) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.time_offset\",\"%g\",\n          dpx.television.time_offset);\n      dpx.television.gamma=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.gamma) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.gamma\",\"%g\",\n          dpx.television.gamma);\n      dpx.television.black_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_level) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.black_level\",\"%g\",\n          dpx.television.black_level);\n      dpx.television.black_gain=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_gain) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.black_gain\",\"%g\",\n          dpx.television.black_gain);\n      dpx.television.break_point=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.break_point) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.break_point\",\"%g\",\n          dpx.television.break_point);\n      dpx.television.white_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.white_level) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.white_level\",\"%g\",\n          dpx.television.white_level);\n      dpx.television.integration_times=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.integration_times) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.integration_times\",\n          \"%g\",dpx.television.integration_times);\n      offset+=ReadBlob(image,sizeof(dpx.television.reserve),(unsigned char *)\n        dpx.television.reserve);\n    }\n  if (dpx.file.image_offset > 2080U)\n    {\n      /*\n        Read DPX user header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);\n      if (*dpx.user.id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:user.id\",\"%.32s\",dpx.user.id);\n      if ((dpx.file.user_size != ~0U) &&\n          ((size_t) dpx.file.user_size > sizeof(dpx.user.id)))\n        {\n          StringInfo\n            *profile;\n\n           profile=BlobToStringInfo((const void *) NULL,\n             dpx.file.user_size-sizeof(dpx.user.id));\n           if (profile == (StringInfo *) NULL)\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           offset+=ReadBlob(image,GetStringInfoLength(profile),\n             GetStringInfoDatum(profile));\n           (void) SetImageProfile(image,\"dpx:user-data\",profile);\n           profile=DestroyStringInfo(profile);\n        }\n    }\n  for ( ; offset < (MagickOffsetType) dpx.file.image_offset; offset++)\n    (void) ReadBlobByte(image);\n  /*\n    Read DPX image header.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  for (n=0; n < (ssize_t) dpx.image.number_elements; n++)\n  {\n    /*\n      Convert DPX raster image to pixel packets.\n    */\n    if ((dpx.image.image_element[n].data_offset != ~0U) &&\n        (dpx.image.image_element[n].data_offset != 0U))\n      {\n         MagickOffsetType\n           data_offset;\n\n         data_offset=(MagickOffsetType) dpx.image.image_element[n].data_offset;\n         if (data_offset < offset)\n           offset=SeekBlob(image,data_offset,SEEK_SET);\n         else\n           for ( ; offset < data_offset; offset++)\n             (void) ReadBlobByte(image);\n          if (offset != data_offset)\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n       }\n    SetPrimaryChromaticity((DPXColorimetric)\n      dpx.image.image_element[n].colorimetric,&image->chromaticity);\n    image->depth=dpx.image.image_element[n].bit_size;\n    samples_per_pixel=1;\n    quantum_type=GrayQuantum;\n    component_type=dpx.image.image_element[n].descriptor;\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      {\n        samples_per_pixel=2;\n        quantum_type=CbYCrYQuantum;\n        break;\n      }\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=CbYCrQuantum;\n        break;\n      }\n      case RGBComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=RGBQuantum;\n        break;\n      }\n      case ABGRComponentType:\n      case RGBAComponentType:\n      {\n        image->matte=MagickTrue;\n        samples_per_pixel=4;\n        quantum_type=RGBAQuantum;\n        break;\n      }\n      default:\n        break;\n    }\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        (void) SetImageColorspace(image,Rec709YCbCrColorspace);\n        break;\n      }\n      case LumaComponentType:\n      {\n        (void) SetImageColorspace(image,GRAYColorspace);\n        break;\n      }\n      default:\n      {\n        (void) SetImageColorspace(image,RGBColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == LogarithmicColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == PrintingDensityColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        break;\n      }\n    }\n    extent=GetBytesPerRow(image->columns,samples_per_pixel,image->depth,\n      dpx.image.image_element[n].packing == 0 ? MagickFalse : MagickTrue);\n    /*\n      DPX any-bit pixel format.\n    */\n    status=MagickTrue;\n    row=0;\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    SetQuantumQuantum(quantum_info,32);\n    SetQuantumPack(quantum_info,dpx.image.image_element[n].packing == 0 ?\n      MagickTrue : MagickFalse);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      const unsigned char\n        *pixels;\n\n      MagickBooleanType\n        sync;\n\n      register PixelPacket\n        *q;\n\n      size_t\n        length;\n\n      ssize_t\n        count,\n        offset;\n\n      if (status == MagickFalse)\n        continue;\n      pixels=(const unsigned char *) ReadBlobStream(image,extent,\n        GetQuantumPixels(quantum_info),&count);\n      if (count != (ssize_t) extent)\n        status=MagickFalse;\n      if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n          (image->previous == (Image *) NULL))\n        {\n          MagickBooleanType\n            proceed;\n\n          proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row,\n            image->rows);\n          if (proceed == MagickFalse)\n            status=MagickFalse;\n        }\n      offset=row++;\n      q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        {\n          status=MagickFalse;\n          continue;\n        }\n      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        quantum_type,pixels,exception);\n      (void) length;\n      sync=SyncAuthenticPixels(image,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (status == MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    SetQuantumImageType(image,quantum_type);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadDPXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[4],\n    value[MaxTextExtent];\n\n  DPXInfo\n    dpx;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent,\n    samples_per_pixel;\n\n  ssize_t\n    count,\n    n,\n    row,\n    y;\n\n  unsigned char\n    component_type;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read DPX file header.\n  */\n  offset=0;\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  offset+=count;\n  if ((count != 4) || ((LocaleNCompare(magick,\"SDPX\",4) != 0) &&\n      (LocaleNCompare((char *) magick,\"XPDS\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->endian=LSBEndian;\n  if (LocaleNCompare(magick,\"SDPX\",4) == 0)\n    image->endian=MSBEndian;\n  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));\n  dpx.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.version),(unsigned char *)\n    dpx.file.version);\n  (void) FormatImageProperty(image,\"dpx:file.version\",\"%.8s\",dpx.file.version);\n  dpx.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.ditto_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.ditto_key != ~0U)\n    (void) FormatImageProperty(image,\"dpx:file.ditto.key\",\"%u\",\n      dpx.file.ditto_key);\n  dpx.file.generic_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.industry_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.user_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.filename),(unsigned char *)\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\"dpx:file.filename\",\"%.100s\",\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\"document\",\"%.100s\",dpx.file.filename);\n  offset+=ReadBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)\n    dpx.file.timestamp);\n  if (*dpx.file.timestamp != '\\0')\n    (void) FormatImageProperty(image,\"dpx:file.timestamp\",\"%.24s\",\n      dpx.file.timestamp);\n  offset+=ReadBlob(image,sizeof(dpx.file.creator),(unsigned char *)\n    dpx.file.creator);\n  if (*dpx.file.creator == '\\0')\n    {\n      char\n        *url;\n\n      url=GetMagickHomeURL();\n      (void) FormatImageProperty(image,\"dpx:file.creator\",\"%.100s\",url);\n      (void) FormatImageProperty(image,\"software\",\"%.100s\",url);\n      url=DestroyString(url);\n    }\n  else\n    {\n      (void) FormatImageProperty(image,\"dpx:file.creator\",\"%.100s\",\n        dpx.file.creator);\n      (void) FormatImageProperty(image,\"software\",\"%.100s\",dpx.file.creator);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.project),(unsigned char *)\n    dpx.file.project);\n  if (*dpx.file.project != '\\0')\n    {\n      (void) FormatImageProperty(image,\"dpx:file.project\",\"%.200s\",\n        dpx.file.project);\n      (void) FormatImageProperty(image,\"comment\",\"%.100s\",dpx.file.project);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.copyright),(unsigned char *)\n    dpx.file.copyright);\n  if (*dpx.file.copyright != '\\0')\n    {\n      (void) FormatImageProperty(image,\"dpx:file.copyright\",\"%.200s\",\n        dpx.file.copyright);\n      (void) FormatImageProperty(image,\"copyright\",\"%.100s\",\n        dpx.file.copyright);\n    }\n  dpx.file.encrypt_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.encrypt_key != ~0U)\n    (void) FormatImageProperty(image,\"dpx:file.encrypt_key\",\"%u\",\n      dpx.file.encrypt_key);\n  offset+=ReadBlob(image,sizeof(dpx.file.reserve),(unsigned char *)\n    dpx.file.reserve);\n  /*\n    Read DPX image header.\n  */\n  dpx.image.orientation=ReadBlobShort(image);\n  if (dpx.image.orientation > 7)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=2;\n  if (dpx.image.orientation != (unsigned short) ~0)\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      dpx.image.orientation);\n  switch (dpx.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  dpx.image.number_elements=ReadBlobShort(image);\n  if (dpx.image.number_elements > MaxNumberImageElements)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=2;\n  dpx.image.pixels_per_line=ReadBlobLong(image);\n  offset+=4;\n  image->columns=dpx.image.pixels_per_line;\n  dpx.image.lines_per_element=ReadBlobLong(image);\n  offset+=4;\n  image->rows=dpx.image.lines_per_element;\n  for (i=0; i < 8; i++)\n  {\n    char\n      property[MaxTextExtent];\n\n    dpx.image.image_element[i].data_sign=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].high_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].high_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].descriptor=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].transfer_characteristic=(unsigned char)\n      ReadBlobByte(image);\n    (void) FormatLocaleString(property,MaxTextExtent,\n      \"dpx:image.element[%lu].transfer-characteristic\",(long) i);\n    (void) FormatImageProperty(image,property,\"%s\",\n      GetImageTransferCharacteristic((DPXTransferCharacteristic)\n      dpx.image.image_element[i].transfer_characteristic));\n    offset++;\n    dpx.image.image_element[i].colorimetric=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].bit_size=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].packing=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].encoding=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].data_offset=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_line_padding=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_image_padding=ReadBlobLong(image);\n    offset+=4;\n    offset+=ReadBlob(image,sizeof(dpx.image.image_element[i].description),\n      (unsigned char *) dpx.image.image_element[i].description);\n  }\n  (void) SetImageColorspace(image,RGBColorspace);\n  offset+=ReadBlob(image,sizeof(dpx.image.reserve),(unsigned char *)\n    dpx.image.reserve);\n  if (dpx.file.image_offset >= 1664U)\n    {\n      /*\n        Read DPX orientation header.\n      */\n      dpx.orientation.x_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_offset != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_offset\",\"%u\",\n          dpx.orientation.x_offset);\n      dpx.orientation.y_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_offset != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_offset\",\"%u\",\n          dpx.orientation.y_offset);\n      dpx.orientation.x_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.x_center) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_center\",\"%g\",\n          dpx.orientation.x_center);\n      dpx.orientation.y_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.y_center) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_center\",\"%g\",\n          dpx.orientation.y_center);\n      dpx.orientation.x_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_size != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_size\",\"%u\",\n          dpx.orientation.x_size);\n      dpx.orientation.y_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_size != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_size\",\"%u\",\n          dpx.orientation.y_size);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)\n        dpx.orientation.filename);\n      if (*dpx.orientation.filename != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.filename\",\"%.100s\",\n          dpx.orientation.filename);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)\n        dpx.orientation.timestamp);\n      if (*dpx.orientation.timestamp != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.timestamp\",\"%.24s\",\n          dpx.orientation.timestamp);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.device),(unsigned char *)\n        dpx.orientation.device);\n      if (*dpx.orientation.device != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.device\",\"%.32s\",\n          dpx.orientation.device);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)\n        dpx.orientation.serial);\n      if (*dpx.orientation.serial != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.serial\",\"%.32s\",\n          dpx.orientation.serial);\n      for (i=0; i < 4; i++)\n      {\n        dpx.orientation.border[i]=ReadBlobShort(image);\n        offset+=2;\n      }\n      if ((dpx.orientation.border[0] != (unsigned short) (~0)) &&\n          (dpx.orientation.border[1] != (unsigned short) (~0)))\n        (void) FormatImageProperty(image,\"dpx:orientation.border\",\"%dx%d%+d%+d\",          dpx.orientation.border[0],dpx.orientation.border[1],\n          dpx.orientation.border[2],dpx.orientation.border[3]);\n      for (i=0; i < 2; i++)\n      {\n        dpx.orientation.aspect_ratio[i]=ReadBlobLong(image);\n        offset+=4;\n      }\n      if ((dpx.orientation.aspect_ratio[0] != ~0U) &&\n          (dpx.orientation.aspect_ratio[1] != ~0U))\n        (void) FormatImageProperty(image,\"dpx:orientation.aspect_ratio\",\n          \"%ux%u\",dpx.orientation.aspect_ratio[0],\n          dpx.orientation.aspect_ratio[1]);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)\n        dpx.orientation.reserve);\n    }\n  if (dpx.file.image_offset >= 1920U)\n    {\n      /*\n        Read DPX film header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);\n      if (*dpx.film.id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%.2s\",dpx.film.id);\n      offset+=ReadBlob(image,sizeof(dpx.film.type),(unsigned char *)\n        dpx.film.type);\n      if (*dpx.film.type != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%.2s\",dpx.film.type);\n      offset+=ReadBlob(image,sizeof(dpx.film.offset),(unsigned char *)\n        dpx.film.offset);\n      if (*dpx.film.offset != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%.2s\",\n          dpx.film.offset);\n      offset+=ReadBlob(image,sizeof(dpx.film.prefix),(unsigned char *)\n        dpx.film.prefix);\n      if (*dpx.film.prefix != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.6s\",\n          dpx.film.prefix);\n      offset+=ReadBlob(image,sizeof(dpx.film.count),(unsigned char *)\n        dpx.film.count);\n      if (*dpx.film.count != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.count\",\"%.4s\",\n          dpx.film.count);\n      offset+=ReadBlob(image,sizeof(dpx.film.format),(unsigned char *)\n        dpx.film.format);\n      if (*dpx.film.format != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.format\",\"%.4s\",\n          dpx.film.format);\n      dpx.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.frame_position != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%u\",\n          dpx.film.frame_position);\n      dpx.film.sequence_extent=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.sequence_extent != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.sequence_extent\",\"%u\",\n          dpx.film.sequence_extent);\n      dpx.film.held_count=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.held_count != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.held_count\",\"%u\",\n          dpx.film.held_count);\n      dpx.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          dpx.film.frame_rate);\n      dpx.film.shutter_angle=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.shutter_angle) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.shutter_angle\",\"%g\",\n          dpx.film.shutter_angle);\n      offset+=ReadBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)\n        dpx.film.frame_id);\n      if (*dpx.film.frame_id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.frame_id\",\"%.32s\",\n          dpx.film.frame_id);\n      offset+=ReadBlob(image,sizeof(dpx.film.slate),(unsigned char *)\n        dpx.film.slate);\n      if (*dpx.film.slate != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.slate\",\"%.100s\",\n          dpx.film.slate);\n      offset+=ReadBlob(image,sizeof(dpx.film.reserve),(unsigned char *)\n        dpx.film.reserve);\n    }\n  if (dpx.file.image_offset >= 2048U)\n    {\n      /*\n        Read DPX television header.\n      */\n      dpx.television.time_code=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.time_code,value);\n      (void) SetImageProperty(image,\"dpx:television.time.code\",value);\n      dpx.television.user_bits=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.user_bits,value);\n      (void) SetImageProperty(image,\"dpx:television.user.bits\",value);\n      dpx.television.interlace=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.interlace != 0)\n        (void) FormatImageProperty(image,\"dpx:television.interlace\",\"%.20g\",\n          (double) dpx.television.interlace);\n      dpx.television.field_number=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.field_number != 0)\n        (void) FormatImageProperty(image,\"dpx:television.field_number\",\"%.20g\",\n          (double) dpx.television.field_number);\n      dpx.television.video_signal=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.video_signal != 0)\n        (void) FormatImageProperty(image,\"dpx:television.video_signal\",\"%.20g\",\n          (double) dpx.television.video_signal);\n      dpx.television.padding=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.padding != 0)\n        (void) FormatImageProperty(image,\"dpx:television.padding\",\"%d\",\n          dpx.television.padding);\n      dpx.television.horizontal_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.horizontal_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\n          \"dpx:television.horizontal_sample_rate\",\"%g\",\n          dpx.television.horizontal_sample_rate);\n      dpx.television.vertical_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.vertical_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.vertical_sample_rate\",\n          \"%g\",dpx.television.vertical_sample_rate);\n      dpx.television.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.frame_rate\",\"%g\",\n          dpx.television.frame_rate);\n      dpx.television.time_offset=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.time_offset) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.time_offset\",\"%g\",\n          dpx.television.time_offset);\n      dpx.television.gamma=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.gamma) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.gamma\",\"%g\",\n          dpx.television.gamma);\n      dpx.television.black_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_level) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.black_level\",\"%g\",\n          dpx.television.black_level);\n      dpx.television.black_gain=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_gain) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.black_gain\",\"%g\",\n          dpx.television.black_gain);\n      dpx.television.break_point=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.break_point) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.break_point\",\"%g\",\n          dpx.television.break_point);\n      dpx.television.white_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.white_level) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.white_level\",\"%g\",\n          dpx.television.white_level);\n      dpx.television.integration_times=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.integration_times) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.integration_times\",\n          \"%g\",dpx.television.integration_times);\n      offset+=ReadBlob(image,sizeof(dpx.television.reserve),(unsigned char *)\n        dpx.television.reserve);\n    }\n  if (dpx.file.image_offset > 2080U)\n    {\n      /*\n        Read DPX user header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);\n      if (*dpx.user.id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:user.id\",\"%.32s\",dpx.user.id);\n      if ((dpx.file.user_size != ~0U) &&\n          ((size_t) dpx.file.user_size > sizeof(dpx.user.id)))\n        {\n          StringInfo\n            *profile;\n\n           profile=BlobToStringInfo((const void *) NULL,\n             dpx.file.user_size-sizeof(dpx.user.id));\n           if (profile == (StringInfo *) NULL)\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           offset+=ReadBlob(image,GetStringInfoLength(profile),\n             GetStringInfoDatum(profile));\n           (void) SetImageProfile(image,\"dpx:user-data\",profile);\n           profile=DestroyStringInfo(profile);\n        }\n    }\n  for ( ; offset < (MagickOffsetType) dpx.file.image_offset; offset++)\n    if (ReadBlobByte(image) == EOF)\n      break;\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  for (n=0; n < (ssize_t) dpx.image.number_elements; n++)\n  {\n    /*\n      Convert DPX raster image to pixel packets.\n    */\n    if ((dpx.image.image_element[n].data_offset != ~0U) &&\n        (dpx.image.image_element[n].data_offset != 0U))\n      {\n         MagickOffsetType\n           data_offset;\n\n         data_offset=(MagickOffsetType) dpx.image.image_element[n].data_offset;\n         if (data_offset < offset)\n           offset=SeekBlob(image,data_offset,SEEK_SET);\n         else\n           for ( ; offset < data_offset; offset++)\n             (void) ReadBlobByte(image);\n          if (offset != data_offset)\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n       }\n    SetPrimaryChromaticity((DPXColorimetric)\n      dpx.image.image_element[n].colorimetric,&image->chromaticity);\n    image->depth=dpx.image.image_element[n].bit_size;\n    samples_per_pixel=1;\n    quantum_type=GrayQuantum;\n    component_type=dpx.image.image_element[n].descriptor;\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      {\n        samples_per_pixel=2;\n        quantum_type=CbYCrYQuantum;\n        break;\n      }\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=CbYCrQuantum;\n        break;\n      }\n      case RGBComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=RGBQuantum;\n        break;\n      }\n      case ABGRComponentType:\n      case RGBAComponentType:\n      {\n        image->matte=MagickTrue;\n        samples_per_pixel=4;\n        quantum_type=RGBAQuantum;\n        break;\n      }\n      default:\n        break;\n    }\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        (void) SetImageColorspace(image,Rec709YCbCrColorspace);\n        break;\n      }\n      case LumaComponentType:\n      {\n        (void) SetImageColorspace(image,GRAYColorspace);\n        break;\n      }\n      default:\n      {\n        (void) SetImageColorspace(image,RGBColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == LogarithmicColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == PrintingDensityColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        break;\n      }\n    }\n    extent=GetBytesPerRow(image->columns,samples_per_pixel,image->depth,\n      dpx.image.image_element[n].packing == 0 ? MagickFalse : MagickTrue);\n    /*\n      DPX any-bit pixel format.\n    */\n    status=MagickTrue;\n    row=0;\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    SetQuantumQuantum(quantum_info,32);\n    SetQuantumPack(quantum_info,dpx.image.image_element[n].packing == 0 ?\n      MagickTrue : MagickFalse);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      const unsigned char\n        *pixels;\n\n      MagickBooleanType\n        sync;\n\n      register PixelPacket\n        *q;\n\n      size_t\n        length;\n\n      ssize_t\n        count,\n        offset;\n\n      if (status == MagickFalse)\n        continue;\n      pixels=(const unsigned char *) ReadBlobStream(image,extent,\n        GetQuantumPixels(quantum_info),&count);\n      if (count != (ssize_t) extent)\n        status=MagickFalse;\n      if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n          (image->previous == (Image *) NULL))\n        {\n          MagickBooleanType\n            proceed;\n\n          proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row,\n            image->rows);\n          if (proceed == MagickFalse)\n            status=MagickFalse;\n        }\n      offset=row++;\n      q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        {\n          status=MagickFalse;\n          continue;\n        }\n      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        quantum_type,pixels,exception);\n      (void) length;\n      sync=SyncAuthenticPixels(image,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (status == MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    SetQuantumImageType(image,quantum_type);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -474,10 +474,11 @@\n         }\n     }\n   for ( ; offset < (MagickOffsetType) dpx.file.image_offset; offset++)\n-    (void) ReadBlobByte(image);\n-  /*\n-    Read DPX image header.\n-  */\n+    if (ReadBlobByte(image) == EOF)\n+      break;\n+  if (EOFBlob(image) != MagickFalse)\n+    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n+      image->filename);\n   if (image_info->ping != MagickFalse)\n     {\n       (void) CloseBlob(image);",
        "diff_line_info": {
            "deleted_lines": [
                "    (void) ReadBlobByte(image);",
                "  /*",
                "    Read DPX image header.",
                "  */"
            ],
            "added_lines": [
                "    if (ReadBlobByte(image) == EOF)",
                "      break;",
                "  if (EOFBlob(image) != MagickFalse)",
                "    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
                "      image->filename);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11360",
        "func_name": "ImageMagick/ReadRLEImage",
        "description": "The ReadRLEImage function in coders\\rle.c in ImageMagick 7.0.6-1 has a large loop vulnerability via a crafted rle file that triggers a huge number_pixels value.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/078e9692a257e7a8aa36ccc750927f9617923061",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/518",
        "commit_text": "",
        "func_before": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n#define ThrowRLEException(exception,message) \\\n{ \\\n  if (colormap != (unsigned char *) NULL) \\\n    colormap=(unsigned char *) RelinquishMagickMemory(colormap); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  colormap=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=(ssize_t) ReadBlobLSBShort(image);\n    image->page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n          {\n            *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(\n              ReadBlobLSBShort(image)));\n            if (EOFBlob(image) != MagickFalse)\n              ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info_length=image->columns*image->rows*\n      MagickMax(number_planes_filled,4);\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    if (opcode == EOF)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n      if (opcode == EOF)\n        ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            ValidateColormapValue(image,(ssize_t) (*p & mask),&index,exception);\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) (x*map_length+\n                  (*p & mask)),&index,exception);\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,(Quantum) *p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define SkipLinesOp  0x01\n#define SetColorOp  0x02\n#define SkipPixelsOp  0x03\n#define ByteDataOp  0x05\n#define RunDataOp  0x06\n#define EOFOp  0x07\n#define ThrowRLEException(exception,message) \\\n{ \\\n  if (colormap != (unsigned char *) NULL) \\\n    colormap=(unsigned char *) RelinquishMagickMemory(colormap); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    magick[12];\n\n  Image\n    *image;\n\n  int\n    opcode,\n    operand,\n    status;\n\n  MagickStatusType\n    flags;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    map_length,\n    number_colormaps,\n    number_planes,\n    number_planes_filled,\n    one,\n    pixel_info_length;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  unsigned char\n    background_color[256],\n    *colormap,\n    pixel,\n    plane,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Determine if this a RLE file.\n  */\n  colormap=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  count=ReadBlob(image,2,(unsigned char *) magick);\n  if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Read image header.\n    */\n    image->page.x=(ssize_t) ReadBlobLSBShort(image);\n    image->page.y=(ssize_t) ReadBlobLSBShort(image);\n    image->columns=ReadBlobLSBShort(image);\n    image->rows=ReadBlobLSBShort(image);\n    flags=(MagickStatusType) ReadBlobByte(image);\n    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;\n    number_planes=(size_t) ReadBlobByte(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    number_colormaps=(size_t) ReadBlobByte(image);\n    map_length=(unsigned char) ReadBlobByte(image);\n    if (map_length >= 22)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    one=1;\n    map_length=one << map_length;\n    if ((number_planes == 0) || (number_planes == 2) ||\n        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||\n        (image->columns == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (flags & 0x02)\n      {\n        /*\n          No background color-- initialize to black.\n        */\n        for (i=0; i < (ssize_t) number_planes; i++)\n          background_color[i]=0;\n        (void) ReadBlobByte(image);\n      }\n    else\n      {\n        /*\n          Initialize background color.\n        */\n        p=background_color;\n        for (i=0; i < (ssize_t) number_planes; i++)\n          *p++=(unsigned char) ReadBlobByte(image);\n      }\n    if ((number_planes & 0x01) == 0)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    if (image->alpha_trait != UndefinedPixelTrait)\n      number_planes++;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((GetBlobSize(image) == 0) || ((((MagickSizeType) number_pixels*\n         number_planes*bits_per_pixel/8)/GetBlobSize(image)) > 254.0))\n      ThrowRLEException(CorruptImageError,\"InsufficientImageDataInFile\")\n    if (((MagickSizeType) number_colormaps*map_length) > GetBlobSize(image))\n      ThrowRLEException(CorruptImageError,\"InsufficientImageDataInFile\")\n    if (number_colormaps != 0)\n      {\n        /*\n          Read image colormaps.\n        */\n        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,\n          3*map_length*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        for (i=0; i < (ssize_t) number_colormaps; i++)\n          for (x=0; x < (ssize_t) map_length; x++)\n          {\n            *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(\n              ReadBlobLSBShort(image)));\n            if (EOFBlob(image) != MagickFalse)\n              ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n      }\n    if ((flags & 0x08) != 0)\n      {\n        char\n          *comment;\n\n        size_t\n          length;\n\n        /*\n          Read image comment.\n        */\n        length=ReadBlobLSBShort(image);\n        if (length != 0)\n          {\n            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));\n            if (comment == (char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            count=ReadBlob(image,length-1,(unsigned char *) comment);\n            comment[length-1]='\\0';\n            (void) SetImageProperty(image,\"comment\",comment,exception);\n            comment=DestroyString(comment);\n            if ((length & 0x01) == 0)\n              (void) ReadBlobByte(image);\n          }\n      }\n    if (EOFBlob(image) != MagickFalse)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate RLE pixels.\n    */\n    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n      number_planes+1;\n    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n         number_planes_filled))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(image->columns,image->rows*\n      MagickMax(number_planes_filled,4)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info_length=image->columns*image->rows*\n      MagickMax(number_planes_filled,4);\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) ResetMagickMemory(pixels,0,pixel_info_length);\n    if ((flags & 0x01) && !(flags & 0x02))\n      {\n        ssize_t\n          j;\n\n        /*\n          Set background color.\n        */\n        p=pixels;\n        for (i=0; i < (ssize_t) number_pixels; i++)\n        {\n          if (image->alpha_trait == UndefinedPixelTrait)\n            for (j=0; j < (ssize_t) number_planes; j++)\n              *p++=background_color[j];\n          else\n            {\n              for (j=0; j < (ssize_t) (number_planes-1); j++)\n                *p++=background_color[j];\n              *p++=0;  /* initialize matte channel */\n            }\n        }\n      }\n    /*\n      Read runlength-encoded image.\n    */\n    plane=0;\n    x=0;\n    y=0;\n    opcode=ReadBlobByte(image);\n    if (opcode == EOF)\n      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    do\n    {\n      switch (opcode & 0x3f)\n      {\n        case SkipLinesOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n          x=0;\n          y+=operand;\n          break;\n        }\n        case SetColorOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          plane=(unsigned char) operand;\n          if (plane == 255)\n            plane=(unsigned char) (number_planes-1);\n          x=0;\n          break;\n        }\n        case SkipPixelsOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n          x+=operand;\n          break;\n        }\n        case ByteDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            pixel=(unsigned char) ReadBlobByte(image);\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          if (operand & 0x01)\n            (void) ReadBlobByte(image);\n          x+=operand;\n          break;\n        }\n        case RunDataOp:\n        {\n          operand=ReadBlobByte(image);\n          if (operand == EOF)\n            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n          if (opcode & 0x40)\n            {\n              operand=ReadBlobLSBSignedShort(image);\n              if (operand == EOF)\n                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n            }\n          pixel=(unsigned char) ReadBlobByte(image);\n          (void) ReadBlobByte(image);\n          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n            number_planes+plane);\n          operand++;\n          if ((offset < 0) ||\n              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n            {\n              if (number_colormaps != 0)\n                colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            }\n          p=pixels+offset;\n          for (i=0; i < (ssize_t) operand; i++)\n          {\n            if ((y < (ssize_t) image->rows) &&\n                ((x+i) < (ssize_t) image->columns))\n              *p=pixel;\n            p+=number_planes;\n          }\n          x+=operand;\n          break;\n        }\n        default:\n          break;\n      }\n      opcode=ReadBlobByte(image);\n      if (opcode == EOF)\n        ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n    if (number_colormaps != 0)\n      {\n        MagickStatusType\n          mask;\n\n        /*\n          Apply colormap affineation to image.\n        */\n        mask=(MagickStatusType) (map_length-1);\n        p=pixels;\n        x=(ssize_t) number_planes;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) number_pixels; i++)\n          {\n            ValidateColormapValue(image,(ssize_t) (*p & mask),&index,exception);\n            *p=colormap[(ssize_t) index];\n            p++;\n          }\n        else\n          if ((number_planes >= 3) && (number_colormaps >= 3))\n            for (i=0; i < (ssize_t) number_pixels; i++)\n              for (x=0; x < (ssize_t) number_planes; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) (x*map_length+\n                  (*p & mask)),&index,exception);\n                *p=colormap[(ssize_t) index];\n                p++;\n              }\n        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))\n          {\n            colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          }\n      }\n    /*\n      Initialize image structure.\n    */\n    if (number_planes >= 3)\n      {\n        /*\n          Convert raster image to DirectClass pixel packets.\n        */\n        p=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        /*\n          Create colormap.\n        */\n        if (number_colormaps == 0)\n          map_length=256;\n        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        p=colormap;\n        if (number_colormaps == 1)\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            /*\n              Pseudocolor.\n            */\n            image->colormap[i].red=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].green=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n            image->colormap[i].blue=(MagickRealType)\n              ScaleCharToQuantum((unsigned char) i);\n          }\n        else\n          if (number_colormaps > 1)\n            for (i=0; i < (ssize_t) image->colors; i++)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum(*p);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length));\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum(*(p+map_length*2));\n              p++;\n            }\n        p=pixels;\n        if (image->alpha_trait == UndefinedPixelTrait)\n          {\n            /*\n              Convert raster image to PseudoClass pixel packets.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelIndex(image,(Quantum) *p++,q);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            (void) SyncImage(image,exception);\n          }\n        else\n          {\n            /*\n              Image has a matte channel-- promote to DirectClass.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].red),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].green),q);\n                ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                  index].blue),q);\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n                q+=GetPixelChannels(image);\n              }\n              if (x < (ssize_t) image->columns)\n                break;\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            image->colormap=(PixelInfo *) RelinquishMagickMemory(\n              image->colormap);\n            image->storage_class=DirectClass;\n            image->colors=0;\n          }\n      }\n    if (number_colormaps != 0)\n      colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    (void) ReadBlobByte(image);\n    count=ReadBlob(image,2,(unsigned char *) magick);\n    if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -140,6 +140,14 @@\n       (void) ReadBlobByte(image);\n     if (EOFBlob(image) != MagickFalse)\n       ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n+    if (image->alpha_trait != UndefinedPixelTrait)\n+      number_planes++;\n+    number_pixels=(MagickSizeType) image->columns*image->rows;\n+    if ((GetBlobSize(image) == 0) || ((((MagickSizeType) number_pixels*\n+         number_planes*bits_per_pixel/8)/GetBlobSize(image)) > 254.0))\n+      ThrowRLEException(CorruptImageError,\"InsufficientImageDataInFile\")\n+    if (((MagickSizeType) number_colormaps*map_length) > GetBlobSize(image))\n+      ThrowRLEException(CorruptImageError,\"InsufficientImageDataInFile\")\n     if (number_colormaps != 0)\n       {\n         /*\n@@ -195,9 +203,6 @@\n     /*\n       Allocate RLE pixels.\n     */\n-    if (image->alpha_trait != UndefinedPixelTrait)\n-      number_planes++;\n-    number_pixels=(MagickSizeType) image->columns*image->rows;\n     number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n       number_planes+1;\n     if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*",
        "diff_line_info": {
            "deleted_lines": [
                "    if (image->alpha_trait != UndefinedPixelTrait)",
                "      number_planes++;",
                "    number_pixels=(MagickSizeType) image->columns*image->rows;"
            ],
            "added_lines": [
                "    if (image->alpha_trait != UndefinedPixelTrait)",
                "      number_planes++;",
                "    number_pixels=(MagickSizeType) image->columns*image->rows;",
                "    if ((GetBlobSize(image) == 0) || ((((MagickSizeType) number_pixels*",
                "         number_planes*bits_per_pixel/8)/GetBlobSize(image)) > 254.0))",
                "      ThrowRLEException(CorruptImageError,\"InsufficientImageDataInFile\")",
                "    if (((MagickSizeType) number_colormaps*map_length) > GetBlobSize(image))",
                "      ThrowRLEException(CorruptImageError,\"InsufficientImageDataInFile\")"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11360",
        "func_name": "ImageMagick/RegisterRLEImage",
        "description": "The ReadRLEImage function in coders\\rle.c in ImageMagick 7.0.6-1 has a large loop vulnerability via a crafted rle file that triggers a huge number_pixels value.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/078e9692a257e7a8aa36ccc750927f9617923061",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/518",
        "commit_text": "",
        "func_before": "ModuleExport size_t RegisterRLEImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"RLE\",\"RLE\",\"Utah Run length encoded image\");\n  entry->decoder=(DecodeImageHandler *) ReadRLEImage;\n  entry->magick=(IsImageFormatHandler *) IsRLE;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "func": "ModuleExport size_t RegisterRLEImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"RLE\",\"RLE\",\"Utah Run length encoded image\");\n  entry->decoder=(DecodeImageHandler *) ReadRLEImage;\n  entry->magick=(IsImageFormatHandler *) IsRLE;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n   entry=AcquireMagickInfo(\"RLE\",\"RLE\",\"Utah Run length encoded image\");\n   entry->decoder=(DecodeImageHandler *) ReadRLEImage;\n   entry->magick=(IsImageFormatHandler *) IsRLE;\n+  entry->flags^=CoderBlobSupportFlag;\n   entry->flags^=CoderAdjoinFlag;\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  entry->flags^=CoderBlobSupportFlag;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14342",
        "func_name": "wireshark/dissect_bgp_update",
        "description": "In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the BGP protocol dissector could go into a large loop. This was addressed in epan/dissectors/packet-bgp.c by validating Path Attribute lengths.",
        "git_url": "https://github.com/wireshark/wireshark/commit/36af43dbb7673495948cd65d0346e8b9812b941c",
        "commit_title": "BGP: Validate length of Path Attribute records.",
        "commit_text": " Bug 13741 showed a case where the BGP dissector's failure to validate the length of the Path Attribute record allowed a pathological BGP UPDATE packet to generate more than one million items in the protocol tree by repeatedly dissecting certain segments of the packet.  It's easy enough to detect when the Path Attribute length cannot be valid, so let's do so.  When the condition arises, let's raise an Expert Info error in the same style and format as used elsewhere in the same routine, and abandon dissection of the Path Attributes list.  With this check in place, an incorrect length computation is revealed at a callsite.  This would only have prevented a small (less than 5 bytes) Path Attribute from being dissected if it was at the very end of the Path Attributes list, but the bounds checking added in this change makes this problem much more apparent, so we fix the length computation while we're here.  Testing Done: Built wireshark on Linux amd64.  Using bgp.pcap from the Sample    Captures page on the wiki, verified that the dissection of the UPDATE    packets were unaltered by this fix.  Using the capture attached to bug 13741    (clusterfuzz-testcase-minimized-6689222578667520.pcap), verified that the    packet no longer triggers the \"too many items\" exception, instead we see    an Expert Info for each oversized Path Attribute length, and eventually an    exception for \"length of contained item exceeds length of containing item\".    30,000 iterations of fuzz test with bgp.pcap as input, and many iterations    of randpkt-test too.  Crafted a packet with a 3-byte ATOMIC_AGGREGATE Path    Attribute at the end of the Path Attributes list; Before this change, an    exception is raised during dissection, but after this change it is dissected    correctly.  Bug: 13741 (cherry picked from commit 6e88943d0eabc8c8bc11334ba4213ec64129575c)",
        "func_before": "static void\ndissect_bgp_update(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo)\n{\n    guint16         hlen;                       /* message length           */\n    gint            o;                          /* packet offset            */\n    gint            end=0;                      /* message end              */\n    guint16         len;                        /* tmp                      */\n    proto_item      *ti;                        /* tree item                */\n    proto_tree      *subtree;                   /* subtree for attributes   */\n    int             i;                          /* tmp                      */\n\n    hlen = tvb_get_ntohs(tvb, BGP_MARKER_SIZE);\n    o = BGP_HEADER_SIZE;\n\n\n    /* check for withdrawals */\n    len = tvb_get_ntohs(tvb, o);\n    proto_tree_add_item(tree, hf_bgp_update_withdrawn_routes_length, tvb, o, 2, ENC_BIG_ENDIAN);\n    o += 2;\n\n    /* parse unfeasible prefixes */\n    if (len > 0) {\n        ti = proto_tree_add_item(tree, hf_bgp_update_withdrawn_routes, tvb, o, len, ENC_NA);\n        subtree = proto_item_add_subtree(ti, ett_bgp_unfeas);\n\n        /* parse each prefix */\n        end = o + len;\n\n        /* Heuristic to detect if IPv4 prefix are using Path Identifiers */\n        if( detect_add_path_prefix4(tvb, o, end) ) {\n            /* IPv4 prefixes with Path Id */\n            while (o < end) {\n                i = decode_path_prefix4(subtree, pinfo, hf_bgp_nlri_path_id, hf_bgp_withdrawn_prefix, tvb, o,\n                    \"Withdrawn route\");\n                if (i < 0)\n                    return;\n                o += i;\n            }\n        } else {\n            while (o < end) {\n                i = decode_prefix4(subtree, pinfo, NULL, hf_bgp_withdrawn_prefix, tvb, o,\n                    \"Withdrawn route\");\n                if (i < 0)\n                    return;\n                o += i;\n            }\n        }\n    }\n\n    /* check for advertisements */\n    len = tvb_get_ntohs(tvb, o);\n    proto_tree_add_item(tree, hf_bgp_update_total_path_attribute_length, tvb, o, 2, ENC_BIG_ENDIAN);\n\n    /* path attributes */\n    if (len > 0) {\n        ti =  proto_tree_add_item(tree, hf_bgp_update_path_attributes, tvb, o+2, len, ENC_NA);\n        subtree = proto_item_add_subtree(ti, ett_bgp_attrs);\n\n        dissect_bgp_path_attr(subtree, tvb, len-4, o+2, pinfo);\n\n        o += 2 + len;\n\n        /* NLRI */\n        len = hlen - o;\n\n        /* parse prefixes */\n        if (len > 0) {\n            ti = proto_tree_add_item(tree, hf_bgp_update_nlri, tvb, o, len, ENC_NA);\n            subtree = proto_item_add_subtree(ti, ett_bgp_nlri);\n            end = o + len;\n            /* Heuristic to detect if IPv4 prefix are using Path Identifiers */\n            if( detect_add_path_prefix4(tvb, o, end) ) {\n                /* IPv4 prefixes with Path Id */\n                while (o < end) {\n                    i = decode_path_prefix4(subtree, pinfo, hf_bgp_nlri_path_id, hf_bgp_nlri_prefix, tvb, o,\n                                            \"NLRI\");\n                    if (i < 0)\n                       return;\n                    o += i;\n                }\n            } else {\n                /* Standard prefixes */\n                while (o < end) {\n                    i = decode_prefix4(subtree, pinfo, NULL, hf_bgp_nlri_prefix, tvb, o, \"NLRI\");\n                    if (i < 0)\n                        return;\n                    o += i;\n                }\n            }\n        }\n    }\n}",
        "func": "static void\ndissect_bgp_update(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo)\n{\n    guint16         hlen;                       /* message length           */\n    gint            o;                          /* packet offset            */\n    gint            end=0;                      /* message end              */\n    guint16         len;                        /* tmp                      */\n    proto_item      *ti;                        /* tree item                */\n    proto_tree      *subtree;                   /* subtree for attributes   */\n    int             i;                          /* tmp                      */\n\n    hlen = tvb_get_ntohs(tvb, BGP_MARKER_SIZE);\n    o = BGP_HEADER_SIZE;\n\n\n    /* check for withdrawals */\n    len = tvb_get_ntohs(tvb, o);\n    proto_tree_add_item(tree, hf_bgp_update_withdrawn_routes_length, tvb, o, 2, ENC_BIG_ENDIAN);\n    o += 2;\n\n    /* parse unfeasible prefixes */\n    if (len > 0) {\n        ti = proto_tree_add_item(tree, hf_bgp_update_withdrawn_routes, tvb, o, len, ENC_NA);\n        subtree = proto_item_add_subtree(ti, ett_bgp_unfeas);\n\n        /* parse each prefix */\n        end = o + len;\n\n        /* Heuristic to detect if IPv4 prefix are using Path Identifiers */\n        if( detect_add_path_prefix4(tvb, o, end) ) {\n            /* IPv4 prefixes with Path Id */\n            while (o < end) {\n                i = decode_path_prefix4(subtree, pinfo, hf_bgp_nlri_path_id, hf_bgp_withdrawn_prefix, tvb, o,\n                    \"Withdrawn route\");\n                if (i < 0)\n                    return;\n                o += i;\n            }\n        } else {\n            while (o < end) {\n                i = decode_prefix4(subtree, pinfo, NULL, hf_bgp_withdrawn_prefix, tvb, o,\n                    \"Withdrawn route\");\n                if (i < 0)\n                    return;\n                o += i;\n            }\n        }\n    }\n\n    /* check for advertisements */\n    len = tvb_get_ntohs(tvb, o);\n    proto_tree_add_item(tree, hf_bgp_update_total_path_attribute_length, tvb, o, 2, ENC_BIG_ENDIAN);\n\n    /* path attributes */\n    if (len > 0) {\n        ti =  proto_tree_add_item(tree, hf_bgp_update_path_attributes, tvb, o+2, len, ENC_NA);\n        subtree = proto_item_add_subtree(ti, ett_bgp_attrs);\n\n        dissect_bgp_path_attr(subtree, tvb, len, o+2, pinfo);\n\n        o += 2 + len;\n\n        /* NLRI */\n        len = hlen - o;\n\n        /* parse prefixes */\n        if (len > 0) {\n            ti = proto_tree_add_item(tree, hf_bgp_update_nlri, tvb, o, len, ENC_NA);\n            subtree = proto_item_add_subtree(ti, ett_bgp_nlri);\n            end = o + len;\n            /* Heuristic to detect if IPv4 prefix are using Path Identifiers */\n            if( detect_add_path_prefix4(tvb, o, end) ) {\n                /* IPv4 prefixes with Path Id */\n                while (o < end) {\n                    i = decode_path_prefix4(subtree, pinfo, hf_bgp_nlri_path_id, hf_bgp_nlri_prefix, tvb, o,\n                                            \"NLRI\");\n                    if (i < 0)\n                       return;\n                    o += i;\n                }\n            } else {\n                /* Standard prefixes */\n                while (o < end) {\n                    i = decode_prefix4(subtree, pinfo, NULL, hf_bgp_nlri_prefix, tvb, o, \"NLRI\");\n                    if (i < 0)\n                        return;\n                    o += i;\n                }\n            }\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,7 +56,7 @@\n         ti =  proto_tree_add_item(tree, hf_bgp_update_path_attributes, tvb, o+2, len, ENC_NA);\n         subtree = proto_item_add_subtree(ti, ett_bgp_attrs);\n \n-        dissect_bgp_path_attr(subtree, tvb, len-4, o+2, pinfo);\n+        dissect_bgp_path_attr(subtree, tvb, len, o+2, pinfo);\n \n         o += 2 + len;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        dissect_bgp_path_attr(subtree, tvb, len-4, o+2, pinfo);"
            ],
            "added_lines": [
                "        dissect_bgp_path_attr(subtree, tvb, len, o+2, pinfo);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14342",
        "func_name": "wireshark/dissect_bgp_path_attr",
        "description": "In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the BGP protocol dissector could go into a large loop. This was addressed in epan/dissectors/packet-bgp.c by validating Path Attribute lengths.",
        "git_url": "https://github.com/wireshark/wireshark/commit/36af43dbb7673495948cd65d0346e8b9812b941c",
        "commit_title": "BGP: Validate length of Path Attribute records.",
        "commit_text": " Bug 13741 showed a case where the BGP dissector's failure to validate the length of the Path Attribute record allowed a pathological BGP UPDATE packet to generate more than one million items in the protocol tree by repeatedly dissecting certain segments of the packet.  It's easy enough to detect when the Path Attribute length cannot be valid, so let's do so.  When the condition arises, let's raise an Expert Info error in the same style and format as used elsewhere in the same routine, and abandon dissection of the Path Attributes list.  With this check in place, an incorrect length computation is revealed at a callsite.  This would only have prevented a small (less than 5 bytes) Path Attribute from being dissected if it was at the very end of the Path Attributes list, but the bounds checking added in this change makes this problem much more apparent, so we fix the length computation while we're here.  Testing Done: Built wireshark on Linux amd64.  Using bgp.pcap from the Sample    Captures page on the wiki, verified that the dissection of the UPDATE    packets were unaltered by this fix.  Using the capture attached to bug 13741    (clusterfuzz-testcase-minimized-6689222578667520.pcap), verified that the    packet no longer triggers the \"too many items\" exception, instead we see    an Expert Info for each oversized Path Attribute length, and eventually an    exception for \"length of contained item exceeds length of containing item\".    30,000 iterations of fuzz test with bgp.pcap as input, and many iterations    of randpkt-test too.  Crafted a packet with a 3-byte ATOMIC_AGGREGATE Path    Attribute at the end of the Path Attributes list; Before this change, an    exception is raised during dissection, but after this change it is dissected    correctly.  Bug: 13741 (cherry picked from commit 6e88943d0eabc8c8bc11334ba4213ec64129575c)",
        "func_before": "static void\ndissect_bgp_path_attr(proto_tree *subtree, tvbuff_t *tvb, guint16 path_attr_len, guint tvb_off, packet_info *pinfo)\n{\n    guint8        bgpa_flags;                 /* path attributes          */\n    guint8        bgpa_type;\n    gint          o;                          /* packet offset            */\n    gint          q=0;                        /* tmp                      */\n    gint          end=0;                      /* message end              */\n    int           advance;                    /* tmp                      */\n    proto_item    *ti;                        /* tree item                */\n    proto_item    *ti_communities;            /* tree communities         */\n    proto_item    *ti_community;              /* tree for each community  */\n    proto_item    *attr_len_item;\n    proto_item    *aigp_type_item;\n    proto_tree    *subtree2;                  /* path attribute subtree   */\n    proto_tree    *subtree3;                  /* subtree for attributes   */\n    proto_tree    *subtree4;                  /* subtree for attributes   */\n    proto_tree    *subtree5;                  /* subtree for attributes   */\n    proto_tree    *subtree6;                  /* subtree for attributes   */\n    proto_tree    *attr_set_subtree;          /* subtree for attr_set     */\n    proto_tree    *as_path_segment_tree;      /* subtree for AS_PATH segments */\n    gint          number_as_segment=0;        /* Number As segment        */\n    proto_tree    *communities_tree;          /* subtree for COMMUNITIES  */\n    proto_tree    *community_tree;            /* subtree for a community  */\n    proto_tree    *cluster_list_tree;         /* subtree for CLUSTER_LIST */\n    int           i=0, j, k;                  /* tmp                      */\n    guint8        type=0;                     /* AS_PATH segment type     */\n    guint8        length=0;                   /* AS_PATH segment length   */\n    wmem_strbuf_t *junk_emstr;                /* tmp                      */\n    guint32       aggregator_as;\n    guint16       ssa_type;                   /* SSA T + Type */\n    guint16       ssa_len;                    /* SSA TLV Length */\n    guint8        ssa_v3_len;                 /* SSA L2TPv3 Cookie Length */\n    guint16       encaps_tunnel_type;         /* Encapsulation Tunnel Type */\n    guint16       encaps_tunnel_len;          /* Encapsulation TLV Length */\n    guint8        encaps_tunnel_subtype;      /* Encapsulation Tunnel Sub-TLV Type */\n    guint8        encaps_tunnel_sublen;       /* Encapsulation TLV Sub-TLV Length */\n    guint8        aigp_type;                  /* AIGP TLV type from AIGP attribute */\n\n    o = tvb_off;\n    junk_emstr = wmem_strbuf_new_label(wmem_packet_scope());\n\n    while (i < path_attr_len) {\n        proto_item *ti_pa, *ti_flags;\n        int     off;\n        gint    alen, aoff, tlen, aoff_save;\n        guint16 af;\n        guint8  saf, snpa;\n        guint8  nexthop_len;\n        guint8  asn_len = 0;\n\n        static const int * path_flags[] = {\n            &hf_bgp_update_path_attribute_flags_optional,\n            &hf_bgp_update_path_attribute_flags_transitive,\n            &hf_bgp_update_path_attribute_flags_partial,\n            &hf_bgp_update_path_attribute_flags_extended_length,\n            NULL\n        };\n\n        bgpa_flags = tvb_get_guint8(tvb, o + i);\n        bgpa_type = tvb_get_guint8(tvb, o + i+1);\n\n        /* check for the Extended Length bit */\n        if (bgpa_flags & BGP_ATTR_FLAG_EXTENDED_LENGTH) {\n            alen = tvb_get_ntohs(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);\n            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+2;\n        } else {\n            alen = tvb_get_guint8(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);\n            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+1;\n        }\n        tlen = alen;\n\n        ti_pa = proto_tree_add_item(subtree, hf_bgp_update_path_attribute, tvb, o + i, tlen + aoff, ENC_NA);\n        proto_item_append_text(ti_pa, \" - %s\", val_to_str(bgpa_type, bgpattr_type, \"Unknown (%u)\"));\n\n        subtree2 = proto_item_add_subtree(ti_pa, ett_bgp_attr);\n\n        ti_flags = proto_tree_add_bitmask(subtree2, tvb, o + i, hf_bgp_update_path_attribute_flags, ett_bgp_attr_flags, path_flags, ENC_NA);\n\n        proto_item_append_text(ti_flags,\"%s%s%s%s\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_OPTIONAL) == 0) ? \": Well-known\" : \": Optional\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_TRANSITIVE) == 0) ? \", Non-transitive\" : \", Transitive\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_PARTIAL) == 0) ? \", Complete\" : \", Partial\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_EXTENDED_LENGTH) == 0) ? \"\" : \", Extended Length\");\n\n        proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_type_code, tvb, o + i + 1, 1, ENC_BIG_ENDIAN);\n\n        attr_len_item = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_length, tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE,\n                                            aoff - BGP_SIZE_OF_PATH_ATTRIBUTE, ENC_BIG_ENDIAN);\n\n        /* Path Attribute Type */\n        switch (bgpa_type) {\n            case BGPTYPE_ORIGIN:\n                if (tlen != 1) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Origin (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_origin, tvb,\n                                        o + i + aoff, 1, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s\", val_to_str_const(tvb_get_guint8(tvb, o + i + aoff), bgpattr_origin, \"Unknown\"));\n                }\n                break;\n            case BGPTYPE_AS_PATH:\n            case BGPTYPE_AS4_PATH:\n                /* Apply heuristic to guess if we are facing 2 or 4 bytes ASN\n                   (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple)\n                   heuristic also tell us how many AS segments we have */\n                asn_len = heuristic_as2_or_4_from_as_path(tvb, o+i+aoff, o+i+aoff+tlen,\n                                                          bgpa_type, &number_as_segment);\n                if (asn_len == 255)\n                    {\n                        expert_add_info_format(pinfo, ti_pa, &ei_bgp_attr_as_path_as_len_err,\n                                               \"ASN length uncalculated by heuristic : %u\", asn_len);\n                        break;\n                    }\n                proto_item_append_text(ti_pa,\": \");\n                if(tlen == 0) {\n                    proto_item_append_text(ti_pa,\"empty\");\n                }\n                q = o + i + aoff;\n                for (k=0; k < number_as_segment; k++)\n                {\n                    type = tvb_get_guint8(tvb, q);\n                    length = tvb_get_guint8(tvb, q+1);\n                    ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_as_path_segment, tvb,\n                                             q, length * asn_len + 2, ENC_NA);\n                    proto_item_append_text(ti,\": \");\n                    as_path_segment_tree = proto_item_add_subtree(ti, ett_bgp_as_path_segment);\n                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_type, tvb,\n                                        q, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_length, tvb,\n                                        q+1, 1, ENC_BIG_ENDIAN);\n                    switch(type)\n                    {\n                        case AS_SET:\n                            proto_item_append_text(ti_pa, \"{\");\n                            proto_item_append_text(ti, \"{\");\n                            break;\n                        case AS_CONFED_SET:\n                            proto_item_append_text(ti_pa, \"[\");\n                            proto_item_append_text(ti, \"[\");\n                            break;\n                        case AS_CONFED_SEQUENCE:\n                            proto_item_append_text(ti_pa, \"(\");\n                            proto_item_append_text(ti, \"(\");\n                            break;\n                    }\n\n                    q = q + 2;\n                    for (j = 0; j < length; j++)\n                    {\n                        if(asn_len == 2) {\n                            proto_tree_add_item(as_path_segment_tree,\n                                                hf_bgp_update_path_attribute_as_path_segment_as2,\n                                                tvb, q, 2, ENC_BIG_ENDIAN);\n                            proto_item_append_text(ti_pa, \"%u\",\n                                                   tvb_get_ntohs(tvb, q));\n                            proto_item_append_text(ti, \"%u\",\n                                                   tvb_get_ntohs(tvb, q));\n                        }\n                        else if (asn_len == 4) {\n                            proto_tree_add_item(as_path_segment_tree,\n                                                hf_bgp_update_path_attribute_as_path_segment_as4,\n                                                tvb, q, 4, ENC_BIG_ENDIAN);\n                            proto_item_append_text(ti_pa, \"%u\",\n                                                   tvb_get_ntohl(tvb, q));\n                            proto_item_append_text(ti, \"%u\",\n                                                   tvb_get_ntohl(tvb, q));\n                        }\n                        if (j != length-1)\n                        {\n                            proto_item_append_text(ti_pa, \"%s\",\n                                                   (type == AS_SET || type == AS_CONFED_SET) ?\n                                                   \", \" : \" \");\n                            proto_item_append_text(ti, \"%s\",\n                                                   (type == AS_SET || type == AS_CONFED_SET) ?\n                                                   \", \" : \" \");\n                        }\n                        q += asn_len;\n                    }\n                    switch(type)\n                    {\n                        case AS_SET:\n                            proto_item_append_text(ti_pa, \"} \");\n                            proto_item_append_text(ti, \"}\");\n                            break;\n                        case AS_CONFED_SET:\n                            proto_item_append_text(ti_pa, \"] \");\n                            proto_item_append_text(ti, \"]\");\n                            break;\n                        case AS_CONFED_SEQUENCE:\n                            proto_item_append_text(ti_pa, \") \");\n                            proto_item_append_text(ti, \")\");\n                            break;\n                        default:\n                            proto_item_append_text(ti_pa, \" \");\n                            break;\n                    }\n                }\n\n                break;\n            case BGPTYPE_NEXT_HOP:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Next hop (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_next_hop, tvb,\n                                        o + i + aoff, 4, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s \", tvb_ip_to_str(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_MULTI_EXIT_DISC:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Multiple exit discriminator (invalid): %u byte%s\",\n                                                 tlen, plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_multi_exit_disc, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa,\": %u\", tvb_get_ntohl(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_LOCAL_PREF:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Local preference (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_local_pref, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %u\", tvb_get_ntohl(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_ATOMIC_AGGREGATE:\n                if (tlen != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Atomic aggregate (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                }\n                break;\n            case BGPTYPE_AGGREGATOR:\n                if (tlen != 6 && tlen != 8) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Aggregator (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n                /* FALL THROUGH */\n            case BGPTYPE_AS4_AGGREGATOR:\n                if (bgpa_type == BGPTYPE_AS4_AGGREGATOR && tlen != 8)\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Aggregator (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                else {\n                    asn_len = tlen - 4;\n                    aggregator_as = (asn_len == 2) ?\n                        tvb_get_ntohs(tvb, o + i + aoff) :\n                        tvb_get_ntohl(tvb, o + i + aoff);\n                    proto_tree_add_uint(subtree2, hf_bgp_update_path_attribute_aggregator_as, tvb,\n                                        o + i + aoff, asn_len, aggregator_as);\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aggregator_origin, tvb,\n                                        o + i + aoff + asn_len, 4, ENC_BIG_ENDIAN);\n\n                    proto_item_append_text(ti_pa, \": AS: %u origin: %s\", aggregator_as,\n                                           tvb_ip_to_str(tvb, o + i + aoff + asn_len));\n                }\n                break;\n            case BGPTYPE_COMMUNITIES:\n                if (tlen % 4 != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Communities (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n\n                proto_item_append_text(ti_pa, \": \");\n\n                ti_communities = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_communities,\n                                                     tvb, o + i + aoff, tlen, ENC_NA);\n\n                communities_tree = proto_item_add_subtree(ti_communities,\n                                                          ett_bgp_communities);\n                proto_item_append_text(ti_communities, \": \");\n                /* (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple) */\n                q = o + i + aoff;\n                end = q + tlen;\n\n                /* snarf each community */\n                while (q < end) {\n                    /* check for reserved values */\n                    guint32 community = tvb_get_ntohl(tvb, q);\n                    if ((community & 0xFFFF0000) == FOURHEX0 ||\n                        (community & 0xFFFF0000) == FOURHEXF) {\n                        proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community_well_known,\n                                            tvb, q, 4, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti_pa, \"%s \", val_to_str_const(community, community_vals, \"Reserved\"));\n                        proto_item_append_text(ti_communities, \"%s \", val_to_str_const(community, community_vals, \"Reserved\"));\n                    }\n                    else {\n                        ti_community = proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community, tvb,\n                                                           q, 4, ENC_NA);\n                        community_tree = proto_item_add_subtree(ti_community,\n                                                                ett_bgp_community);\n                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_as,\n                                            tvb, q, 2, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_value,\n                                            tvb, q+2, 2, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti_pa, \"%u:%u \",tvb_get_ntohs(tvb, q),\n                                               tvb_get_ntohs(tvb, q+2));\n                        proto_item_append_text(ti_communities, \"%u:%u \",tvb_get_ntohs(tvb, q),\n                                               tvb_get_ntohs(tvb, q+2));\n                        proto_item_append_text(ti_community, \": %u:%u \",tvb_get_ntohs(tvb, q),\n                                               tvb_get_ntohs(tvb, q+2));\n                    }\n\n                    q += 4;\n                }\n\n\n                break;\n            case BGPTYPE_ORIGINATOR_ID:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Originator identifier (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_originator_id, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s \", tvb_ip_to_str(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_MP_REACH_NLRI:\n                /*\n                 * RFC 2545 specifies that there may be more than one\n                 * address in the MP_REACH_NLRI attribute in section\n                 * 3, \"Constructing the Next Hop field\".\n                 *\n                 * Yes, RFC 2858 says you can't do that, and, yes, RFC\n                 * 2858 obsoletes RFC 2283, which says you can do that,\n                 * but that doesn't mean we shouldn't dissect packets\n                 * that conform to RFC 2283 but not RFC 2858, as some\n                 * device on the network might implement the 2283-style\n                 * BGP extensions rather than RFC 2858-style extensions.\n                 */\n                af = tvb_get_ntohs(tvb, o + i + aoff);\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_address_family, tvb,\n                                    o + i + aoff, 2, ENC_BIG_ENDIAN);\n                saf = tvb_get_guint8(tvb, o + i + aoff + 2) ;\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_safi, tvb,\n                                    o + i + aoff+2, 1, ENC_BIG_ENDIAN);\n                nexthop_len = tvb_get_guint8(tvb, o + i + aoff + 3);\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff + 3,\n                                                         nexthop_len + 1, ett_bgp_mp_nhna, NULL,\n                                                         \"Next hop network address (%d byte%s)\",\n                                                         nexthop_len, plurality(nexthop_len, \"\", \"s\"));\n\n                /*\n                 * The addresses don't contain lengths, so if we\n                 * don't understand the address family type, we\n                 * cannot parse the subsequent addresses as we\n                 * don't know how long they are.\n                 */\n                switch (af) {\n                    default:\n                    proto_tree_add_expert(subtree3, pinfo, &ei_bgp_unknown_afi, tvb, o + i + aoff + 4, nexthop_len);\n                    break;\n\n                    case AFNUM_INET:\n                    case AFNUM_INET6:\n                    case AFNUM_L2VPN:\n                    case AFNUM_L2VPN_OLD:\n                    case AFNUM_LINK_STATE:\n\n                        j = 0;\n                        while (j < nexthop_len) {\n                            advance = mp_addr_to_str(af, saf, tvb, o + i + aoff + 4 + j,\n                                                     junk_emstr, nexthop_len) ;\n                            if (advance == 0) /* catch if this is a unknown AFI type*/\n                                break;\n                            if (j + advance > nexthop_len)\n                                break;\n                            proto_tree_add_string(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_next_hop, tvb,\n                                                 o + i + aoff + 4 + j, advance, wmem_strbuf_get_str(junk_emstr));\n\n                            j += advance;\n                        }\n                        break;\n                } /* switch (af) */\n\n                aoff_save = aoff;\n                tlen -= nexthop_len + 4;\n                aoff += nexthop_len + 4 ;\n\n                off = 0;\n                snpa = tvb_get_guint8(tvb, o + i + aoff);\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_nbr_snpa, tvb,\n                                         o + i + aoff, 1, ENC_BIG_ENDIAN);\n                off++;\n                if (snpa) {\n                    subtree3 = proto_item_add_subtree(ti, ett_bgp_mp_snpa);\n                    for (/*nothing*/; snpa > 0; snpa--) {\n                        guint8 snpa_length = tvb_get_guint8(tvb, o + i + aoff + off);\n                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa_length, tvb,\n                                            o + i + aoff + off, 1, ENC_BIG_ENDIAN);\n                        off++;\n                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa, tvb,\n                                            o + i + aoff + off, snpa_length, ENC_NA);\n                        off += snpa_length;\n                    }\n                }\n                tlen -= off;\n                aoff += off;\n\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff, tlen,\n                                                         ett_bgp_mp_reach_nlri, NULL, \"Network layer reachability information (%u byte%s)\",\n                                                         tlen, plurality(tlen, \"\", \"s\"));\n                if (tlen)  {\n                    if (af != AFNUM_INET && af != AFNUM_INET6 && af != AFNUM_L2VPN && af != AFNUM_LINK_STATE) {\n                        proto_tree_add_expert(subtree3, pinfo, &ei_bgp_unknown_afi, tvb, o + i + aoff, tlen);\n                    } else {\n                        while (tlen > 0) {\n                            advance = decode_prefix_MP(subtree3,\n                                                       hf_bgp_mp_reach_nlri_ipv4_prefix,\n                                                       hf_bgp_mp_reach_nlri_ipv6_prefix,\n                                                       af, saf,\n                                                       tvb, o + i + aoff, \"MP Reach NLRI\", pinfo);\n                            if (advance < 0)\n                                break;\n                            tlen -= advance;\n                            aoff += advance;\n                        }\n                    }\n                }\n                aoff = aoff_save;\n                break;\n            case BGPTYPE_MP_UNREACH_NLRI:\n                af = tvb_get_ntohs(tvb, o + i + aoff);\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_address_family, tvb,\n                                    o + i + aoff, 2, ENC_BIG_ENDIAN);\n                saf = tvb_get_guint8(tvb, o + i + aoff + 2) ;\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_safi, tvb,\n                                    o + i + aoff+2, 1, ENC_BIG_ENDIAN);\n\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff + 3,\n                                                         tlen - 3, ett_bgp_mp_unreach_nlri, NULL, \"Withdrawn routes (%u byte%s)\", tlen - 3,\n                                                         plurality(tlen - 3, \"\", \"s\"));\n\n                aoff_save = aoff;\n                tlen -= 3;\n                aoff += 3;\n                if (tlen > 0) {\n\n                    while (tlen > 0) {\n                        advance = decode_prefix_MP(subtree3,\n                                                   hf_bgp_mp_unreach_nlri_ipv4_prefix,\n                                                   hf_bgp_mp_unreach_nlri_ipv6_prefix,\n                                                   af, saf,\n                                                   tvb, o + i + aoff, \"MP Unreach NLRI\", pinfo);\n                        if (advance < 0)\n                            break;\n                        tlen -= advance;\n                        aoff += advance;\n                    }\n                }\n                aoff = aoff_save;\n                break;\n            case BGPTYPE_CLUSTER_LIST:\n                if (tlen % 4 != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Cluster list (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_cluster_list,\n                                         tvb, o + i + aoff, tlen, ENC_NA);\n                cluster_list_tree = proto_item_add_subtree(ti,\n                                                               ett_bgp_cluster_list);\n\n                /* (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple) */\n                q = o + i + aoff;\n                end = q + tlen;\n                proto_item_append_text(ti, \":\");\n                proto_item_append_text(ti_pa, \":\");\n                /* snarf each cluster identifier */\n                while (q < end) {\n                    proto_tree_add_item(cluster_list_tree, hf_bgp_update_path_attribute_cluster_id,\n                                        tvb, q - 3 + aoff, 4, ENC_NA);\n                    proto_item_append_text(ti, \" %s\", tvb_ip_to_str(tvb, q-3+aoff));\n                    proto_item_append_text(ti_pa, \" %s\", tvb_ip_to_str(tvb, q-3+aoff));\n                    q += 4;\n                }\n\n                break;\n            case BGPTYPE_EXTENDED_COMMUNITY:\n                if (tlen %8 != 0) {\n                    expert_add_info_format(pinfo, attr_len_item, &ei_bgp_ext_com_len_bad,\n                                           \"Community length %u wrong, must be modulo 8\", tlen);\n                } else {\n                    dissect_bgp_update_ext_com(subtree2, tvb, tlen, o+i+aoff);\n                }\n                break;\n            case BGPTYPE_SAFI_SPECIFIC_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen ;\n\n                while(q < end) {\n                    ssa_type = tvb_get_ntohs(tvb, q) & BGP_SSA_TYPE;\n                    ssa_len = tvb_get_ntohs(tvb, q + 2);\n\n                    subtree3 = proto_tree_add_subtree_format(subtree2, tvb, q, MIN(ssa_len + 4, end - q),\n                                                             ett_bgp_ssa, NULL, \"%s Information\",\n                                                             val_to_str_const(ssa_type, bgp_ssa_type, \"Unknown SSA\"));\n\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_t, tvb,\n                                        q, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_type, tvb, q, 2, ENC_BIG_ENDIAN);\n\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n\n                    if ((ssa_len == 0) || (q + ssa_len > end)) {\n                        proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 2,\n                                                     end - q - 2, \"Invalid Length of %u\", ssa_len);\n                        break;\n                    }\n\n                    switch (ssa_type) {\n                        case BGP_SSA_L2TPv3:\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_pref, tvb,\n                                                q + 4, 2, ENC_BIG_ENDIAN);\n\n                            subtree4 = proto_tree_add_subtree(subtree3, tvb, q + 6, 1, ett_bgp_ssa_subtree, NULL, \"Flags\");\n                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_s, tvb,\n                                                q + 6, 1, ENC_BIG_ENDIAN);\n                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_unused, tvb,\n                                                q + 6, 1, ENC_BIG_ENDIAN);\n\n                            ssa_v3_len = tvb_get_guint8(tvb, q + 7);\n                            if (ssa_v3_len + 8 == ssa_len){\n                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie_len, tvb,\n                                                    q + 7, 1, ENC_BIG_ENDIAN);\n                            } else {\n                                proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 7, 1,\n                                                             \"Invalid Cookie Length of %u\", ssa_v3_len);\n                                q += ssa_len + 4; /* 4 from type and length */\n                                break;\n                            }\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_session_id, tvb,\n                                                q + 8, 4, ENC_BIG_ENDIAN);\n                            if (ssa_v3_len)\n                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie, tvb,\n                                                    q + 12, ssa_v3_len, ENC_NA);\n                            q += ssa_len + 4; /* 4 from type and length */\n                            break;\n                        case BGP_SSA_mGRE:\n                        case BGP_SSA_IPSec:\n                        case BGP_SSA_MPLS:\n                        default:\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_value, tvb,\n                                                q + 4, ssa_len, ENC_NA);\n                            q += ssa_len + 4; /* 4 from type and length */\n                            break;\n                        case BGP_SSA_L2TPv3_IN_IPSec:\n                        case BGP_SSA_mGRE_IN_IPSec:\n                            /* These contain BGP_SSA_IPSec and BGP_SSA_L2TPv3/BGP_SSA_mGRE */\n                            q += 4; /* 4 from type and length */\n                            break;\n                    } /* switch (bgpa.bgpa_type) */\n                }\n                break;\n            case BGPTYPE_TUNNEL_ENCAPS_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen;\n\n                subtree3 = proto_tree_add_subtree(subtree2, tvb, q, tlen, ett_bgp_tunnel_tlv, NULL, \"TLV Encodings\");\n\n                while (q < end) {\n                    encaps_tunnel_type = tvb_get_ntohs(tvb, q);\n                    encaps_tunnel_len = tvb_get_ntohs(tvb, q + 2);\n\n                    subtree4 = proto_tree_add_subtree_format(subtree3, tvb, q, encaps_tunnel_len + 4,\n                                         ett_bgp_tunnel_tlv_subtree, NULL, \"%s (%u bytes)\",\n                                         val_to_str_const(encaps_tunnel_type, bgp_attr_tunnel_type, \"Unknown\"), encaps_tunnel_len + 4);\n\n                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_type, tvb, q, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n\n                    subtree5 = proto_tree_add_subtree(subtree4, tvb, q + 4, encaps_tunnel_len, ett_bgp_tunnel_subtlv, NULL, \"Sub-TLV Encodings\");\n\n                    q += 4;\n                    j = q + encaps_tunnel_len;\n                    while ( q < j ) {\n                        encaps_tunnel_subtype = tvb_get_guint8(tvb, q);\n                        encaps_tunnel_sublen = tvb_get_guint8(tvb, q + 1);\n\n                        subtree6 = proto_tree_add_subtree_format(subtree5, tvb, q, encaps_tunnel_sublen + 2, ett_bgp_tunnel_tlv_subtree, NULL, \"%s (%u bytes)\", val_to_str_const(encaps_tunnel_subtype, subtlv_type, \"Unknown\"), encaps_tunnel_sublen + 2);\n\n                        proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_type, tvb, q, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_len, tvb, q + 1, 1, ENC_BIG_ENDIAN);\n\n                        switch (encaps_tunnel_subtype) {\n                            case TUNNEL_SUBTLV_ENCAPSULATION:\n                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_session_id, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_cookie, tvb, q + 6, encaps_tunnel_sublen - 4, ENC_NA);\n                                } else if (encaps_tunnel_type == TUNNEL_TYPE_GRE) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                }\n                                break;\n                            case TUNNEL_SUBTLV_PROTO_TYPE:\n                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n                                break;\n                            case TUNNEL_SUBTLV_COLOR:\n                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_color_value, tvb, q + 6, 4, ENC_BIG_ENDIAN);\n                               break;\n                            case TUNNEL_SUBTLV_LOAD_BALANCE:\n                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP || encaps_tunnel_type == TUNNEL_TYPE_GRE) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_lb_block_length, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                }\n                                break;\n                            default:\n                                break;\n                        } /* switch (encaps_tunnel_subtype) */\n\n                        q += 2 + encaps_tunnel_sublen; /* type and length + length of value */\n                    }\n\n                }\n\n                break;\n            case BGPTYPE_AIGP:\n                q = o + i + aoff;\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aigp, tvb, q, tlen, ENC_NA);\n                subtree3 = proto_item_add_subtree(ti, ett_bgp_aigp_attr);\n                aigp_type_item =  proto_tree_add_item(subtree3, hf_bgp_aigp_type, tvb, q, 1, ENC_BIG_ENDIAN);\n                aigp_type = tvb_get_guint8(tvb,q);\n                switch (aigp_type) {\n                    case AIGP_TLV_TYPE :\n                        proto_tree_add_item(subtree3, hf_bgp_aigp_tlv_length, tvb, q+1, 2, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(subtree3, hf_bgp_aigp_accu_igp_metric, tvb, q+3, 8, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti, \": %\" G_GINT64_MODIFIER \"u\", tvb_get_ntoh64(tvb, q+3));\n                        proto_item_append_text(ti_pa, \": %\" G_GINT64_MODIFIER \"u\", tvb_get_ntoh64(tvb, q+3));\n                        break;\n                    default :\n                        expert_add_info_format(pinfo, aigp_type_item, &ei_bgp_attr_aigp_type,\n                                               \"AIGP type %u unknown\", aigp_type);\n                }\n                break;\n            case BGPTYPE_LINK_STATE_ATTR:\n            case BGPTYPE_LINK_STATE_OLD_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen;\n                /* FF: BGPTYPE_LINK_STATE_ATTR body dissection is moved after the while.\n                   Here we just save the TLV coordinates and the subtree. */\n                save_link_state_attr_position(pinfo, q, end, tlen, subtree2);\n                break;\n\n            case BGPTYPE_PMSI_TUNNEL_ATTR:\n                dissect_bgp_update_pmsi_attr(pinfo, subtree2, tvb, tlen, o+i+aoff);\n                break;\n\n            case BGPTYPE_ATTR_SET:\n                if (alen >= 4) {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_attrset_origin_as, tvb,\n                                        o + i + aoff, 4, ENC_BIG_ENDIAN);\n                    if (alen > 4) {\n                        ti =  proto_tree_add_item(subtree2, hf_bgp_update_path_attributes, tvb, o+i+aoff+4, alen-4, ENC_NA);\n                        attr_set_subtree = proto_item_add_subtree(ti, ett_bgp_attrs);\n                        dissect_bgp_path_attr(attr_set_subtree, tvb, alen-4, o+i+aoff+4, pinfo);\n                    }\n                } else {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, alen,\n                                                 \"Attribute set (invalid): %u bytes%s\",\n                                                 alen, plurality(alen, \"\", \"s\"));\n                }\n                break;\n            default:\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attributes_unknown, tvb, o + i + aoff, tlen, ENC_NA);\n                break;\n        } /* switch (bgpa.bgpa_type) */ /* end of second switch */\n\n        i += alen + aoff;\n    }\n    {\n        /* FF: postponed BGPTYPE_LINK_STATE_ATTR dissection */\n        link_state_data *data = load_link_state_data(pinfo);\n        if (data && data->link_state_attr_present) {\n            ti = proto_tree_add_item(data->subtree2, hf_bgp_update_path_attribute_link_state, tvb, data->ostart, data->tlen, ENC_NA);\n            subtree3 = proto_item_add_subtree(ti, ett_bgp_link_state);\n            while (data->ostart < data->oend) {\n                advance = decode_link_state_attribute_tlv(subtree3, tvb, data->ostart, pinfo, data->protocol_id);\n                if (advance < 0) {\n                    break;\n                }\n                data->ostart += advance;\n            }\n        }\n    }\n}",
        "func": "static void\ndissect_bgp_path_attr(proto_tree *subtree, tvbuff_t *tvb, guint16 path_attr_len, guint tvb_off, packet_info *pinfo)\n{\n    guint8        bgpa_flags;                 /* path attributes          */\n    guint8        bgpa_type;\n    gint          o;                          /* packet offset            */\n    gint          q=0;                        /* tmp                      */\n    gint          end=0;                      /* message end              */\n    int           advance;                    /* tmp                      */\n    proto_item    *ti;                        /* tree item                */\n    proto_item    *ti_communities;            /* tree communities         */\n    proto_item    *ti_community;              /* tree for each community  */\n    proto_item    *attr_len_item;\n    proto_item    *aigp_type_item;\n    proto_tree    *subtree2;                  /* path attribute subtree   */\n    proto_tree    *subtree3;                  /* subtree for attributes   */\n    proto_tree    *subtree4;                  /* subtree for attributes   */\n    proto_tree    *subtree5;                  /* subtree for attributes   */\n    proto_tree    *subtree6;                  /* subtree for attributes   */\n    proto_tree    *attr_set_subtree;          /* subtree for attr_set     */\n    proto_tree    *as_path_segment_tree;      /* subtree for AS_PATH segments */\n    gint          number_as_segment=0;        /* Number As segment        */\n    proto_tree    *communities_tree;          /* subtree for COMMUNITIES  */\n    proto_tree    *community_tree;            /* subtree for a community  */\n    proto_tree    *cluster_list_tree;         /* subtree for CLUSTER_LIST */\n    int           i=0, j, k;                  /* tmp                      */\n    guint8        type=0;                     /* AS_PATH segment type     */\n    guint8        length=0;                   /* AS_PATH segment length   */\n    wmem_strbuf_t *junk_emstr;                /* tmp                      */\n    guint32       aggregator_as;\n    guint16       ssa_type;                   /* SSA T + Type */\n    guint16       ssa_len;                    /* SSA TLV Length */\n    guint8        ssa_v3_len;                 /* SSA L2TPv3 Cookie Length */\n    guint16       encaps_tunnel_type;         /* Encapsulation Tunnel Type */\n    guint16       encaps_tunnel_len;          /* Encapsulation TLV Length */\n    guint8        encaps_tunnel_subtype;      /* Encapsulation Tunnel Sub-TLV Type */\n    guint8        encaps_tunnel_sublen;       /* Encapsulation TLV Sub-TLV Length */\n    guint8        aigp_type;                  /* AIGP TLV type from AIGP attribute */\n\n    o = tvb_off;\n    junk_emstr = wmem_strbuf_new_label(wmem_packet_scope());\n\n    while (i < path_attr_len) {\n        proto_item *ti_pa, *ti_flags;\n        int     off;\n        gint    alen, aoff, tlen, aoff_save;\n        guint16 af;\n        guint8  saf, snpa;\n        guint8  nexthop_len;\n        guint8  asn_len = 0;\n\n        static const int * path_flags[] = {\n            &hf_bgp_update_path_attribute_flags_optional,\n            &hf_bgp_update_path_attribute_flags_transitive,\n            &hf_bgp_update_path_attribute_flags_partial,\n            &hf_bgp_update_path_attribute_flags_extended_length,\n            NULL\n        };\n\n        bgpa_flags = tvb_get_guint8(tvb, o + i);\n        bgpa_type = tvb_get_guint8(tvb, o + i+1);\n\n        /* check for the Extended Length bit */\n        if (bgpa_flags & BGP_ATTR_FLAG_EXTENDED_LENGTH) {\n            alen = tvb_get_ntohs(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);\n            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+2;\n        } else {\n            alen = tvb_get_guint8(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);\n            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+1;\n        }\n        tlen = alen;\n\n        ti_pa = proto_tree_add_item(subtree, hf_bgp_update_path_attribute, tvb, o + i, tlen + aoff, ENC_NA);\n        proto_item_append_text(ti_pa, \" - %s\", val_to_str(bgpa_type, bgpattr_type, \"Unknown (%u)\"));\n\n        subtree2 = proto_item_add_subtree(ti_pa, ett_bgp_attr);\n\n        ti_flags = proto_tree_add_bitmask(subtree2, tvb, o + i, hf_bgp_update_path_attribute_flags, ett_bgp_attr_flags, path_flags, ENC_NA);\n\n        proto_item_append_text(ti_flags,\"%s%s%s%s\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_OPTIONAL) == 0) ? \": Well-known\" : \": Optional\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_TRANSITIVE) == 0) ? \", Non-transitive\" : \", Transitive\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_PARTIAL) == 0) ? \", Complete\" : \", Partial\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_EXTENDED_LENGTH) == 0) ? \"\" : \", Extended Length\");\n\n        proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_type_code, tvb, o + i + 1, 1, ENC_BIG_ENDIAN);\n\n        attr_len_item = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_length, tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE,\n                                            aoff - BGP_SIZE_OF_PATH_ATTRIBUTE, ENC_BIG_ENDIAN);\n        if (aoff + tlen > path_attr_len - i) {\n            proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                         \"Path attribute length is invalid: %u byte%s\", tlen,\n                                         plurality(tlen, \"\", \"s\"));\n            return;\n        }\n\n        /* Path Attribute Type */\n        switch (bgpa_type) {\n            case BGPTYPE_ORIGIN:\n                if (tlen != 1) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Origin (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_origin, tvb,\n                                        o + i + aoff, 1, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s\", val_to_str_const(tvb_get_guint8(tvb, o + i + aoff), bgpattr_origin, \"Unknown\"));\n                }\n                break;\n            case BGPTYPE_AS_PATH:\n            case BGPTYPE_AS4_PATH:\n                /* Apply heuristic to guess if we are facing 2 or 4 bytes ASN\n                   (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple)\n                   heuristic also tell us how many AS segments we have */\n                asn_len = heuristic_as2_or_4_from_as_path(tvb, o+i+aoff, o+i+aoff+tlen,\n                                                          bgpa_type, &number_as_segment);\n                if (asn_len == 255)\n                    {\n                        expert_add_info_format(pinfo, ti_pa, &ei_bgp_attr_as_path_as_len_err,\n                                               \"ASN length uncalculated by heuristic : %u\", asn_len);\n                        break;\n                    }\n                proto_item_append_text(ti_pa,\": \");\n                if(tlen == 0) {\n                    proto_item_append_text(ti_pa,\"empty\");\n                }\n                q = o + i + aoff;\n                for (k=0; k < number_as_segment; k++)\n                {\n                    type = tvb_get_guint8(tvb, q);\n                    length = tvb_get_guint8(tvb, q+1);\n                    ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_as_path_segment, tvb,\n                                             q, length * asn_len + 2, ENC_NA);\n                    proto_item_append_text(ti,\": \");\n                    as_path_segment_tree = proto_item_add_subtree(ti, ett_bgp_as_path_segment);\n                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_type, tvb,\n                                        q, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_length, tvb,\n                                        q+1, 1, ENC_BIG_ENDIAN);\n                    switch(type)\n                    {\n                        case AS_SET:\n                            proto_item_append_text(ti_pa, \"{\");\n                            proto_item_append_text(ti, \"{\");\n                            break;\n                        case AS_CONFED_SET:\n                            proto_item_append_text(ti_pa, \"[\");\n                            proto_item_append_text(ti, \"[\");\n                            break;\n                        case AS_CONFED_SEQUENCE:\n                            proto_item_append_text(ti_pa, \"(\");\n                            proto_item_append_text(ti, \"(\");\n                            break;\n                    }\n\n                    q = q + 2;\n                    for (j = 0; j < length; j++)\n                    {\n                        if(asn_len == 2) {\n                            proto_tree_add_item(as_path_segment_tree,\n                                                hf_bgp_update_path_attribute_as_path_segment_as2,\n                                                tvb, q, 2, ENC_BIG_ENDIAN);\n                            proto_item_append_text(ti_pa, \"%u\",\n                                                   tvb_get_ntohs(tvb, q));\n                            proto_item_append_text(ti, \"%u\",\n                                                   tvb_get_ntohs(tvb, q));\n                        }\n                        else if (asn_len == 4) {\n                            proto_tree_add_item(as_path_segment_tree,\n                                                hf_bgp_update_path_attribute_as_path_segment_as4,\n                                                tvb, q, 4, ENC_BIG_ENDIAN);\n                            proto_item_append_text(ti_pa, \"%u\",\n                                                   tvb_get_ntohl(tvb, q));\n                            proto_item_append_text(ti, \"%u\",\n                                                   tvb_get_ntohl(tvb, q));\n                        }\n                        if (j != length-1)\n                        {\n                            proto_item_append_text(ti_pa, \"%s\",\n                                                   (type == AS_SET || type == AS_CONFED_SET) ?\n                                                   \", \" : \" \");\n                            proto_item_append_text(ti, \"%s\",\n                                                   (type == AS_SET || type == AS_CONFED_SET) ?\n                                                   \", \" : \" \");\n                        }\n                        q += asn_len;\n                    }\n                    switch(type)\n                    {\n                        case AS_SET:\n                            proto_item_append_text(ti_pa, \"} \");\n                            proto_item_append_text(ti, \"}\");\n                            break;\n                        case AS_CONFED_SET:\n                            proto_item_append_text(ti_pa, \"] \");\n                            proto_item_append_text(ti, \"]\");\n                            break;\n                        case AS_CONFED_SEQUENCE:\n                            proto_item_append_text(ti_pa, \") \");\n                            proto_item_append_text(ti, \")\");\n                            break;\n                        default:\n                            proto_item_append_text(ti_pa, \" \");\n                            break;\n                    }\n                }\n\n                break;\n            case BGPTYPE_NEXT_HOP:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Next hop (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_next_hop, tvb,\n                                        o + i + aoff, 4, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s \", tvb_ip_to_str(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_MULTI_EXIT_DISC:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Multiple exit discriminator (invalid): %u byte%s\",\n                                                 tlen, plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_multi_exit_disc, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa,\": %u\", tvb_get_ntohl(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_LOCAL_PREF:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Local preference (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_local_pref, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %u\", tvb_get_ntohl(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_ATOMIC_AGGREGATE:\n                if (tlen != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Atomic aggregate (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                }\n                break;\n            case BGPTYPE_AGGREGATOR:\n                if (tlen != 6 && tlen != 8) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Aggregator (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n                /* FALL THROUGH */\n            case BGPTYPE_AS4_AGGREGATOR:\n                if (bgpa_type == BGPTYPE_AS4_AGGREGATOR && tlen != 8)\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Aggregator (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                else {\n                    asn_len = tlen - 4;\n                    aggregator_as = (asn_len == 2) ?\n                        tvb_get_ntohs(tvb, o + i + aoff) :\n                        tvb_get_ntohl(tvb, o + i + aoff);\n                    proto_tree_add_uint(subtree2, hf_bgp_update_path_attribute_aggregator_as, tvb,\n                                        o + i + aoff, asn_len, aggregator_as);\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aggregator_origin, tvb,\n                                        o + i + aoff + asn_len, 4, ENC_BIG_ENDIAN);\n\n                    proto_item_append_text(ti_pa, \": AS: %u origin: %s\", aggregator_as,\n                                           tvb_ip_to_str(tvb, o + i + aoff + asn_len));\n                }\n                break;\n            case BGPTYPE_COMMUNITIES:\n                if (tlen % 4 != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Communities (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n\n                proto_item_append_text(ti_pa, \": \");\n\n                ti_communities = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_communities,\n                                                     tvb, o + i + aoff, tlen, ENC_NA);\n\n                communities_tree = proto_item_add_subtree(ti_communities,\n                                                          ett_bgp_communities);\n                proto_item_append_text(ti_communities, \": \");\n                /* (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple) */\n                q = o + i + aoff;\n                end = q + tlen;\n\n                /* snarf each community */\n                while (q < end) {\n                    /* check for reserved values */\n                    guint32 community = tvb_get_ntohl(tvb, q);\n                    if ((community & 0xFFFF0000) == FOURHEX0 ||\n                        (community & 0xFFFF0000) == FOURHEXF) {\n                        proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community_well_known,\n                                            tvb, q, 4, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti_pa, \"%s \", val_to_str_const(community, community_vals, \"Reserved\"));\n                        proto_item_append_text(ti_communities, \"%s \", val_to_str_const(community, community_vals, \"Reserved\"));\n                    }\n                    else {\n                        ti_community = proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community, tvb,\n                                                           q, 4, ENC_NA);\n                        community_tree = proto_item_add_subtree(ti_community,\n                                                                ett_bgp_community);\n                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_as,\n                                            tvb, q, 2, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_value,\n                                            tvb, q+2, 2, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti_pa, \"%u:%u \",tvb_get_ntohs(tvb, q),\n                                               tvb_get_ntohs(tvb, q+2));\n                        proto_item_append_text(ti_communities, \"%u:%u \",tvb_get_ntohs(tvb, q),\n                                               tvb_get_ntohs(tvb, q+2));\n                        proto_item_append_text(ti_community, \": %u:%u \",tvb_get_ntohs(tvb, q),\n                                               tvb_get_ntohs(tvb, q+2));\n                    }\n\n                    q += 4;\n                }\n\n\n                break;\n            case BGPTYPE_ORIGINATOR_ID:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Originator identifier (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_originator_id, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s \", tvb_ip_to_str(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_MP_REACH_NLRI:\n                /*\n                 * RFC 2545 specifies that there may be more than one\n                 * address in the MP_REACH_NLRI attribute in section\n                 * 3, \"Constructing the Next Hop field\".\n                 *\n                 * Yes, RFC 2858 says you can't do that, and, yes, RFC\n                 * 2858 obsoletes RFC 2283, which says you can do that,\n                 * but that doesn't mean we shouldn't dissect packets\n                 * that conform to RFC 2283 but not RFC 2858, as some\n                 * device on the network might implement the 2283-style\n                 * BGP extensions rather than RFC 2858-style extensions.\n                 */\n                af = tvb_get_ntohs(tvb, o + i + aoff);\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_address_family, tvb,\n                                    o + i + aoff, 2, ENC_BIG_ENDIAN);\n                saf = tvb_get_guint8(tvb, o + i + aoff + 2) ;\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_safi, tvb,\n                                    o + i + aoff+2, 1, ENC_BIG_ENDIAN);\n                nexthop_len = tvb_get_guint8(tvb, o + i + aoff + 3);\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff + 3,\n                                                         nexthop_len + 1, ett_bgp_mp_nhna, NULL,\n                                                         \"Next hop network address (%d byte%s)\",\n                                                         nexthop_len, plurality(nexthop_len, \"\", \"s\"));\n\n                /*\n                 * The addresses don't contain lengths, so if we\n                 * don't understand the address family type, we\n                 * cannot parse the subsequent addresses as we\n                 * don't know how long they are.\n                 */\n                switch (af) {\n                    default:\n                    proto_tree_add_expert(subtree3, pinfo, &ei_bgp_unknown_afi, tvb, o + i + aoff + 4, nexthop_len);\n                    break;\n\n                    case AFNUM_INET:\n                    case AFNUM_INET6:\n                    case AFNUM_L2VPN:\n                    case AFNUM_L2VPN_OLD:\n                    case AFNUM_LINK_STATE:\n\n                        j = 0;\n                        while (j < nexthop_len) {\n                            advance = mp_addr_to_str(af, saf, tvb, o + i + aoff + 4 + j,\n                                                     junk_emstr, nexthop_len) ;\n                            if (advance == 0) /* catch if this is a unknown AFI type*/\n                                break;\n                            if (j + advance > nexthop_len)\n                                break;\n                            proto_tree_add_string(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_next_hop, tvb,\n                                                 o + i + aoff + 4 + j, advance, wmem_strbuf_get_str(junk_emstr));\n\n                            j += advance;\n                        }\n                        break;\n                } /* switch (af) */\n\n                aoff_save = aoff;\n                tlen -= nexthop_len + 4;\n                aoff += nexthop_len + 4 ;\n\n                off = 0;\n                snpa = tvb_get_guint8(tvb, o + i + aoff);\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_nbr_snpa, tvb,\n                                         o + i + aoff, 1, ENC_BIG_ENDIAN);\n                off++;\n                if (snpa) {\n                    subtree3 = proto_item_add_subtree(ti, ett_bgp_mp_snpa);\n                    for (/*nothing*/; snpa > 0; snpa--) {\n                        guint8 snpa_length = tvb_get_guint8(tvb, o + i + aoff + off);\n                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa_length, tvb,\n                                            o + i + aoff + off, 1, ENC_BIG_ENDIAN);\n                        off++;\n                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa, tvb,\n                                            o + i + aoff + off, snpa_length, ENC_NA);\n                        off += snpa_length;\n                    }\n                }\n                tlen -= off;\n                aoff += off;\n\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff, tlen,\n                                                         ett_bgp_mp_reach_nlri, NULL, \"Network layer reachability information (%u byte%s)\",\n                                                         tlen, plurality(tlen, \"\", \"s\"));\n                if (tlen)  {\n                    if (af != AFNUM_INET && af != AFNUM_INET6 && af != AFNUM_L2VPN && af != AFNUM_LINK_STATE) {\n                        proto_tree_add_expert(subtree3, pinfo, &ei_bgp_unknown_afi, tvb, o + i + aoff, tlen);\n                    } else {\n                        while (tlen > 0) {\n                            advance = decode_prefix_MP(subtree3,\n                                                       hf_bgp_mp_reach_nlri_ipv4_prefix,\n                                                       hf_bgp_mp_reach_nlri_ipv6_prefix,\n                                                       af, saf,\n                                                       tvb, o + i + aoff, \"MP Reach NLRI\", pinfo);\n                            if (advance < 0)\n                                break;\n                            tlen -= advance;\n                            aoff += advance;\n                        }\n                    }\n                }\n                aoff = aoff_save;\n                break;\n            case BGPTYPE_MP_UNREACH_NLRI:\n                af = tvb_get_ntohs(tvb, o + i + aoff);\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_address_family, tvb,\n                                    o + i + aoff, 2, ENC_BIG_ENDIAN);\n                saf = tvb_get_guint8(tvb, o + i + aoff + 2) ;\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_safi, tvb,\n                                    o + i + aoff+2, 1, ENC_BIG_ENDIAN);\n\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff + 3,\n                                                         tlen - 3, ett_bgp_mp_unreach_nlri, NULL, \"Withdrawn routes (%u byte%s)\", tlen - 3,\n                                                         plurality(tlen - 3, \"\", \"s\"));\n\n                aoff_save = aoff;\n                tlen -= 3;\n                aoff += 3;\n                if (tlen > 0) {\n\n                    while (tlen > 0) {\n                        advance = decode_prefix_MP(subtree3,\n                                                   hf_bgp_mp_unreach_nlri_ipv4_prefix,\n                                                   hf_bgp_mp_unreach_nlri_ipv6_prefix,\n                                                   af, saf,\n                                                   tvb, o + i + aoff, \"MP Unreach NLRI\", pinfo);\n                        if (advance < 0)\n                            break;\n                        tlen -= advance;\n                        aoff += advance;\n                    }\n                }\n                aoff = aoff_save;\n                break;\n            case BGPTYPE_CLUSTER_LIST:\n                if (tlen % 4 != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Cluster list (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_cluster_list,\n                                         tvb, o + i + aoff, tlen, ENC_NA);\n                cluster_list_tree = proto_item_add_subtree(ti,\n                                                               ett_bgp_cluster_list);\n\n                /* (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple) */\n                q = o + i + aoff;\n                end = q + tlen;\n                proto_item_append_text(ti, \":\");\n                proto_item_append_text(ti_pa, \":\");\n                /* snarf each cluster identifier */\n                while (q < end) {\n                    proto_tree_add_item(cluster_list_tree, hf_bgp_update_path_attribute_cluster_id,\n                                        tvb, q - 3 + aoff, 4, ENC_NA);\n                    proto_item_append_text(ti, \" %s\", tvb_ip_to_str(tvb, q-3+aoff));\n                    proto_item_append_text(ti_pa, \" %s\", tvb_ip_to_str(tvb, q-3+aoff));\n                    q += 4;\n                }\n\n                break;\n            case BGPTYPE_EXTENDED_COMMUNITY:\n                if (tlen %8 != 0) {\n                    expert_add_info_format(pinfo, attr_len_item, &ei_bgp_ext_com_len_bad,\n                                           \"Community length %u wrong, must be modulo 8\", tlen);\n                } else {\n                    dissect_bgp_update_ext_com(subtree2, tvb, tlen, o+i+aoff);\n                }\n                break;\n            case BGPTYPE_SAFI_SPECIFIC_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen ;\n\n                while(q < end) {\n                    ssa_type = tvb_get_ntohs(tvb, q) & BGP_SSA_TYPE;\n                    ssa_len = tvb_get_ntohs(tvb, q + 2);\n\n                    subtree3 = proto_tree_add_subtree_format(subtree2, tvb, q, MIN(ssa_len + 4, end - q),\n                                                             ett_bgp_ssa, NULL, \"%s Information\",\n                                                             val_to_str_const(ssa_type, bgp_ssa_type, \"Unknown SSA\"));\n\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_t, tvb,\n                                        q, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_type, tvb, q, 2, ENC_BIG_ENDIAN);\n\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n\n                    if ((ssa_len == 0) || (q + ssa_len > end)) {\n                        proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 2,\n                                                     end - q - 2, \"Invalid Length of %u\", ssa_len);\n                        break;\n                    }\n\n                    switch (ssa_type) {\n                        case BGP_SSA_L2TPv3:\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_pref, tvb,\n                                                q + 4, 2, ENC_BIG_ENDIAN);\n\n                            subtree4 = proto_tree_add_subtree(subtree3, tvb, q + 6, 1, ett_bgp_ssa_subtree, NULL, \"Flags\");\n                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_s, tvb,\n                                                q + 6, 1, ENC_BIG_ENDIAN);\n                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_unused, tvb,\n                                                q + 6, 1, ENC_BIG_ENDIAN);\n\n                            ssa_v3_len = tvb_get_guint8(tvb, q + 7);\n                            if (ssa_v3_len + 8 == ssa_len){\n                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie_len, tvb,\n                                                    q + 7, 1, ENC_BIG_ENDIAN);\n                            } else {\n                                proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 7, 1,\n                                                             \"Invalid Cookie Length of %u\", ssa_v3_len);\n                                q += ssa_len + 4; /* 4 from type and length */\n                                break;\n                            }\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_session_id, tvb,\n                                                q + 8, 4, ENC_BIG_ENDIAN);\n                            if (ssa_v3_len)\n                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie, tvb,\n                                                    q + 12, ssa_v3_len, ENC_NA);\n                            q += ssa_len + 4; /* 4 from type and length */\n                            break;\n                        case BGP_SSA_mGRE:\n                        case BGP_SSA_IPSec:\n                        case BGP_SSA_MPLS:\n                        default:\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_value, tvb,\n                                                q + 4, ssa_len, ENC_NA);\n                            q += ssa_len + 4; /* 4 from type and length */\n                            break;\n                        case BGP_SSA_L2TPv3_IN_IPSec:\n                        case BGP_SSA_mGRE_IN_IPSec:\n                            /* These contain BGP_SSA_IPSec and BGP_SSA_L2TPv3/BGP_SSA_mGRE */\n                            q += 4; /* 4 from type and length */\n                            break;\n                    } /* switch (bgpa.bgpa_type) */\n                }\n                break;\n            case BGPTYPE_TUNNEL_ENCAPS_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen;\n\n                subtree3 = proto_tree_add_subtree(subtree2, tvb, q, tlen, ett_bgp_tunnel_tlv, NULL, \"TLV Encodings\");\n\n                while (q < end) {\n                    encaps_tunnel_type = tvb_get_ntohs(tvb, q);\n                    encaps_tunnel_len = tvb_get_ntohs(tvb, q + 2);\n\n                    subtree4 = proto_tree_add_subtree_format(subtree3, tvb, q, encaps_tunnel_len + 4,\n                                         ett_bgp_tunnel_tlv_subtree, NULL, \"%s (%u bytes)\",\n                                         val_to_str_const(encaps_tunnel_type, bgp_attr_tunnel_type, \"Unknown\"), encaps_tunnel_len + 4);\n\n                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_type, tvb, q, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n\n                    subtree5 = proto_tree_add_subtree(subtree4, tvb, q + 4, encaps_tunnel_len, ett_bgp_tunnel_subtlv, NULL, \"Sub-TLV Encodings\");\n\n                    q += 4;\n                    j = q + encaps_tunnel_len;\n                    while ( q < j ) {\n                        encaps_tunnel_subtype = tvb_get_guint8(tvb, q);\n                        encaps_tunnel_sublen = tvb_get_guint8(tvb, q + 1);\n\n                        subtree6 = proto_tree_add_subtree_format(subtree5, tvb, q, encaps_tunnel_sublen + 2, ett_bgp_tunnel_tlv_subtree, NULL, \"%s (%u bytes)\", val_to_str_const(encaps_tunnel_subtype, subtlv_type, \"Unknown\"), encaps_tunnel_sublen + 2);\n\n                        proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_type, tvb, q, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_len, tvb, q + 1, 1, ENC_BIG_ENDIAN);\n\n                        switch (encaps_tunnel_subtype) {\n                            case TUNNEL_SUBTLV_ENCAPSULATION:\n                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_session_id, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_cookie, tvb, q + 6, encaps_tunnel_sublen - 4, ENC_NA);\n                                } else if (encaps_tunnel_type == TUNNEL_TYPE_GRE) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                }\n                                break;\n                            case TUNNEL_SUBTLV_PROTO_TYPE:\n                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n                                break;\n                            case TUNNEL_SUBTLV_COLOR:\n                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_color_value, tvb, q + 6, 4, ENC_BIG_ENDIAN);\n                               break;\n                            case TUNNEL_SUBTLV_LOAD_BALANCE:\n                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP || encaps_tunnel_type == TUNNEL_TYPE_GRE) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_lb_block_length, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                }\n                                break;\n                            default:\n                                break;\n                        } /* switch (encaps_tunnel_subtype) */\n\n                        q += 2 + encaps_tunnel_sublen; /* type and length + length of value */\n                    }\n\n                }\n\n                break;\n            case BGPTYPE_AIGP:\n                q = o + i + aoff;\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aigp, tvb, q, tlen, ENC_NA);\n                subtree3 = proto_item_add_subtree(ti, ett_bgp_aigp_attr);\n                aigp_type_item =  proto_tree_add_item(subtree3, hf_bgp_aigp_type, tvb, q, 1, ENC_BIG_ENDIAN);\n                aigp_type = tvb_get_guint8(tvb,q);\n                switch (aigp_type) {\n                    case AIGP_TLV_TYPE :\n                        proto_tree_add_item(subtree3, hf_bgp_aigp_tlv_length, tvb, q+1, 2, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(subtree3, hf_bgp_aigp_accu_igp_metric, tvb, q+3, 8, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti, \": %\" G_GINT64_MODIFIER \"u\", tvb_get_ntoh64(tvb, q+3));\n                        proto_item_append_text(ti_pa, \": %\" G_GINT64_MODIFIER \"u\", tvb_get_ntoh64(tvb, q+3));\n                        break;\n                    default :\n                        expert_add_info_format(pinfo, aigp_type_item, &ei_bgp_attr_aigp_type,\n                                               \"AIGP type %u unknown\", aigp_type);\n                }\n                break;\n            case BGPTYPE_LINK_STATE_ATTR:\n            case BGPTYPE_LINK_STATE_OLD_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen;\n                /* FF: BGPTYPE_LINK_STATE_ATTR body dissection is moved after the while.\n                   Here we just save the TLV coordinates and the subtree. */\n                save_link_state_attr_position(pinfo, q, end, tlen, subtree2);\n                break;\n\n            case BGPTYPE_PMSI_TUNNEL_ATTR:\n                dissect_bgp_update_pmsi_attr(pinfo, subtree2, tvb, tlen, o+i+aoff);\n                break;\n\n            case BGPTYPE_ATTR_SET:\n                if (alen >= 4) {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_attrset_origin_as, tvb,\n                                        o + i + aoff, 4, ENC_BIG_ENDIAN);\n                    if (alen > 4) {\n                        ti =  proto_tree_add_item(subtree2, hf_bgp_update_path_attributes, tvb, o+i+aoff+4, alen-4, ENC_NA);\n                        attr_set_subtree = proto_item_add_subtree(ti, ett_bgp_attrs);\n                        dissect_bgp_path_attr(attr_set_subtree, tvb, alen-4, o+i+aoff+4, pinfo);\n                    }\n                } else {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, alen,\n                                                 \"Attribute set (invalid): %u bytes%s\",\n                                                 alen, plurality(alen, \"\", \"s\"));\n                }\n                break;\n            default:\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attributes_unknown, tvb, o + i + aoff, tlen, ENC_NA);\n                break;\n        } /* switch (bgpa.bgpa_type) */ /* end of second switch */\n\n        i += alen + aoff;\n    }\n    {\n        /* FF: postponed BGPTYPE_LINK_STATE_ATTR dissection */\n        link_state_data *data = load_link_state_data(pinfo);\n        if (data && data->link_state_attr_present) {\n            ti = proto_tree_add_item(data->subtree2, hf_bgp_update_path_attribute_link_state, tvb, data->ostart, data->tlen, ENC_NA);\n            subtree3 = proto_item_add_subtree(ti, ett_bgp_link_state);\n            while (data->ostart < data->oend) {\n                advance = decode_link_state_attribute_tlv(subtree3, tvb, data->ostart, pinfo, data->protocol_id);\n                if (advance < 0) {\n                    break;\n                }\n                data->ostart += advance;\n            }\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -87,6 +87,12 @@\n \n         attr_len_item = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_length, tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE,\n                                             aoff - BGP_SIZE_OF_PATH_ATTRIBUTE, ENC_BIG_ENDIAN);\n+        if (aoff + tlen > path_attr_len - i) {\n+            proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n+                                         \"Path attribute length is invalid: %u byte%s\", tlen,\n+                                         plurality(tlen, \"\", \"s\"));\n+            return;\n+        }\n \n         /* Path Attribute Type */\n         switch (bgpa_type) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (aoff + tlen > path_attr_len - i) {",
                "            proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,",
                "                                         \"Path attribute length is invalid: %u byte%s\", tlen,",
                "                                         plurality(tlen, \"\", \"s\"));",
                "            return;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-5632",
        "func_name": "eclipse/mosquitto/packet__write",
        "description": "In Eclipse Mosquito before and including 2.0.5, establishing a connection to the mosquitto server without sending data causes the EPOLLOUT event to be added, which results excessive CPU consumption. This could be used by a malicious actor to perform denial of service type attack. This issue is fixed in 2.0.6\n\n\n",
        "git_url": "https://github.com/eclipse/mosquitto/commit/18bad1ff32435e523d7507e9b2ce0010124a8f2d",
        "commit_title": "Unconditionally adding an event to the epoll causes 100% CPU usage. This happens when the connection to the server is established and the client has not sent any data yet.",
        "commit_text": "",
        "func_before": "int packet__write(struct mosquitto *mosq)\n{\n\tssize_t write_length;\n\tstruct mosquitto__packet *packet;\n\tenum mosquitto_client_state state;\n\n\tif(!mosq) return MOSQ_ERR_INVAL;\n\tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n\n#ifdef WITH_BROKER\n\tmux__add_out(mosq);\n#endif\n\n\tpthread_mutex_lock(&mosq->current_out_packet_mutex);\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\tif(mosq->out_packet && !mosq->current_out_packet){\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tmosq->out_packet = mosq->out_packet->next;\n\t\tif(!mosq->out_packet){\n\t\t\tmosq->out_packet_last = NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\n\tstate = mosquitto__get_state(mosq);\n#if defined(WITH_TLS) && !defined(WITH_BROKER)\n\tif(state == mosq_cs_connect_pending || mosq->want_connect){\n#else\n\tif(state == mosq_cs_connect_pending){\n#endif\n\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n\n\twhile(mosq->current_out_packet){\n\t\tpacket = mosq->current_out_packet;\n\n\t\twhile(packet->to_process > 0){\n\t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n\t\t\tif(write_length > 0){\n\t\t\t\tG_BYTES_SENT_INC(write_length);\n\t\t\t\tpacket->to_process -= (uint32_t)write_length;\n\t\t\t\tpacket->pos += (uint32_t)write_length;\n\t\t\t}else{\n#ifdef WIN32\n\t\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK\n#ifdef WIN32\n\t\t\t\t\t\t|| errno == WSAENOTCONN\n#endif\n\t\t\t\t\t\t){\n\t\t\t\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}else{\n\t\t\t\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\t\t\t\tswitch(errno){\n\t\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tG_MSGS_SENT_INC(1);\n\t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n\t\t\tG_PUB_MSGS_SENT_INC(1);\n#ifndef WITH_BROKER\n\t\t\tpthread_mutex_lock(&mosq->callback_mutex);\n\t\t\tif(mosq->on_publish){\n\t\t\t\t/* This is a QoS=0 message */\n\t\t\t\tmosq->in_callback = true;\n\t\t\t\tmosq->on_publish(mosq, mosq->userdata, packet->mid);\n\t\t\t\tmosq->in_callback = false;\n\t\t\t}\n\t\t\tif(mosq->on_publish_v5){\n\t\t\t\t/* This is a QoS=0 message */\n\t\t\t\tmosq->in_callback = true;\n\t\t\t\tmosq->on_publish_v5(mosq, mosq->userdata, packet->mid, 0, NULL);\n\t\t\t\tmosq->in_callback = false;\n\t\t\t}\n\t\t\tpthread_mutex_unlock(&mosq->callback_mutex);\n\t\t}else if(((packet->command)&0xF0) == CMD_DISCONNECT){\n\t\t\tdo_client_disconnect(mosq, MOSQ_ERR_SUCCESS, NULL);\n\t\t\tpacket__cleanup(packet);\n\t\t\tmosquitto__free(packet);\n\t\t\treturn MOSQ_ERR_SUCCESS;\n#endif\n\t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n\t\t\tG_PUB_MSGS_SENT_INC(1);\n\t\t}\n\n\t\t/* Free data and reset values */\n\t\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tif(mosq->out_packet){\n\t\t\tmosq->out_packet = mosq->out_packet->next;\n\t\t\tif(!mosq->out_packet){\n\t\t\t\tmosq->out_packet_last = NULL;\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\n\t\tpacket__cleanup(packet);\n\t\tmosquitto__free(packet);\n\n#ifdef WITH_BROKER\n\t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n\t\tif(mosq->current_out_packet == NULL){\n\t\t\tmux__remove_out(mosq);\n\t\t}\n#else\n\t\tpthread_mutex_lock(&mosq->msgtime_mutex);\n\t\tmosq->next_msg_out = mosquitto_time() + mosq->keepalive;\n\t\tpthread_mutex_unlock(&mosq->msgtime_mutex);\n#endif\n\t}\n\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\treturn MOSQ_ERR_SUCCESS;\n}",
        "func": "int packet__write(struct mosquitto *mosq)\n{\n\tssize_t write_length;\n\tstruct mosquitto__packet *packet;\n\tenum mosquitto_client_state state;\n\n\tif(!mosq) return MOSQ_ERR_INVAL;\n\tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n\n#ifdef WITH_BROKER\n\tif (mosq->current_out_packet) {\n\t   mux__add_out(mosq);\n\t}\n#endif\n\n\tpthread_mutex_lock(&mosq->current_out_packet_mutex);\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\tif(mosq->out_packet && !mosq->current_out_packet){\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tmosq->out_packet = mosq->out_packet->next;\n\t\tif(!mosq->out_packet){\n\t\t\tmosq->out_packet_last = NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\n\tstate = mosquitto__get_state(mosq);\n#if defined(WITH_TLS) && !defined(WITH_BROKER)\n\tif(state == mosq_cs_connect_pending || mosq->want_connect){\n#else\n\tif(state == mosq_cs_connect_pending){\n#endif\n\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n\n\twhile(mosq->current_out_packet){\n\t\tpacket = mosq->current_out_packet;\n\n\t\twhile(packet->to_process > 0){\n\t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n\t\t\tif(write_length > 0){\n\t\t\t\tG_BYTES_SENT_INC(write_length);\n\t\t\t\tpacket->to_process -= (uint32_t)write_length;\n\t\t\t\tpacket->pos += (uint32_t)write_length;\n\t\t\t}else{\n#ifdef WIN32\n\t\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK\n#ifdef WIN32\n\t\t\t\t\t\t|| errno == WSAENOTCONN\n#endif\n\t\t\t\t\t\t){\n\t\t\t\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}else{\n\t\t\t\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\t\t\t\tswitch(errno){\n\t\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tG_MSGS_SENT_INC(1);\n\t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n\t\t\tG_PUB_MSGS_SENT_INC(1);\n#ifndef WITH_BROKER\n\t\t\tpthread_mutex_lock(&mosq->callback_mutex);\n\t\t\tif(mosq->on_publish){\n\t\t\t\t/* This is a QoS=0 message */\n\t\t\t\tmosq->in_callback = true;\n\t\t\t\tmosq->on_publish(mosq, mosq->userdata, packet->mid);\n\t\t\t\tmosq->in_callback = false;\n\t\t\t}\n\t\t\tif(mosq->on_publish_v5){\n\t\t\t\t/* This is a QoS=0 message */\n\t\t\t\tmosq->in_callback = true;\n\t\t\t\tmosq->on_publish_v5(mosq, mosq->userdata, packet->mid, 0, NULL);\n\t\t\t\tmosq->in_callback = false;\n\t\t\t}\n\t\t\tpthread_mutex_unlock(&mosq->callback_mutex);\n\t\t}else if(((packet->command)&0xF0) == CMD_DISCONNECT){\n\t\t\tdo_client_disconnect(mosq, MOSQ_ERR_SUCCESS, NULL);\n\t\t\tpacket__cleanup(packet);\n\t\t\tmosquitto__free(packet);\n\t\t\treturn MOSQ_ERR_SUCCESS;\n#endif\n\t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n\t\t\tG_PUB_MSGS_SENT_INC(1);\n\t\t}\n\n\t\t/* Free data and reset values */\n\t\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tif(mosq->out_packet){\n\t\t\tmosq->out_packet = mosq->out_packet->next;\n\t\t\tif(!mosq->out_packet){\n\t\t\t\tmosq->out_packet_last = NULL;\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\n\t\tpacket__cleanup(packet);\n\t\tmosquitto__free(packet);\n\n#ifdef WITH_BROKER\n\t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n\t\tif(mosq->current_out_packet == NULL){\n\t\t\tmux__remove_out(mosq);\n\t\t}\n#else\n\t\tpthread_mutex_lock(&mosq->msgtime_mutex);\n\t\tmosq->next_msg_out = mosquitto_time() + mosq->keepalive;\n\t\tpthread_mutex_unlock(&mosq->msgtime_mutex);\n#endif\n\t}\n\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\treturn MOSQ_ERR_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,9 @@\n \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n \n #ifdef WITH_BROKER\n-\tmux__add_out(mosq);\n+\tif (mosq->current_out_packet) {\n+\t   mux__add_out(mosq);\n+\t}\n #endif\n \n \tpthread_mutex_lock(&mosq->current_out_packet_mutex);",
        "diff_line_info": {
            "deleted_lines": [
                "\tmux__add_out(mosq);"
            ],
            "added_lines": [
                "\tif (mosq->current_out_packet) {",
                "\t   mux__add_out(mosq);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1993",
        "func_name": "wireshark/dissect_lcaf",
        "description": "LISP dissector large loop in Wireshark 4.0.0 to 4.0.4 and 3.6.0 to 3.6.12 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b911cf286f495ba068c77b8b2b3445d1a325a819",
        "commit_title": "LISP: Don't go past a LCAF payload length",
        "commit_text": " The LISP Canonical Address Format has a payload length indicator. Use that to create a payload tvb and don't dissect outside the payload length. With fuzzed and malformed packets, this was causing the same bytes to be dissected many times, particularly in the recursive address types.  A LCAF would be dissected outside the payload region, but then elsewhere the offset was only advanced by the payload length.  Fix #18900 ",
        "func_before": "int\ndissect_lcaf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset, proto_item *tip)\n{\n    guint8       lcaf_type;\n    guint16      len;\n    proto_item  *tir, *ti_header, *ti_flags, *ti;\n    proto_tree  *lcaf_tree, *lcaf_header_tree, *flags_tree;\n\n    len = tvb_get_ntohs(tvb, offset + 4);\n\n    tir = proto_tree_add_item(tree, hf_lisp_lcaf, tvb, offset, LCAF_HEADER_LEN + len, ENC_NA);\n    lcaf_tree = proto_item_add_subtree(tir, ett_lisp_lcaf);\n\n    ti_header = proto_tree_add_item(lcaf_tree, hf_lisp_lcaf_header, tvb, offset, LCAF_HEADER_LEN, ENC_NA);\n    lcaf_header_tree = proto_item_add_subtree(ti_header, ett_lisp_lcaf_header);\n\n    /* Reserved bits (8 bits) */\n    proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_res1, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    /* Flags (8 bits) */\n    proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    /* Type (8 bits) */\n    proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    lcaf_type = tvb_get_guint8(tvb, offset);\n    proto_item_append_text(tir, \": %s\", val_to_str(lcaf_type, lcaf_typevals, \"Unknown (%d)\"));\n    offset += 1;\n\n    if (lcaf_type == LCAF_MCAST_INFO) {\n        ti_flags = proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_mcinfo_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n        flags_tree = proto_item_add_subtree(ti_flags, ett_lisp_lcaf_mcinfo_flags);\n\n        /* Reserved (5 bits) */\n        proto_tree_add_item(flags_tree, hf_lisp_lcaf_mcinfo_flags_res, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n        /* Flags (3 bits) */\n        proto_tree_add_item(flags_tree, hf_lisp_lcaf_mcinfo_flags_rp, tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(flags_tree, hf_lisp_lcaf_mcinfo_flags_leave, tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(flags_tree, hf_lisp_lcaf_mcinfo_flags_join, tvb, offset, 1, ENC_NA);\n    } else {\n        /* Reserved (8 bits) */\n        proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_res2, tvb, offset, 1, ENC_BIG_ENDIAN);\n    }\n    offset += 1;\n\n    /* Length (16 bits) */\n    proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    ti = (tip) ? tip : tir;\n\n    switch (lcaf_type) {\n        case LCAF_NULL:\n            break;\n        case LCAF_AFI_LIST:\n            offset = dissect_lcaf_afi_list(tvb, pinfo, lcaf_tree, offset, len);\n            break;\n        case LCAF_IID:\n            offset = dissect_lcaf_iid(tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_ASN:\n            offset = dissect_lcaf_asn(tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_GEO:\n            offset = dissect_lcaf_geo(tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_NATT:\n            offset = dissect_lcaf_natt(tvb, pinfo, lcaf_tree, offset, len);\n            break;\n        case LCAF_NONCE_LOC:\n            offset = dissect_lcaf_nonce_loc(tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_MCAST_INFO:\n            offset = dissect_lcaf_mcast_info(tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_ELP:\n            offset = dissect_lcaf_elp(tvb, pinfo, lcaf_tree, offset, len, ti);\n            break;\n        case LCAF_SRC_DST_KEY:\n            offset = dissect_lcaf_src_dst_key(tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_RLE:\n            offset = dissect_lcaf_rle(tvb, pinfo, lcaf_tree, offset, len, ti);\n            break;\n        case LCAF_KV_ADDR_PAIR:\n            offset = dissect_lcaf_kv_addr_pair(tvb, pinfo, lcaf_tree, offset);\n            break;\n        case LCAF_VENDOR:\n            offset = dissect_lcaf_vendor(tvb, pinfo, lcaf_tree, offset, len);\n            break;\n        default:\n            proto_tree_add_expert(tree, pinfo, &ei_lisp_undecoded, tvb, offset, len);\n            return offset + len;\n    }\n    return offset;\n}",
        "func": "int\ndissect_lcaf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset, proto_item *tip)\n{\n    guint8       lcaf_type;\n    guint16      len;\n    proto_item  *tir, *ti_header, *ti_flags, *ti;\n    proto_tree  *lcaf_tree, *lcaf_header_tree, *flags_tree;\n    tvbuff_t    *payload_tvb;\n\n    len = tvb_get_ntohs(tvb, offset + 4);\n\n    tir = proto_tree_add_item(tree, hf_lisp_lcaf, tvb, offset, LCAF_HEADER_LEN + len, ENC_NA);\n    lcaf_tree = proto_item_add_subtree(tir, ett_lisp_lcaf);\n\n    ti_header = proto_tree_add_item(lcaf_tree, hf_lisp_lcaf_header, tvb, offset, LCAF_HEADER_LEN, ENC_NA);\n    lcaf_header_tree = proto_item_add_subtree(ti_header, ett_lisp_lcaf_header);\n\n    /* Reserved bits (8 bits) */\n    proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_res1, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    /* Flags (8 bits) */\n    proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    /* Type (8 bits) */\n    proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    lcaf_type = tvb_get_guint8(tvb, offset);\n    proto_item_append_text(tir, \": %s\", val_to_str(lcaf_type, lcaf_typevals, \"Unknown (%d)\"));\n    offset += 1;\n\n    if (lcaf_type == LCAF_MCAST_INFO) {\n        ti_flags = proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_mcinfo_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n        flags_tree = proto_item_add_subtree(ti_flags, ett_lisp_lcaf_mcinfo_flags);\n\n        /* Reserved (5 bits) */\n        proto_tree_add_item(flags_tree, hf_lisp_lcaf_mcinfo_flags_res, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n        /* Flags (3 bits) */\n        proto_tree_add_item(flags_tree, hf_lisp_lcaf_mcinfo_flags_rp, tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(flags_tree, hf_lisp_lcaf_mcinfo_flags_leave, tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(flags_tree, hf_lisp_lcaf_mcinfo_flags_join, tvb, offset, 1, ENC_NA);\n    } else {\n        /* Reserved (8 bits) */\n        proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_res2, tvb, offset, 1, ENC_BIG_ENDIAN);\n    }\n    offset += 1;\n\n    /* Length (16 bits) */\n    proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    payload_tvb = tvb_new_subset_length(tvb, 0, offset + len);\n    ti = (tip) ? tip : tir;\n\n    switch (lcaf_type) {\n        case LCAF_NULL:\n            break;\n        case LCAF_AFI_LIST:\n            offset = dissect_lcaf_afi_list(payload_tvb, pinfo, lcaf_tree, offset, len);\n            break;\n        case LCAF_IID:\n            offset = dissect_lcaf_iid(payload_tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_ASN:\n            offset = dissect_lcaf_asn(payload_tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_GEO:\n            offset = dissect_lcaf_geo(payload_tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_NATT:\n            offset = dissect_lcaf_natt(payload_tvb, pinfo, lcaf_tree, offset, len);\n            break;\n        case LCAF_NONCE_LOC:\n            offset = dissect_lcaf_nonce_loc(payload_tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_MCAST_INFO:\n            offset = dissect_lcaf_mcast_info(payload_tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_ELP:\n            offset = dissect_lcaf_elp(payload_tvb, pinfo, lcaf_tree, offset, len, ti);\n            break;\n        case LCAF_SRC_DST_KEY:\n            offset = dissect_lcaf_src_dst_key(payload_tvb, pinfo, lcaf_tree, offset, ti);\n            break;\n        case LCAF_RLE:\n            offset = dissect_lcaf_rle(payload_tvb, pinfo, lcaf_tree, offset, len, ti);\n            break;\n        case LCAF_KV_ADDR_PAIR:\n            offset = dissect_lcaf_kv_addr_pair(payload_tvb, pinfo, lcaf_tree, offset);\n            break;\n        case LCAF_VENDOR:\n            offset = dissect_lcaf_vendor(payload_tvb, pinfo, lcaf_tree, offset, len);\n            break;\n        default:\n            proto_tree_add_expert(tree, pinfo, &ei_lisp_undecoded, tvb, offset, len);\n            return offset + len;\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,7 @@\n     guint16      len;\n     proto_item  *tir, *ti_header, *ti_flags, *ti;\n     proto_tree  *lcaf_tree, *lcaf_header_tree, *flags_tree;\n+    tvbuff_t    *payload_tvb;\n \n     len = tvb_get_ntohs(tvb, offset + 4);\n \n@@ -49,46 +50,47 @@\n     proto_tree_add_item(lcaf_header_tree, hf_lisp_lcaf_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n     offset += 2;\n \n+    payload_tvb = tvb_new_subset_length(tvb, 0, offset + len);\n     ti = (tip) ? tip : tir;\n \n     switch (lcaf_type) {\n         case LCAF_NULL:\n             break;\n         case LCAF_AFI_LIST:\n-            offset = dissect_lcaf_afi_list(tvb, pinfo, lcaf_tree, offset, len);\n+            offset = dissect_lcaf_afi_list(payload_tvb, pinfo, lcaf_tree, offset, len);\n             break;\n         case LCAF_IID:\n-            offset = dissect_lcaf_iid(tvb, pinfo, lcaf_tree, offset, ti);\n+            offset = dissect_lcaf_iid(payload_tvb, pinfo, lcaf_tree, offset, ti);\n             break;\n         case LCAF_ASN:\n-            offset = dissect_lcaf_asn(tvb, pinfo, lcaf_tree, offset, ti);\n+            offset = dissect_lcaf_asn(payload_tvb, pinfo, lcaf_tree, offset, ti);\n             break;\n         case LCAF_GEO:\n-            offset = dissect_lcaf_geo(tvb, pinfo, lcaf_tree, offset, ti);\n+            offset = dissect_lcaf_geo(payload_tvb, pinfo, lcaf_tree, offset, ti);\n             break;\n         case LCAF_NATT:\n-            offset = dissect_lcaf_natt(tvb, pinfo, lcaf_tree, offset, len);\n+            offset = dissect_lcaf_natt(payload_tvb, pinfo, lcaf_tree, offset, len);\n             break;\n         case LCAF_NONCE_LOC:\n-            offset = dissect_lcaf_nonce_loc(tvb, pinfo, lcaf_tree, offset, ti);\n+            offset = dissect_lcaf_nonce_loc(payload_tvb, pinfo, lcaf_tree, offset, ti);\n             break;\n         case LCAF_MCAST_INFO:\n-            offset = dissect_lcaf_mcast_info(tvb, pinfo, lcaf_tree, offset, ti);\n+            offset = dissect_lcaf_mcast_info(payload_tvb, pinfo, lcaf_tree, offset, ti);\n             break;\n         case LCAF_ELP:\n-            offset = dissect_lcaf_elp(tvb, pinfo, lcaf_tree, offset, len, ti);\n+            offset = dissect_lcaf_elp(payload_tvb, pinfo, lcaf_tree, offset, len, ti);\n             break;\n         case LCAF_SRC_DST_KEY:\n-            offset = dissect_lcaf_src_dst_key(tvb, pinfo, lcaf_tree, offset, ti);\n+            offset = dissect_lcaf_src_dst_key(payload_tvb, pinfo, lcaf_tree, offset, ti);\n             break;\n         case LCAF_RLE:\n-            offset = dissect_lcaf_rle(tvb, pinfo, lcaf_tree, offset, len, ti);\n+            offset = dissect_lcaf_rle(payload_tvb, pinfo, lcaf_tree, offset, len, ti);\n             break;\n         case LCAF_KV_ADDR_PAIR:\n-            offset = dissect_lcaf_kv_addr_pair(tvb, pinfo, lcaf_tree, offset);\n+            offset = dissect_lcaf_kv_addr_pair(payload_tvb, pinfo, lcaf_tree, offset);\n             break;\n         case LCAF_VENDOR:\n-            offset = dissect_lcaf_vendor(tvb, pinfo, lcaf_tree, offset, len);\n+            offset = dissect_lcaf_vendor(payload_tvb, pinfo, lcaf_tree, offset, len);\n             break;\n         default:\n             proto_tree_add_expert(tree, pinfo, &ei_lisp_undecoded, tvb, offset, len);",
        "diff_line_info": {
            "deleted_lines": [
                "            offset = dissect_lcaf_afi_list(tvb, pinfo, lcaf_tree, offset, len);",
                "            offset = dissect_lcaf_iid(tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_asn(tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_geo(tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_natt(tvb, pinfo, lcaf_tree, offset, len);",
                "            offset = dissect_lcaf_nonce_loc(tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_mcast_info(tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_elp(tvb, pinfo, lcaf_tree, offset, len, ti);",
                "            offset = dissect_lcaf_src_dst_key(tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_rle(tvb, pinfo, lcaf_tree, offset, len, ti);",
                "            offset = dissect_lcaf_kv_addr_pair(tvb, pinfo, lcaf_tree, offset);",
                "            offset = dissect_lcaf_vendor(tvb, pinfo, lcaf_tree, offset, len);"
            ],
            "added_lines": [
                "    tvbuff_t    *payload_tvb;",
                "    payload_tvb = tvb_new_subset_length(tvb, 0, offset + len);",
                "            offset = dissect_lcaf_afi_list(payload_tvb, pinfo, lcaf_tree, offset, len);",
                "            offset = dissect_lcaf_iid(payload_tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_asn(payload_tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_geo(payload_tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_natt(payload_tvb, pinfo, lcaf_tree, offset, len);",
                "            offset = dissect_lcaf_nonce_loc(payload_tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_mcast_info(payload_tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_elp(payload_tvb, pinfo, lcaf_tree, offset, len, ti);",
                "            offset = dissect_lcaf_src_dst_key(payload_tvb, pinfo, lcaf_tree, offset, ti);",
                "            offset = dissect_lcaf_rle(payload_tvb, pinfo, lcaf_tree, offset, len, ti);",
                "            offset = dissect_lcaf_kv_addr_pair(payload_tvb, pinfo, lcaf_tree, offset);",
                "            offset = dissect_lcaf_vendor(payload_tvb, pinfo, lcaf_tree, offset, len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11409",
        "func_name": "wireshark/llc_gprs_dissect_xid",
        "description": "In Wireshark 2.0.0 to 2.0.13, the GPRS LLC dissector could go into a large loop. This was addressed in epan/dissectors/packet-gprs-llc.c by using a different integer data type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/57b83bbbd76f543eb8d108919f13b662910bff9a",
        "commit_title": "GPRS LLC: fix a variable overflow when decoding XID",
        "commit_text": " Bug: 13603",
        "func_before": "static void llc_gprs_dissect_xid(tvbuff_t *tvb,\n\t\t\t\t\t\t\t\t packet_info *pinfo,\n\t\t\t\t\t\t\t\t proto_item *llcgprs_tree)\n\n{\n\tguint8 xid_param_len = 0, byte1 = 0, byte2 = 0, item_len = 0, tmp = 0;\n\tguint16 location = 0;\n\tguint16 loop_counter = 0;\n\tproto_tree *uinfo_tree = NULL;\n\tproto_tree *xid_tree = NULL;\n\tguint16 info_len;\n\n\tinfo_len = tvb_reported_length(tvb);\n\n\txid_tree = proto_tree_add_subtree_format(llcgprs_tree, tvb, 0, info_len,\n\t\t\t\tett_ui, NULL, \"Information Field: Length = %u\", info_len);\n\n\twhile (location < info_len)\n\t{\n\t\t/* parse the XID parameters */\n\t\tbyte1 = tvb_get_guint8(tvb, location);\n\n\t\tif (byte1 & 0x80)\n\t\t{\n\t\t\tguint8 xid_param_len_high = 0;\n\t\t\tguint8 xid_param_len_low = 0;\n\t\t\tbyte2 = tvb_get_guint8(tvb, location + 1);\n\n\t\t\t/* XL bit is set - length is continued in second byte */\n\t\t\txid_param_len_high = byte1 & 0x03;\n\t\t\txid_param_len_low = byte2 & 0xFC;\n\n\t\t\t/* bit shift the rest of the length */\n\t\t\txid_param_len_low = xid_param_len_low >> 2;\n\t\t\txid_param_len_low = xid_param_len_low & 0x3F;\n\n\t\t\txid_param_len_high = xid_param_len_high << 6;\n\t\t\txid_param_len_high = xid_param_len_high & 0xC0;\n\n\t\t\t/* combine the two */\n\t\t\txid_param_len = xid_param_len_high | xid_param_len_low;\n\t\t\titem_len = xid_param_len + 2;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\txid_param_len = byte1 & 0x3;\n\t\t\titem_len = xid_param_len + 1;\n\t\t}\n\n\t\ttmp =  byte1 & 0x7C;\n\t\ttmp = tmp >> 2;\n\n\t\tif (tmp == 0xB) /* L3 XID parameters, call the SNDCP-XID dissector */\n\t\t{\n\t\t\ttvbuff_t\t*sndcp_xid_tvb;\n\t\t\tguint8 sndcp_xid_offset;\n\n\t\t\tuinfo_tree = proto_tree_add_subtree(xid_tree, tvb, location, item_len,\n\t\t\t\tett_ui, NULL, \"XID parameter Type: L3 parameters\");\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location, 1, byte1);\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location+1, 1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location+1, 1, byte2);\n\t\t\t\tsndcp_xid_offset = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsndcp_xid_offset = 1;\n\t\t\t}\n\n\t\t\tif (xid_param_len) {\n\n\t\t\t\tsndcp_xid_tvb = tvb_new_subset_length (tvb, location+sndcp_xid_offset, xid_param_len);\n\n\t\t\t\tif(sndcp_xid_handle)\n\t\t\t\t{\n\t\t\t\t\tcall_dissector(sndcp_xid_handle, sndcp_xid_tvb, pinfo, uinfo_tree);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocation += item_len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (( xid_param_len > 0 ) && ( xid_param_len <=4 ))\n\t\t\t{\n\t\t\t\tguint32 value = 0;\n\t\t\t\tguint8 i;\n\t\t\t\tfor (i=1;i<=xid_param_len;i++)\n\t\t\t\t{\n\t\t\t\t\tvalue <<= 8;\n\t\t\t\t\tvalue |= (guint32)tvb_get_guint8(tvb, location+i );\n\t\t\t\t}\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \"XID Parameter Type: %s - Value: %u\",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \"Reserved Type:%X\"), value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \"XID Parameter Type: %s\",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \"Reserved Type:%X\"));\n\t\t\t}\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location,\n\t\t\t\t1, byte1);\n\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\t/* length continued into byte 2 */\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location,\n\t\t\t\t\t1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location,\n\t\t\t\t\t1, byte2);\n\n\t\t\t\t/* be sure to account for the second byte of length */\n\t\t\t\tlocation++;\n\t\t\t}\n\n\t\t\tlocation++;\n\t\t\tfor (loop_counter = 0; loop_counter < xid_param_len; loop_counter++)\n\t\t\t{\n\t\t\t\t/* grab the information in the XID param */\n\t\t\t\tbyte2 = tvb_get_guint8(tvb, location);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_byte, tvb, location,\n\t\t\t\t\t1, byte2);\n\t\t\t\tlocation++;\n\t\t\t}\n\t\t}\n\t}\n}",
        "func": "static void llc_gprs_dissect_xid(tvbuff_t *tvb,\n\t\t\t\t\t\t\t\t packet_info *pinfo,\n\t\t\t\t\t\t\t\t proto_item *llcgprs_tree)\n\n{\n\tguint8 xid_param_len = 0, byte1 = 0, byte2 = 0, tmp = 0;\n\tguint16 location = 0;\n\tguint16 loop_counter = 0;\n\tproto_tree *uinfo_tree = NULL;\n\tproto_tree *xid_tree = NULL;\n\tguint16 info_len, item_len;\n\n\tinfo_len = tvb_reported_length(tvb);\n\n\txid_tree = proto_tree_add_subtree_format(llcgprs_tree, tvb, 0, info_len,\n\t\t\t\tett_ui, NULL, \"Information Field: Length = %u\", info_len);\n\n\twhile (location < info_len)\n\t{\n\t\t/* parse the XID parameters */\n\t\tbyte1 = tvb_get_guint8(tvb, location);\n\n\t\tif (byte1 & 0x80)\n\t\t{\n\t\t\tguint8 xid_param_len_high = 0;\n\t\t\tguint8 xid_param_len_low = 0;\n\t\t\tbyte2 = tvb_get_guint8(tvb, location + 1);\n\n\t\t\t/* XL bit is set - length is continued in second byte */\n\t\t\txid_param_len_high = byte1 & 0x03;\n\t\t\txid_param_len_low = byte2 & 0xFC;\n\n\t\t\t/* bit shift the rest of the length */\n\t\t\txid_param_len_low = xid_param_len_low >> 2;\n\t\t\txid_param_len_low = xid_param_len_low & 0x3F;\n\n\t\t\txid_param_len_high = xid_param_len_high << 6;\n\t\t\txid_param_len_high = xid_param_len_high & 0xC0;\n\n\t\t\t/* combine the two */\n\t\t\txid_param_len = xid_param_len_high | xid_param_len_low;\n\t\t\titem_len = xid_param_len + 2;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\txid_param_len = byte1 & 0x3;\n\t\t\titem_len = xid_param_len + 1;\n\t\t}\n\n\t\ttmp =  byte1 & 0x7C;\n\t\ttmp = tmp >> 2;\n\n\t\tif (tmp == 0xB) /* L3 XID parameters, call the SNDCP-XID dissector */\n\t\t{\n\t\t\ttvbuff_t\t*sndcp_xid_tvb;\n\t\t\tguint8 sndcp_xid_offset;\n\n\t\t\tuinfo_tree = proto_tree_add_subtree(xid_tree, tvb, location, item_len,\n\t\t\t\tett_ui, NULL, \"XID parameter Type: L3 parameters\");\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location, 1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location, 1, byte1);\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location+1, 1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location+1, 1, byte2);\n\t\t\t\tsndcp_xid_offset = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsndcp_xid_offset = 1;\n\t\t\t}\n\n\t\t\tif (xid_param_len) {\n\n\t\t\t\tsndcp_xid_tvb = tvb_new_subset_length (tvb, location+sndcp_xid_offset, xid_param_len);\n\n\t\t\t\tif(sndcp_xid_handle)\n\t\t\t\t{\n\t\t\t\t\tcall_dissector(sndcp_xid_handle, sndcp_xid_tvb, pinfo, uinfo_tree);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocation += item_len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (( xid_param_len > 0 ) && ( xid_param_len <=4 ))\n\t\t\t{\n\t\t\t\tguint32 value = 0;\n\t\t\t\tguint8 i;\n\t\t\t\tfor (i=1;i<=xid_param_len;i++)\n\t\t\t\t{\n\t\t\t\t\tvalue <<= 8;\n\t\t\t\t\tvalue |= (guint32)tvb_get_guint8(tvb, location+i );\n\t\t\t\t}\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \"XID Parameter Type: %s - Value: %u\",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \"Reserved Type:%X\"), value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuinfo_tree = proto_tree_add_subtree_format(xid_tree, tvb, location, item_len,\n\t\t\t\t\tett_ui, NULL, \"XID Parameter Type: %s\",\n\t\t\t\t\tval_to_str_ext_const(tmp, &xid_param_type_str_ext, \"Reserved Type:%X\"));\n\t\t\t}\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_xl, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_type, tvb, location,\n\t\t\t\t1, byte1);\n\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len1, tvb, location,\n\t\t\t\t1, byte1);\n\n\t\t\tif (byte1 & 0x80) {\n\t\t\t\t/* length continued into byte 2 */\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_len2, tvb, location,\n\t\t\t\t\t1, byte2);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_spare, tvb, location,\n\t\t\t\t\t1, byte2);\n\n\t\t\t\t/* be sure to account for the second byte of length */\n\t\t\t\tlocation++;\n\t\t\t}\n\n\t\t\tlocation++;\n\t\t\tfor (loop_counter = 0; loop_counter < xid_param_len; loop_counter++)\n\t\t\t{\n\t\t\t\t/* grab the information in the XID param */\n\t\t\t\tbyte2 = tvb_get_guint8(tvb, location);\n\t\t\t\tproto_tree_add_uint(uinfo_tree, hf_llcgprs_xid_byte, tvb, location,\n\t\t\t\t\t1, byte2);\n\t\t\t\tlocation++;\n\t\t\t}\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,12 +3,12 @@\n \t\t\t\t\t\t\t\t proto_item *llcgprs_tree)\n \n {\n-\tguint8 xid_param_len = 0, byte1 = 0, byte2 = 0, item_len = 0, tmp = 0;\n+\tguint8 xid_param_len = 0, byte1 = 0, byte2 = 0, tmp = 0;\n \tguint16 location = 0;\n \tguint16 loop_counter = 0;\n \tproto_tree *uinfo_tree = NULL;\n \tproto_tree *xid_tree = NULL;\n-\tguint16 info_len;\n+\tguint16 info_len, item_len;\n \n \tinfo_len = tvb_reported_length(tvb);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tguint8 xid_param_len = 0, byte1 = 0, byte2 = 0, item_len = 0, tmp = 0;",
                "\tguint16 info_len;"
            ],
            "added_lines": [
                "\tguint8 xid_param_len = 0, byte1 = 0, byte2 = 0, tmp = 0;",
                "\tguint16 info_len, item_len;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11505",
        "func_name": "ImageMagick/ReadOneJNGImage",
        "description": "The ReadOneJNGImage function in coders/png.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (large loop and CPU consumption) via a malformed JNG file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/5d43fdf7a1f18f36e45225f121697d7f13c8cba9",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/526",
        "commit_text": "https://github.com/ImageMagick/ImageMagick/issues/527",
        "func_before": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n          chunk[i]=(unsigned char) ReadBlobByte(image);\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}",
        "func": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -141,7 +141,13 @@\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n \n         for (i=0; i < (ssize_t) length; i++)\n-          chunk[i]=(unsigned char) ReadBlobByte(image);\n+        {\n+          int\n+            c;\n+\n+          c=ReadBlobByte(image);\n+          chunk[i]=(unsigned char) c;\n+        }\n \n         p=chunk;\n       }",
        "diff_line_info": {
            "deleted_lines": [
                "          chunk[i]=(unsigned char) ReadBlobByte(image);"
            ],
            "added_lines": [
                "        {",
                "          int",
                "            c;",
                "",
                "          c=ReadBlobByte(image);",
                "          chunk[i]=(unsigned char) c;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12587",
        "func_name": "ImageMagick/ReadPWPImage",
        "description": "ImageMagick 7.0.6-1 has a large loop vulnerability in the ReadPWPImage function in coders\\pwp.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d4192df5eb03892089806d52a317cc3101856726",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/535",
        "commit_text": "",
        "func_before": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (EOFBlob(image) != MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      break;\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      if (c == EOF)\n        break;\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (EOFBlob(image) != MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -94,6 +94,8 @@\n     for (i=0; i < (ssize_t) filesize; i++)\n     {\n       c=ReadBlobByte(pwp_image);\n+      if (c == EOF)\n+        break;\n       (void) fputc(c,file);\n     }\n     (void) fclose(file);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if (c == EOF)",
                "        break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12674",
        "func_name": "ImageMagick/ReadPDBImage",
        "description": "In ImageMagick 7.0.6-2, a CPU exhaustion vulnerability was found in the function ReadPDBImage in coders/pdb.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/91651bd482b6637cf650700ffd7b3b63de1cb049",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/604",
        "commit_text": "",
        "func_before": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n  attributes=(unsigned char) ReadBlobByte(image);\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n      attributes=(unsigned char) ReadBlobByte(image);\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) (ReadBlobByte(image));\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07) \n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image,pixels,packets*image->rows))\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException(CorruptImageError,\"RLEDecoderError\");\n        }\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\n        \"UnrecognizedImageCompressionType\");\n    }\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes--) ReadBlobByte( image );\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MagickPathExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MagickPathExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MagickPathExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n  attributes=(unsigned char) ReadBlobByte(image);\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n      attributes=(unsigned char) ReadBlobByte(image);\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) (ReadBlobByte(image));\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07) \n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image,pixels,packets*image->rows))\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException(CorruptImageError,\"RLEDecoderError\");\n        }\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\n        \"UnrecognizedImageCompressionType\");\n    }\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes-- != 0)\n      {\n        int\n          c;\n\n        c=ReadBlobByte(image);\n        if (c == EOF)\n          break;\n      }\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MagickPathExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MagickPathExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MagickPathExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -304,7 +304,15 @@\n         length;\n \n       num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n-      while (num_pad_bytes--) ReadBlobByte( image );\n+      while (num_pad_bytes-- != 0)\n+      {\n+        int\n+          c;\n+\n+        c=ReadBlobByte(image);\n+        if (c == EOF)\n+          break;\n+      }\n \n       /*\n         Read comment.",
        "diff_line_info": {
            "deleted_lines": [
                "      while (num_pad_bytes--) ReadBlobByte( image );"
            ],
            "added_lines": [
                "      while (num_pad_bytes-- != 0)",
                "      {",
                "        int",
                "          c;",
                "",
                "        c=ReadBlobByte(image);",
                "        if (c == EOF)",
                "          break;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14054",
        "func_name": "ffmpeg/ivr_read_header",
        "description": "In libavformat/rmdec.c in FFmpeg 3.3.3, a DoS in ivr_read_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted IVR file, which claims a large \"len\" field in the header but does not contain sufficient backing data, is provided, the first type==4 loop would consume huge CPU resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/124eb202e70678539544f6268efc98131f19fa49",
        "commit_title": "avformat/rmdec: Fix DoS due to lack of eof check",
        "commit_text": " ",
        "func_before": "static int ivr_read_header(AVFormatContext *s)\n{\n    unsigned tag, type, len, tlen, value;\n    int i, j, n, count, nb_streams = 0, ret;\n    uint8_t key[256], val[256];\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int64_t pos, offset, temp;\n\n    pos = avio_tell(pb);\n    tag = avio_rl32(pb);\n    if (tag == MKTAG('.','R','1','M')) {\n        if (avio_rb16(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        avio_skip(pb, 5);\n        temp = avio_rb64(pb);\n        while (!avio_feof(pb) && temp) {\n            offset = temp;\n            temp = avio_rb64(pb);\n        }\n        avio_skip(pb, offset - avio_tell(pb));\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        if (avio_r8(pb) != 2)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 16);\n        pos = avio_tell(pb);\n        tag = avio_rl32(pb);\n    }\n\n    if (tag != MKTAG('.','R','E','C'))\n        return AVERROR_INVALIDDATA;\n\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    count = avio_rb32(pb);\n    for (i = 0; i < count; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        type = avio_r8(pb);\n        tlen = avio_rb32(pb);\n        avio_get_str(pb, tlen, key, sizeof(key));\n        len = avio_rb32(pb);\n        if (type == 5) {\n            avio_get_str(pb, len, val, sizeof(val));\n            av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n        } else if (type == 4) {\n            av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n            for (j = 0; j < len; j++)\n                av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n            av_log(s, AV_LOG_DEBUG, \"'\\n\");\n        } else if (len == 4 && type == 3 && !strncmp(key, \"StreamCount\", tlen)) {\n            nb_streams = value = avio_rb32(pb);\n        } else if (len == 4 && type == 3) {\n            value = avio_rb32(pb);\n            av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);\n        } else {\n            av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);\n            avio_skip(pb, len);\n        }\n    }\n\n    for (n = 0; n < nb_streams; n++) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->priv_data = ff_rm_alloc_rmstream();\n        if (!st->priv_data)\n            return AVERROR(ENOMEM);\n\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n\n        count = avio_rb32(pb);\n        for (i = 0; i < count; i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n\n            type = avio_r8(pb);\n            tlen  = avio_rb32(pb);\n            avio_get_str(pb, tlen, key, sizeof(key));\n            len  = avio_rb32(pb);\n            if (type == 5) {\n                avio_get_str(pb, len, val, sizeof(val));\n                av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n            } else if (type == 4 && !strncmp(key, \"OpaqueData\", tlen)) {\n                ret = ffio_ensure_seekback(pb, 4);\n                if (ret < 0)\n                    return ret;\n                if (avio_rb32(pb) == MKBETAG('M', 'L', 'T', 'I')) {\n                    ret = rm_read_multi(s, pb, st, NULL);\n                } else {\n                    avio_seek(pb, -4, SEEK_CUR);\n                    ret = ff_rm_read_mdpr_codecdata(s, pb, st, st->priv_data, len, NULL);\n                }\n\n                if (ret < 0)\n                    return ret;\n            } else if (type == 4) {\n                int j;\n\n                av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n                for (j = 0; j < len; j++)\n                    av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n                av_log(s, AV_LOG_DEBUG, \"'\\n\");\n            } else if (len == 4 && type == 3 && !strncmp(key, \"Duration\", tlen)) {\n                st->duration = avio_rb32(pb);\n            } else if (len == 4 && type == 3) {\n                value = avio_rb32(pb);\n                av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);\n            } else {\n                av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);\n                avio_skip(pb, len);\n            }\n        }\n    }\n\n    if (avio_r8(pb) != 6)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 12);\n    avio_skip(pb, avio_rb64(pb) + pos - avio_tell(s->pb));\n    if (avio_r8(pb) != 8)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 8);\n\n    return 0;\n}",
        "func": "static int ivr_read_header(AVFormatContext *s)\n{\n    unsigned tag, type, len, tlen, value;\n    int i, j, n, count, nb_streams = 0, ret;\n    uint8_t key[256], val[256];\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    int64_t pos, offset, temp;\n\n    pos = avio_tell(pb);\n    tag = avio_rl32(pb);\n    if (tag == MKTAG('.','R','1','M')) {\n        if (avio_rb16(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        avio_skip(pb, 5);\n        temp = avio_rb64(pb);\n        while (!avio_feof(pb) && temp) {\n            offset = temp;\n            temp = avio_rb64(pb);\n        }\n        avio_skip(pb, offset - avio_tell(pb));\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n        len = avio_rb32(pb);\n        avio_skip(pb, len);\n        if (avio_r8(pb) != 2)\n            return AVERROR_INVALIDDATA;\n        avio_skip(pb, 16);\n        pos = avio_tell(pb);\n        tag = avio_rl32(pb);\n    }\n\n    if (tag != MKTAG('.','R','E','C'))\n        return AVERROR_INVALIDDATA;\n\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    count = avio_rb32(pb);\n    for (i = 0; i < count; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        type = avio_r8(pb);\n        tlen = avio_rb32(pb);\n        avio_get_str(pb, tlen, key, sizeof(key));\n        len = avio_rb32(pb);\n        if (type == 5) {\n            avio_get_str(pb, len, val, sizeof(val));\n            av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n        } else if (type == 4) {\n            av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n            for (j = 0; j < len; j++) {\n                if (avio_feof(pb))\n                    return AVERROR_INVALIDDATA;\n                av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n            }\n            av_log(s, AV_LOG_DEBUG, \"'\\n\");\n        } else if (len == 4 && type == 3 && !strncmp(key, \"StreamCount\", tlen)) {\n            nb_streams = value = avio_rb32(pb);\n        } else if (len == 4 && type == 3) {\n            value = avio_rb32(pb);\n            av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);\n        } else {\n            av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);\n            avio_skip(pb, len);\n        }\n    }\n\n    for (n = 0; n < nb_streams; n++) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->priv_data = ff_rm_alloc_rmstream();\n        if (!st->priv_data)\n            return AVERROR(ENOMEM);\n\n        if (avio_r8(pb) != 1)\n            return AVERROR_INVALIDDATA;\n\n        count = avio_rb32(pb);\n        for (i = 0; i < count; i++) {\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n\n            type = avio_r8(pb);\n            tlen  = avio_rb32(pb);\n            avio_get_str(pb, tlen, key, sizeof(key));\n            len  = avio_rb32(pb);\n            if (type == 5) {\n                avio_get_str(pb, len, val, sizeof(val));\n                av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n            } else if (type == 4 && !strncmp(key, \"OpaqueData\", tlen)) {\n                ret = ffio_ensure_seekback(pb, 4);\n                if (ret < 0)\n                    return ret;\n                if (avio_rb32(pb) == MKBETAG('M', 'L', 'T', 'I')) {\n                    ret = rm_read_multi(s, pb, st, NULL);\n                } else {\n                    avio_seek(pb, -4, SEEK_CUR);\n                    ret = ff_rm_read_mdpr_codecdata(s, pb, st, st->priv_data, len, NULL);\n                }\n\n                if (ret < 0)\n                    return ret;\n            } else if (type == 4) {\n                int j;\n\n                av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n                for (j = 0; j < len; j++)\n                    av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n                av_log(s, AV_LOG_DEBUG, \"'\\n\");\n            } else if (len == 4 && type == 3 && !strncmp(key, \"Duration\", tlen)) {\n                st->duration = avio_rb32(pb);\n            } else if (len == 4 && type == 3) {\n                value = avio_rb32(pb);\n                av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);\n            } else {\n                av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);\n                avio_skip(pb, len);\n            }\n        }\n    }\n\n    if (avio_r8(pb) != 6)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 12);\n    avio_skip(pb, avio_rb64(pb) + pos - avio_tell(s->pb));\n    if (avio_r8(pb) != 8)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 8);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,8 +53,11 @@\n             av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n         } else if (type == 4) {\n             av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n-            for (j = 0; j < len; j++)\n+            for (j = 0; j < len; j++) {\n+                if (avio_feof(pb))\n+                    return AVERROR_INVALIDDATA;\n                 av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n+            }\n             av_log(s, AV_LOG_DEBUG, \"'\\n\");\n         } else if (len == 4 && type == 3 && !strncmp(key, \"StreamCount\", tlen)) {\n             nb_streams = value = avio_rb32(pb);",
        "diff_line_info": {
            "deleted_lines": [
                "            for (j = 0; j < len; j++)"
            ],
            "added_lines": [
                "            for (j = 0; j < len; j++) {",
                "                if (avio_feof(pb))",
                "                    return AVERROR_INVALIDDATA;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14055",
        "func_name": "ffmpeg/mv_read_header",
        "description": "In libavformat/mvdec.c in FFmpeg 3.3.3, a DoS in mv_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MV file, which claims a large \"nb_frames\" field in the header but does not contain sufficient backing data, is provided, the loop over the frames would consume huge CPU and memory resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/4f05e2e2dc1a89f38cd9f0960a6561083d714f1e",
        "commit_title": "avformat/mvdec: Fix DoS due to lack of eof check",
        "commit_text": " ",
        "func_before": "static int mv_read_header(AVFormatContext *avctx)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning\n    int version, i;\n    int ret;\n\n    avio_skip(pb, 4);\n\n    version = avio_rb16(pb);\n    if (version == 2) {\n        uint64_t timestamp;\n        int v;\n        avio_skip(pb, 22);\n\n        /* allocate audio track first to prevent unnecessary seeking\n         * (audio packet always precede video packet for a given frame) */\n        ast = avformat_new_stream(avctx, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n\n        vst = avformat_new_stream(avctx, NULL);\n        if (!vst)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(vst, 64, 1, 15);\n        vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        vst->avg_frame_rate    = av_inv_q(vst->time_base);\n        vst->nb_frames         = avio_rb32(pb);\n        v = avio_rb32(pb);\n        switch (v) {\n        case 1:\n            vst->codecpar->codec_id = AV_CODEC_ID_MVC1;\n            break;\n        case 2:\n            vst->codecpar->format = AV_PIX_FMT_ARGB;\n            vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n            break;\n        default:\n            avpriv_request_sample(avctx, \"Video compression %i\", v);\n            break;\n        }\n        vst->codecpar->codec_tag = 0;\n        vst->codecpar->width     = avio_rb32(pb);\n        vst->codecpar->height    = avio_rb32(pb);\n        avio_skip(pb, 12);\n\n        ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n        ast->nb_frames          = vst->nb_frames;\n        ast->codecpar->sample_rate = avio_rb32(pb);\n        if (ast->codecpar->sample_rate <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", ast->codecpar->sample_rate);\n            return AVERROR_INVALIDDATA;\n        }\n        avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);\n        if (set_channels(avctx, ast, avio_rb32(pb)) < 0)\n            return AVERROR_INVALIDDATA;\n\n        v = avio_rb32(pb);\n        if (v == AUDIO_FORMAT_SIGNED) {\n            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n            avpriv_request_sample(avctx, \"Audio compression (format %i)\", v);\n        }\n\n        avio_skip(pb, 12);\n        var_read_metadata(avctx, \"title\", 0x80);\n        var_read_metadata(avctx, \"comment\", 0x100);\n        avio_skip(pb, 0x80);\n\n        timestamp = 0;\n        for (i = 0; i < vst->nb_frames; i++) {\n            uint32_t pos   = avio_rb32(pb);\n            uint32_t asize = avio_rb32(pb);\n            uint32_t vsize = avio_rb32(pb);\n            avio_skip(pb, 8);\n            av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n            av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n            timestamp += asize / (ast->codecpar->channels * 2);\n        }\n    } else if (!version && avio_rb16(pb) == 3) {\n        avio_skip(pb, 4);\n\n        if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)\n            return ret;\n\n        if (mv->nb_audio_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple audio streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_audio_tracks) {\n            ast = avformat_new_stream(avctx, NULL);\n            if (!ast)\n                return AVERROR(ENOMEM);\n            ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            if ((read_table(avctx, ast, parse_audio_var)) < 0)\n                return ret;\n            if (mv->acompression == 100 &&\n                mv->aformat == AUDIO_FORMAT_SIGNED &&\n                ast->codecpar->bits_per_coded_sample == 16) {\n                ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else {\n                avpriv_request_sample(avctx,\n                                      \"Audio compression %i (format %i, sr %i)\",\n                                      mv->acompression, mv->aformat,\n                                      ast->codecpar->bits_per_coded_sample);\n                ast->codecpar->codec_id = AV_CODEC_ID_NONE;\n            }\n            if (ast->codecpar->channels <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"No valid channel count found.\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        if (mv->nb_video_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple video streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_video_tracks) {\n            vst = avformat_new_stream(avctx, NULL);\n            if (!vst)\n                return AVERROR(ENOMEM);\n            vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            if ((ret = read_table(avctx, vst, parse_video_var))<0)\n                return ret;\n        }\n\n        if (mv->nb_audio_tracks)\n            read_index(pb, ast);\n\n        if (mv->nb_video_tracks)\n            read_index(pb, vst);\n    } else {\n        avpriv_request_sample(avctx, \"Version %i\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}",
        "func": "static int mv_read_header(AVFormatContext *avctx)\n{\n    MvContext *mv = avctx->priv_data;\n    AVIOContext *pb = avctx->pb;\n    AVStream *ast = NULL, *vst = NULL; //initialization to suppress warning\n    int version, i;\n    int ret;\n\n    avio_skip(pb, 4);\n\n    version = avio_rb16(pb);\n    if (version == 2) {\n        uint64_t timestamp;\n        int v;\n        avio_skip(pb, 22);\n\n        /* allocate audio track first to prevent unnecessary seeking\n         * (audio packet always precede video packet for a given frame) */\n        ast = avformat_new_stream(avctx, NULL);\n        if (!ast)\n            return AVERROR(ENOMEM);\n\n        vst = avformat_new_stream(avctx, NULL);\n        if (!vst)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(vst, 64, 1, 15);\n        vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        vst->avg_frame_rate    = av_inv_q(vst->time_base);\n        vst->nb_frames         = avio_rb32(pb);\n        v = avio_rb32(pb);\n        switch (v) {\n        case 1:\n            vst->codecpar->codec_id = AV_CODEC_ID_MVC1;\n            break;\n        case 2:\n            vst->codecpar->format = AV_PIX_FMT_ARGB;\n            vst->codecpar->codec_id = AV_CODEC_ID_RAWVIDEO;\n            break;\n        default:\n            avpriv_request_sample(avctx, \"Video compression %i\", v);\n            break;\n        }\n        vst->codecpar->codec_tag = 0;\n        vst->codecpar->width     = avio_rb32(pb);\n        vst->codecpar->height    = avio_rb32(pb);\n        avio_skip(pb, 12);\n\n        ast->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n        ast->nb_frames          = vst->nb_frames;\n        ast->codecpar->sample_rate = avio_rb32(pb);\n        if (ast->codecpar->sample_rate <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", ast->codecpar->sample_rate);\n            return AVERROR_INVALIDDATA;\n        }\n        avpriv_set_pts_info(ast, 33, 1, ast->codecpar->sample_rate);\n        if (set_channels(avctx, ast, avio_rb32(pb)) < 0)\n            return AVERROR_INVALIDDATA;\n\n        v = avio_rb32(pb);\n        if (v == AUDIO_FORMAT_SIGNED) {\n            ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        } else {\n            avpriv_request_sample(avctx, \"Audio compression (format %i)\", v);\n        }\n\n        avio_skip(pb, 12);\n        var_read_metadata(avctx, \"title\", 0x80);\n        var_read_metadata(avctx, \"comment\", 0x100);\n        avio_skip(pb, 0x80);\n\n        timestamp = 0;\n        for (i = 0; i < vst->nb_frames; i++) {\n            uint32_t pos   = avio_rb32(pb);\n            uint32_t asize = avio_rb32(pb);\n            uint32_t vsize = avio_rb32(pb);\n            if (avio_feof(pb))\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 8);\n            av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n            av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n            timestamp += asize / (ast->codecpar->channels * 2);\n        }\n    } else if (!version && avio_rb16(pb) == 3) {\n        avio_skip(pb, 4);\n\n        if ((ret = read_table(avctx, NULL, parse_global_var)) < 0)\n            return ret;\n\n        if (mv->nb_audio_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple audio streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_audio_tracks) {\n            ast = avformat_new_stream(avctx, NULL);\n            if (!ast)\n                return AVERROR(ENOMEM);\n            ast->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n            if ((read_table(avctx, ast, parse_audio_var)) < 0)\n                return ret;\n            if (mv->acompression == 100 &&\n                mv->aformat == AUDIO_FORMAT_SIGNED &&\n                ast->codecpar->bits_per_coded_sample == 16) {\n                ast->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n            } else {\n                avpriv_request_sample(avctx,\n                                      \"Audio compression %i (format %i, sr %i)\",\n                                      mv->acompression, mv->aformat,\n                                      ast->codecpar->bits_per_coded_sample);\n                ast->codecpar->codec_id = AV_CODEC_ID_NONE;\n            }\n            if (ast->codecpar->channels <= 0) {\n                av_log(avctx, AV_LOG_ERROR, \"No valid channel count found.\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        if (mv->nb_video_tracks > 1) {\n            avpriv_request_sample(avctx, \"Multiple video streams support\");\n            return AVERROR_PATCHWELCOME;\n        } else if (mv->nb_video_tracks) {\n            vst = avformat_new_stream(avctx, NULL);\n            if (!vst)\n                return AVERROR(ENOMEM);\n            vst->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            if ((ret = read_table(avctx, vst, parse_video_var))<0)\n                return ret;\n        }\n\n        if (mv->nb_audio_tracks)\n            read_index(pb, ast);\n\n        if (mv->nb_video_tracks)\n            read_index(pb, vst);\n    } else {\n        avpriv_request_sample(avctx, \"Version %i\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,6 +73,8 @@\n             uint32_t pos   = avio_rb32(pb);\n             uint32_t asize = avio_rb32(pb);\n             uint32_t vsize = avio_rb32(pb);\n+            if (avio_feof(pb))\n+                return AVERROR_INVALIDDATA;\n             avio_skip(pb, 8);\n             av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n             av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            if (avio_feof(pb))",
                "                return AVERROR_INVALIDDATA;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14056",
        "func_name": "ffmpeg/rl2_read_header",
        "description": "In libavformat/rl2.c in FFmpeg 3.3.3, a DoS in rl2_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted RL2 file, which claims a large \"frame_count\" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de",
        "commit_title": "avformat/rl2: Fix DoS due to lack of eof check",
        "commit_text": " ",
        "func_before": "static av_cold int rl2_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    unsigned int frame_count;\n    unsigned int audio_frame_counter = 0;\n    unsigned int video_frame_counter = 0;\n    unsigned int back_size;\n    unsigned short sound_rate;\n    unsigned short rate;\n    unsigned short channels;\n    unsigned short def_sound_size;\n    unsigned int signature;\n    unsigned int pts_den = 11025; /* video only case */\n    unsigned int pts_num = 1103;\n    unsigned int* chunk_offset = NULL;\n    int* chunk_size = NULL;\n    int* audio_size = NULL;\n    int i;\n    int ret = 0;\n\n    avio_skip(pb,4);          /* skip FORM tag */\n    back_size = avio_rl32(pb); /**< get size of the background frame */\n    signature = avio_rb32(pb);\n    avio_skip(pb, 4);         /* data size */\n    frame_count = avio_rl32(pb);\n\n    /* disallow back_sizes and frame_counts that may lead to overflows later */\n    if(back_size > INT_MAX/2  || frame_count > INT_MAX / sizeof(uint32_t))\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 2);         /* encoding method */\n    sound_rate = avio_rl16(pb);\n    rate = avio_rl16(pb);\n    channels = avio_rl16(pb);\n    def_sound_size = avio_rl16(pb);\n\n    /** setup video stream */\n    st = avformat_new_stream(s, NULL);\n    if(!st)\n         return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id = AV_CODEC_ID_RL2;\n    st->codecpar->codec_tag = 0;  /* no fourcc */\n    st->codecpar->width = 320;\n    st->codecpar->height = 200;\n\n    /** allocate and fill extradata */\n    st->codecpar->extradata_size = EXTRADATA1_SIZE;\n\n    if(signature == RLV3_TAG && back_size > 0)\n        st->codecpar->extradata_size += back_size;\n\n    if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)\n        return AVERROR(ENOMEM);\n\n    /** setup audio stream if present */\n    if(sound_rate){\n        if (!channels || channels > 42) {\n            av_log(s, AV_LOG_ERROR, \"Invalid number of channels: %d\\n\", channels);\n            return AVERROR_INVALIDDATA;\n        }\n\n        pts_num = def_sound_size;\n        pts_den = rate;\n\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n        st->codecpar->codec_tag = 1;\n        st->codecpar->channels = channels;\n        st->codecpar->bits_per_coded_sample = 8;\n        st->codecpar->sample_rate = rate;\n        st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n            st->codecpar->bits_per_coded_sample;\n        st->codecpar->block_align = st->codecpar->channels *\n            st->codecpar->bits_per_coded_sample / 8;\n        avpriv_set_pts_info(st,32,1,rate);\n    }\n\n    avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den);\n\n    chunk_size =   av_malloc(frame_count * sizeof(uint32_t));\n    audio_size =   av_malloc(frame_count * sizeof(uint32_t));\n    chunk_offset = av_malloc(frame_count * sizeof(uint32_t));\n\n    if(!chunk_size || !audio_size || !chunk_offset){\n        av_free(chunk_size);\n        av_free(audio_size);\n        av_free(chunk_offset);\n        return AVERROR(ENOMEM);\n    }\n\n    /** read offset and size tables */\n    for(i=0; i < frame_count;i++)\n        chunk_size[i] = avio_rl32(pb);\n    for(i=0; i < frame_count;i++)\n        chunk_offset[i] = avio_rl32(pb);\n    for(i=0; i < frame_count;i++)\n        audio_size[i] = avio_rl32(pb) & 0xFFFF;\n\n    /** build the sample index */\n    for(i=0;i<frame_count;i++){\n        if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){\n            ret = AVERROR_INVALIDDATA;\n            break;\n        }\n\n        if(sound_rate && audio_size[i]){\n            av_add_index_entry(s->streams[1], chunk_offset[i],\n                audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME);\n            audio_frame_counter += audio_size[i] / channels;\n        }\n        av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i],\n            video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME);\n        ++video_frame_counter;\n    }\n\n\n    av_free(chunk_size);\n    av_free(audio_size);\n    av_free(chunk_offset);\n\n    return ret;\n}",
        "func": "static av_cold int rl2_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    unsigned int frame_count;\n    unsigned int audio_frame_counter = 0;\n    unsigned int video_frame_counter = 0;\n    unsigned int back_size;\n    unsigned short sound_rate;\n    unsigned short rate;\n    unsigned short channels;\n    unsigned short def_sound_size;\n    unsigned int signature;\n    unsigned int pts_den = 11025; /* video only case */\n    unsigned int pts_num = 1103;\n    unsigned int* chunk_offset = NULL;\n    int* chunk_size = NULL;\n    int* audio_size = NULL;\n    int i;\n    int ret = 0;\n\n    avio_skip(pb,4);          /* skip FORM tag */\n    back_size = avio_rl32(pb); /**< get size of the background frame */\n    signature = avio_rb32(pb);\n    avio_skip(pb, 4);         /* data size */\n    frame_count = avio_rl32(pb);\n\n    /* disallow back_sizes and frame_counts that may lead to overflows later */\n    if(back_size > INT_MAX/2  || frame_count > INT_MAX / sizeof(uint32_t))\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 2);         /* encoding method */\n    sound_rate = avio_rl16(pb);\n    rate = avio_rl16(pb);\n    channels = avio_rl16(pb);\n    def_sound_size = avio_rl16(pb);\n\n    /** setup video stream */\n    st = avformat_new_stream(s, NULL);\n    if(!st)\n         return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id = AV_CODEC_ID_RL2;\n    st->codecpar->codec_tag = 0;  /* no fourcc */\n    st->codecpar->width = 320;\n    st->codecpar->height = 200;\n\n    /** allocate and fill extradata */\n    st->codecpar->extradata_size = EXTRADATA1_SIZE;\n\n    if(signature == RLV3_TAG && back_size > 0)\n        st->codecpar->extradata_size += back_size;\n\n    if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)\n        return AVERROR(ENOMEM);\n\n    /** setup audio stream if present */\n    if(sound_rate){\n        if (!channels || channels > 42) {\n            av_log(s, AV_LOG_ERROR, \"Invalid number of channels: %d\\n\", channels);\n            return AVERROR_INVALIDDATA;\n        }\n\n        pts_num = def_sound_size;\n        pts_den = rate;\n\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n        st->codecpar->codec_tag = 1;\n        st->codecpar->channels = channels;\n        st->codecpar->bits_per_coded_sample = 8;\n        st->codecpar->sample_rate = rate;\n        st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n            st->codecpar->bits_per_coded_sample;\n        st->codecpar->block_align = st->codecpar->channels *\n            st->codecpar->bits_per_coded_sample / 8;\n        avpriv_set_pts_info(st,32,1,rate);\n    }\n\n    avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den);\n\n    chunk_size =   av_malloc(frame_count * sizeof(uint32_t));\n    audio_size =   av_malloc(frame_count * sizeof(uint32_t));\n    chunk_offset = av_malloc(frame_count * sizeof(uint32_t));\n\n    if(!chunk_size || !audio_size || !chunk_offset){\n        av_free(chunk_size);\n        av_free(audio_size);\n        av_free(chunk_offset);\n        return AVERROR(ENOMEM);\n    }\n\n    /** read offset and size tables */\n    for(i=0; i < frame_count;i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        chunk_size[i] = avio_rl32(pb);\n    }\n    for(i=0; i < frame_count;i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        chunk_offset[i] = avio_rl32(pb);\n    }\n    for(i=0; i < frame_count;i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        audio_size[i] = avio_rl32(pb) & 0xFFFF;\n    }\n\n    /** build the sample index */\n    for(i=0;i<frame_count;i++){\n        if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){\n            ret = AVERROR_INVALIDDATA;\n            break;\n        }\n\n        if(sound_rate && audio_size[i]){\n            av_add_index_entry(s->streams[1], chunk_offset[i],\n                audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME);\n            audio_frame_counter += audio_size[i] / channels;\n        }\n        av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i],\n            video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME);\n        ++video_frame_counter;\n    }\n\n\n    av_free(chunk_size);\n    av_free(audio_size);\n    av_free(chunk_offset);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -95,12 +95,21 @@\n     }\n \n     /** read offset and size tables */\n-    for(i=0; i < frame_count;i++)\n+    for(i=0; i < frame_count;i++) {\n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n         chunk_size[i] = avio_rl32(pb);\n-    for(i=0; i < frame_count;i++)\n+    }\n+    for(i=0; i < frame_count;i++) {\n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n         chunk_offset[i] = avio_rl32(pb);\n-    for(i=0; i < frame_count;i++)\n+    }\n+    for(i=0; i < frame_count;i++) {\n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n         audio_size[i] = avio_rl32(pb) & 0xFFFF;\n+    }\n \n     /** build the sample index */\n     for(i=0;i<frame_count;i++){",
        "diff_line_info": {
            "deleted_lines": [
                "    for(i=0; i < frame_count;i++)",
                "    for(i=0; i < frame_count;i++)",
                "    for(i=0; i < frame_count;i++)"
            ],
            "added_lines": [
                "    for(i=0; i < frame_count;i++) {",
                "        if (avio_feof(pb))",
                "            return AVERROR_INVALIDDATA;",
                "    }",
                "    for(i=0; i < frame_count;i++) {",
                "        if (avio_feof(pb))",
                "            return AVERROR_INVALIDDATA;",
                "    }",
                "    for(i=0; i < frame_count;i++) {",
                "        if (avio_feof(pb))",
                "            return AVERROR_INVALIDDATA;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14057",
        "func_name": "ffmpeg/asf_read_marker",
        "description": "In FFmpeg 3.3.3, a DoS in asf_read_marker() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted ASF file, which claims a large \"name_len\" or \"count\" field in the header but does not contain sufficient backing data, is provided, the loops over the name and markers would consume huge CPU and memory resources, since there is no EOF check inside these loops.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/7f9ec5593e04827249e7aeb466da06a98a0d7329",
        "commit_title": "avformat/asfdec: Fix DoS due to lack of eof check",
        "commit_text": " ",
        "func_before": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); // skip the name\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}",
        "func": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    avio_skip(pb, name_len);\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,12 +10,14 @@\n     count = avio_rl32(pb);    // markers count\n     avio_rl16(pb);            // reserved 2 bytes\n     name_len = avio_rl16(pb); // name length\n-    for (i = 0; i < name_len; i++)\n-        avio_r8(pb); // skip the name\n+    avio_skip(pb, name_len);\n \n     for (i = 0; i < count; i++) {\n         int64_t pres_time;\n         int name_len;\n+\n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n \n         avio_rl64(pb);             // offset, 8 bytes\n         pres_time = avio_rl64(pb); // presentation time",
        "diff_line_info": {
            "deleted_lines": [
                "    for (i = 0; i < name_len; i++)",
                "        avio_r8(pb); // skip the name"
            ],
            "added_lines": [
                "    avio_skip(pb, name_len);",
                "",
                "        if (avio_feof(pb))",
                "            return AVERROR_INVALIDDATA;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14059",
        "func_name": "ffmpeg/cine_read_header",
        "description": "In FFmpeg 3.3.3, a DoS in cine_read_header() due to lack of an EOF check might cause huge CPU and memory consumption. When a crafted CINE file, which claims a large \"duration\" field in the header but does not contain sufficient backing data, is provided, the image-offset parsing loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/7e80b63ecd259d69d383623e75b318bf2bd491f6",
        "commit_title": "avformat/cinedec: Fix DoS due to lack of eof check",
        "commit_text": " ",
        "func_before": "static int cine_read_header(AVFormatContext *avctx)\n{\n    AVIOContext *pb = avctx->pb;\n    AVStream *st;\n    unsigned int version, compression, offImageHeader, offSetup, offImageOffsets, biBitCount, length, CFA;\n    int vflip;\n    char *description;\n    uint64_t i;\n\n    st = avformat_new_stream(avctx, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_RAWVIDEO;\n    st->codecpar->codec_tag  = 0;\n\n    /* CINEFILEHEADER structure */\n    avio_skip(pb, 4); // Type, Headersize\n\n    compression = avio_rl16(pb);\n    version     = avio_rl16(pb);\n    if (version != 1) {\n        avpriv_request_sample(avctx, \"unknown version %i\", version);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 12); // FirstMovieImage, TotalImageCount, FirstImageNumber\n\n    st->duration    = avio_rl32(pb);\n    offImageHeader  = avio_rl32(pb);\n    offSetup        = avio_rl32(pb);\n    offImageOffsets = avio_rl32(pb);\n\n    avio_skip(pb, 8); // TriggerTime\n\n    /* BITMAPINFOHEADER structure */\n    avio_seek(pb, offImageHeader, SEEK_SET);\n    avio_skip(pb, 4); //biSize\n    st->codecpar->width      = avio_rl32(pb);\n    st->codecpar->height     = avio_rl32(pb);\n\n    if (avio_rl16(pb) != 1) // biPlanes\n        return AVERROR_INVALIDDATA;\n\n    biBitCount = avio_rl16(pb);\n    if (biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48) {\n        avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (avio_rl32(pb)) {\n    case BMP_RGB:\n        vflip = 0;\n        break;\n    case 0x100: /* BI_PACKED */\n        st->codecpar->codec_tag = MKTAG('B', 'I', 'T', 0);\n        vflip = 1;\n        break;\n    default:\n        avpriv_request_sample(avctx, \"unknown bitmap compression\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // biSizeImage\n\n    /* parse SETUP structure */\n    avio_seek(pb, offSetup, SEEK_SET);\n    avio_skip(pb, 140); // FrameRatae16 .. descriptionOld\n    if (avio_rl16(pb) != 0x5453)\n        return AVERROR_INVALIDDATA;\n    length = avio_rl16(pb);\n    if (length < 0x163C) {\n        avpriv_request_sample(avctx, \"short SETUP header\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 616); // Binning .. bFlipH\n    if (!avio_rl32(pb) ^ vflip) {\n        st->codecpar->extradata  = av_strdup(\"BottomUp\");\n        st->codecpar->extradata_size  = 9;\n    }\n\n    avio_skip(pb, 4); // Grid\n\n    avpriv_set_pts_info(st, 64, 1, avio_rl32(pb));\n\n    avio_skip(pb, 20); // Shutter .. bEnableColor\n\n    set_metadata_int(&st->metadata, \"camera_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"firmware_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"software_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"recording_timezone\", avio_rl32(pb), 0);\n\n    CFA = avio_rl32(pb);\n\n    set_metadata_int(&st->metadata, \"brightness\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"contrast\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"gamma\", avio_rl32(pb), 1);\n\n    avio_skip(pb, 12 + 16); // Reserved1 .. AutoExpRect\n    set_metadata_float(&st->metadata, \"wbgain[0].r\", av_int2float(avio_rl32(pb)), 1);\n    set_metadata_float(&st->metadata, \"wbgain[0].b\", av_int2float(avio_rl32(pb)), 1);\n    avio_skip(pb, 36); // WBGain[1].. WBView\n\n    st->codecpar->bits_per_coded_sample = avio_rl32(pb);\n\n    if (compression == CC_RGB) {\n        if (biBitCount == 8) {\n            st->codecpar->format = AV_PIX_FMT_GRAY8;\n        } else if (biBitCount == 16) {\n            st->codecpar->format = AV_PIX_FMT_GRAY16LE;\n        } else if (biBitCount == 24) {\n            st->codecpar->format = AV_PIX_FMT_BGR24;\n        } else if (biBitCount == 48) {\n            st->codecpar->format = AV_PIX_FMT_BGR48LE;\n        } else {\n            avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (compression == CC_UNINT) {\n        switch (CFA & 0xFFFFFF) {\n        case CFA_BAYER:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG16LE;\n            } else {\n                avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        case CFA_BAYERFLIP:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB16LE;\n            } else {\n                avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        default:\n           avpriv_request_sample(avctx, \"unsupported Color Field Array (CFA) %i\", CFA & 0xFFFFFF);\n            return AVERROR_INVALIDDATA;\n        }\n    } else { //CC_LEAD\n        avpriv_request_sample(avctx, \"unsupported compression %i\", compression);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 668); // Conv8Min ... Sensor\n\n    set_metadata_int(&st->metadata, \"shutter_ns\", avio_rl32(pb), 0);\n\n    avio_skip(pb, 24); // EDRShutterNs ... ImHeightAcq\n\n#define DESCRIPTION_SIZE 4096\n    description = av_malloc(DESCRIPTION_SIZE + 1);\n    if (!description)\n        return AVERROR(ENOMEM);\n    i = avio_get_str(pb, DESCRIPTION_SIZE, description, DESCRIPTION_SIZE + 1);\n    if (i < DESCRIPTION_SIZE)\n        avio_skip(pb, DESCRIPTION_SIZE - i);\n    if (description[0])\n        av_dict_set(&st->metadata, \"description\", description, AV_DICT_DONT_STRDUP_VAL);\n    else\n        av_free(description);\n\n    avio_skip(pb, 1176); // RisingEdge ... cmUser\n\n    set_metadata_int(&st->metadata, \"enable_crop\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_left\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_top\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_right\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_bottom\", avio_rl32(pb), 1);\n\n    /* parse image offsets */\n    avio_seek(pb, offImageOffsets, SEEK_SET);\n    for (i = 0; i < st->duration; i++)\n        av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);\n\n    return 0;\n}",
        "func": "static int cine_read_header(AVFormatContext *avctx)\n{\n    AVIOContext *pb = avctx->pb;\n    AVStream *st;\n    unsigned int version, compression, offImageHeader, offSetup, offImageOffsets, biBitCount, length, CFA;\n    int vflip;\n    char *description;\n    uint64_t i;\n\n    st = avformat_new_stream(avctx, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_RAWVIDEO;\n    st->codecpar->codec_tag  = 0;\n\n    /* CINEFILEHEADER structure */\n    avio_skip(pb, 4); // Type, Headersize\n\n    compression = avio_rl16(pb);\n    version     = avio_rl16(pb);\n    if (version != 1) {\n        avpriv_request_sample(avctx, \"unknown version %i\", version);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 12); // FirstMovieImage, TotalImageCount, FirstImageNumber\n\n    st->duration    = avio_rl32(pb);\n    offImageHeader  = avio_rl32(pb);\n    offSetup        = avio_rl32(pb);\n    offImageOffsets = avio_rl32(pb);\n\n    avio_skip(pb, 8); // TriggerTime\n\n    /* BITMAPINFOHEADER structure */\n    avio_seek(pb, offImageHeader, SEEK_SET);\n    avio_skip(pb, 4); //biSize\n    st->codecpar->width      = avio_rl32(pb);\n    st->codecpar->height     = avio_rl32(pb);\n\n    if (avio_rl16(pb) != 1) // biPlanes\n        return AVERROR_INVALIDDATA;\n\n    biBitCount = avio_rl16(pb);\n    if (biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48) {\n        avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (avio_rl32(pb)) {\n    case BMP_RGB:\n        vflip = 0;\n        break;\n    case 0x100: /* BI_PACKED */\n        st->codecpar->codec_tag = MKTAG('B', 'I', 'T', 0);\n        vflip = 1;\n        break;\n    default:\n        avpriv_request_sample(avctx, \"unknown bitmap compression\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // biSizeImage\n\n    /* parse SETUP structure */\n    avio_seek(pb, offSetup, SEEK_SET);\n    avio_skip(pb, 140); // FrameRatae16 .. descriptionOld\n    if (avio_rl16(pb) != 0x5453)\n        return AVERROR_INVALIDDATA;\n    length = avio_rl16(pb);\n    if (length < 0x163C) {\n        avpriv_request_sample(avctx, \"short SETUP header\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 616); // Binning .. bFlipH\n    if (!avio_rl32(pb) ^ vflip) {\n        st->codecpar->extradata  = av_strdup(\"BottomUp\");\n        st->codecpar->extradata_size  = 9;\n    }\n\n    avio_skip(pb, 4); // Grid\n\n    avpriv_set_pts_info(st, 64, 1, avio_rl32(pb));\n\n    avio_skip(pb, 20); // Shutter .. bEnableColor\n\n    set_metadata_int(&st->metadata, \"camera_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"firmware_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"software_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"recording_timezone\", avio_rl32(pb), 0);\n\n    CFA = avio_rl32(pb);\n\n    set_metadata_int(&st->metadata, \"brightness\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"contrast\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"gamma\", avio_rl32(pb), 1);\n\n    avio_skip(pb, 12 + 16); // Reserved1 .. AutoExpRect\n    set_metadata_float(&st->metadata, \"wbgain[0].r\", av_int2float(avio_rl32(pb)), 1);\n    set_metadata_float(&st->metadata, \"wbgain[0].b\", av_int2float(avio_rl32(pb)), 1);\n    avio_skip(pb, 36); // WBGain[1].. WBView\n\n    st->codecpar->bits_per_coded_sample = avio_rl32(pb);\n\n    if (compression == CC_RGB) {\n        if (biBitCount == 8) {\n            st->codecpar->format = AV_PIX_FMT_GRAY8;\n        } else if (biBitCount == 16) {\n            st->codecpar->format = AV_PIX_FMT_GRAY16LE;\n        } else if (biBitCount == 24) {\n            st->codecpar->format = AV_PIX_FMT_BGR24;\n        } else if (biBitCount == 48) {\n            st->codecpar->format = AV_PIX_FMT_BGR48LE;\n        } else {\n            avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (compression == CC_UNINT) {\n        switch (CFA & 0xFFFFFF) {\n        case CFA_BAYER:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG16LE;\n            } else {\n                avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        case CFA_BAYERFLIP:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB16LE;\n            } else {\n                avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        default:\n           avpriv_request_sample(avctx, \"unsupported Color Field Array (CFA) %i\", CFA & 0xFFFFFF);\n            return AVERROR_INVALIDDATA;\n        }\n    } else { //CC_LEAD\n        avpriv_request_sample(avctx, \"unsupported compression %i\", compression);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 668); // Conv8Min ... Sensor\n\n    set_metadata_int(&st->metadata, \"shutter_ns\", avio_rl32(pb), 0);\n\n    avio_skip(pb, 24); // EDRShutterNs ... ImHeightAcq\n\n#define DESCRIPTION_SIZE 4096\n    description = av_malloc(DESCRIPTION_SIZE + 1);\n    if (!description)\n        return AVERROR(ENOMEM);\n    i = avio_get_str(pb, DESCRIPTION_SIZE, description, DESCRIPTION_SIZE + 1);\n    if (i < DESCRIPTION_SIZE)\n        avio_skip(pb, DESCRIPTION_SIZE - i);\n    if (description[0])\n        av_dict_set(&st->metadata, \"description\", description, AV_DICT_DONT_STRDUP_VAL);\n    else\n        av_free(description);\n\n    avio_skip(pb, 1176); // RisingEdge ... cmUser\n\n    set_metadata_int(&st->metadata, \"enable_crop\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_left\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_top\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_right\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_bottom\", avio_rl32(pb), 1);\n\n    /* parse image offsets */\n    avio_seek(pb, offImageOffsets, SEEK_SET);\n    for (i = 0; i < st->duration; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -176,8 +176,12 @@\n \n     /* parse image offsets */\n     avio_seek(pb, offImageOffsets, SEEK_SET);\n-    for (i = 0; i < st->duration; i++)\n+    for (i = 0; i < st->duration; i++) {\n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n+\n         av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);\n+    }\n \n     return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    for (i = 0; i < st->duration; i++)"
            ],
            "added_lines": [
                "    for (i = 0; i < st->duration; i++) {",
                "        if (avio_feof(pb))",
                "            return AVERROR_INVALIDDATA;",
                "",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39923",
        "func_name": "wireshark/dissect_pnrp",
        "description": "Large loop in the PNRP dissector in Wireshark 3.4.0 to 3.4.9 and 3.2.0 to 3.2.17 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/9104a3744e63b54b2cff3152aedeea340976355b",
        "commit_title": "PNRP: Exit our main loop.",
        "commit_text": " Make sure our main loop offset advances. Fixes #17684. ",
        "func_before": "static int dissect_pnrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    /* Variable declaration */\n    gint offset;\n    gint padding_bytes;\n    guint8 message_type;\n    guint16 field_type;\n    guint16 data_length;\n    proto_item *ti;\n    proto_tree *pnrp_tree;\n    proto_item *pnrp_header_item;\n    proto_tree *pnrp_header_tree;\n    proto_item *pnrp_message_tree = NULL;\n    guint32 msg_id;\n\n    /*----------------------------------------\n     * Validate if it is really a PNRP Packet\n     *----------------------------------------*/\n    /* Check that there's enough data */\n    data_length = tvb_captured_length(tvb);\n\n    /* Shortest Message is ACK -> 12 Bytes for Header plus 8 Bytes for Data */\n    if (data_length <  12+8 )\n    {\n        return 0;\n    }\n\n    /* Check some values from the packet header */\n    /* First 2 bytes must be 0x0010 */\n    if (tvb_get_ntohs(tvb,0) != PNRP_HEADER )\n    {\n        return 0;\n    }\n    /* Length of Header must be 0x000C = 12 */\n    if (tvb_get_ntohs(tvb,2) != 0x000C) {\n        return 0;\n    }\n    /* Identifier must 0x51 */\n    if (tvb_get_guint8(tvb,4) != 0x51) {\n        return 0;\n    }\n\n\n    /* Assign Values to Variables */\n    /* Use to track data */\n    offset= 0;\n    /* Get the message Information beforehand */\n    message_type = tvb_get_guint8(tvb,7);\n\n\n    /* Simply Display the Protocol Name in the INFO column */\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"PNRP\");\n    /* Clear out stuff in the info column */\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"PNRP %s Message \",\n                 val_to_str(message_type, messageType, \"Unknown (0x%02x)\"));\n\n\n    /* Lets add a subtree to our dissection to display the info */\n    ti = proto_tree_add_item(tree, proto_pnrp, tvb, 0, -1, ENC_NA);\n    proto_item_append_text(ti, \", Message Type %s\",\n                           val_to_str(message_type, messageType, \"Unknown (0x%02x)\"));\n    /* Get a main tree for the whole protocol */\n    pnrp_tree = proto_item_add_subtree(ti, ett_pnrp);\n\n    /*-------------------------------\n     *--Add all Header Fields\n     *------------------------------*/\n    /* Get a subtree for the Header */\n    pnrp_header_item = proto_tree_add_item(pnrp_tree, hf_pnrp_header, tvb, offset,12,ENC_NA);\n    pnrp_header_tree = proto_item_add_subtree(pnrp_header_item, ett_pnrp_header);\n\n    /* Add Field ID should be 0c0010 */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_fieldID,tvb,offset,2,ENC_BIG_ENDIAN);\n    offset += 2;\n    /* Add Length should be 0x000C */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_length,tvb,offset,2,ENC_BIG_ENDIAN);\n    offset += 2;\n    /* Add Ident should be 0x51 */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_ident,tvb,offset,1,ENC_BIG_ENDIAN);\n    offset += 1;\n    /* Add Major Version */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_versionMajor,tvb,offset,1,ENC_BIG_ENDIAN);\n    offset += 1;\n    /* Add Minor Version */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_versionMinor,tvb,offset,1,ENC_BIG_ENDIAN);\n    offset += 1;\n    /* Add Message Type */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_messageType,tvb,offset,1,ENC_BIG_ENDIAN);\n    offset += 1;\n    /* Add Message ID */\n    proto_tree_add_item_ret_uint(pnrp_header_tree,hf_pnrp_header_messageID,tvb,offset,4,ENC_BIG_ENDIAN,&msg_id);\n    offset += 4;\n\n\n    /*-------------------------------\n     *--Add all Message Fields\n     *------------------------------*/\n\n    /* The following part has dynamic length depending on message type */\n    while (tvb_reported_length_remaining(tvb, offset) > 0) {\n        /* Determine the Field Type */\n        field_type = tvb_get_ntohs(tvb,offset );\n        /* Determine length of this message */\n        data_length = tvb_get_ntohs(tvb,offset + 2);\n\n        /* Length must be at least 4, because field_type and data_length are part of data_length information */\n        if (data_length < 4) {\n            if (tree) {\n                pnrp_message_tree = proto_tree_add_subtree_format(pnrp_tree, tvb, offset, 4, ett_pnrp_message, NULL,\n                                    \"Message with invalid length %u (< 4)\", data_length);\n                proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n                proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n            }\n            offset += 4;\n            /* Don't continue parsing this message segment */\n            break;\n        }\n        /* Actual Parsing of the message Type */\n        switch (field_type) {\n            /* First Field in ACK Message */\n            case PNRP_HEADER_ACKED:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                    data_length, ett_pnrp_message, NULL, \"Message ACK ID: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_headerack, tvb, offset + 4, data_length -4, ENC_BIG_ENDIAN);\n\n                }\n                offset += data_length;\n                break;\n\n                /* A validate pnrp id follows as found in FLOOD */\n            case VALIDATE_PNRP_ID:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Validate PNRP ID: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* We can have a large number of pnrp IDs here */\n                    dissect_pnrp_ids(tvb,offset+4,data_length-4,pnrp_message_tree);\n\n                }\n                offset += data_length;\n                break;\n\n                /* The Flags have different meaning, depending on the message */\n            case FLAGS_FIELD:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Flags Field: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                }\n                switch (message_type) {\n                    case INQUIRE:\n                        proto_tree_add_bitmask(pnrp_message_tree, tvb, offset+4, hf_pnrp_message_inquire_flags, ett_pnrp_message_inquire_flags, inquire_flags, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + 6, 2, ENC_NA);\n                        offset += data_length+2;\n\n                        break;\n\n                    case ACK:\n                        /* Reserved 0 - 14 bits */\n                        proto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_ack_flags_reserved, tvb, (offset + 4)*8, 15, ENC_BIG_ENDIAN);\n                        /* N - Bit */\n                        proto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_ack_flags_Nbit, tvb,((offset + 4)*8)+15, 1, ENC_BIG_ENDIAN);\n                        offset += data_length;\n                        break;\n                    case AUTHORITY:\n                        proto_tree_add_bitmask(pnrp_message_tree, tvb, offset+4, hf_pnrp_message_authority_flags, ett_pnrp_message_authority_flags, authority_flags, ENC_BIG_ENDIAN);\n                        /* Check if the Flags Field is the last message part. If so, no padding of 2 bytes is added */\n                        if(tvb_reported_length_remaining(tvb, offset+data_length)==0)\n                        {\n                            offset += data_length;\n                        }\n                        else {\n                            padding_bytes = 2;\n                            proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + 6, padding_bytes, ENC_NA);\n                            offset += data_length+2;\n                        }\n                        break;\n\n\n                    default:\n                        proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_flags, tvb, offset + 4, data_length -4, ENC_BIG_ENDIAN);\n                        offset += data_length;\n                        break;\n                }\n                break;\n\n                /* Flood controls found in FLOOD Message */\n            case FLOOD_CONTROLS:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Flood Control: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* Reserved 1 - 15 bits */\n                    proto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_flood_flags_reserved1, tvb, (offset + 4)*8, 15, ENC_BIG_ENDIAN);\n                    /* D - Bit */\n                    proto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_flood_flags_Dbit, tvb,((offset + 4)*8)+15, 1, ENC_BIG_ENDIAN);\n                    /* Reserved 2 */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved8, tvb, offset + 6, 1, ENC_NA);\n                    /* Padding 1 */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + 7, 1, ENC_NA);\n                }\n\n                offset += data_length+1;\n                break;\n\n                /* Solicit Controls found in SOLICIT Message */\n            case SOLICIT_CONTROLS:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Solicit Controls: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved8, tvb, offset + 4, 1, ENC_NA);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_solicitType, tvb, offset + 5, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved16, tvb, offset + 6, 2, ENC_LITTLE_ENDIAN);\n                }\n                offset += data_length +2;   /* Padding involved */\n                break;\n                /* Lookup controls found in LOOKUP Message */\n            case LOOKUP_CONTROLS:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Lookup Control: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* 2 Bytes of Flags */\n                    proto_tree_add_bitmask(pnrp_message_tree, tvb, offset+4, hf_pnrp_message_lookupControls_flags, ett_pnrp_message_lookupControls_flags, lookupControls_flags, ENC_BIG_ENDIAN);\n                    /* Precision Bytes */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_lookupControls_precision, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\n                    /* Resolve Criteria */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_lookupControls_resolveCriteria, tvb, offset + 8, 1, ENC_BIG_ENDIAN);\n                    /* Reason Code */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_lookupControls_reasonCode, tvb, offset + 9, 1, ENC_BIG_ENDIAN);\n                    /* Reserved */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved16, tvb, offset + 10, 2, ENC_LITTLE_ENDIAN);\n\n                }\n\n                offset += data_length;\n                break;\n                /* Target PNRP ID found in Lookup Message */\n            case TARGET_PNRP_ID:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Target PNRP ID: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    dissect_pnrp_ids(tvb, offset+4, data_length-4, pnrp_message_tree);\n                }\n\n                offset += data_length;\n                break;\n\n                /* Extended Payload found in AUTHORITY Message */\n            case EXTENDED_PAYLOAD:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Extended Payload: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* TODO: Do actual parsing */\n                }\n\n                offset += data_length;\n                break;\n                /* Pnrp id Array as found in REQUEST & ADVERTISE Message */\n            case PNRP_ID_ARRAY:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"PNRP ID Array: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_idArray_NumEntries, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_idArray_Length, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ElementFieldType, tvb, offset + 8, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_idarray_Entrylength, tvb, offset + 10, 2, ENC_BIG_ENDIAN);\n                    dissect_pnrp_ids(tvb,offset+12,data_length-12,pnrp_message_tree);\n                }\n\n                offset += data_length;\n                break;\n                /* Cert Chain follows as found in AUTHORITY */\n            case CERT_CHAIN:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"CERT Chain: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_certChain, tvb, offset + 4, data_length-4, ENC_NA);\n                }\n\n                /* There might be padding, so fill up to the next byte */\n                padding_bytes = 0;\n                while (data_length%4 != 0 &&tvb_reported_length_remaining(tvb, offset+data_length)>0) {\n                    data_length++;\n                    padding_bytes++;\n                }\n                /* Check if we actually had some padding bytes */\n                if (0<padding_bytes) {\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + data_length-padding_bytes, padding_bytes, ENC_NA);\n                }\n                offset += data_length;\n                break;\n                /* classifier: A classifier string follows as found in AUTHORITY */\n            case CLASSIFIER:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Classifier: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* NumEntries */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_unicodeCount, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\n                    /* Array Length: 8+(NumEntries*EntryLength */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_arrayLength, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\n                    /* Element Field Type: WCHAR */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset+8 , 2, ENC_BIG_ENDIAN);\n                    /* Entry Length: Must be 0x0002 */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_entryLength, tvb, offset + 10, 2, ENC_BIG_ENDIAN);\n                    /* The actual classifier String */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_string, tvb, offset + 12, tvb_get_ntohs(tvb,offset+6)-8, ENC_UTF_16|ENC_BIG_ENDIAN);\n                }\n\n                /* There might be padding, so fill up to the next byte */\n                padding_bytes = 0;\n                while (data_length%4 != 0 &&tvb_reported_length_remaining(tvb, offset+data_length)>0) {\n                    data_length++;\n                    padding_bytes++;\n                }\n                /* Check if we actually had some padding bytes */\n                if (0<padding_bytes) {\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + data_length-padding_bytes, padding_bytes, ENC_NA);\n                }\n                offset += data_length;\n                break;\n                /* A hashed nonce follows as found in ADVERTISE & SOLICIT */\n            case HASHED_NONCE:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Hashed Nonce: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_hashednonce, tvb, offset + 4, data_length-4, ENC_NA);\n\n                }\n\n                offset += data_length;\n                break;\n\n                /* A nonce follows as found in REQUEST & INQUIRE */\n            case NONCE:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Nonce: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_nonce, tvb, offset + 4, data_length-4, ENC_NA);\n                }\n\n                offset += data_length;\n                break;\n\n                /* split controls as found in AUTHORITY */\n            case SPLIT_CONTROLS:\n            {\n                fragment_head *frag_data;\n                tvbuff_t *frag_tvb;\n                guint32 buffer_len, frag_offset, remaining_len;\n\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Split controls: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                }\n                /* Size of Authority Buffer */\n                proto_tree_add_item_ret_uint(pnrp_message_tree, hf_pnrp_message_splitControls_authorityBuffer,\n                                             tvb, offset + 4, 2, ENC_BIG_ENDIAN, &buffer_len);\n                /* Byte offset */\n                proto_tree_add_item_ret_uint(pnrp_message_tree, hf_pnrp_message_offset,\n                                             tvb, offset + 6, 2, ENC_BIG_ENDIAN, &frag_offset);\n                offset += data_length;\n                remaining_len = tvb_reported_length_remaining(tvb, offset);\n\n                frag_data = fragment_add_check(&pnrp_reassembly_table, tvb, offset, pinfo,\n                                               msg_id, NULL, frag_offset, remaining_len,\n                                               (buffer_len != (frag_offset + remaining_len)));\n                frag_tvb = process_reassembled_data(tvb, offset, pinfo, \"Reassembled PNRP message\",\n                                                    frag_data, &pnrp_frag_items, NULL, pnrp_message_tree);\n                if (frag_tvb) {\n                    tvb = frag_tvb;\n                    offset = 0;\n                } else {\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_fragmented_payload, tvb, offset, -1, ENC_NA);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" [Fragmented message]\");\n                    return tvb_captured_length(tvb);\n                }\n                break;\n            }\n\n                /* routing entry: A route entry follows as found in ADVERTISE, INQUIRE, LOOKUP & AUTHORITY */\n            case ROUTING_ENTRY:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Routing Entry: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    dissect_route_entry(tvb,offset+4, tvb_get_ntohs(tvb,offset+2)-4, pnrp_message_tree);\n                }\n\n                /* There might be padding, so fill up to the next byte */\n                padding_bytes = 0;\n                while (data_length%4 != 0 &&tvb_reported_length_remaining(tvb, offset+data_length)>0) {\n                    data_length++;\n                    padding_bytes++;\n                }\n                /* Check if we actually had some padding bytes */\n                if (0<padding_bytes) {\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + data_length-padding_bytes, padding_bytes, ENC_NA);\n                }\n                offset += data_length;\n                break;\n\n                /* validate cpa: an encoded CPA structure follows as found in AUTHORITY */\n            case VALIDATE_CPA:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Validate CPA: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* Do the actual parsing in own method */\n                    dissect_encodedCPA_structure(tvb, offset+4, data_length-4, pnrp_message_tree);\n\n                }\n\n                offset += data_length;\n                break;\n\n\n                /* IPV6 Endpoint: an ipv6 endpoint array structure follows as found in LOOKUP */\n            case IPV6_ENDPOINT_ARRAY:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"IPv6 Endpoint Array: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* Number of route entries */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ipv6EndpointArray_NumberOfEntries, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\n                    /* Array length */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ipv6EndpointArray_ArrayLength, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\n                    /* Element Field Type */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset+8 , 2, ENC_BIG_ENDIAN);\n                    /* Entry Length: must be 0x0012 (18 bytes) */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ipv6EndpointArray_EntryLength, tvb, offset + 10, 2, ENC_BIG_ENDIAN);\n                    /* Flagged Path */\n                    dissect_ipv6_endpoint_structure(tvb, offset+12, tvb_get_ntohs(tvb,offset+6)-8,pnrp_message_tree);\n                }\n\n                offset += data_length;\n                break;\n\n            default:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree_format(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Type: %s, length: %u\",\n                                                            val_to_str(field_type, fieldID, \"Unknown (0x%04x)\"), data_length);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    if(data_length > 4)\n                    {\n                        proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_data, tvb, offset + 4, data_length -4, ENC_NA);\n                    }\n                    else {\n                        return 0;\n                    }\n                }\n                offset += data_length;\n                break;\n        }\n    }\n    return offset;\n\n}",
        "func": "static int dissect_pnrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    /* Variable declaration */\n    int offset, start_offset;\n    gint padding_bytes;\n    guint8 message_type;\n    guint16 field_type;\n    unsigned data_length;\n    proto_item *ti;\n    proto_tree *pnrp_tree;\n    proto_item *pnrp_header_item;\n    proto_tree *pnrp_header_tree;\n    proto_item *pnrp_message_tree = NULL;\n    guint32 msg_id;\n\n    /*----------------------------------------\n     * Validate if it is really a PNRP Packet\n     *----------------------------------------*/\n    /* Check that there's enough data */\n    data_length = tvb_captured_length(tvb);\n\n    /* Shortest Message is ACK -> 12 Bytes for Header plus 8 Bytes for Data */\n    if (data_length <  12+8 )\n    {\n        return 0;\n    }\n\n    /* Check some values from the packet header */\n    /* First 2 bytes must be 0x0010 */\n    if (tvb_get_ntohs(tvb,0) != PNRP_HEADER )\n    {\n        return 0;\n    }\n    /* Length of Header must be 0x000C = 12 */\n    if (tvb_get_ntohs(tvb,2) != 0x000C) {\n        return 0;\n    }\n    /* Identifier must 0x51 */\n    if (tvb_get_guint8(tvb,4) != 0x51) {\n        return 0;\n    }\n\n\n    /* Assign Values to Variables */\n    /* Use to track data */\n    offset= 0;\n    /* Get the message Information beforehand */\n    message_type = tvb_get_guint8(tvb,7);\n\n\n    /* Simply Display the Protocol Name in the INFO column */\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"PNRP\");\n    /* Clear out stuff in the info column */\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"PNRP %s Message \",\n                 val_to_str(message_type, messageType, \"Unknown (0x%02x)\"));\n\n\n    /* Lets add a subtree to our dissection to display the info */\n    ti = proto_tree_add_item(tree, proto_pnrp, tvb, 0, -1, ENC_NA);\n    proto_item_append_text(ti, \", Message Type %s\",\n                           val_to_str(message_type, messageType, \"Unknown (0x%02x)\"));\n    /* Get a main tree for the whole protocol */\n    pnrp_tree = proto_item_add_subtree(ti, ett_pnrp);\n\n    /*-------------------------------\n     *--Add all Header Fields\n     *------------------------------*/\n    /* Get a subtree for the Header */\n    pnrp_header_item = proto_tree_add_item(pnrp_tree, hf_pnrp_header, tvb, offset,12,ENC_NA);\n    pnrp_header_tree = proto_item_add_subtree(pnrp_header_item, ett_pnrp_header);\n\n    /* Add Field ID should be 0c0010 */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_fieldID,tvb,offset,2,ENC_BIG_ENDIAN);\n    offset += 2;\n    /* Add Length should be 0x000C */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_length,tvb,offset,2,ENC_BIG_ENDIAN);\n    offset += 2;\n    /* Add Ident should be 0x51 */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_ident,tvb,offset,1,ENC_BIG_ENDIAN);\n    offset += 1;\n    /* Add Major Version */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_versionMajor,tvb,offset,1,ENC_BIG_ENDIAN);\n    offset += 1;\n    /* Add Minor Version */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_versionMinor,tvb,offset,1,ENC_BIG_ENDIAN);\n    offset += 1;\n    /* Add Message Type */\n    proto_tree_add_item(pnrp_header_tree,hf_pnrp_header_messageType,tvb,offset,1,ENC_BIG_ENDIAN);\n    offset += 1;\n    /* Add Message ID */\n    proto_tree_add_item_ret_uint(pnrp_header_tree,hf_pnrp_header_messageID,tvb,offset,4,ENC_BIG_ENDIAN,&msg_id);\n    offset += 4;\n\n\n    /*-------------------------------\n     *--Add all Message Fields\n     *------------------------------*/\n\n    /* The following part has dynamic length depending on message type */\n    start_offset = offset;\n    while (tvb_reported_length_remaining(tvb, offset) > 0) {\n        /* Determine the Field Type */\n        field_type = tvb_get_ntohs(tvb,offset );\n        /* Determine length of this message */\n        data_length = tvb_get_ntohs(tvb,offset + 2);\n\n        /* Length must be at least 4, because field_type and data_length are part of data_length information */\n        if (data_length < 4) {\n            if (tree) {\n                pnrp_message_tree = proto_tree_add_subtree_format(pnrp_tree, tvb, offset, 4, ett_pnrp_message, NULL,\n                                    \"Message with invalid length %u (< 4)\", data_length);\n                proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n                proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n            }\n            offset += 4;\n            /* Don't continue parsing this message segment */\n            break;\n        }\n        /* Actual Parsing of the message Type */\n        switch (field_type) {\n            /* First Field in ACK Message */\n            case PNRP_HEADER_ACKED:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                    data_length, ett_pnrp_message, NULL, \"Message ACK ID: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_headerack, tvb, offset + 4, data_length -4, ENC_BIG_ENDIAN);\n\n                }\n                offset += data_length;\n                break;\n\n                /* A validate pnrp id follows as found in FLOOD */\n            case VALIDATE_PNRP_ID:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Validate PNRP ID: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* We can have a large number of pnrp IDs here */\n                    dissect_pnrp_ids(tvb,offset+4,data_length-4,pnrp_message_tree);\n\n                }\n                offset += data_length;\n                break;\n\n                /* The Flags have different meaning, depending on the message */\n            case FLAGS_FIELD:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Flags Field: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                }\n                switch (message_type) {\n                    case INQUIRE:\n                        proto_tree_add_bitmask(pnrp_message_tree, tvb, offset+4, hf_pnrp_message_inquire_flags, ett_pnrp_message_inquire_flags, inquire_flags, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + 6, 2, ENC_NA);\n                        offset += data_length+2;\n\n                        break;\n\n                    case ACK:\n                        /* Reserved 0 - 14 bits */\n                        proto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_ack_flags_reserved, tvb, (offset + 4)*8, 15, ENC_BIG_ENDIAN);\n                        /* N - Bit */\n                        proto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_ack_flags_Nbit, tvb,((offset + 4)*8)+15, 1, ENC_BIG_ENDIAN);\n                        offset += data_length;\n                        break;\n                    case AUTHORITY:\n                        proto_tree_add_bitmask(pnrp_message_tree, tvb, offset+4, hf_pnrp_message_authority_flags, ett_pnrp_message_authority_flags, authority_flags, ENC_BIG_ENDIAN);\n                        /* Check if the Flags Field is the last message part. If so, no padding of 2 bytes is added */\n                        if(tvb_reported_length_remaining(tvb, offset+data_length)==0)\n                        {\n                            offset += data_length;\n                        }\n                        else {\n                            padding_bytes = 2;\n                            proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + 6, padding_bytes, ENC_NA);\n                            offset += data_length+2;\n                        }\n                        break;\n\n                    default:\n                        proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_flags, tvb, offset + 4, data_length -4, ENC_BIG_ENDIAN);\n                        offset += data_length;\n                        break;\n                }\n                break;\n\n                /* Flood controls found in FLOOD Message */\n            case FLOOD_CONTROLS:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Flood Control: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* Reserved 1 - 15 bits */\n                    proto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_flood_flags_reserved1, tvb, (offset + 4)*8, 15, ENC_BIG_ENDIAN);\n                    /* D - Bit */\n                    proto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_flood_flags_Dbit, tvb,((offset + 4)*8)+15, 1, ENC_BIG_ENDIAN);\n                    /* Reserved 2 */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved8, tvb, offset + 6, 1, ENC_NA);\n                    /* Padding 1 */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + 7, 1, ENC_NA);\n                }\n\n                offset += data_length+1;\n                break;\n\n                /* Solicit Controls found in SOLICIT Message */\n            case SOLICIT_CONTROLS:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Solicit Controls: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved8, tvb, offset + 4, 1, ENC_NA);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_solicitType, tvb, offset + 5, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved16, tvb, offset + 6, 2, ENC_LITTLE_ENDIAN);\n                }\n                offset += data_length +2;   /* Padding involved */\n                break;\n                /* Lookup controls found in LOOKUP Message */\n            case LOOKUP_CONTROLS:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Lookup Control: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* 2 Bytes of Flags */\n                    proto_tree_add_bitmask(pnrp_message_tree, tvb, offset+4, hf_pnrp_message_lookupControls_flags, ett_pnrp_message_lookupControls_flags, lookupControls_flags, ENC_BIG_ENDIAN);\n                    /* Precision Bytes */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_lookupControls_precision, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\n                    /* Resolve Criteria */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_lookupControls_resolveCriteria, tvb, offset + 8, 1, ENC_BIG_ENDIAN);\n                    /* Reason Code */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_lookupControls_reasonCode, tvb, offset + 9, 1, ENC_BIG_ENDIAN);\n                    /* Reserved */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved16, tvb, offset + 10, 2, ENC_LITTLE_ENDIAN);\n\n                }\n\n                offset += data_length;\n                break;\n                /* Target PNRP ID found in Lookup Message */\n            case TARGET_PNRP_ID:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Target PNRP ID: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    dissect_pnrp_ids(tvb, offset+4, data_length-4, pnrp_message_tree);\n                }\n\n                offset += data_length;\n                break;\n\n                /* Extended Payload found in AUTHORITY Message */\n            case EXTENDED_PAYLOAD:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Extended Payload: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* TODO: Do actual parsing */\n                }\n\n                offset += data_length;\n                break;\n                /* Pnrp id Array as found in REQUEST & ADVERTISE Message */\n            case PNRP_ID_ARRAY:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"PNRP ID Array: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_idArray_NumEntries, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_idArray_Length, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ElementFieldType, tvb, offset + 8, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_idarray_Entrylength, tvb, offset + 10, 2, ENC_BIG_ENDIAN);\n                    dissect_pnrp_ids(tvb,offset+12,data_length-12,pnrp_message_tree);\n                }\n\n                offset += data_length;\n                break;\n                /* Cert Chain follows as found in AUTHORITY */\n            case CERT_CHAIN:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"CERT Chain: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_certChain, tvb, offset + 4, data_length-4, ENC_NA);\n                }\n\n                /* There might be padding, so fill up to the next byte */\n                padding_bytes = 0;\n                while (data_length%4 != 0 &&tvb_reported_length_remaining(tvb, offset+data_length)>0) {\n                    data_length++;\n                    padding_bytes++;\n                }\n                /* Check if we actually had some padding bytes */\n                if (0<padding_bytes) {\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + data_length-padding_bytes, padding_bytes, ENC_NA);\n                }\n                offset += data_length;\n                break;\n                /* classifier: A classifier string follows as found in AUTHORITY */\n            case CLASSIFIER:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Classifier: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* NumEntries */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_unicodeCount, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\n                    /* Array Length: 8+(NumEntries*EntryLength */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_arrayLength, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\n                    /* Element Field Type: WCHAR */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset+8 , 2, ENC_BIG_ENDIAN);\n                    /* Entry Length: Must be 0x0002 */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_entryLength, tvb, offset + 10, 2, ENC_BIG_ENDIAN);\n                    /* The actual classifier String */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_string, tvb, offset + 12, tvb_get_ntohs(tvb,offset+6)-8, ENC_UTF_16|ENC_BIG_ENDIAN);\n                }\n\n                /* There might be padding, so fill up to the next byte */\n                padding_bytes = 0;\n                while (data_length%4 != 0 &&tvb_reported_length_remaining(tvb, offset+data_length)>0) {\n                    data_length++;\n                    padding_bytes++;\n                }\n                /* Check if we actually had some padding bytes */\n                if (0<padding_bytes) {\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + data_length-padding_bytes, padding_bytes, ENC_NA);\n                }\n                offset += data_length;\n                break;\n                /* A hashed nonce follows as found in ADVERTISE & SOLICIT */\n            case HASHED_NONCE:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Hashed Nonce: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_hashednonce, tvb, offset + 4, data_length-4, ENC_NA);\n\n                }\n\n                offset += data_length;\n                break;\n\n                /* A nonce follows as found in REQUEST & INQUIRE */\n            case NONCE:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Nonce: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_nonce, tvb, offset + 4, data_length-4, ENC_NA);\n                }\n\n                offset += data_length;\n                break;\n\n                /* split controls as found in AUTHORITY */\n            case SPLIT_CONTROLS:\n            {\n                fragment_head *frag_data;\n                tvbuff_t *frag_tvb;\n                guint32 buffer_len, frag_offset, remaining_len;\n\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Split controls: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                }\n                /* Size of Authority Buffer */\n                proto_tree_add_item_ret_uint(pnrp_message_tree, hf_pnrp_message_splitControls_authorityBuffer,\n                                             tvb, offset + 4, 2, ENC_BIG_ENDIAN, &buffer_len);\n                /* Byte offset */\n                proto_tree_add_item_ret_uint(pnrp_message_tree, hf_pnrp_message_offset,\n                                             tvb, offset + 6, 2, ENC_BIG_ENDIAN, &frag_offset);\n                offset += data_length;\n                remaining_len = tvb_reported_length_remaining(tvb, offset);\n\n                frag_data = fragment_add_check(&pnrp_reassembly_table, tvb, offset, pinfo,\n                                               msg_id, NULL, frag_offset, remaining_len,\n                                               (buffer_len != (frag_offset + remaining_len)));\n                frag_tvb = process_reassembled_data(tvb, offset, pinfo, \"Reassembled PNRP message\",\n                                                    frag_data, &pnrp_frag_items, NULL, pnrp_message_tree);\n                if (frag_tvb) {\n                    tvb = frag_tvb;\n                    offset = 0;\n                } else {\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_fragmented_payload, tvb, offset, -1, ENC_NA);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" [Fragmented message]\");\n                    return tvb_captured_length(tvb);\n                }\n                break;\n            }\n\n                /* routing entry: A route entry follows as found in ADVERTISE, INQUIRE, LOOKUP & AUTHORITY */\n            case ROUTING_ENTRY:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Routing Entry: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    dissect_route_entry(tvb,offset+4, tvb_get_ntohs(tvb,offset+2)-4, pnrp_message_tree);\n                }\n\n                /* There might be padding, so fill up to the next byte */\n                padding_bytes = 0;\n                while (data_length%4 != 0 &&tvb_reported_length_remaining(tvb, offset+data_length)>0) {\n                    data_length++;\n                    padding_bytes++;\n                }\n                /* Check if we actually had some padding bytes */\n                if (0<padding_bytes) {\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + data_length-padding_bytes, padding_bytes, ENC_NA);\n                }\n                offset += data_length;\n                break;\n\n                /* validate cpa: an encoded CPA structure follows as found in AUTHORITY */\n            case VALIDATE_CPA:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Validate CPA: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* Do the actual parsing in own method */\n                    dissect_encodedCPA_structure(tvb, offset+4, data_length-4, pnrp_message_tree);\n\n                }\n\n                offset += data_length;\n                break;\n\n\n                /* IPV6 Endpoint: an ipv6 endpoint array structure follows as found in LOOKUP */\n            case IPV6_ENDPOINT_ARRAY:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"IPv6 Endpoint Array: \");\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    /* Number of route entries */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ipv6EndpointArray_NumberOfEntries, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\n                    /* Array length */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ipv6EndpointArray_ArrayLength, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\n                    /* Element Field Type */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset+8 , 2, ENC_BIG_ENDIAN);\n                    /* Entry Length: must be 0x0012 (18 bytes) */\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ipv6EndpointArray_EntryLength, tvb, offset + 10, 2, ENC_BIG_ENDIAN);\n                    /* Flagged Path */\n                    dissect_ipv6_endpoint_structure(tvb, offset+12, tvb_get_ntohs(tvb,offset+6)-8,pnrp_message_tree);\n                }\n\n                offset += data_length;\n                break;\n\n            default:\n                if (tree) {\n                    pnrp_message_tree = proto_tree_add_subtree_format(pnrp_tree, tvb, offset,\n                                                            data_length, ett_pnrp_message, NULL, \"Type: %s, length: %u\",\n                                                            val_to_str(field_type, fieldID, \"Unknown (0x%04x)\"), data_length);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n                    if(data_length > 4)\n                    {\n                        proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_data, tvb, offset + 4, data_length -4, ENC_NA);\n                    }\n                    else {\n                        return 0;\n                    }\n                }\n                offset += data_length;\n                break;\n        }\n        // SPLIT_CONTROLS might reset our offset.\n        if (start_offset <= offset) {\n            THROW(ReportedBoundsError);\n        }\n    }\n    return offset;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,11 @@\n static int dissect_pnrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n {\n     /* Variable declaration */\n-    gint offset;\n+    int offset, start_offset;\n     gint padding_bytes;\n     guint8 message_type;\n     guint16 field_type;\n-    guint16 data_length;\n+    unsigned data_length;\n     proto_item *ti;\n     proto_tree *pnrp_tree;\n     proto_item *pnrp_header_item;\n@@ -97,6 +97,7 @@\n      *------------------------------*/\n \n     /* The following part has dynamic length depending on message type */\n+    start_offset = offset;\n     while (tvb_reported_length_remaining(tvb, offset) > 0) {\n         /* Determine the Field Type */\n         field_type = tvb_get_ntohs(tvb,offset );\n@@ -181,7 +182,6 @@\n                         }\n                         break;\n \n-\n                     default:\n                         proto_tree_add_item(pnrp_message_tree, hf_pnrp_message_flags, tvb, offset + 4, data_length -4, ENC_BIG_ENDIAN);\n                         offset += data_length;\n@@ -482,6 +482,10 @@\n                 offset += data_length;\n                 break;\n         }\n+        // SPLIT_CONTROLS might reset our offset.\n+        if (start_offset <= offset) {\n+            THROW(ReportedBoundsError);\n+        }\n     }\n     return offset;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    gint offset;",
                "    guint16 data_length;",
                ""
            ],
            "added_lines": [
                "    int offset, start_offset;",
                "    unsigned data_length;",
                "    start_offset = offset;",
                "        // SPLIT_CONTROLS might reset our offset.",
                "        if (start_offset <= offset) {",
                "            THROW(ReportedBoundsError);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39924",
        "func_name": "wireshark/dissect_bencoded_dict_entry",
        "description": "Large loop in the Bluetooth DHT dissector in Wireshark 3.4.0 to 3.4.9 and 3.2.0 to 3.2.17 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/79a9fe1cf0d6bcc821f2d56b130c80c9052b5c58",
        "commit_title": "BT-DHT: Fix another loop and add NULL checks.",
        "commit_text": " Make sure dissect_bt_dht_values even when we have a zero-length string. Add a couple of NULL checks. Fixes #17677. ",
        "func_before": "static int\ndissect_bencoded_dict_entry(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset )\n{\n  proto_item *ti;\n  proto_tree *sub_tree;\n  gboolean    tohex;\n  const char *key;\n  const char *val;\n  guint       orig_offset = offset;\n\n  key = NULL;\n  val = NULL;\n\n  ti       = proto_tree_add_item( tree, hf_bencoded_dict_entry, tvb, offset, 0, ENC_NA );\n  sub_tree = proto_item_add_subtree( ti, ett_bencoded_dict_entry);\n\n  /* dissect the key, it must be a string */\n  offset   = dissect_bencoded_string( tvb, pinfo, sub_tree, offset, &key, FALSE, \"Key\" );\n  if (offset == 0)\n  {\n    proto_tree_add_expert_format(sub_tree, pinfo, &ei_int_string, tvb, offset, -1, \"Invalid string for Key\");\n    return 0;\n  }\n\n  /* If it is a dict, then just do recursion */\n  switch( tvb_get_guint8(tvb,offset) )\n  {\n  case 'd':\n    offset = dissect_bencoded_dict( tvb, pinfo, sub_tree, offset, \"Value\" );\n    val    = dict_str;\n    break;\n  case 'l':\n    if( strcmp(key,\"e\")==0 )\n      offset = dissect_bt_dht_error( tvb, pinfo, sub_tree, offset, &val, \"Value\" );\n    else if( strcmp(key,\"values\")==0 )\n      offset = dissect_bt_dht_values( tvb, pinfo, sub_tree, offset, &val, \"Value\" );\n    /* other unfamiliar lists */\n    else\n    {\n      offset = dissect_bencoded_list( tvb, pinfo, sub_tree, offset, \"Value\" );\n      val = list_str;\n    }\n    break;\n  case 'i':\n    offset = dissect_bencoded_int( tvb, pinfo, sub_tree, offset, &val, \"Value\" );\n    break;\n  /* it's a string */\n  default:\n    /* special process */\n    if( strcmp(key,\"nodes\")==0 )\n    {\n      offset = dissect_bt_dht_nodes( tvb, pinfo, sub_tree, offset, &val, \"Value\", 0 );\n    }\n    else if( strcmp(key,\"nodes6\")==0 )\n    {\n      offset = dissect_bt_dht_nodes( tvb, pinfo, sub_tree, offset, &val, \"Value\", 1 );\n    }\n    else if( strcmp(key,\"ip\")==0 )\n    {\n      /*\n       * BEP 42 DHT Security extension\n       * https://www.bittorrent.org/beps/bep_0042.html\n       * https://www.rasterbar.com/products/libtorrent/dht_sec.html\n       */\n\n      int len, old_offset;\n      old_offset = offset;\n      len = bencoded_string_length(pinfo, tvb, &offset);\n\n      if(len == 6) {\n        proto_tree_add_item(sub_tree, hf_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\n        val = tvb_ip_to_str(pinfo->pool, tvb, offset);\n        offset += 4;\n        proto_tree_add_item(sub_tree, hf_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n      }\n      else {\n        /* XXX: BEP 42 doesn't mention IPv6 and predates the IPv6 DHT;\n         * it doesn't make sense for IPv6 because the purpose is to tell\n         * the requestor its own publicly routable IP address and port\n         * (working around NAT). So any other length than 6 is unexpected.\n         */\n        offset = dissect_bencoded_string( tvb, pinfo, sub_tree, old_offset, &val, TRUE, \"Value\" );\n      }\n    }\n    else\n    {\n      /* some need to return hex string */\n      tohex = strcmp(key,\"id\")==0 || strcmp(key,\"target\")==0\n           || strcmp(key,\"info_hash\")==0 || strcmp(key,\"t\")==0\n           || strcmp(key,\"v\")==0 || strcmp(key,\"token\")==0;\n      offset = dissect_bencoded_string( tvb, pinfo, sub_tree, offset, &val, tohex, \"Value\" );\n    }\n  }\n\n  if (offset == 0)\n  {\n    proto_tree_add_expert_format(sub_tree, pinfo, &ei_int_string, tvb, offset, -1, \"Invalid string for value\");\n    return 0;\n  }\n\n  if( strlen(key)==1 )\n    key = val_to_str_const( key[0], short_key_name_value_string, key );\n  if( strlen(val)==1 )\n    val = val_to_str_const( val[0], short_val_name_value_string, val );\n\n  proto_item_set_text( ti, \"%s: %s\", key, val );\n  proto_item_set_len( ti, offset-orig_offset );\n\n  if( strcmp(key,\"message_type\")==0 || strcmp(key,\"request_type\")==0 )\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"%s=%s \", key, val);\n\n  return offset;\n}",
        "func": "static int\ndissect_bencoded_dict_entry(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset )\n{\n  proto_item *ti;\n  proto_tree *sub_tree;\n  gboolean    tohex;\n  const char *key;\n  const char *val;\n  guint       orig_offset = offset;\n\n  key = NULL;\n  val = NULL;\n\n  ti       = proto_tree_add_item( tree, hf_bencoded_dict_entry, tvb, offset, 0, ENC_NA );\n  sub_tree = proto_item_add_subtree( ti, ett_bencoded_dict_entry);\n\n  /* dissect the key, it must be a string */\n  offset   = dissect_bencoded_string( tvb, pinfo, sub_tree, offset, &key, FALSE, \"Key\" );\n  if (offset == 0)\n  {\n    proto_tree_add_expert_format(sub_tree, pinfo, &ei_int_string, tvb, offset, -1, \"Invalid string for Key\");\n    return 0;\n  }\n\n  /* If it is a dict, then just do recursion */\n  switch( tvb_get_guint8(tvb,offset) )\n  {\n  case 'd':\n    offset = dissect_bencoded_dict( tvb, pinfo, sub_tree, offset, \"Value\" );\n    val    = dict_str;\n    break;\n  case 'l':\n    if( strcmp(key,\"e\")==0 )\n      offset = dissect_bt_dht_error( tvb, pinfo, sub_tree, offset, &val, \"Value\" );\n    else if( strcmp(key,\"values\")==0 )\n      offset = dissect_bt_dht_values( tvb, pinfo, sub_tree, offset, &val, \"Value\" );\n    /* other unfamiliar lists */\n    else\n    {\n      offset = dissect_bencoded_list( tvb, pinfo, sub_tree, offset, \"Value\" );\n      val = list_str;\n    }\n    break;\n  case 'i':\n    offset = dissect_bencoded_int( tvb, pinfo, sub_tree, offset, &val, \"Value\" );\n    break;\n  /* it's a string */\n  default:\n    /* special process */\n    if( strcmp(key,\"nodes\")==0 )\n    {\n      offset = dissect_bt_dht_nodes( tvb, pinfo, sub_tree, offset, &val, \"Value\", 0 );\n    }\n    else if( strcmp(key,\"nodes6\")==0 )\n    {\n      offset = dissect_bt_dht_nodes( tvb, pinfo, sub_tree, offset, &val, \"Value\", 1 );\n    }\n    else if( strcmp(key,\"ip\")==0 )\n    {\n      /*\n       * BEP 42 DHT Security extension\n       * https://www.bittorrent.org/beps/bep_0042.html\n       * https://www.rasterbar.com/products/libtorrent/dht_sec.html\n       */\n\n      int len, old_offset;\n      old_offset = offset;\n      len = bencoded_string_length(pinfo, tvb, &offset);\n\n      if(len == 6) {\n        proto_tree_add_item(sub_tree, hf_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\n        val = tvb_ip_to_str(pinfo->pool, tvb, offset);\n        offset += 4;\n        proto_tree_add_item(sub_tree, hf_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n        offset += 2;\n      }\n      else {\n        /* XXX: BEP 42 doesn't mention IPv6 and predates the IPv6 DHT;\n         * it doesn't make sense for IPv6 because the purpose is to tell\n         * the requestor its own publicly routable IP address and port\n         * (working around NAT). So any other length than 6 is unexpected.\n         */\n        offset = dissect_bencoded_string( tvb, pinfo, sub_tree, old_offset, &val, TRUE, \"Value\" );\n      }\n    }\n    else\n    {\n      /* some need to return hex string */\n      tohex = strcmp(key,\"id\")==0 || strcmp(key,\"target\")==0\n           || strcmp(key,\"info_hash\")==0 || strcmp(key,\"t\")==0\n           || strcmp(key,\"v\")==0 || strcmp(key,\"token\")==0;\n      offset = dissect_bencoded_string( tvb, pinfo, sub_tree, offset, &val, tohex, \"Value\" );\n    }\n  }\n\n  if (offset == 0)\n  {\n    proto_tree_add_expert_format(sub_tree, pinfo, &ei_int_string, tvb, offset, -1, \"Invalid string for value\");\n    return 0;\n  }\n\n  if(key && strlen(key)==1 )\n    key = val_to_str_const( key[0], short_key_name_value_string, key );\n  if(val && strlen(val)==1 )\n    val = val_to_str_const( val[0], short_val_name_value_string, val );\n\n  proto_item_set_text( ti, \"%s: %s\", key, val );\n  proto_item_set_len( ti, offset-orig_offset );\n\n  if( strcmp(key,\"message_type\")==0 || strcmp(key,\"request_type\")==0 )\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"%s=%s \", key, val);\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -99,9 +99,9 @@\n     return 0;\n   }\n \n-  if( strlen(key)==1 )\n+  if(key && strlen(key)==1 )\n     key = val_to_str_const( key[0], short_key_name_value_string, key );\n-  if( strlen(val)==1 )\n+  if(val && strlen(val)==1 )\n     val = val_to_str_const( val[0], short_val_name_value_string, val );\n \n   proto_item_set_text( ti, \"%s: %s\", key, val );",
        "diff_line_info": {
            "deleted_lines": [
                "  if( strlen(key)==1 )",
                "  if( strlen(val)==1 )"
            ],
            "added_lines": [
                "  if(key && strlen(key)==1 )",
                "  if(val && strlen(val)==1 )"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39924",
        "func_name": "wireshark/dissect_bt_dht_values",
        "description": "Large loop in the Bluetooth DHT dissector in Wireshark 3.4.0 to 3.4.9 and 3.2.0 to 3.2.17 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/79a9fe1cf0d6bcc821f2d56b130c80c9052b5c58",
        "commit_title": "BT-DHT: Fix another loop and add NULL checks.",
        "commit_text": " Make sure dissect_bt_dht_values even when we have a zero-length string. Add a couple of NULL checks. Fixes #17677. ",
        "func_before": "static int\ndissect_bt_dht_values(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset, const char **result, const char *label )\n{\n  proto_item *ti;\n  proto_tree *sub_tree;\n  proto_item *value_ti;\n  proto_tree *value_tree;\n\n  guint       peer_index;\n  guint       string_len;\n\n  ti = proto_tree_add_item( tree, hf_bt_dht_peers, tvb, offset, 0, ENC_NA );\n  sub_tree = proto_item_add_subtree( ti, ett_bt_dht_peers);\n\n  peer_index = 0;\n  /* we has confirmed that the first byte is 'l' */\n  offset += 1;\n\n  /* dissect bt-dht values */\n  while( tvb_get_guint8(tvb,offset)!='e' )\n  {\n    string_len = bencoded_string_length(pinfo, tvb, &offset);\n\n    if (string_len == 6)\n    {\n      /* 4 bytes ip, 2 bytes port */\n      peer_index += 1;\n\n      value_ti = proto_tree_add_item( sub_tree, hf_bt_dht_peer, tvb, offset, 6, ENC_NA );\n      proto_item_append_text(value_ti, \" %d\", peer_index);\n      value_tree = proto_item_add_subtree( value_ti, ett_bt_dht_peers);\n\n      proto_tree_add_item( value_tree, hf_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \" (IP/Port: %s\", tvb_ip_to_str(pinfo->pool, tvb, offset));\n      proto_tree_add_item( value_tree, hf_port, tvb, offset+4, 2, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \":%u)\", tvb_get_ntohs( tvb, offset+4 ));\n    }\n    else if (string_len == 18)\n    {\n      /* 16 bytes ip, 2 bytes port */\n      peer_index += 1;\n\n      value_ti = proto_tree_add_item( sub_tree, hf_bt_dht_peer, tvb, offset, 18, ENC_NA );\n      proto_item_append_text(value_ti, \" %d\", peer_index);\n      value_tree = proto_item_add_subtree( value_ti, ett_bt_dht_peers);\n\n      proto_tree_add_item( value_tree, hf_ip6, tvb, offset, 16, ENC_NA);\n      proto_item_append_text(value_ti, \" (IPv6/Port: [%s]\", tvb_ip6_to_str(pinfo->pool, tvb, offset));\n      proto_tree_add_item( value_tree, hf_port, tvb, offset+16, 2, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \":%u)\", tvb_get_ntohs( tvb, offset+16 ));\n    }\n    else\n    {\n      /* truncated data */\n      proto_tree_add_item( tree, hf_truncated_data, tvb, offset, string_len, ENC_NA );\n    }\n\n    offset += string_len;\n  }\n\n  if (tvb_get_guint8(tvb,offset)=='e') { /* list ending delimiter */\n    proto_tree_add_item(sub_tree, hf_bencoded_list_terminator, tvb, offset, 1, ENC_ASCII|ENC_NA);\n    offset++;\n  }\n\n  proto_item_set_text( ti, \"%s: %d peers\", label, peer_index );\n  col_append_fstr( pinfo->cinfo, COL_INFO, \" reply=%d peers\", peer_index );\n  *result = wmem_strdup_printf(pinfo->pool, \"%d peers\", peer_index);\n\n  return offset;\n}",
        "func": "static int\ndissect_bt_dht_values(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset, const char **result, const char *label )\n{\n  proto_item *ti;\n  proto_tree *sub_tree;\n  proto_item *value_ti;\n  proto_tree *value_tree;\n\n  guint       peer_index;\n  guint       string_len;\n\n  ti = proto_tree_add_item( tree, hf_bt_dht_peers, tvb, offset, 0, ENC_NA );\n  sub_tree = proto_item_add_subtree( ti, ett_bt_dht_peers);\n\n  peer_index = 0;\n  /* we has confirmed that the first byte is 'l' */\n  offset += 1;\n\n  /* dissect bt-dht values */\n  while( tvb_get_guint8(tvb,offset)!='e' )\n  {\n    string_len = bencoded_string_length(pinfo, tvb, &offset);\n\n    if (string_len == 0)\n    {\n      expert_add_info(pinfo, ti, &ei_invalid_len);\n      // Fail hard here rather than potentially looping excessively.\n      return tvb_reported_length_remaining(tvb, offset);\n    }\n    else if (string_len == 6)\n    {\n      /* 4 bytes ip, 2 bytes port */\n      peer_index += 1;\n\n      value_ti = proto_tree_add_item( sub_tree, hf_bt_dht_peer, tvb, offset, 6, ENC_NA );\n      proto_item_append_text(value_ti, \" %d\", peer_index);\n      value_tree = proto_item_add_subtree( value_ti, ett_bt_dht_peers);\n\n      proto_tree_add_item( value_tree, hf_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \" (IP/Port: %s\", tvb_ip_to_str(pinfo->pool, tvb, offset));\n      proto_tree_add_item( value_tree, hf_port, tvb, offset+4, 2, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \":%u)\", tvb_get_ntohs( tvb, offset+4 ));\n    }\n    else if (string_len == 18)\n    {\n      /* 16 bytes ip, 2 bytes port */\n      peer_index += 1;\n\n      value_ti = proto_tree_add_item( sub_tree, hf_bt_dht_peer, tvb, offset, 18, ENC_NA );\n      proto_item_append_text(value_ti, \" %d\", peer_index);\n      value_tree = proto_item_add_subtree( value_ti, ett_bt_dht_peers);\n\n      proto_tree_add_item( value_tree, hf_ip6, tvb, offset, 16, ENC_NA);\n      proto_item_append_text(value_ti, \" (IPv6/Port: [%s]\", tvb_ip6_to_str(pinfo->pool, tvb, offset));\n      proto_tree_add_item( value_tree, hf_port, tvb, offset+16, 2, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \":%u)\", tvb_get_ntohs( tvb, offset+16 ));\n    }\n    else\n    {\n      /* truncated data */\n      proto_tree_add_item( tree, hf_truncated_data, tvb, offset, string_len, ENC_NA );\n    }\n\n    offset += string_len;\n  }\n\n  if (tvb_get_guint8(tvb,offset)=='e') { /* list ending delimiter */\n    proto_tree_add_item(sub_tree, hf_bencoded_list_terminator, tvb, offset, 1, ENC_ASCII|ENC_NA);\n    offset++;\n  }\n\n  proto_item_set_text( ti, \"%s: %d peers\", label, peer_index );\n  col_append_fstr( pinfo->cinfo, COL_INFO, \" reply=%d peers\", peer_index );\n  *result = wmem_strdup_printf(pinfo->pool, \"%d peers\", peer_index);\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,13 @@\n   {\n     string_len = bencoded_string_length(pinfo, tvb, &offset);\n \n-    if (string_len == 6)\n+    if (string_len == 0)\n+    {\n+      expert_add_info(pinfo, ti, &ei_invalid_len);\n+      // Fail hard here rather than potentially looping excessively.\n+      return tvb_reported_length_remaining(tvb, offset);\n+    }\n+    else if (string_len == 6)\n     {\n       /* 4 bytes ip, 2 bytes port */\n       peer_index += 1;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (string_len == 6)"
            ],
            "added_lines": [
                "    if (string_len == 0)",
                "    {",
                "      expert_add_info(pinfo, ti, &ei_invalid_len);",
                "      // Fail hard here rather than potentially looping excessively.",
                "      return tvb_reported_length_remaining(tvb, offset);",
                "    }",
                "    else if (string_len == 6)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39924",
        "func_name": "wireshark/proto_register_bt_dht",
        "description": "Large loop in the Bluetooth DHT dissector in Wireshark 3.4.0 to 3.4.9 and 3.2.0 to 3.2.17 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/79a9fe1cf0d6bcc821f2d56b130c80c9052b5c58",
        "commit_title": "BT-DHT: Fix another loop and add NULL checks.",
        "commit_text": " Make sure dissect_bt_dht_values even when we have a zero-length string. Add a couple of NULL checks. Fixes #17677. ",
        "func_before": "void\nproto_register_bt_dht(void)\n{\n  expert_module_t* expert_bt_dht;\n\n  static hf_register_info hf[] = {\n    { &hf_bencoded_string,\n      { \"String\", \"bt-dht.bencoded.string\",\n        FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_list,\n      { \"List\", \"bt-dht.bencoded.list\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_int,\n      { \"Int\", \"bt-dht.bencoded.int\",\n        FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_dict,\n      { \"Dictionary\", \"bt-dht.bencoded.dict\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_dict_entry,\n      { \"Dictionary Entry\", \"bt-dht.bencoded.dict_entry\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_list_terminator,\n      { \"Terminator\", \"bt-dht.bencoded.list.terminator\",\n        FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_error,\n      { \"Error\", \"bt-dht.error\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_peer,\n      { \"Peer\", \"bt-dht.peer\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_peers,\n      { \"Peers\", \"bt-dht.peers\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_node,\n      { \"Node\", \"bt-dht.node\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_nodes,\n      { \"Nodes\", \"bt-dht.nodes\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_id,\n      { \"ID\", \"bt-dht.id\",\n        FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_ip,\n      { \"IP\", \"bt-dht.ip\",\n        FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_ip6,\n      { \"IP\", \"bt-dht.ip6\",\n        FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_port,\n      { \"Port\", \"bt-dht.port\",\n        FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_truncated_data,\n      { \"Truncated data\", \"bt-dht.truncated_data\",\n        FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    }\n  };\n\n  static ei_register_info ei[] = {\n    { &ei_int_string, { \"bt-dht.invalid_string\", PI_MALFORMED, PI_ERROR,\n    \"String must contain an integer\", EXPFILL }}\n  };\n\n  /* Setup protocol subtree array */\n  static gint *ett[] = {\n    &ett_bt_dht,\n    &ett_bencoded_list,\n    &ett_bencoded_dict,\n    &ett_bt_dht_error,\n    &ett_bt_dht_peers,\n    &ett_bt_dht_nodes,\n    &ett_bencoded_dict_entry\n  };\n\n  module_t *bt_dht_module;\n\n  proto_bt_dht = proto_register_protocol (\"BitTorrent DHT Protocol\", \"BT-DHT\", \"bt-dht\");\n\n  bt_dht_module = prefs_register_protocol(proto_bt_dht, NULL);\n  prefs_register_obsolete_preference(bt_dht_module, \"enable\");\n\n  proto_register_field_array(proto_bt_dht, hf, array_length(hf));\n  proto_register_subtree_array(ett, array_length(ett));\n\n  expert_bt_dht = expert_register_protocol(proto_bt_dht);\n  expert_register_field_array(expert_bt_dht, ei, array_length(ei));\n}",
        "func": "void\nproto_register_bt_dht(void)\n{\n  expert_module_t* expert_bt_dht;\n\n  static hf_register_info hf[] = {\n    { &hf_bencoded_string,\n      { \"String\", \"bt-dht.bencoded.string\",\n        FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_list,\n      { \"List\", \"bt-dht.bencoded.list\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_int,\n      { \"Int\", \"bt-dht.bencoded.int\",\n        FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_dict,\n      { \"Dictionary\", \"bt-dht.bencoded.dict\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_dict_entry,\n      { \"Dictionary Entry\", \"bt-dht.bencoded.dict_entry\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bencoded_list_terminator,\n      { \"Terminator\", \"bt-dht.bencoded.list.terminator\",\n        FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_error,\n      { \"Error\", \"bt-dht.error\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_peer,\n      { \"Peer\", \"bt-dht.peer\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_peers,\n      { \"Peers\", \"bt-dht.peers\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_node,\n      { \"Node\", \"bt-dht.node\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_nodes,\n      { \"Nodes\", \"bt-dht.nodes\",\n        FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_bt_dht_id,\n      { \"ID\", \"bt-dht.id\",\n        FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_ip,\n      { \"IP\", \"bt-dht.ip\",\n        FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_ip6,\n      { \"IP\", \"bt-dht.ip6\",\n        FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_port,\n      { \"Port\", \"bt-dht.port\",\n        FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_truncated_data,\n      { \"Truncated data\", \"bt-dht.truncated_data\",\n        FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    }\n  };\n\n  static ei_register_info ei[] = {\n    { &ei_int_string, { \"bt-dht.invalid_string\", PI_MALFORMED, PI_ERROR,\n    \"String must contain an integer\", EXPFILL }},\n    { &ei_invalid_len, { \"bt-dht.invalid_length\", PI_MALFORMED, PI_ERROR,\n    \"Invalid length\", EXPFILL }},\n  };\n\n  /* Setup protocol subtree array */\n  static gint *ett[] = {\n    &ett_bt_dht,\n    &ett_bencoded_list,\n    &ett_bencoded_dict,\n    &ett_bt_dht_error,\n    &ett_bt_dht_peers,\n    &ett_bt_dht_nodes,\n    &ett_bencoded_dict_entry\n  };\n\n  module_t *bt_dht_module;\n\n  proto_bt_dht = proto_register_protocol (\"BitTorrent DHT Protocol\", \"BT-DHT\", \"bt-dht\");\n\n  bt_dht_module = prefs_register_protocol(proto_bt_dht, NULL);\n  prefs_register_obsolete_preference(bt_dht_module, \"enable\");\n\n  proto_register_field_array(proto_bt_dht, hf, array_length(hf));\n  proto_register_subtree_array(ett, array_length(ett));\n\n  expert_bt_dht = expert_register_protocol(proto_bt_dht);\n  expert_register_field_array(expert_bt_dht, ei, array_length(ei));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -72,7 +72,9 @@\n \n   static ei_register_info ei[] = {\n     { &ei_int_string, { \"bt-dht.invalid_string\", PI_MALFORMED, PI_ERROR,\n-    \"String must contain an integer\", EXPFILL }}\n+    \"String must contain an integer\", EXPFILL }},\n+    { &ei_invalid_len, { \"bt-dht.invalid_length\", PI_MALFORMED, PI_ERROR,\n+    \"Invalid length\", EXPFILL }},\n   };\n \n   /* Setup protocol subtree array */",
        "diff_line_info": {
            "deleted_lines": [
                "    \"String must contain an integer\", EXPFILL }}"
            ],
            "added_lines": [
                "    \"String must contain an integer\", EXPFILL }},",
                "    { &ei_invalid_len, { \"bt-dht.invalid_length\", PI_MALFORMED, PI_ERROR,",
                "    \"Invalid length\", EXPFILL }},"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_varuint",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_varuint(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                      guint64 *p_value)\n{\n    guint64 value;\n    guint len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &value, ENC_VARINT_PROTOBUF);\n    pi = proto_tree_add_uint64(tree, hf_item, tvb, offset, len, value);\n\n    if (len == 0) {\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return offset;\n    }\n\n    if (p_value != NULL) *p_value = value;\n\n    return offset + len;\n}",
        "func": "static int\ndissect_kafka_varuint(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                      guint64 *p_value)\n{\n    guint64 value;\n    guint len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &value, ENC_VARINT_PROTOBUF);\n    pi = proto_tree_add_uint64(tree, hf_item, tvb, offset, len, value);\n\n    if (len == 0) {\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    }\n\n    if (p_value != NULL) *p_value = value;\n\n    return offset + len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \n     if (len == 0) {\n         expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n-        return offset;\n+        return tvb_captured_length(tvb);\n     }\n \n     if (p_value != NULL) *p_value = value;",
        "diff_line_info": {
            "deleted_lines": [
                "        return offset;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_compact_array",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_compact_array(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                        kafka_api_version_t api_version,\n                        int(*func)(tvbuff_t*, packet_info*, proto_tree*, int, kafka_api_version_t),\n                        int *p_count)\n{\n    gint64 count;\n    gint32 len;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &count, ENC_VARINT_PROTOBUF);\n    if (len == 0 || count > 0x7ffffffL) {\n        expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_kafka_bad_array_length);\n        return offset;\n    }\n    offset += len;\n\n    /*\n     * Compact arrays store count+1\n     * https://cwiki.apache.org/confluence/display/KAFKA/KIP-482%3A+The+Kafka+Protocol+should+Support+Optional+Tagged+Fields\n     */\n    offset = dissect_kafka_array_elements(tree, tvb, pinfo, offset, api_version, func, (int)count - 1);\n\n    if (p_count != NULL) *p_count = (int)count - 1;\n\n    return offset;\n}",
        "func": "static int\ndissect_kafka_compact_array(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                        kafka_api_version_t api_version,\n                        int(*func)(tvbuff_t*, packet_info*, proto_tree*, int, kafka_api_version_t),\n                        int *p_count)\n{\n    gint64 count;\n    gint32 len;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &count, ENC_VARINT_PROTOBUF);\n    if (len == 0) {\n        expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    }\n    if(count > 0x7ffffffL) {\n        expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_kafka_bad_array_length);\n        return offset + len;\n    }\n    offset += len;\n\n    /*\n     * Compact arrays store count+1\n     * https://cwiki.apache.org/confluence/display/KAFKA/KIP-482%3A+The+Kafka+Protocol+should+Support+Optional+Tagged+Fields\n     */\n    offset = dissect_kafka_array_elements(tree, tvb, pinfo, offset, api_version, func, (int)count - 1);\n\n    if (p_count != NULL) *p_count = (int)count - 1;\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,9 +8,13 @@\n     gint32 len;\n \n     len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &count, ENC_VARINT_PROTOBUF);\n-    if (len == 0 || count > 0x7ffffffL) {\n+    if (len == 0) {\n+        expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_kafka_bad_varint);\n+        return tvb_captured_length(tvb);\n+    }\n+    if(count > 0x7ffffffL) {\n         expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_kafka_bad_array_length);\n-        return offset;\n+        return offset + len;\n     }\n     offset += len;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (len == 0 || count > 0x7ffffffL) {",
                "        return offset;"
            ],
            "added_lines": [
                "    if (len == 0) {",
                "        expert_add_info(pinfo, proto_tree_get_parent(tree), &ei_kafka_bad_varint);",
                "        return tvb_captured_length(tvb);",
                "    }",
                "    if(count > 0x7ffffffL) {",
                "        return offset + len;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_compact_string",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_compact_string(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                             int *p_offset, int *p_length)\n{\n    guint len;\n    guint64 length;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &length, ENC_VARINT_PROTOBUF);\n\n    if (len == 0) {\n        pi = proto_tree_add_item(tree, hf_item, tvb, offset, 0, ENC_NA);\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        if (p_offset) {\n            *p_offset = 0;\n        }\n        if (p_length) {\n            *p_length = 0;\n        }\n        return offset;\n    }\n\n    if (length == 0) {\n        proto_tree_add_string(tree, hf_item, tvb, offset, len, NULL);\n    } else {\n        proto_tree_add_string(tree, hf_item, tvb, offset, len + (gint)length - 1,\n                              kafka_tvb_get_string(pinfo->pool, tvb, offset + len, (gint)length - 1));\n    }\n\n    if (p_offset != NULL) *p_offset = offset + len;\n    if (p_length != NULL) *p_length = (gint)length - 1;\n\n    offset += len;\n    if (length > 0) {\n        offset += (gint)length - 1;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_kafka_compact_string(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                             int *p_offset, int *p_length)\n{\n    guint len;\n    guint64 length;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &length, ENC_VARINT_PROTOBUF);\n\n    if (len == 0) {\n        pi = proto_tree_add_item(tree, hf_item, tvb, offset, 0, ENC_NA);\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    }\n\n    if (length == 0) {\n        proto_tree_add_string(tree, hf_item, tvb, offset, len, NULL);\n    } else {\n        proto_tree_add_string(tree, hf_item, tvb, offset, len + (gint)length - 1,\n                              kafka_tvb_get_string(pinfo->pool, tvb, offset + len, (gint)length - 1));\n    }\n\n    if (p_offset != NULL) *p_offset = offset + len;\n    if (p_length != NULL) *p_length = (gint)length - 1;\n\n    offset += len;\n    if (length > 0) {\n        offset += (gint)length - 1;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,13 +11,7 @@\n     if (len == 0) {\n         pi = proto_tree_add_item(tree, hf_item, tvb, offset, 0, ENC_NA);\n         expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n-        if (p_offset) {\n-            *p_offset = 0;\n-        }\n-        if (p_length) {\n-            *p_length = 0;\n-        }\n-        return offset;\n+        return tvb_captured_length(tvb);\n     }\n \n     if (length == 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "        if (p_offset) {",
                "            *p_offset = 0;",
                "        }",
                "        if (p_length) {",
                "            *p_length = 0;",
                "        }",
                "        return offset;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_record",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_record(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int start_offset, guint64 base_offset, guint64 first_timestamp)\n{\n    proto_item *record_ti;\n    proto_tree *subtree;\n\n    gint64     size;\n    guint      len;\n\n    int offset, end_offset;\n    gboolean   invalid;\n\n    offset = start_offset;\n\n    subtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_kafka_record, &record_ti, \"Record\");\n\n    len = tvb_get_varint(tvb, offset, 5, &size, ENC_VARINT_ZIGZAG);\n    if (len == 0) {\n        expert_add_info(pinfo, record_ti, &ei_kafka_bad_varint);\n        return offset;\n    } else if (size < 6) {\n        expert_add_info(pinfo, record_ti, &ei_kafka_bad_record_length);\n        return offset + len;\n    }\n\n    end_offset = offset + len + (gint)size;\n    offset += len;\n\n    proto_tree_add_item(subtree, hf_kafka_record_attributes, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    offset = dissect_kafka_timestamp_delta(tvb, pinfo, subtree, hf_kafka_message_timestamp, offset, first_timestamp);\n    offset = dissect_kafka_offset_delta(tvb, pinfo, subtree, hf_kafka_offset, offset, base_offset);\n\n    offset = dissect_kafka_bytes_new(tvb, pinfo, subtree, hf_kafka_message_key, offset, NULL, NULL, &invalid);\n    if (invalid)\n        return end_offset;\n    offset = dissect_kafka_bytes_new(tvb, pinfo, subtree, hf_kafka_message_value, offset, NULL, NULL, &invalid);\n    if (invalid)\n        return end_offset;\n\n    offset = dissect_kafka_record_headers(tvb, pinfo, subtree, offset);\n\n    if (offset != end_offset) {\n        expert_add_info(pinfo, record_ti, &ei_kafka_bad_record_length);\n    }\n\n    proto_item_set_end(record_ti, tvb, end_offset);\n\n    return end_offset;\n}",
        "func": "static int\ndissect_kafka_record(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int start_offset, guint64 base_offset, guint64 first_timestamp)\n{\n    proto_item *record_ti;\n    proto_tree *subtree;\n\n    gint64     size;\n    guint      len;\n\n    int offset, end_offset;\n    gboolean   invalid;\n\n    offset = start_offset;\n\n    subtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_kafka_record, &record_ti, \"Record\");\n\n    len = tvb_get_varint(tvb, offset, 5, &size, ENC_VARINT_ZIGZAG);\n    if (len == 0) {\n        expert_add_info(pinfo, record_ti, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    } else if (size < 6) {\n        expert_add_info(pinfo, record_ti, &ei_kafka_bad_record_length);\n        return offset + len;\n    }\n\n    end_offset = offset + len + (gint)size;\n    offset += len;\n\n    proto_tree_add_item(subtree, hf_kafka_record_attributes, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    offset = dissect_kafka_timestamp_delta(tvb, pinfo, subtree, hf_kafka_message_timestamp, offset, first_timestamp);\n    offset = dissect_kafka_offset_delta(tvb, pinfo, subtree, hf_kafka_offset, offset, base_offset);\n\n    offset = dissect_kafka_bytes_new(tvb, pinfo, subtree, hf_kafka_message_key, offset, NULL, NULL, &invalid);\n    if (invalid)\n        return end_offset;\n    offset = dissect_kafka_bytes_new(tvb, pinfo, subtree, hf_kafka_message_value, offset, NULL, NULL, &invalid);\n    if (invalid)\n        return end_offset;\n\n    offset = dissect_kafka_record_headers(tvb, pinfo, subtree, offset);\n\n    if (offset != end_offset) {\n        expert_add_info(pinfo, record_ti, &ei_kafka_bad_record_length);\n    }\n\n    proto_item_set_end(record_ti, tvb, end_offset);\n\n    return end_offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n     len = tvb_get_varint(tvb, offset, 5, &size, ENC_VARINT_ZIGZAG);\n     if (len == 0) {\n         expert_add_info(pinfo, record_ti, &ei_kafka_bad_varint);\n-        return offset;\n+        return tvb_captured_length(tvb);\n     } else if (size < 6) {\n         expert_add_info(pinfo, record_ti, &ei_kafka_bad_record_length);\n         return offset + len;",
        "diff_line_info": {
            "deleted_lines": [
                "        return offset;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_compact_bytes",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_compact_bytes(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                    int *p_offset, int *p_length)\n{\n    guint len;\n    guint64 length;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &length, ENC_VARINT_PROTOBUF);\n\n    if (len == 0) {\n        pi = proto_tree_add_item(tree, hf_item, tvb, offset, 0, ENC_NA);\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        if (p_offset) {\n            *p_offset = 0;\n        }\n        if (p_length) {\n            *p_length = 0;\n        }\n        return offset;\n    }\n\n    if (length == 0) {\n        proto_tree_add_bytes_with_length(tree, hf_item, tvb, offset, len, NULL, 0);\n    } else {\n        proto_tree_add_bytes_with_length(tree, hf_item, tvb, offset, len + (gint)length - 1,\n                                         tvb_get_ptr(tvb, offset + len, (gint)length - 1),\n                                         (gint)length - 1);\n    }\n\n    if (p_offset != NULL) *p_offset = offset + len;\n    if (p_length != NULL) *p_length = (gint)length - 1;\n\n    if (length == 0) {\n        offset += len;\n    } else {\n        offset += len + (gint)length - 1;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_kafka_compact_bytes(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                    int *p_offset, int *p_length)\n{\n    guint len;\n    guint64 length;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &length, ENC_VARINT_PROTOBUF);\n\n    if (len == 0) {\n        pi = proto_tree_add_item(tree, hf_item, tvb, offset, 0, ENC_NA);\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    }\n\n    if (length == 0) {\n        proto_tree_add_bytes_with_length(tree, hf_item, tvb, offset, len, NULL, 0);\n    } else {\n        proto_tree_add_bytes_with_length(tree, hf_item, tvb, offset, len + (gint)length - 1,\n                                         tvb_get_ptr(tvb, offset + len, (gint)length - 1),\n                                         (gint)length - 1);\n    }\n\n    if (p_offset != NULL) *p_offset = offset + len;\n    if (p_length != NULL) *p_length = (gint)length - 1;\n\n    if (length == 0) {\n        offset += len;\n    } else {\n        offset += len + (gint)length - 1;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,13 +11,7 @@\n     if (len == 0) {\n         pi = proto_tree_add_item(tree, hf_item, tvb, offset, 0, ENC_NA);\n         expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n-        if (p_offset) {\n-            *p_offset = 0;\n-        }\n-        if (p_length) {\n-            *p_length = 0;\n-        }\n-        return offset;\n+        return tvb_captured_length(tvb);\n     }\n \n     if (length == 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "        if (p_offset) {",
                "            *p_offset = 0;",
                "        }",
                "        if (p_length) {",
                "            *p_length = 0;",
                "        }",
                "        return offset;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_bytes_new",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_bytes_new(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, int *p_bytes_offset, int *p_bytes_length, gboolean *p_invalid)\n{\n    gint64     val;\n    guint      len;\n    proto_item *pi;\n\n    *p_invalid = FALSE;\n\n    len = tvb_get_varint(tvb, offset, 5, &val, ENC_VARINT_ZIGZAG);\n\n    if (len == 0) {\n        pi = proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        len = 5;\n        val = 0;\n    } else if (val > 0) {\n        // there is payload available, possibly with 0 octets\n        proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_NA);\n    } else if (val == 0) {\n        // there is empty payload (0 octets)\n        proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<EMPTY>\");\n    } else if (val == -1) {\n        // there is no payload (null)\n        proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<NULL>\");\n        val = 0;\n    } else {\n        pi = proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n        expert_add_info(pinfo, pi, &ei_kafka_bad_bytes_length);\n        val = 0;\n        *p_invalid = TRUE;\n    }\n\n    if (p_bytes_offset != NULL) {\n        *p_bytes_offset = offset+len;\n    }\n    if (p_bytes_length != NULL) {\n        *p_bytes_length = (gint)val;\n    }\n    return offset+len+(gint)val;\n}",
        "func": "static int\ndissect_kafka_bytes_new(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, int *p_bytes_offset, int *p_bytes_length, gboolean *p_invalid)\n{\n    gint64     val;\n    guint      len;\n    proto_item *pi;\n\n    *p_invalid = FALSE;\n\n    len = tvb_get_varint(tvb, offset, 5, &val, ENC_VARINT_ZIGZAG);\n\n    if (len == 0) {\n        pi = proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    } else if (val > 0) {\n        // there is payload available, possibly with 0 octets\n        proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_NA);\n    } else if (val == 0) {\n        // there is empty payload (0 octets)\n        proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<EMPTY>\");\n    } else if (val == -1) {\n        // there is no payload (null)\n        proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<NULL>\");\n        val = 0;\n    } else {\n        pi = proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n        expert_add_info(pinfo, pi, &ei_kafka_bad_bytes_length);\n        val = 0;\n        *p_invalid = TRUE;\n    }\n\n    if (p_bytes_offset != NULL) {\n        *p_bytes_offset = offset+len;\n    }\n    if (p_bytes_length != NULL) {\n        *p_bytes_length = (gint)val;\n    }\n    return offset+len+(gint)val;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,7 @@\n     if (len == 0) {\n         pi = proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n         expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n-        len = 5;\n-        val = 0;\n+        return tvb_captured_length(tvb);\n     } else if (val > 0) {\n         // there is payload available, possibly with 0 octets\n         proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_NA);",
        "diff_line_info": {
            "deleted_lines": [
                "        len = 5;",
                "        val = 0;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_record_headers",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_record_headers(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset)\n{\n    proto_item *record_headers_ti;\n    proto_tree *subtree;\n    gint64     count;\n    guint      len;\n    int        i;\n    gboolean   invalid = FALSE;\n\n    subtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_kafka_record_headers, &record_headers_ti, \"Headers\");\n\n    len = tvb_get_varint(tvb, offset, 5, &count, ENC_VARINT_ZIGZAG);\n    if (len == 0) {\n        expert_add_info(pinfo, record_headers_ti, &ei_kafka_bad_varint);\n        len = 5;\n    } else if (count < -1) { // -1 means null array\n        expert_add_info(pinfo, record_headers_ti, &ei_kafka_bad_array_length);\n    }\n\n    offset += len;\n    for (i = 0; i < count && !invalid; i++) {\n        offset = dissect_kafka_record_headers_header(tvb, pinfo, subtree, offset, &invalid);\n    }\n\n    proto_item_set_end(record_headers_ti, tvb, offset);\n\n    return offset;\n}",
        "func": "static int\ndissect_kafka_record_headers(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset)\n{\n    proto_item *record_headers_ti;\n    proto_tree *subtree;\n    gint64     count;\n    guint      len;\n    int        i;\n    gboolean   invalid = FALSE;\n\n    subtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_kafka_record_headers, &record_headers_ti, \"Headers\");\n\n    len = tvb_get_varint(tvb, offset, 5, &count, ENC_VARINT_ZIGZAG);\n    if (len == 0) {\n        expert_add_info(pinfo, record_headers_ti, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    } else if (count < -1) { // -1 means null array\n        expert_add_info(pinfo, record_headers_ti, &ei_kafka_bad_array_length);\n    }\n\n    offset += len;\n    for (i = 0; i < count && !invalid; i++) {\n        offset = dissect_kafka_record_headers_header(tvb, pinfo, subtree, offset, &invalid);\n    }\n\n    proto_item_set_end(record_headers_ti, tvb, offset);\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n     len = tvb_get_varint(tvb, offset, 5, &count, ENC_VARINT_ZIGZAG);\n     if (len == 0) {\n         expert_add_info(pinfo, record_headers_ti, &ei_kafka_bad_varint);\n-        len = 5;\n+        return tvb_captured_length(tvb);\n     } else if (count < -1) { // -1 means null array\n         expert_add_info(pinfo, record_headers_ti, &ei_kafka_bad_array_length);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        len = 5;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_varint",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_varint(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                     gint64 *p_value)\n{\n    gint64 value;\n    guint len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &value, ENC_VARINT_ZIGZAG);\n    pi = proto_tree_add_int64(tree, hf_item, tvb, offset, len, value);\n\n    if (len == 0) {\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return offset;\n    }\n\n    if (p_value != NULL) *p_value = value;\n\n    return offset + len;\n}",
        "func": "static int\ndissect_kafka_varint(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                     gint64 *p_value)\n{\n    gint64 value;\n    guint len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &value, ENC_VARINT_ZIGZAG);\n    pi = proto_tree_add_int64(tree, hf_item, tvb, offset, len, value);\n\n    if (len == 0) {\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    }\n\n    if (p_value != NULL) *p_value = value;\n\n    return offset + len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \n     if (len == 0) {\n         expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n-        return offset;\n+        return tvb_captured_length(tvb);\n     }\n \n     if (p_value != NULL) *p_value = value;",
        "diff_line_info": {
            "deleted_lines": [
                "        return offset;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_timestamp_delta",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_timestamp_delta(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, guint64 first_timestamp)\n{\n    nstime_t   nstime;\n    guint64    milliseconds;\n    guint64    val;\n    guint      len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &val, ENC_VARINT_ZIGZAG);\n\n    milliseconds = first_timestamp + val;\n    nstime.secs  = (time_t) (milliseconds / 1000);\n    nstime.nsecs = (int) ((milliseconds % 1000) * 1000000);\n\n    pi = proto_tree_add_time(tree, hf_item, tvb, offset, len, &nstime);\n    if (len == 0) {\n        //This will probably lead to a malformed packet, but it's better than not incrementing the offset\n        len = FT_VARINT_MAX_LEN;\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n    }\n\n    return offset+len;\n}",
        "func": "static int\ndissect_kafka_timestamp_delta(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, guint64 first_timestamp)\n{\n    nstime_t   nstime;\n    guint64    milliseconds;\n    guint64    val;\n    guint      len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &val, ENC_VARINT_ZIGZAG);\n\n    milliseconds = first_timestamp + val;\n    nstime.secs  = (time_t) (milliseconds / 1000);\n    nstime.nsecs = (int) ((milliseconds % 1000) * 1000000);\n\n    pi = proto_tree_add_time(tree, hf_item, tvb, offset, len, &nstime);\n    if (len == 0) {\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    }\n\n    return offset+len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,9 +15,8 @@\n \n     pi = proto_tree_add_time(tree, hf_item, tvb, offset, len, &nstime);\n     if (len == 0) {\n-        //This will probably lead to a malformed packet, but it's better than not incrementing the offset\n-        len = FT_VARINT_MAX_LEN;\n         expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n+        return tvb_captured_length(tvb);\n     }\n \n     return offset+len;",
        "diff_line_info": {
            "deleted_lines": [
                "        //This will probably lead to a malformed packet, but it's better than not incrementing the offset",
                "        len = FT_VARINT_MAX_LEN;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_offset_delta",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_offset_delta(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, guint64 base_offset)\n{\n    gint64     val;\n    guint      len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &val, ENC_VARINT_ZIGZAG);\n\n    pi = proto_tree_add_int64(tree, hf_item, tvb, offset, len, base_offset+val);\n    if (len == 0) {\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return offset;\n    }\n\n    return offset+len;\n}",
        "func": "static int\ndissect_kafka_offset_delta(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, guint64 base_offset)\n{\n    gint64     val;\n    guint      len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &val, ENC_VARINT_ZIGZAG);\n\n    pi = proto_tree_add_int64(tree, hf_item, tvb, offset, len, base_offset+val);\n    if (len == 0) {\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    }\n\n    return offset+len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n     pi = proto_tree_add_int64(tree, hf_item, tvb, offset, len, base_offset+val);\n     if (len == 0) {\n         expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n-        return offset;\n+        return tvb_captured_length(tvb);\n     }\n \n     return offset+len;",
        "diff_line_info": {
            "deleted_lines": [
                "        return offset;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_tagged_field_data",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_tagged_field_data(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                                int *p_offset, int *p_len)\n{\n    proto_item *pi;\n\n    guint64 length;\n    gint32 len;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &length, ENC_VARINT_PROTOBUF);\n    if (len == 0) length = 0;\n\n    pi = proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)length, ENC_NA);\n    if (len == 0) {\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        if (p_offset) {\n            *p_offset = 0;\n        }\n        if (p_len) {\n            *p_len = 0;\n        }\n        return offset;\n    }\n\n    offset = offset + len + (gint)length;\n    if (p_offset != NULL) *p_offset = offset + len;\n    if (p_len != NULL) *p_len = (int)length;\n\n    return offset;\n}",
        "func": "static int\ndissect_kafka_tagged_field_data(proto_tree *tree, int hf_item, tvbuff_t *tvb, packet_info *pinfo, int offset,\n                                int *p_offset, int *p_len)\n{\n    proto_item *pi;\n\n    guint64 length;\n    gint32 len;\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &length, ENC_VARINT_PROTOBUF);\n    if (len == 0) length = 0;\n\n    pi = proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)length, ENC_NA);\n    if (len == 0) {\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    }\n\n    offset = offset + len + (gint)length;\n    if (p_offset != NULL) *p_offset = offset + len;\n    if (p_len != NULL) *p_len = (int)length;\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,13 +13,7 @@\n     pi = proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)length, ENC_NA);\n     if (len == 0) {\n         expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n-        if (p_offset) {\n-            *p_offset = 0;\n-        }\n-        if (p_len) {\n-            *p_len = 0;\n-        }\n-        return offset;\n+        return tvb_captured_length(tvb);\n     }\n \n     offset = offset + len + (gint)length;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (p_offset) {",
                "            *p_offset = 0;",
                "        }",
                "        if (p_len) {",
                "            *p_len = 0;",
                "        }",
                "        return offset;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_string_new",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_string_new(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, int *p_string_offset, int *p_string_length)\n{\n    gint64 val;\n    guint len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, 5, &val, ENC_VARINT_ZIGZAG);\n\n    if (len == 0) {\n        pi = proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        len = 5;\n        val = 0;\n    } else if (val > 0) {\n        // there is payload available, possibly with 0 octets\n        proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_UTF_8);\n    } else if (val == 0) {\n        // there is empty payload (0 octets)\n        proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<EMPTY>\");\n    } else if (val == -1) {\n        // there is no payload (null)\n        proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<NULL>\");\n        val = 0;\n    } else {\n        pi = proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n        expert_add_info(pinfo, pi, &ei_kafka_bad_string_length);\n        val = 0;\n    }\n\n    if (p_string_offset != NULL) {\n        *p_string_offset = offset+len;\n    }\n    if (p_string_length != NULL) {\n        *p_string_length = (gint)val;\n    }\n\n    return offset+len+(gint)val;\n}",
        "func": "static int\ndissect_kafka_string_new(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, int *p_string_offset, int *p_string_length)\n{\n    gint64 val;\n    guint len;\n    proto_item *pi;\n\n    len = tvb_get_varint(tvb, offset, 5, &val, ENC_VARINT_ZIGZAG);\n\n    if (len == 0) {\n        pi = proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n        expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n    } else if (val > 0) {\n        // there is payload available, possibly with 0 octets\n        proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_UTF_8);\n    } else if (val == 0) {\n        // there is empty payload (0 octets)\n        proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<EMPTY>\");\n    } else if (val == -1) {\n        // there is no payload (null)\n        proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<NULL>\");\n        val = 0;\n    } else {\n        pi = proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n        expert_add_info(pinfo, pi, &ei_kafka_bad_string_length);\n        val = 0;\n    }\n\n    if (p_string_offset != NULL) {\n        *p_string_offset = offset+len;\n    }\n    if (p_string_length != NULL) {\n        *p_string_length = (gint)val;\n    }\n\n    return offset+len+(gint)val;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,7 @@\n     if (len == 0) {\n         pi = proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, \"<INVALID>\");\n         expert_add_info(pinfo, pi, &ei_kafka_bad_varint);\n-        len = 5;\n-        val = 0;\n+        return tvb_captured_length(tvb);\n     } else if (val > 0) {\n         // there is payload available, possibly with 0 octets\n         proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_UTF_8);",
        "diff_line_info": {
            "deleted_lines": [
                "        len = 5;",
                "        val = 0;"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4190",
        "func_name": "wireshark/dissect_kafka_tagged_fields",
        "description": "Large loop in the Kafka dissector in Wireshark 3.6.0 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a03f43645d072b7caaa9b204067095481137a2a0",
        "commit_title": "Kafka: Be more strict when dissecting varints.",
        "commit_text": " The Kafka dissector uses the return value of tvb_get_varint to advance the packet offset in many places. If tvb_get_varint fails it returns 0, which means our offset isn't guaranteed to advance. Stop dissection whenever that happens. Fixes #17811. ",
        "func_before": "static int\ndissect_kafka_tagged_fields(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset,\n                               kafka_api_version_t api_version _U_)\n{\n    gint64 count;\n    guint len;\n    proto_item *subti;\n    proto_tree *subtree;\n\n    subtree = proto_tree_add_subtree(tree, tvb, offset, -1,\n                                     ett_kafka_tagged_fields,\n                                     &subti, \"Tagged fields\");\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &count, ENC_VARINT_PROTOBUF);\n    if (len == 0) {\n        expert_add_info(pinfo, subtree, &ei_kafka_bad_varint);\n        return offset;\n    }\n    offset += len;\n\n    /*\n     * Contrary to compact arrays, tagged fields store just count\n     * https://cwiki.apache.org/confluence/display/KAFKA/KIP-482%3A+The+Kafka+Protocol+should+Support+Optional+Tagged+Fields\n     */\n    offset = dissect_kafka_array_elements(subtree, tvb, pinfo, offset, api_version, &dissect_kafka_tagged_field, (gint32)count);\n\n    proto_item_set_end(subti, tvb, offset);\n\n    return offset;\n}",
        "func": "static int\ndissect_kafka_tagged_fields(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset,\n                               kafka_api_version_t api_version _U_)\n{\n    gint64 count;\n    guint len;\n    proto_item *subti;\n    proto_tree *subtree;\n\n    subtree = proto_tree_add_subtree(tree, tvb, offset, -1,\n                                     ett_kafka_tagged_fields,\n                                     &subti, \"Tagged fields\");\n\n    len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &count, ENC_VARINT_PROTOBUF);\n    if (len == 0) {\n        expert_add_info(pinfo, subtree, &ei_kafka_bad_varint);\n        return tvb_captured_length(tvb);\n   }\n    offset += len;\n\n    /*\n     * Contrary to compact arrays, tagged fields store just count\n     * https://cwiki.apache.org/confluence/display/KAFKA/KIP-482%3A+The+Kafka+Protocol+should+Support+Optional+Tagged+Fields\n     */\n    offset = dissect_kafka_array_elements(subtree, tvb, pinfo, offset, api_version, &dissect_kafka_tagged_field, (gint32)count);\n\n    proto_item_set_end(subti, tvb, offset);\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,8 +14,8 @@\n     len = tvb_get_varint(tvb, offset, FT_VARINT_MAX_LEN, &count, ENC_VARINT_PROTOBUF);\n     if (len == 0) {\n         expert_add_info(pinfo, subtree, &ei_kafka_bad_varint);\n-        return offset;\n-    }\n+        return tvb_captured_length(tvb);\n+   }\n     offset += len;\n \n     /*",
        "diff_line_info": {
            "deleted_lines": [
                "        return offset;",
                "    }"
            ],
            "added_lines": [
                "        return tvb_captured_length(tvb);",
                "   }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-35573",
        "func_name": "roehling/postsrsd/srs_timestamp_check",
        "description": "srs2.c in PostSRSd before 1.10 allows remote attackers to cause a denial of service (CPU consumption) via a long timestamp tag in an SRS address.",
        "git_url": "https://github.com/roehling/postsrsd/commit/4733fb11f6bec6524bb8518c5e1a699288c26bac",
        "commit_title": "SECURITY: Fix potential denial of service attack against PostSRSd",
        "commit_text": " I discovered that PostSRSd could be tricked into consuming a lot of CPU time with an SRS address that has an excessively long time stamp tag, e.g.  SRS0=HHHH=TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT=0@example.com",
        "func_before": "int\nsrs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\n\t/* We had better go around this loop exactly twice! */\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}",
        "func": "int\nsrs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\n\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n\t/* We had better go around this loop exactly twice! */\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n \ttime_t\t\t now;\n \ttime_t\t\t then;\n \n+\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n \t/* We had better go around this loop exactly twice! */\n \tthen = 0;\n \tfor (sp = stamp; *sp; sp++) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28950",
        "func_name": "torvalds/linux/fuse_make_bad",
        "description": "An issue was discovered in fs/fuse/fuse_i.h in the Linux kernel before 5.11.8. A \"stall on CPU\" can occur because a retry loop continually finds the same bad inode, aka CID-775c5033a0d1.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=775c5033a0d164622d9d10dd0f0a5531639ed3ed",
        "commit_title": "Commit 5d069dbe8aaf (\"fuse: fix bad inode\") replaced make_bad_inode()",
        "commit_text": "in fuse_iget() with a private implementation fuse_make_bad().  The private implementation fails to remove the bad inode from inode cache, so the retry loop with iget5_locked() finds the same bad inode and marks it bad forever.  kmsg snip:  [ ] rcu: INFO: rcu_sched self-detected stall on CPU ... [ ]  ? bit_wait_io+0x50/0x50 [ ]  ? fuse_init_file_inode+0x70/0x70 [ ]  ? find_inode.isra.32+0x60/0xb0 [ ]  ? fuse_init_file_inode+0x70/0x70 [ ]  ilookup5_nowait+0x65/0x90 [ ]  ? fuse_init_file_inode+0x70/0x70 [ ]  ilookup5.part.36+0x2e/0x80 [ ]  ? fuse_init_file_inode+0x70/0x70 [ ]  ? fuse_inode_eq+0x20/0x20 [ ]  iget5_locked+0x21/0x80 [ ]  ? fuse_inode_eq+0x20/0x20 [ ]  fuse_iget+0x96/0x1b0  Cc: stable@vger.kernel.org # 5.10+ ",
        "func_before": "static inline void fuse_make_bad(struct inode *inode)\n{\n\tset_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);\n}",
        "func": "static inline void fuse_make_bad(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\tset_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n static inline void fuse_make_bad(struct inode *inode)\n {\n+\tremove_inode_hash(inode);\n \tset_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tremove_inode_hash(inode);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9133",
        "func_name": "ImageMagick/EncodeLabImage",
        "description": "ImageMagick 7.0.7-26 Q16 has excessive iteration in the DecodeLabImage and EncodeLabImage functions (coders/tiff.c), which results in a hang (tens of minutes) with a tiny PoC file. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted tiff file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/19b96ba61431914e2ac316b72c0789965f2b7c09",
        "commit_title": "Use break instead of continue (fixes #1072)",
        "commit_text": "",
        "func_before": "static MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}",
        "func": "static MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,13 +19,11 @@\n     register ssize_t\n       x;\n \n-    if (status == MagickFalse)\n-      continue;\n     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n     if (q == (Quantum *) NULL)\n       {\n         status=MagickFalse;\n-        continue;\n+        break;\n       }\n     for (x=0; x < (ssize_t) image->columns; x++)\n     {\n@@ -44,7 +42,10 @@\n       q+=GetPixelChannels(image);\n     }\n     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n-      status=MagickFalse;\n+      {\n+        status=MagickFalse;\n+        break;\n+      }\n   }\n   image_view=DestroyCacheView(image_view);\n   return(status);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (status == MagickFalse)",
                "      continue;",
                "        continue;",
                "      status=MagickFalse;"
            ],
            "added_lines": [
                "        break;",
                "      {",
                "        status=MagickFalse;",
                "        break;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9261",
        "func_name": "wireshark/dissect_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the NBAP dissector could crash with a large loop that ends with a heap-based buffer overflow. This was addressed in epan/dissectors/packet-nbap.c by prohibiting the self-linking of DCH-IDs.",
        "git_url": "https://github.com/wireshark/wireshark/commit/66bc372716e04d6a8afdf6712583c9b5d11fee55",
        "commit_title": "NBAP: avoid linking a DCH-ID to itself",
        "commit_text": " Otherwise it can create an infinite loop, leading to a buffer overflow. Also add explicit cheks on the buffer usage and set its maximum size to 128 instead of 32 per ASN.1 description.  Bug: 14471 (cherry picked from commit 1c9adc63c2c2892a3f069777dfb8c66f79b9ba38) Conflicts: \tepan/dissectors/asn1/nbap/nbap.cnf \tepan/dissectors/packet-nbap.c \tepan/dissectors/packet-umts_fp.h",
        "func_before": "static int\ndissect_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 928 \"./asn1/nbap/nbap.cnf\"\naddress     dst_addr, null_addr;\nconversation_t *conversation;\n\numts_fp_conversation_info_t *umts_fp_conversation_info;\nint i, j, num_tf;\n\ntransportLayerAddress_ipv4 = 0;\nBindingID_port = 0;\n\ntransportFormatSet_type = NBAP_CPCH;\n\n  offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,\n                                   ett_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD, FACH_ParametersItem_CTCH_SetupRqstFDD_sequence);\n\n\n        if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)\n        {\n            return offset;\n        }\n        clear_address(&null_addr);\n\n        set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);\n\n        conversation = find_conversation(actx->pinfo->num,&dst_addr,\n            &null_addr, PT_UDP, BindingID_port,\n            0, NO_ADDR_B|NO_PORT_B);\n\n        if (conversation == NULL) {\n            /* It's not part of any conversation - create a new one. */\n            conversation = conversation_new(actx->pinfo->num, &dst_addr,\n                &null_addr, PT_UDP,BindingID_port ,\n                0, NO_ADDR2|NO_PORT2);\n\n            /* Set dissector */\n            conversation_set_dissector(conversation, fp_handle);\n            if(actx->pinfo->link_dir==P2P_DIR_DL){\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n                /* Fill in the data */\n                umts_fp_conversation_info->iface_type        = IuB_Interface;\n                umts_fp_conversation_info->division          = Division_FDD;\n                umts_fp_conversation_info->channel           = CHANNEL_FACH_FDD;\n                umts_fp_conversation_info->dl_frame_number   = 0;\n                umts_fp_conversation_info->ul_frame_number   = actx->pinfo->num;\n                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);\n                umts_fp_conversation_info->crnc_port         = BindingID_port;\n                umts_fp_conversation_info->rlc_mode          = FP_RLC_MODE_UNKNOWN;\n                /*Save unique UE-identifier */\n                umts_fp_conversation_info->com_context_id = crcn_context_present ? com_context_id : 1;\n\n\n                /* DCH's in this flow */\n                umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;\n                /* Set data for First or single channel */\n                umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[commonphysicalchannelid].num_ul_chans;\n                for (j = 0; j < num_tf; j++) {\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[commonphysicalchannelid].ul_chan_tf_size[j];\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[commonphysicalchannelid].ul_chan_num_tbs[j];\n                }\n\n                /* Traffic flows per DCH(DL) */\n                umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[commonphysicalchannelid].num_dl_chans;\n                for (j = 0; j < num_tf; j++) {\n                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[commonphysicalchannelid].dl_chan_tf_size[j];\n                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[commonphysicalchannelid].dl_chan_num_tbs[j];\n                }\n\n                /* Set data for associated DCH's if we have any */\n                i = commonphysicalchannelid;\n                umts_fp_conversation_info->dchs_in_flow_list[0] = commonphysicalchannelid;\n                while(nbap_dch_chnl_info[i].next_dch != 0){\n                    i = nbap_dch_chnl_info[i].next_dch;\n                    umts_fp_conversation_info->num_dch_in_flow++;\n                    umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                    /* Traffic flows per DCH(UL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];\n                    }\n\n                    /* Traffic flows per DCH(DL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];\n                    }\n                }\n                umts_fp_conversation_info->num_dch_in_flow++;\n                umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                set_umts_fp_conv_data(conversation, umts_fp_conversation_info);\n            }\n\n        }\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 928 \"./asn1/nbap/nbap.cnf\"\naddress     dst_addr, null_addr;\nconversation_t *conversation;\n\numts_fp_conversation_info_t *umts_fp_conversation_info;\nint i, j, num_tf;\n\ntransportLayerAddress_ipv4 = 0;\nBindingID_port = 0;\n\ntransportFormatSet_type = NBAP_CPCH;\n\n  offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,\n                                   ett_nbap_FACH_ParametersItem_CTCH_SetupRqstFDD, FACH_ParametersItem_CTCH_SetupRqstFDD_sequence);\n\n\n        if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)\n        {\n            return offset;\n        }\n        clear_address(&null_addr);\n\n        set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);\n\n        conversation = find_conversation(actx->pinfo->num,&dst_addr,\n            &null_addr, PT_UDP, BindingID_port,\n            0, NO_ADDR_B|NO_PORT_B);\n\n        if (conversation == NULL) {\n            /* It's not part of any conversation - create a new one. */\n            conversation = conversation_new(actx->pinfo->num, &dst_addr,\n                &null_addr, PT_UDP,BindingID_port ,\n                0, NO_ADDR2|NO_PORT2);\n\n            /* Set dissector */\n            conversation_set_dissector(conversation, fp_handle);\n            if(actx->pinfo->link_dir==P2P_DIR_DL){\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n                /* Fill in the data */\n                umts_fp_conversation_info->iface_type        = IuB_Interface;\n                umts_fp_conversation_info->division          = Division_FDD;\n                umts_fp_conversation_info->channel           = CHANNEL_FACH_FDD;\n                umts_fp_conversation_info->dl_frame_number   = 0;\n                umts_fp_conversation_info->ul_frame_number   = actx->pinfo->num;\n                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);\n                umts_fp_conversation_info->crnc_port         = BindingID_port;\n                umts_fp_conversation_info->rlc_mode          = FP_RLC_MODE_UNKNOWN;\n                /*Save unique UE-identifier */\n                umts_fp_conversation_info->com_context_id = crcn_context_present ? com_context_id : 1;\n\n\n                /* DCH's in this flow */\n                umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;\n                /* Set data for First or single channel */\n                umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[commonphysicalchannelid].num_ul_chans;\n                for (j = 0; j < num_tf; j++) {\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[commonphysicalchannelid].ul_chan_tf_size[j];\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[commonphysicalchannelid].ul_chan_num_tbs[j];\n                }\n\n                /* Traffic flows per DCH(DL) */\n                umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[commonphysicalchannelid].num_dl_chans;\n                for (j = 0; j < num_tf; j++) {\n                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[commonphysicalchannelid].dl_chan_tf_size[j];\n                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[commonphysicalchannelid].dl_chan_num_tbs[j];\n                }\n\n                /* Set data for associated DCH's if we have any */\n                i = commonphysicalchannelid;\n                umts_fp_conversation_info->dchs_in_flow_list[0] = commonphysicalchannelid;\n                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){\n                    i = nbap_dch_chnl_info[i].next_dch;\n                    umts_fp_conversation_info->num_dch_in_flow++;\n                    umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                    /* Traffic flows per DCH(UL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];\n                    }\n\n                    /* Traffic flows per DCH(DL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];\n                    }\n                }\n                umts_fp_conversation_info->num_dch_in_flow++;\n                umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                set_umts_fp_conv_data(conversation, umts_fp_conversation_info);\n            }\n\n        }\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -70,7 +70,7 @@\n                 /* Set data for associated DCH's if we have any */\n                 i = commonphysicalchannelid;\n                 umts_fp_conversation_info->dchs_in_flow_list[0] = commonphysicalchannelid;\n-                while(nbap_dch_chnl_info[i].next_dch != 0){\n+                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){\n                     i = nbap_dch_chnl_info[i].next_dch;\n                     umts_fp_conversation_info->num_dch_in_flow++;\n                     umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;",
        "diff_line_info": {
            "deleted_lines": [
                "                while(nbap_dch_chnl_info[i].next_dch != 0){"
            ],
            "added_lines": [
                "                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9261",
        "func_name": "wireshark/dissect_nbap_RL_Specific_DCH_Info_Item",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the NBAP dissector could crash with a large loop that ends with a heap-based buffer overflow. This was addressed in epan/dissectors/packet-nbap.c by prohibiting the self-linking of DCH-IDs.",
        "git_url": "https://github.com/wireshark/wireshark/commit/66bc372716e04d6a8afdf6712583c9b5d11fee55",
        "commit_title": "NBAP: avoid linking a DCH-ID to itself",
        "commit_text": " Otherwise it can create an infinite loop, leading to a buffer overflow. Also add explicit cheks on the buffer usage and set its maximum size to 128 instead of 32 per ASN.1 description.  Bug: 14471 (cherry picked from commit 1c9adc63c2c2892a3f069777dfb8c66f79b9ba38) Conflicts: \tepan/dissectors/asn1/nbap/nbap.cnf \tepan/dissectors/packet-nbap.c \tepan/dissectors/packet-umts_fp.h",
        "func_before": "static int\ndissect_nbap_RL_Specific_DCH_Info_Item(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 1138 \"./asn1/nbap/nbap.cnf\"\naddress     dst_addr, null_addr;\nconversation_t *conversation = NULL;\numts_fp_conversation_info_t *umts_fp_conversation_info;\nint i, j, num_tf;\n\ntransportLayerAddress_ipv4 = 0;\nBindingID_port = 0;\ndch_id = 0xFFFFFFFF;\n\n  offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,\n                                   ett_nbap_RL_Specific_DCH_Info_Item, RL_Specific_DCH_Info_Item_sequence);\n\n\n        if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)\n        {\n            return offset;\n        }\n\n        /*RBS might sometimes send a nonsens bind, to indicate that no DCH is present*/\n        if(BindingID_port == NBAP_IGNORE_PORT){\n                return offset;\n        }\n\n        clear_address(&null_addr);\n\n        set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);\n\n        conversation = find_conversation(actx->pinfo->num,&dst_addr,\n            &null_addr, PT_UDP, BindingID_port,\n            0, NO_ADDR_B|NO_PORT_B);\n\n        if (conversation == NULL) {\n            /* It's not part of any conversation - create a new one. */\n            conversation = conversation_new(actx->pinfo->num, &dst_addr,\n                &null_addr, PT_UDP,BindingID_port ,\n                0, NO_ADDR2|NO_PORT2);\n\n            /* Set dissector */\n            conversation_set_dissector(conversation, fp_handle);\n            if(actx->pinfo->link_dir==P2P_DIR_DL){\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n\n                /* Fill in the data */\n                umts_fp_conversation_info->iface_type        = IuB_Interface;\n                umts_fp_conversation_info->division          = Division_FDD;\n                umts_fp_conversation_info->channel           = CHANNEL_DCH;\n                umts_fp_conversation_info->dl_frame_number   = 0;\n                umts_fp_conversation_info->ul_frame_number   = actx->pinfo->num;\n                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);\n                umts_fp_conversation_info->crnc_port         = BindingID_port;\n                umts_fp_conversation_info->rlc_mode          = FP_RLC_MODE_UNKNOWN;\n\n                /* DCH's in this flow */\n                umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;\n\n                /*Save unique UE-identifier */\n                umts_fp_conversation_info->com_context_id = com_context_id;\n\n                if (dch_id != 0xffffffff) {\n                    /*UPLINK*/\n                    /* Set data for First or single channel */\n                    umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[dch_id].num_ul_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[dch_id].ul_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[dch_id].ul_chan_num_tbs[j];\n                    }\n\n                    /* Traffic flows per DCH(DL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[dch_id].num_dl_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[dch_id].dl_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[dch_id].dl_chan_num_tbs[j];\n                    }\n\n                    /* Set data for associated DCH's if we have any */\n                    i = dch_id;\n                    umts_fp_conversation_info->dchs_in_flow_list[0] = dch_id;\n                    while(nbap_dch_chnl_info[i].next_dch != 0){\n\n\n                        i = nbap_dch_chnl_info[i].next_dch;\n                        umts_fp_conversation_info->num_dch_in_flow++;\n                        umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;   /*Set transport channel id*/\n\n                        /*Setting Logical Channel's for this DCH*/\n                        /* Traffic flows per DCH(UL) */\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;\n                        for (j = 0; j < num_tf; j++) {\n                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];\n                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];\n                        }\n\n                        /* Traffic flows per DCH(DL) */\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;\n                        for (j = 0; j < num_tf; j++) {\n                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];\n                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];\n                        }\n\n                    }\n                    umts_fp_conversation_info->num_dch_in_flow++;\n                    umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                    set_umts_fp_conv_data(conversation, umts_fp_conversation_info);\n                }\n            }\n\n            nbap_debug(\"Frame %u RL-Specific-DCH-Info-Item Start\", actx->pinfo->num);\n            nbap_debug(\"    Total no of ch in flow will be: %d\", umts_fp_conversation_info->num_dch_in_flow);\n            nbap_debug(\"Frame %u RL-Specific-DCH-Info-Item End\", actx->pinfo->num);\n\n        }\n\n\n\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_nbap_RL_Specific_DCH_Info_Item(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 1138 \"./asn1/nbap/nbap.cnf\"\naddress     dst_addr, null_addr;\nconversation_t *conversation = NULL;\numts_fp_conversation_info_t *umts_fp_conversation_info;\nint i, j, num_tf;\n\ntransportLayerAddress_ipv4 = 0;\nBindingID_port = 0;\ndch_id = 0xFFFFFFFF;\n\n  offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,\n                                   ett_nbap_RL_Specific_DCH_Info_Item, RL_Specific_DCH_Info_Item_sequence);\n\n\n        if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)\n        {\n            return offset;\n        }\n\n        /*RBS might sometimes send a nonsens bind, to indicate that no DCH is present*/\n        if(BindingID_port == NBAP_IGNORE_PORT){\n                return offset;\n        }\n\n        clear_address(&null_addr);\n\n        set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);\n\n        conversation = find_conversation(actx->pinfo->num,&dst_addr,\n            &null_addr, PT_UDP, BindingID_port,\n            0, NO_ADDR_B|NO_PORT_B);\n\n        if (conversation == NULL) {\n            /* It's not part of any conversation - create a new one. */\n            conversation = conversation_new(actx->pinfo->num, &dst_addr,\n                &null_addr, PT_UDP,BindingID_port ,\n                0, NO_ADDR2|NO_PORT2);\n\n            /* Set dissector */\n            conversation_set_dissector(conversation, fp_handle);\n            if(actx->pinfo->link_dir==P2P_DIR_DL){\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n\n                /* Fill in the data */\n                umts_fp_conversation_info->iface_type        = IuB_Interface;\n                umts_fp_conversation_info->division          = Division_FDD;\n                umts_fp_conversation_info->channel           = CHANNEL_DCH;\n                umts_fp_conversation_info->dl_frame_number   = 0;\n                umts_fp_conversation_info->ul_frame_number   = actx->pinfo->num;\n                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);\n                umts_fp_conversation_info->crnc_port         = BindingID_port;\n                umts_fp_conversation_info->rlc_mode          = FP_RLC_MODE_UNKNOWN;\n\n                /* DCH's in this flow */\n                umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;\n\n                /*Save unique UE-identifier */\n                umts_fp_conversation_info->com_context_id = com_context_id;\n\n                if (dch_id != 0xffffffff) {\n                    /*UPLINK*/\n                    /* Set data for First or single channel */\n                    umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[dch_id].num_ul_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[dch_id].ul_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[dch_id].ul_chan_num_tbs[j];\n                    }\n\n                    /* Traffic flows per DCH(DL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[dch_id].num_dl_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[dch_id].dl_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[dch_id].dl_chan_num_tbs[j];\n                    }\n\n                    /* Set data for associated DCH's if we have any */\n                    i = dch_id;\n                    umts_fp_conversation_info->dchs_in_flow_list[0] = dch_id;\n                    while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){\n\n\n                        i = nbap_dch_chnl_info[i].next_dch;\n                        umts_fp_conversation_info->num_dch_in_flow++;\n                        umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;   /*Set transport channel id*/\n\n                        /*Setting Logical Channel's for this DCH*/\n                        /* Traffic flows per DCH(UL) */\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;\n                        for (j = 0; j < num_tf; j++) {\n                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];\n                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];\n                        }\n\n                        /* Traffic flows per DCH(DL) */\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;\n                        for (j = 0; j < num_tf; j++) {\n                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];\n                            umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];\n                        }\n\n                    }\n                    umts_fp_conversation_info->num_dch_in_flow++;\n                    umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                    set_umts_fp_conv_data(conversation, umts_fp_conversation_info);\n                }\n            }\n\n            nbap_debug(\"Frame %u RL-Specific-DCH-Info-Item Start\", actx->pinfo->num);\n            nbap_debug(\"    Total no of ch in flow will be: %d\", umts_fp_conversation_info->num_dch_in_flow);\n            nbap_debug(\"Frame %u RL-Specific-DCH-Info-Item End\", actx->pinfo->num);\n\n        }\n\n\n\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -78,7 +78,7 @@\n                     /* Set data for associated DCH's if we have any */\n                     i = dch_id;\n                     umts_fp_conversation_info->dchs_in_flow_list[0] = dch_id;\n-                    while(nbap_dch_chnl_info[i].next_dch != 0){\n+                    while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){\n \n \n                         i = nbap_dch_chnl_info[i].next_dch;",
        "diff_line_info": {
            "deleted_lines": [
                "                    while(nbap_dch_chnl_info[i].next_dch != 0){"
            ],
            "added_lines": [
                "                    while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9261",
        "func_name": "wireshark/dissect_nbap_T_dCH_ID",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the NBAP dissector could crash with a large loop that ends with a heap-based buffer overflow. This was addressed in epan/dissectors/packet-nbap.c by prohibiting the self-linking of DCH-IDs.",
        "git_url": "https://github.com/wireshark/wireshark/commit/66bc372716e04d6a8afdf6712583c9b5d11fee55",
        "commit_title": "NBAP: avoid linking a DCH-ID to itself",
        "commit_text": " Otherwise it can create an infinite loop, leading to a buffer overflow. Also add explicit cheks on the buffer usage and set its maximum size to 128 instead of 32 per ASN.1 description.  Bug: 14471 (cherry picked from commit 1c9adc63c2c2892a3f069777dfb8c66f79b9ba38) Conflicts: \tepan/dissectors/asn1/nbap/nbap.cnf \tepan/dissectors/packet-nbap.c \tepan/dissectors/packet-umts_fp.h",
        "func_before": "static int\ndissect_nbap_T_dCH_ID(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 671 \"./asn1/nbap/nbap.cnf\"\n\n  offset = dissect_per_constrained_integer(tvb, offset, actx, tree, hf_index,\n                                                            0U, 255U, &dch_id, FALSE);\n\n    if(g_num_dch_in_flow>0){\n        g_dchs_in_flow_list[g_num_dch_in_flow-1]=dch_id;\n        nbap_dch_chnl_info[dch_id].next_dch = 0;\n        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff){\n            nbap_dch_chnl_info[prev_dch_id].next_dch = dch_id;\n        }\n    }\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_nbap_T_dCH_ID(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 671 \"./asn1/nbap/nbap.cnf\"\n\n  offset = dissect_per_constrained_integer(tvb, offset, actx, tree, hf_index,\n                                                            0U, 255U, &dch_id, FALSE);\n\n    if(g_num_dch_in_flow>0){\n        g_dchs_in_flow_list[g_num_dch_in_flow-1]=dch_id;\n        nbap_dch_chnl_info[dch_id].next_dch = 0;\n        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff && prev_dch_id != dch_id){\n            nbap_dch_chnl_info[prev_dch_id].next_dch = dch_id;\n        }\n    }\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n     if(g_num_dch_in_flow>0){\n         g_dchs_in_flow_list[g_num_dch_in_flow-1]=dch_id;\n         nbap_dch_chnl_info[dch_id].next_dch = 0;\n-        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff){\n+        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff && prev_dch_id != dch_id){\n             nbap_dch_chnl_info[prev_dch_id].next_dch = dch_id;\n         }\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff){"
            ],
            "added_lines": [
                "        if(prev_dch_id != 0 && prev_dch_id != 0xffffffff && prev_dch_id != dch_id){"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9261",
        "func_name": "wireshark/dissect_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the NBAP dissector could crash with a large loop that ends with a heap-based buffer overflow. This was addressed in epan/dissectors/packet-nbap.c by prohibiting the self-linking of DCH-IDs.",
        "git_url": "https://github.com/wireshark/wireshark/commit/66bc372716e04d6a8afdf6712583c9b5d11fee55",
        "commit_title": "NBAP: avoid linking a DCH-ID to itself",
        "commit_text": " Otherwise it can create an infinite loop, leading to a buffer overflow. Also add explicit cheks on the buffer usage and set its maximum size to 128 instead of 32 per ASN.1 description.  Bug: 14471 (cherry picked from commit 1c9adc63c2c2892a3f069777dfb8c66f79b9ba38) Conflicts: \tepan/dissectors/asn1/nbap/nbap.cnf \tepan/dissectors/packet-nbap.c \tepan/dissectors/packet-umts_fp.h",
        "func_before": "static int\ndissect_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 817 \"./asn1/nbap/nbap.cnf\"\n\naddress     dst_addr, null_addr;\nconversation_t *conversation;\n\numts_fp_conversation_info_t *umts_fp_conversation_info;\nint i, j, num_tf;\n\ntransportLayerAddress_ipv4 = 0;\nBindingID_port = 0;\n\n/* There can only be one item, set num_items here to collect the TransportFormatSet data */\nnum_items = 1;\n\n  offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,\n                                   ett_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD, PCH_ParametersItem_CTCH_SetupRqstFDD_sequence);\n\n\n        if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)\n        {\n            return offset;\n        }\n        clear_address(&null_addr);\n\n        set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);\n\n        conversation = find_conversation(actx->pinfo->num,&dst_addr,\n            &null_addr, PT_UDP, BindingID_port,\n            0, NO_ADDR_B|NO_PORT_B);\n\n        if (conversation == NULL) {\n            /* It's not part of any conversation - create a new one. */\n            conversation = conversation_new(actx->pinfo->num, &dst_addr,\n                &null_addr, PT_UDP,BindingID_port ,\n                0, NO_ADDR2|NO_PORT2);\n\n            /* Set dissector */\n            conversation_set_dissector(conversation, fp_handle);\n            if(actx->pinfo->link_dir==P2P_DIR_DL){\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n                /* Fill in the data */\n                umts_fp_conversation_info->iface_type         = IuB_Interface;\n                umts_fp_conversation_info->division           = Division_FDD;\n                umts_fp_conversation_info->channel            = CHANNEL_PCH;\n                umts_fp_conversation_info->dl_frame_number    = 0;\n                umts_fp_conversation_info->ul_frame_number    = actx->pinfo->num;\n                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);\n                umts_fp_conversation_info->crnc_port          = BindingID_port;\n                umts_fp_conversation_info->paging_indications = paging_indications;\n                umts_fp_conversation_info->rlc_mode           = FP_RLC_MODE_UNKNOWN;\n\n                /* DCH's in this flow */\n                umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;\n                /* Set data for First or single channel */\n                umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[commontransportchannelid].num_ul_chans;\n\n                nbap_debug(\"Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD Start: num_tf %u\",\n                        actx->pinfo->num,\n                        num_tf);\n\n                for (j = 0; j < num_tf; j++) {\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[commontransportchannelid].ul_chan_tf_size[j];\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[commontransportchannelid].ul_chan_num_tbs[j];\n                    nbap_debug(\"    UL tf %u ul_chan_tf_size %u\",j, nbap_dch_chnl_info[commontransportchannelid].ul_chan_tf_size[j]);\n                }\n\n                /* Traffic flows per DCH(DL) */\n                umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[commontransportchannelid].num_dl_chans;\n                for (j = 0; j < num_tf; j++) {\n                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[commontransportchannelid].dl_chan_tf_size[j];\n                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[commontransportchannelid].dl_chan_num_tbs[j];\n                    nbap_debug(\"    DL tf %u ul_chan_tf_size %u\",j, nbap_dch_chnl_info[commontransportchannelid].dl_chan_tf_size[j]);\n                }\n\n                /* Set data for associated DCH's if we have any */\n                i = commontransportchannelid;\n\n                nbap_debug(\"    commontransportchannelid %u next ch %u\",commontransportchannelid, nbap_dch_chnl_info[i].next_dch);\n\n                umts_fp_conversation_info->dchs_in_flow_list[0] = commontransportchannelid;\n                while(nbap_dch_chnl_info[i].next_dch != 0){\n                    i = nbap_dch_chnl_info[i].next_dch;\n                    umts_fp_conversation_info->num_dch_in_flow++;\n                    umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                    /* Traffic flows per DCH(UL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];\n                    }\n\n                    /* Traffic flows per DCH(DL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];\n                    }\n                }\n                umts_fp_conversation_info->num_dch_in_flow++;\n\n                nbap_debug(\"    num_dch_in_flow %u\", umts_fp_conversation_info->num_dch_in_flow);\n\n                umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                set_umts_fp_conv_data(conversation, umts_fp_conversation_info);\n\n                nbap_debug(\"Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD End\",\n                        actx->pinfo->num);\n\n            }\n\n        }\n\n\n\n\n  return offset;\n}",
        "func": "static int\ndissect_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n#line 817 \"./asn1/nbap/nbap.cnf\"\n\naddress     dst_addr, null_addr;\nconversation_t *conversation;\n\numts_fp_conversation_info_t *umts_fp_conversation_info;\nint i, j, num_tf;\n\ntransportLayerAddress_ipv4 = 0;\nBindingID_port = 0;\n\n/* There can only be one item, set num_items here to collect the TransportFormatSet data */\nnum_items = 1;\n\n  offset = dissect_per_sequence(tvb, offset, actx, tree, hf_index,\n                                   ett_nbap_PCH_ParametersItem_CTCH_SetupRqstFDD, PCH_ParametersItem_CTCH_SetupRqstFDD_sequence);\n\n\n        if (actx->pinfo->fd->flags.visited||transportLayerAddress_ipv4==0||BindingID_port == 0)\n        {\n            return offset;\n        }\n        clear_address(&null_addr);\n\n        set_address(&dst_addr, AT_IPv4, 4, &transportLayerAddress_ipv4);\n\n        conversation = find_conversation(actx->pinfo->num,&dst_addr,\n            &null_addr, PT_UDP, BindingID_port,\n            0, NO_ADDR_B|NO_PORT_B);\n\n        if (conversation == NULL) {\n            /* It's not part of any conversation - create a new one. */\n            conversation = conversation_new(actx->pinfo->num, &dst_addr,\n                &null_addr, PT_UDP,BindingID_port ,\n                0, NO_ADDR2|NO_PORT2);\n\n            /* Set dissector */\n            conversation_set_dissector(conversation, fp_handle);\n            if(actx->pinfo->link_dir==P2P_DIR_DL){\n                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t);\n                /* Fill in the data */\n                umts_fp_conversation_info->iface_type         = IuB_Interface;\n                umts_fp_conversation_info->division           = Division_FDD;\n                umts_fp_conversation_info->channel            = CHANNEL_PCH;\n                umts_fp_conversation_info->dl_frame_number    = 0;\n                umts_fp_conversation_info->ul_frame_number    = actx->pinfo->num;\n                copy_address_wmem(wmem_file_scope(), &(umts_fp_conversation_info->crnc_address), &dst_addr);\n                umts_fp_conversation_info->crnc_port          = BindingID_port;\n                umts_fp_conversation_info->paging_indications = paging_indications;\n                umts_fp_conversation_info->rlc_mode           = FP_RLC_MODE_UNKNOWN;\n\n                /* DCH's in this flow */\n                umts_fp_conversation_info->dch_crc_present = g_nbap_msg_info_for_fp.dch_crc_present;\n                /* Set data for First or single channel */\n                umts_fp_conversation_info->fp_dch_channel_info[0].num_ul_chans = num_tf = nbap_dch_chnl_info[commontransportchannelid].num_ul_chans;\n\n                nbap_debug(\"Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD Start: num_tf %u\",\n                        actx->pinfo->num,\n                        num_tf);\n\n                for (j = 0; j < num_tf; j++) {\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_tf_size[j] = nbap_dch_chnl_info[commontransportchannelid].ul_chan_tf_size[j];\n                    umts_fp_conversation_info->fp_dch_channel_info[0].ul_chan_num_tbs[j] = nbap_dch_chnl_info[commontransportchannelid].ul_chan_num_tbs[j];\n                    nbap_debug(\"    UL tf %u ul_chan_tf_size %u\",j, nbap_dch_chnl_info[commontransportchannelid].ul_chan_tf_size[j]);\n                }\n\n                /* Traffic flows per DCH(DL) */\n                umts_fp_conversation_info->fp_dch_channel_info[0].num_dl_chans = num_tf = nbap_dch_chnl_info[commontransportchannelid].num_dl_chans;\n                for (j = 0; j < num_tf; j++) {\n                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_tf_size[j] = nbap_dch_chnl_info[commontransportchannelid].dl_chan_tf_size[j];\n                    umts_fp_conversation_info->fp_dch_channel_info[0].dl_chan_num_tbs[j] = nbap_dch_chnl_info[commontransportchannelid].dl_chan_num_tbs[j];\n                    nbap_debug(\"    DL tf %u ul_chan_tf_size %u\",j, nbap_dch_chnl_info[commontransportchannelid].dl_chan_tf_size[j]);\n                }\n\n                /* Set data for associated DCH's if we have any */\n                i = commontransportchannelid;\n\n                nbap_debug(\"    commontransportchannelid %u next ch %u\",commontransportchannelid, nbap_dch_chnl_info[i].next_dch);\n\n                umts_fp_conversation_info->dchs_in_flow_list[0] = commontransportchannelid;\n                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){\n                    i = nbap_dch_chnl_info[i].next_dch;\n                    umts_fp_conversation_info->num_dch_in_flow++;\n                    umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                    /* Traffic flows per DCH(UL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_ul_chans = num_tf = nbap_dch_chnl_info[i].num_ul_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_tf_size[j] = nbap_dch_chnl_info[i].ul_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].ul_chan_num_tbs[j] = nbap_dch_chnl_info[i].ul_chan_num_tbs[j];\n                    }\n\n                    /* Traffic flows per DCH(DL) */\n                    umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].num_dl_chans = num_tf = nbap_dch_chnl_info[i].num_dl_chans;\n                    for (j = 0; j < num_tf; j++) {\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_tf_size[j] = nbap_dch_chnl_info[i].dl_chan_tf_size[j];\n                        umts_fp_conversation_info->fp_dch_channel_info[umts_fp_conversation_info->num_dch_in_flow].dl_chan_num_tbs[j] = nbap_dch_chnl_info[i].dl_chan_num_tbs[j];\n                    }\n                }\n                umts_fp_conversation_info->num_dch_in_flow++;\n\n                nbap_debug(\"    num_dch_in_flow %u\", umts_fp_conversation_info->num_dch_in_flow);\n\n                umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;\n                set_umts_fp_conv_data(conversation, umts_fp_conversation_info);\n\n                nbap_debug(\"Frame %u PCH-ParametersItem-CTCH-SetupRqstFDD End\",\n                        actx->pinfo->num);\n\n            }\n\n        }\n\n\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,7 +80,7 @@\n                 nbap_debug(\"    commontransportchannelid %u next ch %u\",commontransportchannelid, nbap_dch_chnl_info[i].next_dch);\n \n                 umts_fp_conversation_info->dchs_in_flow_list[0] = commontransportchannelid;\n-                while(nbap_dch_chnl_info[i].next_dch != 0){\n+                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){\n                     i = nbap_dch_chnl_info[i].next_dch;\n                     umts_fp_conversation_info->num_dch_in_flow++;\n                     umts_fp_conversation_info->dchs_in_flow_list[umts_fp_conversation_info->num_dch_in_flow] = i;",
        "diff_line_info": {
            "deleted_lines": [
                "                while(nbap_dch_chnl_info[i].next_dch != 0){"
            ],
            "added_lines": [
                "                while(nbap_dch_chnl_info[i].next_dch != 0 && umts_fp_conversation_info->num_dch_in_flow < FP_maxNrOfDCHs){"
            ]
        }
    }
]