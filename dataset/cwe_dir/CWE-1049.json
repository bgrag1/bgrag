[
    {
        "cve_id": "CVE-2019-8460",
        "func_name": "openbsd/src/tcp_sack_option",
        "description": "OpenBSD kernel version <= 6.5 can be forced to create long chains of TCP SACK holes that causes very expensive calls to tcp_sack_option() for every incoming SACK packet which can lead to a denial of service.",
        "git_url": "https://github.com/openbsd/src/commit/ed8fdce754a5d8d14c09e989d8877707bd43906f",
        "commit_title": "Received SACK options are managed by a linked list at the TCP socket.",
        "commit_text": "There is a global tunable limit net.inet.tcp.sackholelimit, default is 32768.  If an attacker manages to attach all these sack holes to a few TCP connections, the lists may grow long.  Traversing them might cause higher CPU consumption on the victim machine.  In practice such a situation is hard to create as the TCP retransmit and 2*msl timer flush the list periodically.  For additional protection, enforce a per connection limit of 128 SACK holes in the list. reported by Reuven Plevinsky and Tal Vainshtein discussed with claudio@ and procter@; OK deraadt@",
        "func_before": "void\ntcp_sack_option(struct tcpcb *tp, struct tcphdr *th, u_char *cp, int optlen)\n{\n\tint tmp_olen;\n\tu_char *tmp_cp;\n\tstruct sackhole *cur, *p, *temp;\n\n\tif (!tp->sack_enable)\n\t\treturn;\n\t/* SACK without ACK doesn't make sense. */\n\tif ((th->th_flags & TH_ACK) == 0)\n\t       return;\n\t/* Make sure the ACK on this segment is in [snd_una, snd_max]. */\n\tif (SEQ_LT(th->th_ack, tp->snd_una) ||\n\t    SEQ_GT(th->th_ack, tp->snd_max))\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\tif (optlen <= 2 || (optlen - 2) % TCPOLEN_SACK != 0)\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\ttmp_cp = cp + 2;\n\ttmp_olen = optlen - 2;\n\ttcpstat_inc(tcps_sack_rcv_opts);\n\tif (tp->snd_numholes < 0)\n\t\ttp->snd_numholes = 0;\n\tif (tp->t_maxseg == 0)\n\t\tpanic(\"tcp_sack_option\"); /* Should never happen */\n\twhile (tmp_olen > 0) {\n\t\tstruct sackblk sack;\n\n\t\tmemcpy(&sack.start, tmp_cp, sizeof(tcp_seq));\n\t\tsack.start = ntohl(sack.start);\n\t\tmemcpy(&sack.end, tmp_cp + sizeof(tcp_seq), sizeof(tcp_seq));\n\t\tsack.end = ntohl(sack.end);\n\t\ttmp_olen -= TCPOLEN_SACK;\n\t\ttmp_cp += TCPOLEN_SACK;\n\t\tif (SEQ_LEQ(sack.end, sack.start))\n\t\t\tcontinue; /* bad SACK fields */\n\t\tif (SEQ_LEQ(sack.end, tp->snd_una))\n\t\t\tcontinue; /* old block */\n\t\tif (SEQ_GT(th->th_ack, tp->snd_una)) {\n\t\t\tif (SEQ_LT(sack.start, th->th_ack))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (SEQ_GT(sack.end, tp->snd_max))\n\t\t\tcontinue;\n\t\tif (tp->snd_holes == NULL) { /* first hole */\n\t\t\ttp->snd_holes = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (tp->snd_holes == NULL) {\n\t\t\t\t/* ENOBUFS, so ignore SACKed block for now*/\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcur = tp->snd_holes;\n\t\t\tcur->start = th->th_ack;\n\t\t\tcur->end = sack.start;\n\t\t\tcur->rxmit = cur->start;\n\t\t\tcur->next = NULL;\n\t\t\ttp->snd_numholes = 1;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\t/*\n\t\t\t * dups is at least one.  If more data has been\n\t\t\t * SACKed, it can be greater than one.\n\t\t\t */\n\t\t\tcur->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - cur->end)/tp->t_maxseg));\n\t\t\tif (cur->dups < 1)\n\t\t\t\tcur->dups = 1;\n\t\t\tcontinue; /* with next sack block */\n\t\t}\n\t\t/* Go thru list of holes:  p = previous,  cur = current */\n\t\tp = cur = tp->snd_holes;\n\t\twhile (cur) {\n\t\t\tif (SEQ_LEQ(sack.end, cur->start))\n\t\t\t\t/* SACKs data before the current hole */\n\t\t\t\tbreak; /* no use going through more holes */\n\t\t\tif (SEQ_GEQ(sack.start, cur->end)) {\n\t\t\t\t/* SACKs data beyond the current hole */\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LEQ(sack.start, cur->start)) {\n\t\t\t\t/* Data acks at least the beginning of hole */\n\t\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\t\t/* Acks entire hole, so delete hole */\n\t\t\t\t\tif (p != cur) {\n\t\t\t\t\t\tp->next = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, cur);\n\t\t\t\t\t\tcur = p->next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcur = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, p);\n\t\t\t\t\t\tp = cur;\n\t\t\t\t\t\ttp->snd_holes = p;\n\t\t\t\t\t}\n\t\t\t\t\ttp->snd_numholes--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* otherwise, move start of hole forward */\n\t\t\t\tcur->start = sack.end;\n\t\t\t\tcur->rxmit = SEQ_MAX(cur->rxmit, cur->start);\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* move end of hole backward */\n\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LT(cur->start, sack.start) &&\n\t\t\t    SEQ_GT(cur->end, sack.end)) {\n\t\t\t\t/*\n\t\t\t\t * ACKs some data in middle of a hole; need to\n\t\t\t\t * split current hole\n\t\t\t\t */\n\t\t\t\ttemp = (struct sackhole *)\n\t\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\t\tif (temp == NULL)\n\t\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\t\ttemp->next = cur->next;\n\t\t\t\ttemp->start = sack.end;\n\t\t\t\ttemp->end = cur->end;\n\t\t\t\ttemp->dups = cur->dups;\n\t\t\t\ttemp->rxmit = SEQ_MAX(cur->rxmit, temp->start);\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t\ttcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tcur->next = temp;\n\t\t\t\tp = temp;\n\t\t\t\tcur = p->next;\n\t\t\t\ttp->snd_numholes++;\n\t\t\t}\n\t\t}\n\t\t/* At this point, p points to the last hole on the list */\n\t\tif (SEQ_LT(tp->rcv_lastsack, sack.start)) {\n\t\t\t/*\n\t\t\t * Need to append new hole at end.\n\t\t\t * Last hole is p (and it's not NULL).\n\t\t\t */\n\t\t\ttemp = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (temp == NULL)\n\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\ttemp->start = tp->rcv_lastsack;\n\t\t\ttemp->end = sack.start;\n\t\t\ttemp->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - sack.start)/tp->t_maxseg));\n\t\t\tif (temp->dups < 1)\n\t\t\t\ttemp->dups = 1;\n\t\t\ttemp->rxmit = temp->start;\n\t\t\ttemp->next = 0;\n\t\t\tp->next = temp;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\ttp->snd_numholes++;\n\t\t}\n\t}\ndone:\n\treturn;\n}",
        "func": "void\ntcp_sack_option(struct tcpcb *tp, struct tcphdr *th, u_char *cp, int optlen)\n{\n\tint tmp_olen;\n\tu_char *tmp_cp;\n\tstruct sackhole *cur, *p, *temp;\n\n\tif (!tp->sack_enable)\n\t\treturn;\n\t/* SACK without ACK doesn't make sense. */\n\tif ((th->th_flags & TH_ACK) == 0)\n\t       return;\n\t/* Make sure the ACK on this segment is in [snd_una, snd_max]. */\n\tif (SEQ_LT(th->th_ack, tp->snd_una) ||\n\t    SEQ_GT(th->th_ack, tp->snd_max))\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\tif (optlen <= 2 || (optlen - 2) % TCPOLEN_SACK != 0)\n\t\treturn;\n\t/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */\n\ttmp_cp = cp + 2;\n\ttmp_olen = optlen - 2;\n\ttcpstat_inc(tcps_sack_rcv_opts);\n\tif (tp->snd_numholes < 0)\n\t\ttp->snd_numholes = 0;\n\tif (tp->t_maxseg == 0)\n\t\tpanic(\"tcp_sack_option\"); /* Should never happen */\n\twhile (tmp_olen > 0) {\n\t\tstruct sackblk sack;\n\n\t\tmemcpy(&sack.start, tmp_cp, sizeof(tcp_seq));\n\t\tsack.start = ntohl(sack.start);\n\t\tmemcpy(&sack.end, tmp_cp + sizeof(tcp_seq), sizeof(tcp_seq));\n\t\tsack.end = ntohl(sack.end);\n\t\ttmp_olen -= TCPOLEN_SACK;\n\t\ttmp_cp += TCPOLEN_SACK;\n\t\tif (SEQ_LEQ(sack.end, sack.start))\n\t\t\tcontinue; /* bad SACK fields */\n\t\tif (SEQ_LEQ(sack.end, tp->snd_una))\n\t\t\tcontinue; /* old block */\n\t\tif (SEQ_GT(th->th_ack, tp->snd_una)) {\n\t\t\tif (SEQ_LT(sack.start, th->th_ack))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (SEQ_GT(sack.end, tp->snd_max))\n\t\t\tcontinue;\n\t\tif (tp->snd_holes == NULL) { /* first hole */\n\t\t\ttp->snd_holes = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (tp->snd_holes == NULL) {\n\t\t\t\t/* ENOBUFS, so ignore SACKed block for now*/\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcur = tp->snd_holes;\n\t\t\tcur->start = th->th_ack;\n\t\t\tcur->end = sack.start;\n\t\t\tcur->rxmit = cur->start;\n\t\t\tcur->next = NULL;\n\t\t\ttp->snd_numholes = 1;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\t/*\n\t\t\t * dups is at least one.  If more data has been\n\t\t\t * SACKed, it can be greater than one.\n\t\t\t */\n\t\t\tcur->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - cur->end)/tp->t_maxseg));\n\t\t\tif (cur->dups < 1)\n\t\t\t\tcur->dups = 1;\n\t\t\tcontinue; /* with next sack block */\n\t\t}\n\t\t/* Go thru list of holes:  p = previous,  cur = current */\n\t\tp = cur = tp->snd_holes;\n\t\twhile (cur) {\n\t\t\tif (SEQ_LEQ(sack.end, cur->start))\n\t\t\t\t/* SACKs data before the current hole */\n\t\t\t\tbreak; /* no use going through more holes */\n\t\t\tif (SEQ_GEQ(sack.start, cur->end)) {\n\t\t\t\t/* SACKs data beyond the current hole */\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LEQ(sack.start, cur->start)) {\n\t\t\t\t/* Data acks at least the beginning of hole */\n\t\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\t\t/* Acks entire hole, so delete hole */\n\t\t\t\t\tif (p != cur) {\n\t\t\t\t\t\tp->next = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, cur);\n\t\t\t\t\t\tcur = p->next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcur = cur->next;\n\t\t\t\t\t\tpool_put(&sackhl_pool, p);\n\t\t\t\t\t\tp = cur;\n\t\t\t\t\t\ttp->snd_holes = p;\n\t\t\t\t\t}\n\t\t\t\t\ttp->snd_numholes--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* otherwise, move start of hole forward */\n\t\t\t\tcur->start = sack.end;\n\t\t\t\tcur->rxmit = SEQ_MAX(cur->rxmit, cur->start);\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* move end of hole backward */\n\t\t\tif (SEQ_GEQ(sack.end, cur->end)) {\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t    tcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tp = cur;\n\t\t\t\tcur = cur->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SEQ_LT(cur->start, sack.start) &&\n\t\t\t    SEQ_GT(cur->end, sack.end)) {\n\t\t\t\t/*\n\t\t\t\t * ACKs some data in middle of a hole; need to\n\t\t\t\t * split current hole\n\t\t\t\t */\n\t\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)\n\t\t\t\t\tgoto done;\n\t\t\t\ttemp = (struct sackhole *)\n\t\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\t\tif (temp == NULL)\n\t\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\t\ttemp->next = cur->next;\n\t\t\t\ttemp->start = sack.end;\n\t\t\t\ttemp->end = cur->end;\n\t\t\t\ttemp->dups = cur->dups;\n\t\t\t\ttemp->rxmit = SEQ_MAX(cur->rxmit, temp->start);\n\t\t\t\tcur->end = sack.start;\n\t\t\t\tcur->rxmit = SEQ_MIN(cur->rxmit, cur->end);\n\t\t\t\tcur->dups++;\n\t\t\t\tif (((sack.end - cur->end)/tp->t_maxseg) >=\n\t\t\t\t\ttcprexmtthresh)\n\t\t\t\t\tcur->dups = tcprexmtthresh;\n\t\t\t\tcur->next = temp;\n\t\t\t\tp = temp;\n\t\t\t\tcur = p->next;\n\t\t\t\ttp->snd_numholes++;\n\t\t\t}\n\t\t}\n\t\t/* At this point, p points to the last hole on the list */\n\t\tif (SEQ_LT(tp->rcv_lastsack, sack.start)) {\n\t\t\t/*\n\t\t\t * Need to append new hole at end.\n\t\t\t * Last hole is p (and it's not NULL).\n\t\t\t */\n\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)\n\t\t\t\tgoto done;\n\t\t\ttemp = (struct sackhole *)\n\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n\t\t\tif (temp == NULL)\n\t\t\t\tgoto done; /* ENOBUFS */\n\t\t\ttemp->start = tp->rcv_lastsack;\n\t\t\ttemp->end = sack.start;\n\t\t\ttemp->dups = min(tcprexmtthresh,\n\t\t\t    ((sack.end - sack.start)/tp->t_maxseg));\n\t\t\tif (temp->dups < 1)\n\t\t\t\ttemp->dups = 1;\n\t\t\ttemp->rxmit = temp->start;\n\t\t\ttemp->next = 0;\n\t\t\tp->next = temp;\n\t\t\ttp->rcv_lastsack = sack.end;\n\t\t\ttp->snd_numholes++;\n\t\t}\n\t}\ndone:\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -126,6 +126,8 @@\n \t\t\t\t * ACKs some data in middle of a hole; need to\n \t\t\t\t * split current hole\n \t\t\t\t */\n+\t\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)\n+\t\t\t\t\tgoto done;\n \t\t\t\ttemp = (struct sackhole *)\n \t\t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n \t\t\t\tif (temp == NULL)\n@@ -153,6 +155,8 @@\n \t\t\t * Need to append new hole at end.\n \t\t\t * Last hole is p (and it's not NULL).\n \t\t\t */\n+\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)\n+\t\t\t\tgoto done;\n \t\t\ttemp = (struct sackhole *)\n \t\t\t    pool_get(&sackhl_pool, PR_NOWAIT);\n \t\t\tif (temp == NULL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)",
                "\t\t\t\t\tgoto done;",
                "\t\t\tif (tp->snd_numholes >= TCP_SACKHOLE_LIMIT)",
                "\t\t\t\tgoto done;"
            ]
        }
    }
]