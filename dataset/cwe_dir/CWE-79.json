[
    {
        "cve_id": "CVE-2019-13345",
        "func_name": "squid-cache/squid/make_pub_auth",
        "description": "The cachemgr.cgi web module of Squid through 4.7 has XSS via the user_name or auth parameter.",
        "git_url": "https://github.com/squid-cache/squid/commit/8619907c06707d13d2714833a802692138325e34",
        "commit_title": "Bug 4957: Multiple XSS issues in cachemgr.cgi",
        "commit_text": "",
        "func_before": "static void\nmake_pub_auth(cachemgr_request * req)\n{\n    static char buf[1024];\n    safe_free(req->pub_auth);\n    debug(\"cmgr: encoding for pub...\\n\");\n\n    if (!req->passwd || !strlen(req->passwd))\n        return;\n\n    /* host | time | user | passwd */\n    const int bufLen = snprintf(buf, sizeof(buf), \"%s|%d|%s|%s\",\n                                req->hostname,\n                                (int) now,\n                                req->user_name ? req->user_name : \"\",\n                                req->passwd);\n    debug(\"cmgr: pre-encoded for pub: %s\\n\", buf);\n\n    const int encodedLen = base64_encode_len(bufLen);\n    req->pub_auth = (char *) xmalloc(encodedLen);\n    struct base64_encode_ctx ctx;\n    base64_encode_init(&ctx);\n    size_t blen = base64_encode_update(&ctx, req->pub_auth, bufLen, reinterpret_cast<uint8_t*>(buf));\n    blen += base64_encode_final(&ctx, req->pub_auth + blen);\n    req->pub_auth[blen] = '\\0';\n    debug(\"cmgr: encoded: '%s'\\n\", req->pub_auth);\n}",
        "func": "static void\nmake_pub_auth(cachemgr_request * req)\n{\n    static char buf[1024];\n    safe_free(req->pub_auth);\n    debug(\"cmgr: encoding for pub...\\n\");\n\n    if (!req->passwd || !strlen(req->passwd))\n        return;\n\n    /* host | time | user | passwd */\n    const int bufLen = snprintf(buf, sizeof(buf), \"%s|%d|%s|%s\",\n                                req->hostname,\n                                (int) now,\n                                rfc1738_escape(safe_str(req->user_name)),\n                                rfc1738_escape(req->passwd));\n    debug(\"cmgr: pre-encoded for pub: %s\\n\", buf);\n\n    const int encodedLen = base64_encode_len(bufLen);\n    req->pub_auth = (char *) xmalloc(encodedLen);\n    struct base64_encode_ctx ctx;\n    base64_encode_init(&ctx);\n    size_t blen = base64_encode_update(&ctx, req->pub_auth, bufLen, reinterpret_cast<uint8_t*>(buf));\n    blen += base64_encode_final(&ctx, req->pub_auth + blen);\n    req->pub_auth[blen] = '\\0';\n    debug(\"cmgr: encoded: '%s'\\n\", req->pub_auth);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,8 @@\n     const int bufLen = snprintf(buf, sizeof(buf), \"%s|%d|%s|%s\",\n                                 req->hostname,\n                                 (int) now,\n-                                req->user_name ? req->user_name : \"\",\n-                                req->passwd);\n+                                rfc1738_escape(safe_str(req->user_name)),\n+                                rfc1738_escape(req->passwd));\n     debug(\"cmgr: pre-encoded for pub: %s\\n\", buf);\n \n     const int encodedLen = base64_encode_len(bufLen);",
        "diff_line_info": {
            "deleted_lines": [
                "                                req->user_name ? req->user_name : \"\",",
                "                                req->passwd);"
            ],
            "added_lines": [
                "                                rfc1738_escape(safe_str(req->user_name)),",
                "                                rfc1738_escape(req->passwd));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13345",
        "func_name": "squid-cache/squid/decode_pub_auth",
        "description": "The cachemgr.cgi web module of Squid through 4.7 has XSS via the user_name or auth parameter.",
        "git_url": "https://github.com/squid-cache/squid/commit/8619907c06707d13d2714833a802692138325e34",
        "commit_title": "Bug 4957: Multiple XSS issues in cachemgr.cgi",
        "commit_text": "",
        "func_before": "static void\ndecode_pub_auth(cachemgr_request * req)\n{\n    const char *host_name;\n    const char *time_str;\n    const char *user_name;\n    const char *passwd;\n\n    debug(\"cmgr: decoding pub: '%s'\\n\", safe_str(req->pub_auth));\n    safe_free(req->passwd);\n\n    if (!req->pub_auth || strlen(req->pub_auth) < 4 + strlen(safe_str(req->hostname)))\n        return;\n\n    char *buf = static_cast<char*>(xmalloc(BASE64_DECODE_LENGTH(strlen(req->pub_auth))+1));\n    struct base64_decode_ctx ctx;\n    base64_decode_init(&ctx);\n    size_t decodedLen = 0;\n    if (!base64_decode_update(&ctx, &decodedLen, reinterpret_cast<uint8_t*>(buf), strlen(req->pub_auth), req->pub_auth) ||\n            !base64_decode_final(&ctx)) {\n        debug(\"cmgr: base64 decode failure. Incomplete auth token string.\\n\");\n        xfree(buf);\n        return;\n    }\n    buf[decodedLen] = '\\0';\n\n    debug(\"cmgr: length ok\\n\");\n\n    /* parse ( a lot of memory leaks, but that is cachemgr style :) */\n    if ((host_name = strtok(buf, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: decoded host: '%s'\\n\", host_name);\n\n    if ((time_str = strtok(NULL, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: decoded time: '%s' (now: %d)\\n\", time_str, (int) now);\n\n    if ((user_name = strtok(NULL, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: decoded uname: '%s'\\n\", user_name);\n\n    if ((passwd = strtok(NULL, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: decoded passwd: '%s'\\n\", passwd);\n\n    /* verify freshness and validity */\n    if (atoi(time_str) + passwd_ttl < now) {\n        xfree(buf);\n        return;\n    }\n\n    if (strcasecmp(host_name, req->hostname)) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: verified auth. info.\\n\");\n\n    /* ok, accept */\n    safe_free(req->user_name);\n\n    req->user_name = xstrdup(user_name);\n\n    req->passwd = xstrdup(passwd);\n\n    xfree(buf);\n}",
        "func": "static void\ndecode_pub_auth(cachemgr_request * req)\n{\n    const char *host_name;\n    const char *time_str;\n\n    debug(\"cmgr: decoding pub: '%s'\\n\", safe_str(req->pub_auth));\n    safe_free(req->passwd);\n\n    if (!req->pub_auth || strlen(req->pub_auth) < 4 + strlen(safe_str(req->hostname)))\n        return;\n\n    char *buf = static_cast<char*>(xmalloc(BASE64_DECODE_LENGTH(strlen(req->pub_auth))+1));\n    struct base64_decode_ctx ctx;\n    base64_decode_init(&ctx);\n    size_t decodedLen = 0;\n    if (!base64_decode_update(&ctx, &decodedLen, reinterpret_cast<uint8_t*>(buf), strlen(req->pub_auth), req->pub_auth) ||\n            !base64_decode_final(&ctx)) {\n        debug(\"cmgr: base64 decode failure. Incomplete auth token string.\\n\");\n        xfree(buf);\n        return;\n    }\n    buf[decodedLen] = '\\0';\n\n    debug(\"cmgr: length ok\\n\");\n\n    /* parse ( a lot of memory leaks, but that is cachemgr style :) */\n    if ((host_name = strtok(buf, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: decoded host: '%s'\\n\", host_name);\n\n    if ((time_str = strtok(NULL, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: decoded time: '%s' (now: %d)\\n\", time_str, (int) now);\n\n    char *user_name;\n    if ((user_name = strtok(NULL, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n    rfc1738_unescape(user_name);\n\n    debug(\"cmgr: decoded uname: '%s'\\n\", user_name);\n\n    char *passwd;\n    if ((passwd = strtok(NULL, \"|\")) == NULL) {\n        xfree(buf);\n        return;\n    }\n    rfc1738_unescape(passwd);\n\n    debug(\"cmgr: decoded passwd: '%s'\\n\", passwd);\n\n    /* verify freshness and validity */\n    if (atoi(time_str) + passwd_ttl < now) {\n        xfree(buf);\n        return;\n    }\n\n    if (strcasecmp(host_name, req->hostname)) {\n        xfree(buf);\n        return;\n    }\n\n    debug(\"cmgr: verified auth. info.\\n\");\n\n    /* ok, accept */\n    safe_free(req->user_name);\n\n    req->user_name = xstrdup(user_name);\n\n    req->passwd = xstrdup(passwd);\n\n    xfree(buf);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,6 @@\n {\n     const char *host_name;\n     const char *time_str;\n-    const char *user_name;\n-    const char *passwd;\n \n     debug(\"cmgr: decoding pub: '%s'\\n\", safe_str(req->pub_auth));\n     safe_free(req->passwd);\n@@ -41,17 +39,21 @@\n \n     debug(\"cmgr: decoded time: '%s' (now: %d)\\n\", time_str, (int) now);\n \n+    char *user_name;\n     if ((user_name = strtok(NULL, \"|\")) == NULL) {\n         xfree(buf);\n         return;\n     }\n+    rfc1738_unescape(user_name);\n \n     debug(\"cmgr: decoded uname: '%s'\\n\", user_name);\n \n+    char *passwd;\n     if ((passwd = strtok(NULL, \"|\")) == NULL) {\n         xfree(buf);\n         return;\n     }\n+    rfc1738_unescape(passwd);\n \n     debug(\"cmgr: decoded passwd: '%s'\\n\", passwd);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    const char *user_name;",
                "    const char *passwd;"
            ],
            "added_lines": [
                "    char *user_name;",
                "    rfc1738_unescape(user_name);",
                "    char *passwd;",
                "    rfc1738_unescape(passwd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13345",
        "func_name": "squid-cache/squid/menu_url",
        "description": "The cachemgr.cgi web module of Squid through 4.7 has XSS via the user_name or auth parameter.",
        "git_url": "https://github.com/squid-cache/squid/commit/8619907c06707d13d2714833a802692138325e34",
        "commit_title": "Bug 4957: Multiple XSS issues in cachemgr.cgi",
        "commit_text": "",
        "func_before": "static char *\nmenu_url(cachemgr_request * req, const char *action)\n{\n    static char url[1024];\n    snprintf(url, sizeof(url), \"%s?host=%s&port=%d&user_name=%s&operation=%s&auth=%s\",\n             script_name,\n             req->hostname,\n             req->port,\n             safe_str(req->user_name),\n             action,\n             safe_str(req->pub_auth));\n    return url;\n}",
        "func": "static char *\nmenu_url(cachemgr_request * req, const char *action)\n{\n    static char url[1024];\n    snprintf(url, sizeof(url), \"%s?host=%s&port=%d&user_name=%s&operation=%s&auth=%s\",\n             script_name,\n             req->hostname,\n             req->port,\n             rfc1738_escape(safe_str(req->user_name)),\n             action,\n             safe_str(req->pub_auth));\n    return url;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n              script_name,\n              req->hostname,\n              req->port,\n-             safe_str(req->user_name),\n+             rfc1738_escape(safe_str(req->user_name)),\n              action,\n              safe_str(req->pub_auth));\n     return url;",
        "diff_line_info": {
            "deleted_lines": [
                "             safe_str(req->user_name),"
            ],
            "added_lines": [
                "             rfc1738_escape(safe_str(req->user_name)),"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1010247",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_handle_session_management_iframe_rp",
        "description": "ZmartZone IAM mod_auth_openidc 2.3.10.1 and earlier is affected by: Cross Site Scripting (XSS). The impact is: Redirecting the user to a phishing page or interacting with the application on behalf of the user. The component is: File: src/mod_auth_openidc.c, Line: 3109. The fixed version is: 2.3.10.2.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/132a4111bf3791e76437619a66336dce2ce4c79b",
        "commit_title": "release 2.3.10.2: fix XSS vulnerability for poll parameter",
        "commit_text": " in OIDC Session Management RP iframe; CSNC-2019-001; thanks Mischa Bachmann ",
        "func_before": "static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var message = '%s' + ' ' + '%s';\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %s);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.debug('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed') {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=check';\\n\"\n\t\t\t\"          } else {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=logout';\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\treturn DONE;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tif (s_poll_interval == NULL)\n\t\ts_poll_interval = \"3000\";\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, s_poll_interval, redirect_uri,\n\t\t\tredirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, DONE);\n}",
        "func": "static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var message = '%s' + ' ' + '%s';\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %d);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.debug('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed') {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=check';\\n\"\n\t\t\t\"          } else {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=logout';\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\treturn DONE;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tint poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;\n\tif ((poll_interval <= 0) || (poll_interval > 3600 * 24))\n\t\tpoll_interval = 3000;\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, poll_interval, redirect_uri,\n\t\t\tredirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, DONE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,7 @@\n \t\t\t\"\\n\"\n \t\t\t\"      function setTimer() {\\n\"\n \t\t\t\"        checkSession();\\n\"\n-\t\t\t\"        timerID = setInterval('checkSession()', %s);\\n\"\n+\t\t\t\"        timerID = setInterval('checkSession()', %d);\\n\"\n \t\t\t\"      }\\n\"\n \t\t\t\"\\n\"\n \t\t\t\"      function receiveMessage(e) {\\n\"\n@@ -61,12 +61,13 @@\n \n \tchar *s_poll_interval = NULL;\n \toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n-\tif (s_poll_interval == NULL)\n-\t\ts_poll_interval = \"3000\";\n+\tint poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;\n+\tif ((poll_interval <= 0) || (poll_interval > 3600 * 24))\n+\t\tpoll_interval = 3000;\n \n \tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n \tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n-\t\t\tsession_state, op_iframe_id, s_poll_interval, redirect_uri,\n+\t\t\tsession_state, op_iframe_id, poll_interval, redirect_uri,\n \t\t\tredirect_uri);\n \n \treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, DONE);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\"        timerID = setInterval('checkSession()', %s);\\n\"",
                "\tif (s_poll_interval == NULL)",
                "\t\ts_poll_interval = \"3000\";",
                "\t\t\tsession_state, op_iframe_id, s_poll_interval, redirect_uri,"
            ],
            "added_lines": [
                "\t\t\t\"        timerID = setInterval('checkSession()', %d);\\n\"",
                "\tint poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;",
                "\tif ((poll_interval <= 0) || (poll_interval > 3600 * 24))",
                "\t\tpoll_interval = 3000;",
                "\t\t\tsession_state, op_iframe_id, poll_interval, redirect_uri,"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/WebObjects_translate",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/23c9775fb6afb7be1472944e02396f29771dc8e2",
        "commit_title": "Updated the adaptors to have a config.h preproc definition which, if enabled, compiles the adaptors without the ability to check for invalid URL characters.",
        "commit_text": "",
        "func_before": "int WebObjects_translate(request_rec *r) {\n   WebObjects_config *wc;\n   WOURLComponents url;\n   WOURLError urlerr;\n\n   wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n   if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n      url = WOURLComponents_Initializer;\n      urlerr = WOParseApplicationName(&url, r->uri);\n      if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n         /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n         return DECLINED;\n      }\n      if (!adaptorEnabled)\n      {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n         return DECLINED;\n      }\n      /*\n       *\twe'll take it - mark our handler...\n       */\n      r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS);\n      return OK;\n   }\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n   return DECLINED;\n}",
        "func": "int WebObjects_translate(request_rec *r) {\n   WebObjects_config *wc;\n   WOURLComponents url;\n   WOURLError urlerr;\n   WOURLError charcheck;\n\n   wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n   if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n      url = WOURLComponents_Initializer;\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( r->uri );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n         return DECLINED;\n      }\n#endif\n\n\n      urlerr = WOParseApplicationName(&url, r->uri);\n      if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n         /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n         return DECLINED;\n      }\n      if (!adaptorEnabled)\n      {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n         return DECLINED;\n      }\n      /*\n       *\twe'll take it - mark our handler...\n       */\n      r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS);\n      return OK;\n   }\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n   return DECLINED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,24 @@\n    WebObjects_config *wc;\n    WOURLComponents url;\n    WOURLError urlerr;\n+   WOURLError charcheck;\n \n    wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n \n    /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n    if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n       url = WOURLComponents_Initializer;\n+\n+#ifndef __PRESERVE_UNSAFE_URLS\n+      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+      charcheck = WOValidateInitialURL( r->uri );\n+      if ( charcheck != WOURLOK ) {\n+         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n+         return DECLINED;\n+      }\n+#endif\n+\n+\n       urlerr = WOParseApplicationName(&url, r->uri);\n       if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n          /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "   WOURLError charcheck;",
                "",
                "#ifndef __PRESERVE_UNSAFE_URLS",
                "      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "      charcheck = WOValidateInitialURL( r->uri );",
                "      if ( charcheck != WOURLOK ) {",
                "         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");",
                "         return DECLINED;",
                "      }",
                "#endif",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/doit",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/23c9775fb6afb7be1472944e02396f29771dc8e2",
        "commit_title": "Updated the adaptors to have a config.h preproc definition which, if enabled, compiles the adaptors without the ability to check for invalid URL characters.",
        "commit_text": "",
        "func_before": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "func": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n#endif\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,6 +90,7 @@\n       strcat(url, path_info);\n       WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n \n+#ifndef __PRESERVE_UNSAFE_URLS\n       // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n       charcheck = WOValidateInitialURL( url );\n       if ( charcheck != WOURLOK ) {\n@@ -98,6 +99,7 @@\n          _urlerr = WOURLstrerror( charcheck );\n          die( _urlerr, HTTP_BAD_REQUEST );\n       }\n+#endif\n \n       urlerr = WOParseApplicationName(&wc, url);\n       if (urlerr != WOURLOK) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifndef __PRESERVE_UNSAFE_URLS",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/doit",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/23c9775fb6afb7be1472944e02396f29771dc8e2",
        "commit_title": "Updated the adaptors to have a config.h preproc definition which, if enabled, compiles the adaptors without the ability to check for invalid URL characters.",
        "commit_text": "",
        "func_before": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "func": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n#endif\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,6 +90,7 @@\n       strcat(url, path_info);\n       WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n \n+#ifndef __PRESERVE_UNSAFE_URLS\n       // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n       charcheck = WOValidateInitialURL( url );\n       if ( charcheck != WOURLOK ) {\n@@ -98,6 +99,7 @@\n          _urlerr = WOURLstrerror( charcheck );\n          die( _urlerr, HTTP_BAD_REQUEST );\n       }\n+#endif\n \n       urlerr = WOParseApplicationName(&wc, url);\n       if (urlerr != WOURLOK) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifndef __PRESERVE_UNSAFE_URLS",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/WebObjects_translate",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/23c9775fb6afb7be1472944e02396f29771dc8e2",
        "commit_title": "Updated the adaptors to have a config.h preproc definition which, if enabled, compiles the adaptors without the ability to check for invalid URL characters.",
        "commit_text": "",
        "func_before": "int WebObjects_translate(request_rec *r) {\n   WebObjects_config *wc;\n   WOURLComponents url;\n   WOURLError urlerr;\n\n   wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n   if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n      url = WOURLComponents_Initializer;\n      urlerr = WOParseApplicationName(&url, r->uri);\n      if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n         /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n         return DECLINED;\n      }\n      if (!adaptorEnabled)\n      {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n         return DECLINED;\n      }\n      /*\n       *\twe'll take it - mark our handler...\n       */\n      r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS);\n      return OK;\n   }\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n   return DECLINED;\n}",
        "func": "int WebObjects_translate(request_rec *r) {\n   WebObjects_config *wc;\n   WOURLComponents url;\n   WOURLError urlerr;\n   WOURLError charcheck;\n\n   wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n   if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n      url = WOURLComponents_Initializer;\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( r->uri );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n         return DECLINED;\n      }\n#endif\n\n\n      urlerr = WOParseApplicationName(&url, r->uri);\n      if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n         /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n         return DECLINED;\n      }\n      if (!adaptorEnabled)\n      {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n         return DECLINED;\n      }\n      /*\n       *\twe'll take it - mark our handler...\n       */\n      r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS);\n      return OK;\n   }\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n   return DECLINED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,24 @@\n    WebObjects_config *wc;\n    WOURLComponents url;\n    WOURLError urlerr;\n+   WOURLError charcheck;\n \n    wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n \n    /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n    if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n       url = WOURLComponents_Initializer;\n+\n+#ifndef __PRESERVE_UNSAFE_URLS\n+      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+      charcheck = WOValidateInitialURL( r->uri );\n+      if ( charcheck != WOURLOK ) {\n+         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n+         return DECLINED;\n+      }\n+#endif\n+\n+\n       urlerr = WOParseApplicationName(&url, r->uri);\n       if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n          /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "   WOURLError charcheck;",
                "",
                "#ifndef __PRESERVE_UNSAFE_URLS",
                "      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "      charcheck = WOValidateInitialURL( r->uri );",
                "      if ( charcheck != WOURLOK ) {",
                "         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");",
                "         return DECLINED;",
                "      }",
                "#endif",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/WebObjects_translate",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/23c9775fb6afb7be1472944e02396f29771dc8e2",
        "commit_title": "Updated the adaptors to have a config.h preproc definition which, if enabled, compiles the adaptors without the ability to check for invalid URL characters.",
        "commit_text": "",
        "func_before": "int WebObjects_translate(request_rec *r) {\n   WebObjects_config *wc;\n   WOURLComponents url;\n   WOURLError urlerr;\n\n   wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n   if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n      url = WOURLComponents_Initializer;\n      urlerr = WOParseApplicationName(&url, r->uri);\n      if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n         /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n         return DECLINED;\n      }\n      if (!adaptorEnabled)\n      {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n         return DECLINED;\n      }\n      /*\n       *\twe'll take it - mark our handler...\n       */\n      r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS);\n      return OK;\n   }\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n   return DECLINED;\n}",
        "func": "int WebObjects_translate(request_rec *r) {\n   WebObjects_config *wc;\n   WOURLComponents url;\n   WOURLError urlerr;\n   WOURLError charcheck;\n\n   wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n   if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n      url = WOURLComponents_Initializer;\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( r->uri );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n         return DECLINED;\n      }\n#endif\n\n\n      urlerr = WOParseApplicationName(&url, r->uri);\n      if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n         /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n         return DECLINED;\n      }\n      if (!adaptorEnabled)\n      {\n         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n         return DECLINED;\n      }\n      /*\n       *\twe'll take it - mark our handler...\n       */\n      r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS);\n      return OK;\n   }\n   /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */\n   return DECLINED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,24 @@\n    WebObjects_config *wc;\n    WOURLComponents url;\n    WOURLError urlerr;\n+   WOURLError charcheck;\n \n    wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module);\n \n    /* WOLog(WO_DBG,\"<WebObjects Apache Module> new translate: %s\",r->uri); */\n    if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) {\n       url = WOURLComponents_Initializer;\n+\n+#ifndef __PRESERVE_UNSAFE_URLS\n+      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+      charcheck = WOValidateInitialURL( r->uri );\n+      if ( charcheck != WOURLOK ) {\n+         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n+         return DECLINED;\n+      }\n+#endif\n+\n+\n       urlerr = WOParseApplicationName(&url, r->uri);\n       if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n          /* WOLog(WO_DBG,\"<WebObjects Apache Module> translate - DECLINED: %s\",r->uri); */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "   WOURLError charcheck;",
                "",
                "#ifndef __PRESERVE_UNSAFE_URLS",
                "      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "      charcheck = WOValidateInitialURL( r->uri );",
                "      if ( charcheck != WOURLOK ) {",
                "         WOLog(WO_ERR, \"WebObjects_translate(): declining request due to forbidden URL characters\");",
                "         return DECLINED;",
                "      }",
                "#endif",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/doit",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/23c9775fb6afb7be1472944e02396f29771dc8e2",
        "commit_title": "Updated the adaptors to have a config.h preproc definition which, if enabled, compiles the adaptors without the ability to check for invalid URL characters.",
        "commit_text": "",
        "func_before": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "func": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n#ifndef __PRESERVE_UNSAFE_URLS\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n#endif\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,6 +90,7 @@\n       strcat(url, path_info);\n       WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n \n+#ifndef __PRESERVE_UNSAFE_URLS\n       // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n       charcheck = WOValidateInitialURL( url );\n       if ( charcheck != WOURLOK ) {\n@@ -98,6 +99,7 @@\n          _urlerr = WOURLstrerror( charcheck );\n          die( _urlerr, HTTP_BAD_REQUEST );\n       }\n+#endif\n \n       urlerr = WOParseApplicationName(&wc, url);\n       if (urlerr != WOURLOK) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifndef __PRESERVE_UNSAFE_URLS",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/doit",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/9e75cb6cadd4df2d225209f2ff9f82bfd7fbe432",
        "commit_title": "Added WOAdaptor fix for all adaptor versions and incremented the version indicator. Changes are in accordance with my published article at https://xmit.xyz/security/webobjects-url-tomfoolery/",
        "commit_text": "",
        "func_before": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n      \n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "func": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n       const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n       const char *reqerr;\n       WOURLError urlerr;\n+      WOURLError charcheck;\n       strtbl *options = NULL;\n \n #ifdef WIN32\n@@ -88,7 +89,16 @@\n       strcpy(url, script_name);\n       strcat(url, path_info);\n       WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n-      \n+\n+      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+      charcheck = WOValidateInitialURL( url );\n+      if ( charcheck != WOURLOK ) {\n+         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n+         const char* _urlerr;\n+         _urlerr = WOURLstrerror( charcheck );\n+         die( _urlerr, HTTP_BAD_REQUEST );\n+      }\n+\n       urlerr = WOParseApplicationName(&wc, url);\n       if (urlerr != WOURLOK) {\n          const char *_urlerr;",
        "diff_line_info": {
            "deleted_lines": [
                "      "
            ],
            "added_lines": [
                "      WOURLError charcheck;",
                "",
                "      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "      charcheck = WOValidateInitialURL( url );",
                "      if ( charcheck != WOURLOK ) {",
                "         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");",
                "         const char* _urlerr;",
                "         _urlerr = WOURLstrerror( charcheck );",
                "         die( _urlerr, HTTP_BAD_REQUEST );",
                "      }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/WebObjects_translate",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/9e75cb6cadd4df2d225209f2ff9f82bfd7fbe432",
        "commit_title": "Added WOAdaptor fix for all adaptor versions and incremented the version indicator. Changes are in accordance with my published article at https://xmit.xyz/security/webobjects-url-tomfoolery/",
        "commit_text": "",
        "func_before": "int WebObjects_translate(request_rec *r) {\n    WebObjects_config *wc;\n    WOURLComponents url;\n    WOURLError urlerr;\n\n    // get the module configuration (this is the structure created by WebObjects_create_config())\n    wc = ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> new translate: %s\", r->uri);\n    if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0 || (r->handler != NULL && strcasecmp(r->handler, WEBOBJECTS) == 0)) {\n#ifndef _MSC_VER // SWK changed url = WOURLComponents_Initializer; to memset(&url,0,sizeof(WOURLComponents));\n        url = WOURLComponents_Initializer;\n#else\n        memset(&url,0,sizeof(WOURLComponents));\n#endif\n        urlerr = WOParseApplicationName(&url, r->uri);\n        if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n            WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n            return DECLINED;\n        }\n        if (!adaptorEnabled)\n        {\n            WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n            return DECLINED;\n        }\n\n\n        /*\n         *  we'll take it - mark our handler...\n         */\n        r->handler = (char *)apr_pstrdup(r->pool, WEBOBJECTS);\n        r->filename = (char *)apr_pstrdup(r->pool, r->uri);\n\n        return OK;\n    }\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n\n    return DECLINED;\n}",
        "func": "int WebObjects_translate(request_rec *r) {\n    WebObjects_config *wc;\n    WOURLComponents url;\n    WOURLError urlerr;\n    WOURLError charcheck;\n\n    // get the module configuration (this is the structure created by WebObjects_create_config())\n    wc = ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> new translate: %s\", r->uri);\n    if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0 || (r->handler != NULL && strcasecmp(r->handler, WEBOBJECTS) == 0)) {\n#ifndef _MSC_VER // SWK changed url = WOURLComponents_Initializer; to memset(&url,0,sizeof(WOURLComponents));\n        url = WOURLComponents_Initializer;\n#else\n        memset(&url,0,sizeof(WOURLComponents));\n#endif\n\n        // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n        charcheck = WOValidateInitialURL( r->uri );\n        if ( charcheck != WOURLOK ) {\n            WOLog(WO_DBG, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n            return DECLINED;\n        }\n\n        urlerr = WOParseApplicationName(&url, r->uri);\n        if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n            WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n            return DECLINED;\n        }\n        if (!adaptorEnabled)\n        {\n            WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n            return DECLINED;\n        }\n\n\n        /*\n         *  we'll take it - mark our handler...\n         */\n        r->handler = (char *)apr_pstrdup(r->pool, WEBOBJECTS);\n        r->filename = (char *)apr_pstrdup(r->pool, r->uri);\n\n        return OK;\n    }\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n\n    return DECLINED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n     WebObjects_config *wc;\n     WOURLComponents url;\n     WOURLError urlerr;\n+    WOURLError charcheck;\n \n     // get the module configuration (this is the structure created by WebObjects_create_config())\n     wc = ap_get_module_config(r->server->module_config, &WebObjects_module);\n@@ -13,6 +14,14 @@\n #else\n         memset(&url,0,sizeof(WOURLComponents));\n #endif\n+\n+        // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+        charcheck = WOValidateInitialURL( r->uri );\n+        if ( charcheck != WOURLOK ) {\n+            WOLog(WO_DBG, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n+            return DECLINED;\n+        }\n+\n         urlerr = WOParseApplicationName(&url, r->uri);\n         if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n             WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    WOURLError charcheck;",
                "",
                "        // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "        charcheck = WOValidateInitialURL( r->uri );",
                "        if ( charcheck != WOURLOK ) {",
                "            WOLog(WO_DBG, \"WebObjects_translate(): declining request due to forbidden URL characters\");",
                "            return DECLINED;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/doit",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/9e75cb6cadd4df2d225209f2ff9f82bfd7fbe432",
        "commit_title": "Added WOAdaptor fix for all adaptor versions and incremented the version indicator. Changes are in accordance with my published article at https://xmit.xyz/security/webobjects-url-tomfoolery/",
        "commit_text": "",
        "func_before": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n      \n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "func": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n       const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n       const char *reqerr;\n       WOURLError urlerr;\n+      WOURLError charcheck;\n       strtbl *options = NULL;\n \n #ifdef WIN32\n@@ -88,7 +89,16 @@\n       strcpy(url, script_name);\n       strcat(url, path_info);\n       WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n-      \n+\n+      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+      charcheck = WOValidateInitialURL( url );\n+      if ( charcheck != WOURLOK ) {\n+         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n+         const char* _urlerr;\n+         _urlerr = WOURLstrerror( charcheck );\n+         die( _urlerr, HTTP_BAD_REQUEST );\n+      }\n+\n       urlerr = WOParseApplicationName(&wc, url);\n       if (urlerr != WOURLOK) {\n          const char *_urlerr;",
        "diff_line_info": {
            "deleted_lines": [
                "      "
            ],
            "added_lines": [
                "      WOURLError charcheck;",
                "",
                "      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "      charcheck = WOValidateInitialURL( url );",
                "      if ( charcheck != WOURLOK ) {",
                "         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");",
                "         const char* _urlerr;",
                "         _urlerr = WOURLstrerror( charcheck );",
                "         die( _urlerr, HTTP_BAD_REQUEST );",
                "      }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/doit",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/9e75cb6cadd4df2d225209f2ff9f82bfd7fbe432",
        "commit_title": "Added WOAdaptor fix for all adaptor versions and incremented the version indicator. Changes are in accordance with my published article at https://xmit.xyz/security/webobjects-url-tomfoolery/",
        "commit_text": "",
        "func_before": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n      \n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "func": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n       const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n       const char *reqerr;\n       WOURLError urlerr;\n+      WOURLError charcheck;\n       strtbl *options = NULL;\n \n #ifdef WIN32\n@@ -88,7 +89,16 @@\n       strcpy(url, script_name);\n       strcat(url, path_info);\n       WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n-      \n+\n+      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+      charcheck = WOValidateInitialURL( url );\n+      if ( charcheck != WOURLOK ) {\n+         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n+         const char* _urlerr;\n+         _urlerr = WOURLstrerror( charcheck );\n+         die( _urlerr, HTTP_BAD_REQUEST );\n+      }\n+\n       urlerr = WOParseApplicationName(&wc, url);\n       if (urlerr != WOURLOK) {\n          const char *_urlerr;",
        "diff_line_info": {
            "deleted_lines": [
                "      "
            ],
            "added_lines": [
                "      WOURLError charcheck;",
                "",
                "      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "      charcheck = WOValidateInitialURL( url );",
                "      if ( charcheck != WOURLOK ) {",
                "         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");",
                "         const char* _urlerr;",
                "         _urlerr = WOURLstrerror( charcheck );",
                "         die( _urlerr, HTTP_BAD_REQUEST );",
                "      }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/WebObjects_translate",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/9e75cb6cadd4df2d225209f2ff9f82bfd7fbe432",
        "commit_title": "Added WOAdaptor fix for all adaptor versions and incremented the version indicator. Changes are in accordance with my published article at https://xmit.xyz/security/webobjects-url-tomfoolery/",
        "commit_text": "",
        "func_before": "int WebObjects_translate(request_rec *r) {\n    WebObjects_config *wc;\n    WOURLComponents url;\n    WOURLError urlerr;\n\n    // get the module configuration (this is the structure created by WebObjects_create_config())\n    wc = ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> new translate: %s\", r->uri);\n    if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0 || (r->handler != NULL && strcasecmp(r->handler, WEBOBJECTS) == 0)) {\n#ifndef _MSC_VER // SWK changed url = WOURLComponents_Initializer; to memset(&url,0,sizeof(WOURLComponents));\n        url = WOURLComponents_Initializer;\n#else\n        memset(&url,0,sizeof(WOURLComponents));\n#endif\n        urlerr = WOParseApplicationName(&url, r->uri);\n        if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n            WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n            return DECLINED;\n        }\n        if (!adaptorEnabled)\n        {\n            WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n            return DECLINED;\n        }\n\n\n        /*\n         *  we'll take it - mark our handler...\n         */\n        r->handler = (char *)apr_pstrdup(r->pool, WEBOBJECTS);\n        r->filename = (char *)apr_pstrdup(r->pool, r->uri);\n\n        return OK;\n    }\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n\n    return DECLINED;\n}",
        "func": "int WebObjects_translate(request_rec *r) {\n    WebObjects_config *wc;\n    WOURLComponents url;\n    WOURLError urlerr;\n    WOURLError charcheck;\n\n    // get the module configuration (this is the structure created by WebObjects_create_config())\n    wc = ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> new translate: %s\", r->uri);\n    if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0 || (r->handler != NULL && strcasecmp(r->handler, WEBOBJECTS) == 0)) {\n#ifndef _MSC_VER // SWK changed url = WOURLComponents_Initializer; to memset(&url,0,sizeof(WOURLComponents));\n        url = WOURLComponents_Initializer;\n#else\n        memset(&url,0,sizeof(WOURLComponents));\n#endif\n\n        // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n        charcheck = WOValidateInitialURL( r->uri );\n        if ( charcheck != WOURLOK ) {\n            WOLog(WO_DBG, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n            return DECLINED;\n        }\n\n        urlerr = WOParseApplicationName(&url, r->uri);\n        if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n            WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n            return DECLINED;\n        }\n        if (!adaptorEnabled)\n        {\n            WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n            return DECLINED;\n        }\n\n\n        /*\n         *  we'll take it - mark our handler...\n         */\n        r->handler = (char *)apr_pstrdup(r->pool, WEBOBJECTS);\n        r->filename = (char *)apr_pstrdup(r->pool, r->uri);\n\n        return OK;\n    }\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n\n    return DECLINED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n     WebObjects_config *wc;\n     WOURLComponents url;\n     WOURLError urlerr;\n+    WOURLError charcheck;\n \n     // get the module configuration (this is the structure created by WebObjects_create_config())\n     wc = ap_get_module_config(r->server->module_config, &WebObjects_module);\n@@ -13,6 +14,14 @@\n #else\n         memset(&url,0,sizeof(WOURLComponents));\n #endif\n+\n+        // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+        charcheck = WOValidateInitialURL( r->uri );\n+        if ( charcheck != WOURLOK ) {\n+            WOLog(WO_DBG, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n+            return DECLINED;\n+        }\n+\n         urlerr = WOParseApplicationName(&url, r->uri);\n         if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n             WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    WOURLError charcheck;",
                "",
                "        // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "        charcheck = WOValidateInitialURL( r->uri );",
                "        if ( charcheck != WOURLOK ) {",
                "            WOLog(WO_DBG, \"WebObjects_translate(): declining request due to forbidden URL characters\");",
                "            return DECLINED;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/WOParseApplicationName",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/9e75cb6cadd4df2d225209f2ff9f82bfd7fbe432",
        "commit_title": "Added WOAdaptor fix for all adaptor versions and incremented the version indicator. Changes are in accordance with my published article at https://xmit.xyz/security/webobjects-url-tomfoolery/",
        "commit_text": "",
        "func_before": "WOURLError WOParseApplicationName(WOURLComponents *wc, const char *url) {\n    int len;\n    const char *s;\n    const char *webobjects, *extension, *version, *start, *end;\n    int i;\n\n    len = strlen(url);\n\n    webobjects = NULL;\n\n    /*\n     *\tspot our marker in the URL.  It'll look like \"/WebObjects-n.ext/\"\n     */\n    s = (url != NULL) ? url : \"\";\n    while ( (s <= url + (len - WebObjects_LEN)) && (webobjects == NULL) && (*s != '?') ) {\n        while ((*s != '/') && (s <= url + (len - WebObjects_LEN)))\n            s++;\n        if ((strncmp(s, WebObjects_STR, WebObjects_LEN) == 0) ||\n            (strncmp(s, WEBOBJECTS_STR, WebObjects_LEN) == 0) )\n            webobjects = s;\n        else\n            s++;\n    }\n    if (webobjects == NULL)\n        return WOURLInvalidPrefix;\t/* bail if \"WebObjects\" not in URL */\n\n    s = webobjects + WebObjects_LEN;\t/* just beyond \"WebObjects\" */\n    for (end = s; (end < url + len) && (*end != '?') && (*end != '/'); end++)\n        /* find end of CGI moniker */;\n\n    version = (*s == '-') ? s : NULL;\t/* do we have a version? */\n    extension = NULL;\n\n    for (i=0; (extension == NULL) && (cgi_extensions[i] != NULL); i++) {\n        int n = strlen(cgi_extensions[i]);\n        if ((end - n >= version) && (strncmp(end-n, cgi_extensions[i], n) == 0))\n            extension = end - n;\n    }\n\n    /*\n    *\tjust validate the prefix gunk....\n    */\n    if (extension != NULL) {\n       if (version && ((extension - (version+1) < 1) || ( !isdigit((int)*(extension-1)) )))\n            return WOURLInvalidWebObjectsVersion;\n    } else if (version != NULL) {\n       if ((end - (version+1) < 1) || ( !isdigit((int)*(end-1)) ))\n            return WOURLInvalidWebObjectsVersion;\n    } else if ((end - s) > 1 )\n        return WOURLInvalidPrefix;\n\n    wc->prefix.start = url;\n    wc->prefix.length = end - url;\n    if (version != NULL) {\n        wc->webObjectsVersion.start = version + 1;\n        wc->webObjectsVersion.length = ((extension) ? extension : end)-version;\n    }\n\n    /*\n    *\tfind the application name\n    *\t  - we're not supporting WO version 2 URLs here....\n    *\t  - this is probably more convoluted than it need be\n    */\n    start = ((end < url + len) && (*end != '?')) ? end + 1 : end;\n    end = url + len;\n    extension = end;\n    for (i=0; (extension == end) && (app_extensions[i] != NULL); i++) {\n        int n = strlen(app_extensions[i]);\n        for (s=start; (s+n <= url+len) && (*s != '?') && (extension == end); ++s) {\n            if ( (strncmp(s, app_extensions[i], n) == 0) &&\n                    ((s + n == url + len) || (*(s+n) == '?') || (*(s+n) == '/')) )\n            {\n                extension = s;\n                end = s + n;\n            }\n        }\n        if (*s == '?')\n            end = s;\n    }\n\n    /* start == pointer to first character of name. */\n    /* extension == pointer to first character after name. */\n    /* end == pointer to first character after extension. */\n    wc->applicationName.length = (end < extension) ? end - start : extension - start;\n    if (wc->applicationName.length != 0) {\n        wc->applicationName.start = start;\n\n        /* get rid of trailing slashes in case the app name is last */\n        /* and followed by trailing slashes */\n        while(wc->applicationName.length && wc->applicationName.start[wc->applicationName.length-1] == '/')\n            wc->applicationName.length--;\n        return WOURLOK;\n    } else\n        return WOURLInvalidApplicationName;\n}",
        "func": "WOURLError WOParseApplicationName(WOURLComponents *wc, const char *url) {\n    int len;\n    const char *s;\n    const char *webobjects, *extension, *version, *start, *end;\n    int i;\n\n    len = strlen(url);\n\n    webobjects = NULL;\n\n    /*\n     *\tspot our marker in the URL.  It'll look like \"/WebObjects-n.ext/\"\n     */\n    s = (url != NULL) ? url : \"\";\n    while ( (s <= url + (len - WebObjects_LEN)) && (webobjects == NULL) && (*s != '?') ) {\n        while ((*s != '/') && (s <= url + (len - WebObjects_LEN)))\n            s++;\n        if ((strncmp(s, WebObjects_STR, WebObjects_LEN) == 0) ||\n            (strncmp(s, WEBOBJECTS_STR, WebObjects_LEN) == 0) )\n            webobjects = s;\n        else\n            s++;\n    }\n    if (webobjects == NULL)\n        return WOURLInvalidPrefix;\t/* bail if \"WebObjects\" not in URL */\n\n    s = webobjects + WebObjects_LEN;\t/* just beyond \"WebObjects\" */\n    for (end = s; (end < url + len) && (*end != '?') && (*end != '/'); end++)\n        /* find end of CGI moniker */;\n\n    version = (*s == '-') ? s : NULL;\t/* do we have a version? */\n    extension = NULL;\n\n    for (i=0; (extension == NULL) && (cgi_extensions[i] != NULL); i++) {\n        int n = strlen(cgi_extensions[i]);\n        if ((end - n >= version) && (strncmp(end-n, cgi_extensions[i], n) == 0))\n            extension = end - n;\n    }\n\n    /*\n    *   just validate the prefix gunk....\n    *   -- Added fix for invalid WO version info\n    */\n    if (extension != NULL) {\n       if (version && ((extension - (version+1) < 1) || (extension - (version+1) > 5) || ( !isdigit((int)*(extension-1)) )))\n            return WOURLInvalidWebObjectsVersion;\n    } else if (version != NULL) {\n       if ((end - (version+1) < 1) || (end - (version+1) > 5) || ( !isdigit((int)*(end-1)) ))\n            return WOURLInvalidWebObjectsVersion;\n    } else if ((end - s) > 1 )\n        return WOURLInvalidPrefix;\n\n    // Iterate the version string and match it to the regex: [a-z0-9\\.\\-_]+\n    //   Its length is already constrained by the above conditional statements.\n    if ( version != NULL ) {\n        int versionLen = ((extension) ? extension : end)-version;\n        for ( const char* v = (version+1); (*v) && v < version+versionLen; v++ ) {\n            if ( !isalnum( (int)*v ) && (*v != '.') && (*v != '-') && (*v != '_') )\n                return WOURLInvalidWebObjectsVersion;\n        }\n    }\n\n    wc->prefix.start = url;\n    wc->prefix.length = end - url;\n    if (version != NULL) {\n        wc->webObjectsVersion.start = version + 1;\n        wc->webObjectsVersion.length = ((extension) ? extension : end)-version;\n    }\n\n    /*\n    *\tfind the application name\n    *\t  - we're not supporting WO version 2 URLs here....\n    *\t  - this is probably more convoluted than it need be\n    */\n    start = ((end < url + len) && (*end != '?')) ? end + 1 : end;\n    end = url + len;\n    extension = end;\n    for (i=0; (extension == end) && (app_extensions[i] != NULL); i++) {\n        int n = strlen(app_extensions[i]);\n        for (s=start; (s+n <= url+len) && (*s != '?') && (extension == end); ++s) {\n            if ( (strncmp(s, app_extensions[i], n) == 0) &&\n                    ((s + n == url + len) || (*(s+n) == '?') || (*(s+n) == '/')) )\n            {\n                extension = s;\n                end = s + n;\n            }\n        }\n        if (*s == '?')\n            end = s;\n    }\n\n    /* start == pointer to first character of name. */\n    /* extension == pointer to first character after name. */\n    /* end == pointer to first character after extension. */\n    wc->applicationName.length = (end < extension) ? end - start : extension - start;\n    if (wc->applicationName.length != 0) {\n        wc->applicationName.start = start;\n\n        /* get rid of trailing slashes in case the app name is last */\n        /* and followed by trailing slashes */\n        while(wc->applicationName.length && wc->applicationName.start[wc->applicationName.length-1] == '/')\n            wc->applicationName.length--;\n        return WOURLOK;\n    } else\n        return WOURLInvalidApplicationName;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,16 +38,27 @@\n     }\n \n     /*\n-    *\tjust validate the prefix gunk....\n+    *   just validate the prefix gunk....\n+    *   -- Added fix for invalid WO version info\n     */\n     if (extension != NULL) {\n-       if (version && ((extension - (version+1) < 1) || ( !isdigit((int)*(extension-1)) )))\n+       if (version && ((extension - (version+1) < 1) || (extension - (version+1) > 5) || ( !isdigit((int)*(extension-1)) )))\n             return WOURLInvalidWebObjectsVersion;\n     } else if (version != NULL) {\n-       if ((end - (version+1) < 1) || ( !isdigit((int)*(end-1)) ))\n+       if ((end - (version+1) < 1) || (end - (version+1) > 5) || ( !isdigit((int)*(end-1)) ))\n             return WOURLInvalidWebObjectsVersion;\n     } else if ((end - s) > 1 )\n         return WOURLInvalidPrefix;\n+\n+    // Iterate the version string and match it to the regex: [a-z0-9\\.\\-_]+\n+    //   Its length is already constrained by the above conditional statements.\n+    if ( version != NULL ) {\n+        int versionLen = ((extension) ? extension : end)-version;\n+        for ( const char* v = (version+1); (*v) && v < version+versionLen; v++ ) {\n+            if ( !isalnum( (int)*v ) && (*v != '.') && (*v != '-') && (*v != '_') )\n+                return WOURLInvalidWebObjectsVersion;\n+        }\n+    }\n \n     wc->prefix.start = url;\n     wc->prefix.length = end - url;",
        "diff_line_info": {
            "deleted_lines": [
                "    *\tjust validate the prefix gunk....",
                "       if (version && ((extension - (version+1) < 1) || ( !isdigit((int)*(extension-1)) )))",
                "       if ((end - (version+1) < 1) || ( !isdigit((int)*(end-1)) ))"
            ],
            "added_lines": [
                "    *   just validate the prefix gunk....",
                "    *   -- Added fix for invalid WO version info",
                "       if (version && ((extension - (version+1) < 1) || (extension - (version+1) > 5) || ( !isdigit((int)*(extension-1)) )))",
                "       if ((end - (version+1) < 1) || (end - (version+1) > 5) || ( !isdigit((int)*(end-1)) ))",
                "",
                "    // Iterate the version string and match it to the regex: [a-z0-9\\.\\-_]+",
                "    //   Its length is already constrained by the above conditional statements.",
                "    if ( version != NULL ) {",
                "        int versionLen = ((extension) ? extension : end)-version;",
                "        for ( const char* v = (version+1); (*v) && v < version+versionLen; v++ ) {",
                "            if ( !isalnum( (int)*v ) && (*v != '.') && (*v != '-') && (*v != '_') )",
                "                return WOURLInvalidWebObjectsVersion;",
                "        }",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/doit",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/9e75cb6cadd4df2d225209f2ff9f82bfd7fbe432",
        "commit_title": "Added WOAdaptor fix for all adaptor versions and incremented the version indicator. Changes are in accordance with my published article at https://xmit.xyz/security/webobjects-url-tomfoolery/",
        "commit_text": "",
        "func_before": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n      \n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "func": "int doit(int argc, char *argv[], char **envp) {\n#else\n   /*\n    * the request handler...\n    */\n   int main(int argc, char *argv[], char **envp) {\n#endif\n      HTTPRequest *req;\n      HTTPResponse *resp = NULL;\n      WOURLComponents wc = WOURLComponents_Initializer;\n      const char *qs;\n      unsigned int qs_len;\n      char *url;\n      const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n      const char *reqerr;\n      WOURLError urlerr;\n      WOURLError charcheck;\n      strtbl *options = NULL;\n\n#ifdef WIN32\n      _setmode(_fileno(stdout), _O_BINARY);\n      _setmode(_fileno(stdin), _O_BINARY);\n#endif\n\n      if(argc == 2 && strcmp(argv[1], \"test\") == 0)\n      {\n\texit(do_tests());\n      }\n\n      script_name = getenv(CGI_SCRIPT_NAME);\n      path_info = getenv(CGI_PATH_INFO);\n\n      if (script_name == NULL)\n         die(INV_SCRIPT, HTTP_NOT_FOUND);\n      else if (path_info == NULL) {\n         path_info = \"/\";\n      }\n      /* Provide a hook via an environment variable to define the config URL */\n      config_url = getenv(WO_CONFIG_URL);\n      if (!config_url) {\n         /* Flat file URL */\n         /* config_url = \"file:///Local/Library/WebObjects/Configuration/WOConfig.xml\"; */\n         /* Local wotaskd */\n         /* config_url = \"http://localhost:1085\"; */\n         /* Multicast URL */\n         config_url = CONFIG_URL; /* Actually \"webobjects://239.128.14.2:1085\"; */\n      }\n      WOLog(WO_INFO,\"CGI: config url is %s\", config_url);\n      options = st_new(8);\n      st_add(options, WOCONFIG, config_url, 0);\n\n      /*\n         * If your webserver is configured to pass these environment variables, we use them to\n       * protect WOAdaptorInfo output.\n       */\n      username = getenv(WO_ADAPTOR_INFO_USERNAME);\n      if (username && strlen(username) != 0) {\n         st_add(options, WOUSERNAME, username, 0);\n         password = getenv(WO_ADAPTOR_INFO_PASSWORD);\n         if(password && strlen(password) != 0) {\n            st_add(options, WOPASSWORD, password, 0);\n         }\n      }\n\n      config_options = getenv(WO_CONFIG_OPTIONS);\n      if (config_options)\n         st_add(options, WOOPTIONS, config_options, 0);\n      /*\n       * SECURITY ALERT\n       *\n       * To disable WOAdaptorInfo, uncomment the next line.\n       * st_add(options, WOUSERNAME, \"disabled\", 0);\n       *\n       * To specify an WOAdaptorInfo username and password, uncomment the next two lines.\n       * st_add(options, WOUSERNAME, \"joe\", 0);\n       * st_add(options, WOPASSWORD, \"secret\", 0);\n       *\n       */\n\n      if (init_adaptor(options)) {\n          die(\"The request could not be completed due to a server error.\", HTTP_SERVER_ERROR);\n      }\n\n      /*\n       *  extract WebObjects application name from URI\n       */\n\n      url = WOMALLOC(strlen(path_info) + strlen(script_name) + 1);\n      strcpy(url, script_name);\n      strcat(url, path_info);\n      WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n\n      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n      charcheck = WOValidateInitialURL( url );\n      if ( charcheck != WOURLOK ) {\n         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n         const char* _urlerr;\n         _urlerr = WOURLstrerror( charcheck );\n         die( _urlerr, HTTP_BAD_REQUEST );\n      }\n\n      urlerr = WOParseApplicationName(&wc, url);\n      if (urlerr != WOURLOK) {\n         const char *_urlerr;\n         _urlerr = WOURLstrerror(urlerr);\n         WOLog(WO_INFO,\"URL Parsing Error: %s\", _urlerr);\n\n         if (urlerr == WOURLInvalidApplicationName) {\n             if (ac_authorizeAppListing(&wc)) {\n                 resp = WOAdaptorInfo(NULL, &wc);\n                 die_resp(resp);\n             } else {\n                 die(_urlerr, HTTP_NOT_FOUND);\n             }\n         }\n\n         die(_urlerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  build the request...\n       */\n      req = req_new( getenv(\"REQUEST_METHOD\"), NULL);\n\n      /*\n       *  validate the method\n       */\n      reqerr = req_validateMethod(req);\n      if (reqerr) {\n          die(reqerr, HTTP_BAD_REQUEST);\n      }\n\n      /*\n       *  copy the headers.  This looks wierd... all we're doing is copying\n       *  *every* environment variable into our headers.  It may be beyond\n       *  the spec, but more information probably won't hurt.\n       */\n      while (envp && *envp) {\n         char *key, *value;\n         /* copy env. line. */\n         key = WOSTRDUP(*envp);\n\n         for (value = key; *value && !isspace((int)*value) && (*value != '='); value++) {}\n         if (*value) {\n            *value++ = '\\0';  /* null terminate 'key' */\n         }\n         while (*value && (isspace((int)*value) || (*value == '='))) {\n            value++;\n         }\n         /* BEGIN Support for getting the client's certificate. */\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERTIFICATE\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERTIFICATE\") == 0 ) {\n             value = 0;\n             WOLog(WO_INFO,\"<CGI> DROPPING ENV VAR (DUPLICATE) = %s\", key);\n         }\n         if (strcmp((const char *)key, \"SSL_CLIENT_CERT\") == 0 || strcmp((const char *)key, \"SSL_SERVER_CERT\") == 0) {\n             value = make_cert_one_line(value);\n             //WOLog(WO_INFO,\"<CGI> PASSING %s = %s\", key, value);\n         }\n         /*  END Support for getting the client's certificate  */\n\n         if (key && *key && value && *value) {\n            /* must specify copy key and value because key translation might replace this key, and value lives in the same buffer */\n            req_addHeader(req, key, value, STR_COPYKEY|STR_COPYVALUE);\n         }\n\n         /*  BEGIN Support for getting the client's certificate  */\n         if (freeValueNeeded ) {\n             free(value);\n             freeValueNeeded=0;\n         }\n         /*  END Support for getting the client's certificate  */\n\n         WOFREE(key);\n         envp++;      /* next env variable */\n      }\n\n      /*\n       *  get form data if any\n       *  assume that POSTs with content length will be reformatted to GETs later\n       */\n      if (req->content_length > 0) {\n         req_allocateContent(req, req->content_length, 1);\n         req->getMoreContent = (req_getMoreContentCallback)readContentData;\n         if (req->content_buffer_size == 0)\n            die(ALLOCATION_FAILURE, HTTP_SERVER_ERROR);\n         if (readContentData(req, req->content, req->content_buffer_size, 1) == -1) {\n            die(WOURLstrerror(WOURLInvalidPostData), HTTP_BAD_REQUEST);\n         }\n      }\n\n      /* Always get the query string */\n      qs = getenv(\"QUERY_STRING\");\n      if (qs) {\n         qs_len = strlen(qs);\n      } else {\n         qs_len = 0;\n      }\n\n      if (qs_len > 0) {\n         wc.queryString.start = qs;\n         wc.queryString.length = qs_len;\n         WOLog(WO_INFO,\"<CGI> new request with Query String: %s\", qs);\n      }\n\n      /*\n       *  message the application & collect the response\n       */\n      resp = tr_handleRequest(req, url, &wc, getenv(CGI_SERVER_PROTOCOL), documentRoot());\n\n      if (resp != NULL) {\n         sendResponse(resp);\n         resp_free(resp);   /* dump the response */\n      }\n\n      WOFREE(url);\n      st_free(options);\n      req_free(req);\n      \n#if defined(FINDLEAKS)\n      showleaks();\n#endif\n      return 0;\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n       const char *script_name, *path_info, *config_url, *username, *password, *config_options;\n       const char *reqerr;\n       WOURLError urlerr;\n+      WOURLError charcheck;\n       strtbl *options = NULL;\n \n #ifdef WIN32\n@@ -88,7 +89,16 @@\n       strcpy(url, script_name);\n       strcat(url, path_info);\n       WOLog(WO_INFO,\"<CGI> new request: %s\",url);\n-      \n+\n+      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+      charcheck = WOValidateInitialURL( url );\n+      if ( charcheck != WOURLOK ) {\n+         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");\n+         const char* _urlerr;\n+         _urlerr = WOURLstrerror( charcheck );\n+         die( _urlerr, HTTP_BAD_REQUEST );\n+      }\n+\n       urlerr = WOParseApplicationName(&wc, url);\n       if (urlerr != WOURLOK) {\n          const char *_urlerr;",
        "diff_line_info": {
            "deleted_lines": [
                "      "
            ],
            "added_lines": [
                "      WOURLError charcheck;",
                "",
                "      // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "      charcheck = WOValidateInitialURL( url );",
                "      if ( charcheck != WOURLOK ) {",
                "         WOLog(WO_INFO, \"Declining request due to forbidden URL characters.\");",
                "         const char* _urlerr;",
                "         _urlerr = WOURLstrerror( charcheck );",
                "         die( _urlerr, HTTP_BAD_REQUEST );",
                "      }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37724",
        "func_name": "wocommunity/wonder/WebObjects_translate",
        "description": "Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.",
        "git_url": "https://github.com/wocommunity/wonder/commit/9e75cb6cadd4df2d225209f2ff9f82bfd7fbe432",
        "commit_title": "Added WOAdaptor fix for all adaptor versions and incremented the version indicator. Changes are in accordance with my published article at https://xmit.xyz/security/webobjects-url-tomfoolery/",
        "commit_text": "",
        "func_before": "int WebObjects_translate(request_rec *r) {\n    WebObjects_config *wc;\n    WOURLComponents url;\n    WOURLError urlerr;\n\n    // get the module configuration (this is the structure created by WebObjects_create_config())\n    wc = ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> new translate: %s\", r->uri);\n    if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0 || (r->handler != NULL && strcasecmp(r->handler, WEBOBJECTS) == 0)) {\n#ifndef _MSC_VER // SWK changed url = WOURLComponents_Initializer; to memset(&url,0,sizeof(WOURLComponents));\n        url = WOURLComponents_Initializer;\n#else\n        memset(&url,0,sizeof(WOURLComponents));\n#endif\n        urlerr = WOParseApplicationName(&url, r->uri);\n        if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n            WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n            return DECLINED;\n        }\n        if (!adaptorEnabled)\n        {\n            WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n            return DECLINED;\n        }\n\n\n        /*\n         *  we'll take it - mark our handler...\n         */\n        r->handler = (char *)apr_pstrdup(r->pool, WEBOBJECTS);\n        r->filename = (char *)apr_pstrdup(r->pool, r->uri);\n\n        return OK;\n    }\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n\n    return DECLINED;\n}",
        "func": "int WebObjects_translate(request_rec *r) {\n    WebObjects_config *wc;\n    WOURLComponents url;\n    WOURLError urlerr;\n    WOURLError charcheck;\n\n    // get the module configuration (this is the structure created by WebObjects_create_config())\n    wc = ap_get_module_config(r->server->module_config, &WebObjects_module);\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> new translate: %s\", r->uri);\n    if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0 || (r->handler != NULL && strcasecmp(r->handler, WEBOBJECTS) == 0)) {\n#ifndef _MSC_VER // SWK changed url = WOURLComponents_Initializer; to memset(&url,0,sizeof(WOURLComponents));\n        url = WOURLComponents_Initializer;\n#else\n        memset(&url,0,sizeof(WOURLComponents));\n#endif\n\n        // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n        charcheck = WOValidateInitialURL( r->uri );\n        if ( charcheck != WOURLOK ) {\n            WOLog(WO_DBG, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n            return DECLINED;\n        }\n\n        urlerr = WOParseApplicationName(&url, r->uri);\n        if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n            WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n            return DECLINED;\n        }\n        if (!adaptorEnabled)\n        {\n            WOLog(WO_ERR, \"WebObjects_translate(): declining request due to initialization failure\");\n            return DECLINED;\n        }\n\n\n        /*\n         *  we'll take it - mark our handler...\n         */\n        r->handler = (char *)apr_pstrdup(r->pool, WEBOBJECTS);\n        r->filename = (char *)apr_pstrdup(r->pool, r->uri);\n\n        return OK;\n    }\n\n    WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);\n\n    return DECLINED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n     WebObjects_config *wc;\n     WOURLComponents url;\n     WOURLError urlerr;\n+    WOURLError charcheck;\n \n     // get the module configuration (this is the structure created by WebObjects_create_config())\n     wc = ap_get_module_config(r->server->module_config, &WebObjects_module);\n@@ -13,6 +14,14 @@\n #else\n         memset(&url,0,sizeof(WOURLComponents));\n #endif\n+\n+        // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).\n+        charcheck = WOValidateInitialURL( r->uri );\n+        if ( charcheck != WOURLOK ) {\n+            WOLog(WO_DBG, \"WebObjects_translate(): declining request due to forbidden URL characters\");\n+            return DECLINED;\n+        }\n+\n         urlerr = WOParseApplicationName(&url, r->uri);\n         if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) {\n             WOLog(WO_DBG, \"<WebObjects Apache Module> translate - DECLINED: %s\", r->uri);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    WOURLError charcheck;",
                "",
                "        // Make sure the URL does not contain forbidden characters (0x0D or 0x0A).",
                "        charcheck = WOValidateInitialURL( r->uri );",
                "        if ( charcheck != WOURLOK ) {",
                "            WOLog(WO_DBG, \"WebObjects_translate(): declining request due to forbidden URL characters\");",
                "            return DECLINED;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1652",
        "func_name": "chromium/ModuleSystem::RequireForJsInner",
        "description": "Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the Extensions subsystem in Google Chrome before 50.0.2661.75 allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/75b803b1c81ed9fa5513cbff550232b4fb915e7b",
        "commit_title": "[Extensions] Harden against bindings interception",
        "commit_text": " There's more we can do but this is a start.    ",
        "func_before": "v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n    v8::Local<v8::String> module_name) {\n  v8::EscapableHandleScope handle_scope(GetIsolate());\n  v8::Local<v8::Context> v8_context = context()->v8_context();\n  v8::Context::Scope context_scope(v8_context);\n\n  v8::Local<v8::Object> global(context()->v8_context()->Global());\n\n  // The module system might have been deleted. This can happen if a different\n  // context keeps a reference to us, but our frame is destroyed (e.g.\n  // background page keeps reference to chrome object in a closed popup).\n  v8::Local<v8::Value> modules_value;\n  if (!GetPrivate(global, kModulesField, &modules_value) ||\n      modules_value->IsUndefined()) {\n    Warn(GetIsolate(), \"Extension view no longer exists\");\n    return v8::Undefined(GetIsolate());\n  }\n\n  v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n  v8::Local<v8::Value> exports;\n  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n      !exports->IsUndefined())\n    return handle_scope.Escape(exports);\n\n  exports = LoadModule(*v8::String::Utf8Value(module_name));\n  SetProperty(v8_context, modules, module_name, exports);\n  return handle_scope.Escape(exports);\n}",
        "func": "v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n    v8::Local<v8::String> module_name) {\n  v8::EscapableHandleScope handle_scope(GetIsolate());\n  v8::Local<v8::Context> v8_context = context()->v8_context();\n  v8::Context::Scope context_scope(v8_context);\n\n  v8::Local<v8::Object> global(context()->v8_context()->Global());\n\n  // The module system might have been deleted. This can happen if a different\n  // context keeps a reference to us, but our frame is destroyed (e.g.\n  // background page keeps reference to chrome object in a closed popup).\n  v8::Local<v8::Value> modules_value;\n  if (!GetPrivate(global, kModulesField, &modules_value) ||\n      modules_value->IsUndefined()) {\n    Warn(GetIsolate(), \"Extension view no longer exists\");\n    return v8::Undefined(GetIsolate());\n  }\n\n  v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n  v8::Local<v8::Value> exports;\n  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||\n      !exports->IsUndefined())\n    return handle_scope.Escape(exports);\n\n  exports = LoadModule(*v8::String::Utf8Value(module_name));\n  SetPrivateProperty(v8_context, modules, module_name, exports);\n  return handle_scope.Escape(exports);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,11 +18,11 @@\n \n   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n   v8::Local<v8::Value> exports;\n-  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n+  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||\n       !exports->IsUndefined())\n     return handle_scope.Escape(exports);\n \n   exports = LoadModule(*v8::String::Utf8Value(module_name));\n-  SetProperty(v8_context, modules, module_name, exports);\n+  SetPrivateProperty(v8_context, modules, module_name, exports);\n   return handle_scope.Escape(exports);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!GetProperty(v8_context, modules, module_name, &exports) ||",
                "  SetProperty(v8_context, modules, module_name, exports);"
            ],
            "added_lines": [
                "  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||",
                "  SetPrivateProperty(v8_context, modules, module_name, exports);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9714",
        "func_name": "facebook/hhvm/WddxPacket::recursiveAddVar",
        "description": "Cross-site scripting (XSS) vulnerability in the WddxPacket::recursiveAddVar function in HHVM (aka the HipHop Virtual Machine) before 3.5.0 allows remote attackers to inject arbitrary web script or HTML via a crafted string to the wddx_serialize_value function.",
        "git_url": "https://github.com/facebook/hhvm/commit/324701c9fd31beb4f070f1b7ef78b115fbdfec34",
        "commit_title": "HTMLEncode strings in wddx_serialize_value()",
        "commit_text": " Summary: Strings returned through wddx_serialize_value should be HTMLEncode()'d during serialization.  Fixes #4283  {sync, type=\"child\", parent=\"internal\", parentrevid=\"1691695\", parentrevfbid=\"1537976659780590\", parentdiffid=\"5726084\"}  Reviewed By: @JoelMarcey  Differential Revision: D1691695  Signature: t1:1691695:1416530595:722bfcdaf7c0dbee379bea886cd4c43d997ca7dd",
        "func_before": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      //empty object\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue = varVariant.toString().data();\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n\n  return false;\n}",
        "func": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      //empty object\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue;\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    } else {\n      varValue = StringUtil::HtmlEncode(varVariant.toString(),\n                                        StringUtil::QuoteStyle::Double,\n                                        \"UTF-8\", false, false).toCppString();\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,9 +65,13 @@\n \n   std::string varType = getDataTypeString(varVariant.getType()).data();\n   if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n-    std::string varValue = varVariant.toString().data();\n+    std::string varValue;\n     if (varType.compare(\"boolean\") == 0) {\n       varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n+    } else {\n+      varValue = StringUtil::HtmlEncode(varVariant.toString(),\n+                                        StringUtil::QuoteStyle::Double,\n+                                        \"UTF-8\", false, false).toCppString();\n     }\n     m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n     return true;",
        "diff_line_info": {
            "deleted_lines": [
                "    std::string varValue = varVariant.toString().data();"
            ],
            "added_lines": [
                "    std::string varValue;",
                "    } else {",
                "      varValue = StringUtil::HtmlEncode(varVariant.toString(),",
                "                                        StringUtil::QuoteStyle::Double,",
                "                                        \"UTF-8\", false, false).toCppString();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1286",
        "func_name": "chromium/V8ContextNativeHandler::GetModuleSystem",
        "description": "Cross-site scripting (XSS) vulnerability in the V8ContextNativeHandler::GetModuleSystem function in extensions/renderer/v8_context_native_handler.cc in Google Chrome before 44.0.2403.89 allows remote attackers to inject arbitrary web script or HTML by leveraging the lack of a certain V8 context restriction, aka a Blink \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/3b1351e5ead02ced4a026fcc6c6a24215a428f56",
        "commit_title": "Don't create cross origins references in the extension system",
        "commit_text": "   ",
        "func_before": "void V8ContextNativeHandler::GetModuleSystem(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(args.Length(), 1);\n  CHECK(args[0]->IsObject());\n  v8::Local<v8::Context> v8_context =\n      v8::Local<v8::Object>::Cast(args[0])->CreationContext();\n  ScriptContext* context =\n      dispatcher_->script_context_set().GetByV8Context(v8_context);\n  args.GetReturnValue().Set(context->module_system()->NewInstance());\n}",
        "func": "void V8ContextNativeHandler::GetModuleSystem(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(args.Length(), 1);\n  CHECK(args[0]->IsObject());\n  v8::Local<v8::Context> v8_context =\n      v8::Local<v8::Object>::Cast(args[0])->CreationContext();\n  ScriptContext* context =\n      dispatcher_->script_context_set().GetByV8Context(v8_context);\n  if (blink::WebFrame::scriptCanAccess(context->web_frame()))\n    args.GetReturnValue().Set(context->module_system()->NewInstance());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,5 +6,6 @@\n       v8::Local<v8::Object>::Cast(args[0])->CreationContext();\n   ScriptContext* context =\n       dispatcher_->script_context_set().GetByV8Context(v8_context);\n-  args.GetReturnValue().Set(context->module_system()->NewInstance());\n+  if (blink::WebFrame::scriptCanAccess(context->web_frame()))\n+    args.GetReturnValue().Set(context->module_system()->NewInstance());\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  args.GetReturnValue().Set(context->module_system()->NewInstance());"
            ],
            "added_lines": [
                "  if (blink::WebFrame::scriptCanAccess(context->web_frame()))",
                "    args.GetReturnValue().Set(context->module_system()->NewInstance());"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3881",
        "func_name": "android/HTMLPlugInImageElement::allowedToLoadFrameURL",
        "description": "WebKit, as used in Google Chrome before 15.0.874.102 and Android before 4.4, allows remote attackers to bypass the Same Origin Policy and conduct Universal XSS (UXSS) attacks via vectors related to (1) the DOMWindow::clear function and use of a selection object, (2) the Object::GetRealNamedPropertyInPrototypeChain function and use of an __proto__ property, (3) the HTMLPlugInImageElement::allowedToLoadFrameURL function and use of a javascript: URL, (4) incorrect origins for XSLT-generated documents in the XSLTProcessor::createDocumentFromSource function, and (5) improper handling of synchronous frame loads in the ScriptController::executeIfJavaScriptURL function.",
        "git_url": "https://android.googlesource.com/platform/external/webkit/+/109d59bf6fe4abfd001fc60ddd403f1046b117ef",
        "commit_title": "Cherry pick r96826.",
        "commit_text": " Add check for JavaScript URLs in HTMLPlugInImageElement::allowedToLoadFrameURL  Bug: 17658625 ",
        "func_before": "bool HTMLPlugInImageElement::allowedToLoadFrameURL(const String& url)\n{\n    ASSERT(document());\n    ASSERT(document()->frame());\n    if (document()->frame()->page()->frameCount() >= Page::maxNumberOfFrames)\n        return false;\n\n    // We allow one level of self-reference because some sites depend on that.\n    // But we don't allow more than one.\n    KURL completeURL = document()->completeURL(url);\n    bool foundSelfReference = false;\n    for (Frame* frame = document()->frame(); frame; frame = frame->tree()->parent()) {\n        if (equalIgnoringFragmentIdentifier(frame->document()->url(), completeURL)) {\n            if (foundSelfReference)\n                return false;\n            foundSelfReference = true;\n        }\n    }\n    return true;\n}",
        "func": "bool HTMLPlugInImageElement::allowedToLoadFrameURL(const String& url)\n{\n    ASSERT(document());\n    ASSERT(document()->frame());\n    if (document()->frame()->page()->frameCount() >= Page::maxNumberOfFrames)\n        return false;\n\n    KURL completeURL = document()->completeURL(url);\n    \n    if (contentFrame() && protocolIsJavaScript(completeURL)\n        && !document()->securityOrigin()->canAccess(contentDocument()->securityOrigin()))\n        return false;\n    \n    // We allow one level of self-reference because some sites depend on that.\n    // But we don't allow more than one.\n    bool foundSelfReference = false;\n    for (Frame* frame = document()->frame(); frame; frame = frame->tree()->parent()) {\n        if (equalIgnoringFragmentIdentifier(frame->document()->url(), completeURL)) {\n            if (foundSelfReference)\n                return false;\n            foundSelfReference = true;\n        }\n    }\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,9 +5,14 @@\n     if (document()->frame()->page()->frameCount() >= Page::maxNumberOfFrames)\n         return false;\n \n+    KURL completeURL = document()->completeURL(url);\n+    \n+    if (contentFrame() && protocolIsJavaScript(completeURL)\n+        && !document()->securityOrigin()->canAccess(contentDocument()->securityOrigin()))\n+        return false;\n+    \n     // We allow one level of self-reference because some sites depend on that.\n     // But we don't allow more than one.\n-    KURL completeURL = document()->completeURL(url);\n     bool foundSelfReference = false;\n     for (Frame* frame = document()->frame(); frame; frame = frame->tree()->parent()) {\n         if (equalIgnoringFragmentIdentifier(frame->document()->url(), completeURL)) {",
        "diff_line_info": {
            "deleted_lines": [
                "    KURL completeURL = document()->completeURL(url);"
            ],
            "added_lines": [
                "    KURL completeURL = document()->completeURL(url);",
                "    ",
                "    if (contentFrame() && protocolIsJavaScript(completeURL)",
                "        && !document()->securityOrigin()->canAccess(contentDocument()->securityOrigin()))",
                "        return false;",
                "    "
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32792",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_post_preserve_javascript",
        "description": "mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. In mod_auth_openidc before version 2.4.9, there is an XSS vulnerability in when using `OIDCPreservePost On`.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/55ea0a085290cd2c8cdfdd960a230cbc38ba8b56",
        "commit_title": "Add a function to escape Javascript characters",
        "commit_text": "",
        "func_before": "apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\n\treturn TRUE;\n}",
        "func": "apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\toidc_util_javascript_escape(r->pool, location)) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,7 +44,7 @@\n \t\t\t\t\t\"    </script>\\n\", jmethod, json,\n \t\t\t\t\tlocation ?\n \t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n-\t\t\t\t\t\t\t\t\tlocation) :\n+\t\t\t\t\t\t\t\t\toidc_util_javascript_escape(r->pool, location)) :\n \t\t\t\t\t\t\t\t\t\"\");\n \tif (location == NULL) {\n \t\tif (javascript_method)",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t\t\t\t\tlocation) :"
            ],
            "added_lines": [
                "\t\t\t\t\t\t\t\t\toidc_util_javascript_escape(r->pool, location)) :"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32792",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_session_redirect_parent_window_to_logout",
        "description": "mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. In mod_auth_openidc before version 2.4.9, there is an XSS vulnerability in when using `OIDCPreservePost On`.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/55ea0a085290cd2c8cdfdd960a230cbc38ba8b56",
        "commit_title": "Add a function to escape Javascript characters",
        "commit_text": "",
        "func_before": "static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}",
        "func": "static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_util_javascript_escape(r->pool, oidc_get_redirect_uri(r, c)));\n\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \tchar *java_script = apr_psprintf(r->pool,\n \t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n \t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n-\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n+\t\t\t\"    </script>\\n\", oidc_util_javascript_escape(r->pool, oidc_get_redirect_uri(r, c)));\n \n \treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n \t\t\tOK);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));"
            ],
            "added_lines": [
                "\t\t\t\"    </script>\\n\", oidc_util_javascript_escape(r->pool, oidc_get_redirect_uri(r, c)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32792",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_request_post_preserved_restore",
        "description": "mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. In mod_auth_openidc before version 2.4.9, there is an XSS vulnerability in when using `OIDCPreservePost On`.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/55ea0a085290cd2c8cdfdd960a230cbc38ba8b56",
        "commit_title": "Add a function to escape Javascript characters",
        "commit_text": "",
        "func_before": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}",
        "func": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n \t\t\t\t\t\"        document.forms[0].submit();\\n\"\n \t\t\t\t\t\"      }\\n\"\n-\t\t\t\t\t\"    </script>\\n\", method, original_url);\n+\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n \n \tconst char *body = \"    <p>Restoring...</p>\\n\"\n \t\t\t\"    <form method=\\\"post\\\"></form>\\n\";",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t\"    </script>\\n\", method, original_url);"
            ],
            "added_lines": [
                "\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32792",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_request_post_preserved_restore",
        "description": "mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. In mod_auth_openidc before version 2.4.9, there is an XSS vulnerability in when using `OIDCPreservePost On`.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/00c315cb0c8ab77c67be4a2ac08a71a83ac58751",
        "commit_title": "avoid XSS vulnerability when using OIDCPreservePost On",
        "commit_text": " and supplying URLs that contain single quotes; thanks @oss-aimoto ",
        "func_before": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}",
        "func": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n \t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n \t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n \t\t\t\t\t\"        }\\n\"\n-\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n+\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n \t\t\t\t\t\"        document.forms[0].submit();\\n\"\n \t\t\t\t\t\"      }\\n\"\n \t\t\t\t\t\"    </script>\\n\", method, original_url);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\""
            ],
            "added_lines": [
                "\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-27920",
        "func_name": "kiwix/libkiwix/InternalServer::handle_content",
        "description": "libkiwix 10.0.0 and 10.0.1 allows XSS in the built-in webserver functionality via the search suggestions URL parameter. This is fixed in 10.1.0.",
        "git_url": "https://github.com/kiwix/libkiwix/commit/8136138492ab51ae8a311be589b8b131d04125ce",
        "commit_title": "use encoded URLs for searchSuggestionHtml",
        "commit_text": " Previously, the seachURL was not encoded. This resulted in an XSS vulnerability, a concept of proof is:  start kiwix-serve visit - http://192.168.18.1:8081/\"><svg onload=\"alert(1)\"> This would display an alert message.  This encodes the searchURL before passing it to searchSuggestionHtml",
        "func_before": "std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& request)\n{\n  const std::string url = request.get_url();\n  const std::string pattern = url.substr((url.find_last_of('/'))+1);\n  if (m_verbose.load()) {\n    printf(\"** running handle_content\\n\");\n  }\n\n  const std::string bookName = get_book_name(request);\n  if (bookName.empty())\n    return build_homepage(request);\n\n  std::shared_ptr<zim::Archive> archive;\n  try {\n    const std::string bookId = mp_nameMapper->getIdForName(bookName);\n    archive = mp_library->getArchiveById(bookId);\n  } catch (const std::out_of_range& e) {}\n\n  if (archive == nullptr) {\n    std::string searchURL = m_root+\"/search?pattern=\"+pattern; // Make a full search on the entire library.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, \"\", details);\n  }\n\n  auto urlStr = request.get_url().substr(bookName.size()+1);\n  if (urlStr[0] == '/') {\n    urlStr = urlStr.substr(1);\n  }\n\n  try {\n    auto entry = getEntryFromPath(*archive, urlStr);\n    if (entry.isRedirect() || urlStr.empty()) {\n      // If urlStr is empty, we want to mainPage.\n      // We must do a redirection to the real page.\n      return build_redirect(bookName, getFinalItem(*archive, entry));\n    }\n    auto response = ItemResponse::build(*this, request, entry.getItem());\n    try {\n      dynamic_cast<ContentResponse&>(*response).set_taskbar(bookName, getArchiveTitle(*archive));\n    } catch (std::bad_cast& e) {}\n\n    if (m_verbose.load()) {\n      printf(\"Found %s\\n\", entry.getPath().c_str());\n      printf(\"mimeType: %s\\n\", entry.getItem(true).getMimetype().c_str());\n    }\n\n    return response;\n  } catch(zim::EntryNotFound& e) {\n    if (m_verbose.load())\n      printf(\"Failed to find %s\\n\", urlStr.c_str());\n\n    std::string searchURL = m_root+\"/search?content=\"+bookName+\"&pattern=\"+pattern; // Make a search on this specific book only.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);\n  }\n}",
        "func": "std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& request)\n{\n  const std::string url = request.get_url();\n  const std::string pattern = url.substr((url.find_last_of('/'))+1);\n  if (m_verbose.load()) {\n    printf(\"** running handle_content\\n\");\n  }\n\n  const std::string bookName = get_book_name(request);\n  if (bookName.empty())\n    return build_homepage(request);\n\n  std::shared_ptr<zim::Archive> archive;\n  try {\n    const std::string bookId = mp_nameMapper->getIdForName(bookName);\n    archive = mp_library->getArchiveById(bookId);\n  } catch (const std::out_of_range& e) {}\n\n  if (archive == nullptr) {\n    std::string searchURL = m_root + \"/search?pattern=\" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, \"\", details);\n  }\n\n  auto urlStr = request.get_url().substr(bookName.size()+1);\n  if (urlStr[0] == '/') {\n    urlStr = urlStr.substr(1);\n  }\n\n  try {\n    auto entry = getEntryFromPath(*archive, urlStr);\n    if (entry.isRedirect() || urlStr.empty()) {\n      // If urlStr is empty, we want to mainPage.\n      // We must do a redirection to the real page.\n      return build_redirect(bookName, getFinalItem(*archive, entry));\n    }\n    auto response = ItemResponse::build(*this, request, entry.getItem());\n    try {\n      dynamic_cast<ContentResponse&>(*response).set_taskbar(bookName, getArchiveTitle(*archive));\n    } catch (std::bad_cast& e) {}\n\n    if (m_verbose.load()) {\n      printf(\"Found %s\\n\", entry.getPath().c_str());\n      printf(\"mimeType: %s\\n\", entry.getItem(true).getMimetype().c_str());\n    }\n\n    return response;\n  } catch(zim::EntryNotFound& e) {\n    if (m_verbose.load())\n      printf(\"Failed to find %s\\n\", urlStr.c_str());\n\n    std::string searchURL = m_root + \"/search?content=\" + bookName + \"&pattern=\" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only.\n    const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n\n    return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n   } catch (const std::out_of_range& e) {}\n \n   if (archive == nullptr) {\n-    std::string searchURL = m_root+\"/search?pattern=\"+pattern; // Make a full search on the entire library.\n+    std::string searchURL = m_root + \"/search?pattern=\" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.\n     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n \n     return Response::build_404(*this, request.get_full_url(), bookName, \"\", details);\n@@ -50,7 +50,7 @@\n     if (m_verbose.load())\n       printf(\"Failed to find %s\\n\", urlStr.c_str());\n \n-    std::string searchURL = m_root+\"/search?content=\"+bookName+\"&pattern=\"+pattern; // Make a search on this specific book only.\n+    std::string searchURL = m_root + \"/search?content=\" + bookName + \"&pattern=\" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only.\n     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern));\n \n     return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details);",
        "diff_line_info": {
            "deleted_lines": [
                "    std::string searchURL = m_root+\"/search?pattern=\"+pattern; // Make a full search on the entire library.",
                "    std::string searchURL = m_root+\"/search?content=\"+bookName+\"&pattern=\"+pattern; // Make a search on this specific book only."
            ],
            "added_lines": [
                "    std::string searchURL = m_root + \"/search?pattern=\" + kiwix::urlEncode(pattern, true); // Make a full search on the entire library.",
                "    std::string searchURL = m_root + \"/search?content=\" + bookName + \"&pattern=\" + kiwix::urlEncode(pattern, true); // Make a search on this specific book only."
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8935",
        "func_name": "php/php-src/sapi_header_op",
        "description": "The sapi_header_op function in main/SAPI.c in PHP before 5.4.38, 5.5.x before 5.5.22, and 5.6.x before 5.6.6 supports deprecated line folding without considering browser compatibility, which allows remote attackers to conduct cross-site scripting (XSS) attacks against Internet Explorer by leveraging (1) %0A%20 or (2) %0D%0A%20 mishandling in the header function.",
        "git_url": "https://github.com/php/php-src/commit/996faf964bba1aec06b153b370a7f20d3dd2bb8b",
        "commit_title": "Update header handling to RFC 7230",
        "commit_text": "",
        "func_before": "SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n{\n\tsapi_header_struct sapi_header;\n\tchar *colon_offset;\n\tchar *header_line;\n\tuint header_line_len;\n\tint http_response_code;\n\n\tif (SG(headers_sent) && !SG(request_info).no_headers) {\n\t\tconst char *output_start_filename = php_output_get_start_filename(TSRMLS_C);\n\t\tint output_start_lineno = php_output_get_start_lineno(TSRMLS_C);\n\n\t\tif (output_start_filename) {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent by (output started at %s:%d)\",\n\t\t\t\toutput_start_filename, output_start_lineno);\n\t\t} else {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tswitch (op) {\n\t\tcase SAPI_HEADER_SET_STATUS:\n\t\t\tsapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);\n\t\t\treturn SUCCESS;\n\n\t\tcase SAPI_HEADER_ADD:\n\t\tcase SAPI_HEADER_REPLACE:\n\t\tcase SAPI_HEADER_DELETE: {\n\t\t\t\tsapi_header_line *p = arg;\n\n\t\t\t\tif (!p->line || !p->line_len) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\theader_line = p->line;\n\t\t\t\theader_line_len = p->line_len;\n\t\t\t\thttp_response_code = p->response_code;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase SAPI_HEADER_DELETE_ALL:\n\t\t\tif (sapi_module.header_handler) {\n\t\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t\t}\n\t\t\tzend_llist_clean(&SG(sapi_headers).headers);\n\t\t\treturn SUCCESS;\n\n\t\tdefault:\n\t\t\treturn FAILURE;\n\t}\n\n\theader_line = estrndup(header_line, header_line_len);\n\n\t/* cut off trailing spaces, linefeeds and carriage-returns */\n\tif (header_line_len && isspace(header_line[header_line_len-1])) {\n\t\tdo {\n\t\t\theader_line_len--;\n\t\t} while(header_line_len && isspace(header_line[header_line_len-1]));\n\t\theader_line[header_line_len]='\\0';\n\t}\n\t\n\tif (op == SAPI_HEADER_DELETE) {\n\t\tif (strchr(header_line, ':')) {\n\t\t\tefree(header_line);\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Header to delete may not contain colon.\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (sapi_module.header_handler) {\n\t\t\tsapi_header.header = header_line;\n\t\t\tsapi_header.header_len = header_line_len;\n\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t}\n\t\tsapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);\n\t\tefree(header_line);\n\t\treturn SUCCESS;\n\t} else {\n\t\t/* new line/NUL character safety check */\n\t\tint i;\n\t\tfor (i = 0; i < header_line_len; i++) {\n\t\t\t/* RFC 2616 allows new lines if followed by SP or HT */\n\t\t\tint illegal_break =\n\t\t\t\t\t(header_line[i+1] != ' ' && header_line[i+1] != '\\t')\n\t\t\t\t\t&& (\n\t\t\t\t\t\theader_line[i] == '\\n'\n\t\t\t\t\t\t|| (header_line[i] == '\\r' && header_line[i+1] != '\\n'));\n\t\t\tif (illegal_break) {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n\t\t\t\t\t\t\"more than a single header, new line detected\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (header_line[i] == '\\0') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain NUL bytes\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tsapi_header.header = header_line;\n\tsapi_header.header_len = header_line_len;\n\n\t/* Check the header for a few cases that we have special support for in SAPI */\n\tif (header_line_len>=5 \n\t\t&& !strncasecmp(header_line, \"HTTP/\", 5)) {\n\t\t/* filter out the response code */\n\t\tsapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);\n\t\t/* sapi_update_response_code doesn't free the status line if the code didn't change */\n\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\tefree(SG(sapi_headers).http_status_line);\n\t\t}\n\t\tSG(sapi_headers).http_status_line = header_line;\n\t\treturn SUCCESS;\n\t} else {\n\t\tcolon_offset = strchr(header_line, ':');\n\t\tif (colon_offset) {\n\t\t\t*colon_offset = 0;\n\t\t\tif (!STRCASECMP(header_line, \"Content-Type\")) {\n\t\t\t\tchar *ptr = colon_offset+1, *mimetype = NULL, *newheader;\n\t\t\t\tsize_t len = header_line_len - (ptr - header_line), newlen;\n\t\t\t\twhile (*ptr == ' ') {\n\t\t\t\t\tptr++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\n\t\t\t\t/* Disable possible output compression for images */\n\t\t\t\tif (!strncmp(ptr, \"image/\", sizeof(\"image/\")-1)) {\n\t\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"), \"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t\t}\n\n\t\t\t\tmimetype = estrdup(ptr);\n\t\t\t\tnewlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);\n\t\t\t\tif (!SG(sapi_headers).mimetype){\n\t\t\t\t\tSG(sapi_headers).mimetype = estrdup(mimetype);\n\t\t\t\t}\n\n\t\t\t\tif (newlen != 0) {\n\t\t\t\t\tnewlen += sizeof(\"Content-type: \");\n\t\t\t\t\tnewheader = emalloc(newlen);\n\t\t\t\t\tPHP_STRLCPY(newheader, \"Content-type: \", newlen, sizeof(\"Content-type: \")-1);\n\t\t\t\t\tstrlcat(newheader, mimetype, newlen);\n\t\t\t\t\tsapi_header.header = newheader;\n\t\t\t\t\tsapi_header.header_len = newlen - 1;\n\t\t\t\t\tefree(header_line);\n\t\t\t\t}\n\t\t\t\tefree(mimetype);\n\t\t\t\tSG(sapi_headers).send_default_content_type = 0;\n\t\t\t} else if (!STRCASECMP(header_line, \"Content-Length\")) {\n\t\t\t\t/* Script is setting Content-length. The script cannot reasonably\n\t\t\t\t * know the size of the message body after compression, so it's best\n\t\t\t\t * do disable compression altogether. This contributes to making scripts\n\t\t\t\t * portable between setups that have and don't have zlib compression\n\t\t\t\t * enabled globally. See req #44164 */\n\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"),\n\t\t\t\t\t\"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t} else if (!STRCASECMP(header_line, \"Location\")) {\n\t\t\t\tif ((SG(sapi_headers).http_response_code < 300 ||\n\t\t\t\t\tSG(sapi_headers).http_response_code > 399) &&\n\t\t\t\t\tSG(sapi_headers).http_response_code != 201) {\n\t\t\t\t\t/* Return a Found Redirect if one is not already specified */\n\t\t\t\t\tif (http_response_code) { /* user specified redirect code */\n\t\t\t\t\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t\t\t\t\t} else if (SG(request_info).proto_num > 1000 && \n\t\t\t\t\t   SG(request_info).request_method && \n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"HEAD\") &&\n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"GET\")) {\n\t\t\t\t\t\tsapi_update_response_code(303 TSRMLS_CC);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsapi_update_response_code(302 TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!STRCASECMP(header_line, \"WWW-Authenticate\")) { /* HTTP Authentication */\n\t\t\t\tsapi_update_response_code(401 TSRMLS_CC); /* authentication-required */\n\t\t\t}\n\t\t\tif (sapi_header.header==header_line) {\n\t\t\t\t*colon_offset = ':';\n\t\t\t}\n\t\t}\n\t}\n\tif (http_response_code) {\n\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t}\n\tsapi_header_add_op(op, &sapi_header TSRMLS_CC);\n\treturn SUCCESS;\n}",
        "func": "SAPI_API int sapi_header_op(sapi_header_op_enum op, void *arg TSRMLS_DC)\n{\n\tsapi_header_struct sapi_header;\n\tchar *colon_offset;\n\tchar *header_line;\n\tuint header_line_len;\n\tint http_response_code;\n\n\tif (SG(headers_sent) && !SG(request_info).no_headers) {\n\t\tconst char *output_start_filename = php_output_get_start_filename(TSRMLS_C);\n\t\tint output_start_lineno = php_output_get_start_lineno(TSRMLS_C);\n\n\t\tif (output_start_filename) {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent by (output started at %s:%d)\",\n\t\t\t\toutput_start_filename, output_start_lineno);\n\t\t} else {\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Cannot modify header information - headers already sent\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tswitch (op) {\n\t\tcase SAPI_HEADER_SET_STATUS:\n\t\t\tsapi_update_response_code((int)(zend_intptr_t) arg TSRMLS_CC);\n\t\t\treturn SUCCESS;\n\n\t\tcase SAPI_HEADER_ADD:\n\t\tcase SAPI_HEADER_REPLACE:\n\t\tcase SAPI_HEADER_DELETE: {\n\t\t\t\tsapi_header_line *p = arg;\n\n\t\t\t\tif (!p->line || !p->line_len) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\theader_line = p->line;\n\t\t\t\theader_line_len = p->line_len;\n\t\t\t\thttp_response_code = p->response_code;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase SAPI_HEADER_DELETE_ALL:\n\t\t\tif (sapi_module.header_handler) {\n\t\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t\t}\n\t\t\tzend_llist_clean(&SG(sapi_headers).headers);\n\t\t\treturn SUCCESS;\n\n\t\tdefault:\n\t\t\treturn FAILURE;\n\t}\n\n\theader_line = estrndup(header_line, header_line_len);\n\n\t/* cut off trailing spaces, linefeeds and carriage-returns */\n\tif (header_line_len && isspace(header_line[header_line_len-1])) {\n\t\tdo {\n\t\t\theader_line_len--;\n\t\t} while(header_line_len && isspace(header_line[header_line_len-1]));\n\t\theader_line[header_line_len]='\\0';\n\t}\n\t\n\tif (op == SAPI_HEADER_DELETE) {\n\t\tif (strchr(header_line, ':')) {\n\t\t\tefree(header_line);\n\t\t\tsapi_module.sapi_error(E_WARNING, \"Header to delete may not contain colon.\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (sapi_module.header_handler) {\n\t\t\tsapi_header.header = header_line;\n\t\t\tsapi_header.header_len = header_line_len;\n\t\t\tsapi_module.header_handler(&sapi_header, op, &SG(sapi_headers) TSRMLS_CC);\n\t\t}\n\t\tsapi_remove_header(&SG(sapi_headers).headers, header_line, header_line_len);\n\t\tefree(header_line);\n\t\treturn SUCCESS;\n\t} else {\n\t\t/* new line/NUL character safety check */\n\t\tint i;\n\t\tfor (i = 0; i < header_line_len; i++) {\n\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */\n\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n\t\t\t\t\t\t\"more than a single header, new line detected\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (header_line[i] == '\\0') {\n\t\t\t\tefree(header_line);\n\t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain NUL bytes\");\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\tsapi_header.header = header_line;\n\tsapi_header.header_len = header_line_len;\n\n\t/* Check the header for a few cases that we have special support for in SAPI */\n\tif (header_line_len>=5 \n\t\t&& !strncasecmp(header_line, \"HTTP/\", 5)) {\n\t\t/* filter out the response code */\n\t\tsapi_update_response_code(sapi_extract_response_code(header_line) TSRMLS_CC);\n\t\t/* sapi_update_response_code doesn't free the status line if the code didn't change */\n\t\tif (SG(sapi_headers).http_status_line) {\n\t\t\tefree(SG(sapi_headers).http_status_line);\n\t\t}\n\t\tSG(sapi_headers).http_status_line = header_line;\n\t\treturn SUCCESS;\n\t} else {\n\t\tcolon_offset = strchr(header_line, ':');\n\t\tif (colon_offset) {\n\t\t\t*colon_offset = 0;\n\t\t\tif (!STRCASECMP(header_line, \"Content-Type\")) {\n\t\t\t\tchar *ptr = colon_offset+1, *mimetype = NULL, *newheader;\n\t\t\t\tsize_t len = header_line_len - (ptr - header_line), newlen;\n\t\t\t\twhile (*ptr == ' ') {\n\t\t\t\t\tptr++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\n\t\t\t\t/* Disable possible output compression for images */\n\t\t\t\tif (!strncmp(ptr, \"image/\", sizeof(\"image/\")-1)) {\n\t\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"), \"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t\t}\n\n\t\t\t\tmimetype = estrdup(ptr);\n\t\t\t\tnewlen = sapi_apply_default_charset(&mimetype, len TSRMLS_CC);\n\t\t\t\tif (!SG(sapi_headers).mimetype){\n\t\t\t\t\tSG(sapi_headers).mimetype = estrdup(mimetype);\n\t\t\t\t}\n\n\t\t\t\tif (newlen != 0) {\n\t\t\t\t\tnewlen += sizeof(\"Content-type: \");\n\t\t\t\t\tnewheader = emalloc(newlen);\n\t\t\t\t\tPHP_STRLCPY(newheader, \"Content-type: \", newlen, sizeof(\"Content-type: \")-1);\n\t\t\t\t\tstrlcat(newheader, mimetype, newlen);\n\t\t\t\t\tsapi_header.header = newheader;\n\t\t\t\t\tsapi_header.header_len = newlen - 1;\n\t\t\t\t\tefree(header_line);\n\t\t\t\t}\n\t\t\t\tefree(mimetype);\n\t\t\t\tSG(sapi_headers).send_default_content_type = 0;\n\t\t\t} else if (!STRCASECMP(header_line, \"Content-Length\")) {\n\t\t\t\t/* Script is setting Content-length. The script cannot reasonably\n\t\t\t\t * know the size of the message body after compression, so it's best\n\t\t\t\t * do disable compression altogether. This contributes to making scripts\n\t\t\t\t * portable between setups that have and don't have zlib compression\n\t\t\t\t * enabled globally. See req #44164 */\n\t\t\t\tzend_alter_ini_entry(\"zlib.output_compression\", sizeof(\"zlib.output_compression\"),\n\t\t\t\t\t\"0\", sizeof(\"0\") - 1, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\t\t\t} else if (!STRCASECMP(header_line, \"Location\")) {\n\t\t\t\tif ((SG(sapi_headers).http_response_code < 300 ||\n\t\t\t\t\tSG(sapi_headers).http_response_code > 399) &&\n\t\t\t\t\tSG(sapi_headers).http_response_code != 201) {\n\t\t\t\t\t/* Return a Found Redirect if one is not already specified */\n\t\t\t\t\tif (http_response_code) { /* user specified redirect code */\n\t\t\t\t\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t\t\t\t\t} else if (SG(request_info).proto_num > 1000 && \n\t\t\t\t\t   SG(request_info).request_method && \n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"HEAD\") &&\n\t\t\t\t\t   strcmp(SG(request_info).request_method, \"GET\")) {\n\t\t\t\t\t\tsapi_update_response_code(303 TSRMLS_CC);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsapi_update_response_code(302 TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!STRCASECMP(header_line, \"WWW-Authenticate\")) { /* HTTP Authentication */\n\t\t\t\tsapi_update_response_code(401 TSRMLS_CC); /* authentication-required */\n\t\t\t}\n\t\t\tif (sapi_header.header==header_line) {\n\t\t\t\t*colon_offset = ':';\n\t\t\t}\n\t\t}\n\t}\n\tif (http_response_code) {\n\t\tsapi_update_response_code(http_response_code TSRMLS_CC);\n\t}\n\tsapi_header_add_op(op, &sapi_header TSRMLS_CC);\n\treturn SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,13 +77,8 @@\n \t\t/* new line/NUL character safety check */\n \t\tint i;\n \t\tfor (i = 0; i < header_line_len; i++) {\n-\t\t\t/* RFC 2616 allows new lines if followed by SP or HT */\n-\t\t\tint illegal_break =\n-\t\t\t\t\t(header_line[i+1] != ' ' && header_line[i+1] != '\\t')\n-\t\t\t\t\t&& (\n-\t\t\t\t\t\theader_line[i] == '\\n'\n-\t\t\t\t\t\t|| (header_line[i] == '\\r' && header_line[i+1] != '\\n'));\n-\t\t\tif (illegal_break) {\n+\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */\n+\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {\n \t\t\t\tefree(header_line);\n \t\t\t\tsapi_module.sapi_error(E_WARNING, \"Header may not contain \"\n \t\t\t\t\t\t\"more than a single header, new line detected\");",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t/* RFC 2616 allows new lines if followed by SP or HT */",
                "\t\t\tint illegal_break =",
                "\t\t\t\t\t(header_line[i+1] != ' ' && header_line[i+1] != '\\t')",
                "\t\t\t\t\t&& (",
                "\t\t\t\t\t\theader_line[i] == '\\n'",
                "\t\t\t\t\t\t|| (header_line[i] == '\\r' && header_line[i+1] != '\\n'));",
                "\t\t\tif (illegal_break) {"
            ],
            "added_lines": [
                "\t\t\t/* RFC 7230 ch. 3.2.4 deprecates folding support */",
                "\t\t\tif (header_line[i] == '\\n' || header_line[i] == '\\r') {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5164",
        "func_name": "chromium/V8Debugger::functionLocation",
        "description": "Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/93bc623489bdcfc7e9127614fcfb3258edf3f0f9",
        "commit_title": "[DevTools] Copy objects from debugger context to inspected context properly.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2253643002 ",
        "func_before": "v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n{\n    int scriptId = function->ScriptId();\n    if (scriptId == v8::UnboundScript::kNoScriptId)\n        return v8::Null(m_isolate);\n    int lineNumber = function->GetScriptLineNumber();\n    int columnNumber = function->GetScriptColumnNumber();\n    if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n        return v8::Null(m_isolate);\n    v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"scriptId\"), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"lineNumber\"), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"columnNumber\"), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!markAsInternal(context, location, V8InternalValueType::kLocation))\n        return v8::Null(m_isolate);\n    return location;\n}",
        "func": "v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n{\n    int scriptId = function->ScriptId();\n    if (scriptId == v8::UnboundScript::kNoScriptId)\n        return v8::Null(m_isolate);\n    int lineNumber = function->GetScriptLineNumber();\n    int columnNumber = function->GetScriptColumnNumber();\n    if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n        return v8::Null(m_isolate);\n    v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"scriptId\"), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"lineNumber\"), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"columnNumber\"), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!markAsInternal(context, location, V8InternalValueType::kLocation))\n        return v8::Null(m_isolate);\n    return location;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,8 @@\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n+    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n+        return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \"scriptId\"), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \"lineNumber\"), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!location->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))",
                "        return v8::Null(m_isolate);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5164",
        "func_name": "chromium/V8Debugger::functionScopes",
        "description": "Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/93bc623489bdcfc7e9127614fcfb3258edf3f0f9",
        "commit_title": "[DevTools] Copy objects from debugger context to inspected context properly.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2253643002 ",
        "func_before": "v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n{\n    if (!enabled()) {\n        NOTREACHED();\n        return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n    }\n    v8::Local<v8::Value> argv[] = { function };\n    v8::Local<v8::Value> scopesValue;\n    if (!callDebuggerMethod(\"getFunctionScopes\", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n        return v8::MaybeLocal<v8::Value>();\n    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n        return v8::MaybeLocal<v8::Value>();\n    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n        return v8::MaybeLocal<v8::Value>();\n    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n        return v8::Undefined(m_isolate);\n    return scopes;\n}",
        "func": "v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n{\n    if (!enabled()) {\n        NOTREACHED();\n        return v8::Local<v8::Value>::New(m_isolate, v8::Undefined(m_isolate));\n    }\n    v8::Local<v8::Value> argv[] = { function };\n    v8::Local<v8::Value> scopesValue;\n    if (!callDebuggerMethod(\"getFunctionScopes\", 1, argv).ToLocal(&scopesValue))\n        return v8::MaybeLocal<v8::Value>();\n    v8::Local<v8::Value> copied;\n    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n        return v8::MaybeLocal<v8::Value>();\n    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n        return v8::MaybeLocal<v8::Value>();\n    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n        return v8::MaybeLocal<v8::Value>();\n    return copied;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)\n+v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n {\n     if (!enabled()) {\n         NOTREACHED();\n@@ -6,15 +6,14 @@\n     }\n     v8::Local<v8::Value> argv[] = { function };\n     v8::Local<v8::Value> scopesValue;\n-    if (!callDebuggerMethod(\"getFunctionScopes\", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())\n+    if (!callDebuggerMethod(\"getFunctionScopes\", 1, argv).ToLocal(&scopesValue))\n         return v8::MaybeLocal<v8::Value>();\n-    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::MaybeLocal<v8::Value>();\n-    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))\n+    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))\n         return v8::MaybeLocal<v8::Value>();\n-    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return scopes;\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))\n+        return v8::MaybeLocal<v8::Value>();\n+    return copied;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Function> function)",
                "    if (!callDebuggerMethod(\"getFunctionScopes\", 1, argv).ToLocal(&scopesValue) || !scopesValue->IsArray())",
                "    v8::Local<v8::Array> scopes = scopesValue.As<v8::Array>();",
                "    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);",
                "    if (!markAsInternal(context, scopes, V8InternalValueType::kScopeList))",
                "    if (!markArrayEntriesAsInternal(context, scopes, V8InternalValueType::kScope))",
                "    if (!scopes->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))",
                "        return v8::Undefined(m_isolate);",
                "    return scopes;"
            ],
            "added_lines": [
                "v8::MaybeLocal<v8::Value> V8Debugger::functionScopes(v8::Local<v8::Context> context, v8::Local<v8::Function> function)",
                "    if (!callDebuggerMethod(\"getFunctionScopes\", 1, argv).ToLocal(&scopesValue))",
                "    v8::Local<v8::Value> copied;",
                "    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, scopesValue).ToLocal(&copied) || !copied->IsArray())",
                "    if (!markAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScopeList))",
                "    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kScope))",
                "        return v8::MaybeLocal<v8::Value>();",
                "    return copied;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5164",
        "func_name": "chromium/V8Debugger::collectionEntries",
        "description": "Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/93bc623489bdcfc7e9127614fcfb3258edf3f0f9",
        "commit_title": "[DevTools] Copy objects from debugger context to inspected context properly.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2253643002 ",
        "func_before": "v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n{\n    if (!enabled()) {\n        NOTREACHED();\n        return v8::Undefined(m_isolate);\n    }\n    v8::Local<v8::Value> argv[] = { object };\n    v8::Local<v8::Value> entriesValue = callDebuggerMethod(\"getCollectionEntries\", 1, argv).ToLocalChecked();\n    if (!entriesValue->IsArray())\n        return v8::Undefined(m_isolate);\n    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n        return v8::Undefined(m_isolate);\n    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n        return v8::Undefined(m_isolate);\n    return entries;\n}",
        "func": "v8::Local<v8::Value> V8Debugger::collectionEntries(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n{\n    if (!enabled()) {\n        NOTREACHED();\n        return v8::Undefined(m_isolate);\n    }\n    v8::Local<v8::Value> argv[] = { object };\n    v8::Local<v8::Value> entriesValue = callDebuggerMethod(\"getCollectionEntries\", 1, argv).ToLocalChecked();\n    v8::Local<v8::Value> copied;\n    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n        return v8::Undefined(m_isolate);\n    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n        return v8::Undefined(m_isolate);\n    return copied;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,12 +6,10 @@\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> entriesValue = callDebuggerMethod(\"getCollectionEntries\", 1, argv).ToLocalChecked();\n-    if (!entriesValue->IsArray())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())\n         return v8::Undefined(m_isolate);\n-    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();\n-    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))\n+    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))\n         return v8::Undefined(m_isolate);\n-    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))\n-        return v8::Undefined(m_isolate);\n-    return entries;\n+    return copied;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!entriesValue->IsArray())",
                "    v8::Local<v8::Array> entries = entriesValue.As<v8::Array>();",
                "    if (!markArrayEntriesAsInternal(context, entries, V8InternalValueType::kEntry))",
                "    if (!entries->SetPrototype(context, v8::Null(m_isolate)).FromMaybe(false))",
                "        return v8::Undefined(m_isolate);",
                "    return entries;"
            ],
            "added_lines": [
                "    v8::Local<v8::Value> copied;",
                "    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, entriesValue).ToLocal(&copied) || !copied->IsArray())",
                "    if (!markArrayEntriesAsInternal(context, v8::Local<v8::Array>::Cast(copied), V8InternalValueType::kEntry))",
                "    return copied;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5164",
        "func_name": "chromium/V8Debugger::internalProperties",
        "description": "Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/93bc623489bdcfc7e9127614fcfb3258edf3f0f9",
        "commit_title": "[DevTools] Copy objects from debugger context to inspected context properly.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2253643002 ",
        "func_before": "v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n{\n    v8::Local<v8::Array> properties;\n    if (!v8::Debug::GetInternalProperties(m_isolate, value).ToLocal(&properties))\n        return v8::MaybeLocal<v8::Array>();\n    if (value->IsFunction()) {\n        v8::Local<v8::Function> function = value.As<v8::Function>();\n        v8::Local<v8::Value> location = functionLocation(context, function);\n        if (location->IsObject()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[FunctionLocation]]\"));\n            properties->Set(properties->Length(), location);\n        }\n        if (function->IsGeneratorFunction()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[IsGenerator]]\"));\n            properties->Set(properties->Length(), v8::True(m_isolate));\n        }\n    }\n    if (!enabled())\n        return properties;\n    if (value->IsMap() || value->IsWeakMap() || value->IsSet() || value->IsWeakSet() || value->IsSetIterator() || value->IsMapIterator()) {\n        v8::Local<v8::Value> entries = collectionEntries(context, v8::Local<v8::Object>::Cast(value));\n        if (entries->IsArray()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[Entries]]\"));\n            properties->Set(properties->Length(), entries);\n        }\n    }\n    if (value->IsGeneratorObject()) {\n        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n        if (location->IsObject()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[GeneratorLocation]]\"));\n            properties->Set(properties->Length(), location);\n        }\n    }\n    if (value->IsFunction()) {\n        v8::Local<v8::Function> function = value.As<v8::Function>();\n        v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n        v8::Local<v8::Value> scopes;\n        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[Scopes]]\"));\n            properties->Set(properties->Length(), scopes);\n        }\n    }\n    return properties;\n}",
        "func": "v8::MaybeLocal<v8::Array> V8Debugger::internalProperties(v8::Local<v8::Context> context, v8::Local<v8::Value> value)\n{\n    v8::Local<v8::Array> properties;\n    if (!v8::Debug::GetInternalProperties(m_isolate, value).ToLocal(&properties))\n        return v8::MaybeLocal<v8::Array>();\n    if (value->IsFunction()) {\n        v8::Local<v8::Function> function = value.As<v8::Function>();\n        v8::Local<v8::Value> location = functionLocation(context, function);\n        if (location->IsObject()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[FunctionLocation]]\"));\n            properties->Set(properties->Length(), location);\n        }\n        if (function->IsGeneratorFunction()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[IsGenerator]]\"));\n            properties->Set(properties->Length(), v8::True(m_isolate));\n        }\n    }\n    if (!enabled())\n        return properties;\n    if (value->IsMap() || value->IsWeakMap() || value->IsSet() || value->IsWeakSet() || value->IsSetIterator() || value->IsMapIterator()) {\n        v8::Local<v8::Value> entries = collectionEntries(context, v8::Local<v8::Object>::Cast(value));\n        if (entries->IsArray()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[Entries]]\"));\n            properties->Set(properties->Length(), entries);\n        }\n    }\n    if (value->IsGeneratorObject()) {\n        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n        if (location->IsObject()) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[GeneratorLocation]]\"));\n            properties->Set(properties->Length(), location);\n        }\n    }\n    if (value->IsFunction()) {\n        v8::Local<v8::Function> function = value.As<v8::Function>();\n        v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n        v8::Local<v8::Value> scopes;\n        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n            properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[Scopes]]\"));\n            properties->Set(properties->Length(), scopes);\n        }\n    }\n    return properties;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n         }\n     }\n     if (value->IsGeneratorObject()) {\n-        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));\n+        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));\n         if (location->IsObject()) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[GeneratorLocation]]\"));\n             properties->Set(properties->Length(), location);\n@@ -35,7 +35,7 @@\n         v8::Local<v8::Function> function = value.As<v8::Function>();\n         v8::Local<v8::Value> boundFunction = function->GetBoundFunction();\n         v8::Local<v8::Value> scopes;\n-        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {\n+        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {\n             properties->Set(properties->Length(), toV8StringInternalized(m_isolate, \"[[Scopes]]\"));\n             properties->Set(properties->Length(), scopes);\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        v8::Local<v8::Value> location = generatorObjectLocation(v8::Local<v8::Object>::Cast(value));",
                "        if (boundFunction->IsUndefined() && functionScopes(function).ToLocal(&scopes)) {"
            ],
            "added_lines": [
                "        v8::Local<v8::Value> location = generatorObjectLocation(context, v8::Local<v8::Object>::Cast(value));",
                "        if (boundFunction->IsUndefined() && functionScopes(context, function).ToLocal(&scopes)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5164",
        "func_name": "chromium/V8Debugger::generatorObjectLocation",
        "description": "Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/93bc623489bdcfc7e9127614fcfb3258edf3f0f9",
        "commit_title": "[DevTools] Copy objects from debugger context to inspected context properly.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2253643002 ",
        "func_before": "v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n{\n    if (!enabled()) {\n        NOTREACHED();\n        return v8::Null(m_isolate);\n    }\n    v8::Local<v8::Value> argv[] = { object };\n    v8::Local<v8::Value> location = callDebuggerMethod(\"getGeneratorObjectLocation\", 1, argv).ToLocalChecked();\n    if (!location->IsObject())\n        return v8::Null(m_isolate);\n    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n        return v8::Null(m_isolate);\n    return location;\n}",
        "func": "v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n{\n    if (!enabled()) {\n        NOTREACHED();\n        return v8::Null(m_isolate);\n    }\n    v8::Local<v8::Value> argv[] = { object };\n    v8::Local<v8::Value> location = callDebuggerMethod(\"getGeneratorObjectLocation\", 1, argv).ToLocalChecked();\n    v8::Local<v8::Value> copied;\n    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n        return v8::Null(m_isolate);\n    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n        return v8::Null(m_isolate);\n    return copied;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n+v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n@@ -6,10 +6,10 @@\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\"getGeneratorObjectLocation\", 1, argv).ToLocalChecked();\n-    if (!location->IsObject())\n+    v8::Local<v8::Value> copied;\n+    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())\n         return v8::Null(m_isolate);\n-    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n-    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n+    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n-    return location;\n+    return copied;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)",
                "    if (!location->IsObject())",
                "    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);",
                "    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))",
                "    return location;"
            ],
            "added_lines": [
                "v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Context> context, v8::Local<v8::Object> object)",
                "    v8::Local<v8::Value> copied;",
                "    if (!copyValueFromDebuggerContext(m_isolate, debuggerContext(), context, location).ToLocal(&copied) || !copied->IsObject())",
                "    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(copied), V8InternalValueType::kLocation))",
                "    return copied;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5164",
        "func_name": "chromium/V8Console::createCommandLineAPI",
        "description": "Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/93bc623489bdcfc7e9127614fcfb3258edf3f0f9",
        "commit_title": "[DevTools] Copy objects from debugger context to inspected context properly.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2253643002 ",
        "func_before": "v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspectedContext)\n{\n    v8::Local<v8::Context> context = inspectedContext->context();\n    v8::Isolate* isolate = context->GetIsolate();\n    v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n\n    v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n\n    createBoundFunctionProperty(context, commandLineAPI, \"dir\", V8Console::dirCallback, \"function dir(value) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"dirxml\", V8Console::dirxmlCallback, \"function dirxml(value) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"profile\", V8Console::profileCallback, \"function profile(title) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"profileEnd\", V8Console::profileEndCallback, \"function profileEnd(title) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"clear\", V8Console::clearCallback, \"function clear() { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"table\", V8Console::tableCallback, \"function table(data, [columns]) { [Command Line API] }\");\n\n    createBoundFunctionProperty(context, commandLineAPI, \"keys\", V8Console::keysCallback, \"function keys(object) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"values\", V8Console::valuesCallback, \"function values(object) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"debug\", V8Console::debugFunctionCallback, \"function debug(function) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"undebug\", V8Console::undebugFunctionCallback, \"function undebug(function) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"monitor\", V8Console::monitorFunctionCallback, \"function monitor(function) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"unmonitor\", V8Console::unmonitorFunctionCallback, \"function unmonitor(function) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"inspect\", V8Console::inspectCallback, \"function inspect(object) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"copy\", V8Console::copyCallback, \"function copy(value) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"$_\", V8Console::lastEvaluationResultCallback);\n    createBoundFunctionProperty(context, commandLineAPI, \"$0\", V8Console::inspectedObject0);\n    createBoundFunctionProperty(context, commandLineAPI, \"$1\", V8Console::inspectedObject1);\n    createBoundFunctionProperty(context, commandLineAPI, \"$2\", V8Console::inspectedObject2);\n    createBoundFunctionProperty(context, commandLineAPI, \"$3\", V8Console::inspectedObject3);\n    createBoundFunctionProperty(context, commandLineAPI, \"$4\", V8Console::inspectedObject4);\n\n    inspectedContext->inspector()->client()->installAdditionalCommandLineAPI(context, commandLineAPI);\n\n    commandLineAPI->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));\n    return commandLineAPI;\n}",
        "func": "v8::Local<v8::Object> V8Console::createCommandLineAPI(InspectedContext* inspectedContext)\n{\n    v8::Local<v8::Context> context = inspectedContext->context();\n    v8::Isolate* isolate = context->GetIsolate();\n    v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n\n    v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n    DCHECK(success);\n\n    createBoundFunctionProperty(context, commandLineAPI, \"dir\", V8Console::dirCallback, \"function dir(value) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"dirxml\", V8Console::dirxmlCallback, \"function dirxml(value) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"profile\", V8Console::profileCallback, \"function profile(title) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"profileEnd\", V8Console::profileEndCallback, \"function profileEnd(title) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"clear\", V8Console::clearCallback, \"function clear() { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"table\", V8Console::tableCallback, \"function table(data, [columns]) { [Command Line API] }\");\n\n    createBoundFunctionProperty(context, commandLineAPI, \"keys\", V8Console::keysCallback, \"function keys(object) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"values\", V8Console::valuesCallback, \"function values(object) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"debug\", V8Console::debugFunctionCallback, \"function debug(function) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"undebug\", V8Console::undebugFunctionCallback, \"function undebug(function) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"monitor\", V8Console::monitorFunctionCallback, \"function monitor(function) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"unmonitor\", V8Console::unmonitorFunctionCallback, \"function unmonitor(function) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"inspect\", V8Console::inspectCallback, \"function inspect(object) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"copy\", V8Console::copyCallback, \"function copy(value) { [Command Line API] }\");\n    createBoundFunctionProperty(context, commandLineAPI, \"$_\", V8Console::lastEvaluationResultCallback);\n    createBoundFunctionProperty(context, commandLineAPI, \"$0\", V8Console::inspectedObject0);\n    createBoundFunctionProperty(context, commandLineAPI, \"$1\", V8Console::inspectedObject1);\n    createBoundFunctionProperty(context, commandLineAPI, \"$2\", V8Console::inspectedObject2);\n    createBoundFunctionProperty(context, commandLineAPI, \"$3\", V8Console::inspectedObject3);\n    createBoundFunctionProperty(context, commandLineAPI, \"$4\", V8Console::inspectedObject4);\n\n    inspectedContext->inspector()->client()->installAdditionalCommandLineAPI(context, commandLineAPI);\n\n    commandLineAPI->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));\n    return commandLineAPI;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> commandLineAPI = v8::Object::New(isolate);\n+    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, commandLineAPI, \"dir\", V8Console::dirCallback, \"function dir(value) { [Command Line API] }\");\n     createBoundFunctionProperty(context, commandLineAPI, \"dirxml\", V8Console::dirxmlCallback, \"function dirxml(value) { [Command Line API] }\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    bool success = commandLineAPI->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);",
                "    DCHECK(success);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5164",
        "func_name": "chromium/V8Console::createConsole",
        "description": "Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/93bc623489bdcfc7e9127614fcfb3258edf3f0f9",
        "commit_title": "[DevTools] Copy objects from debugger context to inspected context properly.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2253643002 ",
        "func_before": "v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContext, bool hasMemoryAttribute)\n{\n    v8::Local<v8::Context> context = inspectedContext->context();\n    v8::Context::Scope contextScope(context);\n    v8::Isolate* isolate = context->GetIsolate();\n    v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n\n    v8::Local<v8::Object> console = v8::Object::New(isolate);\n\n    createBoundFunctionProperty(context, console, \"debug\", V8Console::debugCallback);\n    createBoundFunctionProperty(context, console, \"error\", V8Console::errorCallback);\n    createBoundFunctionProperty(context, console, \"info\", V8Console::infoCallback);\n    createBoundFunctionProperty(context, console, \"log\", V8Console::logCallback);\n    createBoundFunctionProperty(context, console, \"warn\", V8Console::warnCallback);\n    createBoundFunctionProperty(context, console, \"dir\", V8Console::dirCallback);\n    createBoundFunctionProperty(context, console, \"dirxml\", V8Console::dirxmlCallback);\n    createBoundFunctionProperty(context, console, \"table\", V8Console::tableCallback);\n    createBoundFunctionProperty(context, console, \"trace\", V8Console::traceCallback);\n    createBoundFunctionProperty(context, console, \"group\", V8Console::groupCallback);\n    createBoundFunctionProperty(context, console, \"groupCollapsed\", V8Console::groupCollapsedCallback);\n    createBoundFunctionProperty(context, console, \"groupEnd\", V8Console::groupEndCallback);\n    createBoundFunctionProperty(context, console, \"clear\", V8Console::clearCallback);\n    createBoundFunctionProperty(context, console, \"count\", V8Console::countCallback);\n    createBoundFunctionProperty(context, console, \"assert\", V8Console::assertCallback);\n    createBoundFunctionProperty(context, console, \"markTimeline\", V8Console::markTimelineCallback);\n    createBoundFunctionProperty(context, console, \"profile\", V8Console::profileCallback);\n    createBoundFunctionProperty(context, console, \"profileEnd\", V8Console::profileEndCallback);\n    createBoundFunctionProperty(context, console, \"timeline\", V8Console::timelineCallback);\n    createBoundFunctionProperty(context, console, \"timelineEnd\", V8Console::timelineEndCallback);\n    createBoundFunctionProperty(context, console, \"time\", V8Console::timeCallback);\n    createBoundFunctionProperty(context, console, \"timeEnd\", V8Console::timeEndCallback);\n    createBoundFunctionProperty(context, console, \"timeStamp\", V8Console::timeStampCallback);\n\n    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n    DCHECK(success);\n\n    if (hasMemoryAttribute)\n        console->SetAccessorProperty(toV8StringInternalized(isolate, \"memory\"), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n\n    console->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));\n    return console;\n}",
        "func": "v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContext, bool hasMemoryAttribute)\n{\n    v8::Local<v8::Context> context = inspectedContext->context();\n    v8::Context::Scope contextScope(context);\n    v8::Isolate* isolate = context->GetIsolate();\n    v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n\n    v8::Local<v8::Object> console = v8::Object::New(isolate);\n    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n    DCHECK(success);\n\n    createBoundFunctionProperty(context, console, \"debug\", V8Console::debugCallback);\n    createBoundFunctionProperty(context, console, \"error\", V8Console::errorCallback);\n    createBoundFunctionProperty(context, console, \"info\", V8Console::infoCallback);\n    createBoundFunctionProperty(context, console, \"log\", V8Console::logCallback);\n    createBoundFunctionProperty(context, console, \"warn\", V8Console::warnCallback);\n    createBoundFunctionProperty(context, console, \"dir\", V8Console::dirCallback);\n    createBoundFunctionProperty(context, console, \"dirxml\", V8Console::dirxmlCallback);\n    createBoundFunctionProperty(context, console, \"table\", V8Console::tableCallback);\n    createBoundFunctionProperty(context, console, \"trace\", V8Console::traceCallback);\n    createBoundFunctionProperty(context, console, \"group\", V8Console::groupCallback);\n    createBoundFunctionProperty(context, console, \"groupCollapsed\", V8Console::groupCollapsedCallback);\n    createBoundFunctionProperty(context, console, \"groupEnd\", V8Console::groupEndCallback);\n    createBoundFunctionProperty(context, console, \"clear\", V8Console::clearCallback);\n    createBoundFunctionProperty(context, console, \"count\", V8Console::countCallback);\n    createBoundFunctionProperty(context, console, \"assert\", V8Console::assertCallback);\n    createBoundFunctionProperty(context, console, \"markTimeline\", V8Console::markTimelineCallback);\n    createBoundFunctionProperty(context, console, \"profile\", V8Console::profileCallback);\n    createBoundFunctionProperty(context, console, \"profileEnd\", V8Console::profileEndCallback);\n    createBoundFunctionProperty(context, console, \"timeline\", V8Console::timelineCallback);\n    createBoundFunctionProperty(context, console, \"timelineEnd\", V8Console::timelineEndCallback);\n    createBoundFunctionProperty(context, console, \"time\", V8Console::timeCallback);\n    createBoundFunctionProperty(context, console, \"timeEnd\", V8Console::timeEndCallback);\n    createBoundFunctionProperty(context, console, \"timeStamp\", V8Console::timeStampCallback);\n\n    if (hasMemoryAttribute)\n        console->SetAccessorProperty(toV8StringInternalized(isolate, \"memory\"), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n\n    console->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));\n    return console;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,8 @@\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n+    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n+    DCHECK(success);\n \n     createBoundFunctionProperty(context, console, \"debug\", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \"error\", V8Console::errorCallback);\n@@ -31,9 +33,6 @@\n     createBoundFunctionProperty(context, console, \"timeEnd\", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \"timeStamp\", V8Console::timeStampCallback);\n \n-    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n-    DCHECK(success);\n-\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \"memory\"), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);",
                "    DCHECK(success);",
                ""
            ],
            "added_lines": [
                "    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);",
                "    DCHECK(success);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5164",
        "func_name": "chromium/V8InjectedScriptHost::create",
        "description": "Cross-site scripting (XSS) vulnerability in WebKit/Source/platform/v8_inspector/V8Debugger.cpp in Blink, as used in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to inject arbitrary web script or HTML into the Developer Tools (aka DevTools) subsystem via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/93bc623489bdcfc7e9127614fcfb3258edf3f0f9",
        "commit_title": "[DevTools] Copy objects from debugger context to inspected context properly.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2253643002 ",
        "func_before": "v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)\n{\n    v8::Isolate* isolate = inspector->isolate();\n    v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n    v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n    setFunctionProperty(context, injectedScriptHost, \"internalConstructorName\", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"formatAccessorsAsProperties\", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"subtype\", V8InjectedScriptHost::subtypeCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"getInternalProperties\", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"objectHasOwnProperty\", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"bind\", V8InjectedScriptHost::bindCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"proxyTargetValue\", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);\n    return injectedScriptHost;\n}",
        "func": "v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)\n{\n    v8::Isolate* isolate = inspector->isolate();\n    v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n    DCHECK(success);\n    v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n    setFunctionProperty(context, injectedScriptHost, \"internalConstructorName\", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"formatAccessorsAsProperties\", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"subtype\", V8InjectedScriptHost::subtypeCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"getInternalProperties\", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"objectHasOwnProperty\", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"bind\", V8InjectedScriptHost::bindCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"proxyTargetValue\", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);\n    return injectedScriptHost;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,8 @@\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n+    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);\n+    DCHECK(success);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \"internalConstructorName\", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \"formatAccessorsAsProperties\", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    bool success = injectedScriptHost->SetPrototype(context, v8::Null(isolate)).FromMaybe(false);",
                "    DCHECK(success);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5165",
        "func_name": "chromium/DevToolsWindow::GetDevToolsURL",
        "description": "Cross-site scripting (XSS) vulnerability in the Developer Tools (aka DevTools) subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux allows remote attackers to inject arbitrary web script or HTML via the settings parameter in a chrome-devtools-frontend.appspot.com URL's query string.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/d5e6098dc2e984befc836f482845137245fa04e2",
        "commit_title": "[DevTools] Do not use \"settings\" query param.",
        "commit_text": " Implemented the same functionality on embedder side. Also, sanitizing \"settings\" query param for remote frontends.   Review-Url: https://codereview.chromium.org/2177983004 ",
        "func_before": "GURL DevToolsWindow::GetDevToolsURL(Profile* profile,\n                                    const GURL& base_url,\n                                    bool shared_worker_frontend,\n                                    const std::string& remote_frontend,\n                                    bool can_dock,\n                                    const std::string& settings) {\n  // Compatibility errors are encoded with data urls, pass them\n  // through with no decoration.\n  if (base_url.SchemeIs(\"data\"))\n    return base_url;\n\n  std::string frontend_url(\n      !remote_frontend.empty() ?\n          remote_frontend :\n          base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\"));\n  if (shared_worker_frontend)\n    url_string += \"&isSharedWorker=true\";\n  if (remote_frontend.size()) {\n    url_string += \"&remoteFrontend=true\";\n  } else {\n    url_string += \"&remoteBase=\" + DevToolsUI::GetRemoteBaseURL().spec();\n  }\n  if (can_dock)\n    url_string += \"&can_dock=true\";\n  if (settings.size())\n    url_string += \"&settings=\" + settings;\n  return GURL(url_string);\n}",
        "func": "GURL DevToolsWindow::GetDevToolsURL(Profile* profile,\n                                    const GURL& base_url,\n                                    bool shared_worker_frontend,\n                                    const std::string& remote_frontend,\n                                    bool can_dock) {\n  // Compatibility errors are encoded with data urls, pass them\n  // through with no decoration.\n  if (base_url.SchemeIs(\"data\"))\n    return base_url;\n\n  std::string frontend_url(\n      !remote_frontend.empty() ?\n          remote_frontend :\n          base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\"));\n  if (shared_worker_frontend)\n    url_string += \"&isSharedWorker=true\";\n  if (remote_frontend.size()) {\n    url_string += \"&remoteFrontend=true\";\n  } else {\n    url_string += \"&remoteBase=\" + DevToolsUI::GetRemoteBaseURL().spec();\n  }\n  if (can_dock)\n    url_string += \"&can_dock=true\";\n  return GURL(url_string);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,7 @@\n                                     const GURL& base_url,\n                                     bool shared_worker_frontend,\n                                     const std::string& remote_frontend,\n-                                    bool can_dock,\n-                                    const std::string& settings) {\n+                                    bool can_dock) {\n   // Compatibility errors are encoded with data urls, pass them\n   // through with no decoration.\n   if (base_url.SchemeIs(\"data\"))\n@@ -25,7 +24,5 @@\n   }\n   if (can_dock)\n     url_string += \"&can_dock=true\";\n-  if (settings.size())\n-    url_string += \"&settings=\" + settings;\n   return GURL(url_string);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                                    bool can_dock,",
                "                                    const std::string& settings) {",
                "  if (settings.size())",
                "    url_string += \"&settings=\" + settings;"
            ],
            "added_lines": [
                "                                    bool can_dock) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5165",
        "func_name": "chromium/DevToolsWindow::Create",
        "description": "Cross-site scripting (XSS) vulnerability in the Developer Tools (aka DevTools) subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux allows remote attackers to inject arbitrary web script or HTML via the settings parameter in a chrome-devtools-frontend.appspot.com URL's query string.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/d5e6098dc2e984befc836f482845137245fa04e2",
        "commit_title": "[DevTools] Do not use \"settings\" query param.",
        "commit_text": " Implemented the same functionality on embedder side. Also, sanitizing \"settings\" query param for remote frontends.   Review-Url: https://codereview.chromium.org/2177983004 ",
        "func_before": "DevToolsWindow* DevToolsWindow::Create(\n    Profile* profile,\n    const GURL& frontend_url,\n    content::WebContents* inspected_web_contents,\n    bool shared_worker_frontend,\n    const std::string& remote_frontend,\n    bool can_dock,\n    const std::string& settings) {\n  if (profile->GetPrefs()->GetBoolean(prefs::kDevToolsDisabled) ||\n      base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))\n    return nullptr;\n\n  if (inspected_web_contents) {\n    // Check for a place to dock.\n    Browser* browser = NULL;\n    int tab;\n    if (!FindInspectedBrowserAndTabIndex(inspected_web_contents,\n                                         &browser, &tab) ||\n        browser->is_type_popup()) {\n      can_dock = false;\n    }\n  }\n\n  // Create WebContents with devtools.\n  GURL url(GetDevToolsURL(profile, frontend_url,\n                          shared_worker_frontend,\n                          remote_frontend,\n                          can_dock, settings));\n  std::unique_ptr<WebContents> main_web_contents(\n      WebContents::Create(WebContents::CreateParams(profile)));\n  main_web_contents->GetController().LoadURL(\n      DecorateFrontendURL(url), content::Referrer(),\n      ui::PAGE_TRANSITION_AUTO_TOPLEVEL, std::string());\n  DevToolsUIBindings* bindings =\n      DevToolsUIBindings::ForWebContents(main_web_contents.get());\n  if (!bindings)\n    return nullptr;\n\n  return new DevToolsWindow(profile, main_web_contents.release(), bindings,\n                            inspected_web_contents, can_dock);\n}",
        "func": "DevToolsWindow* DevToolsWindow::Create(\n    Profile* profile,\n    const GURL& frontend_url,\n    content::WebContents* inspected_web_contents,\n    bool shared_worker_frontend,\n    const std::string& remote_frontend,\n    bool can_dock,\n    const std::string& settings) {\n  if (profile->GetPrefs()->GetBoolean(prefs::kDevToolsDisabled) ||\n      base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))\n    return nullptr;\n\n  if (inspected_web_contents) {\n    // Check for a place to dock.\n    Browser* browser = NULL;\n    int tab;\n    if (!FindInspectedBrowserAndTabIndex(inspected_web_contents,\n                                         &browser, &tab) ||\n        browser->is_type_popup()) {\n      can_dock = false;\n    }\n  }\n\n  // Create WebContents with devtools.\n  GURL url(GetDevToolsURL(profile, frontend_url,\n                          shared_worker_frontend,\n                          remote_frontend,\n                          can_dock));\n  std::unique_ptr<WebContents> main_web_contents(\n      WebContents::Create(WebContents::CreateParams(profile)));\n  main_web_contents->GetController().LoadURL(\n      DecorateFrontendURL(url), content::Referrer(),\n      ui::PAGE_TRANSITION_AUTO_TOPLEVEL, std::string());\n  DevToolsUIBindings* bindings =\n      DevToolsUIBindings::ForWebContents(main_web_contents.get());\n  if (!bindings)\n    return nullptr;\n  if (!settings.empty())\n    SetPreferencesFromJson(profile, settings);\n  return new DevToolsWindow(profile, main_web_contents.release(), bindings,\n                            inspected_web_contents, can_dock);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n   GURL url(GetDevToolsURL(profile, frontend_url,\n                           shared_worker_frontend,\n                           remote_frontend,\n-                          can_dock, settings));\n+                          can_dock));\n   std::unique_ptr<WebContents> main_web_contents(\n       WebContents::Create(WebContents::CreateParams(profile)));\n   main_web_contents->GetController().LoadURL(\n@@ -35,7 +35,8 @@\n       DevToolsUIBindings::ForWebContents(main_web_contents.get());\n   if (!bindings)\n     return nullptr;\n-\n+  if (!settings.empty())\n+    SetPreferencesFromJson(profile, settings);\n   return new DevToolsWindow(profile, main_web_contents.release(), bindings,\n                             inspected_web_contents, can_dock);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                          can_dock, settings));",
                ""
            ],
            "added_lines": [
                "                          can_dock));",
                "  if (!settings.empty())",
                "    SetPreferencesFromJson(profile, settings);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5181",
        "func_name": "chromium/PrivateScriptRunner::runDOMMethod",
        "description": "Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/0a242b6c8a66ee530d5b68c74dfabe74e6415d45",
        "commit_title": "Blink-in-JS should not run micro tasks",
        "commit_text": " If Blink-in-JS runs micro tasks, there's a risk of causing a UXSS bug (see 645211 for concrete steps).  This CL makes Blink-in-JS use callInternalFunction (instead of callFunction) to avoid running micro tasks after Blink-in-JS' callbacks.   Review-Url: https://codereview.chromium.org/2330843002 ",
        "func_before": "v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* methodName, v8::Local<v8::Value> holder, int argc, v8::Local<v8::Value> argv[])\n{\n    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);\n    v8::Local<v8::Value> method;\n    if (!classObject->Get(scriptState->context(), v8String(scriptState->isolate(), methodName)).ToLocal(&method) || !method->IsFunction()) {\n        fprintf(stderr, \"Private script error: Target DOM method was not found. (Class name = %s, Method name = %s)\\n\", className, methodName);\n        RELEASE_NOTREACHED();\n    }\n    initializeHolderIfNeeded(scriptState, classObject, holder);\n    v8::TryCatch block(scriptState->isolate());\n    v8::Local<v8::Value> result;\n    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n        rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);\n        block.ReThrow();\n        return v8::Local<v8::Value>();\n    }\n    return result;\n}",
        "func": "v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* methodName, v8::Local<v8::Value> holder, int argc, v8::Local<v8::Value> argv[])\n{\n    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);\n    v8::Local<v8::Value> method;\n    if (!classObject->Get(scriptState->context(), v8String(scriptState->isolate(), methodName)).ToLocal(&method) || !method->IsFunction()) {\n        fprintf(stderr, \"Private script error: Target DOM method was not found. (Class name = %s, Method name = %s)\\n\", className, methodName);\n        RELEASE_NOTREACHED();\n    }\n    initializeHolderIfNeeded(scriptState, classObject, holder);\n    v8::TryCatch block(scriptState->isolate());\n    v8::Local<v8::Value> result;\n    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n        rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);\n        block.ReThrow();\n        return v8::Local<v8::Value>();\n    }\n    return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(scriptState->isolate());\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {"
            ],
            "added_lines": [
                "    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5181",
        "func_name": "chromium/PrivateScriptRunner::runDOMAttributeSetter",
        "description": "Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/0a242b6c8a66ee530d5b68c74dfabe74e6415d45",
        "commit_title": "Blink-in-JS should not run micro tasks",
        "commit_text": " If Blink-in-JS runs micro tasks, there's a risk of causing a UXSS bug (see 645211 for concrete steps).  This CL makes Blink-in-JS use callInternalFunction (instead of callFunction) to avoid running micro tasks after Blink-in-JS' callbacks.   Review-Url: https://codereview.chromium.org/2330843002 ",
        "func_before": "bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder, v8::Local<v8::Value> v8Value)\n{\n    v8::Isolate* isolate = scriptState->isolate();\n    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);\n    v8::Local<v8::Value> descriptor;\n    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n    v8::Local<v8::Value> setter;\n    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, \"set\")).ToLocal(&setter) || !setter->IsFunction()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n    initializeHolderIfNeeded(scriptState, classObject, holder);\n    v8::Local<v8::Value> argv[] = { v8Value };\n    v8::TryCatch block(isolate);\n    v8::Local<v8::Value> result;\n    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n        rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);\n        block.ReThrow();\n        return false;\n    }\n    return true;\n}",
        "func": "bool PrivateScriptRunner::runDOMAttributeSetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder, v8::Local<v8::Value> v8Value)\n{\n    v8::Isolate* isolate = scriptState->isolate();\n    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);\n    v8::Local<v8::Value> descriptor;\n    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n    v8::Local<v8::Value> setter;\n    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, \"set\")).ToLocal(&setter) || !setter->IsFunction()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute setter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n    initializeHolderIfNeeded(scriptState, classObject, holder);\n    v8::Local<v8::Value> argv[] = { v8Value };\n    v8::TryCatch block(isolate);\n    v8::Local<v8::Value> result;\n    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n        rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);\n        block.ReThrow();\n        return false;\n    }\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n     v8::Local<v8::Value> argv[] = { v8Value };\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::SetterContext, attributeName, className);\n         block.ReThrow();\n         return false;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(setter), scriptState->getExecutionContext(), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {"
            ],
            "added_lines": [
                "    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(setter), holder, WTF_ARRAY_LENGTH(argv), argv, isolate).ToLocal(&result)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5181",
        "func_name": "chromium/PrivateScriptRunner::runDOMAttributeGetter",
        "description": "Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/0a242b6c8a66ee530d5b68c74dfabe74e6415d45",
        "commit_title": "Blink-in-JS should not run micro tasks",
        "commit_text": " If Blink-in-JS runs micro tasks, there's a risk of causing a UXSS bug (see 645211 for concrete steps).  This CL makes Blink-in-JS use callInternalFunction (instead of callFunction) to avoid running micro tasks after Blink-in-JS' callbacks.   Review-Url: https://codereview.chromium.org/2330843002 ",
        "func_before": "v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder)\n{\n    v8::Isolate* isolate = scriptState->isolate();\n    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);\n    v8::Local<v8::Value> descriptor;\n    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n    v8::Local<v8::Value> getter;\n    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, \"get\")).ToLocal(&getter) || !getter->IsFunction()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n    initializeHolderIfNeeded(scriptState, classObject, holder);\n    v8::TryCatch block(isolate);\n    v8::Local<v8::Value> result;\n    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n        rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);\n        block.ReThrow();\n        return v8::Local<v8::Value>();\n    }\n    return result;\n}",
        "func": "v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder)\n{\n    v8::Isolate* isolate = scriptState->isolate();\n    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);\n    v8::Local<v8::Value> descriptor;\n    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n    v8::Local<v8::Value> getter;\n    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, \"get\")).ToLocal(&getter) || !getter->IsFunction()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n    initializeHolderIfNeeded(scriptState, classObject, holder);\n    v8::TryCatch block(isolate);\n    v8::Local<v8::Value> result;\n    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {\n        rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);\n        block.ReThrow();\n        return v8::Local<v8::Value>();\n    }\n    return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n-    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {"
            ],
            "added_lines": [
                "    if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(getter), holder, 0, 0, isolate).ToLocal(&result)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5181",
        "func_name": "chromium/initializeHolderIfNeeded",
        "description": "Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/0a242b6c8a66ee530d5b68c74dfabe74e6415d45",
        "commit_title": "Blink-in-JS should not run micro tasks",
        "commit_text": " If Blink-in-JS runs micro tasks, there's a risk of causing a UXSS bug (see 645211 for concrete steps).  This CL makes Blink-in-JS use callInternalFunction (instead of callFunction) to avoid running micro tasks after Blink-in-JS' callbacks.   Review-Url: https://codereview.chromium.org/2330843002 ",
        "func_before": "static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Object> classObject, v8::Local<v8::Value> holder)\n{\n    RELEASE_ASSERT(!holder.IsEmpty());\n    RELEASE_ASSERT(holder->IsObject());\n    v8::Local<v8::Object> holderObject = v8::Local<v8::Object>::Cast(holder);\n    v8::Isolate* isolate = scriptState->isolate();\n    v8::Local<v8::Context> context = scriptState->context();\n    auto privateIsInitialized = V8PrivateProperty::getPrivateScriptRunnerIsInitialized(isolate);\n    if (privateIsInitialized.hasValue(context, holderObject))\n        return; // Already initialized.\n\n    v8::TryCatch block(isolate);\n    v8::Local<v8::Value> initializeFunction;\n    if (classObject->Get(scriptState->context(), v8String(isolate, \"initialize\")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {\n        v8::TryCatch block(isolate);\n        v8::Local<v8::Value> result;\n        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n            fprintf(stderr, \"Private script error: Object constructor threw an exception.\\n\");\n            dumpV8Message(context, block.Message());\n            RELEASE_NOTREACHED();\n        }\n    }\n\n    // Inject the prototype object of the private script into the prototype chain of the holder object.\n    // This is necessary to let the holder object use properties defined on the prototype object\n    // of the private script. (e.g., if the prototype object has |foo|, the holder object should be able\n    // to use it with |this.foo|.)\n    if (classObject->GetPrototype() != holderObject->GetPrototype()) {\n        if (!v8CallBoolean(classObject->SetPrototype(context, holderObject->GetPrototype()))) {\n            fprintf(stderr, \"Private script error: SetPrototype failed.\\n\");\n            dumpV8Message(context, block.Message());\n            RELEASE_NOTREACHED();\n        }\n    }\n    if (!v8CallBoolean(holderObject->SetPrototype(context, classObject))) {\n        fprintf(stderr, \"Private script error: SetPrototype failed.\\n\");\n        dumpV8Message(context, block.Message());\n        RELEASE_NOTREACHED();\n    }\n\n    privateIsInitialized.set(context, holderObject, v8Boolean(true, isolate));\n}",
        "func": "static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Object> classObject, v8::Local<v8::Value> holder)\n{\n    RELEASE_ASSERT(!holder.IsEmpty());\n    RELEASE_ASSERT(holder->IsObject());\n    v8::Local<v8::Object> holderObject = v8::Local<v8::Object>::Cast(holder);\n    v8::Isolate* isolate = scriptState->isolate();\n    v8::Local<v8::Context> context = scriptState->context();\n    auto privateIsInitialized = V8PrivateProperty::getPrivateScriptRunnerIsInitialized(isolate);\n    if (privateIsInitialized.hasValue(context, holderObject))\n        return; // Already initialized.\n\n    v8::TryCatch block(isolate);\n    v8::Local<v8::Value> initializeFunction;\n    if (classObject->Get(scriptState->context(), v8String(isolate, \"initialize\")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {\n        v8::TryCatch block(isolate);\n        v8::Local<v8::Value> result;\n        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {\n            fprintf(stderr, \"Private script error: Object constructor threw an exception.\\n\");\n            dumpV8Message(context, block.Message());\n            RELEASE_NOTREACHED();\n        }\n    }\n\n    // Inject the prototype object of the private script into the prototype chain of the holder object.\n    // This is necessary to let the holder object use properties defined on the prototype object\n    // of the private script. (e.g., if the prototype object has |foo|, the holder object should be able\n    // to use it with |this.foo|.)\n    if (classObject->GetPrototype() != holderObject->GetPrototype()) {\n        if (!v8CallBoolean(classObject->SetPrototype(context, holderObject->GetPrototype()))) {\n            fprintf(stderr, \"Private script error: SetPrototype failed.\\n\");\n            dumpV8Message(context, block.Message());\n            RELEASE_NOTREACHED();\n        }\n    }\n    if (!v8CallBoolean(holderObject->SetPrototype(context, classObject))) {\n        fprintf(stderr, \"Private script error: SetPrototype failed.\\n\");\n        dumpV8Message(context, block.Message());\n        RELEASE_NOTREACHED();\n    }\n\n    privateIsInitialized.set(context, holderObject, v8Boolean(true, isolate));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n     if (classObject->Get(scriptState->context(), v8String(isolate, \"initialize\")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {\n         v8::TryCatch block(isolate);\n         v8::Local<v8::Value> result;\n-        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n+        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {\n             fprintf(stderr, \"Private script error: Object constructor threw an exception.\\n\");\n             dumpV8Message(context, block.Message());\n             RELEASE_NOTREACHED();",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {"
            ],
            "added_lines": [
                "        if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(initializeFunction), holder, 0, 0, isolate).ToLocal(&result)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5191",
        "func_name": "chromium/FormatBookmarkURLForDisplay",
        "description": "Bookmark handling in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android had insufficient validation of supplied data, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages, as demonstrated by an interpretation conflict between userinfo and scheme in an http://javascript:payload@example.com URL.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/2775e31152857adc2bb9775b03212d1356541b4b",
        "commit_title": "[merge to m54] Prevent interpretating userinfo as url scheme when editing bookmarks",
        "commit_text": " Chrome's Edit Bookmark dialog formats urls for display such that a url of http://javascript:scripttext@host.com is later converted to a javascript url scheme, allowing persistence of a script injection attack within the user's bookmarks.  This fix prevents such misinterpretations by always showing the scheme when a userinfo component is present within the url.   Review-Url: https://codereview.chromium.org/2368593002 (cherry picked from commit fa34e547d6ee25ea0692436ba7462ed0a0ef45f4)   ",
        "func_before": "base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n  // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme\n  // and trailing slash, and unescape most characters.  However, it's\n  // important not to drop any username/password, or unescape anything that\n  // changes the URL's meaning.\n  return url_formatter::FormatUrl(\n      url, url_formatter::kFormatUrlOmitAll &\n               ~url_formatter::kFormatUrlOmitUsernamePassword,\n      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);\n}",
        "func": "base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n  // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme\n  // and trailing slash, and unescape most characters. However, it's\n  // important not to drop any username/password, or unescape anything that\n  // changes the URL's meaning.\n  url_formatter::FormatUrlTypes format_types =\n      url_formatter::kFormatUrlOmitAll &\n      ~url_formatter::kFormatUrlOmitUsernamePassword;\n\n  // If username is present, we must not omit the scheme because FixupURL() will\n  // subsequently interpret the username as a scheme. crbug.com/639126\n  if (url.has_username())\n    format_types &= ~url_formatter::kFormatUrlOmitHTTP;\n\n  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,\n                                  nullptr, nullptr, nullptr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,17 @@\n base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n   // Because this gets re-parsed by FixupURL(), it's safe to omit the scheme\n-  // and trailing slash, and unescape most characters.  However, it's\n+  // and trailing slash, and unescape most characters. However, it's\n   // important not to drop any username/password, or unescape anything that\n   // changes the URL's meaning.\n-  return url_formatter::FormatUrl(\n-      url, url_formatter::kFormatUrlOmitAll &\n-               ~url_formatter::kFormatUrlOmitUsernamePassword,\n-      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);\n+  url_formatter::FormatUrlTypes format_types =\n+      url_formatter::kFormatUrlOmitAll &\n+      ~url_formatter::kFormatUrlOmitUsernamePassword;\n+\n+  // If username is present, we must not omit the scheme because FixupURL() will\n+  // subsequently interpret the username as a scheme. crbug.com/639126\n+  if (url.has_username())\n+    format_types &= ~url_formatter::kFormatUrlOmitHTTP;\n+\n+  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,\n+                                  nullptr, nullptr, nullptr);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  // and trailing slash, and unescape most characters.  However, it's",
                "  return url_formatter::FormatUrl(",
                "      url, url_formatter::kFormatUrlOmitAll &",
                "               ~url_formatter::kFormatUrlOmitUsernamePassword,",
                "      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);"
            ],
            "added_lines": [
                "  // and trailing slash, and unescape most characters. However, it's",
                "  url_formatter::FormatUrlTypes format_types =",
                "      url_formatter::kFormatUrlOmitAll &",
                "      ~url_formatter::kFormatUrlOmitUsernamePassword;",
                "",
                "  // If username is present, we must not omit the scheme because FixupURL() will",
                "  // subsequently interpret the username as a scheme. crbug.com/639126",
                "  if (url.has_username())",
                "    format_types &= ~url_formatter::kFormatUrlOmitHTTP;",
                "",
                "  return url_formatter::FormatUrl(url, format_types, net::UnescapeRule::SPACES,",
                "                                  nullptr, nullptr, nullptr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6503",
        "func_name": "qbittorrent/qBittorrent/PropertiesWidget::loadTorrentInfos",
        "description": "WebUI in qBittorrent before 3.3.11 did not escape many values, which could potentially lead to XSS.",
        "git_url": "https://github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "commit_title": "Add Utils::String::toHtmlEscaped",
        "commit_text": "",
        "func_before": "void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n\n    // Save path\n    updateSavePath(m_torrent);\n    // Hash\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        // Creation date\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n\n        // Comment\n        comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));\n\n        // URL seeds\n        loadUrlSeeds();\n\n        label_created_by_val->setText(m_torrent->creator());\n\n        // List files in torrent\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n\n        // Load file priorities\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    // Load dynamic data\n    loadDynamicData();\n}",
        "func": "void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n\n    // Save path\n    updateSavePath(m_torrent);\n    // Hash\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        // Creation date\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n\n        // Comment\n        comment_text->setText(Utils::Misc::parseHtmlLinks(Utils::String::toHtmlEscaped(m_torrent->comment())));\n\n        // URL seeds\n        loadUrlSeeds();\n\n        label_created_by_val->setText(Utils::String::toHtmlEscaped(m_torrent->creator()));\n\n        // List files in torrent\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n\n        // Load file priorities\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    // Load dynamic data\n    loadDynamicData();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,12 +18,12 @@\n         label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n \n         // Comment\n-        comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));\n+        comment_text->setText(Utils::Misc::parseHtmlLinks(Utils::String::toHtmlEscaped(m_torrent->comment())));\n \n         // URL seeds\n         loadUrlSeeds();\n \n-        label_created_by_val->setText(m_torrent->creator());\n+        label_created_by_val->setText(Utils::String::toHtmlEscaped(m_torrent->creator()));\n \n         // List files in torrent\n         PropListModel->model()->setupModelData(m_torrent->info());",
        "diff_line_info": {
            "deleted_lines": [
                "        comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));",
                "        label_created_by_val->setText(m_torrent->creator());"
            ],
            "added_lines": [
                "        comment_text->setText(Utils::Misc::parseHtmlLinks(Utils::String::toHtmlEscaped(m_torrent->comment())));",
                "        label_created_by_val->setText(Utils::String::toHtmlEscaped(m_torrent->creator()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6503",
        "func_name": "qbittorrent/qBittorrent/PeerListWidget::addPeer",
        "description": "WebUI in qBittorrent before 3.3.11 did not escape many values, which could potentially lead to XSS.",
        "git_url": "https://github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "commit_title": "Add Utils::String::toHtmlEscaped",
        "commit_text": "",
        "func_before": "QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    int row = m_listModel->rowCount();\n    // Adding Peer to peer list\n    m_listModel->insertRow(row);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n        }\n        else {\n            m_missingFlags.insert(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n\n    return m_listModel->item(row, PeerListDelegate::IP);\n}",
        "func": "QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    int row = m_listModel->rowCount();\n    // Adding Peer to peer list\n    m_listModel->insertRow(row);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n        }\n        else {\n            m_missingFlags.insert(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n\n    return m_listModel->item(row, PeerListDelegate::IP);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n-    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n+    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());",
        "diff_line_info": {
            "deleted_lines": [
                "    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());"
            ],
            "added_lines": [
                "    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6503",
        "func_name": "qbittorrent/qBittorrent/PeerListWidget::updatePeer",
        "description": "WebUI in qBittorrent before 3.3.11 did not escape many values, which could potentially lead to XSS.",
        "git_url": "https://github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "commit_title": "Add Utils::String::toHtmlEscaped",
        "commit_text": "",
        "func_before": "void PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    QStandardItem *item = m_peerItems.value(ip);\n    int row = item->row();\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n            m_missingFlags.remove(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n}",
        "func": "void PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    QStandardItem *item = m_peerItems.value(ip);\n    int row = item->row();\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n            m_missingFlags.remove(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n-    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n+    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n     m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());",
        "diff_line_info": {
            "deleted_lines": [
                "    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());"
            ],
            "added_lines": [
                "    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6503",
        "func_name": "qbittorrent/qBittorrent/Logger::addMessage",
        "description": "WebUI in qBittorrent before 3.3.11 did not escape many values, which could potentially lead to XSS.",
        "git_url": "https://github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "commit_title": "Add Utils::String::toHtmlEscaped",
        "commit_text": "",
        "func_before": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}",
        "func": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, Utils::String::toHtmlEscaped(message) };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n     QWriteLocker locker(&lock);\n \n-    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n+    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, Utils::String::toHtmlEscaped(message) };\n     m_messages.push_back(temp);\n \n     if (m_messages.size() >= MAX_LOG_MESSAGES)",
        "diff_line_info": {
            "deleted_lines": [
                "    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };"
            ],
            "added_lines": [
                "    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, Utils::String::toHtmlEscaped(message) };"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6503",
        "func_name": "qbittorrent/qBittorrent/Logger::addPeer",
        "description": "WebUI in qBittorrent before 3.3.11 did not escape many values, which could potentially lead to XSS.",
        "git_url": "https://github.com/qbittorrent/qBittorrent/commit/6ca3e4f094da0a0017cb2d483ec1db6176bb0b16",
        "commit_title": "Add Utils::String::toHtmlEscaped",
        "commit_text": "",
        "func_before": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}",
        "func": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n     QWriteLocker locker(&lock);\n \n-    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n+    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };\n     m_peers.push_back(temp);\n \n     if (m_peers.size() >= MAX_LOG_MESSAGES)",
        "diff_line_info": {
            "deleted_lines": [
                "    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };"
            ],
            "added_lines": [
                "    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-17082",
        "func_name": "php/php-src/php_handler",
        "description": "The Apache2 component in PHP before 5.6.38, 7.0.x before 7.0.32, 7.1.x before 7.1.22, and 7.2.x before 7.2.10 allows XSS via the body of a \"Transfer-Encoding: chunked\" request, because the bucket brigade is mishandled in the php_handler function in sapi/apache2handler/sapi_apache2.c.",
        "git_url": "https://github.com/php/php-src/commit/23b057742e3cf199612fa8050ae86cae675e214e",
        "commit_title": "Fix for bug #76582",
        "commit_text": " The brigade seems to end up in a messed up state if something fails in shutdown, so we clean it up.",
        "func_before": "static int php_handler(request_rec *r)\n{\n\tphp_struct * volatile ctx;\n\tvoid *conf;\n\tapr_bucket_brigade * volatile brigade;\n\tapr_bucket *bucket;\n\tapr_status_t rv;\n\trequest_rec * volatile parent_req = NULL;\n\tTSRMLS_FETCH();\n\n#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);\n\n\tconf = ap_get_module_config(r->per_dir_config, &php5_module);\n\n\t/* apply_config() needs r in some cases, so allocate server_context early */\n\tctx = SG(server_context);\n\tif (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, \"INCLUDED\"))) {\nnormal:\n\t\tctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));\n\t\t/* register a cleanup so we clear out the SG(server_context)\n\t\t * after each request. Note: We pass in the pointer to the\n\t\t * server_context in case this is handled by a different thread.\n\t\t */\n\t\tapr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);\n\t\tctx->r = r;\n\t\tctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */\n\t} else {\n\t\tparent_req = ctx->r;\n\t\tctx->r = r;\n\t}\n\tapply_config(conf);\n\n\tif (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {\n\t\t/* Check for xbithack in this case. */\n\t\tif (!AP2(xbithack) || strcmp(r->handler, \"text/html\") || !(r->finfo.protection & APR_UEXECUTE)) {\n\t\t\tPHPAP_INI_OFF;\n\t\t\treturn DECLINED;\n\t\t}\n\t}\n\n\t/* Give a 404 if PATH_INFO is used but is explicitly disabled in\n\t * the configuration; default behaviour is to accept. */\n\tif (r->used_path_info == AP_REQ_REJECT_PATH_INFO\n\t\t&& r->path_info && r->path_info[0]) {\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* handle situations where user turns the engine off */\n\tif (!AP2(engine)) {\n\t\tPHPAP_INI_OFF;\n\t\treturn DECLINED;\n\t}\n\n\tif (r->finfo.filetype == 0) {\n\t\tphp_apache_sapi_log_message_ex(\"script '%s' not found or unable to stat\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\tif (r->finfo.filetype == APR_DIR) {\n\t\tphp_apache_sapi_log_message_ex(\"attempt to invoke directory '%s' as script\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_FORBIDDEN;\n\t}\n\n\t/* Setup the CGI variables if this is the main request */\n\tif (r->main == NULL ||\n\t\t/* .. or if the sub-request environment differs from the main-request. */\n\t\tr->subprocess_env != r->main->subprocess_env\n\t) {\n\t\t/* setup standard CGI variables */\n\t\tap_add_common_vars(r);\n\t\tap_add_cgi_vars(r);\n\t}\n\nzend_first_try {\n\n\tif (ctx == NULL) {\n\t\tbrigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n\t\tctx = SG(server_context);\n\t\tctx->brigade = brigade;\n\n\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\tzend_bailout();\n\t\t}\n\t} else {\n\t\tif (!parent_req) {\n\t\t\tparent_req = ctx->r;\n\t\t}\n\t\tif (parent_req && parent_req->handler &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SCRIPT)) {\n\t\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\t\tzend_bailout();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * check if coming due to ErrorDocument\n\t\t * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs\n\t\t * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting\n\t\t * PHP instance to handle the request rather then creating a new one.\n\t\t*/\n\t\tif (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, \"INCLUDED\")) {\n\t\t\tparent_req = NULL;\n\t\t\tgoto normal;\n\t\t}\n\t\tctx->r = r;\n\t\tbrigade = ctx->brigade;\n\t}\n\n\tif (AP2(last_modified)) {\n\t\tap_update_mtime(r, r->finfo.mtime);\n\t\tap_set_last_modified(r);\n\t}\n\n\t/* Determine if we need to parse the file or show the source */\n\tif (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {\n\t\tzend_syntax_highlighter_ini syntax_highlighter_ini;\n\t\tphp_get_highlight_struct(&syntax_highlighter_ini);\n\t\thighlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);\n\t} else {\n\t\tzend_file_handle zfd;\n\n\t\tzfd.type = ZEND_HANDLE_FILENAME;\n\t\tzfd.filename = (char *) r->filename;\n\t\tzfd.free_filename = 0;\n\t\tzfd.opened_path = NULL;\n\n\t\tif (!parent_req) {\n\t\t\tphp_execute_script(&zfd TSRMLS_CC);\n\t\t} else {\n\t\t\tzend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);\n\t\t}\n\n\t\tapr_table_set(r->notes, \"mod_php_memory_usage\",\n\t\t\tapr_psprintf(ctx->r->pool, \"%\" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));\n\t}\n\n} zend_end_try();\n\n\tif (!parent_req) {\n\t\tphp_apache_request_dtor(r TSRMLS_CC);\n\t\tctx->request_processed = 1;\n\t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n\t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n\n\t\trv = ap_pass_brigade(r->output_filters, brigade);\n\t\tif (rv != APR_SUCCESS || r->connection->aborted) {\nzend_first_try {\n\t\t\tphp_handle_aborted_connection();\n} zend_end_try();\n\t\t}\n\t\tapr_brigade_cleanup(brigade);\n\t\tapr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);\n\t} else {\n\t\tctx->r = parent_req;\n\t}\n\n\treturn OK;\n}",
        "func": "static int php_handler(request_rec *r)\n{\n\tphp_struct * volatile ctx;\n\tvoid *conf;\n\tapr_bucket_brigade * volatile brigade;\n\tapr_bucket *bucket;\n\tapr_status_t rv;\n\trequest_rec * volatile parent_req = NULL;\n\tTSRMLS_FETCH();\n\n#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);\n\n\tconf = ap_get_module_config(r->per_dir_config, &php5_module);\n\n\t/* apply_config() needs r in some cases, so allocate server_context early */\n\tctx = SG(server_context);\n\tif (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, \"INCLUDED\"))) {\nnormal:\n\t\tctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));\n\t\t/* register a cleanup so we clear out the SG(server_context)\n\t\t * after each request. Note: We pass in the pointer to the\n\t\t * server_context in case this is handled by a different thread.\n\t\t */\n\t\tapr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);\n\t\tctx->r = r;\n\t\tctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */\n\t} else {\n\t\tparent_req = ctx->r;\n\t\tctx->r = r;\n\t}\n\tapply_config(conf);\n\n\tif (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {\n\t\t/* Check for xbithack in this case. */\n\t\tif (!AP2(xbithack) || strcmp(r->handler, \"text/html\") || !(r->finfo.protection & APR_UEXECUTE)) {\n\t\t\tPHPAP_INI_OFF;\n\t\t\treturn DECLINED;\n\t\t}\n\t}\n\n\t/* Give a 404 if PATH_INFO is used but is explicitly disabled in\n\t * the configuration; default behaviour is to accept. */\n\tif (r->used_path_info == AP_REQ_REJECT_PATH_INFO\n\t\t&& r->path_info && r->path_info[0]) {\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* handle situations where user turns the engine off */\n\tif (!AP2(engine)) {\n\t\tPHPAP_INI_OFF;\n\t\treturn DECLINED;\n\t}\n\n\tif (r->finfo.filetype == 0) {\n\t\tphp_apache_sapi_log_message_ex(\"script '%s' not found or unable to stat\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\tif (r->finfo.filetype == APR_DIR) {\n\t\tphp_apache_sapi_log_message_ex(\"attempt to invoke directory '%s' as script\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_FORBIDDEN;\n\t}\n\n\t/* Setup the CGI variables if this is the main request */\n\tif (r->main == NULL ||\n\t\t/* .. or if the sub-request environment differs from the main-request. */\n\t\tr->subprocess_env != r->main->subprocess_env\n\t) {\n\t\t/* setup standard CGI variables */\n\t\tap_add_common_vars(r);\n\t\tap_add_cgi_vars(r);\n\t}\n\nzend_first_try {\n\n\tif (ctx == NULL) {\n\t\tbrigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n\t\tctx = SG(server_context);\n\t\tctx->brigade = brigade;\n\n\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\tzend_bailout();\n\t\t}\n\t} else {\n\t\tif (!parent_req) {\n\t\t\tparent_req = ctx->r;\n\t\t}\n\t\tif (parent_req && parent_req->handler &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SCRIPT)) {\n\t\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\t\tzend_bailout();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * check if coming due to ErrorDocument\n\t\t * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs\n\t\t * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting\n\t\t * PHP instance to handle the request rather then creating a new one.\n\t\t*/\n\t\tif (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, \"INCLUDED\")) {\n\t\t\tparent_req = NULL;\n\t\t\tgoto normal;\n\t\t}\n\t\tctx->r = r;\n\t\tbrigade = ctx->brigade;\n\t}\n\n\tif (AP2(last_modified)) {\n\t\tap_update_mtime(r, r->finfo.mtime);\n\t\tap_set_last_modified(r);\n\t}\n\n\t/* Determine if we need to parse the file or show the source */\n\tif (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {\n\t\tzend_syntax_highlighter_ini syntax_highlighter_ini;\n\t\tphp_get_highlight_struct(&syntax_highlighter_ini);\n\t\thighlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);\n\t} else {\n\t\tzend_file_handle zfd;\n\n\t\tzfd.type = ZEND_HANDLE_FILENAME;\n\t\tzfd.filename = (char *) r->filename;\n\t\tzfd.free_filename = 0;\n\t\tzfd.opened_path = NULL;\n\n\t\tif (!parent_req) {\n\t\t\tphp_execute_script(&zfd TSRMLS_CC);\n\t\t} else {\n\t\t\tzend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);\n\t\t}\n\n\t\tapr_table_set(r->notes, \"mod_php_memory_usage\",\n\t\t\tapr_psprintf(ctx->r->pool, \"%\" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));\n\t}\n\n} zend_end_try();\n\n\tif (!parent_req) {\n\t\tphp_apache_request_dtor(r TSRMLS_CC);\n\t\tctx->request_processed = 1;\n\t\tapr_brigade_cleanup(brigade);\n\t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n\t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n\n\t\trv = ap_pass_brigade(r->output_filters, brigade);\n\t\tif (rv != APR_SUCCESS || r->connection->aborted) {\nzend_first_try {\n\t\t\tphp_handle_aborted_connection();\n} zend_end_try();\n\t\t}\n\t\tapr_brigade_cleanup(brigade);\n\t\tapr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);\n\t} else {\n\t\tctx->r = parent_req;\n\t}\n\n\treturn OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -143,6 +143,7 @@\n \tif (!parent_req) {\n \t\tphp_apache_request_dtor(r TSRMLS_CC);\n \t\tctx->request_processed = 1;\n+\t\tapr_brigade_cleanup(brigade);\n \t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n \t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tapr_brigade_cleanup(brigade);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19131",
        "func_name": "squid-cache/squid/Ssl::ErrorDetail::ca_name",
        "description": "Squid before 4.4 has XSS via a crafted X.509 certificate during HTTP(S) error page generation for certificate errors.",
        "git_url": "https://github.com/squid-cache/squid/commit/d241f11e4aaa2ab719358cb808935c98612e71b5",
        "commit_title": "SSL Interception: Injection into default ssl error page via untrusted certificate",
        "commit_text": " The error page allows injecting snippets using the distinguished name of untrusted certificates via the %D template parameter. This patch quote information retrieved from  remote certificates using the %ssl_subject, %ssl_ca_name and %ssl_cn error details formating codes.  Thanks to Nikolas Lohmann [eBlocker] for identifying the problem.  This is a Measurement Factory project",
        "func_before": "const char *Ssl::ErrorDetail::ca_name() const\n{\n    if (broken_cert.get()) {\n        static char tmpBuffer[256]; // A temporary buffer\n        if (X509_NAME_oneline(X509_get_issuer_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))\n            return tmpBuffer;\n    }\n    return \"[Not available]\";\n}",
        "func": "const char *Ssl::ErrorDetail::ca_name() const\n{\n    if (broken_cert.get()) {\n        static char tmpBuffer[256]; // A temporary buffer\n        if (X509_NAME_oneline(X509_get_issuer_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer))) {\n            // quote to avoid possible html code injection through\n            // certificate issuer subject\n            return html_quote(tmpBuffer);\n        }\n    }\n    return \"[Not available]\";\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,11 @@\n {\n     if (broken_cert.get()) {\n         static char tmpBuffer[256]; // A temporary buffer\n-        if (X509_NAME_oneline(X509_get_issuer_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))\n-            return tmpBuffer;\n+        if (X509_NAME_oneline(X509_get_issuer_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer))) {\n+            // quote to avoid possible html code injection through\n+            // certificate issuer subject\n+            return html_quote(tmpBuffer);\n+        }\n     }\n     return \"[Not available]\";\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (X509_NAME_oneline(X509_get_issuer_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))",
                "            return tmpBuffer;"
            ],
            "added_lines": [
                "        if (X509_NAME_oneline(X509_get_issuer_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer))) {",
                "            // quote to avoid possible html code injection through",
                "            // certificate issuer subject",
                "            return html_quote(tmpBuffer);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19131",
        "func_name": "squid-cache/squid/Ssl::ErrorDetail::cn",
        "description": "Squid before 4.4 has XSS via a crafted X.509 certificate during HTTP(S) error page generation for certificate errors.",
        "git_url": "https://github.com/squid-cache/squid/commit/d241f11e4aaa2ab719358cb808935c98612e71b5",
        "commit_title": "SSL Interception: Injection into default ssl error page via untrusted certificate",
        "commit_text": " The error page allows injecting snippets using the distinguished name of untrusted certificates via the %D template parameter. This patch quote information retrieved from  remote certificates using the %ssl_subject, %ssl_ca_name and %ssl_cn error details formating codes.  Thanks to Nikolas Lohmann [eBlocker] for identifying the problem.  This is a Measurement Factory project",
        "func_before": "const char *Ssl::ErrorDetail::cn() const\n{\n    if (broken_cert.get()) {\n        static String tmpStr;  ///< A temporary string buffer\n        tmpStr.clean();\n        Ssl::matchX509CommonNames(broken_cert.get(), &tmpStr, copy_cn);\n        if (tmpStr.size())\n            return tmpStr.termedBuf();\n    }\n    return \"[Not available]\";\n}",
        "func": "const char *Ssl::ErrorDetail::cn() const\n{\n    if (broken_cert.get()) {\n        static String tmpStr;  ///< A temporary string buffer\n        tmpStr.clean();\n        Ssl::matchX509CommonNames(broken_cert.get(), &tmpStr, copy_cn);\n        if (tmpStr.size()) {\n            // quote to avoid possible html code injection through\n            // certificate subject\n            return html_quote(tmpStr.termedBuf());\n        }\n    }\n    return \"[Not available]\";\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,11 @@\n         static String tmpStr;  ///< A temporary string buffer\n         tmpStr.clean();\n         Ssl::matchX509CommonNames(broken_cert.get(), &tmpStr, copy_cn);\n-        if (tmpStr.size())\n-            return tmpStr.termedBuf();\n+        if (tmpStr.size()) {\n+            // quote to avoid possible html code injection through\n+            // certificate subject\n+            return html_quote(tmpStr.termedBuf());\n+        }\n     }\n     return \"[Not available]\";\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (tmpStr.size())",
                "            return tmpStr.termedBuf();"
            ],
            "added_lines": [
                "        if (tmpStr.size()) {",
                "            // quote to avoid possible html code injection through",
                "            // certificate subject",
                "            return html_quote(tmpStr.termedBuf());",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19131",
        "func_name": "squid-cache/squid/Ssl::ErrorDetail::subject",
        "description": "Squid before 4.4 has XSS via a crafted X.509 certificate during HTTP(S) error page generation for certificate errors.",
        "git_url": "https://github.com/squid-cache/squid/commit/d241f11e4aaa2ab719358cb808935c98612e71b5",
        "commit_title": "SSL Interception: Injection into default ssl error page via untrusted certificate",
        "commit_text": " The error page allows injecting snippets using the distinguished name of untrusted certificates via the %D template parameter. This patch quote information retrieved from  remote certificates using the %ssl_subject, %ssl_ca_name and %ssl_cn error details formating codes.  Thanks to Nikolas Lohmann [eBlocker] for identifying the problem.  This is a Measurement Factory project",
        "func_before": "const char  *Ssl::ErrorDetail::subject() const\n{\n    if (broken_cert.get()) {\n        static char tmpBuffer[256]; // A temporary buffer\n        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))\n            return tmpBuffer;\n    }\n    return \"[Not available]\";\n}",
        "func": "const char  *Ssl::ErrorDetail::subject() const\n{\n    if (broken_cert.get()) {\n        static char tmpBuffer[256]; // A temporary buffer\n        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer))) {\n            // quote to avoid possible html code injection through\n            // certificate subject\n            return html_quote(tmpBuffer);\n        }\n    }\n    return \"[Not available]\";\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,11 @@\n {\n     if (broken_cert.get()) {\n         static char tmpBuffer[256]; // A temporary buffer\n-        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))\n-            return tmpBuffer;\n+        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer))) {\n+            // quote to avoid possible html code injection through\n+            // certificate subject\n+            return html_quote(tmpBuffer);\n+        }\n     }\n     return \"[Not available]\";\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer)))",
                "            return tmpBuffer;"
            ],
            "added_lines": [
                "        if (X509_NAME_oneline(X509_get_subject_name(broken_cert.get()), tmpBuffer, sizeof(tmpBuffer))) {",
                "            // quote to avoid possible html code injection through",
                "            // certificate subject",
                "            return html_quote(tmpBuffer);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26123",
        "func_name": "raysan5/raylib/OpenURL",
        "description": "Versions of the package raysan5/raylib before 4.5.0 are vulnerable to Cross-site Scripting (XSS) such that the SetClipboardText API does not properly escape the ' character, allowing attacker-controlled input to break out of the string and execute arbitrary JavaScript via emscripten_run_script function.\r\r**Note:** This vulnerability is present only when compiling raylib for PLATFORM_WEB. All the other Desktop/Mobile/Embedded platforms are not affected.",
        "git_url": "https://github.com/raysan5/raylib/commit/b436c8d7e5346a241b00511a11585936895d959d",
        "commit_title": "ADDED: Security check for `emscripten_run_script()` #2954",
        "commit_text": "",
        "func_before": "void OpenURL(const char *url)\n{\n    // Small security check trying to avoid (partially) malicious code...\n    // sorry for the inconvenience when you hit this point...\n    if (strchr(url, '\\'') != NULL)\n    {\n        TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");\n    }\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));\n    #if defined(_WIN32)\n        sprintf(cmd, \"explorer \\\"%s\\\"\", url);\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        sprintf(cmd, \"xdg-open '%s'\", url); // Alternatives: firefox, x-www-browser\n    #endif\n    #if defined(__APPLE__)\n        sprintf(cmd, \"open '%s'\", url);\n    #endif\n        int result = system(cmd);\n        if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");\n        RL_FREE(cmd);\n#endif\n#if defined(PLATFORM_WEB)\n        emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));\n#endif\n#if defined(PLATFORM_ANDROID)\n        JNIEnv *env = NULL;\n        JavaVM *vm = CORE.Android.app->activity->vm;\n        (*vm)->AttachCurrentThread(vm, &env, NULL);\n\n        jstring urlString = (*env)->NewStringUTF(env, url);\n        jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");\n        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");\n        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);\n\n        jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");\n        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");\n        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);\n        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");\n        jobject intent = (*env)->AllocObject(env, intentClass);\n\n        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);\n        jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");\n        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");\n        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);\n\n        (*vm)->DetachCurrentThread(vm);\n#endif\n    }\n}",
        "func": "void OpenURL(const char *url)\n{\n    // Security check to (aprtially) avoid malicious code on PLATFORM_WEB\n    if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\");\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));\n    #if defined(_WIN32)\n        sprintf(cmd, \"explorer \\\"%s\\\"\", url);\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        sprintf(cmd, \"xdg-open '%s'\", url); // Alternatives: firefox, x-www-browser\n    #endif\n    #if defined(__APPLE__)\n        sprintf(cmd, \"open '%s'\", url);\n    #endif\n        int result = system(cmd);\n        if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");\n        RL_FREE(cmd);\n#endif\n#if defined(PLATFORM_WEB)\n        emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));\n#endif\n#if defined(PLATFORM_ANDROID)\n        JNIEnv *env = NULL;\n        JavaVM *vm = CORE.Android.app->activity->vm;\n        (*vm)->AttachCurrentThread(vm, &env, NULL);\n\n        jstring urlString = (*env)->NewStringUTF(env, url);\n        jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");\n        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");\n        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);\n\n        jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");\n        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");\n        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);\n        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");\n        jobject intent = (*env)->AllocObject(env, intentClass);\n\n        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);\n        jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");\n        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");\n        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);\n\n        (*vm)->DetachCurrentThread(vm);\n#endif\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,7 @@\n void OpenURL(const char *url)\n {\n-    // Small security check trying to avoid (partially) malicious code...\n-    // sorry for the inconvenience when you hit this point...\n-    if (strchr(url, '\\'') != NULL)\n-    {\n-        TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");\n-    }\n+    // Security check to (aprtially) avoid malicious code on PLATFORM_WEB\n+    if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\");\n     else\n     {\n #if defined(PLATFORM_DESKTOP)",
        "diff_line_info": {
            "deleted_lines": [
                "    // Small security check trying to avoid (partially) malicious code...",
                "    // sorry for the inconvenience when you hit this point...",
                "    if (strchr(url, '\\'') != NULL)",
                "    {",
                "        TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");",
                "    }"
            ],
            "added_lines": [
                "    // Security check to (aprtially) avoid malicious code on PLATFORM_WEB",
                "    if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26123",
        "func_name": "raysan5/raylib/SetClipboardText",
        "description": "Versions of the package raysan5/raylib before 4.5.0 are vulnerable to Cross-site Scripting (XSS) such that the SetClipboardText API does not properly escape the ' character, allowing attacker-controlled input to break out of the string and execute arbitrary JavaScript via emscripten_run_script function.\r\r**Note:** This vulnerability is present only when compiling raylib for PLATFORM_WEB. All the other Desktop/Mobile/Embedded platforms are not affected.",
        "git_url": "https://github.com/raysan5/raylib/commit/b436c8d7e5346a241b00511a11585936895d959d",
        "commit_title": "ADDED: Security check for `emscripten_run_script()` #2954",
        "commit_text": "",
        "func_before": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}",
        "func": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    // Security check to (partially) avoid malicious code\n    if (strchr(text, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided Clipboard could be potentially malicious, avoid [\\'] character\");\n    else emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n     glfwSetClipboardString(CORE.Window.handle, text);\n #endif\n #if defined(PLATFORM_WEB)\n-    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n+    // Security check to (partially) avoid malicious code\n+    if (strchr(text, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided Clipboard could be potentially malicious, avoid [\\'] character\");\n+    else emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n #endif\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));"
            ],
            "added_lines": [
                "    // Security check to (partially) avoid malicious code",
                "    if (strchr(text, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided Clipboard could be potentially malicious, avoid [\\'] character\");",
                "    else emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26123",
        "func_name": "raysan5/raylib/TakeScreenshot",
        "description": "Versions of the package raysan5/raylib before 4.5.0 are vulnerable to Cross-site Scripting (XSS) such that the SetClipboardText API does not properly escape the ' character, allowing attacker-controlled input to break out of the string and execute arbitrary JavaScript via emscripten_run_script function.\r\r**Note:** This vulnerability is present only when compiling raylib for PLATFORM_WEB. All the other Desktop/Mobile/Embedded platforms are not affected.",
        "git_url": "https://github.com/raysan5/raylib/commit/b436c8d7e5346a241b00511a11585936895d959d",
        "commit_title": "ADDED: Security check for `emscripten_run_script()` #2954",
        "commit_text": "",
        "func_before": "void TakeScreenshot(const char *fileName)\n{\n#if defined(SUPPORT_MODULE_RTEXTURES)\n    Vector2 scale = GetWindowScaleDPI();\n    unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n    Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };\n\n    char path[2048] = { 0 };\n    strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));\n\n    ExportImage(image, path);           // WARNING: Module required: rtextures\n    RL_FREE(imgData);\n\n#if defined(PLATFORM_WEB)\n    // Download file from MEMFS (emscripten memory filesystem)\n    // saveFileFromMEMFSToDisk() function is defined in raylib/src/shell.html\n    emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", GetFileName(path), GetFileName(path)));\n#endif\n\n    TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);\n#else\n    TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");\n#endif\n}",
        "func": "void TakeScreenshot(const char *fileName)\n{\n#if defined(SUPPORT_MODULE_RTEXTURES)\n    // Security check to (partially) avoid malicious code on PLATFORM_WEB\n    if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }\n\n    Vector2 scale = GetWindowScaleDPI();\n    unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n    Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };\n\n    char path[2048] = { 0 };\n    strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));\n\n    ExportImage(image, path);           // WARNING: Module required: rtextures\n    RL_FREE(imgData);\n\n#if defined(PLATFORM_WEB)\n    // Download file from MEMFS (emscripten memory filesystem)\n    // saveFileFromMEMFSToDisk() function is defined in raylib/src/shell.html\n    emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", GetFileName(path), GetFileName(path)));\n#endif\n\n    TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);\n#else\n    TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n void TakeScreenshot(const char *fileName)\n {\n #if defined(SUPPORT_MODULE_RTEXTURES)\n+    // Security check to (partially) avoid malicious code on PLATFORM_WEB\n+    if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }\n+\n     Vector2 scale = GetWindowScaleDPI();\n     unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n     Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // Security check to (partially) avoid malicious code on PLATFORM_WEB",
                "    if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26123",
        "func_name": "raysan5/raylib/GetClipboardText",
        "description": "Versions of the package raysan5/raylib before 4.5.0 are vulnerable to Cross-site Scripting (XSS) such that the SetClipboardText API does not properly escape the ' character, allowing attacker-controlled input to break out of the string and execute arbitrary JavaScript via emscripten_run_script function.\r\r**Note:** This vulnerability is present only when compiling raylib for PLATFORM_WEB. All the other Desktop/Mobile/Embedded platforms are not affected.",
        "git_url": "https://github.com/raysan5/raylib/commit/b436c8d7e5346a241b00511a11585936895d959d",
        "commit_title": "ADDED: Security check for `emscripten_run_script()` #2954",
        "commit_text": "",
        "func_before": "const char *GetClipboardText(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return glfwGetClipboardString(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_WEB)\n    // Accessing clipboard data from browser is tricky due to security reasons\n    // The method to use is navigator.clipboard.readText() but this is an asynchronous method\n    // that will return at some moment after the function is called with the required data\n    emscripten_run_script_string(\"navigator.clipboard.readText() \\\n        .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\\n        .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"\n    );\n\n    // The main issue is getting that data, one approach could be using ASYNCIFY and wait\n    // for the data but it requires adding Asyncify emscripten library on compilation\n\n    // Another approach could be just copy the data in a HTML text field and try to retrieve it\n    // later on if available... and clean it for future accesses\n\n    return NULL;\n#endif\n    return NULL;\n}",
        "func": "const char *GetClipboardText(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return glfwGetClipboardString(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_WEB)\n/*\n    // Accessing clipboard data from browser is tricky due to security reasons\n    // The method to use is navigator.clipboard.readText() but this is an asynchronous method\n    // that will return at some moment after the function is called with the required data\n    emscripten_run_script_string(\"navigator.clipboard.readText() \\\n        .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\\n        .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"\n    );\n\n    // The main issue is getting that data, one approach could be using ASYNCIFY and wait\n    // for the data but it requires adding Asyncify emscripten library on compilation\n\n    // Another approach could be just copy the data in a HTML text field and try to retrieve it\n    // later on if available... and clean it for future accesses\n*/\n    return NULL;\n#endif\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n     return glfwGetClipboardString(CORE.Window.handle);\n #endif\n #if defined(PLATFORM_WEB)\n+/*\n     // Accessing clipboard data from browser is tricky due to security reasons\n     // The method to use is navigator.clipboard.readText() but this is an asynchronous method\n     // that will return at some moment after the function is called with the required data\n@@ -17,7 +18,7 @@\n \n     // Another approach could be just copy the data in a HTML text field and try to retrieve it\n     // later on if available... and clean it for future accesses\n-\n+*/\n     return NULL;\n #endif\n     return NULL;",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "/*",
                "*/"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-43523",
        "func_name": "wbx-github/uclibc-ng/__dns_lookup",
        "description": "In uClibc and uClibc-ng before 1.0.39, incorrect handling of special characters in domain names returned by DNS servers via gethostbyname, getaddrinfo, gethostbyaddr, and getnameinfo can lead to output of wrong hostnames (leading to domain hijacking) or injection into applications (leading to remote code execution, XSS, applications crashes, etc.). In other words, a validation step, which is expected in any stub resolver, does not occur.",
        "git_url": "https://github.com/wbx-github/uclibc-ng/commit/0f822af0445e5348ce7b7bd8ce1204244f31d174",
        "commit_title": "libc/inet/resolv.c: add __hnbad to check DNS entries for validity",
        "commit_text": "  using the same rules glibc does  also call __hnbad in some places to check answers",
        "func_before": "int __dns_lookup(const char *name,\n\t\tint type,\n\t\tunsigned char **outpacket,\n\t\tstruct resolv_answer *a)\n{\n\t/* Protected by __resolv_lock: */\n\tstatic int last_ns_num = 0;\n\tstatic uint16_t last_id = 1;\n\n\tint i, j, fd, rc;\n\tint packet_len;\n\tint name_len;\n#ifdef USE_SELECT\n\tstruct timeval tv;\n\tfd_set fds;\n#else\n\tstruct pollfd fds;\n#endif\n\tstruct resolv_header h;\n\tstruct resolv_question q;\n\tstruct resolv_answer ma;\n\tbool first_answer = 1;\n\tint retries_left;\n\tunsigned char *packet = malloc(PACKETSZ);\n\tchar *lookup;\n\tint variant = -1;  /* search domain to append, -1: none */\n\tint local_ns_num = -1; /* Nth server to use */\n\tint local_id = local_id; /* for compiler */\n\tint sdomains = 0;\n\tbool ends_with_dot;\n\tbool contains_dot;\n\tsockaddr46_t sa;\n\n\tfd = -1;\n\tlookup = NULL;\n\tname_len = strlen(name);\n\tif ((unsigned)name_len >= MAXDNAME - MAXLEN_searchdomain - 2)\n\t\tgoto fail; /* paranoia */\n\tlookup = malloc(name_len + 1/*for '.'*/ + MAXLEN_searchdomain + 1);\n\tif (!packet || !lookup || !name[0])\n\t\tgoto fail;\n\tends_with_dot = (name[name_len - 1] == '.');\n\tcontains_dot = strchr(name, '.') != NULL;\n\t/* no strcpy! paranoia, user might change name[] under us */\n\tmemcpy(lookup, name, name_len);\n\n\tDPRINTF(\"Looking up type %d answer for '%s'\\n\", type, name);\n\tretries_left = 0; /* for compiler */\n\tdo {\n\t\tunsigned act_variant;\n\t\tint pos;\n\t\tunsigned reply_timeout;\n\n\t\tif (fd != -1) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t}\n\n\t\t/* Mess with globals while under lock */\n\t\t/* NB: even data *pointed to* by globals may vanish\n\t\t * outside the locks. We should assume any and all\n\t\t * globals can completely change between locked\n\t\t * code regions. OTOH, this is rare, so we don't need\n\t\t * to handle it \"nicely\" (do not skip servers,\n\t\t * search domains, etc), we only need to ensure\n\t\t * we do not SEGV, use freed+overwritten data\n\t\t * or do other Really Bad Things. */\n\t\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t\t__open_nameservers();\n\t\tif (type != T_PTR) {\n\t\t\tsdomains = __searchdomains;\n\t\t}\n\t\tlookup[name_len] = '\\0';\n\t\t/* For qualified names, act_variant = MAX_UINT, 0, .., sdomains-1\n\t\t *  => Try original name first, then append search domains\n\t\t * For names without domain, act_variant = 0, 1, .., sdomains\n\t\t *  => Try search domains first, original name last */\n\t\tact_variant = contains_dot ? variant : variant + 1;\n\t\tif (act_variant < sdomains) {\n\t\t\t/* lookup is name_len + 1 + MAXLEN_searchdomain + 1 long */\n\t\t\t/* __searchdomain[] is not bigger than MAXLEN_searchdomain */\n\t\t\tlookup[name_len] = '.';\n\t\t\tstrcpy(&lookup[name_len + 1], __searchdomain[act_variant]);\n\t\t}\n\t\t/* first time? pick starting server etc */\n\t\tif (local_ns_num < 0) {\n\t\t\tlocal_id = last_id;\n/*TODO: implement /etc/resolv.conf's \"options rotate\"\n (a.k.a. RES_ROTATE bit in _res.options)\n\t\t\tlocal_ns_num = 0;\n\t\t\tif (_res.options & RES_ROTATE) */\n\t\t\t\tlocal_ns_num = last_ns_num;\n\t\t\tretries_left = __nameservers * __resolv_attempts;\n\t\t}\n\t\tif (local_ns_num >= __nameservers)\n\t\t\tlocal_ns_num = 0;\n\t\tlocal_id++;\n\t\tlocal_id &= 0xffff;\n\t\t/* write new values back while still under lock */\n\t\tlast_id = local_id;\n\t\tlast_ns_num = local_ns_num;\n\t\t/* struct copy */\n\t\t/* can't just take a pointer, __nameserver[x]\n\t\t * is not safe to use outside of locks */\n\t\tsa = __nameserver[local_ns_num];\n\t\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\n\t\tmemset(packet, 0, PACKETSZ);\n\t\tmemset(&h, 0, sizeof(h));\n\n\t\t/* encode header */\n\t\th.id = local_id;\n\t\th.qdcount = 1;\n\t\th.rd = 1;\n\t\tDPRINTF(\"encoding header\\n\", h.rd);\n\t\ti = __encode_header(&h, packet, PACKETSZ);\n\t\tif (i < 0)\n\t\t\tgoto fail;\n\n\t\t/* encode question */\n\t\tDPRINTF(\"lookup name: %s\\n\", lookup);\n\t\tq.dotted = lookup;\n\t\tq.qtype = type;\n\t\tq.qclass = C_IN; /* CLASS_IN */\n\t\tj = __encode_question(&q, packet+i, PACKETSZ-i);\n\t\tif (j < 0)\n\t\t\tgoto fail;\n\t\tpacket_len = i + j;\n\n\t\t/* send packet */\n#ifdef DEBUG\n\t\t{\n\t\t\tconst socklen_t plen = sa.sa.sa_family == AF_INET ? INET_ADDRSTRLEN : INET6_ADDRSTRLEN;\n\t\t\tchar *pbuf = malloc(plen);\n\t\t\tif (pbuf == NULL) ;/* nothing */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\telse if (sa.sa.sa_family == AF_INET6)\n\t\t\t\tpbuf = (char*)inet_ntop(AF_INET6, &sa.sa6.sin6_addr, pbuf, plen);\n#endif\n#ifdef __UCLIBC_HAS_IPV4__\n\t\t\telse if (sa.sa.sa_family == AF_INET)\n\t\t\t\tpbuf = (char*)inet_ntop(AF_INET, &sa.sa4.sin_addr, pbuf, plen);\n#endif\n\t\t\tDPRINTF(\"On try %d, sending query to %s, port %d\\n\",\n\t\t\t\tretries_left, pbuf, NAMESERVER_PORT);\n\t\t\tfree(pbuf);\n\t\t}\n#endif\n\t\tfd = socket(sa.sa.sa_family, SOCK_DGRAM, IPPROTO_UDP);\n\t\tif (fd < 0) /* paranoia */\n\t\t\tgoto try_next_server;\n\t\trc = connect(fd, &sa.sa, sizeof(sa));\n\t\tif (rc < 0) {\n\t\t\t/*if (errno == ENETUNREACH) { */\n\t\t\t\t/* routing error, presume not transient */\n\t\t\t\tgoto try_next_server;\n\t\t\t/*} */\n/*For example, what transient error this can be? Can't think of any */\n\t\t\t/* retry */\n\t\t\t/*continue; */\n\t\t}\n\t\tDPRINTF(\"Xmit packet len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\t/* no error check - if it fails, we time out on recv */\n\t\tsend(fd, packet, packet_len, 0);\n\n#ifdef USE_SELECT\n\t\treply_timeout = __resolv_timeout;\n wait_again:\n\t\tFD_ZERO(&fds);\n\t\tFD_SET(fd, &fds);\n\t\ttv.tv_sec = reply_timeout;\n\t\ttv.tv_usec = 0;\n\t\tif (select(fd + 1, &fds, NULL, NULL, &tv) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n\t\treply_timeout--;\n#else /* !USE_SELECT */\n\t\treply_timeout = __resolv_timeout * 1000;\n wait_again:\n\t\tfds.fd = fd;\n\t\tfds.events = POLLIN;\n\t\tif (poll(&fds, 1, reply_timeout) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n\t\tif (fds.revents & (POLLERR | POLLHUP | POLLNVAL)) {\n\t\t\tDPRINTF(\"Bad event\\n\");\n\t\t\tgoto try_next_server;\n\t\t}\n/*TODO: better timeout accounting?*/\n\t\treply_timeout -= 1000;\n#endif /* USE_SELECT */\n\n/* vda: a bogus response seen in real world (caused SEGV in uclibc):\n * \"ping www.google.com\" sending AAAA query and getting\n * response with one answer... with answer part missing!\n * Fixed by thorough checks for not going past the packet's end.\n */\n#ifdef DEBUG\n\t\t{\n\t\t\tstatic const char test_query[32] = \"\\0\\2\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tstatic const char test_respn[32] = \"\\0\\2\\201\\200\\0\\1\\0\\1\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tpos = memcmp(packet + 2, test_query + 2, 30);\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n\t\t\tif (pos == 0) {\n\t\t\t\tpacket_len = 32;\n\t\t\t\tmemcpy(packet + 2, test_respn + 2, 30);\n\t\t\t}\n\t\t}\n#else\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n#endif\n\n\t\tif (packet_len < HFIXEDSZ) {\n\t\t\t/* too short!\n\t\t\t * If the peer did shutdown then retry later,\n\t\t\t * try next peer on error.\n\t\t\t * it's just a bogus packet from somewhere */\n bogus_packet:\n\t\t\tif (packet_len >= 0 && reply_timeout)\n\t\t\t\tgoto wait_again;\n\t\t\tgoto try_next_server;\n\t\t}\n\t\t__decode_header(packet, &h);\n\t\tDPRINTF(\"len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\tif (h.id != local_id || !h.qr) {\n\t\t\t/* unsolicited */\n\t\t\tgoto bogus_packet;\n\t\t}\n\n\t\tDPRINTF(\"Got response (i think)!\\n\");\n\t\tDPRINTF(\"qrcount=%d,ancount=%d,nscount=%d,arcount=%d\\n\",\n\t\t\t\th.qdcount, h.ancount, h.nscount, h.arcount);\n\t\tDPRINTF(\"opcode=%d,aa=%d,tc=%d,rd=%d,ra=%d,rcode=%d\\n\",\n\t\t\t\th.opcode, h.aa, h.tc, h.rd, h.ra, h.rcode);\n\n\t\t/* bug 660 says we treat negative response as an error\n\t\t * and retry, which is, eh, an error. :)\n\t\t * We were incurring long delays because of this. */\n\t\tif (h.rcode == NXDOMAIN || h.rcode == SERVFAIL) {\n\t\t\t/* if possible, try next search domain */\n\t\t\tif (!ends_with_dot) {\n\t\t\t\tDPRINTF(\"variant:%d sdomains:%d\\n\", variant, sdomains);\n\t\t\t\tif (variant < sdomains - 1) {\n\t\t\t\t\t/* next search domain */\n\t\t\t\t\tvariant++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* no more search domains to try */\n\t\t\t}\n\t\t\tif (h.rcode != SERVFAIL) {\n\t\t\t\t/* dont loop, this is \"no such host\" situation */\n\t\t\t\th_errno = HOST_NOT_FOUND;\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t/* Insert other non-fatal errors here, which do not warrant\n\t\t * switching to next nameserver */\n\n\t\t/* Strange error, assuming this nameserver is feeling bad */\n\t\tif (h.rcode != 0)\n\t\t\tgoto try_next_server;\n\n\t\t/* Code below won't work correctly with h.ancount == 0, so... */\n\t\tif (h.ancount <= 0) {\n\t\t\th_errno = NO_DATA; /* [is this correct code to check for?] */\n\t\t\tgoto fail1;\n\t\t}\n\t\tpos = HFIXEDSZ;\n\t\tfor (j = 0; j < h.qdcount; j++) {\n\t\t\tDPRINTF(\"Skipping question %d at %d\\n\", j, pos);\n\t\t\ti = __length_question(packet + pos, packet_len - pos);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"Packet'question section \"\n\t\t\t\t\t\"is truncated, trying next server\\n\");\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\t\t\tDPRINTF(\"Length of question %d is %d\\n\", j, i);\n\t\t}\n\t\tDPRINTF(\"Decoding answer at pos %d\\n\", pos);\n\n\t\tfirst_answer = 1;\n\t\ta->dotted = NULL;\n\t\tfor (j = 0; j < h.ancount; j++) {\n\t\t\ti = __decode_answer(packet, pos, packet_len, &ma);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"failed decode %d\\n\", i);\n\t\t\t\t/* If the message was truncated but we have\n\t\t\t\t * decoded some answers, pretend it's OK */\n\t\t\t\tif (j && h.tc)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\n\t\t\tif (first_answer) {\n\t\t\t\tma.buf = a->buf;\n\t\t\t\tma.buflen = a->buflen;\n\t\t\t\tma.add_count = a->add_count;\n\t\t\t\tfree(a->dotted);\n\t\t\t\tmemcpy(a, &ma, sizeof(ma));\n\t\t\t\tif (a->atype != T_SIG && (NULL == a->buf || (type != T_A && type != T_AAAA)))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a->atype != type)\n\t\t\t\t\tcontinue;\n\t\t\t\ta->add_count = h.ancount - j - 1;\n\t\t\t\tif ((a->rdlength + sizeof(struct in_addr*)) * a->add_count > a->buflen)\n\t\t\t\t\tbreak;\n\t\t\t\ta->add_count = 0;\n\t\t\t\tfirst_answer = 0;\n\t\t\t} else {\n\t\t\t\tfree(ma.dotted);\n\t\t\t\tif (ma.atype != type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (a->rdlength != ma.rdlength) {\n\t\t\t\t\tfree(a->dotted);\n\t\t\t\t\tDPRINTF(\"Answer address len(%u) differs from original(%u)\\n\",\n\t\t\t\t\t\t\tma.rdlength, a->rdlength);\n\t\t\t\t\tgoto try_next_server;\n\t\t\t\t}\n\t\t\t\tmemcpy(a->buf + (a->add_count * ma.rdlength), ma.rdata, ma.rdlength);\n\t\t\t\t++a->add_count;\n\t\t\t}\n\t\t}\n\n\t\t/* Success! */\n\t\tDPRINTF(\"Answer name = |%s|\\n\", a->dotted);\n\t\tDPRINTF(\"Answer type = |%d|\\n\", a->atype);\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tif (outpacket)\n\t\t\t*outpacket = packet;\n\t\telse\n\t\t\tfree(packet);\n\t\tfree(lookup);\n\t\treturn packet_len;\n\n try_next_server:\n\t\t/* Try next nameserver */\n\t\tretries_left--;\n\t\tlocal_ns_num++;\n\t\tvariant = -1;\n\t} while (retries_left > 0);\n\n fail:\n\th_errno = NETDB_INTERNAL;\n fail1:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(lookup);\n\tfree(packet);\n\treturn -1;\n}",
        "func": "int __dns_lookup(const char *name,\n\t\tint type,\n\t\tunsigned char **outpacket,\n\t\tstruct resolv_answer *a)\n{\n\t/* Protected by __resolv_lock: */\n\tstatic int last_ns_num = 0;\n\tstatic uint16_t last_id = 1;\n\n\tint i, j, fd, rc;\n\tint packet_len;\n\tint name_len;\n#ifdef USE_SELECT\n\tstruct timeval tv;\n\tfd_set fds;\n#else\n\tstruct pollfd fds;\n#endif\n\tstruct resolv_header h;\n\tstruct resolv_question q;\n\tstruct resolv_answer ma;\n\tbool first_answer = 1;\n\tint retries_left;\n\tunsigned char *packet = malloc(PACKETSZ);\n\tchar *lookup;\n\tint variant = -1;  /* search domain to append, -1: none */\n\tint local_ns_num = -1; /* Nth server to use */\n\tint local_id = local_id; /* for compiler */\n\tint sdomains = 0;\n\tbool ends_with_dot;\n\tbool contains_dot;\n\tsockaddr46_t sa;\n\tint num_answers;\n\n\tfd = -1;\n\tlookup = NULL;\n\tname_len = strlen(name);\n\tif ((unsigned)name_len >= MAXDNAME - MAXLEN_searchdomain - 2)\n\t\tgoto fail; /* paranoia */\n\tlookup = malloc(name_len + 1/*for '.'*/ + MAXLEN_searchdomain + 1);\n\tif (!packet || !lookup || !name[0])\n\t\tgoto fail;\n\tends_with_dot = (name[name_len - 1] == '.');\n\tcontains_dot = strchr(name, '.') != NULL;\n\t/* no strcpy! paranoia, user might change name[] under us */\n\tmemcpy(lookup, name, name_len);\n\n\tDPRINTF(\"Looking up type %d answer for '%s'\\n\", type, name);\n\tretries_left = 0; /* for compiler */\n\tdo {\n\t\tunsigned act_variant;\n\t\tint pos;\n\t\tunsigned reply_timeout;\n\n\t\tif (fd != -1) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t}\n\n\t\t/* Mess with globals while under lock */\n\t\t/* NB: even data *pointed to* by globals may vanish\n\t\t * outside the locks. We should assume any and all\n\t\t * globals can completely change between locked\n\t\t * code regions. OTOH, this is rare, so we don't need\n\t\t * to handle it \"nicely\" (do not skip servers,\n\t\t * search domains, etc), we only need to ensure\n\t\t * we do not SEGV, use freed+overwritten data\n\t\t * or do other Really Bad Things. */\n\t\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t\t__open_nameservers();\n\t\tif (type != T_PTR) {\n\t\t\tsdomains = __searchdomains;\n\t\t}\n\t\tlookup[name_len] = '\\0';\n\t\t/* For qualified names, act_variant = MAX_UINT, 0, .., sdomains-1\n\t\t *  => Try original name first, then append search domains\n\t\t * For names without domain, act_variant = 0, 1, .., sdomains\n\t\t *  => Try search domains first, original name last */\n\t\tact_variant = contains_dot ? variant : variant + 1;\n\t\tif (act_variant < sdomains) {\n\t\t\t/* lookup is name_len + 1 + MAXLEN_searchdomain + 1 long */\n\t\t\t/* __searchdomain[] is not bigger than MAXLEN_searchdomain */\n\t\t\tlookup[name_len] = '.';\n\t\t\tstrcpy(&lookup[name_len + 1], __searchdomain[act_variant]);\n\t\t}\n\t\t/* first time? pick starting server etc */\n\t\tif (local_ns_num < 0) {\n\t\t\tlocal_id = last_id;\n/*TODO: implement /etc/resolv.conf's \"options rotate\"\n (a.k.a. RES_ROTATE bit in _res.options)\n\t\t\tlocal_ns_num = 0;\n\t\t\tif (_res.options & RES_ROTATE) */\n\t\t\t\tlocal_ns_num = last_ns_num;\n\t\t\tretries_left = __nameservers * __resolv_attempts;\n\t\t}\n\t\tif (local_ns_num >= __nameservers)\n\t\t\tlocal_ns_num = 0;\n\t\tlocal_id++;\n\t\tlocal_id &= 0xffff;\n\t\t/* write new values back while still under lock */\n\t\tlast_id = local_id;\n\t\tlast_ns_num = local_ns_num;\n\t\t/* struct copy */\n\t\t/* can't just take a pointer, __nameserver[x]\n\t\t * is not safe to use outside of locks */\n\t\tsa = __nameserver[local_ns_num];\n\t\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\n\t\tmemset(packet, 0, PACKETSZ);\n\t\tmemset(&h, 0, sizeof(h));\n\n\t\t/* encode header */\n\t\th.id = local_id;\n\t\th.qdcount = 1;\n\t\th.rd = 1;\n\t\tDPRINTF(\"encoding header\\n\", h.rd);\n\t\ti = __encode_header(&h, packet, PACKETSZ);\n\t\tif (i < 0)\n\t\t\tgoto fail;\n\n\t\t/* encode question */\n\t\tDPRINTF(\"lookup name: %s\\n\", lookup);\n\t\tq.dotted = lookup;\n\t\tq.qtype = type;\n\t\tq.qclass = C_IN; /* CLASS_IN */\n\t\tj = __encode_question(&q, packet+i, PACKETSZ-i);\n\t\tif (j < 0)\n\t\t\tgoto fail;\n\t\tpacket_len = i + j;\n\n\t\t/* send packet */\n#ifdef DEBUG\n\t\t{\n\t\t\tconst socklen_t plen = sa.sa.sa_family == AF_INET ? INET_ADDRSTRLEN : INET6_ADDRSTRLEN;\n\t\t\tchar *pbuf = malloc(plen);\n\t\t\tif (pbuf == NULL) ;/* nothing */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\telse if (sa.sa.sa_family == AF_INET6)\n\t\t\t\tpbuf = (char*)inet_ntop(AF_INET6, &sa.sa6.sin6_addr, pbuf, plen);\n#endif\n#ifdef __UCLIBC_HAS_IPV4__\n\t\t\telse if (sa.sa.sa_family == AF_INET)\n\t\t\t\tpbuf = (char*)inet_ntop(AF_INET, &sa.sa4.sin_addr, pbuf, plen);\n#endif\n\t\t\tDPRINTF(\"On try %d, sending query to %s, port %d\\n\",\n\t\t\t\tretries_left, pbuf, NAMESERVER_PORT);\n\t\t\tfree(pbuf);\n\t\t}\n#endif\n\t\tfd = socket(sa.sa.sa_family, SOCK_DGRAM, IPPROTO_UDP);\n\t\tif (fd < 0) /* paranoia */\n\t\t\tgoto try_next_server;\n\t\trc = connect(fd, &sa.sa, sizeof(sa));\n\t\tif (rc < 0) {\n\t\t\t/*if (errno == ENETUNREACH) { */\n\t\t\t\t/* routing error, presume not transient */\n\t\t\t\tgoto try_next_server;\n\t\t\t/*} */\n/*For example, what transient error this can be? Can't think of any */\n\t\t\t/* retry */\n\t\t\t/*continue; */\n\t\t}\n\t\tDPRINTF(\"Xmit packet len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\t/* no error check - if it fails, we time out on recv */\n\t\tsend(fd, packet, packet_len, 0);\n\n#ifdef USE_SELECT\n\t\treply_timeout = __resolv_timeout;\n wait_again:\n\t\tFD_ZERO(&fds);\n\t\tFD_SET(fd, &fds);\n\t\ttv.tv_sec = reply_timeout;\n\t\ttv.tv_usec = 0;\n\t\tif (select(fd + 1, &fds, NULL, NULL, &tv) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n\t\treply_timeout--;\n#else /* !USE_SELECT */\n\t\treply_timeout = __resolv_timeout * 1000;\n wait_again:\n\t\tfds.fd = fd;\n\t\tfds.events = POLLIN;\n\t\tif (poll(&fds, 1, reply_timeout) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n\t\tif (fds.revents & (POLLERR | POLLHUP | POLLNVAL)) {\n\t\t\tDPRINTF(\"Bad event\\n\");\n\t\t\tgoto try_next_server;\n\t\t}\n/*TODO: better timeout accounting?*/\n\t\treply_timeout -= 1000;\n#endif /* USE_SELECT */\n\n/* vda: a bogus response seen in real world (caused SEGV in uclibc):\n * \"ping www.google.com\" sending AAAA query and getting\n * response with one answer... with answer part missing!\n * Fixed by thorough checks for not going past the packet's end.\n */\n#ifdef DEBUG\n\t\t{\n\t\t\tstatic const char test_query[32] = \"\\0\\2\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tstatic const char test_respn[32] = \"\\0\\2\\201\\200\\0\\1\\0\\1\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tpos = memcmp(packet + 2, test_query + 2, 30);\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n\t\t\tif (pos == 0) {\n\t\t\t\tpacket_len = 32;\n\t\t\t\tmemcpy(packet + 2, test_respn + 2, 30);\n\t\t\t}\n\t\t}\n#else\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n#endif\n\n\t\tif (packet_len < HFIXEDSZ) {\n\t\t\t/* too short!\n\t\t\t * If the peer did shutdown then retry later,\n\t\t\t * try next peer on error.\n\t\t\t * it's just a bogus packet from somewhere */\n bogus_packet:\n\t\t\tif (packet_len >= 0 && reply_timeout)\n\t\t\t\tgoto wait_again;\n\t\t\tgoto try_next_server;\n\t\t}\n\t\t__decode_header(packet, &h);\n\t\tDPRINTF(\"len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\tif (h.id != local_id || !h.qr) {\n\t\t\t/* unsolicited */\n\t\t\tgoto bogus_packet;\n\t\t}\n\n\t\tDPRINTF(\"Got response (i think)!\\n\");\n\t\tDPRINTF(\"qrcount=%d,ancount=%d,nscount=%d,arcount=%d\\n\",\n\t\t\t\th.qdcount, h.ancount, h.nscount, h.arcount);\n\t\tDPRINTF(\"opcode=%d,aa=%d,tc=%d,rd=%d,ra=%d,rcode=%d\\n\",\n\t\t\t\th.opcode, h.aa, h.tc, h.rd, h.ra, h.rcode);\n\n\t\t/* bug 660 says we treat negative response as an error\n\t\t * and retry, which is, eh, an error. :)\n\t\t * We were incurring long delays because of this. */\n\t\tif (h.rcode == NXDOMAIN || h.rcode == SERVFAIL) {\n\t\t\t/* if possible, try next search domain */\n\t\t\tif (!ends_with_dot) {\n\t\t\t\tDPRINTF(\"variant:%d sdomains:%d\\n\", variant, sdomains);\n\t\t\t\tif (variant < sdomains - 1) {\n\t\t\t\t\t/* next search domain */\n\t\t\t\t\tvariant++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* no more search domains to try */\n\t\t\t}\n\t\t\tif (h.rcode != SERVFAIL) {\n\t\t\t\t/* dont loop, this is \"no such host\" situation */\n\t\t\t\th_errno = HOST_NOT_FOUND;\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t/* Insert other non-fatal errors here, which do not warrant\n\t\t * switching to next nameserver */\n\n\t\t/* Strange error, assuming this nameserver is feeling bad */\n\t\tif (h.rcode != 0)\n\t\t\tgoto try_next_server;\n\n\t\t/* Code below won't work correctly with h.ancount == 0, so... */\n\t\tif (h.ancount <= 0) {\n\t\t\th_errno = NO_DATA; /* [is this correct code to check for?] */\n\t\t\tgoto fail1;\n\t\t}\n\t\tpos = HFIXEDSZ;\n\t\t/*XXX TODO: check that question matches query (and qdcount==1?) */\n\t\tfor (j = 0; j < h.qdcount; j++) {\n\t\t\tDPRINTF(\"Skipping question %d at %d\\n\", j, pos);\n\t\t\ti = __length_question(packet + pos, packet_len - pos);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"Packet'question section \"\n\t\t\t\t\t\"is truncated, trying next server\\n\");\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\t\t\tDPRINTF(\"Length of question %d is %d\\n\", j, i);\n\t\t}\n\t\tDPRINTF(\"Decoding answer at pos %d\\n\", pos);\n\n\t\tfirst_answer = 1;\n\t\tnum_answers = 0;\n\t\ta->dotted = NULL;\n\t\tfor (j = 0; j < h.ancount; j++) {\n\t\t\ti = __decode_answer(packet, pos, packet_len, &ma);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"failed decode %d\\n\", i);\n\t\t\t\t/* If the message was truncated but we have\n\t\t\t\t * decoded some answers, pretend it's OK */\n\t\t\t\tif (num_answers && h.tc)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\n\t\t\tif (__hnbad(ma.dotted))\n\t\t\t\tbreak;\n\t\t\t++num_answers;\n\t\t\tif (first_answer) {\n\t\t\t\tma.buf = a->buf;\n\t\t\t\tma.buflen = a->buflen;\n\t\t\t\tma.add_count = a->add_count;\n\t\t\t\tfree(a->dotted);\n\t\t\t\tmemcpy(a, &ma, sizeof(ma));\n\t\t\t\tif (a->atype != T_SIG && (NULL == a->buf || (type != T_A && type != T_AAAA)))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a->atype != type)\n\t\t\t\t\tcontinue;\n\t\t\t\ta->add_count = h.ancount - j - 1;\n\t\t\t\tif ((a->rdlength + sizeof(struct in_addr*)) * a->add_count > a->buflen)\n\t\t\t\t\tbreak;\n\t\t\t\ta->add_count = 0;\n\t\t\t\tfirst_answer = 0;\n\t\t\t} else {\n\t\t\t\tfree(ma.dotted);\n\t\t\t\tif (ma.atype != type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (a->rdlength != ma.rdlength) {\n\t\t\t\t\tfree(a->dotted);\n\t\t\t\t\tDPRINTF(\"Answer address len(%u) differs from original(%u)\\n\",\n\t\t\t\t\t\t\tma.rdlength, a->rdlength);\n\t\t\t\t\tgoto try_next_server;\n\t\t\t\t}\n\t\t\t\tmemcpy(a->buf + (a->add_count * ma.rdlength), ma.rdata, ma.rdlength);\n\t\t\t\t++a->add_count;\n\t\t\t}\n\t\t}\n\t\tif (!num_answers) {\n\t\t\th_errno = NO_RECOVERY;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\t/* Success! */\n\t\tDPRINTF(\"Answer name = |%s|\\n\", a->dotted);\n\t\tDPRINTF(\"Answer type = |%d|\\n\", a->atype);\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tif (outpacket)\n\t\t\t*outpacket = packet;\n\t\telse\n\t\t\tfree(packet);\n\t\tfree(lookup);\n\t\treturn packet_len;\n\n try_next_server:\n\t\t/* Try next nameserver */\n\t\tretries_left--;\n\t\tlocal_ns_num++;\n\t\tvariant = -1;\n\t} while (retries_left > 0);\n\n fail:\n\th_errno = NETDB_INTERNAL;\n fail1:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(lookup);\n\tfree(packet);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,7 @@\n \tbool ends_with_dot;\n \tbool contains_dot;\n \tsockaddr46_t sa;\n+\tint num_answers;\n \n \tfd = -1;\n \tlookup = NULL;\n@@ -272,6 +273,7 @@\n \t\t\tgoto fail1;\n \t\t}\n \t\tpos = HFIXEDSZ;\n+\t\t/*XXX TODO: check that question matches query (and qdcount==1?) */\n \t\tfor (j = 0; j < h.qdcount; j++) {\n \t\t\tDPRINTF(\"Skipping question %d at %d\\n\", j, pos);\n \t\t\ti = __length_question(packet + pos, packet_len - pos);\n@@ -286,6 +288,7 @@\n \t\tDPRINTF(\"Decoding answer at pos %d\\n\", pos);\n \n \t\tfirst_answer = 1;\n+\t\tnum_answers = 0;\n \t\ta->dotted = NULL;\n \t\tfor (j = 0; j < h.ancount; j++) {\n \t\t\ti = __decode_answer(packet, pos, packet_len, &ma);\n@@ -293,12 +296,15 @@\n \t\t\t\tDPRINTF(\"failed decode %d\\n\", i);\n \t\t\t\t/* If the message was truncated but we have\n \t\t\t\t * decoded some answers, pretend it's OK */\n-\t\t\t\tif (j && h.tc)\n+\t\t\t\tif (num_answers && h.tc)\n \t\t\t\t\tbreak;\n \t\t\t\tgoto try_next_server;\n \t\t\t}\n \t\t\tpos += i;\n \n+\t\t\tif (__hnbad(ma.dotted))\n+\t\t\t\tbreak;\n+\t\t\t++num_answers;\n \t\t\tif (first_answer) {\n \t\t\t\tma.buf = a->buf;\n \t\t\t\tma.buflen = a->buflen;\n@@ -328,6 +334,10 @@\n \t\t\t\t++a->add_count;\n \t\t\t}\n \t\t}\n+\t\tif (!num_answers) {\n+\t\t\th_errno = NO_RECOVERY;\n+\t\t\tgoto fail1;\n+\t\t}\n \n \t\t/* Success! */\n \t\tDPRINTF(\"Answer name = |%s|\\n\", a->dotted);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tif (j && h.tc)"
            ],
            "added_lines": [
                "\tint num_answers;",
                "\t\t/*XXX TODO: check that question matches query (and qdcount==1?) */",
                "\t\tnum_answers = 0;",
                "\t\t\t\tif (num_answers && h.tc)",
                "\t\t\tif (__hnbad(ma.dotted))",
                "\t\t\t\tbreak;",
                "\t\t\t++num_answers;",
                "\t\tif (!num_answers) {",
                "\t\t\th_errno = NO_RECOVERY;",
                "\t\t\tgoto fail1;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-43523",
        "func_name": "wbx-github/uclibc-ng/gethostbyaddr_r",
        "description": "In uClibc and uClibc-ng before 1.0.39, incorrect handling of special characters in domain names returned by DNS servers via gethostbyname, getaddrinfo, gethostbyaddr, and getnameinfo can lead to output of wrong hostnames (leading to domain hijacking) or injection into applications (leading to remote code execution, XSS, applications crashes, etc.). In other words, a validation step, which is expected in any stub resolver, does not occur.",
        "git_url": "https://github.com/wbx-github/uclibc-ng/commit/0f822af0445e5348ce7b7bd8ce1204244f31d174",
        "commit_title": "libc/inet/resolv.c: add __hnbad to check DNS entries for validity",
        "commit_text": "  using the same rules glibc does  also call __hnbad in some places to check answers",
        "func_before": "libc_hidden_def(gethostbyname2_r)\n#endif /* L_gethostbyname2_r */\n\n\n#ifdef L_gethostbyaddr_r\n\nint gethostbyaddr_r(const void *addr, socklen_t addrlen,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf, size_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n\n{\n\tstruct in_addr *in;\n\tstruct in_addr **addr_list;\n\tchar **alias;\n\tunsigned char *packet;\n\tstruct resolv_answer a;\n\tint i;\n\tint packet_len;\n\tint nest = 0;\n\n\t*result = NULL;\n\tif (!addr)\n\t\treturn EINVAL;\n\n\tswitch (type) {\n#ifdef __UCLIBC_HAS_IPV4__\n\t\tcase AF_INET:\n\t\t\tif (addrlen != sizeof(struct in_addr))\n\t\t\t\treturn EINVAL;\n\t\t\tbreak;\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tcase AF_INET6:\n\t\t\tif (addrlen != sizeof(struct in6_addr))\n\t\t\t\treturn EINVAL;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t}\n\n\t/* do /etc/hosts first */\n\ti = __get_hosts_byaddr_r(addr, addrlen, type, result_buf,\n\t\t\t\tbuf, buflen, result, h_errnop);\n\tif (i == 0)\n\t\treturn i;\n\tswitch (*h_errnop) {\n\t\tcase HOST_NOT_FOUND:\n\t\tcase NO_ADDRESS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn i;\n\t}\n\n\t*h_errnop = NETDB_INTERNAL;\n\n\t/* make sure pointer is aligned */\n\ti = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\t/* Layout in buf:\n\t * char *alias[ALIAS_DIM];\n\t * struct in[6]_addr* addr_list[2];\n\t * struct in[6]_addr in;\n\t * char scratch_buffer[256+];\n\t */\n#define in6 ((struct in6_addr *)in)\n\talias = (char **)buf;\n\taddr_list = (struct in_addr**)buf;\n\tbuf += sizeof(*addr_list) * 2;\n\tbuflen -= sizeof(*addr_list) * 2;\n\tin = (struct in_addr*)buf;\n#ifndef __UCLIBC_HAS_IPV6__\n\tbuf += sizeof(*in);\n\tbuflen -= sizeof(*in);\n\tif (addrlen > sizeof(*in))\n\t\treturn ERANGE;\n#else\n\tbuf += sizeof(*in6);\n\tbuflen -= sizeof(*in6);\n\tif (addrlen > sizeof(*in6))\n\t\treturn ERANGE;\n#endif\n\tif ((ssize_t)buflen < 256)\n\t\treturn ERANGE;\n\talias[0] = buf;\n\talias[1] = NULL;\n\taddr_list[0] = in;\n\taddr_list[1] = NULL;\n\tmemcpy(in, addr, addrlen);\n\n\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV4__\n\telse IF_HAS_BOTH(if (type == AF_INET)) {\n\t\tunsigned char *tp = (unsigned char *)addr;\n\t\tsprintf(buf, \"%u.%u.%u.%u.in-addr.arpa\",\n\t\t\t\ttp[3], tp[2], tp[1], tp[0]);\n\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\telse {\n\t\tchar *dst = buf;\n\t\tunsigned char *tp = (unsigned char *)addr + addrlen - 1;\n\t\tdo {\n\t\t\tdst += sprintf(dst, \"%x.%x.\", tp[0] & 0xf, tp[0] >> 4);\n\t\t\ttp--;\n\t\t} while (tp >= (unsigned char *)addr);\n\t\tstrcpy(dst, \"ip6.arpa\");\n\t}\n#endif\n\n\tmemset(&a, '\\0', sizeof(a));\n\tfor (;;) {\n/* Hmm why we memset(a) to zeros only once? */\n\t\tpacket_len = __dns_lookup(buf, T_PTR, &packet, &a);\n\t\tif (packet_len < 0) {\n\t\t\t*h_errnop = HOST_NOT_FOUND;\n\t\t\treturn TRY_AGAIN;\n\t\t}\n\n\t\tstrncpy(buf, a.dotted, buflen);\n\t\tfree(a.dotted);\n\t\tif (a.atype != T_CNAME)\n\t\t\tbreak;\n\n\t\tDPRINTF(\"Got a CNAME in gethostbyaddr()\\n\");\n\t\tif (++nest > MAX_RECURSE) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\t/* Decode CNAME into buf, feed it to __dns_lookup() again */\n\t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n\t\tfree(packet);\n\t\tif (i < 0) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (a.atype == T_PTR) {\t/* ADDRESS */\n\t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n\t\tfree(packet);\n\t\tresult_buf->h_name = buf;\n\t\tresult_buf->h_addrtype = type;\n\t\tresult_buf->h_length = addrlen;\n\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\tresult_buf->h_aliases = alias;\n\t\t*result = result_buf;\n\t\t*h_errnop = NETDB_SUCCESS;\n\t\treturn NETDB_SUCCESS;\n\t}\n\n\tfree(packet);\n\t*h_errnop = NO_ADDRESS;\n\treturn TRY_AGAIN;\n#undef in6\n}",
        "func": "libc_hidden_def(gethostbyname2_r)\n#endif /* L_gethostbyname2_r */\n\n\n#ifdef L_gethostbyaddr_r\n\nint gethostbyaddr_r(const void *addr, socklen_t addrlen,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf, size_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n\n{\n\tstruct in_addr *in;\n\tstruct in_addr **addr_list;\n\tchar **alias;\n\tunsigned char *packet;\n\tstruct resolv_answer a;\n\tint i;\n\tint packet_len;\n\tint nest = 0;\n\n\t*result = NULL;\n\tif (!addr)\n\t\treturn EINVAL;\n\n\tswitch (type) {\n#ifdef __UCLIBC_HAS_IPV4__\n\t\tcase AF_INET:\n\t\t\tif (addrlen != sizeof(struct in_addr))\n\t\t\t\treturn EINVAL;\n\t\t\tbreak;\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tcase AF_INET6:\n\t\t\tif (addrlen != sizeof(struct in6_addr))\n\t\t\t\treturn EINVAL;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t}\n\n\t/* do /etc/hosts first */\n\ti = __get_hosts_byaddr_r(addr, addrlen, type, result_buf,\n\t\t\t\tbuf, buflen, result, h_errnop);\n\tif (i == 0)\n\t\treturn i;\n\tswitch (*h_errnop) {\n\t\tcase HOST_NOT_FOUND:\n\t\tcase NO_ADDRESS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn i;\n\t}\n\n\t*h_errnop = NETDB_INTERNAL;\n\n\t/* make sure pointer is aligned */\n\ti = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\t/* Layout in buf:\n\t * char *alias[ALIAS_DIM];\n\t * struct in[6]_addr* addr_list[2];\n\t * struct in[6]_addr in;\n\t * char scratch_buffer[256+];\n\t */\n#define in6 ((struct in6_addr *)in)\n\talias = (char **)buf;\n\taddr_list = (struct in_addr**)buf;\n\tbuf += sizeof(*addr_list) * 2;\n\tbuflen -= sizeof(*addr_list) * 2;\n\tin = (struct in_addr*)buf;\n#ifndef __UCLIBC_HAS_IPV6__\n\tbuf += sizeof(*in);\n\tbuflen -= sizeof(*in);\n\tif (addrlen > sizeof(*in))\n\t\treturn ERANGE;\n#else\n\tbuf += sizeof(*in6);\n\tbuflen -= sizeof(*in6);\n\tif (addrlen > sizeof(*in6))\n\t\treturn ERANGE;\n#endif\n\tif ((ssize_t)buflen < 256)\n\t\treturn ERANGE;\n\talias[0] = buf;\n\talias[1] = NULL;\n\taddr_list[0] = in;\n\taddr_list[1] = NULL;\n\tmemcpy(in, addr, addrlen);\n\n\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV4__\n\telse IF_HAS_BOTH(if (type == AF_INET)) {\n\t\tunsigned char *tp = (unsigned char *)addr;\n\t\tsprintf(buf, \"%u.%u.%u.%u.in-addr.arpa\",\n\t\t\t\ttp[3], tp[2], tp[1], tp[0]);\n\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\telse {\n\t\tchar *dst = buf;\n\t\tunsigned char *tp = (unsigned char *)addr + addrlen - 1;\n\t\tdo {\n\t\t\tdst += sprintf(dst, \"%x.%x.\", tp[0] & 0xf, tp[0] >> 4);\n\t\t\ttp--;\n\t\t} while (tp >= (unsigned char *)addr);\n\t\tstrcpy(dst, \"ip6.arpa\");\n\t}\n#endif\n\n\tmemset(&a, '\\0', sizeof(a));\n\tfor (;;) {\n/* Hmm why we memset(a) to zeros only once? */\n\t\tpacket_len = __dns_lookup(buf, T_PTR, &packet, &a);\n\t\tif (packet_len < 0) {\n\t\t\t*h_errnop = HOST_NOT_FOUND;\n\t\t\treturn TRY_AGAIN;\n\t\t}\n\n\t\tstrncpy(buf, a.dotted, buflen);\n\t\tfree(a.dotted);\n\t\tif (a.atype != T_CNAME)\n\t\t\tbreak;\n\n\t\tDPRINTF(\"Got a CNAME in gethostbyaddr()\\n\");\n\t\tif (++nest > MAX_RECURSE) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\t/* Decode CNAME into buf, feed it to __dns_lookup() again */\n\t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n\t\tfree(packet);\n\t\tif (i < 0 || __hnbad(buf)) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (a.atype == T_PTR) {\t/* ADDRESS */\n\t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n\t\tfree(packet);\n\t\tif (__hnbad(buf)) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\tresult_buf->h_name = buf;\n\t\tresult_buf->h_addrtype = type;\n\t\tresult_buf->h_length = addrlen;\n\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\tresult_buf->h_aliases = alias;\n\t\t*result = result_buf;\n\t\t*h_errnop = NETDB_SUCCESS;\n\t\treturn NETDB_SUCCESS;\n\t}\n\n\tfree(packet);\n\t*h_errnop = NO_ADDRESS;\n\treturn TRY_AGAIN;\n#undef in6\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -134,7 +134,7 @@\n \t\t/* Decode CNAME into buf, feed it to __dns_lookup() again */\n \t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n \t\tfree(packet);\n-\t\tif (i < 0) {\n+\t\tif (i < 0 || __hnbad(buf)) {\n \t\t\t*h_errnop = NO_RECOVERY;\n \t\t\treturn -1;\n \t\t}\n@@ -143,6 +143,10 @@\n \tif (a.atype == T_PTR) {\t/* ADDRESS */\n \t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n \t\tfree(packet);\n+\t\tif (__hnbad(buf)) {\n+\t\t\t*h_errnop = NO_RECOVERY;\n+\t\t\treturn -1;\n+\t\t}\n \t\tresult_buf->h_name = buf;\n \t\tresult_buf->h_addrtype = type;\n \t\tresult_buf->h_length = addrlen;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (i < 0) {"
            ],
            "added_lines": [
                "\t\tif (i < 0 || __hnbad(buf)) {",
                "\t\tif (__hnbad(buf)) {",
                "\t\t\t*h_errnop = NO_RECOVERY;",
                "\t\t\treturn -1;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-43523",
        "func_name": "wbx-github/uclibc-ng/ns_name_unpack",
        "description": "In uClibc and uClibc-ng before 1.0.39, incorrect handling of special characters in domain names returned by DNS servers via gethostbyname, getaddrinfo, gethostbyaddr, and getnameinfo can lead to output of wrong hostnames (leading to domain hijacking) or injection into applications (leading to remote code execution, XSS, applications crashes, etc.). In other words, a validation step, which is expected in any stub resolver, does not occur.",
        "git_url": "https://github.com/wbx-github/uclibc-ng/commit/0f822af0445e5348ce7b7bd8ce1204244f31d174",
        "commit_title": "libc/inet/resolv.c: add __hnbad to check DNS entries for validity",
        "commit_text": "  using the same rules glibc does  also call __hnbad in some places to check answers",
        "func_before": "libc_hidden_def(ns_name_pton)\n\n/*\n * ns_name_unpack(msg, eom, src, dst, dstsiz)\n *      Unpack a domain name from a message, source may be compressed.\n * return:\n *      -1 if it fails, or consumed octets if it succeeds.\n */\nint ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,\n               u_char *dst, size_t dstsiz)\n{\n\tconst u_char *srcp, *dstlim;\n\tu_char *dstp;\n\tint n, len, checked;\n\n\tlen = -1;\n\tchecked = 0;\n\tdstp = dst;\n\tsrcp = src;\n\tdstlim = dst + dstsiz;\n\tif (srcp < msg || srcp >= eom) {\n\t\t__set_errno(EMSGSIZE);\n\t\treturn -1;\n\t}\n\t/* Fetch next label in domain name. */\n\twhile ((n = *srcp++) != 0) {\n\t\t/* Check for indirection. */\n\t\tswitch (n & NS_CMPRSFLGS) {\n\t\t\tcase 0:\n\t\t\t\t/* Limit checks. */\n\t\t\t\tif (dstp + n + 1 >= dstlim || srcp + n >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += n + 1;\n\t\t\t\t*dstp++ = n;\n\t\t\t\tmemcpy(dstp, srcp, n);\n\t\t\t\tdstp += n;\n\t\t\t\tsrcp += n;\n\t\t\t\tbreak;\n\n\t\t\tcase NS_CMPRSFLGS:\n\t\t\t\tif (srcp >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (len < 0)\n\t\t\t\t\tlen = srcp - src + 1;\n\t\t\t\tsrcp = msg + (((n & 0x3f) << 8) | (*srcp & 0xff));\n\t\t\t\tif (srcp < msg || srcp >= eom) {  /* Out of range. */\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += 2;\n\t\t\t\t/*\n\t\t\t\t * Check for loops in the compressed name;\n\t\t\t\t * if we've looked at the whole message,\n\t\t\t\t * there must be a loop.\n\t\t\t\t */\n\t\t\t\tif (checked >= eom - msg) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\treturn -1;                    /* flag error */\n\t\t}\n\t}\n\t*dstp = '\\0';\n\tif (len < 0)\n\t\tlen = srcp - src;\n\treturn len;\n}",
        "func": "int ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,\n               u_char *dst, size_t dstsiz)\n{\n\tconst u_char *srcp, *dstlim;\n\tu_char *dstp;\n\tint n, len, checked;\n\n\tlen = -1;\n\tchecked = 0;\n\tdstp = dst;\n\tsrcp = src;\n\tdstlim = dst + dstsiz;\n\tif (srcp < msg || srcp >= eom) {\n\t\t__set_errno(EMSGSIZE);\n\t\treturn -1;\n\t}\n\t/* Fetch next label in domain name. */\n\twhile ((n = *srcp++) != 0) {\n\t\t/* Check for indirection. */\n\t\tswitch (n & NS_CMPRSFLGS) {\n\t\t\tcase 0:\n\t\t\t\t/* Limit checks. */\n\t\t\t\tif (dstp + n + 1 >= dstlim || srcp + n >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += n + 1;\n\t\t\t\t*dstp++ = n;\n\t\t\t\tmemcpy(dstp, srcp, n);\n\t\t\t\tdstp += n;\n\t\t\t\tsrcp += n;\n\t\t\t\tbreak;\n\n\t\t\tcase NS_CMPRSFLGS:\n\t\t\t\tif (srcp >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (len < 0)\n\t\t\t\t\tlen = srcp - src + 1;\n\t\t\t\tsrcp = msg + (((n & 0x3f) << 8) | (*srcp & 0xff));\n\t\t\t\tif (srcp < msg || srcp >= eom) {  /* Out of range. */\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += 2;\n\t\t\t\t/*\n\t\t\t\t * Check for loops in the compressed name;\n\t\t\t\t * if we've looked at the whole message,\n\t\t\t\t * there must be a loop.\n\t\t\t\t */\n\t\t\t\tif (checked >= eom - msg) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\treturn -1;                    /* flag error */\n\t\t}\n\t}\n\t*dstp = '\\0';\n\tif (len < 0)\n\t\tlen = srcp - src;\n\treturn len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,3 @@\n-libc_hidden_def(ns_name_pton)\n-\n-/*\n- * ns_name_unpack(msg, eom, src, dst, dstsiz)\n- *      Unpack a domain name from a message, source may be compressed.\n- * return:\n- *      -1 if it fails, or consumed octets if it succeeds.\n- */\n int ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,\n                u_char *dst, size_t dstsiz)\n {",
        "diff_line_info": {
            "deleted_lines": [
                "libc_hidden_def(ns_name_pton)",
                "",
                "/*",
                " * ns_name_unpack(msg, eom, src, dst, dstsiz)",
                " *      Unpack a domain name from a message, source may be compressed.",
                " * return:",
                " *      -1 if it fails, or consumed octets if it succeeds.",
                " */"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-45085",
        "func_name": "GNOME/epiphany/history_service_query_urls_cb",
        "description": "XSS can occur in GNOME Web (aka Epiphany) before 40.4 and 41.x before 41.1 via an about: page, as demonstrated by ephy-about:overview when a user visits an XSS payload page often enough to place that page on the Most Visited list.",
        "git_url": "https://github.com/GNOME/epiphany/commit/359e465148254278337537b4f0ef4fd16df72bb4",
        "commit_title": "about-handler: properly encode page title/URL in about:overview",
        "commit_text": " Otherwise, web pages can execute code in about:overview via a malicious page title. It might be possible to do the same via the URL, so better encode that too.  Fixes #1612  Part-of: <https://gitlab.gnome.org/GNOME/epiphany/-/merge_requests/1045>",
        "func_before": "static void\nhistory_service_query_urls_cb (EphyHistoryService     *history,\n                               gboolean                success,\n                               GList                  *urls,\n                               WebKitURISchemeRequest *request)\n{\n  EphySnapshotService *snapshot_service;\n  EphyEmbedShell *shell;\n  GString *data_str;\n  gsize data_length;\n  char *lang;\n  GList *l;\n  guint list_length;\n\n  snapshot_service = ephy_snapshot_service_get_default ();\n  shell = ephy_embed_shell_get_default ();\n\n  data_str = g_string_new (NULL);\n\n  lang = g_strdup (pango_language_to_string (gtk_get_default_language ()));\n  g_strdelimit (lang, \"_-@\", '\\0');\n\n  g_string_append_printf (data_str,\n                          \"<html xml:lang=\\\"%s\\\" lang=\\\"%s\\\" dir=\\\"%s\\\">\\n\"\n                          \"<head>\\n\"\n                          \"  <title>%s</title>\\n\"\n                          \"  <meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=utf-8\\\" />\\n\"\n                          \"  <meta name=\\\"viewport\\\" content=\\\"width=device-width\\\">\"\n                          \"  <link href=\\\"\"EPHY_PAGE_TEMPLATE_ABOUT_CSS \"\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\"\n                          \"  <script> </script>\\n\"\n                          \"</head>\\n\"\n                          \"<body>\\n\",\n                          lang, lang,\n                          ((gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL) ? \"rtl\" : \"ltr\"),\n                          _(NEW_TAB_PAGE_TITLE));\n  g_free (lang);\n\n  list_length = g_list_length (urls);\n\n  if (list_length == 0 || !success) {\n    GtkIconInfo *icon_info;\n    g_autofree gchar *icon = g_strconcat (APPLICATION_ID, \"-symbolic\", NULL);\n\n    icon_info = gtk_icon_theme_lookup_icon (gtk_icon_theme_get_default (),\n                                            icon,\n                                            128,\n                                            0);\n    g_string_append_printf (data_str,\n                            \"  <div id=\\\"overview\\\" class=\\\"overview-empty\\\">\\n\"\n                            \"    <img src=\\\"file://%s\\\"/>\\n\"\n                            \"    <div><h1>%s</h1></div>\\n\"\n                            \"    <div><p>%s</p></div>\\n\"\n                            \"  </div>\\n\"\n                            \"</body></html>\\n\",\n                            icon_info ? gtk_icon_info_get_filename (icon_info) : \"\",\n                            /* Displayed when opening the browser for the first time. */\n                            _(\"Welcome to Web\"), _(\"Start browsing and your most-visited sites will appear here.\"));\n    if (icon_info)\n      g_object_unref (icon_info);\n    goto out;\n  }\n\n  g_string_append (data_str,\n                   \"<div id=\\\"overview\\\">\\n\");\n\n  g_string_append (data_str,\n                   \"<div id=\\\"most-visited-grid\\\">\\n\");\n\n  for (l = urls; l; l = g_list_next (l)) {\n    EphyHistoryURL *url = (EphyHistoryURL *)l->data;\n    const char *snapshot;\n    g_autofree char *thumbnail_style = NULL;\n    g_autofree char *markup = NULL;\n\n    snapshot = ephy_snapshot_service_lookup_cached_snapshot_path (snapshot_service, url->url);\n    if (snapshot)\n      thumbnail_style = g_strdup_printf (\" style=\\\"background: url(file://%s) no-repeat; background-size: 100%%;\\\"\", snapshot);\n    else\n      ephy_embed_shell_schedule_thumbnail_update (shell, url);\n\n    markup = g_markup_escape_text (url->title, -1);\n    g_string_append_printf (data_str,\n                            \"<a class=\\\"overview-item\\\" title=\\\"%s\\\" href=\\\"%s\\\">\"\n                            \"  <div class=\\\"overview-close-button\\\" title=\\\"%s\\\"></div>\"\n                            \"  <span class=\\\"overview-thumbnail\\\"%s></span>\"\n                            \"  <span class=\\\"overview-title\\\">%s</span>\"\n                            \"</a>\",\n                            markup, url->url, _(\"Remove from overview\"),\n                            thumbnail_style ? thumbnail_style : \"\", url->title);\n  }\n\n  data_str = g_string_append (data_str,\n                              \"  </div>\\n\"\n                              \"  </div>\\n\"\n                              \"</body></html>\\n\");\n\nout:\n  data_length = data_str->len;\n  ephy_about_handler_finish_request (request, g_string_free (data_str, FALSE), data_length);\n  g_object_unref (request);\n}",
        "func": "static void\nhistory_service_query_urls_cb (EphyHistoryService     *history,\n                               gboolean                success,\n                               GList                  *urls,\n                               WebKitURISchemeRequest *request)\n{\n  EphySnapshotService *snapshot_service;\n  EphyEmbedShell *shell;\n  GString *data_str;\n  gsize data_length;\n  char *lang;\n  GList *l;\n  guint list_length;\n\n  snapshot_service = ephy_snapshot_service_get_default ();\n  shell = ephy_embed_shell_get_default ();\n\n  data_str = g_string_new (NULL);\n\n  lang = g_strdup (pango_language_to_string (gtk_get_default_language ()));\n  g_strdelimit (lang, \"_-@\", '\\0');\n\n  g_string_append_printf (data_str,\n                          \"<html xml:lang=\\\"%s\\\" lang=\\\"%s\\\" dir=\\\"%s\\\">\\n\"\n                          \"<head>\\n\"\n                          \"  <title>%s</title>\\n\"\n                          \"  <meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=utf-8\\\" />\\n\"\n                          \"  <meta name=\\\"viewport\\\" content=\\\"width=device-width\\\">\"\n                          \"  <link href=\\\"\"EPHY_PAGE_TEMPLATE_ABOUT_CSS \"\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\"\n                          \"  <script> </script>\\n\"\n                          \"</head>\\n\"\n                          \"<body>\\n\",\n                          lang, lang,\n                          ((gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL) ? \"rtl\" : \"ltr\"),\n                          _(NEW_TAB_PAGE_TITLE));\n  g_free (lang);\n\n  list_length = g_list_length (urls);\n\n  if (list_length == 0 || !success) {\n    GtkIconInfo *icon_info;\n    g_autofree gchar *icon = g_strconcat (APPLICATION_ID, \"-symbolic\", NULL);\n\n    icon_info = gtk_icon_theme_lookup_icon (gtk_icon_theme_get_default (),\n                                            icon,\n                                            128,\n                                            0);\n    g_string_append_printf (data_str,\n                            \"  <div id=\\\"overview\\\" class=\\\"overview-empty\\\">\\n\"\n                            \"    <img src=\\\"file://%s\\\"/>\\n\"\n                            \"    <div><h1>%s</h1></div>\\n\"\n                            \"    <div><p>%s</p></div>\\n\"\n                            \"  </div>\\n\"\n                            \"</body></html>\\n\",\n                            icon_info ? gtk_icon_info_get_filename (icon_info) : \"\",\n                            /* Displayed when opening the browser for the first time. */\n                            _(\"Welcome to Web\"), _(\"Start browsing and your most-visited sites will appear here.\"));\n    if (icon_info)\n      g_object_unref (icon_info);\n    goto out;\n  }\n\n  g_string_append (data_str,\n                   \"<div id=\\\"overview\\\">\\n\");\n\n  g_string_append (data_str,\n                   \"<div id=\\\"most-visited-grid\\\">\\n\");\n\n  for (l = urls; l; l = g_list_next (l)) {\n    EphyHistoryURL *url = (EphyHistoryURL *)l->data;\n    const char *snapshot;\n    g_autofree char *thumbnail_style = NULL;\n    g_autofree char *encoded_title = NULL;\n    g_autofree char *encoded_url = NULL;\n\n    snapshot = ephy_snapshot_service_lookup_cached_snapshot_path (snapshot_service, url->url);\n    if (snapshot)\n      thumbnail_style = g_strdup_printf (\" style=\\\"background: url(file://%s) no-repeat; background-size: 100%%;\\\"\", snapshot);\n    else\n      ephy_embed_shell_schedule_thumbnail_update (shell, url);\n\n    /* Title and URL are controlled by web content and could be malicious. */\n    encoded_title = ephy_encode_for_html_attribute (url->title);\n    encoded_url = ephy_encode_for_html_attribute (url->url);\n    g_string_append_printf (data_str,\n                            \"<a class=\\\"overview-item\\\" title=\\\"%s\\\" href=\\\"%s\\\">\"\n                            \"  <div class=\\\"overview-close-button\\\" title=\\\"%s\\\"></div>\"\n                            \"  <span class=\\\"overview-thumbnail\\\"%s></span>\"\n                            \"  <span class=\\\"overview-title\\\">%s</span>\"\n                            \"</a>\",\n                            encoded_title, encoded_url, _(\"Remove from overview\"),\n                            thumbnail_style ? thumbnail_style : \"\", encoded_title);\n  }\n\n  data_str = g_string_append (data_str,\n                              \"  </div>\\n\"\n                              \"  </div>\\n\"\n                              \"</body></html>\\n\");\n\nout:\n  data_length = data_str->len;\n  ephy_about_handler_finish_request (request, g_string_free (data_str, FALSE), data_length);\n  g_object_unref (request);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -70,7 +70,8 @@\n     EphyHistoryURL *url = (EphyHistoryURL *)l->data;\n     const char *snapshot;\n     g_autofree char *thumbnail_style = NULL;\n-    g_autofree char *markup = NULL;\n+    g_autofree char *encoded_title = NULL;\n+    g_autofree char *encoded_url = NULL;\n \n     snapshot = ephy_snapshot_service_lookup_cached_snapshot_path (snapshot_service, url->url);\n     if (snapshot)\n@@ -78,15 +79,17 @@\n     else\n       ephy_embed_shell_schedule_thumbnail_update (shell, url);\n \n-    markup = g_markup_escape_text (url->title, -1);\n+    /* Title and URL are controlled by web content and could be malicious. */\n+    encoded_title = ephy_encode_for_html_attribute (url->title);\n+    encoded_url = ephy_encode_for_html_attribute (url->url);\n     g_string_append_printf (data_str,\n                             \"<a class=\\\"overview-item\\\" title=\\\"%s\\\" href=\\\"%s\\\">\"\n                             \"  <div class=\\\"overview-close-button\\\" title=\\\"%s\\\"></div>\"\n                             \"  <span class=\\\"overview-thumbnail\\\"%s></span>\"\n                             \"  <span class=\\\"overview-title\\\">%s</span>\"\n                             \"</a>\",\n-                            markup, url->url, _(\"Remove from overview\"),\n-                            thumbnail_style ? thumbnail_style : \"\", url->title);\n+                            encoded_title, encoded_url, _(\"Remove from overview\"),\n+                            thumbnail_style ? thumbnail_style : \"\", encoded_title);\n   }\n \n   data_str = g_string_append (data_str,",
        "diff_line_info": {
            "deleted_lines": [
                "    g_autofree char *markup = NULL;",
                "    markup = g_markup_escape_text (url->title, -1);",
                "                            markup, url->url, _(\"Remove from overview\"),",
                "                            thumbnail_style ? thumbnail_style : \"\", url->title);"
            ],
            "added_lines": [
                "    g_autofree char *encoded_title = NULL;",
                "    g_autofree char *encoded_url = NULL;",
                "    /* Title and URL are controlled by web content and could be malicious. */",
                "    encoded_title = ephy_encode_for_html_attribute (url->title);",
                "    encoded_url = ephy_encode_for_html_attribute (url->url);",
                "                            encoded_title, encoded_url, _(\"Remove from overview\"),",
                "                            thumbnail_style ? thumbnail_style : \"\", encoded_title);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/escape",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/0a160214424d5ca708b8e2eaea061924d8fb0c38",
        "commit_title": "Fix vulnrabilities in mustache and static",
        "commit_text": "",
        "func_before": "void escape(const std::string& in, std::string& out)\n            {\n                out.reserve(out.size() + in.size());\n                for (auto it = in.begin(); it != in.end(); ++it)\n                {\n                    switch (*it)\n                    {\n                        case '&': out += \"&amp;\"; break;\n                        case '<': out += \"&lt;\"; break;\n                        case '>': out += \"&gt;\"; break;\n                        case '\"': out += \"&quot;\"; break;\n                        case '\\'': out += \"&#39;\"; break;\n                        case '/': out += \"&#x2F;\"; break;\n                        default: out += *it; break;\n                    }\n                }\n            }",
        "func": "void escape(const std::string& in, std::string& out)\n            {\n                out.reserve(out.size() + in.size());\n                for (auto it = in.begin(); it != in.end(); ++it)\n                {\n                    switch (*it)\n                    {\n                        case '&': out += \"&amp;\"; break;\n                        case '<': out += \"&lt;\"; break;\n                        case '>': out += \"&gt;\"; break;\n                        case '\"': out += \"&quot;\"; break;\n                        case '\\'': out += \"&#39;\"; break;\n                        case '/': out += \"&#x2F;\"; break;\n                        case '`': out += \"&#x60\"; break;\n                        case '=': out += \"&#x3D\"; break;\n                        default: out += *it; break;\n                    }\n                }\n            }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,8 @@\n                         case '\"': out += \"&quot;\"; break;\n                         case '\\'': out += \"&#39;\"; break;\n                         case '/': out += \"&#x2F;\"; break;\n+                        case '`': out += \"&#x60\"; break;\n+                        case '=': out += \"&#x3D\"; break;\n                         default: out += *it; break;\n                     }\n                 }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                        case '`': out += \"&#x60\"; break;",
                "                        case '=': out += \"&#x3D\"; break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/set_static_file_info",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/0a160214424d5ca708b8e2eaea061924d8fb0c38",
        "commit_title": "Fix vulnrabilities in mustache and static",
        "commit_text": "",
        "func_before": "void set_static_file_info(std::string path)\n        {\n            file_info.path = path;\n            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n#ifdef CROW_ENABLE_COMPRESSION\n            compressed = false;\n#endif\n            if (file_info.statResult == 0)\n            {\n                std::size_t last_dot = path.find_last_of(\".\");\n                std::string extension = path.substr(last_dot + 1);\n                std::string mimeType = \"\";\n                code = 200;\n                this->add_header(\"Content-length\", std::to_string(file_info.statbuf.st_size));\n\n                if (extension != \"\")\n                {\n                    mimeType = mime_types.at(extension);\n                    if (mimeType != \"\")\n                        this->add_header(\"Content-Type\", mimeType);\n                    else\n                        this->add_header(\"content-Type\", \"text/plain\");\n                }\n            }\n            else\n            {\n                code = 404;\n                this->end();\n            }\n        }",
        "func": "void set_static_file_info(std::string path)\n        {\n            path = utility::sanitize_filename(path); //TODO create a no_copy function instead\n            file_info.path = path;\n            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n#ifdef CROW_ENABLE_COMPRESSION\n            compressed = false;\n#endif\n            if (file_info.statResult == 0)\n            {\n                std::size_t last_dot = path.find_last_of(\".\");\n                std::string extension = path.substr(last_dot + 1);\n                std::string mimeType = \"\";\n                code = 200;\n                this->add_header(\"Content-length\", std::to_string(file_info.statbuf.st_size));\n\n                if (extension != \"\")\n                {\n                    mimeType = mime_types.at(extension);\n                    if (mimeType != \"\")\n                        this->add_header(\"Content-Type\", mimeType);\n                    else\n                        this->add_header(\"content-Type\", \"text/plain\");\n                }\n            }\n            else\n            {\n                code = 404;\n                this->end();\n            }\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n void set_static_file_info(std::string path)\n         {\n+            path = utility::sanitize_filename(path); //TODO create a no_copy function instead\n             file_info.path = path;\n             file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n #ifdef CROW_ENABLE_COMPRESSION",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            path = utility::sanitize_filename(path); //TODO create a no_copy function instead"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/load",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a",
        "commit_title": "Fixed another vulnerability in mustache file loading",
        "commit_text": "and made the file sanitizer a copy-less function",
        "func_before": "inline template_t load(const std::string& filename)\n        {\n            return compile(detail::get_loader_ref()(filename));\n        }",
        "func": "inline template_t load(const std::string& filename)\n        {\n            std::string filename_sanitized(filename);\n            utility::sanitize_filename(filename_sanitized);\n            return compile(detail::get_loader_ref()(filename_sanitized));\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,6 @@\n inline template_t load(const std::string& filename)\n         {\n-            return compile(detail::get_loader_ref()(filename));\n+            std::string filename_sanitized(filename);\n+            utility::sanitize_filename(filename_sanitized);\n+            return compile(detail::get_loader_ref()(filename_sanitized));\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "            return compile(detail::get_loader_ref()(filename));"
            ],
            "added_lines": [
                "            std::string filename_sanitized(filename);",
                "            utility::sanitize_filename(filename_sanitized);",
                "            return compile(detail::get_loader_ref()(filename_sanitized));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/sanitize_filename",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a",
        "commit_title": "Fixed another vulnerability in mustache file loading",
        "commit_text": "and made the file sanitizer a copy-less function",
        "func_before": "inline std::string sanitize_filename(std::string data, char replacement = '_')\n        {\n            unsigned char i = 0, length_limit;\n\n            length_limit = data.length() < 255 ? data.length() : 255;\n            data = data.substr(0, length_limit);\n\n            for (; i < length_limit; i++)\n            {\n                switch (data[i])\n                {\n                    case '/':\n                    case '?':\n                    case '<':\n                    case '>':\n                    case '\\\\':\n                    case ':':\n                    case '*':\n                    case '|':\n                    case '\\\"':\n\n                    case 0x00:\n                    case 0x01:\n                    case 0x02:\n                    case 0x03:\n                    case 0x04:\n                    case 0x05:\n                    case 0x06:\n                    case 0x07:\n                    case 0x08:\n                    case 0x09:\n                    case 0x0a:\n                    case 0x0b:\n                    case 0x0c:\n                    case 0x0d:\n                    case 0x0e:\n                    case 0x0f:\n                    case 0x10:\n                    case 0x11:\n                    case 0x12:\n                    case 0x13:\n                    case 0x14:\n                    case 0x15:\n                    case 0x16:\n                    case 0x17:\n                    case 0x18:\n                    case 0x19:\n                    case 0x1a:\n                    case 0x1b:\n                    case 0x1c:\n                    case 0x1d:\n                    case 0x1e:\n                    case 0x1f:\n\n                    case 0x80:\n                    case 0x81:\n                    case 0x82:\n                    case 0x83:\n                    case 0x84:\n                    case 0x85:\n                    case 0x86:\n                    case 0x87:\n                    case 0x88:\n                    case 0x89:\n                    case 0x8a:\n                    case 0x8b:\n                    case 0x8c:\n                    case 0x8d:\n                    case 0x8e:\n                    case 0x8f:\n                    case 0x90:\n                    case 0x91:\n                    case 0x92:\n                    case 0x93:\n                    case 0x94:\n                    case 0x95:\n                    case 0x96:\n                    case 0x97:\n                    case 0x98:\n                    case 0x99:\n                    case 0x9a:\n                    case 0x9b:\n                    case 0x9c:\n                    case 0x9d:\n                    case 0x9e:\n                    case 0x9f:\n\n                        data[i] = replacement;\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n            std::string str_replacement(1, replacement);\n\n            boost::ireplace_all(data, \"..\", str_replacement);\n\n            boost::ireplace_all(data, \"CON\", str_replacement);\n            boost::ireplace_all(data, \"PRN\", str_replacement);\n            boost::ireplace_all(data, \"AUX\", str_replacement);\n            boost::ireplace_all(data, \"NUL\", str_replacement);\n            boost::ireplace_all(data, \"COM1\", str_replacement);\n            boost::ireplace_all(data, \"COM2\", str_replacement);\n            boost::ireplace_all(data, \"COM3\", str_replacement);\n            boost::ireplace_all(data, \"COM4\", str_replacement);\n            boost::ireplace_all(data, \"COM5\", str_replacement);\n            boost::ireplace_all(data, \"COM6\", str_replacement);\n            boost::ireplace_all(data, \"COM7\", str_replacement);\n            boost::ireplace_all(data, \"COM8\", str_replacement);\n            boost::ireplace_all(data, \"COM9\", str_replacement);\n            boost::ireplace_all(data, \"LPT1\", str_replacement);\n            boost::ireplace_all(data, \"LPT2\", str_replacement);\n            boost::ireplace_all(data, \"LPT3\", str_replacement);\n            boost::ireplace_all(data, \"LPT4\", str_replacement);\n            boost::ireplace_all(data, \"LPT5\", str_replacement);\n            boost::ireplace_all(data, \"LPT6\", str_replacement);\n            boost::ireplace_all(data, \"LPT7\", str_replacement);\n            boost::ireplace_all(data, \"LPT8\", str_replacement);\n            boost::ireplace_all(data, \"LPT9\", str_replacement);\n\n            return data;\n        }",
        "func": "inline static void sanitize_filename(std::string& data, char replacement = '_')\n        {\n            unsigned char i = 0, length_limit;\n\n            length_limit = data.length() < 255 ? data.length() : 255;\n            data = data.substr(0, length_limit);\n\n            for (; i < length_limit; i++)\n            {\n                switch ((unsigned char)data[i])\n                {\n                    // WARNING While I can't see how using '\\' or '/' would cause a problem, it still warrants an investigation\n                    //case '/':\n                    case '?':\n                    case '<':\n                    case '>':\n                    //case '\\\\':\n                    case ':':\n                    case '*':\n                    case '|':\n                    case '\\\"':\n\n                    case 0x00:\n                    case 0x01:\n                    case 0x02:\n                    case 0x03:\n                    case 0x04:\n                    case 0x05:\n                    case 0x06:\n                    case 0x07:\n                    case 0x08:\n                    case 0x09:\n                    case 0x0a:\n                    case 0x0b:\n                    case 0x0c:\n                    case 0x0d:\n                    case 0x0e:\n                    case 0x0f:\n                    case 0x10:\n                    case 0x11:\n                    case 0x12:\n                    case 0x13:\n                    case 0x14:\n                    case 0x15:\n                    case 0x16:\n                    case 0x17:\n                    case 0x18:\n                    case 0x19:\n                    case 0x1a:\n                    case 0x1b:\n                    case 0x1c:\n                    case 0x1d:\n                    case 0x1e:\n                    case 0x1f:\n\n                    case 0x80:\n                    case 0x81:\n                    case 0x82:\n                    case 0x83:\n                    case 0x84:\n                    case 0x85:\n                    case 0x86:\n                    case 0x87:\n                    case 0x88:\n                    case 0x89:\n                    case 0x8a:\n                    case 0x8b:\n                    case 0x8c:\n                    case 0x8d:\n                    case 0x8e:\n                    case 0x8f:\n                    case 0x90:\n                    case 0x91:\n                    case 0x92:\n                    case 0x93:\n                    case 0x94:\n                    case 0x95:\n                    case 0x96:\n                    case 0x97:\n                    case 0x98:\n                    case 0x99:\n                    case 0x9a:\n                    case 0x9b:\n                    case 0x9c:\n                    case 0x9d:\n                    case 0x9e:\n                    case 0x9f:\n\n                        data[i] = replacement;\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n            std::string str_replacement(1, replacement);\n\n            boost::ireplace_all(data, \"..\", str_replacement);\n\n            boost::ireplace_all(data, \"CON\", str_replacement);\n            boost::ireplace_all(data, \"PRN\", str_replacement);\n            boost::ireplace_all(data, \"AUX\", str_replacement);\n            boost::ireplace_all(data, \"NUL\", str_replacement);\n            boost::ireplace_all(data, \"COM1\", str_replacement);\n            boost::ireplace_all(data, \"COM2\", str_replacement);\n            boost::ireplace_all(data, \"COM3\", str_replacement);\n            boost::ireplace_all(data, \"COM4\", str_replacement);\n            boost::ireplace_all(data, \"COM5\", str_replacement);\n            boost::ireplace_all(data, \"COM6\", str_replacement);\n            boost::ireplace_all(data, \"COM7\", str_replacement);\n            boost::ireplace_all(data, \"COM8\", str_replacement);\n            boost::ireplace_all(data, \"COM9\", str_replacement);\n            boost::ireplace_all(data, \"LPT1\", str_replacement);\n            boost::ireplace_all(data, \"LPT2\", str_replacement);\n            boost::ireplace_all(data, \"LPT3\", str_replacement);\n            boost::ireplace_all(data, \"LPT4\", str_replacement);\n            boost::ireplace_all(data, \"LPT5\", str_replacement);\n            boost::ireplace_all(data, \"LPT6\", str_replacement);\n            boost::ireplace_all(data, \"LPT7\", str_replacement);\n            boost::ireplace_all(data, \"LPT8\", str_replacement);\n            boost::ireplace_all(data, \"LPT9\", str_replacement);\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-inline std::string sanitize_filename(std::string data, char replacement = '_')\n+inline static void sanitize_filename(std::string& data, char replacement = '_')\n         {\n             unsigned char i = 0, length_limit;\n \n@@ -7,13 +7,14 @@\n \n             for (; i < length_limit; i++)\n             {\n-                switch (data[i])\n+                switch ((unsigned char)data[i])\n                 {\n-                    case '/':\n+                    // WARNING While I can't see how using '\\' or '/' would cause a problem, it still warrants an investigation\n+                    //case '/':\n                     case '?':\n                     case '<':\n                     case '>':\n-                    case '\\\\':\n+                    //case '\\\\':\n                     case ':':\n                     case '*':\n                     case '|':\n@@ -118,6 +119,4 @@\n             boost::ireplace_all(data, \"LPT7\", str_replacement);\n             boost::ireplace_all(data, \"LPT8\", str_replacement);\n             boost::ireplace_all(data, \"LPT9\", str_replacement);\n-\n-            return data;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "inline std::string sanitize_filename(std::string data, char replacement = '_')",
                "                switch (data[i])",
                "                    case '/':",
                "                    case '\\\\':",
                "",
                "            return data;"
            ],
            "added_lines": [
                "inline static void sanitize_filename(std::string& data, char replacement = '_')",
                "                switch ((unsigned char)data[i])",
                "                    // WARNING While I can't see how using '\\' or '/' would cause a problem, it still warrants an investigation",
                "                    //case '/':",
                "                    //case '\\\\':"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23514",
        "func_name": "CrowCpp/Crow/set_static_file_info",
        "description": "This affects the package Crow before 0.3+4. It is possible to traverse directories to fetch arbitrary files from the server.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/e688cbd18ea85a4a61b32be4e8d6b37c66943c4a",
        "commit_title": "Fixed another vulnerability in mustache file loading",
        "commit_text": "and made the file sanitizer a copy-less function",
        "func_before": "void set_static_file_info(std::string path)\n        {\n            path = utility::sanitize_filename(path); //TODO create a no_copy function instead\n            file_info.path = path;\n            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n#ifdef CROW_ENABLE_COMPRESSION\n            compressed = false;\n#endif\n            if (file_info.statResult == 0)\n            {\n                std::size_t last_dot = path.find_last_of(\".\");\n                std::string extension = path.substr(last_dot + 1);\n                std::string mimeType = \"\";\n                code = 200;\n                this->add_header(\"Content-length\", std::to_string(file_info.statbuf.st_size));\n\n                if (extension != \"\")\n                {\n                    mimeType = mime_types.at(extension);\n                    if (mimeType != \"\")\n                        this->add_header(\"Content-Type\", mimeType);\n                    else\n                        this->add_header(\"content-Type\", \"text/plain\");\n                }\n            }\n            else\n            {\n                code = 404;\n                this->end();\n            }\n        }",
        "func": "void set_static_file_info(std::string path)\n        {\n            utility::sanitize_filename(path);\n            file_info.path = path;\n            file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n#ifdef CROW_ENABLE_COMPRESSION\n            compressed = false;\n#endif\n            if (file_info.statResult == 0)\n            {\n                std::size_t last_dot = path.find_last_of(\".\");\n                std::string extension = path.substr(last_dot + 1);\n                std::string mimeType = \"\";\n                code = 200;\n                this->add_header(\"Content-length\", std::to_string(file_info.statbuf.st_size));\n\n                if (extension != \"\")\n                {\n                    mimeType = mime_types.at(extension);\n                    if (mimeType != \"\")\n                        this->add_header(\"Content-Type\", mimeType);\n                    else\n                        this->add_header(\"content-Type\", \"text/plain\");\n                }\n            }\n            else\n            {\n                code = 404;\n                this->end();\n            }\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n void set_static_file_info(std::string path)\n         {\n-            path = utility::sanitize_filename(path); //TODO create a no_copy function instead\n+            utility::sanitize_filename(path);\n             file_info.path = path;\n             file_info.statResult = stat(file_info.path.c_str(), &file_info.statbuf);\n #ifdef CROW_ENABLE_COMPRESSION",
        "diff_line_info": {
            "deleted_lines": [
                "            path = utility::sanitize_filename(path); //TODO create a no_copy function instead"
            ],
            "added_lines": [
                "            utility::sanitize_filename(path);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26298",
        "func_name": "vmg/redcarpet/rndr_quote",
        "description": "Redcarpet is a Ruby library for Markdown processing. In Redcarpet before version 3.5.1, there is an injection vulnerability which can enable a cross-site scripting attack. In affected versions no HTML escaping was being performed when processing quotes. This applies even when the `:escape_html` option was being used. This is fixed in version 3.5.1 by the referenced commit.",
        "git_url": "https://github.com/vmg/redcarpet/commit/a699c82292b17c8e6a62e1914d5eccc252272793",
        "commit_title": "Fix a security issue using `:quote` with `:escape_html`",
        "commit_text": " Reported by @johan-smits.",
        "func_before": "static int\nrndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\n\treturn 1;\n}",
        "func": "static int\nrndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tstruct html_renderopt *options = opaque;\n\n\tBUFPUTSL(ob, \"<q>\");\n\n\tif (options->flags & HTML_ESCAPE)\n\t\tescape_html(ob, text->data, text->size);\n\telse\n\t\tbufput(ob, text->data, text->size);\n\n\tBUFPUTSL(ob, \"</q>\");\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,15 @@\n \tif (!text || !text->size)\n \t\treturn 0;\n \n+\tstruct html_renderopt *options = opaque;\n+\n \tBUFPUTSL(ob, \"<q>\");\n-\tbufput(ob, text->data, text->size);\n+\n+\tif (options->flags & HTML_ESCAPE)\n+\t\tescape_html(ob, text->data, text->size);\n+\telse\n+\t\tbufput(ob, text->data, text->size);\n+\n \tBUFPUTSL(ob, \"</q>\");\n \n \treturn 1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tbufput(ob, text->data, text->size);"
            ],
            "added_lines": [
                "\tstruct html_renderopt *options = opaque;",
                "",
                "",
                "\tif (options->flags & HTML_ESCAPE)",
                "\t\tescape_html(ob, text->data, text->size);",
                "\telse",
                "\t\tbufput(ob, text->data, text->size);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20798",
        "func_name": "cherokee/webserver/server_info_build_html",
        "description": "An XSS issue was discovered in handler_server_info.c in Cherokee through 1.2.104. The requested URL is improperly displayed on the About page in the default configuration of the web server and its administrator panel. The XSS in the administrator panel can be used to reconfigure the server and execute arbitrary commands.",
        "git_url": "https://github.com/cherokee/webserver/commit/39c6b73ff1b4749812eea940fa63e54e2ed860da",
        "commit_title": "Use relative paths in the handler_server_info page",
        "commit_text": " Issue #1227 describes a XSS vulnerability on the about page of cherokee-admin. While the report by LogicalTrust only describes a JavaScript variant, a CSS method could also be probed via logo.gif.  The root cause is the request being verbatim copied in to the HTML template. The request could be escaped, but leads to the question: Why are we presenting a full path, instead of a relative path to the page? This change removes the full path, and makes it relative. No URL is being printed in the template, and the XSS is avoided and therefore it should also be faster.",
        "func_before": "static ret_t\nserver_info_build_html (cherokee_handler_server_info_t *hdl, cherokee_buffer_t *buffer)\n{\n\tcherokee_buffer_t ver = CHEROKEE_BUF_INIT;\n\n\tcherokee_buffer_add_str (buffer, PAGE_HEADER);\n\tcherokee_buffer_add_str (buffer, AJAX_JS);\n\n\tcherokee_version_add (&ver, HANDLER_SRV(hdl)->server_token);\n\tcherokee_buffer_replace_string (buffer, \"{cherokee_name}\", 15, ver.buf, ver.len);\n\tcherokee_buffer_mrproper (&ver);\n\n\tcherokee_buffer_replace_string (buffer, \"{request}\", 9,\n\t                                HANDLER_CONN(hdl)->request.buf,\n\t                                HANDLER_CONN(hdl)->request.len);\n\n\tcherokee_buffer_add_str (buffer, PAGE_FOOT);\n\treturn ret_ok;\n}",
        "func": "static ret_t\nserver_info_build_html (cherokee_handler_server_info_t *hdl, cherokee_buffer_t *buffer)\n{\n\tcherokee_buffer_t ver = CHEROKEE_BUF_INIT;\n\n\tcherokee_buffer_add_str (buffer, PAGE_HEADER);\n\tcherokee_buffer_add_str (buffer, AJAX_JS);\n\n\tcherokee_version_add (&ver, HANDLER_SRV(hdl)->server_token);\n\tcherokee_buffer_replace_string (buffer, \"{cherokee_name}\", 15, ver.buf, ver.len);\n\tcherokee_buffer_mrproper (&ver);\n\n\tcherokee_buffer_add_str (buffer, PAGE_FOOT);\n\treturn ret_ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,10 +10,6 @@\n \tcherokee_buffer_replace_string (buffer, \"{cherokee_name}\", 15, ver.buf, ver.len);\n \tcherokee_buffer_mrproper (&ver);\n \n-\tcherokee_buffer_replace_string (buffer, \"{request}\", 9,\n-\t                                HANDLER_CONN(hdl)->request.buf,\n-\t                                HANDLER_CONN(hdl)->request.len);\n-\n \tcherokee_buffer_add_str (buffer, PAGE_FOOT);\n \treturn ret_ok;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tcherokee_buffer_replace_string (buffer, \"{request}\", 9,",
                "\t                                HANDLER_CONN(hdl)->request.buf,",
                "\t                                HANDLER_CONN(hdl)->request.len);",
                ""
            ],
            "added_lines": []
        }
    }
]