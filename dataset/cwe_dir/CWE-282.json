[
    {
        "cve_id": "CVE-2023-0386",
        "func_name": "torvalds/linux/ovl_copy_up_one",
        "description": "A flaw was found in the Linux kernel, where unauthorized access to the execution of the setuid file with capabilities was found in the Linux kernelâ€™s OverlayFS subsystem in how a user copies a capable file from a nosuid mount into another mount. This uid mapping bug allows a local user to escalate their privileges on the system.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=4f11ada10d0a",
        "commit_title": "If st_uid/st_gid doesn't have a mapping in the mounter's user_ns, then",
        "commit_text": "copy-up should fail, just like it would fail if the mounter task was doing the copy using \"cp -a\".  There's a corner case where the \"cp -a\" would succeed but copy up fail: if there's a mapping of the invalid uid/gid (65534 by default) in the user namespace.  This is because stat(2) will return this value if the mapping doesn't exist in the current user_ns and \"cp -a\" will in turn be able to create a file with this uid/gid.  This behavior would be inconsistent with POSIX ACL's, which return -1 for invalid uid/gid which result in a failed copy.  For consistency and simplicity fail the copy of the st_uid/st_gid are invalid.  Cc: <stable@vger.kernel.org> # v5.11 ",
        "func_before": "static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t\t   int flags)\n{\n\tint err;\n\tDEFINE_DELAYED_CALL(done);\n\tstruct path parentpath;\n\tstruct ovl_copy_up_ctx ctx = {\n\t\t.parent = parent,\n\t\t.dentry = dentry,\n\t\t.workdir = ovl_workdir(dentry),\n\t};\n\n\tif (WARN_ON(!ctx.workdir))\n\t\treturn -EROFS;\n\n\tovl_path_lower(dentry, &ctx.lowerpath);\n\terr = vfs_getattr(&ctx.lowerpath, &ctx.stat,\n\t\t\t  STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);\n\tif (err)\n\t\treturn err;\n\n\tctx.metacopy = ovl_need_meta_copy_up(dentry, ctx.stat.mode, flags);\n\n\tif (parent) {\n\t\tovl_path_upper(parent, &parentpath);\n\t\tctx.destdir = parentpath.dentry;\n\t\tctx.destname = dentry->d_name;\n\n\t\terr = vfs_getattr(&parentpath, &ctx.pstat,\n\t\t\t\t  STATX_ATIME | STATX_MTIME,\n\t\t\t\t  AT_STATX_SYNC_AS_STAT);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* maybe truncate regular file. this has no effect on dirs */\n\tif (flags & O_TRUNC)\n\t\tctx.stat.size = 0;\n\n\tif (S_ISLNK(ctx.stat.mode)) {\n\t\tctx.link = vfs_get_link(ctx.lowerpath.dentry, &done);\n\t\tif (IS_ERR(ctx.link))\n\t\t\treturn PTR_ERR(ctx.link);\n\t}\n\n\terr = ovl_copy_up_start(dentry, flags);\n\t/* err < 0: interrupted, err > 0: raced with another copy-up */\n\tif (unlikely(err)) {\n\t\tif (err > 0)\n\t\t\terr = 0;\n\t} else {\n\t\tif (!ovl_dentry_upper(dentry))\n\t\t\terr = ovl_do_copy_up(&ctx);\n\t\tif (!err && parent && !ovl_dentry_has_upper_alias(dentry))\n\t\t\terr = ovl_link_up(&ctx);\n\t\tif (!err && ovl_dentry_needs_data_copy_up_locked(dentry, flags))\n\t\t\terr = ovl_copy_up_meta_inode_data(&ctx);\n\t\tovl_copy_up_end(dentry);\n\t}\n\tdo_delayed_call(&done);\n\n\treturn err;\n}",
        "func": "static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,\n\t\t\t   int flags)\n{\n\tint err;\n\tDEFINE_DELAYED_CALL(done);\n\tstruct path parentpath;\n\tstruct ovl_copy_up_ctx ctx = {\n\t\t.parent = parent,\n\t\t.dentry = dentry,\n\t\t.workdir = ovl_workdir(dentry),\n\t};\n\n\tif (WARN_ON(!ctx.workdir))\n\t\treturn -EROFS;\n\n\tovl_path_lower(dentry, &ctx.lowerpath);\n\terr = vfs_getattr(&ctx.lowerpath, &ctx.stat,\n\t\t\t  STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);\n\tif (err)\n\t\treturn err;\n\n\tif (!kuid_has_mapping(current_user_ns(), ctx.stat.uid) ||\n\t    !kgid_has_mapping(current_user_ns(), ctx.stat.gid))\n\t\treturn -EOVERFLOW;\n\n\tctx.metacopy = ovl_need_meta_copy_up(dentry, ctx.stat.mode, flags);\n\n\tif (parent) {\n\t\tovl_path_upper(parent, &parentpath);\n\t\tctx.destdir = parentpath.dentry;\n\t\tctx.destname = dentry->d_name;\n\n\t\terr = vfs_getattr(&parentpath, &ctx.pstat,\n\t\t\t\t  STATX_ATIME | STATX_MTIME,\n\t\t\t\t  AT_STATX_SYNC_AS_STAT);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* maybe truncate regular file. this has no effect on dirs */\n\tif (flags & O_TRUNC)\n\t\tctx.stat.size = 0;\n\n\tif (S_ISLNK(ctx.stat.mode)) {\n\t\tctx.link = vfs_get_link(ctx.lowerpath.dentry, &done);\n\t\tif (IS_ERR(ctx.link))\n\t\t\treturn PTR_ERR(ctx.link);\n\t}\n\n\terr = ovl_copy_up_start(dentry, flags);\n\t/* err < 0: interrupted, err > 0: raced with another copy-up */\n\tif (unlikely(err)) {\n\t\tif (err > 0)\n\t\t\terr = 0;\n\t} else {\n\t\tif (!ovl_dentry_upper(dentry))\n\t\t\terr = ovl_do_copy_up(&ctx);\n\t\tif (!err && parent && !ovl_dentry_has_upper_alias(dentry))\n\t\t\terr = ovl_link_up(&ctx);\n\t\tif (!err && ovl_dentry_needs_data_copy_up_locked(dentry, flags))\n\t\t\terr = ovl_copy_up_meta_inode_data(&ctx);\n\t\tovl_copy_up_end(dentry);\n\t}\n\tdo_delayed_call(&done);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,10 @@\n \t\t\t  STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);\n \tif (err)\n \t\treturn err;\n+\n+\tif (!kuid_has_mapping(current_user_ns(), ctx.stat.uid) ||\n+\t    !kgid_has_mapping(current_user_ns(), ctx.stat.gid))\n+\t\treturn -EOVERFLOW;\n \n \tctx.metacopy = ovl_need_meta_copy_up(dentry, ctx.stat.mode, flags);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (!kuid_has_mapping(current_user_ns(), ctx.stat.uid) ||",
                "\t    !kgid_has_mapping(current_user_ns(), ctx.stat.gid))",
                "\t\treturn -EOVERFLOW;"
            ]
        }
    }
]