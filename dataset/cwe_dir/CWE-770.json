[
    {
        "cve_id": "CVE-2021-40607",
        "func_name": "gpac/schm_box_read",
        "description": "The schm_box_size function in GPAC 1.0.1 allows attackers to cause a denial of service via a crafted file in the MP4Box command.",
        "git_url": "https://github.com/gpac/gpac/commit/f19668964bf422cf5a63e4dbe1d3c6c75edadcbb",
        "commit_title": "fixed #1879",
        "commit_text": "",
        "func_before": "GF_Err schm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->scheme_type = gf_bs_read_u32(bs);\n\tptr->scheme_version = gf_bs_read_u32(bs);\n\n\tif (ptr->size && (ptr->flags & 0x000001)) {\n\t\tu32 len = (u32) (ptr->size);\n\t\tptr->URI = (char*)gf_malloc(sizeof(char)*len);\n\t\tif (!ptr->URI) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URI, len);\n\t}\n\treturn GF_OK;\n}",
        "func": "GF_Err schm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->scheme_type = gf_bs_read_u32(bs);\n\tptr->scheme_version = gf_bs_read_u32(bs);\n\n\tif (ptr->size && (ptr->flags & 0x000001)) {\n\t\tu32 len = (u32) (ptr->size);\n\t\tptr->URI = (char*)gf_malloc(sizeof(char)*(len+1));\n\t\tif (!ptr->URI) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URI, len);\n\t\tptr->URI[len] = 0;\n\t}\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,9 +8,10 @@\n \n \tif (ptr->size && (ptr->flags & 0x000001)) {\n \t\tu32 len = (u32) (ptr->size);\n-\t\tptr->URI = (char*)gf_malloc(sizeof(char)*len);\n+\t\tptr->URI = (char*)gf_malloc(sizeof(char)*(len+1));\n \t\tif (!ptr->URI) return GF_OUT_OF_MEM;\n \t\tgf_bs_read_data(bs, ptr->URI, len);\n+\t\tptr->URI[len] = 0;\n \t}\n \treturn GF_OK;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tptr->URI = (char*)gf_malloc(sizeof(char)*len);"
            ],
            "added_lines": [
                "\t\tptr->URI = (char*)gf_malloc(sizeof(char)*(len+1));",
                "\t\tptr->URI[len] = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40609",
        "func_name": "gpac/GetHintFormat",
        "description": "The GetHintFormat function in GPAC 1.0.1 allows attackers to cause a denial of service via a crafted file in the MP4Box command.",
        "git_url": "https://github.com/gpac/gpac/commit/86c1566f040b2b84c72afcb6cbd444c5aff56cfe",
        "commit_title": "fixed #1894",
        "commit_text": "",
        "func_before": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}",
        "func": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n u32 GetHintFormat(GF_TrackBox *trak)\n {\n \tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n+\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n+\t\treturn 0;\n+\t\t\n \tif (!hmhd || !hmhd->subType) {\n \t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n \t\tif (!hmhd) return a ? a->type : 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)",
                "\t\treturn 0;",
                "\t\t"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11479",
        "func_name": "kernel/git/netdev/net/tcp_sk_init",
        "description": "Jonathan Looney discovered that the Linux kernel default MSS is hard-coded to 48 bytes. This allows a remote peer to fragment TCP resend queues significantly more than if a larger MSS were enforced. A remote attacker could use this to cause a denial of service. This has been fixed in stable kernel releases 4.4.182, 4.9.182, 4.14.127, 4.19.52, 5.1.11, and is fixed in commits 967c05aee439e6e5d7d805e195b3a20ef5c433d6 and 5f3e2bf008c2221478101ee72f5cb4654b9fc363.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=5f3e2bf008c2221478101ee72f5cb4654b9fc363",
        "commit_title": "Some TCP peers announce a very small MSS option in their SYN and/or",
        "commit_text": "SYN/ACK messages.  This forces the stack to send packets with a very high network/cpu overhead.  Linux has enforced a minimal value of 48. Since this value includes the size of TCP options, and that the options can consume up to 40 bytes, this means that each segment can include only 8 bytes of payload.  In some cases, it can be useful to increase the minimal value to a saner value.  We still let the default to 48 (TCP_MIN_SND_MSS), for compatibility reasons.  Note that TCP_MAXSEG socket option enforces a minimal value of (TCP_MIN_MSS). David Miller increased this minimal value in commit c39508d6f118 (\"tcp: Make TCP_MAXSEG minimum more correct.\") from 64 to 88.  We might in the future merge TCP_MIN_SND_MSS and TCP_MIN_MSS.  CVE-2019-11479 -- tcp mss hardcoded to 48  Suggested-by: Jonathan Looney <jtl@netflix.com> Cc: Yuchung Cheng <ycheng@google.com> Cc: Tyler Hicks <tyhicks@canonical.com> Cc: Bruce Curtis <brucec@netflix.com> Cc: Jonathan Lemon <jonathan.lemon@gmail.com> ",
        "func_before": "static int __net_init tcp_sk_init(struct net *net)\n{\n\tint res, cpu, cnt;\n\n\tnet->ipv4.tcp_sk = alloc_percpu(struct sock *);\n\tif (!net->ipv4.tcp_sk)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct sock *sk;\n\n\t\tres = inet_ctl_sock_create(&sk, PF_INET, SOCK_RAW,\n\t\t\t\t\t   IPPROTO_TCP, net);\n\t\tif (res)\n\t\t\tgoto fail;\n\t\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\n\t\t/* Please enforce IP_DF and IPID==0 for RST and\n\t\t * ACK sent in SYN-RECV and TIME-WAIT state.\n\t\t */\n\t\tinet_sk(sk)->pmtudisc = IP_PMTUDISC_DO;\n\n\t\t*per_cpu_ptr(net->ipv4.tcp_sk, cpu) = sk;\n\t}\n\n\tnet->ipv4.sysctl_tcp_ecn = 2;\n\tnet->ipv4.sysctl_tcp_ecn_fallback = 1;\n\n\tnet->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;\n\tnet->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;\n\tnet->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;\n\n\tnet->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;\n\tnet->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;\n\tnet->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;\n\n\tnet->ipv4.sysctl_tcp_syn_retries = TCP_SYN_RETRIES;\n\tnet->ipv4.sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES;\n\tnet->ipv4.sysctl_tcp_syncookies = 1;\n\tnet->ipv4.sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;\n\tnet->ipv4.sysctl_tcp_retries1 = TCP_RETR1;\n\tnet->ipv4.sysctl_tcp_retries2 = TCP_RETR2;\n\tnet->ipv4.sysctl_tcp_orphan_retries = 0;\n\tnet->ipv4.sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;\n\tnet->ipv4.sysctl_tcp_notsent_lowat = UINT_MAX;\n\tnet->ipv4.sysctl_tcp_tw_reuse = 2;\n\n\tcnt = tcp_hashinfo.ehash_mask + 1;\n\tnet->ipv4.tcp_death_row.sysctl_max_tw_buckets = cnt / 2;\n\tnet->ipv4.tcp_death_row.hashinfo = &tcp_hashinfo;\n\n\tnet->ipv4.sysctl_max_syn_backlog = max(128, cnt / 256);\n\tnet->ipv4.sysctl_tcp_sack = 1;\n\tnet->ipv4.sysctl_tcp_window_scaling = 1;\n\tnet->ipv4.sysctl_tcp_timestamps = 1;\n\tnet->ipv4.sysctl_tcp_early_retrans = 3;\n\tnet->ipv4.sysctl_tcp_recovery = TCP_RACK_LOSS_DETECTION;\n\tnet->ipv4.sysctl_tcp_slow_start_after_idle = 1; /* By default, RFC2861 behavior.  */\n\tnet->ipv4.sysctl_tcp_retrans_collapse = 1;\n\tnet->ipv4.sysctl_tcp_max_reordering = 300;\n\tnet->ipv4.sysctl_tcp_dsack = 1;\n\tnet->ipv4.sysctl_tcp_app_win = 31;\n\tnet->ipv4.sysctl_tcp_adv_win_scale = 1;\n\tnet->ipv4.sysctl_tcp_frto = 2;\n\tnet->ipv4.sysctl_tcp_moderate_rcvbuf = 1;\n\t/* This limits the percentage of the congestion window which we\n\t * will allow a single TSO frame to consume.  Building TSO frames\n\t * which are too large can cause TCP streams to be bursty.\n\t */\n\tnet->ipv4.sysctl_tcp_tso_win_divisor = 3;\n\t/* Default TSQ limit of 16 TSO segments */\n\tnet->ipv4.sysctl_tcp_limit_output_bytes = 16 * 65536;\n\t/* rfc5961 challenge ack rate limiting */\n\tnet->ipv4.sysctl_tcp_challenge_ack_limit = 1000;\n\tnet->ipv4.sysctl_tcp_min_tso_segs = 2;\n\tnet->ipv4.sysctl_tcp_min_rtt_wlen = 300;\n\tnet->ipv4.sysctl_tcp_autocorking = 1;\n\tnet->ipv4.sysctl_tcp_invalid_ratelimit = HZ/2;\n\tnet->ipv4.sysctl_tcp_pacing_ss_ratio = 200;\n\tnet->ipv4.sysctl_tcp_pacing_ca_ratio = 120;\n\tif (net != &init_net) {\n\t\tmemcpy(net->ipv4.sysctl_tcp_rmem,\n\t\t       init_net.ipv4.sysctl_tcp_rmem,\n\t\t       sizeof(init_net.ipv4.sysctl_tcp_rmem));\n\t\tmemcpy(net->ipv4.sysctl_tcp_wmem,\n\t\t       init_net.ipv4.sysctl_tcp_wmem,\n\t\t       sizeof(init_net.ipv4.sysctl_tcp_wmem));\n\t}\n\tnet->ipv4.sysctl_tcp_comp_sack_delay_ns = NSEC_PER_MSEC;\n\tnet->ipv4.sysctl_tcp_comp_sack_nr = 44;\n\tnet->ipv4.sysctl_tcp_fastopen = TFO_CLIENT_ENABLE;\n\tspin_lock_init(&net->ipv4.tcp_fastopen_ctx_lock);\n\tnet->ipv4.sysctl_tcp_fastopen_blackhole_timeout = 60 * 60;\n\tatomic_set(&net->ipv4.tfo_active_disable_times, 0);\n\n\t/* Reno is always built in */\n\tif (!net_eq(net, &init_net) &&\n\t    try_module_get(init_net.ipv4.tcp_congestion_control->owner))\n\t\tnet->ipv4.tcp_congestion_control = init_net.ipv4.tcp_congestion_control;\n\telse\n\t\tnet->ipv4.tcp_congestion_control = &tcp_reno;\n\n\treturn 0;\nfail:\n\ttcp_sk_exit(net);\n\n\treturn res;\n}",
        "func": "static int __net_init tcp_sk_init(struct net *net)\n{\n\tint res, cpu, cnt;\n\n\tnet->ipv4.tcp_sk = alloc_percpu(struct sock *);\n\tif (!net->ipv4.tcp_sk)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct sock *sk;\n\n\t\tres = inet_ctl_sock_create(&sk, PF_INET, SOCK_RAW,\n\t\t\t\t\t   IPPROTO_TCP, net);\n\t\tif (res)\n\t\t\tgoto fail;\n\t\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\n\t\t/* Please enforce IP_DF and IPID==0 for RST and\n\t\t * ACK sent in SYN-RECV and TIME-WAIT state.\n\t\t */\n\t\tinet_sk(sk)->pmtudisc = IP_PMTUDISC_DO;\n\n\t\t*per_cpu_ptr(net->ipv4.tcp_sk, cpu) = sk;\n\t}\n\n\tnet->ipv4.sysctl_tcp_ecn = 2;\n\tnet->ipv4.sysctl_tcp_ecn_fallback = 1;\n\n\tnet->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;\n\tnet->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;\n\tnet->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;\n\tnet->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;\n\n\tnet->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;\n\tnet->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;\n\tnet->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;\n\n\tnet->ipv4.sysctl_tcp_syn_retries = TCP_SYN_RETRIES;\n\tnet->ipv4.sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES;\n\tnet->ipv4.sysctl_tcp_syncookies = 1;\n\tnet->ipv4.sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;\n\tnet->ipv4.sysctl_tcp_retries1 = TCP_RETR1;\n\tnet->ipv4.sysctl_tcp_retries2 = TCP_RETR2;\n\tnet->ipv4.sysctl_tcp_orphan_retries = 0;\n\tnet->ipv4.sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;\n\tnet->ipv4.sysctl_tcp_notsent_lowat = UINT_MAX;\n\tnet->ipv4.sysctl_tcp_tw_reuse = 2;\n\n\tcnt = tcp_hashinfo.ehash_mask + 1;\n\tnet->ipv4.tcp_death_row.sysctl_max_tw_buckets = cnt / 2;\n\tnet->ipv4.tcp_death_row.hashinfo = &tcp_hashinfo;\n\n\tnet->ipv4.sysctl_max_syn_backlog = max(128, cnt / 256);\n\tnet->ipv4.sysctl_tcp_sack = 1;\n\tnet->ipv4.sysctl_tcp_window_scaling = 1;\n\tnet->ipv4.sysctl_tcp_timestamps = 1;\n\tnet->ipv4.sysctl_tcp_early_retrans = 3;\n\tnet->ipv4.sysctl_tcp_recovery = TCP_RACK_LOSS_DETECTION;\n\tnet->ipv4.sysctl_tcp_slow_start_after_idle = 1; /* By default, RFC2861 behavior.  */\n\tnet->ipv4.sysctl_tcp_retrans_collapse = 1;\n\tnet->ipv4.sysctl_tcp_max_reordering = 300;\n\tnet->ipv4.sysctl_tcp_dsack = 1;\n\tnet->ipv4.sysctl_tcp_app_win = 31;\n\tnet->ipv4.sysctl_tcp_adv_win_scale = 1;\n\tnet->ipv4.sysctl_tcp_frto = 2;\n\tnet->ipv4.sysctl_tcp_moderate_rcvbuf = 1;\n\t/* This limits the percentage of the congestion window which we\n\t * will allow a single TSO frame to consume.  Building TSO frames\n\t * which are too large can cause TCP streams to be bursty.\n\t */\n\tnet->ipv4.sysctl_tcp_tso_win_divisor = 3;\n\t/* Default TSQ limit of 16 TSO segments */\n\tnet->ipv4.sysctl_tcp_limit_output_bytes = 16 * 65536;\n\t/* rfc5961 challenge ack rate limiting */\n\tnet->ipv4.sysctl_tcp_challenge_ack_limit = 1000;\n\tnet->ipv4.sysctl_tcp_min_tso_segs = 2;\n\tnet->ipv4.sysctl_tcp_min_rtt_wlen = 300;\n\tnet->ipv4.sysctl_tcp_autocorking = 1;\n\tnet->ipv4.sysctl_tcp_invalid_ratelimit = HZ/2;\n\tnet->ipv4.sysctl_tcp_pacing_ss_ratio = 200;\n\tnet->ipv4.sysctl_tcp_pacing_ca_ratio = 120;\n\tif (net != &init_net) {\n\t\tmemcpy(net->ipv4.sysctl_tcp_rmem,\n\t\t       init_net.ipv4.sysctl_tcp_rmem,\n\t\t       sizeof(init_net.ipv4.sysctl_tcp_rmem));\n\t\tmemcpy(net->ipv4.sysctl_tcp_wmem,\n\t\t       init_net.ipv4.sysctl_tcp_wmem,\n\t\t       sizeof(init_net.ipv4.sysctl_tcp_wmem));\n\t}\n\tnet->ipv4.sysctl_tcp_comp_sack_delay_ns = NSEC_PER_MSEC;\n\tnet->ipv4.sysctl_tcp_comp_sack_nr = 44;\n\tnet->ipv4.sysctl_tcp_fastopen = TFO_CLIENT_ENABLE;\n\tspin_lock_init(&net->ipv4.tcp_fastopen_ctx_lock);\n\tnet->ipv4.sysctl_tcp_fastopen_blackhole_timeout = 60 * 60;\n\tatomic_set(&net->ipv4.tfo_active_disable_times, 0);\n\n\t/* Reno is always built in */\n\tif (!net_eq(net, &init_net) &&\n\t    try_module_get(init_net.ipv4.tcp_congestion_control->owner))\n\t\tnet->ipv4.tcp_congestion_control = init_net.ipv4.tcp_congestion_control;\n\telse\n\t\tnet->ipv4.tcp_congestion_control = &tcp_reno;\n\n\treturn 0;\nfail:\n\ttcp_sk_exit(net);\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,7 @@\n \tnet->ipv4.sysctl_tcp_ecn_fallback = 1;\n \n \tnet->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;\n+\tnet->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;\n \tnet->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;\n \tnet->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tnet->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11479",
        "func_name": "kernel/git/netdev/net/__tcp_mtu_to_mss",
        "description": "Jonathan Looney discovered that the Linux kernel default MSS is hard-coded to 48 bytes. This allows a remote peer to fragment TCP resend queues significantly more than if a larger MSS were enforced. A remote attacker could use this to cause a denial of service. This has been fixed in stable kernel releases 4.4.182, 4.9.182, 4.14.127, 4.19.52, 5.1.11, and is fixed in commits 967c05aee439e6e5d7d805e195b3a20ef5c433d6 and 5f3e2bf008c2221478101ee72f5cb4654b9fc363.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=5f3e2bf008c2221478101ee72f5cb4654b9fc363",
        "commit_title": "Some TCP peers announce a very small MSS option in their SYN and/or",
        "commit_text": "SYN/ACK messages.  This forces the stack to send packets with a very high network/cpu overhead.  Linux has enforced a minimal value of 48. Since this value includes the size of TCP options, and that the options can consume up to 40 bytes, this means that each segment can include only 8 bytes of payload.  In some cases, it can be useful to increase the minimal value to a saner value.  We still let the default to 48 (TCP_MIN_SND_MSS), for compatibility reasons.  Note that TCP_MAXSEG socket option enforces a minimal value of (TCP_MIN_MSS). David Miller increased this minimal value in commit c39508d6f118 (\"tcp: Make TCP_MAXSEG minimum more correct.\") from 64 to 88.  We might in the future merge TCP_MIN_SND_MSS and TCP_MIN_MSS.  CVE-2019-11479 -- tcp mss hardcoded to 48  Suggested-by: Jonathan Looney <jtl@netflix.com> Cc: Yuchung Cheng <ycheng@google.com> Cc: Tyler Hicks <tyhicks@canonical.com> Cc: Bruce Curtis <brucec@netflix.com> Cc: Jonathan Lemon <jonathan.lemon@gmail.com> ",
        "func_before": "static inline int __tcp_mtu_to_mss(struct sock *sk, int pmtu)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tint mss_now;\n\n\t/* Calculate base mss without TCP options:\n\t   It is MMS_S - sizeof(tcphdr) of rfc1122\n\t */\n\tmss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);\n\n\t/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set */\n\tif (icsk->icsk_af_ops->net_frag_header_len) {\n\t\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\n\t\tif (dst && dst_allfrag(dst))\n\t\t\tmss_now -= icsk->icsk_af_ops->net_frag_header_len;\n\t}\n\n\t/* Clamp it (mss_clamp does not include tcp options) */\n\tif (mss_now > tp->rx_opt.mss_clamp)\n\t\tmss_now = tp->rx_opt.mss_clamp;\n\n\t/* Now subtract optional transport overhead */\n\tmss_now -= icsk->icsk_ext_hdr_len;\n\n\t/* Then reserve room for full set of TCP options and 8 bytes of data */\n\tif (mss_now < TCP_MIN_SND_MSS)\n\t\tmss_now = TCP_MIN_SND_MSS;\n\treturn mss_now;\n}",
        "func": "static inline int __tcp_mtu_to_mss(struct sock *sk, int pmtu)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tint mss_now;\n\n\t/* Calculate base mss without TCP options:\n\t   It is MMS_S - sizeof(tcphdr) of rfc1122\n\t */\n\tmss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);\n\n\t/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set */\n\tif (icsk->icsk_af_ops->net_frag_header_len) {\n\t\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\n\t\tif (dst && dst_allfrag(dst))\n\t\t\tmss_now -= icsk->icsk_af_ops->net_frag_header_len;\n\t}\n\n\t/* Clamp it (mss_clamp does not include tcp options) */\n\tif (mss_now > tp->rx_opt.mss_clamp)\n\t\tmss_now = tp->rx_opt.mss_clamp;\n\n\t/* Now subtract optional transport overhead */\n\tmss_now -= icsk->icsk_ext_hdr_len;\n\n\t/* Then reserve room for full set of TCP options and 8 bytes of data */\n\tmss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);\n\treturn mss_now;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,6 @@\n \tmss_now -= icsk->icsk_ext_hdr_len;\n \n \t/* Then reserve room for full set of TCP options and 8 bytes of data */\n-\tif (mss_now < TCP_MIN_SND_MSS)\n-\t\tmss_now = TCP_MIN_SND_MSS;\n+\tmss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);\n \treturn mss_now;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (mss_now < TCP_MIN_SND_MSS)",
                "\t\tmss_now = TCP_MIN_SND_MSS;"
            ],
            "added_lines": [
                "\tmss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11479",
        "func_name": "kernel/git/netdev/net/tcp_mtu_probing",
        "description": "Jonathan Looney discovered that the Linux kernel default MSS is hard-coded to 48 bytes. This allows a remote peer to fragment TCP resend queues significantly more than if a larger MSS were enforced. A remote attacker could use this to cause a denial of service. This has been fixed in stable kernel releases 4.4.182, 4.9.182, 4.14.127, 4.19.52, 5.1.11, and is fixed in commits 967c05aee439e6e5d7d805e195b3a20ef5c433d6 and 5f3e2bf008c2221478101ee72f5cb4654b9fc363.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=967c05aee439e6e5d7d805e195b3a20ef5c433d6",
        "commit_title": "If mtu probing is enabled tcp_mtu_probing() could very well end up",
        "commit_text": "with a too small MSS.  Use the new sysctl tcp_min_snd_mss to make sure MSS search is performed in an acceptable range.  CVE-2019-11479 -- tcp mss hardcoded to 48  Cc: Jonathan Looney <jtl@netflix.com> Cc: Yuchung Cheng <ycheng@google.com> Cc: Tyler Hicks <tyhicks@canonical.com> Cc: Bruce Curtis <brucec@netflix.com> ",
        "func_before": "static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)\n{\n\tconst struct net *net = sock_net(sk);\n\tint mss;\n\n\t/* Black hole detection */\n\tif (!net->ipv4.sysctl_tcp_mtu_probing)\n\t\treturn;\n\n\tif (!icsk->icsk_mtup.enabled) {\n\t\ticsk->icsk_mtup.enabled = 1;\n\t\ticsk->icsk_mtup.probe_timestamp = tcp_jiffies32;\n\t} else {\n\t\tmss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;\n\t\tmss = min(net->ipv4.sysctl_tcp_base_mss, mss);\n\t\tmss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);\n\t\ticsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);\n\t}\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n}",
        "func": "static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)\n{\n\tconst struct net *net = sock_net(sk);\n\tint mss;\n\n\t/* Black hole detection */\n\tif (!net->ipv4.sysctl_tcp_mtu_probing)\n\t\treturn;\n\n\tif (!icsk->icsk_mtup.enabled) {\n\t\ticsk->icsk_mtup.enabled = 1;\n\t\ticsk->icsk_mtup.probe_timestamp = tcp_jiffies32;\n\t} else {\n\t\tmss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;\n\t\tmss = min(net->ipv4.sysctl_tcp_base_mss, mss);\n\t\tmss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);\n\t\tmss = max(mss, net->ipv4.sysctl_tcp_min_snd_mss);\n\t\ticsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);\n\t}\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n \t\tmss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;\n \t\tmss = min(net->ipv4.sysctl_tcp_base_mss, mss);\n \t\tmss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);\n+\t\tmss = max(mss, net->ipv4.sysctl_tcp_min_snd_mss);\n \t\ticsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);\n \t}\n \ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tmss = max(mss, net->ipv4.sysctl_tcp_min_snd_mss);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11924",
        "func_name": "facebookincubator/fizz/ReadRecordLayer::readEvent",
        "description": "A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00.",
        "git_url": "https://github.com/facebookincubator/fizz/commit/3eaddb33619eaaf74a760872850c550ad8f5c52f",
        "commit_title": "Coalesce handshake buffers",
        "commit_text": " Summary: It is possible that a peer might send us records in a manner such that there is a 16KB record and only 1 byte of handshake message in each record. Since we normally just trim the IOBuf, we would end up holding 16K of data per actual byte of data. To prevent this we allocate a contiguous buffer to copy over these bytes for handshake messages for now.  This is a partial fix for CVE-2019-11924  Reviewed By: ngoyal  Differential Revision: D16478044  fbshipit-source-id: 464bc68eaefda065d9a327818100427377293fbd",
        "func_before": "folly::Optional<Param> ReadRecordLayer::readEvent(\n    folly::IOBufQueue& socketBuf) {\n  if (!unparsedHandshakeData_.empty()) {\n    auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n    if (param) {\n      VLOG(8) << \"Received handshake message \"\n              << toString(boost::apply_visitor(EventVisitor(), *param));\n      return param;\n    }\n  }\n\n  while (true) {\n    // Read one record. We read one record at a time since records could cause\n    // a change in the record layer.\n    auto message = read(socketBuf);\n    if (!message) {\n      return folly::none;\n    }\n\n    if (!unparsedHandshakeData_.empty() &&\n        message->type != ContentType::handshake) {\n      throw std::runtime_error(\"spliced handshake data\");\n    }\n\n    switch (message->type) {\n      case ContentType::alert: {\n        auto alert = decode<Alert>(std::move(message->fragment));\n        if (alert.description == AlertDescription::close_notify) {\n          return Param(CloseNotify(socketBuf.move()));\n        } else {\n          return Param(std::move(alert));\n        }\n      }\n      case ContentType::handshake: {\n        unparsedHandshakeData_.append(std::move(message->fragment));\n        auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n        if (param) {\n          VLOG(8) << \"Received handshake message \"\n                  << toString(boost::apply_visitor(EventVisitor(), *param));\n          return param;\n        } else {\n          // If we read handshake data but didn't have enough to get a full\n          // message we immediately try to read another record.\n          // TODO: add limits on number of records we buffer\n          continue;\n        }\n      }\n      case ContentType::application_data:\n        return Param(AppData(std::move(message->fragment)));\n      default:\n        throw std::runtime_error(\"unknown content type\");\n    }\n  }\n}",
        "func": "folly::Optional<Param> ReadRecordLayer::readEvent(\n    folly::IOBufQueue& socketBuf) {\n  if (!unparsedHandshakeData_.empty()) {\n    auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n    if (param) {\n      VLOG(8) << \"Received handshake message \"\n              << toString(boost::apply_visitor(EventVisitor(), *param));\n      return param;\n    }\n  }\n\n  while (true) {\n    // Read one record. We read one record at a time since records could cause\n    // a change in the record layer.\n    auto message = read(socketBuf);\n    if (!message) {\n      return folly::none;\n    }\n\n    if (!unparsedHandshakeData_.empty() &&\n        message->type != ContentType::handshake) {\n      throw std::runtime_error(\"spliced handshake data\");\n    }\n\n    switch (message->type) {\n      case ContentType::alert: {\n        auto alert = decode<Alert>(std::move(message->fragment));\n        if (alert.description == AlertDescription::close_notify) {\n          return Param(CloseNotify(socketBuf.move()));\n        } else {\n          return Param(std::move(alert));\n        }\n      }\n      case ContentType::handshake: {\n        std::unique_ptr<folly::IOBuf> handshakeMessage =\n            unparsedHandshakeData_.move();\n        // It is possible that a peer might send us records in a manner such\n        // that there is a 16KB record and only 1 byte of handshake message in\n        // each record. Since we normally just trim the IOBuf, we would end up\n        // holding 16K of data. To prevent this we allocate a contiguous\n        // buffer to copy over these bytes. We supply kExtraAlloc bytes in\n        // order to avoid needing to re-allocate a lot of times if we receive\n        // a lot of small messages. There might be more optimal reallocation\n        // policies, but this should be fine.\n        message->fragment->coalesce();\n        constexpr size_t kExtraAlloc = 1024;\n        if (!handshakeMessage) {\n          handshakeMessage =\n              folly::IOBuf::create(message->fragment->length() + kExtraAlloc);\n        } else if (handshakeMessage->tailroom() < message->fragment->length()) {\n          handshakeMessage->reserve(\n              0, message->fragment->length() + kExtraAlloc);\n        }\n        memcpy(\n            handshakeMessage->writableTail(),\n            message->fragment->data(),\n            message->fragment->length());\n        handshakeMessage->append(message->fragment->length());\n        unparsedHandshakeData_.append(std::move(handshakeMessage));\n        auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n        if (param) {\n          VLOG(8) << \"Received handshake message \"\n                  << toString(boost::apply_visitor(EventVisitor(), *param));\n          return param;\n        } else {\n          // If we read handshake data but didn't have enough to get a full\n          // message we immediately try to read another record.\n          // TODO: add limits on number of records we buffer\n          continue;\n        }\n      }\n      case ContentType::application_data:\n        return Param(AppData(std::move(message->fragment)));\n      default:\n        throw std::runtime_error(\"unknown content type\");\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,31 @@\n         }\n       }\n       case ContentType::handshake: {\n-        unparsedHandshakeData_.append(std::move(message->fragment));\n+        std::unique_ptr<folly::IOBuf> handshakeMessage =\n+            unparsedHandshakeData_.move();\n+        // It is possible that a peer might send us records in a manner such\n+        // that there is a 16KB record and only 1 byte of handshake message in\n+        // each record. Since we normally just trim the IOBuf, we would end up\n+        // holding 16K of data. To prevent this we allocate a contiguous\n+        // buffer to copy over these bytes. We supply kExtraAlloc bytes in\n+        // order to avoid needing to re-allocate a lot of times if we receive\n+        // a lot of small messages. There might be more optimal reallocation\n+        // policies, but this should be fine.\n+        message->fragment->coalesce();\n+        constexpr size_t kExtraAlloc = 1024;\n+        if (!handshakeMessage) {\n+          handshakeMessage =\n+              folly::IOBuf::create(message->fragment->length() + kExtraAlloc);\n+        } else if (handshakeMessage->tailroom() < message->fragment->length()) {\n+          handshakeMessage->reserve(\n+              0, message->fragment->length() + kExtraAlloc);\n+        }\n+        memcpy(\n+            handshakeMessage->writableTail(),\n+            message->fragment->data(),\n+            message->fragment->length());\n+        handshakeMessage->append(message->fragment->length());\n+        unparsedHandshakeData_.append(std::move(handshakeMessage));\n         auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n         if (param) {\n           VLOG(8) << \"Received handshake message \"",
        "diff_line_info": {
            "deleted_lines": [
                "        unparsedHandshakeData_.append(std::move(message->fragment));"
            ],
            "added_lines": [
                "        std::unique_ptr<folly::IOBuf> handshakeMessage =",
                "            unparsedHandshakeData_.move();",
                "        // It is possible that a peer might send us records in a manner such",
                "        // that there is a 16KB record and only 1 byte of handshake message in",
                "        // each record. Since we normally just trim the IOBuf, we would end up",
                "        // holding 16K of data. To prevent this we allocate a contiguous",
                "        // buffer to copy over these bytes. We supply kExtraAlloc bytes in",
                "        // order to avoid needing to re-allocate a lot of times if we receive",
                "        // a lot of small messages. There might be more optimal reallocation",
                "        // policies, but this should be fine.",
                "        message->fragment->coalesce();",
                "        constexpr size_t kExtraAlloc = 1024;",
                "        if (!handshakeMessage) {",
                "          handshakeMessage =",
                "              folly::IOBuf::create(message->fragment->length() + kExtraAlloc);",
                "        } else if (handshakeMessage->tailroom() < message->fragment->length()) {",
                "          handshakeMessage->reserve(",
                "              0, message->fragment->length() + kExtraAlloc);",
                "        }",
                "        memcpy(",
                "            handshakeMessage->writableTail(),",
                "            message->fragment->data(),",
                "            message->fragment->length());",
                "        handshakeMessage->append(message->fragment->length());",
                "        unparsedHandshakeData_.append(std::move(handshakeMessage));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11924",
        "func_name": "facebookincubator/fizz/EncryptedReadRecordLayer::read",
        "description": "A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00.",
        "git_url": "https://github.com/facebookincubator/fizz/commit/3eaddb33619eaaf74a760872850c550ad8f5c52f",
        "commit_title": "Coalesce handshake buffers",
        "commit_text": " Summary: It is possible that a peer might send us records in a manner such that there is a 16KB record and only 1 byte of handshake message in each record. Since we normally just trim the IOBuf, we would end up holding 16K of data per actual byte of data. To prevent this we allocate a contiguous buffer to copy over these bytes for handshake messages for now.  This is a partial fix for CVE-2019-11924  Reviewed By: ngoyal  Differential Revision: D16478044  fbshipit-source-id: 464bc68eaefda065d9a327818100427377293fbd",
        "func_before": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n\n  TLSMessage msg;\n  // Iterate over the buffers while trying to find\n  // the first non-zero octet. This is much faster than\n  // first iterating and then trimming.\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n\n  return msg;\n}",
        "func": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n\n  TLSMessage msg{};\n  // Iterate over the buffers while trying to find\n  // the first non-zero octet. This is much faster than\n  // first iterating and then trimming.\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n\n  return msg;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     return folly::none;\n   }\n \n-  TLSMessage msg;\n+  TLSMessage msg{};\n   // Iterate over the buffers while trying to find\n   // the first non-zero octet. This is much faster than\n   // first iterating and then trimming.",
        "diff_line_info": {
            "deleted_lines": [
                "  TLSMessage msg;"
            ],
            "added_lines": [
                "  TLSMessage msg{};"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11924",
        "func_name": "facebookincubator/fizz/EncryptedReadRecordLayer::read",
        "description": "A peer could send empty handshake fragments containing only padding which would be kept in memory until a full handshake was received, resulting in memory exhaustion. This issue affects versions v2019.01.28.00 and above of fizz, until v2019.08.05.00.",
        "git_url": "https://github.com/facebookincubator/fizz/commit/6bf67137ef1ee5cd70c842b014c322b7deaf994b",
        "commit_title": "Reject zero length handshake records.",
        "commit_text": " Summary: Zero length (all padding) handshake are forbidden by RFC. Allowing these was a regression in D13754697 (2c6f78a).  This is a partial fix for CVE-2019-11924  Reviewed By: xybu  Differential Revision: D16285100  fbshipit-source-id: 05a19d31ad74601ce89156a0e59517aaad8dd928",
        "func_before": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n\n  TLSMessage msg;\n  // Iterate over the buffers while trying to find\n  // the first non-zero octet. This is much faster than\n  // first iterating and then trimming.\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n\n  if (!msg.fragment) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n\n  return msg;\n}",
        "func": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n\n  TLSMessage msg;\n  // Iterate over the buffers while trying to find\n  // the first non-zero octet. This is much faster than\n  // first iterating and then trimming.\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n\n  return msg;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n           static_cast<ContentTypeType>(msg.type)));\n   }\n \n-  if (!msg.fragment) {\n+  if (!msg.fragment || msg.fragment->empty()) {\n     if (msg.type == ContentType::application_data) {\n       msg.fragment = folly::IOBuf::create(0);\n     } else {",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!msg.fragment) {"
            ],
            "added_lines": [
                "  if (!msg.fragment || msg.fragment->empty()) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15165",
        "func_name": "the-tcpdump-group/libpcap/read_bytes",
        "description": "sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.",
        "git_url": "https://github.com/the-tcpdump-group/libpcap/commit/87d6bef033062f969e70fa40c43dfd945d5a20ab",
        "commit_title": "do sanity checks on PHB header length before allocating memory. There was no fault; but doing the check results in a more consistent error",
        "commit_text": "",
        "func_before": "static int\nread_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t/* EOF */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}",
        "func": "static int\nread_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t/* EOF */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated pcapng dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \t\t\tif (amt_read == 0 && !fail_on_eof)\n \t\t\t\treturn (0);\t/* EOF */\n \t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n+\t\t\t    \"truncated pcapng dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n \t\t\t    bytes_to_read, amt_read);\n \t\t}\n \t\treturn (-1);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,"
            ],
            "added_lines": [
                "\t\t\t    \"truncated pcapng dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15165",
        "func_name": "the-tcpdump-group/libpcap/pcap_ng_check_header",
        "description": "sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.",
        "git_url": "https://github.com/the-tcpdump-group/libpcap/commit/87d6bef033062f969e70fa40c43dfd945d5a20ab",
        "commit_title": "do sanity checks on PHB header length before allocating memory. There was no fault; but doing the check results in a more consistent error",
        "commit_text": "",
        "func_before": "pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has a length of %u < %\" PRIsize,\n\t\t    total_length,\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Make sure it's not too big.\n\t */\n\tif (total_length > INITIAL_MAX_BLOCKSIZE) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"pcapng block size %u > maximum %u\",\n\t\t    total_length, INITIAL_MAX_BLOCKSIZE);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}",
        "func": "pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n                              total_length,\n                              BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -94,25 +94,19 @@\n \t/*\n \t * Check the sanity of the total length.\n \t */\n-\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {\n+\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n+            (total_length > BT_SHB_INSANE_MAX)) {\n \t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t    \"Section Header Block in pcapng dump file has a length of %u < %\" PRIsize,\n-\t\t    total_length,\n-\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));\n+\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n+                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n+                              total_length,\n+                              BT_SHB_INSANE_MAX);\n+\n \t\t*err = 1;\n \t\treturn (NULL);\n \t}\n \n-\t/*\n-\t * Make sure it's not too big.\n-\t */\n-\tif (total_length > INITIAL_MAX_BLOCKSIZE) {\n-\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t    \"pcapng block size %u > maximum %u\",\n-\t\t    total_length, INITIAL_MAX_BLOCKSIZE);\n-\t\t*err = 1;\n-\t\treturn (NULL);\n-\t}\n+\n \n \t/*\n \t * OK, this is a good pcapng file.",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {",
                "\t\t    \"Section Header Block in pcapng dump file has a length of %u < %\" PRIsize,",
                "\t\t    total_length,",
                "\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));",
                "\t/*",
                "\t * Make sure it's not too big.",
                "\t */",
                "\tif (total_length > INITIAL_MAX_BLOCKSIZE) {",
                "\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,",
                "\t\t    \"pcapng block size %u > maximum %u\",",
                "\t\t    total_length, INITIAL_MAX_BLOCKSIZE);",
                "\t\t*err = 1;",
                "\t\treturn (NULL);",
                "\t}"
            ],
            "added_lines": [
                "\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||",
                "            (total_length > BT_SHB_INSANE_MAX)) {",
                "\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",",
                "                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),",
                "                              total_length,",
                "                              BT_SHB_INSANE_MAX);",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15165",
        "func_name": "the-tcpdump-group/libpcap/pcap_ng_check_header",
        "description": "sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.",
        "git_url": "https://github.com/the-tcpdump-group/libpcap/commit/a5a36d9e82dde7265e38fe1f87b7f11c461c29f6",
        "commit_title": "Fix some format warnings.",
        "commit_text": "",
        "func_before": "pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n                              total_length,\n                              BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}",
        "func": "pcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%u_ < %u (BT_SHB_INSANE_MAX)\",\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n\t\t    total_length,\n\t\t    BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -97,10 +97,10 @@\n \tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n             (total_length > BT_SHB_INSANE_MAX)) {\n \t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n-                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n-                              total_length,\n-                              BT_SHB_INSANE_MAX);\n+\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%u_ < %u (BT_SHB_INSANE_MAX)\",\n+\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n+\t\t    total_length,\n+\t\t    BT_SHB_INSANE_MAX);\n \n \t\t*err = 1;\n \t\treturn (NULL);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",",
                "                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),",
                "                              total_length,",
                "                              BT_SHB_INSANE_MAX);"
            ],
            "added_lines": [
                "\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%u_ < %u (BT_SHB_INSANE_MAX)\",",
                "\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),",
                "\t\t    total_length,",
                "\t\t    BT_SHB_INSANE_MAX);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17351",
        "func_name": "torvalds/linux/add_ballooned_pages",
        "description": "An issue was discovered in drivers/xen/balloon.c in the Linux kernel before 5.2.3, as used in Xen through 4.12.x, allowing guest OS users to cause a denial of service because of unrestricted resource consumption during the mapping of guest memory, aka CID-6ef36ab967c7.",
        "git_url": "https://github.com/torvalds/linux/commit/6ef36ab967c71690ebe7e5ef997a8be4da3bc844",
        "commit_title": "xen: let alloc_xenballooned_pages() fail if not enough memory free",
        "commit_text": " commit a1078e821b605813b63bf6bca414a85f804d5c66 upstream.  Instead of trying to allocate pages with GFP_USER in add_ballooned_pages() check the available free memory via si_mem_available(). GFP_USER is far less limiting memory exhaustion than the test via si_mem_available().  This will avoid dom0 running out of memory due to excessive foreign page mappings especially on ARM and on x86 in PVH mode, as those don't have a pre-ballooned area which can be used for foreign mappings.  As the normal ballooning suffers from the same problem don't balloon down more than si_mem_available() pages in one iteration. At the same time limit the default maximum number of retries.  This is part of XSA-300. ",
        "func_before": "static int add_ballooned_pages(int nr_pages)\n{\n\tenum bp_state st;\n\n\tif (xen_hotplug_unpopulated) {\n\t\tst = reserve_additional_memory();\n\t\tif (st != BP_ECANCELED) {\n\t\t\tmutex_unlock(&balloon_mutex);\n\t\t\twait_event(balloon_wq,\n\t\t\t\t   !list_empty(&ballooned_pages));\n\t\t\tmutex_lock(&balloon_mutex);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tst = decrease_reservation(nr_pages, GFP_USER);\n\tif (st != BP_DONE)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "func": "static int add_ballooned_pages(int nr_pages)\n{\n\tenum bp_state st;\n\n\tif (xen_hotplug_unpopulated) {\n\t\tst = reserve_additional_memory();\n\t\tif (st != BP_ECANCELED) {\n\t\t\tmutex_unlock(&balloon_mutex);\n\t\t\twait_event(balloon_wq,\n\t\t\t\t   !list_empty(&ballooned_pages));\n\t\t\tmutex_lock(&balloon_mutex);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (si_mem_available() < nr_pages)\n\t\treturn -ENOMEM;\n\n\tst = decrease_reservation(nr_pages, GFP_USER);\n\tif (st != BP_DONE)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,9 @@\n \t\t}\n \t}\n \n+\tif (si_mem_available() < nr_pages)\n+\t\treturn -ENOMEM;\n+\n \tst = decrease_reservation(nr_pages, GFP_USER);\n \tif (st != BP_DONE)\n \t\treturn -ENOMEM;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (si_mem_available() < nr_pages)",
                "\t\treturn -ENOMEM;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17351",
        "func_name": "torvalds/linux/balloon_init",
        "description": "An issue was discovered in drivers/xen/balloon.c in the Linux kernel before 5.2.3, as used in Xen through 4.12.x, allowing guest OS users to cause a denial of service because of unrestricted resource consumption during the mapping of guest memory, aka CID-6ef36ab967c7.",
        "git_url": "https://github.com/torvalds/linux/commit/6ef36ab967c71690ebe7e5ef997a8be4da3bc844",
        "commit_title": "xen: let alloc_xenballooned_pages() fail if not enough memory free",
        "commit_text": " commit a1078e821b605813b63bf6bca414a85f804d5c66 upstream.  Instead of trying to allocate pages with GFP_USER in add_ballooned_pages() check the available free memory via si_mem_available(). GFP_USER is far less limiting memory exhaustion than the test via si_mem_available().  This will avoid dom0 running out of memory due to excessive foreign page mappings especially on ARM and on x86 in PVH mode, as those don't have a pre-ballooned area which can be used for foreign mappings.  As the normal ballooning suffers from the same problem don't balloon down more than si_mem_available() pages in one iteration. At the same time limit the default maximum number of retries.  This is part of XSA-300. ",
        "func_before": "static int __init balloon_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tpr_info(\"Initialising balloon driver\\n\");\n\n#ifdef CONFIG_XEN_PV\n\tballoon_stats.current_pages = xen_pv_domain()\n\t\t? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)\n\t\t: get_num_physpages();\n#else\n\tballoon_stats.current_pages = get_num_physpages();\n#endif\n\tballoon_stats.target_pages  = balloon_stats.current_pages;\n\tballoon_stats.balloon_low   = 0;\n\tballoon_stats.balloon_high  = 0;\n\tballoon_stats.total_pages   = balloon_stats.current_pages;\n\n\tballoon_stats.schedule_delay = 1;\n\tballoon_stats.max_schedule_delay = 32;\n\tballoon_stats.retry_count = 1;\n\tballoon_stats.max_retry_count = RETRY_UNLIMITED;\n\n#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n\tset_online_page_callback(&xen_online_page);\n\tregister_memory_notifier(&xen_memory_nb);\n\tregister_sysctl_table(xen_root);\n#endif\n\n#ifdef CONFIG_XEN_PV\n\t{\n\t\tint i;\n\n\t\t/*\n\t\t * Initialize the balloon with pages from the extra memory\n\t\t * regions (see arch/x86/xen/setup.c).\n\t\t */\n\t\tfor (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++)\n\t\t\tif (xen_extra_mem[i].n_pfns)\n\t\t\t\tballoon_add_region(xen_extra_mem[i].start_pfn,\n\t\t\t\t\t\t   xen_extra_mem[i].n_pfns);\n\t}\n#endif\n\n\t/* Init the xen-balloon driver. */\n\txen_balloon_init();\n\n\treturn 0;\n}",
        "func": "static int __init balloon_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tpr_info(\"Initialising balloon driver\\n\");\n\n#ifdef CONFIG_XEN_PV\n\tballoon_stats.current_pages = xen_pv_domain()\n\t\t? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)\n\t\t: get_num_physpages();\n#else\n\tballoon_stats.current_pages = get_num_physpages();\n#endif\n\tballoon_stats.target_pages  = balloon_stats.current_pages;\n\tballoon_stats.balloon_low   = 0;\n\tballoon_stats.balloon_high  = 0;\n\tballoon_stats.total_pages   = balloon_stats.current_pages;\n\n\tballoon_stats.schedule_delay = 1;\n\tballoon_stats.max_schedule_delay = 32;\n\tballoon_stats.retry_count = 1;\n\tballoon_stats.max_retry_count = 4;\n\n#ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n\tset_online_page_callback(&xen_online_page);\n\tregister_memory_notifier(&xen_memory_nb);\n\tregister_sysctl_table(xen_root);\n#endif\n\n#ifdef CONFIG_XEN_PV\n\t{\n\t\tint i;\n\n\t\t/*\n\t\t * Initialize the balloon with pages from the extra memory\n\t\t * regions (see arch/x86/xen/setup.c).\n\t\t */\n\t\tfor (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++)\n\t\t\tif (xen_extra_mem[i].n_pfns)\n\t\t\t\tballoon_add_region(xen_extra_mem[i].start_pfn,\n\t\t\t\t\t\t   xen_extra_mem[i].n_pfns);\n\t}\n#endif\n\n\t/* Init the xen-balloon driver. */\n\txen_balloon_init();\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n \tballoon_stats.schedule_delay = 1;\n \tballoon_stats.max_schedule_delay = 32;\n \tballoon_stats.retry_count = 1;\n-\tballoon_stats.max_retry_count = RETRY_UNLIMITED;\n+\tballoon_stats.max_retry_count = 4;\n \n #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n \tset_online_page_callback(&xen_online_page);",
        "diff_line_info": {
            "deleted_lines": [
                "\tballoon_stats.max_retry_count = RETRY_UNLIMITED;"
            ],
            "added_lines": [
                "\tballoon_stats.max_retry_count = 4;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17351",
        "func_name": "torvalds/linux/balloon_process",
        "description": "An issue was discovered in drivers/xen/balloon.c in the Linux kernel before 5.2.3, as used in Xen through 4.12.x, allowing guest OS users to cause a denial of service because of unrestricted resource consumption during the mapping of guest memory, aka CID-6ef36ab967c7.",
        "git_url": "https://github.com/torvalds/linux/commit/6ef36ab967c71690ebe7e5ef997a8be4da3bc844",
        "commit_title": "xen: let alloc_xenballooned_pages() fail if not enough memory free",
        "commit_text": " commit a1078e821b605813b63bf6bca414a85f804d5c66 upstream.  Instead of trying to allocate pages with GFP_USER in add_ballooned_pages() check the available free memory via si_mem_available(). GFP_USER is far less limiting memory exhaustion than the test via si_mem_available().  This will avoid dom0 running out of memory due to excessive foreign page mappings especially on ARM and on x86 in PVH mode, as those don't have a pre-ballooned area which can be used for foreign mappings.  As the normal ballooning suffers from the same problem don't balloon down more than si_mem_available() pages in one iteration. At the same time limit the default maximum number of retries.  This is part of XSA-300. ",
        "func_before": "static void balloon_process(struct work_struct *work)\n{\n\tenum bp_state state = BP_DONE;\n\tlong credit;\n\n\n\tdo {\n\t\tmutex_lock(&balloon_mutex);\n\n\t\tcredit = current_credit();\n\n\t\tif (credit > 0) {\n\t\t\tif (balloon_is_inflated())\n\t\t\t\tstate = increase_reservation(credit);\n\t\t\telse\n\t\t\t\tstate = reserve_additional_memory();\n\t\t}\n\n\t\tif (credit < 0)\n\t\t\tstate = decrease_reservation(-credit, GFP_BALLOON);\n\n\t\tstate = update_schedule(state);\n\n\t\tmutex_unlock(&balloon_mutex);\n\n\t\tcond_resched();\n\n\t} while (credit && state == BP_DONE);\n\n\t/* Schedule more work if there is some still to be done. */\n\tif (state == BP_EAGAIN)\n\t\tschedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);\n}",
        "func": "static void balloon_process(struct work_struct *work)\n{\n\tenum bp_state state = BP_DONE;\n\tlong credit;\n\n\n\tdo {\n\t\tmutex_lock(&balloon_mutex);\n\n\t\tcredit = current_credit();\n\n\t\tif (credit > 0) {\n\t\t\tif (balloon_is_inflated())\n\t\t\t\tstate = increase_reservation(credit);\n\t\t\telse\n\t\t\t\tstate = reserve_additional_memory();\n\t\t}\n\n\t\tif (credit < 0) {\n\t\t\tlong n_pages;\n\n\t\t\tn_pages = min(-credit, si_mem_available());\n\t\t\tstate = decrease_reservation(n_pages, GFP_BALLOON);\n\t\t\tif (state == BP_DONE && n_pages != -credit &&\n\t\t\t    n_pages < totalreserve_pages)\n\t\t\t\tstate = BP_EAGAIN;\n\t\t}\n\n\t\tstate = update_schedule(state);\n\n\t\tmutex_unlock(&balloon_mutex);\n\n\t\tcond_resched();\n\n\t} while (credit && state == BP_DONE);\n\n\t/* Schedule more work if there is some still to be done. */\n\tif (state == BP_EAGAIN)\n\t\tschedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,8 +16,15 @@\n \t\t\t\tstate = reserve_additional_memory();\n \t\t}\n \n-\t\tif (credit < 0)\n-\t\t\tstate = decrease_reservation(-credit, GFP_BALLOON);\n+\t\tif (credit < 0) {\n+\t\t\tlong n_pages;\n+\n+\t\t\tn_pages = min(-credit, si_mem_available());\n+\t\t\tstate = decrease_reservation(n_pages, GFP_BALLOON);\n+\t\t\tif (state == BP_DONE && n_pages != -credit &&\n+\t\t\t    n_pages < totalreserve_pages)\n+\t\t\t\tstate = BP_EAGAIN;\n+\t\t}\n \n \t\tstate = update_schedule(state);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (credit < 0)",
                "\t\t\tstate = decrease_reservation(-credit, GFP_BALLOON);"
            ],
            "added_lines": [
                "\t\tif (credit < 0) {",
                "\t\t\tlong n_pages;",
                "",
                "\t\t\tn_pages = min(-credit, si_mem_available());",
                "\t\t\tstate = decrease_reservation(n_pages, GFP_BALLOON);",
                "\t\t\tif (state == BP_DONE && n_pages != -credit &&",
                "\t\t\t    n_pages < totalreserve_pages)",
                "\t\t\t\tstate = BP_EAGAIN;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21732",
        "func_name": "tensorflow/PrivateThreadPoolDatasetOp::MakeDatasetFromOptions",
        "description": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `ThreadPoolHandle` can be used to trigger a denial of service attack by allocating too much memory. This is because the `num_threads` argument is only checked to not be negative, but there is no upper bound on its value. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/e3749a6d5d1e8d11806d4a2e9cc3123d1a90b75e",
        "commit_title": "[tf.data] Set limit on number of threads used in threadpool_dataset.",
        "commit_text": " PiperOrigin-RevId: 410922677",
        "func_before": "void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}",
        "func": "void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,7 @@\n                                                         DatasetBase* input,\n                                                         int32_t num_threads,\n                                                         DatasetBase** output) {\n-  OP_REQUIRES(ctx, num_threads >= 0,\n-              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n+  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n   *output = new Dataset(ctx,\n                         DatasetContext(DatasetContext::Params(\n                             {PrivateThreadPoolDatasetOp::kDatasetType,",
        "diff_line_info": {
            "deleted_lines": [
                "  OP_REQUIRES(ctx, num_threads >= 0,",
                "              errors::InvalidArgument(\"`num_threads` must be >= 0\"));"
            ],
            "added_lines": [
                "  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21732",
        "func_name": "tensorflow/ThreadPoolHandleOp",
        "description": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `ThreadPoolHandle` can be used to trigger a denial of service attack by allocating too much memory. This is because the `num_threads` argument is only checked to not be negative, but there is no upper bound on its value. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/e3749a6d5d1e8d11806d4a2e9cc3123d1a90b75e",
        "commit_title": "[tf.data] Set limit on number of threads used in threadpool_dataset.",
        "commit_text": " PiperOrigin-RevId: 410922677",
        "func_before": "explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES(\n        ctx, num_threads_ > 0,\n        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n  }",
        "func": "explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads_));\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,5 @@\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n     OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                      &max_intra_op_parallelism_));\n-    OP_REQUIRES(\n-        ctx, num_threads_ > 0,\n-        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n+    OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads_));\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "    OP_REQUIRES(",
                "        ctx, num_threads_ > 0,",
                "        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));"
            ],
            "added_lines": [
                "    OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads_));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21732",
        "func_name": "tensorflow/PrivateThreadPoolDatasetOp::MakeDataset",
        "description": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `ThreadPoolHandle` can be used to trigger a denial of service attack by allocating too much memory. This is because the `num_threads` argument is only checked to not be negative, but there is no upper bound on its value. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/e3749a6d5d1e8d11806d4a2e9cc3123d1a90b75e",
        "commit_title": "[tf.data] Set limit on number of threads used in threadpool_dataset.",
        "commit_text": " PiperOrigin-RevId: 410922677",
        "func_before": "void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx, input, num_threads);\n}",
        "func": "void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n  *output = new Dataset(ctx, input, num_threads);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,6 @@\n   int64_t num_threads = 0;\n   OP_REQUIRES_OK(\n       ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n-  OP_REQUIRES(ctx, num_threads >= 0,\n-              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n+  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n   *output = new Dataset(ctx, input, num_threads);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  OP_REQUIRES(ctx, num_threads >= 0,",
                "              errors::InvalidArgument(\"`num_threads` must be >= 0\"));"
            ],
            "added_lines": [
                "  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-38155",
        "func_name": "Samsung/mTower/tee_user_mem_realloc",
        "description": "TEE_Malloc in Samsung mTower through 0.3.0 allows a trusted application to achieve Excessive Memory Allocation via a large len value, as demonstrated by a Numaker-PFM-M2351 TEE kernel crash.",
        "git_url": "https://github.com/Samsung/mTower/commit/236357f0e756f0fd2120a1a78cf573765471e088",
        "commit_title": "Fixed CVE-2022-38155, CVE-2022-40762",
        "commit_text": "",
        "func_before": "void *tee_user_mem_realloc(void *buffer, size_t len)\n{\n//  return utee_realloc(buffer, len);\n  return realloc(buffer, len);\n}",
        "func": "void *tee_user_mem_realloc(void *buffer, size_t len)\n{\n\tuint8_t *p;\n\tvoid* limit = &__HeapLimit;\n\tvoid* base = &__HeapBase;\n\n\tif ((limit - base)/2 < len + 8)\n\t\treturn NULL;\n\tp = realloc(buffer, len);\n\tif ( base + ((limit - base)/2) < p + len) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n//   return utee_realloc(buffer, len);\n\treturn p;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,16 @@\n void *tee_user_mem_realloc(void *buffer, size_t len)\n {\n-//  return utee_realloc(buffer, len);\n-  return realloc(buffer, len);\n+\tuint8_t *p;\n+\tvoid* limit = &__HeapLimit;\n+\tvoid* base = &__HeapBase;\n+\n+\tif ((limit - base)/2 < len + 8)\n+\t\treturn NULL;\n+\tp = realloc(buffer, len);\n+\tif ( base + ((limit - base)/2) < p + len) {\n+\t\tfree(p);\n+\t\treturn NULL;\n+\t}\n+//   return utee_realloc(buffer, len);\n+\treturn p;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "//  return utee_realloc(buffer, len);",
                "  return realloc(buffer, len);"
            ],
            "added_lines": [
                "\tuint8_t *p;",
                "\tvoid* limit = &__HeapLimit;",
                "\tvoid* base = &__HeapBase;",
                "",
                "\tif ((limit - base)/2 < len + 8)",
                "\t\treturn NULL;",
                "\tp = realloc(buffer, len);",
                "\tif ( base + ((limit - base)/2) < p + len) {",
                "\t\tfree(p);",
                "\t\treturn NULL;",
                "\t}",
                "//   return utee_realloc(buffer, len);",
                "\treturn p;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-38155",
        "func_name": "Samsung/mTower/tee_user_mem_free",
        "description": "TEE_Malloc in Samsung mTower through 0.3.0 allows a trusted application to achieve Excessive Memory Allocation via a large len value, as demonstrated by a Numaker-PFM-M2351 TEE kernel crash.",
        "git_url": "https://github.com/Samsung/mTower/commit/236357f0e756f0fd2120a1a78cf573765471e088",
        "commit_title": "Fixed CVE-2022-38155, CVE-2022-40762",
        "commit_text": "",
        "func_before": "void tee_user_mem_free(void *buffer)\n{\n  free(buffer);\n//  utee_free(buffer);\n}",
        "func": "void tee_user_mem_free(void *buffer)\n{\n\tfree(buffer);\n//  utee_free(buffer);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n void tee_user_mem_free(void *buffer)\n {\n-  free(buffer);\n+\tfree(buffer);\n //  utee_free(buffer);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  free(buffer);"
            ],
            "added_lines": [
                "\tfree(buffer);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-38155",
        "func_name": "Samsung/mTower/tee_user_mem_alloc",
        "description": "TEE_Malloc in Samsung mTower through 0.3.0 allows a trusted application to achieve Excessive Memory Allocation via a large len value, as demonstrated by a Numaker-PFM-M2351 TEE kernel crash.",
        "git_url": "https://github.com/Samsung/mTower/commit/236357f0e756f0fd2120a1a78cf573765471e088",
        "commit_title": "Fixed CVE-2022-38155, CVE-2022-40762",
        "commit_text": "",
        "func_before": "void *tee_user_mem_alloc(size_t len, uint32_t hint)\n{\n\tuint8_t *p;\n\n\tswitch (hint) {\n\tcase TEE_MALLOC_FILL_ZERO:\n\tcase TEE_USER_MEM_HINT_NO_FILL_ZERO:\n\t\tbreak;\n\tdefault:\n\t\tEMSG(\"Invalid alloc hint [%X]\", (unsigned int)hint);\n\t\treturn NULL;\n\t}\n\n\t//  p = utee_malloc(len);\n\tp = malloc(len);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tif (hint == TEE_MALLOC_FILL_ZERO)\n\t\tmemset(p, 0, len);\n#if (CFG_TEE_CORE_USER_MEM_DEBUG == 1)\n\tif (hint == (typeof(hint)) TEE_USER_MEM_HINT_NO_FILL_ZERO)\n\t\tmemset(p, 0xBB, len);\n#endif\n\treturn p;\n}",
        "func": "void *tee_user_mem_alloc(size_t len, uint32_t hint)\n{\n\tuint8_t *p;\n\tvoid* limit = &__HeapLimit;\n\tvoid* base = &__HeapBase;\n\n\tswitch (hint) {\n\tcase TEE_MALLOC_FILL_ZERO:\n\tcase TEE_USER_MEM_HINT_NO_FILL_ZERO:\n\t\tbreak;\n\tdefault:\n\t\tEMSG(\"Invalid alloc hint [%X]\", (unsigned int)hint);\n\t\treturn NULL;\n\t}\n\t// printf(\"malloc = base = %x\\n\", base );\n\t// printf(\"malloc = (limit - base)/2 = %x\\n\", (limit - base)/2 );\n\tif ((limit - base)/2 < len + 8)\n\t\treturn NULL;\n\t//  p = utee_malloc(len);\n\tp = malloc(len);\n\t// printf(\"malloc 1 = base + ((limit - base)/2) = %x\\n\", base + ((limit - base)/2) );\n\t// printf(\"malloc 2 = p + len = %x\\n\", p + len );\n\tif ( base + ((limit - base)/2) < p + len) {\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tif (hint == TEE_MALLOC_FILL_ZERO)\n\t\tmemset(p, 0, len);\n#if (CFG_TEE_CORE_USER_MEM_DEBUG == 1)\n\tif (hint == (typeof(hint)) TEE_USER_MEM_HINT_NO_FILL_ZERO)\n\t\tmemset(p, 0xBB, len);\n#endif\n\treturn p;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n void *tee_user_mem_alloc(size_t len, uint32_t hint)\n {\n \tuint8_t *p;\n+\tvoid* limit = &__HeapLimit;\n+\tvoid* base = &__HeapBase;\n \n \tswitch (hint) {\n \tcase TEE_MALLOC_FILL_ZERO:\n@@ -10,9 +12,18 @@\n \t\tEMSG(\"Invalid alloc hint [%X]\", (unsigned int)hint);\n \t\treturn NULL;\n \t}\n-\n+\t// printf(\"malloc = base = %x\\n\", base );\n+\t// printf(\"malloc = (limit - base)/2 = %x\\n\", (limit - base)/2 );\n+\tif ((limit - base)/2 < len + 8)\n+\t\treturn NULL;\n \t//  p = utee_malloc(len);\n \tp = malloc(len);\n+\t// printf(\"malloc 1 = base + ((limit - base)/2) = %x\\n\", base + ((limit - base)/2) );\n+\t// printf(\"malloc 2 = p + len = %x\\n\", p + len );\n+\tif ( base + ((limit - base)/2) < p + len) {\n+\t\tfree(p);\n+\t\treturn NULL;\n+\t}\n \tif (p == NULL)\n \t\treturn NULL;\n ",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "\tvoid* limit = &__HeapLimit;",
                "\tvoid* base = &__HeapBase;",
                "\t// printf(\"malloc = base = %x\\n\", base );",
                "\t// printf(\"malloc = (limit - base)/2 = %x\\n\", (limit - base)/2 );",
                "\tif ((limit - base)/2 < len + 8)",
                "\t\treturn NULL;",
                "\t// printf(\"malloc 1 = base + ((limit - base)/2) = %x\\n\", base + ((limit - base)/2) );",
                "\t// printf(\"malloc 2 = p + len = %x\\n\", p + len );",
                "\tif ( base + ((limit - base)/2) < p + len) {",
                "\t\tfree(p);",
                "\t\treturn NULL;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0480",
        "func_name": "torvalds/linux/filelock_init",
        "description": "A flaw was found in the filelock_init in fs/locks.c function in the Linux kernel. This issue can lead to host memory exhaustion due to memcg not limiting the number of Portable Operating System Interface (POSIX) file locks.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0f12156dff2862ac54235fc72703f18770769042",
        "commit_title": "User can create file locks for each open file and force kernel to allocate",
        "commit_text": "small but long-living objects per each open file.  It makes sense to account for these objects to limit the host's memory consumption from inside the memcg-limited container.  Link: https://lkml.kernel.org/r/b009f4c7-f0ab-c0ec-8e83-918f47d677da@virtuozzo.com Cc: Alexander Viro <viro@zeniv.linux.org.uk> Cc: Alexey Dobriyan <adobriyan@gmail.com> Cc: Andrei Vagin <avagin@gmail.com> Cc: Borislav Petkov <bp@alien8.de> Cc: Borislav Petkov <bp@suse.de> Cc: Christian Brauner <christian.brauner@ubuntu.com> Cc: Dmitry Safonov <0x7f454c46@gmail.com> Cc: \"Eric W. Biederman\" <ebiederm@xmission.com> Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org> Cc: \"H. Peter Anvin\" <hpa@zytor.com> Cc: Ingo Molnar <mingo@redhat.com> Cc: \"J. Bruce Fields\" <bfields@fieldses.org> Cc: Jeff Layton <jlayton@kernel.org> Cc: Jens Axboe <axboe@kernel.dk> Cc: Jiri Slaby <jirislaby@kernel.org> Cc: Johannes Weiner <hannes@cmpxchg.org> Cc: Kirill Tkhai <ktkhai@virtuozzo.com> Cc: Michal Hocko <mhocko@kernel.org> Cc: Oleg Nesterov <oleg@redhat.com> Cc: Roman Gushchin <guro@fb.com> Cc: Serge Hallyn <serge@hallyn.com> Cc: Tejun Heo <tj@kernel.org> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: Vladimir Davydov <vdavydov.dev@gmail.com> Cc: Yutian Yang <nglaive@gmail.com> Cc: Zefan Li <lizefan.x@bytedance.com> ",
        "func_before": "static int __init filelock_init(void)\n{\n\tint i;\n\n\tflctx_cache = kmem_cache_create(\"file_lock_ctx\",\n\t\t\tsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);\n\n\tfilelock_cache = kmem_cache_create(\"file_lock_cache\",\n\t\t\tsizeof(struct file_lock), 0, SLAB_PANIC, NULL);\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);\n\n\t\tspin_lock_init(&fll->lock);\n\t\tINIT_HLIST_HEAD(&fll->hlist);\n\t}\n\n\tlease_notifier_chain_init();\n\treturn 0;\n}",
        "func": "static int __init filelock_init(void)\n{\n\tint i;\n\n\tflctx_cache = kmem_cache_create(\"file_lock_ctx\",\n\t\t\tsizeof(struct file_lock_context), 0,\n\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);\n\n\tfilelock_cache = kmem_cache_create(\"file_lock_cache\",\n\t\t\tsizeof(struct file_lock), 0,\n\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);\n\n\t\tspin_lock_init(&fll->lock);\n\t\tINIT_HLIST_HEAD(&fll->hlist);\n\t}\n\n\tlease_notifier_chain_init();\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,12 @@\n \tint i;\n \n \tflctx_cache = kmem_cache_create(\"file_lock_ctx\",\n-\t\t\tsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);\n+\t\t\tsizeof(struct file_lock_context), 0,\n+\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);\n \n \tfilelock_cache = kmem_cache_create(\"file_lock_cache\",\n-\t\t\tsizeof(struct file_lock), 0, SLAB_PANIC, NULL);\n+\t\t\tsizeof(struct file_lock), 0,\n+\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);\n \n \tfor_each_possible_cpu(i) {\n \t\tstruct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);",
                "\t\t\tsizeof(struct file_lock), 0, SLAB_PANIC, NULL);"
            ],
            "added_lines": [
                "\t\t\tsizeof(struct file_lock_context), 0,",
                "\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);",
                "\t\t\tsizeof(struct file_lock), 0,",
                "\t\t\tSLAB_PANIC | SLAB_ACCOUNT, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-35534",
        "func_name": "LibRaw/crxSetupSubbandData",
        "description": "In LibRaw, there is a memory corruption vulnerability within the \"crxFreeSubbandData()\" function (libraw\\src\\decoders\\crx.cpp) when processing cr3 files.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/e41f331e90b383e3208cefb74e006df44bf3a4b8",
        "commit_title": "CR3 decoder: use mempool for memory",
        "commit_text": "",
        "func_before": "int crxSetupSubbandData(CrxImage *img, CrxPlaneComp *planeComp,\n                        const CrxTile *tile, uint32_t mdatOffset)\n{\n  long compDataSize = 0;\n  long waveletDataOffset = 0;\n  long compCoeffDataOffset = 0;\n  int32_t toSubbands = 3 * img->levels + 1;\n  int32_t transformWidth = 0;\n\n  CrxSubband *subbands = planeComp->subBands;\n\n  // calculate sizes\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\n  {\n    subbands[subbandNum].bandSize =\n        subbands[subbandNum].width * sizeof(int32_t); // 4bytes\n    compDataSize += subbands[subbandNum].bandSize;\n  }\n\n  if (img->levels)\n  {\n    int32_t encLevels = img->levels ? img->levels : 1;\n    waveletDataOffset = (compDataSize + 7) & ~7;\n    compDataSize =\n        (sizeof(CrxWaveletTransform) * encLevels + waveletDataOffset + 7) & ~7;\n    compCoeffDataOffset = compDataSize;\n\n    // calc wavelet line buffer sizes (always at one level up from current)\n    for (int level = 0; level < img->levels; ++level)\n      if (level < img->levels - 1)\n        compDataSize += 8 * sizeof(int32_t) *\n                        planeComp->subBands[3 * (level + 1) + 2].width;\n      else\n        compDataSize += 8 * sizeof(int32_t) * tile->width;\n  }\n\n  // buffer allocation\n  planeComp->compBuf = (uint8_t *)malloc(compDataSize);\n  if (!planeComp->compBuf)\n    return -1;\n\n  // subbands buffer and sizes initialisation\n  uint64_t subbandMdatOffset = img->mdatOffset + mdatOffset;\n  uint8_t *subbandBuf = planeComp->compBuf;\n\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\n  {\n    subbands[subbandNum].bandBuf = subbandBuf;\n    subbandBuf += subbands[subbandNum].bandSize;\n    subbands[subbandNum].mdatOffset =\n        subbandMdatOffset + subbands[subbandNum].dataOffset;\n  }\n\n  // wavelet data initialisation\n  if (img->levels)\n  {\n    CrxWaveletTransform *waveletTransforms =\n        (CrxWaveletTransform *)(planeComp->compBuf + waveletDataOffset);\n    int32_t *paramData = (int32_t *)(planeComp->compBuf + compCoeffDataOffset);\n\n    planeComp->waveletTransform = waveletTransforms;\n    waveletTransforms[0].subband0Buf = (int32_t *)subbands->bandBuf;\n\n    for (int level = 0; level < img->levels; ++level)\n    {\n      int32_t band = 3 * level + 1;\n\n      if (level >= img->levels - 1)\n      {\n        waveletTransforms[level].height = tile->height;\n        transformWidth = tile->width;\n      }\n      else\n      {\n        waveletTransforms[level].height = subbands[band + 3].height;\n        transformWidth = subbands[band + 4].width;\n      }\n      waveletTransforms[level].width = transformWidth;\n      waveletTransforms[level].lineBuf[0] = paramData;\n      waveletTransforms[level].lineBuf[1] =\n          waveletTransforms[level].lineBuf[0] + transformWidth;\n      waveletTransforms[level].lineBuf[2] =\n          waveletTransforms[level].lineBuf[1] + transformWidth;\n      waveletTransforms[level].lineBuf[3] =\n          waveletTransforms[level].lineBuf[2] + transformWidth;\n      waveletTransforms[level].lineBuf[4] =\n          waveletTransforms[level].lineBuf[3] + transformWidth;\n      waveletTransforms[level].lineBuf[5] =\n          waveletTransforms[level].lineBuf[4] + transformWidth;\n      waveletTransforms[level].lineBuf[6] =\n          waveletTransforms[level].lineBuf[5] + transformWidth;\n      waveletTransforms[level].lineBuf[7] =\n          waveletTransforms[level].lineBuf[6] + transformWidth;\n      waveletTransforms[level].curLine = 0;\n      waveletTransforms[level].curH = 0;\n      waveletTransforms[level].fltTapH = 0;\n      waveletTransforms[level].subband1Buf = (int32_t *)subbands[band].bandBuf;\n      waveletTransforms[level].subband2Buf =\n          (int32_t *)subbands[band + 1].bandBuf;\n      waveletTransforms[level].subband3Buf =\n          (int32_t *)subbands[band + 2].bandBuf;\n\n      paramData = waveletTransforms[level].lineBuf[7] + transformWidth;\n    }\n  }\n\n  // decoding params and bitstream initialisation\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\n  {\n    if (subbands[subbandNum].dataSize)\n    {\n      int32_t supportsPartial = 0;\n      uint32_t roundedBitsMask = 0;\n\n      if (planeComp->supportsPartial && subbandNum == 0)\n      {\n        roundedBitsMask = planeComp->roundedBitsMask;\n        supportsPartial = 1;\n      }\n      if (crxParamInit(&subbands[subbandNum].bandParam,\n                       subbands[subbandNum].mdatOffset,\n                       subbands[subbandNum].dataSize,\n                       subbands[subbandNum].width, subbands[subbandNum].height,\n                       supportsPartial, roundedBitsMask, img->input))\n        return -1;\n    }\n  }\n\n  return 0;\n}",
        "func": "int crxSetupSubbandData(CrxImage *img, CrxPlaneComp *planeComp,\n                        const CrxTile *tile, uint32_t mdatOffset)\n{\n  long compDataSize = 0;\n  long waveletDataOffset = 0;\n  long compCoeffDataOffset = 0;\n  int32_t toSubbands = 3 * img->levels + 1;\n  int32_t transformWidth = 0;\n\n  CrxSubband *subbands = planeComp->subBands;\n\n  // calculate sizes\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\n  {\n    subbands[subbandNum].bandSize =\n        subbands[subbandNum].width * sizeof(int32_t); // 4bytes\n    compDataSize += subbands[subbandNum].bandSize;\n  }\n\n  if (img->levels)\n  {\n    int32_t encLevels = img->levels ? img->levels : 1;\n    waveletDataOffset = (compDataSize + 7) & ~7;\n    compDataSize =\n        (sizeof(CrxWaveletTransform) * encLevels + waveletDataOffset + 7) & ~7;\n    compCoeffDataOffset = compDataSize;\n\n    // calc wavelet line buffer sizes (always at one level up from current)\n    for (int level = 0; level < img->levels; ++level)\n      if (level < img->levels - 1)\n        compDataSize += 8 * sizeof(int32_t) *\n                        planeComp->subBands[3 * (level + 1) + 2].width;\n      else\n        compDataSize += 8 * sizeof(int32_t) * tile->width;\n  }\n\n  // buffer allocation\n  planeComp->compBuf = (uint8_t *)\n#ifdef LIBRAW_CR3_MEMPOOL\n\t  img->memmgr.\n#endif\n\t  malloc(compDataSize);\n  if (!planeComp->compBuf)\n    return -1;\n\n  // subbands buffer and sizes initialisation\n  uint64_t subbandMdatOffset = img->mdatOffset + mdatOffset;\n  uint8_t *subbandBuf = planeComp->compBuf;\n\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\n  {\n    subbands[subbandNum].bandBuf = subbandBuf;\n    subbandBuf += subbands[subbandNum].bandSize;\n    subbands[subbandNum].mdatOffset =\n        subbandMdatOffset + subbands[subbandNum].dataOffset;\n  }\n\n  // wavelet data initialisation\n  if (img->levels)\n  {\n    CrxWaveletTransform *waveletTransforms =\n        (CrxWaveletTransform *)(planeComp->compBuf + waveletDataOffset);\n    int32_t *paramData = (int32_t *)(planeComp->compBuf + compCoeffDataOffset);\n\n    planeComp->waveletTransform = waveletTransforms;\n    waveletTransforms[0].subband0Buf = (int32_t *)subbands->bandBuf;\n\n    for (int level = 0; level < img->levels; ++level)\n    {\n      int32_t band = 3 * level + 1;\n\n      if (level >= img->levels - 1)\n      {\n        waveletTransforms[level].height = tile->height;\n        transformWidth = tile->width;\n      }\n      else\n      {\n        waveletTransforms[level].height = subbands[band + 3].height;\n        transformWidth = subbands[band + 4].width;\n      }\n      waveletTransforms[level].width = transformWidth;\n      waveletTransforms[level].lineBuf[0] = paramData;\n      waveletTransforms[level].lineBuf[1] =\n          waveletTransforms[level].lineBuf[0] + transformWidth;\n      waveletTransforms[level].lineBuf[2] =\n          waveletTransforms[level].lineBuf[1] + transformWidth;\n      waveletTransforms[level].lineBuf[3] =\n          waveletTransforms[level].lineBuf[2] + transformWidth;\n      waveletTransforms[level].lineBuf[4] =\n          waveletTransforms[level].lineBuf[3] + transformWidth;\n      waveletTransforms[level].lineBuf[5] =\n          waveletTransforms[level].lineBuf[4] + transformWidth;\n      waveletTransforms[level].lineBuf[6] =\n          waveletTransforms[level].lineBuf[5] + transformWidth;\n      waveletTransforms[level].lineBuf[7] =\n          waveletTransforms[level].lineBuf[6] + transformWidth;\n      waveletTransforms[level].curLine = 0;\n      waveletTransforms[level].curH = 0;\n      waveletTransforms[level].fltTapH = 0;\n      waveletTransforms[level].subband1Buf = (int32_t *)subbands[band].bandBuf;\n      waveletTransforms[level].subband2Buf =\n          (int32_t *)subbands[band + 1].bandBuf;\n      waveletTransforms[level].subband3Buf =\n          (int32_t *)subbands[band + 2].bandBuf;\n\n      paramData = waveletTransforms[level].lineBuf[7] + transformWidth;\n    }\n  }\n\n  // decoding params and bitstream initialisation\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\n  {\n    if (subbands[subbandNum].dataSize)\n    {\n      int32_t supportsPartial = 0;\n      uint32_t roundedBitsMask = 0;\n\n      if (planeComp->supportsPartial && subbandNum == 0)\n      {\n        roundedBitsMask = planeComp->roundedBitsMask;\n        supportsPartial = 1;\n      }\n      if (crxParamInit(\n#ifdef LIBRAW_CR3_MEMPOOL\n\t\t  img->memmgr,\n#endif\n\t\t  &subbands[subbandNum].bandParam,\n                       subbands[subbandNum].mdatOffset,\n                       subbands[subbandNum].dataSize,\n                       subbands[subbandNum].width, subbands[subbandNum].height,\n                       supportsPartial, roundedBitsMask, img->input))\n        return -1;\n    }\n  }\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,11 @@\n   }\n \n   // buffer allocation\n-  planeComp->compBuf = (uint8_t *)malloc(compDataSize);\n+  planeComp->compBuf = (uint8_t *)\n+#ifdef LIBRAW_CR3_MEMPOOL\n+\t  img->memmgr.\n+#endif\n+\t  malloc(compDataSize);\n   if (!planeComp->compBuf)\n     return -1;\n \n@@ -117,7 +121,11 @@\n         roundedBitsMask = planeComp->roundedBitsMask;\n         supportsPartial = 1;\n       }\n-      if (crxParamInit(&subbands[subbandNum].bandParam,\n+      if (crxParamInit(\n+#ifdef LIBRAW_CR3_MEMPOOL\n+\t\t  img->memmgr,\n+#endif\n+\t\t  &subbands[subbandNum].bandParam,\n                        subbands[subbandNum].mdatOffset,\n                        subbands[subbandNum].dataSize,\n                        subbands[subbandNum].width, subbands[subbandNum].height,",
        "diff_line_info": {
            "deleted_lines": [
                "  planeComp->compBuf = (uint8_t *)malloc(compDataSize);",
                "      if (crxParamInit(&subbands[subbandNum].bandParam,"
            ],
            "added_lines": [
                "  planeComp->compBuf = (uint8_t *)",
                "#ifdef LIBRAW_CR3_MEMPOOL",
                "\t  img->memmgr.",
                "#endif",
                "\t  malloc(compDataSize);",
                "      if (crxParamInit(",
                "#ifdef LIBRAW_CR3_MEMPOOL",
                "\t\t  img->memmgr,",
                "#endif",
                "\t\t  &subbands[subbandNum].bandParam,"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-35534",
        "func_name": "LibRaw/crxReadImageHeaders",
        "description": "In LibRaw, there is a memory corruption vulnerability within the \"crxFreeSubbandData()\" function (libraw\\src\\decoders\\crx.cpp) when processing cr3 files.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/e41f331e90b383e3208cefb74e006df44bf3a4b8",
        "commit_title": "CR3 decoder: use mempool for memory",
        "commit_text": "",
        "func_before": "int crxReadImageHeaders(crx_data_header_t *hdr, CrxImage *img, uint8_t *mdatPtr,\n                        uint32_t mdatSize)\n{\n  int nTiles = img->tileRows * img->tileCols;\n\n  if (!nTiles)\n    return -1;\n\n  if (!img->tiles)\n  {\n    img->tiles = (CrxTile *)malloc(\n        sizeof(CrxTile) * nTiles +\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount);\n    if (!img->tiles)\n      return -1;\n\n    // memory areas in allocated chunk\n    CrxTile *tile = img->tiles;\n    CrxPlaneComp *comps = (CrxPlaneComp *)(tile + nTiles);\n    CrxSubband *bands = (CrxSubband *)(comps + img->nPlanes * nTiles);\n\n    for (int curTile = 0; curTile < nTiles; curTile++, tile++)\n    {\n      tile->tileFlag = 0; // tile neighbouring flags\n      tile->tileNumber = curTile;\n      tile->tileSize = 0;\n      tile->comps = comps + curTile * img->nPlanes;\n\n      if ((curTile + 1) % img->tileCols)\n      {\n        // not the last tile in a tile row\n        tile->width = hdr->tileWidth;\n        if (img->tileCols > 1)\n        {\n          tile->tileFlag = E_HAS_TILES_ON_THE_RIGHT;\n          if (curTile % img->tileCols)\n            // not the first tile in tile row\n            tile->tileFlag |= E_HAS_TILES_ON_THE_LEFT;\n        }\n      }\n      else\n      {\n        // last tile in a tile row\n        tile->width = img->planeWidth - hdr->tileWidth * (img->tileCols - 1);\n        if (img->tileCols > 1)\n          tile->tileFlag = E_HAS_TILES_ON_THE_LEFT;\n      }\n      if (curTile < nTiles - img->tileCols)\n      {\n        // in first tile row\n        tile->height = hdr->tileHeight;\n        if (img->tileRows > 1)\n        {\n          tile->tileFlag |= E_HAS_TILES_ON_THE_BOTTOM;\n          if (curTile >= img->tileCols)\n            tile->tileFlag |= E_HAS_TILES_ON_THE_TOP;\n        }\n      }\n      else\n      {\n        // non first tile row\n        tile->height = img->planeHeight - hdr->tileHeight * (img->tileRows - 1);\n        if (img->tileRows > 1)\n          tile->tileFlag |= E_HAS_TILES_ON_THE_TOP;\n      }\n      if (img->nPlanes)\n      {\n        CrxPlaneComp *comp = tile->comps;\n        CrxSubband *band = bands + curTile * img->nPlanes * img->subbandCount;\n\n        for (int curComp = 0; curComp < img->nPlanes; curComp++, comp++)\n        {\n          comp->compNumber = curComp;\n          comp->supportsPartial = 1;\n          comp->tileFlag = tile->tileFlag;\n          comp->subBands = band;\n          comp->compBuf = 0;\n          comp->waveletTransform = 0;\n          if (img->subbandCount)\n          {\n            for (int curBand = 0; curBand < img->subbandCount;\n                 curBand++, band++)\n            {\n              band->supportsPartial = 0;\n              band->quantValue = 4;\n              band->bandParam = 0;\n              band->dataSize = 0;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  uint32_t tileOffset = 0;\n  uint32_t dataSize = mdatSize;\n  uint8_t *dataPtr = mdatPtr;\n  CrxTile *tile = img->tiles;\n\n  for (int curTile = 0; curTile < nTiles; curTile++, tile++)\n  {\n    if (dataSize < 0xC)\n      return -1;\n\n    if (LibRaw::sgetn(2, dataPtr) != 0xFF01)\n      return -1;\n    if (LibRaw::sgetn(2, dataPtr + 8) != curTile)\n      return -1;\n\n    dataSize -= 0xC;\n\n    tile->tileSize = LibRaw::sgetn(4, dataPtr + 4);\n    tile->dataOffset = tileOffset;\n\n    int32_t hdrExtraBytes = LibRaw::sgetn(2, dataPtr + 2) - 8;\n    tileOffset += tile->tileSize;\n    dataPtr += hdrExtraBytes + 0xC;\n    dataSize -= hdrExtraBytes;\n\n    uint32_t compOffset = 0;\n    CrxPlaneComp *comp = tile->comps;\n\n    for (int compNum = 0; compNum < img->nPlanes; compNum++, comp++)\n    {\n      if (dataSize < 0xC)\n        return -1;\n\n      if (LibRaw::sgetn(2, dataPtr) != 0xFF02)\n        return -1;\n      if (compNum != dataPtr[8] >> 4)\n        return -1;\n\n      comp->compSize = LibRaw::sgetn(4, dataPtr + 4);\n\n      int32_t compHdrRoundedBits = (dataPtr[8] >> 1) & 3;\n      comp->supportsPartial = (dataPtr[8] & 8) != 0;\n\n      comp->dataOffset = compOffset;\n      comp->tileFlag = tile->tileFlag;\n\n      compOffset += comp->compSize;\n      dataSize -= 0xC;\n      dataPtr += 0xC;\n\n      comp->roundedBitsMask = 0;\n\n      if (compHdrRoundedBits)\n      {\n        if (img->levels || !comp->supportsPartial)\n          return -1;\n\n        comp->roundedBitsMask = 1 << (compHdrRoundedBits - 1);\n      }\n\n      if (crxReadSubbandHeaders(hdr, img, tile, comp, &dataPtr, &dataSize))\n        return -1;\n    }\n  }\n  return 0;\n}",
        "func": "int crxReadImageHeaders(crx_data_header_t *hdr, CrxImage *img, uint8_t *mdatPtr,\n                        uint32_t mdatSize)\n{\n  int nTiles = img->tileRows * img->tileCols;\n\n  if (!nTiles)\n    return -1;\n\n  if (!img->tiles)\n  {\n    img->tiles = (CrxTile *)\n#ifdef LIBRAW_CR3_MEMPOOL\n\t\timg->memmgr.\n#endif\n\t\tcalloc(\n        sizeof(CrxTile) * nTiles +\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount,1);\n    if (!img->tiles)\n      return -1;\n\n    // memory areas in allocated chunk\n    CrxTile *tile = img->tiles;\n    CrxPlaneComp *comps = (CrxPlaneComp *)(tile + nTiles);\n    CrxSubband *bands = (CrxSubband *)(comps + img->nPlanes * nTiles);\n\n    for (int curTile = 0; curTile < nTiles; curTile++, tile++)\n    {\n      tile->tileFlag = 0; // tile neighbouring flags\n      tile->tileNumber = curTile;\n      tile->tileSize = 0;\n      tile->comps = comps + curTile * img->nPlanes;\n\n      if ((curTile + 1) % img->tileCols)\n      {\n        // not the last tile in a tile row\n        tile->width = hdr->tileWidth;\n        if (img->tileCols > 1)\n        {\n          tile->tileFlag = E_HAS_TILES_ON_THE_RIGHT;\n          if (curTile % img->tileCols)\n            // not the first tile in tile row\n            tile->tileFlag |= E_HAS_TILES_ON_THE_LEFT;\n        }\n      }\n      else\n      {\n        // last tile in a tile row\n        tile->width = img->planeWidth - hdr->tileWidth * (img->tileCols - 1);\n        if (img->tileCols > 1)\n          tile->tileFlag = E_HAS_TILES_ON_THE_LEFT;\n      }\n      if (curTile < nTiles - img->tileCols)\n      {\n        // in first tile row\n        tile->height = hdr->tileHeight;\n        if (img->tileRows > 1)\n        {\n          tile->tileFlag |= E_HAS_TILES_ON_THE_BOTTOM;\n          if (curTile >= img->tileCols)\n            tile->tileFlag |= E_HAS_TILES_ON_THE_TOP;\n        }\n      }\n      else\n      {\n        // non first tile row\n        tile->height = img->planeHeight - hdr->tileHeight * (img->tileRows - 1);\n        if (img->tileRows > 1)\n          tile->tileFlag |= E_HAS_TILES_ON_THE_TOP;\n      }\n      if (img->nPlanes)\n      {\n        CrxPlaneComp *comp = tile->comps;\n        CrxSubband *band = bands + curTile * img->nPlanes * img->subbandCount;\n\n        for (int curComp = 0; curComp < img->nPlanes; curComp++, comp++)\n        {\n          comp->compNumber = curComp;\n          comp->supportsPartial = 1;\n          comp->tileFlag = tile->tileFlag;\n          comp->subBands = band;\n          comp->compBuf = 0;\n          comp->waveletTransform = 0;\n          if (img->subbandCount)\n          {\n            for (int curBand = 0; curBand < img->subbandCount;\n                 curBand++, band++)\n            {\n              band->supportsPartial = 0;\n              band->quantValue = 4;\n              band->bandParam = 0;\n              band->dataSize = 0;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  uint32_t tileOffset = 0;\n  uint32_t dataSize = mdatSize;\n  uint8_t *dataPtr = mdatPtr;\n  CrxTile *tile = img->tiles;\n\n  for (int curTile = 0; curTile < nTiles; curTile++, tile++)\n  {\n    if (dataSize < 0xC)\n      return -1;\n\n    if (LibRaw::sgetn(2, dataPtr) != 0xFF01)\n      return -1;\n    if (LibRaw::sgetn(2, dataPtr + 8) != curTile)\n      return -1;\n\n    dataSize -= 0xC;\n\n    tile->tileSize = LibRaw::sgetn(4, dataPtr + 4);\n    tile->dataOffset = tileOffset;\n\n    int32_t hdrExtraBytes = LibRaw::sgetn(2, dataPtr + 2) - 8;\n    tileOffset += tile->tileSize;\n    dataPtr += hdrExtraBytes + 0xC;\n    dataSize -= hdrExtraBytes;\n\n    uint32_t compOffset = 0;\n    CrxPlaneComp *comp = tile->comps;\n\n    for (int compNum = 0; compNum < img->nPlanes; compNum++, comp++)\n    {\n      if (dataSize < 0xC)\n        return -1;\n\n      if (LibRaw::sgetn(2, dataPtr) != 0xFF02)\n        return -1;\n      if (compNum != dataPtr[8] >> 4)\n        return -1;\n\n      comp->compSize = LibRaw::sgetn(4, dataPtr + 4);\n\n      int32_t compHdrRoundedBits = (dataPtr[8] >> 1) & 3;\n      comp->supportsPartial = (dataPtr[8] & 8) != 0;\n\n      comp->dataOffset = compOffset;\n      comp->tileFlag = tile->tileFlag;\n\n      compOffset += comp->compSize;\n      dataSize -= 0xC;\n      dataPtr += 0xC;\n\n      comp->roundedBitsMask = 0;\n\n      if (compHdrRoundedBits)\n      {\n        if (img->levels || !comp->supportsPartial)\n          return -1;\n\n        comp->roundedBitsMask = 1 << (compHdrRoundedBits - 1);\n      }\n\n      if (crxReadSubbandHeaders(hdr, img, tile, comp, &dataPtr, &dataSize))\n        return -1;\n    }\n  }\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,10 +8,14 @@\n \n   if (!img->tiles)\n   {\n-    img->tiles = (CrxTile *)malloc(\n+    img->tiles = (CrxTile *)\n+#ifdef LIBRAW_CR3_MEMPOOL\n+\t\timg->memmgr.\n+#endif\n+\t\tcalloc(\n         sizeof(CrxTile) * nTiles +\n         sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\n-        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount);\n+        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount,1);\n     if (!img->tiles)\n       return -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    img->tiles = (CrxTile *)malloc(",
                "        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount);"
            ],
            "added_lines": [
                "    img->tiles = (CrxTile *)",
                "#ifdef LIBRAW_CR3_MEMPOOL",
                "\t\timg->memmgr.",
                "#endif",
                "\t\tcalloc(",
                "        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount,1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-35534",
        "func_name": "LibRaw/crxSetupImageData",
        "description": "In LibRaw, there is a memory corruption vulnerability within the \"crxFreeSubbandData()\" function (libraw\\src\\decoders\\crx.cpp) when processing cr3 files.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/e41f331e90b383e3208cefb74e006df44bf3a4b8",
        "commit_title": "CR3 decoder: use mempool for memory",
        "commit_text": "",
        "func_before": "int crxSetupImageData(crx_data_header_t *hdr, CrxImage *img, int16_t *outBuf,\n                      uint64_t mdatOffset, uint32_t mdatSize,\n                      uint8_t *mdatHdrPtr)\n{\n  int IncrBitTable[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0,\n                          0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0};\n\n  img->planeWidth = hdr->f_width;\n  img->planeHeight = hdr->f_height;\n\n  if (hdr->tileWidth < 0x16 || hdr->tileHeight < 0x16 ||\n      img->planeWidth > 0x7FFF || img->planeHeight > 0x7FFF)\n    return -1;\n\n  img->tileCols = (img->planeWidth + hdr->tileWidth - 1) / hdr->tileWidth;\n  img->tileRows = (img->planeHeight + hdr->tileHeight - 1) / hdr->tileHeight;\n\n  if (img->tileCols > 0xFF || img->tileRows > 0xFF ||\n      img->planeWidth - hdr->tileWidth * (img->tileCols - 1) < 0x16 ||\n      img->planeHeight - hdr->tileHeight * (img->tileRows - 1) < 0x16)\n    return -1;\n\n  img->tiles = 0;\n  img->levels = hdr->imageLevels;\n  img->subbandCount = 3 * img->levels + 1; // 3 bands per level + one last LL\n  img->nPlanes = hdr->nPlanes;\n  img->nBits = hdr->nBits;\n  img->encType = hdr->encType;\n  img->samplePrecision = hdr->nBits + IncrBitTable[4 * hdr->encType + 2] + 1;\n  img->mdatOffset = mdatOffset + hdr->mdatHdrSize;\n  img->mdatSize = mdatSize;\n  img->planeBuf = 0;\n  img->outBufs[0] = img->outBufs[1] = img->outBufs[2] = img->outBufs[3] = 0;\n\n  // The encoding type 3 needs all 4 planes to be decoded to generate row of\n  // RGGB values. It seems to be using some other colour space for raw encoding\n  // It is a massive buffer so ideallly it will need a different approach:\n  // decode planes line by line and convert single line then without\n  // intermediate plane buffer. At the moment though it's too many changes so\n  // left as is.\n  if (img->encType == 3 && img->nPlanes == 4 && img->nBits > 8)\n  {\n    img->planeBuf =\n        (int16_t *)malloc(img->planeHeight * img->planeWidth * img->nPlanes *\n                          ((img->samplePrecision + 7) >> 3));\n    if (!img->planeBuf)\n      return -1;\n  }\n\n  int32_t rowSize = 2 * img->planeWidth;\n\n  if (img->nPlanes == 1)\n    img->outBufs[0] = outBuf;\n  else\n    switch (hdr->cfaLayout)\n    {\n    case 0:\n      // R G\n      // G B\n      img->outBufs[0] = outBuf;\n      img->outBufs[1] = outBuf + 1;\n      img->outBufs[2] = outBuf + rowSize;\n      img->outBufs[3] = img->outBufs[2] + 1;\n      break;\n    case 1:\n      // G R\n      // B G\n      img->outBufs[1] = outBuf;\n      img->outBufs[0] = outBuf + 1;\n      img->outBufs[3] = outBuf + rowSize;\n      img->outBufs[2] = img->outBufs[3] + 1;\n      break;\n    case 2:\n      // G B\n      // R G\n      img->outBufs[2] = outBuf;\n      img->outBufs[3] = outBuf + 1;\n      img->outBufs[0] = outBuf + rowSize;\n      img->outBufs[1] = img->outBufs[0] + 1;\n      break;\n    case 3:\n      // B G\n      // G R\n      img->outBufs[3] = outBuf;\n      img->outBufs[2] = outBuf + 1;\n      img->outBufs[1] = outBuf + rowSize;\n      img->outBufs[0] = img->outBufs[1] + 1;\n      break;\n    }\n\n  // read header\n  return crxReadImageHeaders(hdr, img, mdatHdrPtr, mdatSize);\n}",
        "func": "int crxSetupImageData(crx_data_header_t *hdr, CrxImage *img, int16_t *outBuf,\n                      uint64_t mdatOffset, uint32_t mdatSize,\n                      uint8_t *mdatHdrPtr)\n{\n  int IncrBitTable[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0,\n                          0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0};\n\n  img->planeWidth = hdr->f_width;\n  img->planeHeight = hdr->f_height;\n\n  if (hdr->tileWidth < 0x16 || hdr->tileHeight < 0x16 ||\n      img->planeWidth > 0x7FFF || img->planeHeight > 0x7FFF)\n    return -1;\n\n  img->tileCols = (img->planeWidth + hdr->tileWidth - 1) / hdr->tileWidth;\n  img->tileRows = (img->planeHeight + hdr->tileHeight - 1) / hdr->tileHeight;\n\n  if (img->tileCols > 0xFF || img->tileRows > 0xFF ||\n      img->planeWidth - hdr->tileWidth * (img->tileCols - 1) < 0x16 ||\n      img->planeHeight - hdr->tileHeight * (img->tileRows - 1) < 0x16)\n    return -1;\n\n  img->tiles = 0;\n  img->levels = hdr->imageLevels;\n  img->subbandCount = 3 * img->levels + 1; // 3 bands per level + one last LL\n  img->nPlanes = hdr->nPlanes;\n  img->nBits = hdr->nBits;\n  img->encType = hdr->encType;\n  img->samplePrecision = hdr->nBits + IncrBitTable[4 * hdr->encType + 2] + 1;\n  img->mdatOffset = mdatOffset + hdr->mdatHdrSize;\n  img->mdatSize = mdatSize;\n  img->planeBuf = 0;\n  img->outBufs[0] = img->outBufs[1] = img->outBufs[2] = img->outBufs[3] = 0;\n\n  // The encoding type 3 needs all 4 planes to be decoded to generate row of\n  // RGGB values. It seems to be using some other colour space for raw encoding\n  // It is a massive buffer so ideallly it will need a different approach:\n  // decode planes line by line and convert single line then without\n  // intermediate plane buffer. At the moment though it's too many changes so\n  // left as is.\n  if (img->encType == 3 && img->nPlanes == 4 && img->nBits > 8)\n  {\n    img->planeBuf =\n        (int16_t *)\n#ifdef LIBRAW_CR3_MEMPOOL\n\t\timg->memmgr.\n#endif\n\t\tmalloc(img->planeHeight * img->planeWidth * img->nPlanes *\n                          ((img->samplePrecision + 7) >> 3));\n    if (!img->planeBuf)\n      return -1;\n  }\n\n  int32_t rowSize = 2 * img->planeWidth;\n\n  if (img->nPlanes == 1)\n    img->outBufs[0] = outBuf;\n  else\n    switch (hdr->cfaLayout)\n    {\n    case 0:\n      // R G\n      // G B\n      img->outBufs[0] = outBuf;\n      img->outBufs[1] = outBuf + 1;\n      img->outBufs[2] = outBuf + rowSize;\n      img->outBufs[3] = img->outBufs[2] + 1;\n      break;\n    case 1:\n      // G R\n      // B G\n      img->outBufs[1] = outBuf;\n      img->outBufs[0] = outBuf + 1;\n      img->outBufs[3] = outBuf + rowSize;\n      img->outBufs[2] = img->outBufs[3] + 1;\n      break;\n    case 2:\n      // G B\n      // R G\n      img->outBufs[2] = outBuf;\n      img->outBufs[3] = outBuf + 1;\n      img->outBufs[0] = outBuf + rowSize;\n      img->outBufs[1] = img->outBufs[0] + 1;\n      break;\n    case 3:\n      // B G\n      // G R\n      img->outBufs[3] = outBuf;\n      img->outBufs[2] = outBuf + 1;\n      img->outBufs[1] = outBuf + rowSize;\n      img->outBufs[0] = img->outBufs[1] + 1;\n      break;\n    }\n\n  // read header\n  return crxReadImageHeaders(hdr, img, mdatHdrPtr, mdatSize);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,7 +41,11 @@\n   if (img->encType == 3 && img->nPlanes == 4 && img->nBits > 8)\n   {\n     img->planeBuf =\n-        (int16_t *)malloc(img->planeHeight * img->planeWidth * img->nPlanes *\n+        (int16_t *)\n+#ifdef LIBRAW_CR3_MEMPOOL\n+\t\timg->memmgr.\n+#endif\n+\t\tmalloc(img->planeHeight * img->planeWidth * img->nPlanes *\n                           ((img->samplePrecision + 7) >> 3));\n     if (!img->planeBuf)\n       return -1;",
        "diff_line_info": {
            "deleted_lines": [
                "        (int16_t *)malloc(img->planeHeight * img->planeWidth * img->nPlanes *"
            ],
            "added_lines": [
                "        (int16_t *)",
                "#ifdef LIBRAW_CR3_MEMPOOL",
                "\t\timg->memmgr.",
                "#endif",
                "\t\tmalloc(img->planeHeight * img->planeWidth * img->nPlanes *"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-35534",
        "func_name": "LibRaw/crxFreeImageData",
        "description": "In LibRaw, there is a memory corruption vulnerability within the \"crxFreeSubbandData()\" function (libraw\\src\\decoders\\crx.cpp) when processing cr3 files.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/e41f331e90b383e3208cefb74e006df44bf3a4b8",
        "commit_title": "CR3 decoder: use mempool for memory",
        "commit_text": "",
        "func_before": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n\n  return 0;\n}",
        "func": "int crxFreeImageData(CrxImage *img)\n{\n#ifdef LIBRAW_CR3_MEMPOOL\n\timg->memmgr.cleanup();\n#else\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n#endif\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n int crxFreeImageData(CrxImage *img)\n {\n+#ifdef LIBRAW_CR3_MEMPOOL\n+\timg->memmgr.cleanup();\n+#else\n   CrxTile *tile = img->tiles;\n   int nTiles = img->tileRows * img->tileCols;\n \n@@ -18,6 +21,6 @@\n     free(img->planeBuf);\n     img->planeBuf = 0;\n   }\n-\n+#endif\n   return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "#ifdef LIBRAW_CR3_MEMPOOL",
                "\timg->memmgr.cleanup();",
                "#else",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14938",
        "func_name": "binutils-gdb/_bfd_elf_slurp_version_tables",
        "description": "_bfd_elf_slurp_version_tables in elf.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted ELF file.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=bd61e135492ecf624880e6b78e5fcde3c9716df6",
        "commit_title": "",
        "commit_text": "PR22166, SHT_GNU_verneed memory allocation  The sanity check covers the previous minimim size, plus that the size is at least enough for sh_info verneed entries.  Also, since we write all verneed fields or exit with an error, there isn't any need to zero the memory allocated for verneed entries.  \tPR 22166 \t* elf.c (_bfd_elf_slurp_version_tables): Test sh_info on \tSHT_GNU_verneed section for sanity.  Don't zalloc memory for \tverref. ",
        "func_before": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "func": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0\n\t  || hdr->sh_info > hdr->sh_size / sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_alloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,8 @@\n \n       hdr = &elf_tdata (abfd)->dynverref_hdr;\n \n-      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verneed))\n+      if (hdr->sh_info == 0\n+\t  || hdr->sh_info > hdr->sh_size / sizeof (Elf_External_Verneed))\n \t{\n error_return_bad_verref:\n \t  _bfd_error_handler\n@@ -35,7 +36,7 @@\n \tgoto error_return_verref;\n \n       elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n-\tbfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n+\tbfd_alloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n \n       if (elf_tdata (abfd)->verref == NULL)\n \tgoto error_return_verref;",
        "diff_line_info": {
            "deleted_lines": [
                "      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verneed))",
                "\tbfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));"
            ],
            "added_lines": [
                "      if (hdr->sh_info == 0",
                "\t  || hdr->sh_info > hdr->sh_size / sizeof (Elf_External_Verneed))",
                "\tbfd_alloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-4074",
        "func_name": "jqlang/jq/jv_dump_term",
        "description": "The jv_dump_term function in jq 1.5 allows remote attackers to cause a denial of service (stack consumption and application crash) via a crafted JSON file. This issue has been fixed in jq 1.6_rc1-r0.",
        "git_url": "https://github.com/jqlang/jq/commit/83e2cf607f3599d208b6b3129092fa7deb2e5292",
        "commit_title": "Skip printing what's below a MAX_PRINT_DEPTH",
        "commit_text": " This addresses #1136, and mitigates a stack exhaustion when printing a very deeply nested term.",
        "func_before": "static void jv_dump_term(struct dtoa_context* C, jv x, int flags, int indent, FILE* F, jv* S) {\n  char buf[JVP_DTOA_FMT_MAX_LEN];\n  const char* color = 0;\n  double refcnt = (flags & JV_PRINT_REFCOUNT) ? jv_get_refcnt(x) - 1 : -1;\n  if (flags & JV_PRINT_COLOR) {\n    for (unsigned i=0; i<sizeof(color_kinds)/sizeof(color_kinds[0]); i++) {\n      if (jv_get_kind(x) == color_kinds[i]) {\n        color = colors[i];\n        put_str(color, F, S, flags & JV_PRINT_ISATTY);\n        break;\n      }\n    }\n  }\n  switch (jv_get_kind(x)) {\n  default:\n  case JV_KIND_INVALID:\n    if (flags & JV_PRINT_INVALID) {\n      jv msg = jv_invalid_get_msg(jv_copy(x));\n      if (jv_get_kind(msg) == JV_KIND_STRING) {\n        put_str(\"<invalid:\", F, S, flags & JV_PRINT_ISATTY);\n        jvp_dump_string(msg, flags | JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY);\n        put_str(\">\", F, S, flags & JV_PRINT_ISATTY);\n      } else {\n        put_str(\"<invalid>\", F, S, flags & JV_PRINT_ISATTY);\n      }\n    } else {\n      assert(0 && \"Invalid value\");\n    }\n    break;\n  case JV_KIND_NULL:\n    put_str(\"null\", F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_FALSE:\n    put_str(\"false\", F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_TRUE:\n    put_str(\"true\", F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_NUMBER: {\n    double d = jv_number_value(x);\n    if (d != d) {\n      // JSON doesn't have NaN, so we'll render it as \"null\"\n      put_str(\"null\", F, S, flags & JV_PRINT_ISATTY);\n    } else {\n      // Normalise infinities to something we can print in valid JSON\n      if (d > DBL_MAX) d = DBL_MAX;\n      if (d < -DBL_MAX) d = -DBL_MAX;\n      put_str(jvp_dtoa_fmt(C, buf, d), F, S, flags & JV_PRINT_ISATTY);\n    }\n    break;\n  }\n  case JV_KIND_STRING:\n    jvp_dump_string(x, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_REFCOUNT)\n      put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_ARRAY: {\n    if (jv_array_length(jv_copy(x)) == 0) {\n      put_str(\"[]\", F, S, flags & JV_PRINT_ISATTY);\n      break;\n    }\n    put_str(\"[\", F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    jv_array_foreach(x, i, elem) {\n      if (i!=0) {\n        if (flags & JV_PRINT_PRETTY) {\n          put_str(\",\\n\", F, S, flags & JV_PRINT_ISATTY);\n          put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n        } else {\n          put_str(\",\", F, S, flags & JV_PRINT_ISATTY);\n        }\n      }\n      jv_dump_term(C, elem, flags, indent + 1, F, S);\n      if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    put_char(']', F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_REFCOUNT)\n      put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY);\n    break;\n  }\n  case JV_KIND_OBJECT: {\n    if (jv_object_length(jv_copy(x)) == 0) {\n      put_str(\"{}\", F, S, flags & JV_PRINT_ISATTY);\n      break;\n    }\n    put_char('{', F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    int first = 1;\n    int i = 0;\n    jv keyset = jv_null();\n    while (1) {\n      jv key, value;\n      if (flags & JV_PRINT_SORTED) {\n        if (first) {\n          keyset = jv_keys(jv_copy(x));\n          i = 0;\n        } else {\n          i++;\n        }\n        if (i >= jv_array_length(jv_copy(keyset))) {\n          jv_free(keyset);\n          break;\n        }\n        key = jv_array_get(jv_copy(keyset), i);\n        value = jv_object_get(jv_copy(x), jv_copy(key));\n      } else {\n        if (first) {\n          i = jv_object_iter(x);\n        } else {\n          i = jv_object_iter_next(x, i);\n        }\n        if (!jv_object_iter_valid(x, i)) break;\n        key = jv_object_iter_key(x, i);\n        value = jv_object_iter_value(x, i);\n      }\n\n      if (!first) {\n        if (flags & JV_PRINT_PRETTY){\n          put_str(\",\\n\", F, S, flags & JV_PRINT_ISATTY);\n          put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n        } else {\n          put_str(\",\", F, S, flags & JV_PRINT_ISATTY);\n        }\n      }\n      if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n\n      first = 0;\n      if (color) put_str(FIELD_COLOR, F, S, flags & JV_PRINT_ISATTY);\n      jvp_dump_string(key, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY);\n      jv_free(key);\n      if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n\n      if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n      put_str((flags & JV_PRINT_PRETTY) ? \": \" : \":\", F, S, flags & JV_PRINT_ISATTY);\n      if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n\n      jv_dump_term(C, value, flags, indent + 1, F, S);\n      if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    put_char('}', F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_REFCOUNT)\n      put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY);\n  }\n  }\n  jv_free(x);\n  if (color) {\n    put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n  }\n}",
        "func": "static void jv_dump_term(struct dtoa_context* C, jv x, int flags, int indent, FILE* F, jv* S) {\n  char buf[JVP_DTOA_FMT_MAX_LEN];\n  const char* color = 0;\n  double refcnt = (flags & JV_PRINT_REFCOUNT) ? jv_get_refcnt(x) - 1 : -1;\n  if (flags & JV_PRINT_COLOR) {\n    for (unsigned i=0; i<sizeof(color_kinds)/sizeof(color_kinds[0]); i++) {\n      if (jv_get_kind(x) == color_kinds[i]) {\n        color = colors[i];\n        put_str(color, F, S, flags & JV_PRINT_ISATTY);\n        break;\n      }\n    }\n  }\n  if (indent > MAX_PRINT_DEPTH) {\n    put_str(\"<skipped: too deep>\", F, S, flags & JV_PRINT_ISATTY);\n  } else switch (jv_get_kind(x)) {\n  default:\n  case JV_KIND_INVALID:\n    if (flags & JV_PRINT_INVALID) {\n      jv msg = jv_invalid_get_msg(jv_copy(x));\n      if (jv_get_kind(msg) == JV_KIND_STRING) {\n        put_str(\"<invalid:\", F, S, flags & JV_PRINT_ISATTY);\n        jvp_dump_string(msg, flags | JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY);\n        put_str(\">\", F, S, flags & JV_PRINT_ISATTY);\n      } else {\n        put_str(\"<invalid>\", F, S, flags & JV_PRINT_ISATTY);\n      }\n    } else {\n      assert(0 && \"Invalid value\");\n    }\n    break;\n  case JV_KIND_NULL:\n    put_str(\"null\", F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_FALSE:\n    put_str(\"false\", F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_TRUE:\n    put_str(\"true\", F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_NUMBER: {\n    double d = jv_number_value(x);\n    if (d != d) {\n      // JSON doesn't have NaN, so we'll render it as \"null\"\n      put_str(\"null\", F, S, flags & JV_PRINT_ISATTY);\n    } else {\n      // Normalise infinities to something we can print in valid JSON\n      if (d > DBL_MAX) d = DBL_MAX;\n      if (d < -DBL_MAX) d = -DBL_MAX;\n      put_str(jvp_dtoa_fmt(C, buf, d), F, S, flags & JV_PRINT_ISATTY);\n    }\n    break;\n  }\n  case JV_KIND_STRING:\n    jvp_dump_string(x, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_REFCOUNT)\n      put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY);\n    break;\n  case JV_KIND_ARRAY: {\n    if (jv_array_length(jv_copy(x)) == 0) {\n      put_str(\"[]\", F, S, flags & JV_PRINT_ISATTY);\n      break;\n    }\n    put_str(\"[\", F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    jv_array_foreach(x, i, elem) {\n      if (i!=0) {\n        if (flags & JV_PRINT_PRETTY) {\n          put_str(\",\\n\", F, S, flags & JV_PRINT_ISATTY);\n          put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n        } else {\n          put_str(\",\", F, S, flags & JV_PRINT_ISATTY);\n        }\n      }\n      jv_dump_term(C, elem, flags, indent + 1, F, S);\n      if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    put_char(']', F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_REFCOUNT)\n      put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY);\n    break;\n  }\n  case JV_KIND_OBJECT: {\n    if (jv_object_length(jv_copy(x)) == 0) {\n      put_str(\"{}\", F, S, flags & JV_PRINT_ISATTY);\n      break;\n    }\n    put_char('{', F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    int first = 1;\n    int i = 0;\n    jv keyset = jv_null();\n    while (1) {\n      jv key, value;\n      if (flags & JV_PRINT_SORTED) {\n        if (first) {\n          keyset = jv_keys(jv_copy(x));\n          i = 0;\n        } else {\n          i++;\n        }\n        if (i >= jv_array_length(jv_copy(keyset))) {\n          jv_free(keyset);\n          break;\n        }\n        key = jv_array_get(jv_copy(keyset), i);\n        value = jv_object_get(jv_copy(x), jv_copy(key));\n      } else {\n        if (first) {\n          i = jv_object_iter(x);\n        } else {\n          i = jv_object_iter_next(x, i);\n        }\n        if (!jv_object_iter_valid(x, i)) break;\n        key = jv_object_iter_key(x, i);\n        value = jv_object_iter_value(x, i);\n      }\n\n      if (!first) {\n        if (flags & JV_PRINT_PRETTY){\n          put_str(\",\\n\", F, S, flags & JV_PRINT_ISATTY);\n          put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY);\n        } else {\n          put_str(\",\", F, S, flags & JV_PRINT_ISATTY);\n        }\n      }\n      if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n\n      first = 0;\n      if (color) put_str(FIELD_COLOR, F, S, flags & JV_PRINT_ISATTY);\n      jvp_dump_string(key, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY);\n      jv_free(key);\n      if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n\n      if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n      put_str((flags & JV_PRINT_PRETTY) ? \": \" : \":\", F, S, flags & JV_PRINT_ISATTY);\n      if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n\n      jv_dump_term(C, value, flags, indent + 1, F, S);\n      if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (flags & JV_PRINT_PRETTY) {\n      put_char('\\n', F, S, flags & JV_PRINT_ISATTY);\n      put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY);\n    }\n    if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY);\n    put_char('}', F, S, flags & JV_PRINT_ISATTY);\n    if (flags & JV_PRINT_REFCOUNT)\n      put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY);\n  }\n  }\n  jv_free(x);\n  if (color) {\n    put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,9 @@\n       }\n     }\n   }\n-  switch (jv_get_kind(x)) {\n+  if (indent > MAX_PRINT_DEPTH) {\n+    put_str(\"<skipped: too deep>\", F, S, flags & JV_PRINT_ISATTY);\n+  } else switch (jv_get_kind(x)) {\n   default:\n   case JV_KIND_INVALID:\n     if (flags & JV_PRINT_INVALID) {",
        "diff_line_info": {
            "deleted_lines": [
                "  switch (jv_get_kind(x)) {"
            ],
            "added_lines": [
                "  if (indent > MAX_PRINT_DEPTH) {",
                "    put_str(\"<skipped: too deep>\", F, S, flags & JV_PRINT_ISATTY);",
                "  } else switch (jv_get_kind(x)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20652",
        "func_name": "syoyo/tinyexr/DecodeChunk",
        "description": "An attempted excessive memory allocation was discovered in the function tinyexr::AllocateImage in tinyexr.h in tinyexr v0.9.5. Remote attackers could leverage this vulnerability to cause a denial-of-service via crafted input, which leads to an out-of-memory exception.",
        "git_url": "https://github.com/syoyo/tinyexr/commit/65f9859446c32f0dcfd91f376b1a5abafb8e0457",
        "commit_title": "Add data size check for AllocateImage. Fixes #104",
        "commit_text": "",
        "func_before": "static int DecodeChunk(EXRImage *exr_image, const EXRHeader *exr_header,\n                       const std::vector<tinyexr::tinyexr_uint64> &offsets,\n                       const unsigned char *head, const size_t size,\n                       std::string *err) {\n  int num_channels = exr_header->num_channels;\n\n  int num_scanline_blocks = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanline_blocks = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanline_blocks = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanline_blocks = 16;\n  }\n\n  int data_width = exr_header->data_window[2] - exr_header->data_window[0] + 1;\n  int data_height = exr_header->data_window[3] - exr_header->data_window[1] + 1;\n\n  size_t num_blocks = offsets.size();\n\n  std::vector<size_t> channel_offset_list;\n  int pixel_data_size = 0;\n  size_t channel_offset = 0;\n  if (!tinyexr::ComputeChannelLayout(&channel_offset_list, &pixel_data_size,\n                                     &channel_offset, num_channels,\n                                     exr_header->channels)) {\n    if (err) {\n      (*err) += \"Failed to compute channel layout.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  bool invalid_data = false;  // TODO(LTE): Use atomic lock for MT safety.\n\n  if (exr_header->tiled) {\n    size_t num_tiles = offsets.size();  // = # of blocks\n\n    exr_image->tiles = static_cast<EXRTile *>(\n        calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)));\n\n    for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) {\n      // Allocate memory for each tile.\n      exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(\n          num_channels, exr_header->channels, exr_header->requested_pixel_types,\n          exr_header->tile_size_x, exr_header->tile_size_y);\n\n      // 16 byte: tile coordinates\n      // 4 byte : data size\n      // ~      : data(uncompressed or compressed)\n      if (offsets[tile_idx] + sizeof(int) * 5 > size) {\n        if (err) {\n          (*err) += \"Insufficient data size.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5));\n      const unsigned char *data_ptr =\n          reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);\n\n      int tile_coordinates[4];\n      memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[0]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[1]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[2]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[3]));\n\n      // @todo{ LoD }\n      if (tile_coordinates[2] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n      if (tile_coordinates[3] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n\n      int data_len;\n      memcpy(&data_len, data_ptr + 16,\n             sizeof(int));  // 16 = sizeof(tile_coordinates)\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n      if (data_len < 4 || size_t(data_len) > data_size) {\n        if (err) {\n          (*err) += \"Insufficient data length.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      // Move to data addr: 20 = 16 + 4;\n      data_ptr += 20;\n\n      tinyexr::DecodeTiledPixelData(\n          exr_image->tiles[tile_idx].images,\n          &(exr_image->tiles[tile_idx].width),\n          &(exr_image->tiles[tile_idx].height),\n          exr_header->requested_pixel_types, data_ptr,\n          static_cast<size_t>(data_len), exr_header->compression_type,\n          exr_header->line_order, data_width, data_height, tile_coordinates[0],\n          tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y,\n          static_cast<size_t>(pixel_data_size),\n          static_cast<size_t>(exr_header->num_custom_attributes),\n          exr_header->custom_attributes,\n          static_cast<size_t>(exr_header->num_channels), exr_header->channels,\n          channel_offset_list);\n\n      exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];\n      exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];\n      exr_image->tiles[tile_idx].level_x = tile_coordinates[2];\n      exr_image->tiles[tile_idx].level_y = tile_coordinates[3];\n\n      exr_image->num_tiles = static_cast<int>(num_tiles);\n    }\n  } else {  // scanline format\n\n    exr_image->images = tinyexr::AllocateImage(\n        num_channels, exr_header->channels, exr_header->requested_pixel_types,\n        data_width, data_height);\n\n#ifdef _OPENMP\n#pragma omp parallel for\n#endif\n    for (int y = 0; y < static_cast<int>(num_blocks); y++) {\n      size_t y_idx = static_cast<size_t>(y);\n\n      if (offsets[y_idx] + sizeof(int) * 2 > size) {\n        invalid_data = true;\n      } else {\n        // 4 byte: scan line\n        // 4 byte: data size\n        // ~     : pixel data(uncompressed or compressed)\n        size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2));\n        const unsigned char *data_ptr =\n            reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);\n\n        int line_no;\n        memcpy(&line_no, data_ptr, sizeof(int));\n        int data_len;\n        memcpy(&data_len, data_ptr + 4, sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n        if (size_t(data_len) > data_size) {\n          invalid_data = true;\n        } else {\n          int end_line_no = (std::min)(line_no + num_scanline_blocks,\n                                       (exr_header->data_window[3] + 1));\n\n          int num_lines = end_line_no - line_no;\n          // assert(num_lines > 0);\n\n          if (num_lines <= 0) {\n            invalid_data = true;\n          } else {\n            // Move to data addr: 8 = 4 + 4;\n            data_ptr += 8;\n\n            // Adjust line_no with data_window.bmin.y\n            line_no -= exr_header->data_window[1];\n\n            if (line_no < 0) {\n              invalid_data = true;\n            } else {\n              if (!tinyexr::DecodePixelData(\n                      exr_image->images, exr_header->requested_pixel_types,\n                      data_ptr, static_cast<size_t>(data_len),\n                      exr_header->compression_type, exr_header->line_order,\n                      data_width, data_height, data_width, y, line_no,\n                      num_lines, static_cast<size_t>(pixel_data_size),\n                      static_cast<size_t>(exr_header->num_custom_attributes),\n                      exr_header->custom_attributes,\n                      static_cast<size_t>(exr_header->num_channels),\n                      exr_header->channels, channel_offset_list)) {\n                invalid_data = true;\n              }\n            }\n          }\n        }\n      }\n    }  // omp parallel\n  }\n\n  if (invalid_data) {\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Overwrite `pixel_type` with `requested_pixel_type`.\n  {\n    for (int c = 0; c < exr_header->num_channels; c++) {\n      exr_header->pixel_types[c] = exr_header->requested_pixel_types[c];\n    }\n  }\n\n  {\n    exr_image->num_channels = num_channels;\n\n    exr_image->width = data_width;\n    exr_image->height = data_height;\n  }\n\n  return TINYEXR_SUCCESS;\n}",
        "func": "static int DecodeChunk(EXRImage *exr_image, const EXRHeader *exr_header,\n                       const std::vector<tinyexr::tinyexr_uint64> &offsets,\n                       const unsigned char *head, const size_t size,\n                       std::string *err) {\n  int num_channels = exr_header->num_channels;\n\n  int num_scanline_blocks = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanline_blocks = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanline_blocks = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanline_blocks = 16;\n  }\n\n  int data_width = exr_header->data_window[2] - exr_header->data_window[0] + 1;\n  int data_height = exr_header->data_window[3] - exr_header->data_window[1] + 1;\n\n  if ((data_width < 0) || (data_height < 0)) {\n    if (err) {\n      std::stringstream ss;\n      ss << \"Invalid data width or data height: \" << data_width << \", \" << data_height << std::endl;\n      (*err) += ss.str();\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  size_t num_blocks = offsets.size();\n\n  std::vector<size_t> channel_offset_list;\n  int pixel_data_size = 0;\n  size_t channel_offset = 0;\n  if (!tinyexr::ComputeChannelLayout(&channel_offset_list, &pixel_data_size,\n                                     &channel_offset, num_channels,\n                                     exr_header->channels)) {\n    if (err) {\n      (*err) += \"Failed to compute channel layout.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  bool invalid_data = false;  // TODO(LTE): Use atomic lock for MT safety.\n\n  if (exr_header->tiled) {\n    size_t num_tiles = offsets.size();  // = # of blocks\n\n    exr_image->tiles = static_cast<EXRTile *>(\n        calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)));\n\n    for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) {\n      // Allocate memory for each tile.\n      exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(\n          num_channels, exr_header->channels, exr_header->requested_pixel_types,\n          exr_header->tile_size_x, exr_header->tile_size_y);\n\n      // 16 byte: tile coordinates\n      // 4 byte : data size\n      // ~      : data(uncompressed or compressed)\n      if (offsets[tile_idx] + sizeof(int) * 5 > size) {\n        if (err) {\n          (*err) += \"Insufficient data size.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5));\n      const unsigned char *data_ptr =\n          reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);\n\n      int tile_coordinates[4];\n      memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[0]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[1]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[2]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[3]));\n\n      // @todo{ LoD }\n      if (tile_coordinates[2] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n      if (tile_coordinates[3] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n\n      int data_len;\n      memcpy(&data_len, data_ptr + 16,\n             sizeof(int));  // 16 = sizeof(tile_coordinates)\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n      if (data_len < 4 || size_t(data_len) > data_size) {\n        if (err) {\n          (*err) += \"Insufficient data length.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      // Move to data addr: 20 = 16 + 4;\n      data_ptr += 20;\n\n      tinyexr::DecodeTiledPixelData(\n          exr_image->tiles[tile_idx].images,\n          &(exr_image->tiles[tile_idx].width),\n          &(exr_image->tiles[tile_idx].height),\n          exr_header->requested_pixel_types, data_ptr,\n          static_cast<size_t>(data_len), exr_header->compression_type,\n          exr_header->line_order, data_width, data_height, tile_coordinates[0],\n          tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y,\n          static_cast<size_t>(pixel_data_size),\n          static_cast<size_t>(exr_header->num_custom_attributes),\n          exr_header->custom_attributes,\n          static_cast<size_t>(exr_header->num_channels), exr_header->channels,\n          channel_offset_list);\n\n      exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];\n      exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];\n      exr_image->tiles[tile_idx].level_x = tile_coordinates[2];\n      exr_image->tiles[tile_idx].level_y = tile_coordinates[3];\n\n      exr_image->num_tiles = static_cast<int>(num_tiles);\n    }\n  } else {  // scanline format\n\n    // Don't allow too large image(256GB * pixel_data_size or more). Workaround for #104.\n    size_t data_len = size_t(data_width) * size_t(data_height) * size_t(num_channels);\n    if ((data_len == 0) || (data_len >= 0x4000000000)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Image data size is zero or too large: width = \" << data_width << \", height = \" << data_height << \", channels = \" << num_channels << std::endl;\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    exr_image->images = tinyexr::AllocateImage(\n        num_channels, exr_header->channels, exr_header->requested_pixel_types,\n        data_width, data_height);\n\n#ifdef _OPENMP\n#pragma omp parallel for\n#endif\n    for (int y = 0; y < static_cast<int>(num_blocks); y++) {\n      size_t y_idx = static_cast<size_t>(y);\n\n      if (offsets[y_idx] + sizeof(int) * 2 > size) {\n        invalid_data = true;\n      } else {\n        // 4 byte: scan line\n        // 4 byte: data size\n        // ~     : pixel data(uncompressed or compressed)\n        size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2));\n        const unsigned char *data_ptr =\n            reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);\n\n        int line_no;\n        memcpy(&line_no, data_ptr, sizeof(int));\n        int data_len;\n        memcpy(&data_len, data_ptr + 4, sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n        if (size_t(data_len) > data_size) {\n          invalid_data = true;\n        } else {\n          int end_line_no = (std::min)(line_no + num_scanline_blocks,\n                                       (exr_header->data_window[3] + 1));\n\n          int num_lines = end_line_no - line_no;\n          // assert(num_lines > 0);\n\n          if (num_lines <= 0) {\n            invalid_data = true;\n          } else {\n            // Move to data addr: 8 = 4 + 4;\n            data_ptr += 8;\n\n            // Adjust line_no with data_window.bmin.y\n            line_no -= exr_header->data_window[1];\n\n            if (line_no < 0) {\n              invalid_data = true;\n            } else {\n              if (!tinyexr::DecodePixelData(\n                      exr_image->images, exr_header->requested_pixel_types,\n                      data_ptr, static_cast<size_t>(data_len),\n                      exr_header->compression_type, exr_header->line_order,\n                      data_width, data_height, data_width, y, line_no,\n                      num_lines, static_cast<size_t>(pixel_data_size),\n                      static_cast<size_t>(exr_header->num_custom_attributes),\n                      exr_header->custom_attributes,\n                      static_cast<size_t>(exr_header->num_channels),\n                      exr_header->channels, channel_offset_list)) {\n                invalid_data = true;\n              }\n            }\n          }\n        }\n      }\n    }  // omp parallel\n  }\n\n  if (invalid_data) {\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Overwrite `pixel_type` with `requested_pixel_type`.\n  {\n    for (int c = 0; c < exr_header->num_channels; c++) {\n      exr_header->pixel_types[c] = exr_header->requested_pixel_types[c];\n    }\n  }\n\n  {\n    exr_image->num_channels = num_channels;\n\n    exr_image->width = data_width;\n    exr_image->height = data_height;\n  }\n\n  return TINYEXR_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,15 @@\n \n   int data_width = exr_header->data_window[2] - exr_header->data_window[0] + 1;\n   int data_height = exr_header->data_window[3] - exr_header->data_window[1] + 1;\n+\n+  if ((data_width < 0) || (data_height < 0)) {\n+    if (err) {\n+      std::stringstream ss;\n+      ss << \"Invalid data width or data height: \" << data_width << \", \" << data_height << std::endl;\n+      (*err) += ss.str();\n+    }\n+    return TINYEXR_ERROR_INVALID_DATA;\n+  }\n \n   size_t num_blocks = offsets.size();\n \n@@ -110,6 +119,17 @@\n       exr_image->num_tiles = static_cast<int>(num_tiles);\n     }\n   } else {  // scanline format\n+\n+    // Don't allow too large image(256GB * pixel_data_size or more). Workaround for #104.\n+    size_t data_len = size_t(data_width) * size_t(data_height) * size_t(num_channels);\n+    if ((data_len == 0) || (data_len >= 0x4000000000)) {\n+      if (err) {\n+        std::stringstream ss;\n+        ss << \"Image data size is zero or too large: width = \" << data_width << \", height = \" << data_height << \", channels = \" << num_channels << std::endl;\n+        (*err) += ss.str();\n+      }\n+      return TINYEXR_ERROR_INVALID_DATA;\n+    }\n \n     exr_image->images = tinyexr::AllocateImage(\n         num_channels, exr_header->channels, exr_header->requested_pixel_types,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if ((data_width < 0) || (data_height < 0)) {",
                "    if (err) {",
                "      std::stringstream ss;",
                "      ss << \"Invalid data width or data height: \" << data_width << \", \" << data_height << std::endl;",
                "      (*err) += ss.str();",
                "    }",
                "    return TINYEXR_ERROR_INVALID_DATA;",
                "  }",
                "",
                "    // Don't allow too large image(256GB * pixel_data_size or more). Workaround for #104.",
                "    size_t data_len = size_t(data_width) * size_t(data_height) * size_t(num_channels);",
                "    if ((data_len == 0) || (data_len >= 0x4000000000)) {",
                "      if (err) {",
                "        std::stringstream ss;",
                "        ss << \"Image data size is zero or too large: width = \" << data_width << \", height = \" << data_height << \", channels = \" << num_channels << std::endl;",
                "        (*err) += ss.str();",
                "      }",
                "      return TINYEXR_ERROR_INVALID_DATA;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20659",
        "func_name": "axiomatic-systems/Bento4/AP4_StcoAtom::AP4_StcoAtom",
        "description": "An issue was discovered in Bento4 1.5.1-627. The AP4_StcoAtom class in Core/Ap4StcoAtom.cpp has an attempted excessive memory allocation when called from AP4_AtomFactory::CreateAtomFromStream in Core/Ap4AtomFactory.cpp, as demonstrated by mp42hls.",
        "git_url": "https://github.com/axiomatic-systems/Bento4/commit/03f9fef0d8c5333557aa3b804c9bda838a846b88",
        "commit_title": "fix #350",
        "commit_text": "",
        "func_before": "AP4_StcoAtom::AP4_StcoAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags)\n{\n    stream.ReadUI32(m_EntryCount);\n    if (m_EntryCount > (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4) {\n        m_EntryCount = (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4;\n    }\n    m_Entries = new AP4_UI32[m_EntryCount];\n    unsigned char* buffer = new unsigned char[m_EntryCount*4];\n    AP4_Result result = stream.Read(buffer, m_EntryCount*4);\n    if (AP4_FAILED(result)) {\n        delete[] buffer;\n        return;\n    }\n    for (AP4_Ordinal i=0; i<m_EntryCount; i++) {\n        m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);\n    }\n    delete[] buffer;\n}",
        "func": "AP4_StcoAtom::AP4_StcoAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags),\n    m_EntryCount(0)\n{\n    if (size < AP4_FULL_ATOM_HEADER_SIZE+4) {\n        return;\n    }\n    stream.ReadUI32(m_EntryCount);\n    if (m_EntryCount > (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4) {\n        m_EntryCount = (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4;\n    }\n    m_Entries = new AP4_UI32[m_EntryCount];\n    unsigned char* buffer = new unsigned char[m_EntryCount*4];\n    AP4_Result result = stream.Read(buffer, m_EntryCount*4);\n    if (AP4_FAILED(result)) {\n        delete[] buffer;\n        return;\n    }\n    for (AP4_Ordinal i=0; i<m_EntryCount; i++) {\n        m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);\n    }\n    delete[] buffer;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,12 @@\n                            AP4_UI08        version,\n                            AP4_UI32        flags,\n                            AP4_ByteStream& stream) :\n-    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags)\n+    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags),\n+    m_EntryCount(0)\n {\n+    if (size < AP4_FULL_ATOM_HEADER_SIZE+4) {\n+        return;\n+    }\n     stream.ReadUI32(m_EntryCount);\n     if (m_EntryCount > (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4) {\n         m_EntryCount = (size-AP4_FULL_ATOM_HEADER_SIZE-4)/4;",
        "diff_line_info": {
            "deleted_lines": [
                "    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags)"
            ],
            "added_lines": [
                "    AP4_Atom(AP4_ATOM_TYPE_STCO, size, version, flags),",
                "    m_EntryCount(0)",
                "    if (size < AP4_FULL_ATOM_HEADER_SIZE+4) {",
                "        return;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7702",
        "func_name": "WebAssembly/binaryen/WasmBinaryBuilder::visitCall",
        "description": "A NULL pointer dereference was discovered in wasm::SExpressionWasmBuilder::parseExpression in wasm-s-parser.cpp in Binaryen 1.38.22. A crafted wasm input can cause a segmentation fault, leading to denial-of-service, as demonstrated by wasm-as.",
        "git_url": "https://github.com/WebAssembly/binaryen/commit/cbb24eb4a0810640c9dcee2f6682c64f9bc6c512",
        "commit_title": "Misc minor ASAN fixes (#1869)",
        "commit_text": " * handle end of input in skipWhitespace in s-parser. fixes #1863\r \r * ignore debug locations when not in a function ; fixes #1867\r \r * error properly on invalid user section sizes ; fixes #1866\r \r * throw a proper error on invalid call offsets in binary reading ; fixes #1865",
        "func_before": "void WasmBinaryBuilder::visitCall(Call* curr) {\n  if (debug) std::cerr << \"zz node: Call\" << std::endl;\n  auto index = getU32LEB();\n  FunctionType* type;\n  if (index < functionImports.size()) {\n    auto* import = functionImports[index];\n    type = wasm.getFunctionType(import->type);\n  } else {\n    auto adjustedIndex = index - functionImports.size();\n    type = functionTypes[adjustedIndex];\n  }\n  assert(type);\n  auto num = type->params.size();\n  curr->operands.resize(num);\n  for (size_t i = 0; i < num; i++) {\n    curr->operands[num - i - 1] = popNonVoidExpression();\n  }\n  curr->type = type->result;\n  functionCalls[index].push_back(curr); // we don't know function names yet\n  curr->finalize();\n}",
        "func": "void WasmBinaryBuilder::visitCall(Call* curr) {\n  if (debug) std::cerr << \"zz node: Call\" << std::endl;\n  auto index = getU32LEB();\n  FunctionType* type;\n  if (index < functionImports.size()) {\n    auto* import = functionImports[index];\n    type = wasm.getFunctionType(import->type);\n  } else {\n    Index adjustedIndex = index - functionImports.size();\n    if (adjustedIndex >= functionTypes.size()) {\n      throwError(\"invalid call index\");\n    }\n    type = functionTypes[adjustedIndex];\n  }\n  assert(type);\n  auto num = type->params.size();\n  curr->operands.resize(num);\n  for (size_t i = 0; i < num; i++) {\n    curr->operands[num - i - 1] = popNonVoidExpression();\n  }\n  curr->type = type->result;\n  functionCalls[index].push_back(curr); // we don't know function names yet\n  curr->finalize();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,10 @@\n     auto* import = functionImports[index];\n     type = wasm.getFunctionType(import->type);\n   } else {\n-    auto adjustedIndex = index - functionImports.size();\n+    Index adjustedIndex = index - functionImports.size();\n+    if (adjustedIndex >= functionTypes.size()) {\n+      throwError(\"invalid call index\");\n+    }\n     type = functionTypes[adjustedIndex];\n   }\n   assert(type);",
        "diff_line_info": {
            "deleted_lines": [
                "    auto adjustedIndex = index - functionImports.size();"
            ],
            "added_lines": [
                "    Index adjustedIndex = index - functionImports.size();",
                "    if (adjustedIndex >= functionTypes.size()) {",
                "      throwError(\"invalid call index\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7702",
        "func_name": "WebAssembly/binaryen/WasmBinaryBuilder::readUserSection",
        "description": "A NULL pointer dereference was discovered in wasm::SExpressionWasmBuilder::parseExpression in wasm-s-parser.cpp in Binaryen 1.38.22. A crafted wasm input can cause a segmentation fault, leading to denial-of-service, as demonstrated by wasm-as.",
        "git_url": "https://github.com/WebAssembly/binaryen/commit/cbb24eb4a0810640c9dcee2f6682c64f9bc6c512",
        "commit_title": "Misc minor ASAN fixes (#1869)",
        "commit_text": " * handle end of input in skipWhitespace in s-parser. fixes #1863\r \r * ignore debug locations when not in a function ; fixes #1867\r \r * error properly on invalid user section sizes ; fixes #1866\r \r * throw a proper error on invalid call offsets in binary reading ; fixes #1865",
        "func_before": "void WasmBinaryBuilder::readUserSection(size_t payloadLen) {\n  auto oldPos = pos;\n  Name sectionName = getInlineString();\n  if (sectionName.equals(BinaryConsts::UserSections::Name)) {\n    readNames(payloadLen - (pos - oldPos));\n  } else {\n    // an unfamiliar custom section\n    if (sectionName.equals(BinaryConsts::UserSections::Linking)) {\n      std::cerr << \"warning: linking section is present, which binaryen cannot handle yet - relocations will be invalidated!\\n\";\n    }\n    wasm.userSections.resize(wasm.userSections.size() + 1);\n    auto& section = wasm.userSections.back();\n    section.name = sectionName.str;\n    auto sectionSize = payloadLen - (pos - oldPos);\n    section.data.resize(sectionSize);\n    for (size_t i = 0; i < sectionSize; i++) {\n      section.data[i] = getInt8();\n    }\n  }\n}",
        "func": "void WasmBinaryBuilder::readUserSection(size_t payloadLen) {\n  auto oldPos = pos;\n  Name sectionName = getInlineString();\n  size_t read = pos - oldPos;\n  if (read > payloadLen) {\n    throwError(\"bad user section size\");\n  }\n  payloadLen -= read;\n  if (sectionName.equals(BinaryConsts::UserSections::Name)) {\n    readNames(payloadLen);\n  } else {\n    // an unfamiliar custom section\n    if (sectionName.equals(BinaryConsts::UserSections::Linking)) {\n      std::cerr << \"warning: linking section is present, which binaryen cannot handle yet - relocations will be invalidated!\\n\";\n    }\n    wasm.userSections.resize(wasm.userSections.size() + 1);\n    auto& section = wasm.userSections.back();\n    section.name = sectionName.str;\n    auto sectionSize = payloadLen;\n    section.data.resize(sectionSize);\n    for (size_t i = 0; i < sectionSize; i++) {\n      section.data[i] = getInt8();\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,13 @@\n void WasmBinaryBuilder::readUserSection(size_t payloadLen) {\n   auto oldPos = pos;\n   Name sectionName = getInlineString();\n+  size_t read = pos - oldPos;\n+  if (read > payloadLen) {\n+    throwError(\"bad user section size\");\n+  }\n+  payloadLen -= read;\n   if (sectionName.equals(BinaryConsts::UserSections::Name)) {\n-    readNames(payloadLen - (pos - oldPos));\n+    readNames(payloadLen);\n   } else {\n     // an unfamiliar custom section\n     if (sectionName.equals(BinaryConsts::UserSections::Linking)) {\n@@ -11,7 +16,7 @@\n     wasm.userSections.resize(wasm.userSections.size() + 1);\n     auto& section = wasm.userSections.back();\n     section.name = sectionName.str;\n-    auto sectionSize = payloadLen - (pos - oldPos);\n+    auto sectionSize = payloadLen;\n     section.data.resize(sectionSize);\n     for (size_t i = 0; i < sectionSize; i++) {\n       section.data[i] = getInt8();",
        "diff_line_info": {
            "deleted_lines": [
                "    readNames(payloadLen - (pos - oldPos));",
                "    auto sectionSize = payloadLen - (pos - oldPos);"
            ],
            "added_lines": [
                "  size_t read = pos - oldPos;",
                "  if (read > payloadLen) {",
                "    throwError(\"bad user section size\");",
                "  }",
                "  payloadLen -= read;",
                "    readNames(payloadLen);",
                "    auto sectionSize = payloadLen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7702",
        "func_name": "WebAssembly/binaryen/SExpressionParser::skipWhitespace",
        "description": "A NULL pointer dereference was discovered in wasm::SExpressionWasmBuilder::parseExpression in wasm-s-parser.cpp in Binaryen 1.38.22. A crafted wasm input can cause a segmentation fault, leading to denial-of-service, as demonstrated by wasm-as.",
        "git_url": "https://github.com/WebAssembly/binaryen/commit/cbb24eb4a0810640c9dcee2f6682c64f9bc6c512",
        "commit_title": "Misc minor ASAN fixes (#1869)",
        "commit_text": " * handle end of input in skipWhitespace in s-parser. fixes #1863\r \r * ignore debug locations when not in a function ; fixes #1867\r \r * error properly on invalid user section sizes ; fixes #1866\r \r * throw a proper error on invalid call offsets in binary reading ; fixes #1865",
        "func_before": "void SExpressionParser::skipWhitespace() {\n  while (1) {\n    while (isspace(input[0])) {\n      if (input[0] == '\\n') {\n        line++;\n        lineStart = input + 1;\n      }\n      input++;\n    }\n    if (input[0] == ';' && input[1] == ';') {\n      if (input[2] == '@') {\n        parseDebugLocation();\n      }\n      while (input[0] && input[0] != '\\n') input++;\n      line++;\n      lineStart = ++input;\n    } else if (input[0] == '(' && input[1] == ';') {\n      // Skip nested block comments.\n      input += 2;\n      int depth = 1;\n      while (1) {\n        if (input[0] == 0) {\n          return;\n        }\n        if (input[0] == '(' && input[1] == ';') {\n          input += 2;\n          depth++;\n        } else if (input[0] == ';' && input[1] == ')') {\n          input += 2;\n          --depth;\n          if (depth == 0) {\n            break;\n          }\n        } else if (input[0] == '\\n') {\n          line++;\n          lineStart = input;\n          input++;\n        } else {\n          input++;\n        }\n      }\n    } else {\n      return;\n    }\n  }\n}",
        "func": "void SExpressionParser::skipWhitespace() {\n  while (1) {\n    while (isspace(input[0])) {\n      if (input[0] == '\\n') {\n        line++;\n        lineStart = input + 1;\n      }\n      input++;\n    }\n    if (input[0] == ';' && input[1] == ';') {\n      if (input[2] == '@') {\n        parseDebugLocation();\n      }\n      while (input[0] && input[0] != '\\n') input++;\n      line++;\n      if (!input[0]) return;\n      lineStart = ++input;\n    } else if (input[0] == '(' && input[1] == ';') {\n      // Skip nested block comments.\n      input += 2;\n      int depth = 1;\n      while (1) {\n        if (!input[0]) return;\n        if (input[0] == '(' && input[1] == ';') {\n          input += 2;\n          depth++;\n        } else if (input[0] == ';' && input[1] == ')') {\n          input += 2;\n          --depth;\n          if (depth == 0) {\n            break;\n          }\n        } else if (input[0] == '\\n') {\n          line++;\n          lineStart = input;\n          input++;\n        } else {\n          input++;\n        }\n      }\n    } else {\n      return;\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,15 +13,14 @@\n       }\n       while (input[0] && input[0] != '\\n') input++;\n       line++;\n+      if (!input[0]) return;\n       lineStart = ++input;\n     } else if (input[0] == '(' && input[1] == ';') {\n       // Skip nested block comments.\n       input += 2;\n       int depth = 1;\n       while (1) {\n-        if (input[0] == 0) {\n-          return;\n-        }\n+        if (!input[0]) return;\n         if (input[0] == '(' && input[1] == ';') {\n           input += 2;\n           depth++;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (input[0] == 0) {",
                "          return;",
                "        }"
            ],
            "added_lines": [
                "      if (!input[0]) return;",
                "        if (!input[0]) return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7702",
        "func_name": "WebAssembly/binaryen/SExpressionWasmBuilder::parseExpression",
        "description": "A NULL pointer dereference was discovered in wasm::SExpressionWasmBuilder::parseExpression in wasm-s-parser.cpp in Binaryen 1.38.22. A crafted wasm input can cause a segmentation fault, leading to denial-of-service, as demonstrated by wasm-as.",
        "git_url": "https://github.com/WebAssembly/binaryen/commit/cbb24eb4a0810640c9dcee2f6682c64f9bc6c512",
        "commit_title": "Misc minor ASAN fixes (#1869)",
        "commit_text": " * handle end of input in skipWhitespace in s-parser. fixes #1863\r \r * ignore debug locations when not in a function ; fixes #1867\r \r * error properly on invalid user section sizes ; fixes #1866\r \r * throw a proper error on invalid call offsets in binary reading ; fixes #1865",
        "func_before": "Expression* SExpressionWasmBuilder::parseExpression(Element& s) {\n  Expression* result = makeExpression(s);\n  if (s.startLoc) {\n    currFunction->debugLocations[result] = getDebugLocation(*s.startLoc);\n  }\n  return result;\n}",
        "func": "Expression* SExpressionWasmBuilder::parseExpression(Element& s) {\n  Expression* result = makeExpression(s);\n  if (s.startLoc && currFunction) {\n    currFunction->debugLocations[result] = getDebugLocation(*s.startLoc);\n  }\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n Expression* SExpressionWasmBuilder::parseExpression(Element& s) {\n   Expression* result = makeExpression(s);\n-  if (s.startLoc) {\n+  if (s.startLoc && currFunction) {\n     currFunction->debugLocations[result] = getDebugLocation(*s.startLoc);\n   }\n   return result;",
        "diff_line_info": {
            "deleted_lines": [
                "  if (s.startLoc) {"
            ],
            "added_lines": [
                "  if (s.startLoc && currFunction) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33910",
        "func_name": "systemd/unit_name_path_escape",
        "description": "basic/unit-name.c in systemd prior to 246.15, 247.8, 248.5, and 249.1 has a Memory Allocation with an Excessive Size Value (involving strdupa and alloca for a pathname controlled by a local attacker) that results in an operating system crash.",
        "git_url": "https://github.com/systemd/systemd/commit/441e0115646d54f080e5c3bb0ba477c892861ab9",
        "commit_title": "basic/unit-name: do not use strdupa() on a path",
        "commit_text": " The path may have unbounded length, for example through a fuse mount.  CVE-2021-33910: attacked controlled alloca() leads to crash in systemd and ultimately a kernel panic. Systemd parses the content of /proc/self/mountinfo and each mountpoint is passed to mount_setup_unit(), which calls unit_name_path_escape() underneath. A local attacker who is able to mount a filesystem with a very long path can crash systemd and the whole system.  https://bugzilla.redhat.com/show_bug.cgi?id=1970887  The resulting string length is bounded by UNIT_NAME_MAX, which is 256. But we can't easily check the length after simplification before doing the simplification, which in turns uses a copy of the string we can write to. So we can't reject paths that are too long before doing the duplication. Hence the most obvious solution is to switch back to strdup(), as before 7410616cd9dbbec97cf98d75324da5cda2b2f7a2.",
        "func_before": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n\n        assert(f);\n        assert(ret);\n\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n\n        path_simplify(p);\n\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n\n                /* Truncate trailing slashes */\n                delete_trailing_chars(p, \"/\");\n\n                /* Truncate leading slashes */\n                p = skip_leading_chars(p, \"/\");\n\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n\n        *ret = s;\n        return 0;\n}",
        "func": "int unit_name_path_escape(const char *f, char **ret) {\n        _cleanup_free_ char *p = NULL;\n        char *s;\n\n        assert(f);\n        assert(ret);\n\n        p = strdup(f);\n        if (!p)\n                return -ENOMEM;\n\n        path_simplify(p);\n\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n\n                /* Truncate trailing slashes and skip leading slashes */\n                delete_trailing_chars(p, \"/\");\n                s = unit_name_escape(skip_leading_chars(p, \"/\"));\n        }\n        if (!s)\n                return -ENOMEM;\n\n        *ret = s;\n        return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,11 @@\n int unit_name_path_escape(const char *f, char **ret) {\n-        char *p, *s;\n+        _cleanup_free_ char *p = NULL;\n+        char *s;\n \n         assert(f);\n         assert(ret);\n \n-        p = strdupa(f);\n+        p = strdup(f);\n         if (!p)\n                 return -ENOMEM;\n \n@@ -16,13 +17,9 @@\n                 if (!path_is_normalized(p))\n                         return -EINVAL;\n \n-                /* Truncate trailing slashes */\n+                /* Truncate trailing slashes and skip leading slashes */\n                 delete_trailing_chars(p, \"/\");\n-\n-                /* Truncate leading slashes */\n-                p = skip_leading_chars(p, \"/\");\n-\n-                s = unit_name_escape(p);\n+                s = unit_name_escape(skip_leading_chars(p, \"/\"));\n         }\n         if (!s)\n                 return -ENOMEM;",
        "diff_line_info": {
            "deleted_lines": [
                "        char *p, *s;",
                "        p = strdupa(f);",
                "                /* Truncate trailing slashes */",
                "",
                "                /* Truncate leading slashes */",
                "                p = skip_leading_chars(p, \"/\");",
                "",
                "                s = unit_name_escape(p);"
            ],
            "added_lines": [
                "        _cleanup_free_ char *p = NULL;",
                "        char *s;",
                "        p = strdup(f);",
                "                /* Truncate trailing slashes and skip leading slashes */",
                "                s = unit_name_escape(skip_leading_chars(p, \"/\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32675",
        "func_name": "redis/processMultibulkBuffer",
        "description": "Redis is an open source, in-memory database that persists on disk. When parsing an incoming Redis Standard Protocol (RESP) request, Redis allocates memory according to user-specified values which determine the number of elements (in the multi-bulk header) and size of each element (in the bulk header). An attacker delivering specially crafted requests over multiple connections can cause the server to allocate significant amount of memory. Because the same parsing mechanism is used to handle authentication requests, this vulnerability can also be exploited by unauthenticated users. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate this problem without patching the redis-server executable is to block access to prevent unauthenticated users from connecting to Redis. This can be done in different ways: Using network access control tools like firewalls, iptables, security groups, etc. or Enabling TLS and requiring users to authenticate using client side certificates.",
        "git_url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8",
        "commit_title": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)",
        "commit_text": " This change sets a low limit for multibulk and bulk length in the protocol for unauthenticated connections, so that they can't easily cause redis to allocate massive amounts of memory by sending just a few characters on the network. The new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
        "func_before": "int processMultibulkBuffer(client *c) {\n    char *newline = NULL;\n    int ok;\n    long long ll;\n\n    if (c->multibulklen == 0) {\n        /* The client should have been reset */\n        serverAssertWithInfo(c,NULL,c->argc == 0);\n\n        /* Multi bulk length cannot be read without a \\r\\n */\n        newline = strchr(c->querybuf+c->qb_pos,'\\r');\n        if (newline == NULL) {\n            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                addReplyError(c,\"Protocol error: too big mbulk count string\");\n                setProtocolError(\"too big mbulk count string\",c);\n            }\n            return C_ERR;\n        }\n\n        /* Buffer should also contain \\n */\n        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n            return C_ERR;\n\n        /* We know for sure there is a whole line since newline != NULL,\n         * so go ahead and find out the multi bulk length. */\n        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');\n        ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);\n        if (!ok || ll > 1024*1024) {\n            addReplyError(c,\"Protocol error: invalid multibulk length\");\n            setProtocolError(\"invalid mbulk count\",c);\n            return C_ERR;\n        }\n\n        c->qb_pos = (newline-c->querybuf)+2;\n\n        if (ll <= 0) return C_OK;\n\n        c->multibulklen = ll;\n\n        /* Setup argv array on client structure */\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*c->multibulklen);\n        c->argv_len_sum = 0;\n    }\n\n    serverAssertWithInfo(c,NULL,c->multibulklen > 0);\n    while(c->multibulklen) {\n        /* Read bulk length if unknown */\n        if (c->bulklen == -1) {\n            newline = strchr(c->querybuf+c->qb_pos,'\\r');\n            if (newline == NULL) {\n                if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                    addReplyError(c,\n                        \"Protocol error: too big bulk count string\");\n                    setProtocolError(\"too big bulk count string\",c);\n                    return C_ERR;\n                }\n                break;\n            }\n\n            /* Buffer should also contain \\n */\n            if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n                break;\n\n            if (c->querybuf[c->qb_pos] != '$') {\n                addReplyErrorFormat(c,\n                    \"Protocol error: expected '$', got '%c'\",\n                    c->querybuf[c->qb_pos]);\n                setProtocolError(\"expected $ but got something else\",c);\n                return C_ERR;\n            }\n\n            ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);\n            if (!ok || ll < 0 ||\n                (!(c->flags & CLIENT_MASTER) && ll > server.proto_max_bulk_len)) {\n                addReplyError(c,\"Protocol error: invalid bulk length\");\n                setProtocolError(\"invalid bulk length\",c);\n                return C_ERR;\n            }\n\n            c->qb_pos = newline-c->querybuf+2;\n            if (ll >= PROTO_MBULK_BIG_ARG) {\n                /* If we are going to read a large object from network\n                 * try to make it likely that it will start at c->querybuf\n                 * boundary so that we can optimize object creation\n                 * avoiding a large copy of data.\n                 *\n                 * But only when the data we have not parsed is less than\n                 * or equal to ll+2. If the data length is greater than\n                 * ll+2, trimming querybuf is just a waste of time, because\n                 * at this time the querybuf contains not only our bulk. */\n                if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {\n                    sdsrange(c->querybuf,c->qb_pos,-1);\n                    c->qb_pos = 0;\n                    /* Hint the sds library about the amount of bytes this string is\n                     * going to contain. */\n                    c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2-sdslen(c->querybuf));\n                }\n            }\n            c->bulklen = ll;\n        }\n\n        /* Read bulk argument */\n        if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {\n            /* Not enough data (+2 == trailing \\r\\n) */\n            break;\n        } else {\n            /* Optimization: if the buffer contains JUST our bulk element\n             * instead of creating a new object by *copying* the sds we\n             * just use the current sds string. */\n            if (c->qb_pos == 0 &&\n                c->bulklen >= PROTO_MBULK_BIG_ARG &&\n                sdslen(c->querybuf) == (size_t)(c->bulklen+2))\n            {\n                c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);\n                c->argv_len_sum += c->bulklen;\n                sdsIncrLen(c->querybuf,-2); /* remove CRLF */\n                /* Assume that if we saw a fat argument we'll see another one\n                 * likely... */\n                c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);\n                sdsclear(c->querybuf);\n            } else {\n                c->argv[c->argc++] =\n                    createStringObject(c->querybuf+c->qb_pos,c->bulklen);\n                c->argv_len_sum += c->bulklen;\n                c->qb_pos += c->bulklen+2;\n            }\n            c->bulklen = -1;\n            c->multibulklen--;\n        }\n    }\n\n    /* We're done when c->multibulk == 0 */\n    if (c->multibulklen == 0) return C_OK;\n\n    /* Still not ready to process the command */\n    return C_ERR;\n}",
        "func": "int processMultibulkBuffer(client *c) {\n    char *newline = NULL;\n    int ok;\n    long long ll;\n\n    if (c->multibulklen == 0) {\n        /* The client should have been reset */\n        serverAssertWithInfo(c,NULL,c->argc == 0);\n\n        /* Multi bulk length cannot be read without a \\r\\n */\n        newline = strchr(c->querybuf+c->qb_pos,'\\r');\n        if (newline == NULL) {\n            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                addReplyError(c,\"Protocol error: too big mbulk count string\");\n                setProtocolError(\"too big mbulk count string\",c);\n            }\n            return C_ERR;\n        }\n\n        /* Buffer should also contain \\n */\n        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n            return C_ERR;\n\n        /* We know for sure there is a whole line since newline != NULL,\n         * so go ahead and find out the multi bulk length. */\n        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_pos] == '*');\n        ok = string2ll(c->querybuf+1+c->qb_pos,newline-(c->querybuf+1+c->qb_pos),&ll);\n        if (!ok || ll > 1024*1024) {\n            addReplyError(c,\"Protocol error: invalid multibulk length\");\n            setProtocolError(\"invalid mbulk count\",c);\n            return C_ERR;\n        } else if (ll > 10 && authRequired(c)) {\n            addReplyError(c, \"Protocol error: unauthenticated multibulk length\");\n            setProtocolError(\"unauth mbulk count\", c);\n            return C_ERR;\n        }\n\n        c->qb_pos = (newline-c->querybuf)+2;\n\n        if (ll <= 0) return C_OK;\n\n        c->multibulklen = ll;\n\n        /* Setup argv array on client structure */\n        if (c->argv) zfree(c->argv);\n        c->argv = zmalloc(sizeof(robj*)*c->multibulklen);\n        c->argv_len_sum = 0;\n    }\n\n    serverAssertWithInfo(c,NULL,c->multibulklen > 0);\n    while(c->multibulklen) {\n        /* Read bulk length if unknown */\n        if (c->bulklen == -1) {\n            newline = strchr(c->querybuf+c->qb_pos,'\\r');\n            if (newline == NULL) {\n                if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {\n                    addReplyError(c,\n                        \"Protocol error: too big bulk count string\");\n                    setProtocolError(\"too big bulk count string\",c);\n                    return C_ERR;\n                }\n                break;\n            }\n\n            /* Buffer should also contain \\n */\n            if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))\n                break;\n\n            if (c->querybuf[c->qb_pos] != '$') {\n                addReplyErrorFormat(c,\n                    \"Protocol error: expected '$', got '%c'\",\n                    c->querybuf[c->qb_pos]);\n                setProtocolError(\"expected $ but got something else\",c);\n                return C_ERR;\n            }\n\n            ok = string2ll(c->querybuf+c->qb_pos+1,newline-(c->querybuf+c->qb_pos+1),&ll);\n            if (!ok || ll < 0 ||\n                (!(c->flags & CLIENT_MASTER) && ll > server.proto_max_bulk_len)) {\n                addReplyError(c,\"Protocol error: invalid bulk length\");\n                setProtocolError(\"invalid bulk length\",c);\n                return C_ERR;\n            } else if (ll > 16384 && authRequired(c)) {\n                addReplyError(c, \"Protocol error: unauthenticated bulk length\");\n                setProtocolError(\"unauth bulk length\", c);\n                return C_ERR;\n            }\n\n            c->qb_pos = newline-c->querybuf+2;\n            if (ll >= PROTO_MBULK_BIG_ARG) {\n                /* If we are going to read a large object from network\n                 * try to make it likely that it will start at c->querybuf\n                 * boundary so that we can optimize object creation\n                 * avoiding a large copy of data.\n                 *\n                 * But only when the data we have not parsed is less than\n                 * or equal to ll+2. If the data length is greater than\n                 * ll+2, trimming querybuf is just a waste of time, because\n                 * at this time the querybuf contains not only our bulk. */\n                if (sdslen(c->querybuf)-c->qb_pos <= (size_t)ll+2) {\n                    sdsrange(c->querybuf,c->qb_pos,-1);\n                    c->qb_pos = 0;\n                    /* Hint the sds library about the amount of bytes this string is\n                     * going to contain. */\n                    c->querybuf = sdsMakeRoomFor(c->querybuf,ll+2-sdslen(c->querybuf));\n                }\n            }\n            c->bulklen = ll;\n        }\n\n        /* Read bulk argument */\n        if (sdslen(c->querybuf)-c->qb_pos < (size_t)(c->bulklen+2)) {\n            /* Not enough data (+2 == trailing \\r\\n) */\n            break;\n        } else {\n            /* Optimization: if the buffer contains JUST our bulk element\n             * instead of creating a new object by *copying* the sds we\n             * just use the current sds string. */\n            if (c->qb_pos == 0 &&\n                c->bulklen >= PROTO_MBULK_BIG_ARG &&\n                sdslen(c->querybuf) == (size_t)(c->bulklen+2))\n            {\n                c->argv[c->argc++] = createObject(OBJ_STRING,c->querybuf);\n                c->argv_len_sum += c->bulklen;\n                sdsIncrLen(c->querybuf,-2); /* remove CRLF */\n                /* Assume that if we saw a fat argument we'll see another one\n                 * likely... */\n                c->querybuf = sdsnewlen(SDS_NOINIT,c->bulklen+2);\n                sdsclear(c->querybuf);\n            } else {\n                c->argv[c->argc++] =\n                    createStringObject(c->querybuf+c->qb_pos,c->bulklen);\n                c->argv_len_sum += c->bulklen;\n                c->qb_pos += c->bulklen+2;\n            }\n            c->bulklen = -1;\n            c->multibulklen--;\n        }\n    }\n\n    /* We're done when c->multibulk == 0 */\n    if (c->multibulklen == 0) return C_OK;\n\n    /* Still not ready to process the command */\n    return C_ERR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,10 @@\n         if (!ok || ll > 1024*1024) {\n             addReplyError(c,\"Protocol error: invalid multibulk length\");\n             setProtocolError(\"invalid mbulk count\",c);\n+            return C_ERR;\n+        } else if (ll > 10 && authRequired(c)) {\n+            addReplyError(c, \"Protocol error: unauthenticated multibulk length\");\n+            setProtocolError(\"unauth mbulk count\", c);\n             return C_ERR;\n         }\n \n@@ -75,6 +79,10 @@\n                 (!(c->flags & CLIENT_MASTER) && ll > server.proto_max_bulk_len)) {\n                 addReplyError(c,\"Protocol error: invalid bulk length\");\n                 setProtocolError(\"invalid bulk length\",c);\n+                return C_ERR;\n+            } else if (ll > 16384 && authRequired(c)) {\n+                addReplyError(c, \"Protocol error: unauthenticated bulk length\");\n+                setProtocolError(\"unauth bulk length\", c);\n                 return C_ERR;\n             }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            return C_ERR;",
                "        } else if (ll > 10 && authRequired(c)) {",
                "            addReplyError(c, \"Protocol error: unauthenticated multibulk length\");",
                "            setProtocolError(\"unauth mbulk count\", c);",
                "                return C_ERR;",
                "            } else if (ll > 16384 && authRequired(c)) {",
                "                addReplyError(c, \"Protocol error: unauthenticated bulk length\");",
                "                setProtocolError(\"unauth bulk length\", c);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32675",
        "func_name": "redis/processCommand",
        "description": "Redis is an open source, in-memory database that persists on disk. When parsing an incoming Redis Standard Protocol (RESP) request, Redis allocates memory according to user-specified values which determine the number of elements (in the multi-bulk header) and size of each element (in the bulk header). An attacker delivering specially crafted requests over multiple connections can cause the server to allocate significant amount of memory. Because the same parsing mechanism is used to handle authentication requests, this vulnerability can also be exploited by unauthenticated users. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate this problem without patching the redis-server executable is to block access to prevent unauthenticated users from connecting to Redis. This can be done in different ways: Using network access control tools like firewalls, iptables, security groups, etc. or Enabling TLS and requiring users to authenticate using client side certificates.",
        "git_url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8",
        "commit_title": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)",
        "commit_text": " This change sets a low limit for multibulk and bulk length in the protocol for unauthenticated connections, so that they can't easily cause redis to allocate massive amounts of memory by sending just a few characters on the network. The new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
        "func_before": "int processCommand(client *c) {\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n\n    /* Check if the user is authenticated. This check is skipped in case\n     * the default user is flagged as \"nopass\" and is active. */\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    if (auth_required) {\n        /* AUTH and HELLO and no auth modules are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_keypos;\n    int acl_retval = ACLCheckCommandPerm(c,&acl_keypos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_keypos,NULL);\n        if (acl_retval == ACL_DENIED_CMD)\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n        else\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(c->cmd->getkeys_proc == NULL && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;\n        /* freeMemoryIfNeeded may flush slave output buffers. This may result\n         * into a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n    return C_OK;\n}",
        "func": "int processCommand(client *c) {\n    moduleCallCommandFilters(c);\n\n    /* The QUIT command is handled separately. Normal command procs will\n     * go through checking for replication and QUIT will cause trouble\n     * when FORCE_REPLICATION is enabled and would be implemented in\n     * a regular command proc. */\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= CLIENT_CLOSE_AFTER_REPLY;\n        return C_ERR;\n    }\n\n    /* Now lookup the command and check ASAP about trivial error conditions\n     * such as wrong arity, bad command name and so forth. */\n    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);\n    if (!c->cmd) {\n        sds args = sdsempty();\n        int i;\n        for (i=1; i < c->argc && sdslen(args) < 128; i++)\n            args = sdscatprintf(args, \"`%.*s`, \", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);\n        rejectCommandFormat(c,\"unknown command `%s`, with args beginning with: %s\",\n            (char*)c->argv[0]->ptr, args);\n        sdsfree(args);\n        return C_OK;\n    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||\n               (c->argc < -c->cmd->arity)) {\n        rejectCommandFormat(c,\"wrong number of arguments for '%s' command\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    int is_write_command = (c->cmd->flags & CMD_WRITE) ||\n                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));\n    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||\n                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));\n    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||\n                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));\n    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n\n    if (authRequired(c)) {\n        /* AUTH and HELLO and no auth commands are valid even in\n         * non-authenticated state. */\n        if (!(c->cmd->flags & CMD_NO_AUTH)) {\n            rejectCommand(c,shared.noautherr);\n            return C_OK;\n        }\n    }\n\n    /* Check if the user can run this command according to the current\n     * ACLs. */\n    int acl_keypos;\n    int acl_retval = ACLCheckCommandPerm(c,&acl_keypos);\n    if (acl_retval != ACL_OK) {\n        addACLLogEntry(c,acl_retval,acl_keypos,NULL);\n        if (acl_retval == ACL_DENIED_CMD)\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to run \"\n                \"the '%s' command or its subcommand\", c->cmd->name);\n        else\n            rejectCommandFormat(c,\n                \"-NOPERM this user has no permissions to access \"\n                \"one of the keys used as arguments\");\n        return C_OK;\n    }\n\n    /* If cluster is enabled perform the cluster redirection here.\n     * However we don't perform the redirection if:\n     * 1) The sender of this command is our master.\n     * 2) The command has no key arguments. */\n    if (server.cluster_enabled &&\n        !(c->flags & CLIENT_MASTER) &&\n        !(c->flags & CLIENT_LUA &&\n          server.lua_caller->flags & CLIENT_MASTER) &&\n        !(c->cmd->getkeys_proc == NULL && c->cmd->firstkey == 0 &&\n          c->cmd->proc != execCommand))\n    {\n        int hashslot;\n        int error_code;\n        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,\n                                        &hashslot,&error_code);\n        if (n == NULL || n != server.cluster->myself) {\n            if (c->cmd->proc == execCommand) {\n                discardTransaction(c);\n            } else {\n                flagTransaction(c);\n            }\n            clusterRedirectClient(c,n,hashslot,error_code);\n            return C_OK;\n        }\n    }\n\n    /* Handle the maxmemory directive.\n     *\n     * Note that we do not want to reclaim memory if we are here re-entering\n     * the event loop since there is a busy Lua script running in timeout\n     * condition, to avoid mixing the propagation of scripts with the\n     * propagation of DELs due to eviction. */\n    if (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;\n        /* freeMemoryIfNeeded may flush slave output buffers. This may result\n         * into a slave, that may be the active client, to be freed. */\n        if (server.current_client == NULL) return C_ERR;\n\n        int reject_cmd_on_oom = is_denyoom_command;\n        /* If client is in MULTI/EXEC context, queuing may consume an unlimited\n         * amount of memory, so we want to stop that.\n         * However, we never want to reject DISCARD, or even EXEC (unless it\n         * contains denied commands, in which case is_denyoom_command is already\n         * set. */\n        if (c->flags & CLIENT_MULTI &&\n            c->cmd->proc != execCommand &&\n            c->cmd->proc != discardCommand) {\n            reject_cmd_on_oom = 1;\n        }\n\n        if (out_of_memory && reject_cmd_on_oom) {\n            rejectCommand(c, shared.oomerr);\n            return C_OK;\n        }\n\n        /* Save out_of_memory result at script start, otherwise if we check OOM\n         * until first write within script, memory used by lua stack and\n         * arguments might interfere. */\n        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {\n            server.lua_oom = out_of_memory;\n        }\n    }\n\n    /* Make sure to use a reasonable amount of memory for client side\n     * caching metadata. */\n    if (server.tracking_clients) trackingLimitUsedSlots();\n\n    /* Don't accept write commands if there are problems persisting on disk\n     * and if this is a master instance. */\n    int deny_write_type = writeCommandsDeniedByDiskError();\n    if (deny_write_type != DISK_ERROR_TYPE_NONE &&\n        server.masterhost == NULL &&\n        (is_write_command ||c->cmd->proc == pingCommand))\n    {\n        if (deny_write_type == DISK_ERROR_TYPE_RDB)\n            rejectCommand(c, shared.bgsaveerr);\n        else\n            rejectCommandFormat(c,\n                \"-MISCONF Errors writing to the AOF file: %s\",\n                strerror(server.aof_last_write_errno));\n        return C_OK;\n    }\n\n    /* Don't accept write commands if there are not enough good slaves and\n     * user configured the min-slaves-to-write option. */\n    if (server.masterhost == NULL &&\n        server.repl_min_slaves_to_write &&\n        server.repl_min_slaves_max_lag &&\n        is_write_command &&\n        server.repl_good_slaves_count < server.repl_min_slaves_to_write)\n    {\n        rejectCommand(c, shared.noreplicaserr);\n        return C_OK;\n    }\n\n    /* Don't accept write commands if this is a read only slave. But\n     * accept write commands if this is our master. */\n    if (server.masterhost && server.repl_slave_ro &&\n        !(c->flags & CLIENT_MASTER) &&\n        is_write_command)\n    {\n        rejectCommand(c, shared.roslaveerr);\n        return C_OK;\n    }\n\n    /* Only allow a subset of commands in the context of Pub/Sub if the\n     * connection is in RESP2 mode. With RESP3 there are no limits. */\n    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&\n        c->cmd->proc != pingCommand &&\n        c->cmd->proc != subscribeCommand &&\n        c->cmd->proc != unsubscribeCommand &&\n        c->cmd->proc != psubscribeCommand &&\n        c->cmd->proc != punsubscribeCommand) {\n        rejectCommandFormat(c,\n            \"Can't execute '%s': only (P)SUBSCRIBE / \"\n            \"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context\",\n            c->cmd->name);\n        return C_OK;\n    }\n\n    /* Only allow commands with flag \"t\", such as INFO, SLAVEOF and so on,\n     * when slave-serve-stale-data is no and we are a slave with a broken\n     * link with master. */\n    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        is_denystale_command)\n    {\n        rejectCommand(c, shared.masterdownerr);\n        return C_OK;\n    }\n\n    /* Loading DB? Return an error if the command has not the\n     * CMD_LOADING flag. */\n    if (server.loading && is_denyloading_command) {\n        rejectCommand(c, shared.loadingerr);\n        return C_OK;\n    }\n\n    /* Lua script too slow? Only allow a limited number of commands.\n     * Note that we need to allow the transactions commands, otherwise clients\n     * sending a transaction with pipelining without error checking, may have\n     * the MULTI plus a few initial commands refused, then the timeout\n     * condition resolves, and the bottom-half of the transaction gets\n     * executed, see Github PR #7022. */\n    if (server.lua_timedout &&\n          c->cmd->proc != authCommand &&\n          c->cmd->proc != helloCommand &&\n          c->cmd->proc != replconfCommand &&\n          c->cmd->proc != multiCommand &&\n          c->cmd->proc != discardCommand &&\n          c->cmd->proc != watchCommand &&\n          c->cmd->proc != unwatchCommand &&\n        !(c->cmd->proc == shutdownCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&\n        !(c->cmd->proc == scriptCommand &&\n          c->argc == 2 &&\n          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))\n    {\n        rejectCommand(c, shared.slowscripterr);\n        return C_OK;\n    }\n\n    /* Exec the command */\n    if (c->flags & CLIENT_MULTI &&\n        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&\n        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c);\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);\n        c->woff = server.master_repl_offset;\n        if (listLength(server.ready_keys))\n            handleClientsBlockedOnKeys();\n    }\n    return C_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,13 +39,8 @@\n     int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||\n                                  (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));\n \n-    /* Check if the user is authenticated. This check is skipped in case\n-     * the default user is flagged as \"nopass\" and is active. */\n-    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n-                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n-                        !c->authenticated;\n-    if (auth_required) {\n-        /* AUTH and HELLO and no auth modules are valid even in\n+    if (authRequired(c)) {\n+        /* AUTH and HELLO and no auth commands are valid even in\n          * non-authenticated state. */\n         if (!(c->cmd->flags & CMD_NO_AUTH)) {\n             rejectCommand(c,shared.noautherr);",
        "diff_line_info": {
            "deleted_lines": [
                "    /* Check if the user is authenticated. This check is skipped in case",
                "     * the default user is flagged as \"nopass\" and is active. */",
                "    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
                "                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
                "                        !c->authenticated;",
                "    if (auth_required) {",
                "        /* AUTH and HELLO and no auth modules are valid even in"
            ],
            "added_lines": [
                "    if (authRequired(c)) {",
                "        /* AUTH and HELLO and no auth commands are valid even in"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-4868",
        "func_name": "Exiv2/exiv2/Jp2Image::readMetadata",
        "description": "The Exiv2::Jp2Image::readMetadata function in jp2image.cpp in Exiv2 0.26 allows remote attackers to cause a denial of service (excessive memory allocation) via a crafted file.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/fcb42570519f8cf924b0302b09062a60aa565fbe",
        "commit_title": "Add check for DataBuf.size_ in Jp2Image::readMetadata()",
        "commit_text": " When parsing a subBox that is a ColorHeader, a length is extracted from the input file and fed directly into DataBuf() (which calls malloc). A crafted input file can provide arbitrarily (up to max(uint32_t)-8) large values and result in excessive memory allocation.  This commit adds a check for the new size of DataBuf so that it is not larger than the remaining size of the file.  This fixes #202 aka CVE-2018-4868",
        "func_before": "void Jp2Image::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(9, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(14);\n            throw Error(3, \"JPEG-2000\");\n        }\n\n        long              position  = 0;\n        Jp2BoxHeader      box       = {0,0};\n        Jp2BoxHeader      subBox    = {0,0};\n        Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n\n        while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n        {\n            position   = io_->tell();\n            box.length = getLong((byte*)&box.length, bigEndian);\n            box.type   = getLong((byte*)&box.type, bigEndian);\n#ifdef DEBUG\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << position\n                      << \" box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length\n                      << std::endl;\n#endif\n\n            if (box.length == 0) return ;\n\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long restore = io_->tell();\n\n                    while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )\n                    {\n                        subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                        subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n#ifdef DEBUG\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                        if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)\n                        {\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long pad = 3 ; // 3 padding bytes 2 0 0\n                            DataBuf data(Safe::add(subBox.length, static_cast<uint32_t>(8)));\n                            io_->read(data.pData_,data.size_);\n                            const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                            // subtracting pad from data.size_ is safe:\n                            // size_ is at least 8 and pad = 3\n                            if (iccLength > data.size_ - pad) {\n                                throw Error(58);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(icc.pData_,data.pData_+pad,icc.size_);\n#ifdef DEBUG\n                            const char* iccPath = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* f = fopen(iccPath,\"wb\");\n                            if ( f ) {\n                                fwrite(icc.pData_,icc.size_,1,f);\n                                fclose(f);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;\n#endif\n                            setIccProfile(icc);\n                        }\n\n                        if( subBox.type == kJp2BoxTypeImageHeader)\n                        {\n                            io_->read((byte*)&ihdr, sizeof(ihdr));\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);\n                            ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);\n                            ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);\n                            ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);\n\n                            pixelWidth_  = ihdr.imageWidth;\n                            pixelHeight_ = ihdr.imageHeight;\n                        }\n\n                        io_->seek(restore,BasicIo::beg);\n                        io_->seek(subBox.length, Exiv2::BasicIo::cur);\n                        restore = io_->tell();\n                    }\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                    {\n                        DataBuf rawData;\n                        long    bufRead;\n                        bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                        bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                        bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                        if(bIsExif)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n\n                            if (rawData.size_ > 0)\n                            {\n                                // Find the position of Exif header in bytes array.\n                                long pos = (     (rawData.pData_[0]      == rawData.pData_[1])\n                                           &&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                // #1242  Forgive having Exif\\0\\0 in rawData.pData_\n                                const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)\n                                {\n                                    if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)\n                                    {\n                                        pos = i+sizeof(exifHeader);\n#ifndef SUPPRESS_WARNINGS\n                                        EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                // If found it, store only these data at from this place.\n                                if (pos >= 0 )\n                                {\n#ifdef DEBUG\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;\n#endif\n                                    ByteOrder bo = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      rawData.pData_ + pos,\n                                                                      rawData.size_ - pos);\n                                    setByteOrder(bo);\n                                }\n                            }\n                            else\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                exifData_.clear();\n                            }\n                        }\n\n                        if(bIsIPTC)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n\n                            if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                iptcData_.clear();\n                            }\n                        }\n\n                        if(bIsXMP)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n                            xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);\n\n                            std::string::size_type idx = xmpPacket_.find_first_of('<');\n                            if (idx != std::string::npos && idx > 0)\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                xmpPacket_ = xmpPacket_.substr(idx);\n                            }\n\n                            if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            // Move to the next box.\n            io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n            if (io_->error()) throw Error(14);\n        }\n\n    }",
        "func": "void Jp2Image::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(9, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(14);\n            throw Error(3, \"JPEG-2000\");\n        }\n\n        long              position  = 0;\n        Jp2BoxHeader      box       = {0,0};\n        Jp2BoxHeader      subBox    = {0,0};\n        Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n\n        while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n        {\n            position   = io_->tell();\n            box.length = getLong((byte*)&box.length, bigEndian);\n            box.type   = getLong((byte*)&box.type, bigEndian);\n#ifdef DEBUG\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << position\n                      << \" box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length\n                      << std::endl;\n#endif\n\n            if (box.length == 0) return ;\n\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long restore = io_->tell();\n\n                    while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )\n                    {\n                        subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                        subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n#ifdef DEBUG\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                        if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)\n                        {\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long pad = 3 ; // 3 padding bytes 2 0 0\n\t\t\t    const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));\n\t\t\t    // data_length makes no sense if it is larger than the rest of the file\n\t\t\t    if (data_length > io_->size() - io_->tell()) {\n\t\t\t\tthrow Error(58);\n\t\t\t    }\n                            DataBuf data(data_length);\n                            io_->read(data.pData_,data.size_);\n                            const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                            // subtracting pad from data.size_ is safe:\n                            // size_ is at least 8 and pad = 3\n                            if (iccLength > data.size_ - pad) {\n                                throw Error(58);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(icc.pData_,data.pData_+pad,icc.size_);\n#ifdef DEBUG\n                            const char* iccPath = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* f = fopen(iccPath,\"wb\");\n                            if ( f ) {\n                                fwrite(icc.pData_,icc.size_,1,f);\n                                fclose(f);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;\n#endif\n                            setIccProfile(icc);\n                        }\n\n                        if( subBox.type == kJp2BoxTypeImageHeader)\n                        {\n                            io_->read((byte*)&ihdr, sizeof(ihdr));\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);\n                            ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);\n                            ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);\n                            ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);\n\n                            pixelWidth_  = ihdr.imageWidth;\n                            pixelHeight_ = ihdr.imageHeight;\n                        }\n\n                        io_->seek(restore,BasicIo::beg);\n                        io_->seek(subBox.length, Exiv2::BasicIo::cur);\n                        restore = io_->tell();\n                    }\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                    {\n                        DataBuf rawData;\n                        long    bufRead;\n                        bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                        bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                        bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                        if(bIsExif)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n\n                            if (rawData.size_ > 0)\n                            {\n                                // Find the position of Exif header in bytes array.\n                                long pos = (     (rawData.pData_[0]      == rawData.pData_[1])\n                                           &&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                // #1242  Forgive having Exif\\0\\0 in rawData.pData_\n                                const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)\n                                {\n                                    if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)\n                                    {\n                                        pos = i+sizeof(exifHeader);\n#ifndef SUPPRESS_WARNINGS\n                                        EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                // If found it, store only these data at from this place.\n                                if (pos >= 0 )\n                                {\n#ifdef DEBUG\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;\n#endif\n                                    ByteOrder bo = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      rawData.pData_ + pos,\n                                                                      rawData.size_ - pos);\n                                    setByteOrder(bo);\n                                }\n                            }\n                            else\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                exifData_.clear();\n                            }\n                        }\n\n                        if(bIsIPTC)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n\n                            if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                iptcData_.clear();\n                            }\n                        }\n\n                        if(bIsXMP)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(14);\n                            if (bufRead != rawData.size_) throw Error(20);\n                            xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);\n\n                            std::string::size_type idx = xmpPacket_.find_first_of('<');\n                            if (idx != std::string::npos && idx > 0)\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                xmpPacket_ = xmpPacket_.substr(idx);\n                            }\n\n                            if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            // Move to the next box.\n            io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n            if (io_->error()) throw Error(14);\n        }\n\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,12 @@\n #endif\n \n                             const long pad = 3 ; // 3 padding bytes 2 0 0\n-                            DataBuf data(Safe::add(subBox.length, static_cast<uint32_t>(8)));\n+\t\t\t    const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));\n+\t\t\t    // data_length makes no sense if it is larger than the rest of the file\n+\t\t\t    if (data_length > io_->size() - io_->tell()) {\n+\t\t\t\tthrow Error(58);\n+\t\t\t    }\n+                            DataBuf data(data_length);\n                             io_->read(data.pData_,data.size_);\n                             const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                             // subtracting pad from data.size_ is safe:",
        "diff_line_info": {
            "deleted_lines": [
                "                            DataBuf data(Safe::add(subBox.length, static_cast<uint32_t>(8)));"
            ],
            "added_lines": [
                "\t\t\t    const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));",
                "\t\t\t    // data_length makes no sense if it is larger than the rest of the file",
                "\t\t\t    if (data_length > io_->size() - io_->tell()) {",
                "\t\t\t\tthrow Error(58);",
                "\t\t\t    }",
                "                            DataBuf data(data_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18028",
        "func_name": "ImageMagick/TIFFWritePhotoshopLayers",
        "description": "In ImageMagick 7.0.7-1 Q16, a memory exhaustion vulnerability was found in the function ReadTIFFImage in coders/tiff.c, which allow remote attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/32a3eeb9e0da083cbc05909e4935efdbf9846df9",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/736",
        "commit_text": "",
        "func_before": "static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n  const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BlobInfo\n    *blob;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *next;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  PhotoshopProfile\n    profile;\n\n  PSDInfo\n    info;\n\n  size_t\n    length;\n\n  StringInfo\n    *layers;\n\n  next=image->next;\n  if (next == (Image *) NULL)\n    return(MagickTrue);\n  clone_info=CloneImageInfo(image_info);\n  if (clone_info == (ImageInfo *) NULL)\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n  profile.offset=0;\n  profile.quantum=MagickMinBlobExtent;\n  layers=AcquireStringInfo(profile.quantum);\n  if (layers == (StringInfo *) NULL)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  profile.data=layers;\n  profile.extent=layers->length;\n  custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  blob=CloneBlobInfo((BlobInfo *) NULL);\n  if (blob == (BlobInfo *) NULL)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  DestroyBlob(next);\n  next->blob=blob;\n  while (next != (Image *) NULL)\n    next=SyncNextImageInList(next);\n  next=image->next;\n  AttachCustomStream(next->blob,custom_stream);\n  InitPSDInfo(image,&info);\n  if (next->endian == UndefinedEndian)\n    next->endian=(HOST_FILLORDER == FILLORDER_LSB2MSB) ? LSBEndian : MSBEndian;\n  WriteBlobString(next,\"Adobe Photoshop Document Data Block\");\n  WriteBlobByte(next,0);\n  WriteBlobString(next,next->endian == LSBEndian ? \"MIB8ryaL\" : \"8BIMLayr\");\n  status=WritePSDLayers(next,clone_info,&info,exception);\n  if (status != MagickFalse)\n    {\n      SetStringInfoLength(layers,(size_t) profile.offset);\n      status=SetImageProfile(image,\"tiff:37724\",layers,exception);\n    }\n  while (next != (Image *) NULL)\n  {\n    CloseBlob(next);\n    next=next->next;\n  }\n  layers=DestroyStringInfo(layers);\n  clone_info=DestroyImageInfo(clone_info);\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n  return(status);\n}",
        "func": "static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n  const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BlobInfo\n    *blob;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *next;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  PhotoshopProfile\n    profile;\n\n  PSDInfo\n    info;\n\n  StringInfo\n    *layers;\n\n  next=image->next;\n  if (next == (Image *) NULL)\n    return(MagickTrue);\n  clone_info=CloneImageInfo(image_info);\n  if (clone_info == (ImageInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  profile.offset=0;\n  profile.quantum=MagickMinBlobExtent;\n  layers=AcquireStringInfo(profile.quantum);\n  if (layers == (StringInfo *) NULL)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  profile.data=layers;\n  profile.extent=layers->length;\n  custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  blob=CloneBlobInfo((BlobInfo *) NULL);\n  if (blob == (BlobInfo *) NULL)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  DestroyBlob(next);\n  next->blob=blob;\n  while (next != (Image *) NULL)\n    next=SyncNextImageInList(next);\n  next=image->next;\n  AttachCustomStream(next->blob,custom_stream);\n  InitPSDInfo(image,&info);\n  if (next->endian == UndefinedEndian)\n    next->endian=(HOST_FILLORDER == FILLORDER_LSB2MSB) ? LSBEndian : MSBEndian;\n  WriteBlobString(next,\"Adobe Photoshop Document Data Block\");\n  WriteBlobByte(next,0);\n  WriteBlobString(next,next->endian == LSBEndian ? \"MIB8ryaL\" : \"8BIMLayr\");\n  status=WritePSDLayers(next,clone_info,&info,exception);\n  if (status != MagickFalse)\n    {\n      SetStringInfoLength(layers,(size_t) profile.offset);\n      status=SetImageProfile(image,\"tiff:37724\",layers,exception);\n    }\n  while (next != (Image *) NULL)\n  {\n    CloseBlob(next);\n    next=next->next;\n  }\n  layers=DestroyStringInfo(layers);\n  clone_info=DestroyImageInfo(clone_info);\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,9 +22,6 @@\n   PSDInfo\n     info;\n \n-  size_t\n-    length;\n-\n   StringInfo\n     *layers;\n \n@@ -33,8 +30,8 @@\n     return(MagickTrue);\n   clone_info=CloneImageInfo(image_info);\n   if (clone_info == (ImageInfo *) NULL)\n-      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n-        image->filename);\n+    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n+      image->filename);\n   profile.offset=0;\n   profile.quantum=MagickMinBlobExtent;\n   layers=AcquireStringInfo(profile.quantum);",
        "diff_line_info": {
            "deleted_lines": [
                "  size_t",
                "    length;",
                "",
                "      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",",
                "        image->filename);"
            ],
            "added_lines": [
                "    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",",
                "      image->filename);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13189",
        "func_name": "android/ih264d_create",
        "description": "A vulnerability in the Android media framework (libavc) related to handling dec_hdl memory allocation failures. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-68300072.",
        "git_url": "https://android.googlesource.com/platform/external/libavc/+/5acaa6fc86c73a750e5f4900c4e2d44bf22f683a",
        "commit_title": "Decoder: Handle dec_hdl memory allocation failure gracefully",
        "commit_text": " If memory allocation for dec_hdl fails, return gracefully with an error code. All other allocation failures are handled correctly.  Bug: 68300072 Test: ran poc before/after (cherry picked from commit 7720b3fe3de04523da3a9ecec2b42a3748529bbd) ",
        "func_before": "WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n    ih264d_create_op_t *ps_create_op;\n\n    WORD32 ret;\n\n    ps_create_op = (ih264d_create_op_t *)pv_api_op;\n\n    ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n\n    ret = ih264d_allocate_static_bufs(&dec_hdl, pv_api_ip, pv_api_op);\n\n    /* If allocation of some buffer fails, then free buffers allocated till then */\n    if((IV_FAIL == ret) && (NULL != dec_hdl))\n    {\n        ih264d_free_static_bufs(dec_hdl);\n        ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n        ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n\n        return IV_FAIL;\n    }\n\n    return IV_SUCCESS;\n}",
        "func": "WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n    ih264d_create_ip_t *ps_create_ip;\n    ih264d_create_op_t *ps_create_op;\n\n    WORD32 ret;\n\n    ps_create_ip = (ih264d_create_ip_t *)pv_api_ip;\n    ps_create_op = (ih264d_create_op_t *)pv_api_op;\n\n    ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n    dec_hdl = NULL;\n    ret = ih264d_allocate_static_bufs(&dec_hdl, pv_api_ip, pv_api_op);\n\n    /* If allocation of some buffer fails, then free buffers allocated till then */\n    if(IV_FAIL == ret)\n    {\n        if(dec_hdl)\n        {\n            if(dec_hdl->pv_codec_handle)\n            {\n                ih264d_free_static_bufs(dec_hdl);\n            }\n            else\n            {\n                void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);\n                void *pv_mem_ctxt;\n\n                pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;\n                pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;\n                pf_aligned_free(pv_mem_ctxt, dec_hdl);\n            }\n        }\n        ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n        ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n\n        return IV_FAIL;\n    }\n\n    return IV_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,19 +1,36 @@\n WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n {\n+    ih264d_create_ip_t *ps_create_ip;\n     ih264d_create_op_t *ps_create_op;\n \n     WORD32 ret;\n \n+    ps_create_ip = (ih264d_create_ip_t *)pv_api_ip;\n     ps_create_op = (ih264d_create_op_t *)pv_api_op;\n \n     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n-\n+    dec_hdl = NULL;\n     ret = ih264d_allocate_static_bufs(&dec_hdl, pv_api_ip, pv_api_op);\n \n     /* If allocation of some buffer fails, then free buffers allocated till then */\n-    if((IV_FAIL == ret) && (NULL != dec_hdl))\n+    if(IV_FAIL == ret)\n     {\n-        ih264d_free_static_bufs(dec_hdl);\n+        if(dec_hdl)\n+        {\n+            if(dec_hdl->pv_codec_handle)\n+            {\n+                ih264d_free_static_bufs(dec_hdl);\n+            }\n+            else\n+            {\n+                void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);\n+                void *pv_mem_ctxt;\n+\n+                pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;\n+                pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;\n+                pf_aligned_free(pv_mem_ctxt, dec_hdl);\n+            }\n+        }\n         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "    if((IV_FAIL == ret) && (NULL != dec_hdl))",
                "        ih264d_free_static_bufs(dec_hdl);"
            ],
            "added_lines": [
                "    ih264d_create_ip_t *ps_create_ip;",
                "    ps_create_ip = (ih264d_create_ip_t *)pv_api_ip;",
                "    dec_hdl = NULL;",
                "    if(IV_FAIL == ret)",
                "        if(dec_hdl)",
                "        {",
                "            if(dec_hdl->pv_codec_handle)",
                "            {",
                "                ih264d_free_static_bufs(dec_hdl);",
                "            }",
                "            else",
                "            {",
                "                void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);",
                "                void *pv_mem_ctxt;",
                "",
                "                pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;",
                "                pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;",
                "                pf_aligned_free(pv_mem_ctxt, dec_hdl);",
                "            }",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13190",
        "func_name": "android/ihevcd_create",
        "description": "A vulnerability in the Android media framework (libhevc) related to handling ps_codec_obj memory allocation failures. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-68299873.",
        "git_url": "https://android.googlesource.com/platform/external/libhevc/+/3ed3c6b79a7b9a60c475dd4936ad57b0b92fd600",
        "commit_title": "Decoder: Handle ps_codec_obj memory allocation failure gracefully",
        "commit_text": " If memory allocation for ps_codec_obj fails, return gracefully with an error code. All other allocation failures are handled correctly.  Bug: 68299873 Test: before/after with always-failing malloc (cherry picked from commit a966e2a65dd901151ce7f4481d0084840c9a0f7e) ",
        "func_before": "WORD32 ihevcd_create(iv_obj_t *ps_codec_obj,\n                           void *pv_api_ip,\n                           void *pv_api_op)\n{\n\n    ihevcd_cxa_create_op_t *ps_create_op;\n\n    WORD32 ret;\n    codec_t *ps_codec;\n    ps_create_op = (ihevcd_cxa_create_op_t *)pv_api_op;\n\n    ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n\n    ret = ihevcd_allocate_static_bufs(&ps_codec_obj, pv_api_ip, pv_api_op);\n\n    /* If allocation of some buffer fails, then free buffers allocated till then */\n    if((IV_FAIL == ret) && (NULL != ps_codec_obj))\n    {\n        ihevcd_free_static_bufs(ps_codec_obj);\n        ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n        ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n\n        return IV_FAIL;\n    }\n    ps_codec = (codec_t *)ps_codec_obj->pv_codec_handle;\n    ret = ihevcd_init(ps_codec);\n\n    TRACE_INIT(NULL);\n    STATS_INIT();\n\n    return ret;\n}",
        "func": "WORD32 ihevcd_create(iv_obj_t *ps_codec_obj,\n                           void *pv_api_ip,\n                           void *pv_api_op)\n{\n    ihevcd_cxa_create_ip_t *ps_create_ip;\n    ihevcd_cxa_create_op_t *ps_create_op;\n\n    WORD32 ret;\n    codec_t *ps_codec;\n    ps_create_ip = (ihevcd_cxa_create_ip_t *)pv_api_ip;\n    ps_create_op = (ihevcd_cxa_create_op_t *)pv_api_op;\n\n    ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n    ps_codec_obj = NULL;\n    ret = ihevcd_allocate_static_bufs(&ps_codec_obj, pv_api_ip, pv_api_op);\n\n    /* If allocation of some buffer fails, then free buffers allocated till then */\n    if(IV_FAIL == ret)\n    {\n        if(NULL != ps_codec_obj)\n        {\n            if(ps_codec_obj->pv_codec_handle)\n            {\n                ihevcd_free_static_bufs(ps_codec_obj);\n            }\n            else\n            {\n                void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);\n                void *pv_mem_ctxt;\n\n                pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;\n                pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;\n                pf_aligned_free(pv_mem_ctxt, ps_codec_obj);\n            }\n        }\n        ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n        ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n\n        return IV_FAIL;\n    }\n    ps_codec = (codec_t *)ps_codec_obj->pv_codec_handle;\n    ret = ihevcd_init(ps_codec);\n\n    TRACE_INIT(NULL);\n    STATS_INIT();\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,21 +2,37 @@\n                            void *pv_api_ip,\n                            void *pv_api_op)\n {\n-\n+    ihevcd_cxa_create_ip_t *ps_create_ip;\n     ihevcd_cxa_create_op_t *ps_create_op;\n \n     WORD32 ret;\n     codec_t *ps_codec;\n+    ps_create_ip = (ihevcd_cxa_create_ip_t *)pv_api_ip;\n     ps_create_op = (ihevcd_cxa_create_op_t *)pv_api_op;\n \n     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n-\n+    ps_codec_obj = NULL;\n     ret = ihevcd_allocate_static_bufs(&ps_codec_obj, pv_api_ip, pv_api_op);\n \n     /* If allocation of some buffer fails, then free buffers allocated till then */\n-    if((IV_FAIL == ret) && (NULL != ps_codec_obj))\n+    if(IV_FAIL == ret)\n     {\n-        ihevcd_free_static_bufs(ps_codec_obj);\n+        if(NULL != ps_codec_obj)\n+        {\n+            if(ps_codec_obj->pv_codec_handle)\n+            {\n+                ihevcd_free_static_bufs(ps_codec_obj);\n+            }\n+            else\n+            {\n+                void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);\n+                void *pv_mem_ctxt;\n+\n+                pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;\n+                pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;\n+                pf_aligned_free(pv_mem_ctxt, ps_codec_obj);\n+            }\n+        }\n         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "",
                "    if((IV_FAIL == ret) && (NULL != ps_codec_obj))",
                "        ihevcd_free_static_bufs(ps_codec_obj);"
            ],
            "added_lines": [
                "    ihevcd_cxa_create_ip_t *ps_create_ip;",
                "    ps_create_ip = (ihevcd_cxa_create_ip_t *)pv_api_ip;",
                "    ps_codec_obj = NULL;",
                "    if(IV_FAIL == ret)",
                "        if(NULL != ps_codec_obj)",
                "        {",
                "            if(ps_codec_obj->pv_codec_handle)",
                "            {",
                "                ihevcd_free_static_bufs(ps_codec_obj);",
                "            }",
                "            else",
                "            {",
                "                void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);",
                "                void *pv_mem_ctxt;",
                "",
                "                pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;",
                "                pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;",
                "                pf_aligned_free(pv_mem_ctxt, ps_codec_obj);",
                "            }",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25193",
        "func_name": "harfbuzz/prev",
        "description": "hb-ot-layout-gsubgpos.hh in HarfBuzz through 6.0.0 allows attackers to trigger O(n^2) growth via consecutive marks during the process of looking back for base glyphs when attaching marks.",
        "git_url": "https://github.com/harfbuzz/harfbuzz/commit/85be877925ddbf34f74a1229f3ca1716bb6170dc",
        "commit_title": "[layout] Limit how far we skip when looking back",
        "commit_text": " See comments.",
        "func_before": "bool prev (unsigned *unsafe_from = nullptr)\n    {\n      assert (num_items > 0);\n      /* The alternate condition below is faster at string boundaries,\n       * but produces subpar \"unsafe-to-concat\" values. */\n      unsigned stop = num_items - 1;\n      if (c->buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT)\n        stop = 1 - 1;\n      while (idx > stop)\n      {\n\tidx--;\n\thb_glyph_info_t &info = c->buffer->out_info[idx];\n\n\tmatcher_t::may_skip_t skip = matcher.may_skip (c, info);\n\tif (unlikely (skip == matcher_t::SKIP_YES))\n\t  continue;\n\n\tmatcher_t::may_match_t match = matcher.may_match (info, get_glyph_data ());\n\tif (match == matcher_t::MATCH_YES ||\n\t    (match == matcher_t::MATCH_MAYBE &&\n\t     skip == matcher_t::SKIP_NO))\n\t{\n\t  num_items--;\n\t  advance_glyph_data ();\n\t  return true;\n\t}\n\n\tif (skip == matcher_t::SKIP_NO)\n\t{\n\t  if (unsafe_from)\n\t    *unsafe_from = hb_max (1u, idx) - 1u;\n\t  return false;\n\t}\n      }\n      if (unsafe_from)\n        *unsafe_from = 0;\n      return false;\n    }",
        "func": "bool prev (unsigned *unsafe_from = nullptr)\n    {\n      assert (num_items > 0);\n      /* The alternate condition below is faster at string boundaries,\n       * but produces subpar \"unsafe-to-concat\" values. */\n      unsigned stop = num_items - 1;\n      if (c->buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT)\n        stop = 1 - 1;\n\n      /* When looking back, limit how far we search; this function is mostly\n       * used for looking back for base glyphs when attaching marks. If we\n       * don't limit, we can get O(n^2) behavior where n is the number of\n       * consecutive marks. */\n      stop = (unsigned) hb_max ((int) stop, (int) idx - HB_MAX_CONTEXT_LENGTH);\n\n      while (idx > stop)\n      {\n\tidx--;\n\thb_glyph_info_t &info = c->buffer->out_info[idx];\n\n\tmatcher_t::may_skip_t skip = matcher.may_skip (c, info);\n\tif (unlikely (skip == matcher_t::SKIP_YES))\n\t  continue;\n\n\tmatcher_t::may_match_t match = matcher.may_match (info, get_glyph_data ());\n\tif (match == matcher_t::MATCH_YES ||\n\t    (match == matcher_t::MATCH_MAYBE &&\n\t     skip == matcher_t::SKIP_NO))\n\t{\n\t  num_items--;\n\t  advance_glyph_data ();\n\t  return true;\n\t}\n\n\tif (skip == matcher_t::SKIP_NO)\n\t{\n\t  if (unsafe_from)\n\t    *unsafe_from = hb_max (1u, idx) - 1u;\n\t  return false;\n\t}\n      }\n      if (unsafe_from)\n        *unsafe_from = 0;\n      return false;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,13 @@\n       unsigned stop = num_items - 1;\n       if (c->buffer->flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT)\n         stop = 1 - 1;\n+\n+      /* When looking back, limit how far we search; this function is mostly\n+       * used for looking back for base glyphs when attaching marks. If we\n+       * don't limit, we can get O(n^2) behavior where n is the number of\n+       * consecutive marks. */\n+      stop = (unsigned) hb_max ((int) stop, (int) idx - HB_MAX_CONTEXT_LENGTH);\n+\n       while (idx > stop)\n       {\n \tidx--;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "      /* When looking back, limit how far we search; this function is mostly",
                "       * used for looking back for base glyphs when attaching marks. If we",
                "       * don't limit, we can get O(n^2) behavior where n is the number of",
                "       * consecutive marks. */",
                "      stop = (unsigned) hb_max ((int) stop, (int) idx - HB_MAX_CONTEXT_LENGTH);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8576",
        "func_name": "qemu/xhci_ring_chain_length",
        "description": "The xhci_ring_fetch function in hw/usb/hcd-xhci.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) by leveraging failure to limit the number of link Transfer Request Blocks (TRB) to process.",
        "git_url": "https://github.com/qemu/qemu/commit/05f43d44e4bc26611ce25fd7d726e483f73363ce",
        "commit_title": "xhci: limit the number of link trbs we are willing to process",
        "commit_text": " Needed to avoid we run in circles forever in case the guest builds an endless loop with link trbs. ",
        "func_before": "static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    XHCITRB trb;\n    int length = 0;\n    dma_addr_t dequeue = ring->dequeue;\n    bool ccs = ring->ccs;\n    /* hack to bundle together the two/three TDs that make a setup transfer */\n    bool control_td_set = 0;\n\n    while (1) {\n        TRBType type;\n        pci_dma_read(pci_dev, dequeue, &trb, TRB_SIZE);\n        le64_to_cpus(&trb.parameter);\n        le32_to_cpus(&trb.status);\n        le32_to_cpus(&trb.control);\n\n        if ((trb.control & TRB_C) != ccs) {\n            return -length;\n        }\n\n        type = TRB_TYPE(trb);\n\n        if (type == TR_LINK) {\n            dequeue = xhci_mask64(trb.parameter);\n            if (trb.control & TRB_LK_TC) {\n                ccs = !ccs;\n            }\n            continue;\n        }\n\n        length += 1;\n        dequeue += TRB_SIZE;\n\n        if (type == TR_SETUP) {\n            control_td_set = 1;\n        } else if (type == TR_STATUS) {\n            control_td_set = 0;\n        }\n\n        if (!control_td_set && !(trb.control & TRB_TR_CH)) {\n            return length;\n        }\n    }\n}",
        "func": "static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    XHCITRB trb;\n    int length = 0;\n    dma_addr_t dequeue = ring->dequeue;\n    bool ccs = ring->ccs;\n    /* hack to bundle together the two/three TDs that make a setup transfer */\n    bool control_td_set = 0;\n    uint32_t link_cnt = 0;\n\n    while (1) {\n        TRBType type;\n        pci_dma_read(pci_dev, dequeue, &trb, TRB_SIZE);\n        le64_to_cpus(&trb.parameter);\n        le32_to_cpus(&trb.status);\n        le32_to_cpus(&trb.control);\n\n        if ((trb.control & TRB_C) != ccs) {\n            return -length;\n        }\n\n        type = TRB_TYPE(trb);\n\n        if (type == TR_LINK) {\n            if (++link_cnt > TRB_LINK_LIMIT) {\n                return -length;\n            }\n            dequeue = xhci_mask64(trb.parameter);\n            if (trb.control & TRB_LK_TC) {\n                ccs = !ccs;\n            }\n            continue;\n        }\n\n        length += 1;\n        dequeue += TRB_SIZE;\n\n        if (type == TR_SETUP) {\n            control_td_set = 1;\n        } else if (type == TR_STATUS) {\n            control_td_set = 0;\n        }\n\n        if (!control_td_set && !(trb.control & TRB_TR_CH)) {\n            return length;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n     bool ccs = ring->ccs;\n     /* hack to bundle together the two/three TDs that make a setup transfer */\n     bool control_td_set = 0;\n+    uint32_t link_cnt = 0;\n \n     while (1) {\n         TRBType type;\n@@ -22,6 +23,9 @@\n         type = TRB_TYPE(trb);\n \n         if (type == TR_LINK) {\n+            if (++link_cnt > TRB_LINK_LIMIT) {\n+                return -length;\n+            }\n             dequeue = xhci_mask64(trb.parameter);\n             if (trb.control & TRB_LK_TC) {\n                 ccs = !ccs;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    uint32_t link_cnt = 0;",
                "            if (++link_cnt > TRB_LINK_LIMIT) {",
                "                return -length;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8576",
        "func_name": "qemu/xhci_ring_fetch",
        "description": "The xhci_ring_fetch function in hw/usb/hcd-xhci.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) by leveraging failure to limit the number of link Transfer Request Blocks (TRB) to process.",
        "git_url": "https://github.com/qemu/qemu/commit/05f43d44e4bc26611ce25fd7d726e483f73363ce",
        "commit_title": "xhci: limit the number of link trbs we are willing to process",
        "commit_text": " Needed to avoid we run in circles forever in case the guest builds an endless loop with link trbs. ",
        "func_before": "static TRBType xhci_ring_fetch(XHCIState *xhci, XHCIRing *ring, XHCITRB *trb,\n                               dma_addr_t *addr)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n\n    while (1) {\n        TRBType type;\n        pci_dma_read(pci_dev, ring->dequeue, trb, TRB_SIZE);\n        trb->addr = ring->dequeue;\n        trb->ccs = ring->ccs;\n        le64_to_cpus(&trb->parameter);\n        le32_to_cpus(&trb->status);\n        le32_to_cpus(&trb->control);\n\n        trace_usb_xhci_fetch_trb(ring->dequeue, trb_name(trb),\n                                 trb->parameter, trb->status, trb->control);\n\n        if ((trb->control & TRB_C) != ring->ccs) {\n            return 0;\n        }\n\n        type = TRB_TYPE(*trb);\n\n        if (type != TR_LINK) {\n            if (addr) {\n                *addr = ring->dequeue;\n            }\n            ring->dequeue += TRB_SIZE;\n            return type;\n        } else {\n            ring->dequeue = xhci_mask64(trb->parameter);\n            if (trb->control & TRB_LK_TC) {\n                ring->ccs = !ring->ccs;\n            }\n        }\n    }\n}",
        "func": "static TRBType xhci_ring_fetch(XHCIState *xhci, XHCIRing *ring, XHCITRB *trb,\n                               dma_addr_t *addr)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    uint32_t link_cnt = 0;\n\n    while (1) {\n        TRBType type;\n        pci_dma_read(pci_dev, ring->dequeue, trb, TRB_SIZE);\n        trb->addr = ring->dequeue;\n        trb->ccs = ring->ccs;\n        le64_to_cpus(&trb->parameter);\n        le32_to_cpus(&trb->status);\n        le32_to_cpus(&trb->control);\n\n        trace_usb_xhci_fetch_trb(ring->dequeue, trb_name(trb),\n                                 trb->parameter, trb->status, trb->control);\n\n        if ((trb->control & TRB_C) != ring->ccs) {\n            return 0;\n        }\n\n        type = TRB_TYPE(*trb);\n\n        if (type != TR_LINK) {\n            if (addr) {\n                *addr = ring->dequeue;\n            }\n            ring->dequeue += TRB_SIZE;\n            return type;\n        } else {\n            if (++link_cnt > TRB_LINK_LIMIT) {\n                return 0;\n            }\n            ring->dequeue = xhci_mask64(trb->parameter);\n            if (trb->control & TRB_LK_TC) {\n                ring->ccs = !ring->ccs;\n            }\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n                                dma_addr_t *addr)\n {\n     PCIDevice *pci_dev = PCI_DEVICE(xhci);\n+    uint32_t link_cnt = 0;\n \n     while (1) {\n         TRBType type;\n@@ -28,6 +29,9 @@\n             ring->dequeue += TRB_SIZE;\n             return type;\n         } else {\n+            if (++link_cnt > TRB_LINK_LIMIT) {\n+                return 0;\n+            }\n             ring->dequeue = xhci_mask64(trb->parameter);\n             if (trb->control & TRB_LK_TC) {\n                 ring->ccs = !ring->ccs;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    uint32_t link_cnt = 0;",
                "            if (++link_cnt > TRB_LINK_LIMIT) {",
                "                return 0;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-5850",
        "func_name": "openbsd/src/server_partial_file_request",
        "description": "httpd in OpenBSD allows remote attackers to cause a denial of service (memory consumption) via a series of requests for a large file using an HTTP Range header.",
        "git_url": "https://github.com/openbsd/src/commit/142cfc82b932bc211218fbd7bdda8c7ce83f19df",
        "commit_title": "Reimplement httpd's support for byte ranges.",
        "commit_text": " The previous implementation loaded all the output into a single output buffer and used its size to determine the Content-Length of the body.  The new implementation calculates the body length first and writes the individual ranges in an async way using the bufferevent mechanism.  This prevents httpd from using too much memory and applies the watermark and throttling mechanisms to range requests.  Problem reported by Pierre Kim (pierre.kim.sec at gmail.com)  OK benno@ sunil@",
        "func_before": "int\nserver_partial_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st, char *range_str)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range\t\t*range;\n\tstruct evbuffer\t\t*evb = NULL;\n\tsize_t\t\t\t content_length;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tuint32_t\t\t boundary;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t/* Ignore range request for methods other than GET */\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes */%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t}\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tif ((evb = evbuffer_new()) == NULL) {\n\t\terrstr = \"failed to allocate file buffer\";\n\t\tgoto abort;\n\t}\n\n\tif (nranges == 1) {\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\tcontent_length = range->end - range->start + 1;\n\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\tgoto abort;\n\n\t} else {\n\t\tcontent_length = 0;\n\t\tboundary = arc4random();\n\t\t/* Generate a multipart payload of byteranges */\n\t\twhile (nranges--) {\n\t\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",\n\t\t\t    boundary)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Type: %s/%s\\r\\n\",\n\t\t\t    media->media_type, media->media_subtype)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n\t\t\t    range->start, range->end, st->st_size)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += range->end - range->start + 1;\n\t\t\trange++;\n\t\t}\n\n\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",\n\t\t    boundary)) == -1)\n\t\t\tgoto abort;\n\n\t\tcontent_length += i;\n\n\t\t/* prepare multipart/byteranges media type */\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%ud\", boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\tclose(fd);\n\tfd = -1;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (server_bufferevent_write_buffer(clt, evb) == -1)\n\t\tgoto fail;\n\n\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\tif (clt->clt_persist)\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\telse\n\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n\tclt->clt_done = 0;\n\n done:\n\tevbuffer_free(evb);\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (evb != NULL)\n\t\tevbuffer_free(evb);\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}",
        "func": "int\nserver_partial_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st, char *range_str)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\tstruct range\t\t*range;\n\tsize_t\t\t\t content_length = 0;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t/* Ignore range request for methods other than GET */\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes */%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t}\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tr->range_media = media;\n\n\tif (nranges == 1) {\n\t\trange = &r->range[0];\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\trange = &r->range[0];\n\t\tcontent_length += range->end - range->start + 1;\n\t} else {\n\t\t/* Add boundary, all parts will be handled by the callback */\n\t\tarc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));\n\n\t\t/* Calculate Content-Length of the complete multipart body */\n\t\tfor (i = 0; i < nranges; i++) {\n\t\t\trange = &r->range[i];\n\n\t\t\t/* calculate Content-Length of the complete body */\n\t\t\tif ((ret = snprintf(NULL, 0,\n\t\t\t    \"\\r\\n--%llu\\r\\n\"\n\t\t\t    \"Content-Type: %s/%s\\r\\n\"\n\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n\t\t\t    clt->clt_boundary,\n\t\t\t    media->media_type, media->media_subtype,\n\t\t\t    range->start, range->end, st->st_size)) < 0)\n\t\t\t\tgoto abort;\n\n\t\t\t/* Add data length */\n\t\t\tcontent_length += ret + range->end - range->start + 1;\n\n\t\t}\n\t\tif ((ret = snprintf(NULL, 0, \"\\r\\n--%llu--\\r\\n\",\n\t\t    clt->clt_boundary)) < 0)\n\t\t\tgoto abort;\n\t\tcontent_length += ret;\n\n\t\t/* prepare multipart/byteranges media type */\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%llu\", clt->clt_boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\t/* Start with first range */\n\tr->range_toread = TOREAD_HTTP_RANGE;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tclose(fd);\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclt->clt_fd = fd;\n\tif (clt->clt_srvbev != NULL)\n\t\tbufferevent_free(clt->clt_srvbev);\n\n\tclt->clt_srvbev_throttled = 0;\n\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,\n\t    server_write, server_file_error, clt);\n\tif (clt->clt_srvbev == NULL) {\n\t\terrstr = \"failed to allocate file buffer event\";\n\t\tgoto fail;\n\t}\n\n\t/* Adjust read watermark to the socket output buffer size */\n\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,\n\t    clt->clt_sndbufsiz);\n\n\tbufferevent_settimeout(clt->clt_srvbev,\n\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);\n\tbufferevent_enable(clt->clt_srvbev, EV_READ);\n\tbufferevent_disable(clt->clt_bev, EV_READ);\n\n done:\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,11 +6,10 @@\n \tstruct http_descriptor\t*resp = clt->clt_descresp;\n \tstruct http_descriptor\t*desc = clt->clt_descreq;\n \tstruct media_type\t*media, multipart_media;\n+\tstruct range_data\t*r = &clt->clt_ranges;\n \tstruct range\t\t*range;\n-\tstruct evbuffer\t\t*evb = NULL;\n-\tsize_t\t\t\t content_length;\n+\tsize_t\t\t\t content_length = 0;\n \tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n-\tuint32_t\t\t boundary;\n \tchar\t\t\t content_range[64];\n \tconst char\t\t*errstr = NULL;\n \n@@ -18,7 +17,7 @@\n \tif (desc->http_method != HTTP_METHOD_GET)\n \t\treturn server_file_request(env, clt, path, st);\n \n-\tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {\n+\tif ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {\n \t\tcode = 416;\n \t\t(void)snprintf(content_range, sizeof(content_range),\n \t\t    \"bytes */%lld\", st->st_size);\n@@ -31,12 +30,10 @@\n \t\tgoto abort;\n \n \tmedia = media_find_config(env, srv_conf, path);\n-\tif ((evb = evbuffer_new()) == NULL) {\n-\t\terrstr = \"failed to allocate file buffer\";\n-\t\tgoto abort;\n-\t}\n+\tr->range_media = media;\n \n \tif (nranges == 1) {\n+\t\trange = &r->range[0];\n \t\t(void)snprintf(content_range, sizeof(content_range),\n \t\t    \"bytes %lld-%lld/%lld\", range->start, range->end,\n \t\t    st->st_size);\n@@ -44,56 +41,46 @@\n \t\t    content_range) == NULL)\n \t\t\tgoto abort;\n \n-\t\tcontent_length = range->end - range->start + 1;\n-\t\tif (buffer_add_range(fd, evb, range) == 0)\n-\t\t\tgoto abort;\n+\t\trange = &r->range[0];\n+\t\tcontent_length += range->end - range->start + 1;\n+\t} else {\n+\t\t/* Add boundary, all parts will be handled by the callback */\n+\t\tarc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));\n \n-\t} else {\n-\t\tcontent_length = 0;\n-\t\tboundary = arc4random();\n-\t\t/* Generate a multipart payload of byteranges */\n-\t\twhile (nranges--) {\n-\t\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",\n-\t\t\t    boundary)) == -1)\n+\t\t/* Calculate Content-Length of the complete multipart body */\n+\t\tfor (i = 0; i < nranges; i++) {\n+\t\t\trange = &r->range[i];\n+\n+\t\t\t/* calculate Content-Length of the complete body */\n+\t\t\tif ((ret = snprintf(NULL, 0,\n+\t\t\t    \"\\r\\n--%llu\\r\\n\"\n+\t\t\t    \"Content-Type: %s/%s\\r\\n\"\n+\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n+\t\t\t    clt->clt_boundary,\n+\t\t\t    media->media_type, media->media_subtype,\n+\t\t\t    range->start, range->end, st->st_size)) < 0)\n \t\t\t\tgoto abort;\n \n-\t\t\tcontent_length += i;\n-\t\t\tif ((i = evbuffer_add_printf(evb,\n-\t\t\t    \"Content-Type: %s/%s\\r\\n\",\n-\t\t\t    media->media_type, media->media_subtype)) == -1)\n-\t\t\t\tgoto abort;\n+\t\t\t/* Add data length */\n+\t\t\tcontent_length += ret + range->end - range->start + 1;\n \n-\t\t\tcontent_length += i;\n-\t\t\tif ((i = evbuffer_add_printf(evb,\n-\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n-\t\t\t    range->start, range->end, st->st_size)) == -1)\n-\t\t\t\tgoto abort;\n-\n-\t\t\tcontent_length += i;\n-\t\t\tif (buffer_add_range(fd, evb, range) == 0)\n-\t\t\t\tgoto abort;\n-\n-\t\t\tcontent_length += range->end - range->start + 1;\n-\t\t\trange++;\n \t\t}\n-\n-\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",\n-\t\t    boundary)) == -1)\n+\t\tif ((ret = snprintf(NULL, 0, \"\\r\\n--%llu--\\r\\n\",\n+\t\t    clt->clt_boundary)) < 0)\n \t\t\tgoto abort;\n-\n-\t\tcontent_length += i;\n+\t\tcontent_length += ret;\n \n \t\t/* prepare multipart/byteranges media type */\n \t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n \t\t    sizeof(multipart_media.media_type));\n \t\t(void)snprintf(multipart_media.media_subtype,\n \t\t    sizeof(multipart_media.media_subtype),\n-\t\t    \"byteranges; boundary=%ud\", boundary);\n+\t\t    \"byteranges; boundary=%llu\", clt->clt_boundary);\n \t\tmedia = &multipart_media;\n \t}\n \n-\tclose(fd);\n-\tfd = -1;\n+\t/* Start with first range */\n+\tr->range_toread = TOREAD_HTTP_RANGE;\n \n \tret = server_response_http(clt, 206, media, content_length,\n \t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n@@ -102,23 +89,34 @@\n \t\tgoto fail;\n \tcase 0:\n \t\t/* Connection is already finished */\n+\t\tclose(fd);\n \t\tgoto done;\n \tdefault:\n \t\tbreak;\n \t}\n \n-\tif (server_bufferevent_write_buffer(clt, evb) == -1)\n+\tclt->clt_fd = fd;\n+\tif (clt->clt_srvbev != NULL)\n+\t\tbufferevent_free(clt->clt_srvbev);\n+\n+\tclt->clt_srvbev_throttled = 0;\n+\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,\n+\t    server_write, server_file_error, clt);\n+\tif (clt->clt_srvbev == NULL) {\n+\t\terrstr = \"failed to allocate file buffer event\";\n \t\tgoto fail;\n+\t}\n \n-\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n-\tif (clt->clt_persist)\n-\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n-\telse\n-\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n-\tclt->clt_done = 0;\n+\t/* Adjust read watermark to the socket output buffer size */\n+\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,\n+\t    clt->clt_sndbufsiz);\n+\n+\tbufferevent_settimeout(clt->clt_srvbev,\n+\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);\n+\tbufferevent_enable(clt->clt_srvbev, EV_READ);\n+\tbufferevent_disable(clt->clt_bev, EV_READ);\n \n  done:\n-\tevbuffer_free(evb);\n \tserver_reset_http(clt);\n \treturn (0);\n  fail:\n@@ -126,8 +124,6 @@\n \tbufferevent_free(clt->clt_bev);\n \tclt->clt_bev = NULL;\n  abort:\n-\tif (evb != NULL)\n-\t\tevbuffer_free(evb);\n \tif (fd != -1)\n \t\tclose(fd);\n \tif (errstr == NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct evbuffer\t\t*evb = NULL;",
                "\tsize_t\t\t\t content_length;",
                "\tuint32_t\t\t boundary;",
                "\tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {",
                "\tif ((evb = evbuffer_new()) == NULL) {",
                "\t\terrstr = \"failed to allocate file buffer\";",
                "\t\tgoto abort;",
                "\t}",
                "\t\tcontent_length = range->end - range->start + 1;",
                "\t\tif (buffer_add_range(fd, evb, range) == 0)",
                "\t\t\tgoto abort;",
                "\t} else {",
                "\t\tcontent_length = 0;",
                "\t\tboundary = arc4random();",
                "\t\t/* Generate a multipart payload of byteranges */",
                "\t\twhile (nranges--) {",
                "\t\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",",
                "\t\t\t    boundary)) == -1)",
                "\t\t\tcontent_length += i;",
                "\t\t\tif ((i = evbuffer_add_printf(evb,",
                "\t\t\t    \"Content-Type: %s/%s\\r\\n\",",
                "\t\t\t    media->media_type, media->media_subtype)) == -1)",
                "\t\t\t\tgoto abort;",
                "\t\t\tcontent_length += i;",
                "\t\t\tif ((i = evbuffer_add_printf(evb,",
                "\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",",
                "\t\t\t    range->start, range->end, st->st_size)) == -1)",
                "\t\t\t\tgoto abort;",
                "",
                "\t\t\tcontent_length += i;",
                "\t\t\tif (buffer_add_range(fd, evb, range) == 0)",
                "\t\t\t\tgoto abort;",
                "",
                "\t\t\tcontent_length += range->end - range->start + 1;",
                "\t\t\trange++;",
                "",
                "\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",",
                "\t\t    boundary)) == -1)",
                "",
                "\t\tcontent_length += i;",
                "\t\t    \"byteranges; boundary=%ud\", boundary);",
                "\tclose(fd);",
                "\tfd = -1;",
                "\tif (server_bufferevent_write_buffer(clt, evb) == -1)",
                "\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);",
                "\tif (clt->clt_persist)",
                "\t\tclt->clt_toread = TOREAD_HTTP_HEADER;",
                "\telse",
                "\t\tclt->clt_toread = TOREAD_HTTP_NONE;",
                "\tclt->clt_done = 0;",
                "\tevbuffer_free(evb);",
                "\tif (evb != NULL)",
                "\t\tevbuffer_free(evb);"
            ],
            "added_lines": [
                "\tstruct range_data\t*r = &clt->clt_ranges;",
                "\tsize_t\t\t\t content_length = 0;",
                "\tif ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {",
                "\tr->range_media = media;",
                "\t\trange = &r->range[0];",
                "\t\trange = &r->range[0];",
                "\t\tcontent_length += range->end - range->start + 1;",
                "\t} else {",
                "\t\t/* Add boundary, all parts will be handled by the callback */",
                "\t\tarc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));",
                "\t\t/* Calculate Content-Length of the complete multipart body */",
                "\t\tfor (i = 0; i < nranges; i++) {",
                "\t\t\trange = &r->range[i];",
                "",
                "\t\t\t/* calculate Content-Length of the complete body */",
                "\t\t\tif ((ret = snprintf(NULL, 0,",
                "\t\t\t    \"\\r\\n--%llu\\r\\n\"",
                "\t\t\t    \"Content-Type: %s/%s\\r\\n\"",
                "\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",",
                "\t\t\t    clt->clt_boundary,",
                "\t\t\t    media->media_type, media->media_subtype,",
                "\t\t\t    range->start, range->end, st->st_size)) < 0)",
                "\t\t\t/* Add data length */",
                "\t\t\tcontent_length += ret + range->end - range->start + 1;",
                "\t\tif ((ret = snprintf(NULL, 0, \"\\r\\n--%llu--\\r\\n\",",
                "\t\t    clt->clt_boundary)) < 0)",
                "\t\tcontent_length += ret;",
                "\t\t    \"byteranges; boundary=%llu\", clt->clt_boundary);",
                "\t/* Start with first range */",
                "\tr->range_toread = TOREAD_HTTP_RANGE;",
                "\t\tclose(fd);",
                "\tclt->clt_fd = fd;",
                "\tif (clt->clt_srvbev != NULL)",
                "\t\tbufferevent_free(clt->clt_srvbev);",
                "",
                "\tclt->clt_srvbev_throttled = 0;",
                "\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,",
                "\t    server_write, server_file_error, clt);",
                "\tif (clt->clt_srvbev == NULL) {",
                "\t\terrstr = \"failed to allocate file buffer event\";",
                "\t}",
                "\t/* Adjust read watermark to the socket output buffer size */",
                "\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,",
                "\t    clt->clt_sndbufsiz);",
                "",
                "\tbufferevent_settimeout(clt->clt_srvbev,",
                "\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);",
                "\tbufferevent_enable(clt->clt_srvbev, EV_READ);",
                "\tbufferevent_disable(clt->clt_bev, EV_READ);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9039",
        "func_name": "binutils-gdb/process_mips_specific",
        "description": "GNU Binutils 2.28 allows remote attackers to cause a denial of service (memory consumption) via a crafted ELF file with many program headers, related to the get_program_headers function in readelf.c.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=82156ab704b08b124d319c0decdbd48b3ca2dac5",
        "commit_title": "",
        "commit_text": "readelf: Fix overlarge memory allocation when reading a binary with an excessive number of program headers.  \tPR binutils/21345 \t* readelf.c (get_program_headers): Check for there being too many \tprogram headers before attempting to allocate space for them. ",
        "func_before": "static bfd_boolean\nprocess_mips_specific (FILE * file)\n{\n  Elf_Internal_Dyn * entry;\n  Elf_Internal_Shdr *sect = NULL;\n  size_t liblist_offset = 0;\n  size_t liblistno = 0;\n  size_t conflictsno = 0;\n  size_t options_offset = 0;\n  size_t conflicts_offset = 0;\n  size_t pltrelsz = 0;\n  size_t pltrel = 0;\n  bfd_vma pltgot = 0;\n  bfd_vma mips_pltgot = 0;\n  bfd_vma jmprel = 0;\n  bfd_vma local_gotno = 0;\n  bfd_vma gotsym = 0;\n  bfd_vma symtabno = 0;\n  bfd_boolean res = TRUE;\n\n  if (! process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t    display_mips_gnu_attribute))\n    res = FALSE;\n\n  sect = find_section (\".MIPS.abiflags\");\n\n  if (sect != NULL)\n    {\n      Elf_External_ABIFlags_v0 *abiflags_ext;\n      Elf_Internal_ABIFlags_v0 abiflags_in;\n\n      if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size)\n\t{\n\t  error (_(\"Corrupt MIPS ABI Flags section.\\n\"));\n\t  res = FALSE;\n\t}\n      else\n\t{\n\t  abiflags_ext = get_data (NULL, file, sect->sh_offset, 1,\n\t\t\t\t   sect->sh_size, _(\"MIPS ABI Flags section\"));\n\t  if (abiflags_ext)\n\t    {\n\t      abiflags_in.version = BYTE_GET (abiflags_ext->version);\n\t      abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level);\n\t      abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev);\n\t      abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size);\n\t      abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size);\n\t      abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size);\n\t      abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi);\n\t      abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext);\n\t      abiflags_in.ases = BYTE_GET (abiflags_ext->ases);\n\t      abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1);\n\t      abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2);\n\n\t      printf (\"\\nMIPS ABI Flags Version: %d\\n\", abiflags_in.version);\n\t      printf (\"\\nISA: MIPS%d\", abiflags_in.isa_level);\n\t      if (abiflags_in.isa_rev > 1)\n\t\tprintf (\"r%d\", abiflags_in.isa_rev);\n\t      printf (\"\\nGPR size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.gpr_size));\n\t      printf (\"\\nCPR1 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr1_size));\n\t      printf (\"\\nCPR2 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr2_size));\n\t      fputs (\"\\nFP ABI: \", stdout);\n\t      print_mips_fp_abi_value (abiflags_in.fp_abi);\n\t      fputs (\"ISA Extension: \", stdout);\n\t      print_mips_isa_ext (abiflags_in.isa_ext);\n\t      fputs (\"\\nASEs:\", stdout);\n\t      print_mips_ases (abiflags_in.ases);\n\t      printf (\"\\nFLAGS 1: %8.8lx\", abiflags_in.flags1);\n\t      printf (\"\\nFLAGS 2: %8.8lx\", abiflags_in.flags2);\n\t      fputc ('\\n', stdout);\n\t      free (abiflags_ext);\n\t    }\n\t}\n    }\n\n  /* We have a lot of special sections.  Thanks SGI!  */\n  if (dynamic_section == NULL)\n    /* No information available.  */\n    return res;\n\n  for (entry = dynamic_section;\n       /* PR 17531 file: 012-50589-0.004.  */\n       entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL;\n       ++entry)\n    switch (entry->d_tag)\n      {\n      case DT_MIPS_LIBLIST:\n\tliblist_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     liblistno * sizeof (Elf32_External_Lib));\n\tbreak;\n      case DT_MIPS_LIBLISTNO:\n\tliblistno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_OPTIONS:\n\toptions_offset = offset_from_vma (file, entry->d_un.d_val, 0);\n\tbreak;\n      case DT_MIPS_CONFLICT:\n\tconflicts_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     conflictsno * sizeof (Elf32_External_Conflict));\n\tbreak;\n      case DT_MIPS_CONFLICTNO:\n\tconflictsno = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTGOT:\n\tpltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_MIPS_LOCAL_GOTNO:\n\tlocal_gotno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_GOTSYM:\n\tgotsym = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_SYMTABNO:\n\tsymtabno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_PLTGOT:\n\tmips_pltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_PLTREL:\n\tpltrel = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTRELSZ:\n\tpltrelsz = entry->d_un.d_val;\n\tbreak;\n      case DT_JMPREL:\n\tjmprel = entry->d_un.d_ptr;\n\tbreak;\n      default:\n\tbreak;\n      }\n\n  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)\n    {\n      Elf32_External_Lib * elib;\n      size_t cnt;\n\n      elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset,\n                                              liblistno,\n                                              sizeof (Elf32_External_Lib),\n                                              _(\"liblist section data\"));\n      if (elib)\n\t{\n\t  printf (_(\"\\nSection '.liblist' contains %lu entries:\\n\"),\n\t\t  (unsigned long) liblistno);\n\t  fputs (_(\"     Library              Time Stamp          Checksum   Version Flags\\n\"),\n\t\t stdout);\n\n\t  for (cnt = 0; cnt < liblistno; ++cnt)\n\t    {\n\t      Elf32_Lib liblist;\n\t      time_t atime;\n\t      char timebuf[128];\n\t      struct tm * tmp;\n\n\t      liblist.l_name = BYTE_GET (elib[cnt].l_name);\n\t      atime = BYTE_GET (elib[cnt].l_time_stamp);\n\t      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);\n\t      liblist.l_version = BYTE_GET (elib[cnt].l_version);\n\t      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);\n\n\t      tmp = gmtime (&atime);\n\t      snprintf (timebuf, sizeof (timebuf),\n\t\t\t\"%04u-%02u-%02uT%02u:%02u:%02u\",\n\t\t\ttmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,\n\t\t\ttmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n\t      printf (\"%3lu: \", (unsigned long) cnt);\n\t      if (VALID_DYNAMIC_NAME (liblist.l_name))\n\t\tprint_symbol (20, GET_DYNAMIC_NAME (liblist.l_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %9ld>\"), liblist.l_name);\n\t      printf (\" %s %#10lx %-7ld\", timebuf, liblist.l_checksum,\n\t\t      liblist.l_version);\n\n\t      if (liblist.l_flags == 0)\n\t\tputs (_(\" NONE\"));\n\t      else\n\t\t{\n\t\t  static const struct\n\t\t  {\n\t\t    const char * name;\n\t\t    int bit;\n\t\t  }\n\t\t  l_flags_vals[] =\n\t\t  {\n\t\t    { \" EXACT_MATCH\", LL_EXACT_MATCH },\n\t\t    { \" IGNORE_INT_VER\", LL_IGNORE_INT_VER },\n\t\t    { \" REQUIRE_MINOR\", LL_REQUIRE_MINOR },\n\t\t    { \" EXPORTS\", LL_EXPORTS },\n\t\t    { \" DELAY_LOAD\", LL_DELAY_LOAD },\n\t\t    { \" DELTA\", LL_DELTA }\n\t\t  };\n\t\t  int flags = liblist.l_flags;\n\t\t  size_t fcnt;\n\n\t\t  for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt)\n\t\t    if ((flags & l_flags_vals[fcnt].bit) != 0)\n\t\t      {\n\t\t\tfputs (l_flags_vals[fcnt].name, stdout);\n\t\t\tflags ^= l_flags_vals[fcnt].bit;\n\t\t      }\n\t\t  if (flags != 0)\n\t\t    printf (\" %#x\", (unsigned int) flags);\n\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\n\t  free (elib);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (options_offset != 0)\n    {\n      Elf_External_Options * eopt;\n      Elf_Internal_Options * iopt;\n      Elf_Internal_Options * option;\n      size_t offset;\n      int cnt;\n      sect = section_headers;\n\n      /* Find the section header so that we get the size.  */\n      sect = find_section_by_type (SHT_MIPS_OPTIONS);\n      /* PR 17533 file: 012-277276-0.004.  */\n      if (sect == NULL)\n\t{\n\t  error (_(\"No MIPS_OPTIONS header found\\n\"));\n\t  return FALSE;\n\t}\n\n      eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1,\n                                                sect->sh_size, _(\"options\"));\n      if (eopt)\n\t{\n\t  iopt = (Elf_Internal_Options *)\n              cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));\n\t  if (iopt == NULL)\n\t    {\n\t      error (_(\"Out of memory allocating space for MIPS options\\n\"));\n\t      return FALSE;\n\t    }\n\n\t  offset = cnt = 0;\n\t  option = iopt;\n\n\t  while (offset <= sect->sh_size - sizeof (* eopt))\n\t    {\n\t      Elf_External_Options * eoption;\n\n\t      eoption = (Elf_External_Options *) ((char *) eopt + offset);\n\n\t      option->kind = BYTE_GET (eoption->kind);\n\t      option->size = BYTE_GET (eoption->size);\n\t      option->section = BYTE_GET (eoption->section);\n\t      option->info = BYTE_GET (eoption->info);\n\n\t      /* PR 17531: file: ffa0fa3b.  */\n\t      if (option->size < sizeof (* eopt)\n\t\t  || offset + option->size > sect->sh_size)\n\t\t{\n\t\t  error (_(\"Invalid size (%u) for MIPS option\\n\"), option->size);\n\t\t  return FALSE;\n\t\t}\n\t      offset += option->size;\n\n\t      ++option;\n\t      ++cnt;\n\t    }\n\n\t  printf (_(\"\\nSection '%s' contains %d entries:\\n\"),\n\t\t  printable_section_name (sect), cnt);\n\n\t  option = iopt;\n\t  offset = 0;\n\n\t  while (cnt-- > 0)\n\t    {\n\t      size_t len;\n\n\t      switch (option->kind)\n\t\t{\n\t\tcase ODK_NULL:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" NULL       %d %lx\", option->section, option->info);\n\t\t  break;\n\t\tcase ODK_REGINFO:\n\t\t  printf (\" REGINFO    \");\n\t\t  if (elf_header.e_machine == EM_MIPS)\n\t\t    {\n\t\t      /* 32bit form.  */\n\t\t      Elf32_External_RegInfo * ereg;\n\t\t      Elf32_RegInfo reginfo;\n\n\t\t      ereg = (Elf32_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x%lx\\n\",\n\t\t\t      reginfo.ri_gprmask,\n\t\t\t      (unsigned long) reginfo.ri_gp_value);\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* 64 bit form.  */\n\t\t      Elf64_External_RegInfo * ereg;\n\t\t      Elf64_Internal_RegInfo reginfo;\n\n\t\t      ereg = (Elf64_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x\",\n\t\t\t      reginfo.ri_gprmask);\n\t\t      printf_vma (reginfo.ri_gp_value);\n\t\t      printf (\"\\n\");\n\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  ++option;\n\t\t  continue;\n\t\tcase ODK_EXCEPTIONS:\n\t\t  fputs (\" EXCEPTIONS fpe_min(\", stdout);\n\t\t  process_mips_fpe_exception (option->info & OEX_FPU_MIN);\n\t\t  fputs (\") fpe_max(\", stdout);\n\t\t  process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8);\n\t\t  fputs (\")\", stdout);\n\n\t\t  if (option->info & OEX_PAGE0)\n\t\t    fputs (\" PAGE0\", stdout);\n\t\t  if (option->info & OEX_SMM)\n\t\t    fputs (\" SMM\", stdout);\n\t\t  if (option->info & OEX_FPDBUG)\n\t\t    fputs (\" FPDBUG\", stdout);\n\t\t  if (option->info & OEX_DISMISS)\n\t\t    fputs (\" DISMISS\", stdout);\n\t\t  break;\n\t\tcase ODK_PAD:\n\t\t  fputs (\" PAD       \", stdout);\n\t\t  if (option->info & OPAD_PREFIX)\n\t\t    fputs (\" PREFIX\", stdout);\n\t\t  if (option->info & OPAD_POSTFIX)\n\t\t    fputs (\" POSTFIX\", stdout);\n\t\t  if (option->info & OPAD_SYMBOL)\n\t\t    fputs (\" SYMBOL\", stdout);\n\t\t  break;\n\t\tcase ODK_HWPATCH:\n\t\t  fputs (\" HWPATCH   \", stdout);\n\t\t  if (option->info & OHW_R4KEOP)\n\t\t    fputs (\" R4KEOP\", stdout);\n\t\t  if (option->info & OHW_R8KPFETCH)\n\t\t    fputs (\" R8KPFETCH\", stdout);\n\t\t  if (option->info & OHW_R5KEOP)\n\t\t    fputs (\" R5KEOP\", stdout);\n\t\t  if (option->info & OHW_R5KCVTL)\n\t\t    fputs (\" R5KCVTL\", stdout);\n\t\t  break;\n\t\tcase ODK_FILL:\n\t\t  fputs (\" FILL       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_TAGS:\n\t\t  fputs (\" TAGS       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_HWAND:\n\t\t  fputs (\" HWAND     \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_HWOR:\n\t\t  fputs (\" HWOR      \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_GP_GROUP:\n\t\t  printf (\" GP_GROUP  %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tcase ODK_IDENT:\n\t\t  printf (\" IDENT     %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tdefault:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" %3d ???     %d %lx\",\n\t\t\t  option->kind, option->section, option->info);\n\t\t  break;\n\t\t}\n\n\t      len = sizeof (* eopt);\n\t      while (len < option->size)\n\t\t{\n\t\t  unsigned char datum = * ((unsigned char *) eopt + offset + len);\n\n\t\t  if (ISPRINT (datum))\n\t\t    printf (\"%c\", datum);\n\t\t  else\n\t\t    printf (\"\\\\%03o\", datum);\n\t\t  len ++;\n\t\t}\n\t      fputs (\"\\n\", stdout);\n\n\t      offset += option->size;\n\t      ++option;\n\t    }\n\n\t  free (eopt);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (conflicts_offset != 0 && conflictsno != 0)\n    {\n      Elf32_Conflict * iconf;\n      size_t cnt;\n\n      if (dynamic_symbols == NULL)\n\t{\n\t  error (_(\"conflict list found without a dynamic symbol table\\n\"));\n\t  return FALSE;\n\t}\n\n      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));\n      if (iconf == NULL)\n\t{\n\t  error (_(\"Out of memory allocating space for dynamic conflicts\\n\"));\n\t  return FALSE;\n\t}\n\n      if (is_32bit_elf)\n\t{\n\t  Elf32_External_Conflict * econf32;\n\n\t  econf32 = (Elf32_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf32), _(\"conflict\"));\n\t  if (!econf32)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf32[cnt]);\n\n\t  free (econf32);\n\t}\n      else\n\t{\n\t  Elf64_External_Conflict * econf64;\n\n\t  econf64 = (Elf64_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf64), _(\"conflict\"));\n\t  if (!econf64)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf64[cnt]);\n\n\t  free (econf64);\n\t}\n\n      printf (_(\"\\nSection '.conflict' contains %lu entries:\\n\"),\n\t      (unsigned long) conflictsno);\n      puts (_(\"  Num:    Index       Value  Name\"));\n\n      for (cnt = 0; cnt < conflictsno; ++cnt)\n\t{\n\t  printf (\"%5lu: %8lu  \", (unsigned long) cnt, iconf[cnt]);\n\n\t  if (iconf[cnt] >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index>\"));\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym;\n\n\t      psym = & dynamic_symbols[iconf[cnt]];\n\t      print_vma (psym->st_value, FULL_HEX);\n\t      putchar (' ');\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (25, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  putchar ('\\n');\n\t}\n\n      free (iconf);\n    }\n\n  if (pltgot != 0 && local_gotno != 0)\n    {\n      bfd_vma ent, local_end, global_end;\n      size_t i, offset;\n      unsigned char * data;\n      unsigned char * data_end;\n      int addr_size;\n\n      ent = pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      local_end = pltgot + local_gotno * addr_size;\n\n      /* PR binutils/17533 file: 012-111227-0.004  */\n      if (symtabno < gotsym)\n\t{\n\t  error (_(\"The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\\n\"),\n\t\t (unsigned long) gotsym, (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      global_end = local_end + (symtabno - gotsym) * addr_size;\n      /* PR 17531: file: 54c91a34.  */\n      if (global_end < local_end)\n\t{\n\t  error (_(\"Too many GOT symbols: %lu\\n\"), (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      offset = offset_from_vma (file, pltgot, global_end - pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset,\n                                         global_end - pltgot, 1,\n\t\t\t\t\t _(\"Global Offset Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n      data_end = data + (global_end - pltgot);\n\n      printf (_(\"\\nPrimary GOT:\\n\"));\n      printf (_(\" Canonical gp value: \"));\n      print_vma (pltgot + 0x7ff0, LONG_HEX);\n      printf (\"\\n\\n\");\n\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %10s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t      addr_size * 2, _(\"Initial\"));\n      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n      printf (_(\" Lazy resolver\\n\"));\n      if (ent == (bfd_vma) -1)\n\tgoto got_print_fail;\n\n      if (data)\n\t{\n\t  /* PR 21344 */\n\t  if (data + ent - pltgot > data_end - addr_size)\n\t    {\n\t      error (_(\"Invalid got entry - %#lx - overflows GOT table\\n\"), ent);\n\t      goto got_print_fail;\n\t    }\n\t  \n\t  if (byte_get (data + ent - pltgot, addr_size)\n\t      >> (addr_size * 8 - 1) != 0)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (_(\" Module pointer (GNU extension)\\n\"));\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t}\n      printf (\"\\n\");\n\n      if (ent < local_end)\n\t{\n\t  printf (_(\" Local entries:\\n\"));\n\t  printf (\"  %*s %10s %*s\\n\",\n\t\t  addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"));\n\t  while (ent < local_end)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n      if (gotsym < symtabno)\n\t{\n\t  int sym_width;\n\n\t  printf (_(\" Global entries:\\n\"));\n\t  printf (\"  %*s %10s %*s %*s %-7s %3s %s\\n\",\n\t\t  addr_size * 2, _(\"Address\"),\n\t\t  _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"),\n\t\t  addr_size * 2, _(\"Sym.Val.\"),\n\t\t  _(\"Type\"),\n\t\t  /* Note for translators: \"Ndx\" = abbreviated form of \"Index\".  */\n\t\t  _(\"Ndx\"), _(\"Name\"));\n\n\t  sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;\n\n\t  for (i = gotsym; i < symtabno; i++)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\" \");\n\n\t      if (dynamic_symbols == NULL)\n\t\tprintf (_(\"<no dynamic symbols>\"));\n\t      else if (i < num_dynamic_syms)\n\t\t{\n\t\t  Elf_Internal_Sym * psym = dynamic_symbols + i;\n\n\t\t  print_vma (psym->st_value, LONG_HEX);\n\t\t  printf (\" %-7s %3s \",\n\t\t\t  get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t\t  get_symbol_index_type (psym->st_shndx));\n\n\t\t  if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\t    print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t\t  else\n\t\t    printf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t\t}\n\t      else\n\t\tprintf (_(\"<symbol index %lu exceeds number of dynamic symbols>\"),\n\t\t\t(unsigned long) i);\n\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tbreak;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n    got_print_fail:\n      if (data)\n\tfree (data);\n    }\n\n  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)\n    {\n      bfd_vma ent, end;\n      size_t offset, rel_offset;\n      unsigned long count, i;\n      unsigned char * data;\n      int addr_size, sym_width;\n      Elf_Internal_Rela * rels;\n\n      rel_offset = offset_from_vma (file, jmprel, pltrelsz);\n      if (pltrel == DT_RELA)\n\t{\n\t  if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n      else\n\t{\n\t  if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n\n      ent = mips_pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      end = mips_pltgot + (2 + count) * addr_size;\n\n      offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot,\n                                         1, _(\"Procedure Linkage Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n\n      printf (\"\\nPLT GOT:\\n\\n\");\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), addr_size * 2, _(\"Initial\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" PLT lazy resolver\\n\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" Module pointer\\n\"));\n      printf (\"\\n\");\n\n      printf (_(\" Entries:\\n\"));\n      printf (\"  %*s %*s %*s %-7s %3s %s\\n\",\n\t      addr_size * 2, _(\"Address\"),\n\t      addr_size * 2, _(\"Initial\"),\n\t      addr_size * 2, _(\"Sym.Val.\"), _(\"Type\"), _(\"Ndx\"), _(\"Name\"));\n      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;\n      for (i = 0; i < count; i++)\n\t{\n\t  unsigned long idx = get_reloc_symindex (rels[i].r_info);\n\n\t  ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n\t  printf (\" \");\n\n\t  if (idx >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index: %lu>\"), idx);\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym = dynamic_symbols + idx;\n\n\t      print_vma (psym->st_value, LONG_HEX);\n\t      printf (\" %-7s %3s \",\n\t\t      get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t      get_symbol_index_type (psym->st_shndx));\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  printf (\"\\n\");\n\t}\n      printf (\"\\n\");\n\n      if (data)\n\tfree (data);\n      free (rels);\n    }\n\n  return res;\n}",
        "func": "static bfd_boolean\nprocess_mips_specific (FILE * file)\n{\n  Elf_Internal_Dyn * entry;\n  Elf_Internal_Shdr *sect = NULL;\n  size_t liblist_offset = 0;\n  size_t liblistno = 0;\n  size_t conflictsno = 0;\n  size_t options_offset = 0;\n  size_t conflicts_offset = 0;\n  size_t pltrelsz = 0;\n  size_t pltrel = 0;\n  bfd_vma pltgot = 0;\n  bfd_vma mips_pltgot = 0;\n  bfd_vma jmprel = 0;\n  bfd_vma local_gotno = 0;\n  bfd_vma gotsym = 0;\n  bfd_vma symtabno = 0;\n  bfd_boolean res = TRUE;\n\n  if (! process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,\n\t\t\t    display_mips_gnu_attribute))\n    res = FALSE;\n\n  sect = find_section (\".MIPS.abiflags\");\n\n  if (sect != NULL)\n    {\n      Elf_External_ABIFlags_v0 *abiflags_ext;\n      Elf_Internal_ABIFlags_v0 abiflags_in;\n\n      if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size)\n\t{\n\t  error (_(\"Corrupt MIPS ABI Flags section.\\n\"));\n\t  res = FALSE;\n\t}\n      else\n\t{\n\t  abiflags_ext = get_data (NULL, file, sect->sh_offset, 1,\n\t\t\t\t   sect->sh_size, _(\"MIPS ABI Flags section\"));\n\t  if (abiflags_ext)\n\t    {\n\t      abiflags_in.version = BYTE_GET (abiflags_ext->version);\n\t      abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level);\n\t      abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev);\n\t      abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size);\n\t      abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size);\n\t      abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size);\n\t      abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi);\n\t      abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext);\n\t      abiflags_in.ases = BYTE_GET (abiflags_ext->ases);\n\t      abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1);\n\t      abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2);\n\n\t      printf (\"\\nMIPS ABI Flags Version: %d\\n\", abiflags_in.version);\n\t      printf (\"\\nISA: MIPS%d\", abiflags_in.isa_level);\n\t      if (abiflags_in.isa_rev > 1)\n\t\tprintf (\"r%d\", abiflags_in.isa_rev);\n\t      printf (\"\\nGPR size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.gpr_size));\n\t      printf (\"\\nCPR1 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr1_size));\n\t      printf (\"\\nCPR2 size: %d\",\n\t\t      get_mips_reg_size (abiflags_in.cpr2_size));\n\t      fputs (\"\\nFP ABI: \", stdout);\n\t      print_mips_fp_abi_value (abiflags_in.fp_abi);\n\t      fputs (\"ISA Extension: \", stdout);\n\t      print_mips_isa_ext (abiflags_in.isa_ext);\n\t      fputs (\"\\nASEs:\", stdout);\n\t      print_mips_ases (abiflags_in.ases);\n\t      printf (\"\\nFLAGS 1: %8.8lx\", abiflags_in.flags1);\n\t      printf (\"\\nFLAGS 2: %8.8lx\", abiflags_in.flags2);\n\t      fputc ('\\n', stdout);\n\t      free (abiflags_ext);\n\t    }\n\t}\n    }\n\n  /* We have a lot of special sections.  Thanks SGI!  */\n  if (dynamic_section == NULL)\n    /* No information available.  */\n    return res;\n\n  for (entry = dynamic_section;\n       /* PR 17531 file: 012-50589-0.004.  */\n       entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL;\n       ++entry)\n    switch (entry->d_tag)\n      {\n      case DT_MIPS_LIBLIST:\n\tliblist_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     liblistno * sizeof (Elf32_External_Lib));\n\tbreak;\n      case DT_MIPS_LIBLISTNO:\n\tliblistno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_OPTIONS:\n\toptions_offset = offset_from_vma (file, entry->d_un.d_val, 0);\n\tbreak;\n      case DT_MIPS_CONFLICT:\n\tconflicts_offset\n\t  = offset_from_vma (file, entry->d_un.d_val,\n\t\t\t     conflictsno * sizeof (Elf32_External_Conflict));\n\tbreak;\n      case DT_MIPS_CONFLICTNO:\n\tconflictsno = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTGOT:\n\tpltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_MIPS_LOCAL_GOTNO:\n\tlocal_gotno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_GOTSYM:\n\tgotsym = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_SYMTABNO:\n\tsymtabno = entry->d_un.d_val;\n\tbreak;\n      case DT_MIPS_PLTGOT:\n\tmips_pltgot = entry->d_un.d_ptr;\n\tbreak;\n      case DT_PLTREL:\n\tpltrel = entry->d_un.d_val;\n\tbreak;\n      case DT_PLTRELSZ:\n\tpltrelsz = entry->d_un.d_val;\n\tbreak;\n      case DT_JMPREL:\n\tjmprel = entry->d_un.d_ptr;\n\tbreak;\n      default:\n\tbreak;\n      }\n\n  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)\n    {\n      Elf32_External_Lib * elib;\n      size_t cnt;\n\n      elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset,\n                                              liblistno,\n                                              sizeof (Elf32_External_Lib),\n                                              _(\"liblist section data\"));\n      if (elib)\n\t{\n\t  printf (_(\"\\nSection '.liblist' contains %lu entries:\\n\"),\n\t\t  (unsigned long) liblistno);\n\t  fputs (_(\"     Library              Time Stamp          Checksum   Version Flags\\n\"),\n\t\t stdout);\n\n\t  for (cnt = 0; cnt < liblistno; ++cnt)\n\t    {\n\t      Elf32_Lib liblist;\n\t      time_t atime;\n\t      char timebuf[128];\n\t      struct tm * tmp;\n\n\t      liblist.l_name = BYTE_GET (elib[cnt].l_name);\n\t      atime = BYTE_GET (elib[cnt].l_time_stamp);\n\t      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);\n\t      liblist.l_version = BYTE_GET (elib[cnt].l_version);\n\t      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);\n\n\t      tmp = gmtime (&atime);\n\t      snprintf (timebuf, sizeof (timebuf),\n\t\t\t\"%04u-%02u-%02uT%02u:%02u:%02u\",\n\t\t\ttmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,\n\t\t\ttmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n\t      printf (\"%3lu: \", (unsigned long) cnt);\n\t      if (VALID_DYNAMIC_NAME (liblist.l_name))\n\t\tprint_symbol (20, GET_DYNAMIC_NAME (liblist.l_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %9ld>\"), liblist.l_name);\n\t      printf (\" %s %#10lx %-7ld\", timebuf, liblist.l_checksum,\n\t\t      liblist.l_version);\n\n\t      if (liblist.l_flags == 0)\n\t\tputs (_(\" NONE\"));\n\t      else\n\t\t{\n\t\t  static const struct\n\t\t  {\n\t\t    const char * name;\n\t\t    int bit;\n\t\t  }\n\t\t  l_flags_vals[] =\n\t\t  {\n\t\t    { \" EXACT_MATCH\", LL_EXACT_MATCH },\n\t\t    { \" IGNORE_INT_VER\", LL_IGNORE_INT_VER },\n\t\t    { \" REQUIRE_MINOR\", LL_REQUIRE_MINOR },\n\t\t    { \" EXPORTS\", LL_EXPORTS },\n\t\t    { \" DELAY_LOAD\", LL_DELAY_LOAD },\n\t\t    { \" DELTA\", LL_DELTA }\n\t\t  };\n\t\t  int flags = liblist.l_flags;\n\t\t  size_t fcnt;\n\n\t\t  for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt)\n\t\t    if ((flags & l_flags_vals[fcnt].bit) != 0)\n\t\t      {\n\t\t\tfputs (l_flags_vals[fcnt].name, stdout);\n\t\t\tflags ^= l_flags_vals[fcnt].bit;\n\t\t      }\n\t\t  if (flags != 0)\n\t\t    printf (\" %#x\", (unsigned int) flags);\n\n\t\t  puts (\"\");\n\t\t}\n\t    }\n\n\t  free (elib);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (options_offset != 0)\n    {\n      Elf_External_Options * eopt;\n      Elf_Internal_Options * iopt;\n      Elf_Internal_Options * option;\n      size_t offset;\n      int cnt;\n      sect = section_headers;\n\n      /* Find the section header so that we get the size.  */\n      sect = find_section_by_type (SHT_MIPS_OPTIONS);\n      /* PR 17533 file: 012-277276-0.004.  */\n      if (sect == NULL)\n\t{\n\t  error (_(\"No MIPS_OPTIONS header found\\n\"));\n\t  return FALSE;\n\t}\n\n      eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1,\n                                                sect->sh_size, _(\"options\"));\n      if (eopt)\n\t{\n\t  iopt = (Elf_Internal_Options *)\n              cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));\n\t  if (iopt == NULL)\n\t    {\n\t      error (_(\"Out of memory allocating space for MIPS options\\n\"));\n\t      return FALSE;\n\t    }\n\n\t  offset = cnt = 0;\n\t  option = iopt;\n\n\t  while (offset <= sect->sh_size - sizeof (* eopt))\n\t    {\n\t      Elf_External_Options * eoption;\n\n\t      eoption = (Elf_External_Options *) ((char *) eopt + offset);\n\n\t      option->kind = BYTE_GET (eoption->kind);\n\t      option->size = BYTE_GET (eoption->size);\n\t      option->section = BYTE_GET (eoption->section);\n\t      option->info = BYTE_GET (eoption->info);\n\n\t      /* PR 17531: file: ffa0fa3b.  */\n\t      if (option->size < sizeof (* eopt)\n\t\t  || offset + option->size > sect->sh_size)\n\t\t{\n\t\t  error (_(\"Invalid size (%u) for MIPS option\\n\"), option->size);\n\t\t  return FALSE;\n\t\t}\n\t      offset += option->size;\n\n\t      ++option;\n\t      ++cnt;\n\t    }\n\n\t  printf (_(\"\\nSection '%s' contains %d entries:\\n\"),\n\t\t  printable_section_name (sect), cnt);\n\n\t  option = iopt;\n\t  offset = 0;\n\n\t  while (cnt-- > 0)\n\t    {\n\t      size_t len;\n\n\t      switch (option->kind)\n\t\t{\n\t\tcase ODK_NULL:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" NULL       %d %lx\", option->section, option->info);\n\t\t  break;\n\t\tcase ODK_REGINFO:\n\t\t  printf (\" REGINFO    \");\n\t\t  if (elf_header.e_machine == EM_MIPS)\n\t\t    {\n\t\t      /* 32bit form.  */\n\t\t      Elf32_External_RegInfo * ereg;\n\t\t      Elf32_RegInfo reginfo;\n\n\t\t      ereg = (Elf32_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x%lx\\n\",\n\t\t\t      reginfo.ri_gprmask,\n\t\t\t      (unsigned long) reginfo.ri_gp_value);\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* 64 bit form.  */\n\t\t      Elf64_External_RegInfo * ereg;\n\t\t      Elf64_Internal_RegInfo reginfo;\n\n\t\t      ereg = (Elf64_External_RegInfo *) (option + 1);\n\t\t      reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask);\n\t\t      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);\n\t\t      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);\n\t\t      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);\n\t\t      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);\n\t\t      reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value);\n\n\t\t      printf (\"GPR %08lx  GP 0x\",\n\t\t\t      reginfo.ri_gprmask);\n\t\t      printf_vma (reginfo.ri_gp_value);\n\t\t      printf (\"\\n\");\n\n\t\t      printf (\"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\\n\",\n\t\t\t      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],\n\t\t\t      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);\n\t\t    }\n\t\t  ++option;\n\t\t  continue;\n\t\tcase ODK_EXCEPTIONS:\n\t\t  fputs (\" EXCEPTIONS fpe_min(\", stdout);\n\t\t  process_mips_fpe_exception (option->info & OEX_FPU_MIN);\n\t\t  fputs (\") fpe_max(\", stdout);\n\t\t  process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8);\n\t\t  fputs (\")\", stdout);\n\n\t\t  if (option->info & OEX_PAGE0)\n\t\t    fputs (\" PAGE0\", stdout);\n\t\t  if (option->info & OEX_SMM)\n\t\t    fputs (\" SMM\", stdout);\n\t\t  if (option->info & OEX_FPDBUG)\n\t\t    fputs (\" FPDBUG\", stdout);\n\t\t  if (option->info & OEX_DISMISS)\n\t\t    fputs (\" DISMISS\", stdout);\n\t\t  break;\n\t\tcase ODK_PAD:\n\t\t  fputs (\" PAD       \", stdout);\n\t\t  if (option->info & OPAD_PREFIX)\n\t\t    fputs (\" PREFIX\", stdout);\n\t\t  if (option->info & OPAD_POSTFIX)\n\t\t    fputs (\" POSTFIX\", stdout);\n\t\t  if (option->info & OPAD_SYMBOL)\n\t\t    fputs (\" SYMBOL\", stdout);\n\t\t  break;\n\t\tcase ODK_HWPATCH:\n\t\t  fputs (\" HWPATCH   \", stdout);\n\t\t  if (option->info & OHW_R4KEOP)\n\t\t    fputs (\" R4KEOP\", stdout);\n\t\t  if (option->info & OHW_R8KPFETCH)\n\t\t    fputs (\" R8KPFETCH\", stdout);\n\t\t  if (option->info & OHW_R5KEOP)\n\t\t    fputs (\" R5KEOP\", stdout);\n\t\t  if (option->info & OHW_R5KCVTL)\n\t\t    fputs (\" R5KCVTL\", stdout);\n\t\t  break;\n\t\tcase ODK_FILL:\n\t\t  fputs (\" FILL       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_TAGS:\n\t\t  fputs (\" TAGS       \", stdout);\n\t\t  /* XXX Print content of info word?  */\n\t\t  break;\n\t\tcase ODK_HWAND:\n\t\t  fputs (\" HWAND     \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_HWOR:\n\t\t  fputs (\" HWOR      \", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CHECKED)\n\t\t    fputs (\" R4KEOP_CHECKED\", stdout);\n\t\t  if (option->info & OHWA0_R4KEOP_CLEAN)\n\t\t    fputs (\" R4KEOP_CLEAN\", stdout);\n\t\t  break;\n\t\tcase ODK_GP_GROUP:\n\t\t  printf (\" GP_GROUP  %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tcase ODK_IDENT:\n\t\t  printf (\" IDENT     %#06lx  self-contained %#06lx\",\n\t\t\t  option->info & OGP_GROUP,\n\t\t\t  (option->info & OGP_SELF) >> 16);\n\t\t  break;\n\t\tdefault:\n\t\t  /* This shouldn't happen.  */\n\t\t  printf (\" %3d ???     %d %lx\",\n\t\t\t  option->kind, option->section, option->info);\n\t\t  break;\n\t\t}\n\n\t      len = sizeof (* eopt);\n\t      while (len < option->size)\n\t\t{\n\t\t  unsigned char datum = * ((unsigned char *) eopt + offset + len);\n\n\t\t  if (ISPRINT (datum))\n\t\t    printf (\"%c\", datum);\n\t\t  else\n\t\t    printf (\"\\\\%03o\", datum);\n\t\t  len ++;\n\t\t}\n\t      fputs (\"\\n\", stdout);\n\n\t      offset += option->size;\n\t      ++option;\n\t    }\n\n\t  free (eopt);\n\t}\n      else\n\tres = FALSE;\n    }\n\n  if (conflicts_offset != 0 && conflictsno != 0)\n    {\n      Elf32_Conflict * iconf;\n      size_t cnt;\n\n      if (dynamic_symbols == NULL)\n\t{\n\t  error (_(\"conflict list found without a dynamic symbol table\\n\"));\n\t  return FALSE;\n\t}\n\n      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));\n      if (iconf == NULL)\n\t{\n\t  error (_(\"Out of memory allocating space for dynamic conflicts\\n\"));\n\t  return FALSE;\n\t}\n\n      if (is_32bit_elf)\n\t{\n\t  Elf32_External_Conflict * econf32;\n\n\t  econf32 = (Elf32_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf32), _(\"conflict\"));\n\t  if (!econf32)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf32[cnt]);\n\n\t  free (econf32);\n\t}\n      else\n\t{\n\t  Elf64_External_Conflict * econf64;\n\n\t  econf64 = (Elf64_External_Conflict *)\n              get_data (NULL, file, conflicts_offset, conflictsno,\n                        sizeof (* econf64), _(\"conflict\"));\n\t  if (!econf64)\n\t    return FALSE;\n\n\t  for (cnt = 0; cnt < conflictsno; ++cnt)\n\t    iconf[cnt] = BYTE_GET (econf64[cnt]);\n\n\t  free (econf64);\n\t}\n\n      printf (_(\"\\nSection '.conflict' contains %lu entries:\\n\"),\n\t      (unsigned long) conflictsno);\n      puts (_(\"  Num:    Index       Value  Name\"));\n\n      for (cnt = 0; cnt < conflictsno; ++cnt)\n\t{\n\t  printf (\"%5lu: %8lu  \", (unsigned long) cnt, iconf[cnt]);\n\n\t  if (iconf[cnt] >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index>\"));\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym;\n\n\t      psym = & dynamic_symbols[iconf[cnt]];\n\t      print_vma (psym->st_value, FULL_HEX);\n\t      putchar (' ');\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (25, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  putchar ('\\n');\n\t}\n\n      free (iconf);\n    }\n\n  if (pltgot != 0 && local_gotno != 0)\n    {\n      bfd_vma ent, local_end, global_end;\n      size_t i, offset;\n      unsigned char * data;\n      unsigned char * data_end;\n      int addr_size;\n\n      ent = pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      local_end = pltgot + local_gotno * addr_size;\n\n      /* PR binutils/17533 file: 012-111227-0.004  */\n      if (symtabno < gotsym)\n\t{\n\t  error (_(\"The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\\n\"),\n\t\t (unsigned long) gotsym, (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      global_end = local_end + (symtabno - gotsym) * addr_size;\n      /* PR 17531: file: 54c91a34.  */\n      if (global_end < local_end)\n\t{\n\t  error (_(\"Too many GOT symbols: %lu\\n\"), (unsigned long) symtabno);\n\t  return FALSE;\n\t}\n\n      offset = offset_from_vma (file, pltgot, global_end - pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset,\n                                         global_end - pltgot, 1,\n\t\t\t\t\t _(\"Global Offset Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n      data_end = data + (global_end - pltgot);\n\n      printf (_(\"\\nPrimary GOT:\\n\"));\n      printf (_(\" Canonical gp value: \"));\n      print_vma (pltgot + 0x7ff0, LONG_HEX);\n      printf (\"\\n\\n\");\n\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %10s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t      addr_size * 2, _(\"Initial\"));\n      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n      printf (_(\" Lazy resolver\\n\"));\n      if (ent == (bfd_vma) -1)\n\tgoto got_print_fail;\n\n      if (data)\n\t{\n\t  /* PR 21344 */\n\t  if (data + ent - pltgot > data_end - addr_size)\n\t    {\n\t      error (_(\"Invalid got entry - %#lx - overflows GOT table\\n\"),\n\t\t     (long) ent);\n\t      goto got_print_fail;\n\t    }\n\t  \n\t  if (byte_get (data + ent - pltgot, addr_size)\n\t      >> (addr_size * 8 - 1) != 0)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (_(\" Module pointer (GNU extension)\\n\"));\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t}\n      printf (\"\\n\");\n\n      if (ent < local_end)\n\t{\n\t  printf (_(\" Local entries:\\n\"));\n\t  printf (\"  %*s %10s %*s\\n\",\n\t\t  addr_size * 2, _(\"Address\"), _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"));\n\t  while (ent < local_end)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tgoto got_print_fail;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n      if (gotsym < symtabno)\n\t{\n\t  int sym_width;\n\n\t  printf (_(\" Global entries:\\n\"));\n\t  printf (\"  %*s %10s %*s %*s %-7s %3s %s\\n\",\n\t\t  addr_size * 2, _(\"Address\"),\n\t\t  _(\"Access\"),\n\t\t  addr_size * 2, _(\"Initial\"),\n\t\t  addr_size * 2, _(\"Sym.Val.\"),\n\t\t  _(\"Type\"),\n\t\t  /* Note for translators: \"Ndx\" = abbreviated form of \"Index\".  */\n\t\t  _(\"Ndx\"), _(\"Name\"));\n\n\t  sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;\n\n\t  for (i = gotsym; i < symtabno; i++)\n\t    {\n\t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n\t      printf (\" \");\n\n\t      if (dynamic_symbols == NULL)\n\t\tprintf (_(\"<no dynamic symbols>\"));\n\t      else if (i < num_dynamic_syms)\n\t\t{\n\t\t  Elf_Internal_Sym * psym = dynamic_symbols + i;\n\n\t\t  print_vma (psym->st_value, LONG_HEX);\n\t\t  printf (\" %-7s %3s \",\n\t\t\t  get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t\t  get_symbol_index_type (psym->st_shndx));\n\n\t\t  if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\t    print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t\t  else\n\t\t    printf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t\t}\n\t      else\n\t\tprintf (_(\"<symbol index %lu exceeds number of dynamic symbols>\"),\n\t\t\t(unsigned long) i);\n\n\t      printf (\"\\n\");\n\t      if (ent == (bfd_vma) -1)\n\t\tbreak;\n\t    }\n\t  printf (\"\\n\");\n\t}\n\n    got_print_fail:\n      if (data)\n\tfree (data);\n    }\n\n  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)\n    {\n      bfd_vma ent, end;\n      size_t offset, rel_offset;\n      unsigned long count, i;\n      unsigned char * data;\n      int addr_size, sym_width;\n      Elf_Internal_Rela * rels;\n\n      rel_offset = offset_from_vma (file, jmprel, pltrelsz);\n      if (pltrel == DT_RELA)\n\t{\n\t  if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n      else\n\t{\n\t  if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count))\n\t    return FALSE;\n\t}\n\n      ent = mips_pltgot;\n      addr_size = (is_32bit_elf ? 4 : 8);\n      end = mips_pltgot + (2 + count) * addr_size;\n\n      offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot);\n      data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot,\n                                         1, _(\"Procedure Linkage Table data\"));\n      if (data == NULL)\n\treturn FALSE;\n\n      printf (\"\\nPLT GOT:\\n\\n\");\n      printf (_(\" Reserved entries:\\n\"));\n      printf (_(\"  %*s %*s Purpose\\n\"),\n\t      addr_size * 2, _(\"Address\"), addr_size * 2, _(\"Initial\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" PLT lazy resolver\\n\"));\n      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n      printf (_(\" Module pointer\\n\"));\n      printf (\"\\n\");\n\n      printf (_(\" Entries:\\n\"));\n      printf (\"  %*s %*s %*s %-7s %3s %s\\n\",\n\t      addr_size * 2, _(\"Address\"),\n\t      addr_size * 2, _(\"Initial\"),\n\t      addr_size * 2, _(\"Sym.Val.\"), _(\"Type\"), _(\"Ndx\"), _(\"Name\"));\n      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;\n      for (i = 0; i < count; i++)\n\t{\n\t  unsigned long idx = get_reloc_symindex (rels[i].r_info);\n\n\t  ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n\t  printf (\" \");\n\n\t  if (idx >= num_dynamic_syms)\n\t    printf (_(\"<corrupt symbol index: %lu>\"), idx);\n\t  else\n\t    {\n\t      Elf_Internal_Sym * psym = dynamic_symbols + idx;\n\n\t      print_vma (psym->st_value, LONG_HEX);\n\t      printf (\" %-7s %3s \",\n\t\t      get_symbol_type (ELF_ST_TYPE (psym->st_info)),\n\t\t      get_symbol_index_type (psym->st_shndx));\n\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n\t\tprint_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n\t      else\n\t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n\t    }\n\t  printf (\"\\n\");\n\t}\n      printf (\"\\n\");\n\n      if (data)\n\tfree (data);\n      free (rels);\n    }\n\n  return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -568,7 +568,8 @@\n \t  /* PR 21344 */\n \t  if (data + ent - pltgot > data_end - addr_size)\n \t    {\n-\t      error (_(\"Invalid got entry - %#lx - overflows GOT table\\n\"), ent);\n+\t      error (_(\"Invalid got entry - %#lx - overflows GOT table\\n\"),\n+\t\t     (long) ent);\n \t      goto got_print_fail;\n \t    }\n \t  ",
        "diff_line_info": {
            "deleted_lines": [
                "\t      error (_(\"Invalid got entry - %#lx - overflows GOT table\\n\"), ent);"
            ],
            "added_lines": [
                "\t      error (_(\"Invalid got entry - %#lx - overflows GOT table\\n\"),",
                "\t\t     (long) ent);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9039",
        "func_name": "binutils-gdb/get_program_headers",
        "description": "GNU Binutils 2.28 allows remote attackers to cause a denial of service (memory consumption) via a crafted ELF file with many program headers, related to the get_program_headers function in readelf.c.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=82156ab704b08b124d319c0decdbd48b3ca2dac5",
        "commit_title": "",
        "commit_text": "readelf: Fix overlarge memory allocation when reading a binary with an excessive number of program headers.  \tPR binutils/21345 \t* readelf.c (get_program_headers): Check for there being too many \tprogram headers before attempting to allocate space for them. ",
        "func_before": "static bfd_boolean\nget_program_headers (FILE * file)\n{\n  Elf_Internal_Phdr * phdrs;\n\n  /* Check cache of prior read.  */\n  if (program_headers != NULL)\n    return TRUE;\n\n  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,\n                                         sizeof (Elf_Internal_Phdr));\n\n  if (phdrs == NULL)\n    {\n      error (_(\"Out of memory reading %u program headers\\n\"),\n\t     elf_header.e_phnum);\n      return FALSE;\n    }\n\n  if (is_32bit_elf\n      ? get_32bit_program_headers (file, phdrs)\n      : get_64bit_program_headers (file, phdrs))\n    {\n      program_headers = phdrs;\n      return TRUE;\n    }\n\n  free (phdrs);\n  return FALSE;\n}",
        "func": "static bfd_boolean\nget_program_headers (FILE * file)\n{\n  Elf_Internal_Phdr * phdrs;\n\n  /* Check cache of prior read.  */\n  if (program_headers != NULL)\n    return TRUE;\n\n  /* Be kind to memory checkers by looking for\n     e_phnum values which we know must be invalid.  */\n  if (elf_header.e_phnum\n      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))\n      >= current_file_size)\n    {\n      error (_(\"Too many program headers - %#x - the file is not that big\\n\"),\n\t     elf_header.e_phnum);\n      return FALSE;\n    }\n\n  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,\n\t\t\t\t\t sizeof (Elf_Internal_Phdr));\n  if (phdrs == NULL)\n    {\n      error (_(\"Out of memory reading %u program headers\\n\"),\n\t     elf_header.e_phnum);\n      return FALSE;\n    }\n\n  if (is_32bit_elf\n      ? get_32bit_program_headers (file, phdrs)\n      : get_64bit_program_headers (file, phdrs))\n    {\n      program_headers = phdrs;\n      return TRUE;\n    }\n\n  free (phdrs);\n  return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,19 @@\n   if (program_headers != NULL)\n     return TRUE;\n \n+  /* Be kind to memory checkers by looking for\n+     e_phnum values which we know must be invalid.  */\n+  if (elf_header.e_phnum\n+      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))\n+      >= current_file_size)\n+    {\n+      error (_(\"Too many program headers - %#x - the file is not that big\\n\"),\n+\t     elf_header.e_phnum);\n+      return FALSE;\n+    }\n+\n   phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,\n-                                         sizeof (Elf_Internal_Phdr));\n-\n+\t\t\t\t\t sizeof (Elf_Internal_Phdr));\n   if (phdrs == NULL)\n     {\n       error (_(\"Out of memory reading %u program headers\\n\"),",
        "diff_line_info": {
            "deleted_lines": [
                "                                         sizeof (Elf_Internal_Phdr));",
                ""
            ],
            "added_lines": [
                "  /* Be kind to memory checkers by looking for",
                "     e_phnum values which we know must be invalid.  */",
                "  if (elf_header.e_phnum",
                "      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))",
                "      >= current_file_size)",
                "    {",
                "      error (_(\"Too many program headers - %#x - the file is not that big\\n\"),",
                "\t     elf_header.e_phnum);",
                "      return FALSE;",
                "    }",
                "",
                "\t\t\t\t\t sizeof (Elf_Internal_Phdr));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9350",
        "func_name": "wireshark/dissect_opensafety_ssdo_message",
        "description": "In Wireshark 2.2.0 to 2.2.6 and 2.0.0 to 2.0.12, the openSAFETY dissector could crash or exhaust system memory. This was addressed in epan/dissectors/packet-opensafety.c by checking for a negative length.",
        "git_url": "https://github.com/wireshark/wireshark/commit/dbc7cb0bbdd501fa96e0cb98668f6d6bf17ac4e6",
        "commit_title": "[OpenSafety] Bugfix invalid length calculation.",
        "commit_text": " Length calculation leads to -1, which will result in a large malloc  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1212 Bug: 13649 (cherry picked from commit f6431695049116176361ce4691dfd3c77ab19858)",
        "func_before": "static void\ndissect_opensafety_ssdo_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *opensafety_tree,\n        opensafety_packet_info * packet, proto_item * opensafety_item )\n{\n    proto_item    *item;\n    proto_tree    *ssdo_tree, *ssdo_payload;\n    guint16        taddr                = 0, sdn = 0, server = 0, client = 0, n = 0, ct = 0;\n    guint32        abortcode, ssdoIndex = 0, ssdoSubIndex = 0, payloadSize, fragmentId = 0, entry = 0;\n    guint8         db0Offset, db0, payloadOffset, preload;\n    guint          dataLength;\n    gint           calcDataLength;\n    gboolean       isResponse, saveFragmented;\n    tvbuff_t      *new_tvb              = NULL;\n    fragment_head *frag_msg             = NULL;\n\n    static const int * ssdo_sacmd_flags[] = {\n            &hf_oss_ssdo_sacmd_end_segment,\n            &hf_oss_ssdo_sacmd_initiate,\n            &hf_oss_ssdo_sacmd_toggle,\n            &hf_oss_ssdo_sacmd_segmentation,\n            &hf_oss_ssdo_sacmd_abort_transfer,\n            &hf_oss_ssdo_sacmd_preload,\n            &hf_oss_ssdo_sacmd_access_type,\n            NULL\n    };\n\n    dataLength = tvb_get_guint8(message_tvb, OSS_FRAME_POS_LEN + packet->frame.subframe1);\n\n    db0Offset = packet->frame.subframe1 + OSS_FRAME_POS_DATA;\n    db0 = tvb_get_guint8(message_tvb, db0Offset);\n    ssdoIndex = 0;\n    ssdoSubIndex = 0;\n\n    /* Response is determined by the openSAFETY message field */\n    isResponse = ( ( OSS_FRAME_ID_T(message_tvb, packet->frame.subframe1) & 0x04 ) == 0x04 );\n\n    if ( packet->scm_udid_valid )\n    {\n        /* taddr is the 4th octet in the second frame */\n        taddr = OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2 + 3, packet->scm_udid[3], packet->scm_udid[4]);\n        sdn =  ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ^\n                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) );\n\n        opensafety_packet_sendreceiv ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet, taddr,\n                packet->frame.subframe2 + 3, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),\n                packet->frame.subframe1, packet->frame.subframe2, sdn );\n    }\n    else if ( ! isResponse )\n    {\n        opensafety_packet_sender ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,\n                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,\n                packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^\n                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );\n    }\n    else if ( isResponse )\n    {\n        opensafety_packet_receiver ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,\n                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,\n                packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^\n                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );\n    }\n\n    ssdo_tree = opensafety_packet_payloadtree ( message_tvb, opensafety_tree, packet, ett_opensafety_ssdo );\n\n    opensafety_packet_response ( message_tvb, ssdo_tree, packet, isResponse );\n\n    packet->payload.ssdo->sacmd.toggle = ( db0 & OPENSAFETY_SSDO_SACMD_TGL ) == OPENSAFETY_SSDO_SACMD_TGL;\n    packet->payload.ssdo->sacmd.abort_transfer = ( db0 & OPENSAFETY_SSDO_SACMD_ABRT ) == OPENSAFETY_SSDO_SACMD_ABRT;\n    packet->payload.ssdo->sacmd.preload = ( db0 & OPENSAFETY_SSDO_SACMD_PRLD ) == OPENSAFETY_SSDO_SACMD_PRLD;\n    packet->payload.ssdo->sacmd.read_access = ( db0 & OPENSAFETY_SSDO_DOWNLOAD ) == OPENSAFETY_SSDO_DOWNLOAD;\n    packet->payload.ssdo->sacmd.initiate = ( db0 & OPENSAFETY_SSDO_SACMD_INI ) == OPENSAFETY_SSDO_SACMD_INI;\n    packet->payload.ssdo->sacmd.segmented = ( db0 & OPENSAFETY_SSDO_SACMD_SEG ) == OPENSAFETY_SSDO_SACMD_SEG;\n    packet->payload.ssdo->sacmd.end_segment = ( db0 & OPENSAFETY_SSDO_SACMD_ENSG ) == OPENSAFETY_SSDO_SACMD_ENSG;\n\n    if ( isResponse )\n    {\n        opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,\n                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),\n                packet->frame.subframe1, packet->frame.subframe2, sdn );\n        client = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);\n\n        if ( packet->scm_udid_valid )\n        {\n            proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe2 + 3, 2, taddr);\n            server = taddr;\n        }\n    }\n    else if ( ! isResponse )\n    {\n        proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe1, 2, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1));\n        server = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);\n        if ( packet->scm_udid_valid )\n        {\n            opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,\n                    taddr, packet->frame.subframe2 + 3, packet->frame.subframe2, sdn );\n            client = taddr;\n        }\n    }\n\n    /* Toggle bit must be removed, otherwise the values cannot be displayed correctly */\n    if ( packet->payload.ssdo->sacmd.toggle )\n        db0 &= (~OPENSAFETY_SSDO_SACMD_TGL);\n    proto_tree_add_bitmask(ssdo_tree, message_tvb, db0Offset, hf_oss_ssdo_sacmd,\n            ett_opensafety_ssdo_sacmd, ssdo_sacmd_flags, ENC_NA);\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \", SACMD: %s\", val_to_str_const(db0, opensafety_ssdo_sacmd_values, \" \"));\n\n    payloadOffset = db0Offset + 1;\n\n    ct = tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3);\n    if ( packet->scm_udid_valid )\n    {\n        ct = (guint16)((tvb_get_guint8(message_tvb, packet->frame.subframe2 + 2) ^ packet->scm_udid[2]) << 8);\n        ct += (tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3));\n    }\n\n    proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_sano, message_tvb, packet->frame.subframe1 + 3, 1, ct );\n\n    /* Evaluate preload field [field TR] */\n    if ( packet->scm_udid_valid && packet->payload.ssdo->sacmd.preload && isResponse )\n    {\n        /* Preload info are the higher 6 bit of the TR field */\n        preload = ( (tvb_get_guint8(message_tvb, packet->frame.subframe2 + 4) ^ packet->scm_udid[4]) & 0xFC ) >> 2;\n\n        if ( packet->payload.ssdo->sacmd.initiate )\n        {\n            /* Use the lower 4 bits from the preload as size */\n            proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_preload_queue, message_tvb, packet->frame.subframe2 + 4, 1,\n                    preload & 0x0F, \"%d\", preload & 0x0F );\n        }\n        else\n        {\n            /* The highest 2 bits of information contain an error flag */\n            item = proto_tree_add_item(ssdo_tree, hf_oss_ssdo_preload_error, message_tvb, packet->frame.subframe2 + 4, 1, ENC_NA );\n            if ( (preload & 0x30) == 0x30 )\n                proto_item_append_text(item, \" (SOD Access Request Number is last successful)\" );\n        }\n    }\n\n    /* When the following clause is met, DB1,2 contain the SOD index, and DB3 the SOD subindex */\n    if ( packet->payload.ssdo->sacmd.initiate && !packet->payload.ssdo->sacmd.abort_transfer )\n    {\n        ssdoIndex = tvb_get_letohs(message_tvb, db0Offset + 1);\n        ssdoSubIndex = tvb_get_guint8(message_tvb, db0Offset + 3);\n\n        proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_index, message_tvb, db0Offset + 1, 2,\n                ssdoIndex, \"0x%04X (%s)\", ssdoIndex,\n                val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, \"Unknown\") );\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s\", val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, \"Unknown\"));\n\n        /* Some SOD downloads (0x101A for instance) don't have sub-indeces */\n        if ( ssdoSubIndex != 0x0 )\n        {\n            proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_subindex, message_tvb, db0Offset + 3, 1,\n                ssdoSubIndex, \"0x%02X (%s)\", ssdoSubIndex,\n                val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, \"Unknown\") );\n            col_append_fstr(pinfo->cinfo, COL_INFO, \" - %s\",\n                    val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, \"Unknown\"));\n        }\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"%s\", \"]\" );\n        payloadOffset += 3;\n    }\n\n    if ( packet->payload.ssdo->sacmd.abort_transfer )\n    {\n        abortcode = tvb_get_letohl(message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4);\n\n        proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_abort_code, message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4, 4, abortcode,\n                \"0x%04X %04X - %s\", (guint16)(abortcode >> 16), (guint16)(abortcode),\n                val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, \"Unknown\"));\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" - %s\", val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, \"Unknown\"));\n\n\n    } else {\n        /* Either the SSDO msg is a response, then data is sent by the server and only in uploads,\n         * or the message is a request, then data is coming from the client and payload data is\n         * sent in downloads. Data is only sent in initiate, segmented or end-segment messages */\n        if ( ( packet->payload.ssdo->sacmd.initiate || packet->payload.ssdo->sacmd.segmented || packet->payload.ssdo->sacmd.end_segment ) &&\n             ( ( isResponse && !packet->payload.ssdo->sacmd.read_access ) ||\n                     ( !isResponse && packet->payload.ssdo->sacmd.read_access ) ) )\n        {\n            saveFragmented = pinfo->fragmented;\n            if ( server != 0 && client != 0 )\n                fragmentId = (guint32)((((guint32)client) << 16 ) + server );\n\n            /* If payload data has to be calculated, either a total size is given, or not */\n            if ( packet->payload.ssdo->sacmd.segmented && packet->payload.ssdo->sacmd.initiate )\n            {\n\n                payloadOffset += 4;\n\n                /* reading real size */\n                payloadSize = tvb_get_letohl(message_tvb, payloadOffset - 4);\n\n                calcDataLength = dataLength - (payloadOffset - db0Offset);\n\n                item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, payloadOffset - 4, 4,\n                        payloadSize, \"%d octets total (%d octets in this frame)\", payloadSize, calcDataLength);\n\n                if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )\n                {\n                    pinfo->fragmented = TRUE;\n                    frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,\n                                                      fragmentId, NULL, 0, calcDataLength, TRUE );\n                    fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );\n\n                    if ( frag_msg != NULL )\n                    {\n                        item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, \"Reassembled\" );\n                        PROTO_ITEM_SET_GENERATED(item);\n\n                        ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);\n                        process_reassembled_data(message_tvb, 0, pinfo, \"Reassembled Message\", frag_msg, &oss_frag_items, NULL, ssdo_payload );\n                    }\n                }\n\n                if ( (gint) calcDataLength >= (gint) 0 )\n                {\n                    proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, calcDataLength, ENC_NA );\n                } else {\n                    expert_add_info_format(pinfo, item, &ei_payload_length_not_positive,\n                                                \"Calculation for payload length yielded non-positive result [%d]\", (guint) calcDataLength );\n                }\n            }\n            else\n            {\n                payloadSize = dataLength - (payloadOffset - db0Offset);\n\n                if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )\n                {\n                    pinfo->fragmented = TRUE;\n\n                    frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,\n                                                      fragmentId, NULL, ct, payloadSize,\n                                                      packet->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );\n                }\n\n                if ( frag_msg )\n                {\n                    item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb,\n                                                             0, 0, NULL, \"Reassembled\" );\n                    PROTO_ITEM_SET_GENERATED(item);\n                    ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);\n\n                    new_tvb = process_reassembled_data(message_tvb, 0, pinfo, \"Reassembled Message\", frag_msg,\n                                                       &oss_frag_items, NULL, ssdo_payload );\n                    if ( packet->payload.ssdo->sacmd.end_segment && new_tvb )\n                    {\n                        item = proto_tree_add_uint_format_value(ssdo_payload, hf_oss_ssdo_payload_size, message_tvb, 0, 0,\n                                                                payloadSize, \"%d octets (over all fragments)\", frag_msg->len);\n                        PROTO_ITEM_SET_GENERATED(item);\n\n                        col_append_str(pinfo->cinfo, COL_INFO, \" (Message Reassembled)\" );\n                        dissect_opensafety_ssdo_payload ( pinfo, new_tvb, ssdo_payload, db0 );\n                    }\n                }\n                else\n                {\n                    item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, 0, 0, payloadSize,\n                            \"%d octets\", payloadSize);\n                    PROTO_ITEM_SET_GENERATED(item);\n\n                    if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x06 )\n                    {\n                        entry = tvb_get_letohl ( message_tvb, payloadOffset );\n                        proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,\n                                    4, entry, \"0x%08X\", entry );\n                        for ( n = 4; n < payloadSize; n+=4 )\n                        {\n                            entry = tvb_get_letohl ( message_tvb, payloadOffset + n );\n                            proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_checksum, message_tvb, (payloadOffset + n ),\n                                    4, entry, \"[#%d] 0x%08X\", ( n / 4 ), entry );\n                        }\n                    } else if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x07 ) {\n                        entry = tvb_get_letohl ( message_tvb, payloadOffset );\n                        proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,\n                                    4, entry, \"0x%08X\", entry );\n                    } else\n                        proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, payloadSize, ENC_NA );\n                }\n            }\n\n            pinfo->fragmented = saveFragmented;\n        }\n    }\n}",
        "func": "static void\ndissect_opensafety_ssdo_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *opensafety_tree,\n        opensafety_packet_info * packet, proto_item * opensafety_item )\n{\n    proto_item    *item;\n    proto_tree    *ssdo_tree, *ssdo_payload;\n    guint16        taddr                = 0, sdn = 0, server = 0, client = 0, n = 0, ct = 0;\n    guint32        abortcode, ssdoIndex = 0, ssdoSubIndex = 0, payloadSize, fragmentId = 0, entry = 0;\n    guint8         db0Offset, db0, payloadOffset, preload;\n    guint          dataLength;\n    gint           calcDataLength;\n    gboolean       isResponse, saveFragmented;\n    tvbuff_t      *new_tvb              = NULL;\n    fragment_head *frag_msg             = NULL;\n\n    static const int * ssdo_sacmd_flags[] = {\n            &hf_oss_ssdo_sacmd_end_segment,\n            &hf_oss_ssdo_sacmd_initiate,\n            &hf_oss_ssdo_sacmd_toggle,\n            &hf_oss_ssdo_sacmd_segmentation,\n            &hf_oss_ssdo_sacmd_abort_transfer,\n            &hf_oss_ssdo_sacmd_preload,\n            &hf_oss_ssdo_sacmd_access_type,\n            NULL\n    };\n\n    dataLength = tvb_get_guint8(message_tvb, OSS_FRAME_POS_LEN + packet->frame.subframe1);\n\n    db0Offset = packet->frame.subframe1 + OSS_FRAME_POS_DATA;\n    db0 = tvb_get_guint8(message_tvb, db0Offset);\n    ssdoIndex = 0;\n    ssdoSubIndex = 0;\n\n    /* Response is determined by the openSAFETY message field */\n    isResponse = ( ( OSS_FRAME_ID_T(message_tvb, packet->frame.subframe1) & 0x04 ) == 0x04 );\n\n    if ( packet->scm_udid_valid )\n    {\n        /* taddr is the 4th octet in the second frame */\n        taddr = OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2 + 3, packet->scm_udid[3], packet->scm_udid[4]);\n        sdn =  ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ^\n                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) );\n\n        opensafety_packet_sendreceiv ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet, taddr,\n                packet->frame.subframe2 + 3, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),\n                packet->frame.subframe1, packet->frame.subframe2, sdn );\n    }\n    else if ( ! isResponse )\n    {\n        opensafety_packet_sender ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,\n                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,\n                packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^\n                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );\n    }\n    else if ( isResponse )\n    {\n        opensafety_packet_receiver ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,\n                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,\n                packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^\n                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );\n    }\n\n    ssdo_tree = opensafety_packet_payloadtree ( message_tvb, opensafety_tree, packet, ett_opensafety_ssdo );\n\n    opensafety_packet_response ( message_tvb, ssdo_tree, packet, isResponse );\n\n    packet->payload.ssdo->sacmd.toggle = ( db0 & OPENSAFETY_SSDO_SACMD_TGL ) == OPENSAFETY_SSDO_SACMD_TGL;\n    packet->payload.ssdo->sacmd.abort_transfer = ( db0 & OPENSAFETY_SSDO_SACMD_ABRT ) == OPENSAFETY_SSDO_SACMD_ABRT;\n    packet->payload.ssdo->sacmd.preload = ( db0 & OPENSAFETY_SSDO_SACMD_PRLD ) == OPENSAFETY_SSDO_SACMD_PRLD;\n    packet->payload.ssdo->sacmd.read_access = ( db0 & OPENSAFETY_SSDO_DOWNLOAD ) == OPENSAFETY_SSDO_DOWNLOAD;\n    packet->payload.ssdo->sacmd.initiate = ( db0 & OPENSAFETY_SSDO_SACMD_INI ) == OPENSAFETY_SSDO_SACMD_INI;\n    packet->payload.ssdo->sacmd.segmented = ( db0 & OPENSAFETY_SSDO_SACMD_SEG ) == OPENSAFETY_SSDO_SACMD_SEG;\n    packet->payload.ssdo->sacmd.end_segment = ( db0 & OPENSAFETY_SSDO_SACMD_ENSG ) == OPENSAFETY_SSDO_SACMD_ENSG;\n\n    if ( isResponse )\n    {\n        opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,\n                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),\n                packet->frame.subframe1, packet->frame.subframe2, sdn );\n        client = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);\n\n        if ( packet->scm_udid_valid )\n        {\n            proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe2 + 3, 2, taddr);\n            server = taddr;\n        }\n    }\n    else if ( ! isResponse )\n    {\n        proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe1, 2, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1));\n        server = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);\n        if ( packet->scm_udid_valid )\n        {\n            opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,\n                    taddr, packet->frame.subframe2 + 3, packet->frame.subframe2, sdn );\n            client = taddr;\n        }\n    }\n\n    /* Toggle bit must be removed, otherwise the values cannot be displayed correctly */\n    if ( packet->payload.ssdo->sacmd.toggle )\n        db0 &= (~OPENSAFETY_SSDO_SACMD_TGL);\n    proto_tree_add_bitmask(ssdo_tree, message_tvb, db0Offset, hf_oss_ssdo_sacmd,\n            ett_opensafety_ssdo_sacmd, ssdo_sacmd_flags, ENC_NA);\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \", SACMD: %s\", val_to_str_const(db0, opensafety_ssdo_sacmd_values, \" \"));\n\n    payloadOffset = db0Offset + 1;\n\n    ct = tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3);\n    if ( packet->scm_udid_valid )\n    {\n        ct = (guint16)((tvb_get_guint8(message_tvb, packet->frame.subframe2 + 2) ^ packet->scm_udid[2]) << 8);\n        ct += (tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3));\n    }\n\n    proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_sano, message_tvb, packet->frame.subframe1 + 3, 1, ct );\n\n    /* Evaluate preload field [field TR] */\n    if ( packet->scm_udid_valid && packet->payload.ssdo->sacmd.preload && isResponse )\n    {\n        /* Preload info are the higher 6 bit of the TR field */\n        preload = ( (tvb_get_guint8(message_tvb, packet->frame.subframe2 + 4) ^ packet->scm_udid[4]) & 0xFC ) >> 2;\n\n        if ( packet->payload.ssdo->sacmd.initiate )\n        {\n            /* Use the lower 4 bits from the preload as size */\n            proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_preload_queue, message_tvb, packet->frame.subframe2 + 4, 1,\n                    preload & 0x0F, \"%d\", preload & 0x0F );\n        }\n        else\n        {\n            /* The highest 2 bits of information contain an error flag */\n            item = proto_tree_add_item(ssdo_tree, hf_oss_ssdo_preload_error, message_tvb, packet->frame.subframe2 + 4, 1, ENC_NA );\n            if ( (preload & 0x30) == 0x30 )\n                proto_item_append_text(item, \" (SOD Access Request Number is last successful)\" );\n        }\n    }\n\n    /* When the following clause is met, DB1,2 contain the SOD index, and DB3 the SOD subindex */\n    if ( packet->payload.ssdo->sacmd.initiate && !packet->payload.ssdo->sacmd.abort_transfer )\n    {\n        ssdoIndex = tvb_get_letohs(message_tvb, db0Offset + 1);\n        ssdoSubIndex = tvb_get_guint8(message_tvb, db0Offset + 3);\n\n        proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_index, message_tvb, db0Offset + 1, 2,\n                ssdoIndex, \"0x%04X (%s)\", ssdoIndex,\n                val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, \"Unknown\") );\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" [%s\", val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, \"Unknown\"));\n\n        /* Some SOD downloads (0x101A for instance) don't have sub-indeces */\n        if ( ssdoSubIndex != 0x0 )\n        {\n            proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_subindex, message_tvb, db0Offset + 3, 1,\n                ssdoSubIndex, \"0x%02X (%s)\", ssdoSubIndex,\n                val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, \"Unknown\") );\n            col_append_fstr(pinfo->cinfo, COL_INFO, \" - %s\",\n                    val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, \"Unknown\"));\n        }\n        col_append_fstr(pinfo->cinfo, COL_INFO, \"%s\", \"]\" );\n        payloadOffset += 3;\n    }\n\n    if ( packet->payload.ssdo->sacmd.abort_transfer )\n    {\n        abortcode = tvb_get_letohl(message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4);\n\n        proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_abort_code, message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4, 4, abortcode,\n                \"0x%04X %04X - %s\", (guint16)(abortcode >> 16), (guint16)(abortcode),\n                val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, \"Unknown\"));\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" - %s\", val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, \"Unknown\"));\n\n\n    } else {\n        /* Either the SSDO msg is a response, then data is sent by the server and only in uploads,\n         * or the message is a request, then data is coming from the client and payload data is\n         * sent in downloads. Data is only sent in initiate, segmented or end-segment messages */\n        if ( ( packet->payload.ssdo->sacmd.initiate || packet->payload.ssdo->sacmd.segmented || packet->payload.ssdo->sacmd.end_segment ) &&\n             ( ( isResponse && !packet->payload.ssdo->sacmd.read_access ) ||\n                     ( !isResponse && packet->payload.ssdo->sacmd.read_access ) ) )\n        {\n            saveFragmented = pinfo->fragmented;\n            if ( server != 0 && client != 0 )\n                fragmentId = (guint32)((((guint32)client) << 16 ) + server );\n\n            /* If payload data has to be calculated, either a total size is given, or not */\n            if ( packet->payload.ssdo->sacmd.segmented && packet->payload.ssdo->sacmd.initiate )\n            {\n\n                payloadOffset += 4;\n\n                /* reading real size */\n                payloadSize = tvb_get_letohl(message_tvb, payloadOffset - 4);\n\n                calcDataLength = dataLength - (payloadOffset - db0Offset);\n\n                item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, payloadOffset - 4, 4,\n                        payloadSize, \"%d octets total (%d octets in this frame)\", payloadSize, calcDataLength);\n\n                if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )\n                {\n                    pinfo->fragmented = TRUE;\n                    frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,\n                                                      fragmentId, NULL, 0, calcDataLength, TRUE );\n                    fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );\n\n                    if ( frag_msg != NULL )\n                    {\n                        item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, \"Reassembled\" );\n                        PROTO_ITEM_SET_GENERATED(item);\n\n                        ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);\n                        process_reassembled_data(message_tvb, 0, pinfo, \"Reassembled Message\", frag_msg, &oss_frag_items, NULL, ssdo_payload );\n                    }\n                }\n\n                if ( (gint) calcDataLength >= (gint) 0 )\n                {\n                    proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, calcDataLength, ENC_NA );\n                } else {\n                    expert_add_info_format(pinfo, item, &ei_payload_length_not_positive,\n                                                \"Calculation for payload length yielded non-positive result [%d]\", (guint) calcDataLength );\n                }\n            }\n            else\n            {\n                payloadSize = dataLength - (payloadOffset - db0Offset);\n                if ((gint)dataLength < (payloadOffset - db0Offset))\n                {\n                    expert_add_info_format(pinfo, opensafety_item, &ei_payload_length_not_positive,\n                                                    \"Calculation for payload length yielded non-positive result [%d]\", (gint)payloadSize );\n                    return;\n                }\n\n                if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )\n                {\n                    pinfo->fragmented = TRUE;\n\n                    frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,\n                                                      fragmentId, NULL, ct, payloadSize,\n                                                      packet->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );\n                }\n\n                if ( frag_msg )\n                {\n                    item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb,\n                                                             0, 0, NULL, \"Reassembled\" );\n                    PROTO_ITEM_SET_GENERATED(item);\n                    ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);\n\n                    new_tvb = process_reassembled_data(message_tvb, 0, pinfo, \"Reassembled Message\", frag_msg,\n                                                       &oss_frag_items, NULL, ssdo_payload );\n                    if ( packet->payload.ssdo->sacmd.end_segment && new_tvb )\n                    {\n                        item = proto_tree_add_uint_format_value(ssdo_payload, hf_oss_ssdo_payload_size, message_tvb, 0, 0,\n                                                                payloadSize, \"%d octets (over all fragments)\", frag_msg->len);\n                        PROTO_ITEM_SET_GENERATED(item);\n\n                        col_append_str(pinfo->cinfo, COL_INFO, \" (Message Reassembled)\" );\n                        dissect_opensafety_ssdo_payload ( pinfo, new_tvb, ssdo_payload, db0 );\n                    }\n                }\n                else\n                {\n                    item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, 0, 0, payloadSize,\n                            \"%d octets\", payloadSize);\n                    PROTO_ITEM_SET_GENERATED(item);\n\n                    if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x06 )\n                    {\n                        entry = tvb_get_letohl ( message_tvb, payloadOffset );\n                        proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,\n                                    4, entry, \"0x%08X\", entry );\n                        for ( n = 4; n < payloadSize; n+=4 )\n                        {\n                            entry = tvb_get_letohl ( message_tvb, payloadOffset + n );\n                            proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_checksum, message_tvb, (payloadOffset + n ),\n                                    4, entry, \"[#%d] 0x%08X\", ( n / 4 ), entry );\n                        }\n                    } else if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x07 ) {\n                        entry = tvb_get_letohl ( message_tvb, payloadOffset );\n                        proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,\n                                    4, entry, \"0x%08X\", entry );\n                    } else\n                        proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, payloadSize, ENC_NA );\n                }\n            }\n\n            pinfo->fragmented = saveFragmented;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -225,6 +225,12 @@\n             else\n             {\n                 payloadSize = dataLength - (payloadOffset - db0Offset);\n+                if ((gint)dataLength < (payloadOffset - db0Offset))\n+                {\n+                    expert_add_info_format(pinfo, opensafety_item, &ei_payload_length_not_positive,\n+                                                    \"Calculation for payload length yielded non-positive result [%d]\", (gint)payloadSize );\n+                    return;\n+                }\n \n                 if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )\n                 {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                if ((gint)dataLength < (payloadOffset - db0Offset))",
                "                {",
                "                    expert_add_info_format(pinfo, opensafety_item, &ei_payload_length_not_positive,",
                "                                                    \"Calculation for payload length yielded non-positive result [%d]\", (gint)payloadSize );",
                "                    return;",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3553",
        "func_name": "facebook/fbthrift/CompactProtocolReader::readStringBody",
        "description": "C++ Facebook Thrift servers would not error upon receiving messages declaring containers of sizes larger than the payload. As a result, malicious clients could send short messages which would result in a large memory allocation, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2020.02.03.00.",
        "git_url": "https://github.com/facebook/fbthrift/commit/c9a903e5902834e95bbd4ab0e9fa53ba0189f351",
        "commit_title": "Better handling of truncated data when reading strings",
        "commit_text": " Summary: Currently we read string size and blindly pre-allocate it. This allows malicious attacker to send a few bytes message and cause server to allocate huge amount of memory (>1GB).  This diff changes the logic to check if we have enough data in the buffer before allocating the string.  This is a second part of a fix for CVE-2019-3553.  Reviewed By: vitaut  Differential Revision: D14393393  fbshipit-source-id: e2046d2f5b087d3abc9a9d2c6c107cf088673057",
        "func_before": "void CompactProtocolReader::readStringBody(StrType& str, int32_t size) {\n  if (static_cast<int32_t>(in_.length()) < size) {\n    str.reserve(size); // only reserve for multi iter case below\n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}",
        "func": "void CompactProtocolReader::readStringBody(StrType& str, int32_t size) {\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); // only reserve for multi iter case below\n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n void CompactProtocolReader::readStringBody(StrType& str, int32_t size) {\n   if (static_cast<int32_t>(in_.length()) < size) {\n+    if (!in_.canAdvance(size)) {\n+      protocol::TProtocolException::throwTruncatedData();\n+    }\n     str.reserve(size); // only reserve for multi iter case below\n   }\n   str.clear();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!in_.canAdvance(size)) {",
                "      protocol::TProtocolException::throwTruncatedData();",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3553",
        "func_name": "facebook/fbthrift/BinaryProtocolReader::readStringBody",
        "description": "C++ Facebook Thrift servers would not error upon receiving messages declaring containers of sizes larger than the payload. As a result, malicious clients could send short messages which would result in a large memory allocation, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2020.02.03.00.",
        "git_url": "https://github.com/facebook/fbthrift/commit/c9a903e5902834e95bbd4ab0e9fa53ba0189f351",
        "commit_title": "Better handling of truncated data when reading strings",
        "commit_text": " Summary: Currently we read string size and blindly pre-allocate it. This allows malicious attacker to send a few bytes message and cause server to allocate huge amount of memory (>1GB).  This diff changes the logic to check if we have enough data in the buffer before allocating the string.  This is a second part of a fix for CVE-2019-3553.  Reviewed By: vitaut  Differential Revision: D14393393  fbshipit-source-id: e2046d2f5b087d3abc9a9d2c6c107cf088673057",
        "func_before": "void BinaryProtocolReader::readStringBody(StrType& str, int32_t size) {\n  checkStringSize(size);\n\n  // Catch empty string case\n  if (size == 0) {\n    str.clear();\n    return;\n  }\n\n  if (static_cast<int32_t>(in_.length()) < size) {\n    str.reserve(size); // only reserve for multi iter case below\n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}",
        "func": "void BinaryProtocolReader::readStringBody(StrType& str, int32_t size) {\n  checkStringSize(size);\n\n  // Catch empty string case\n  if (size == 0) {\n    str.clear();\n    return;\n  }\n\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); // only reserve for multi iter case below\n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,9 @@\n   }\n \n   if (static_cast<int32_t>(in_.length()) < size) {\n+    if (!in_.canAdvance(size)) {\n+      protocol::TProtocolException::throwTruncatedData();\n+    }\n     str.reserve(size); // only reserve for multi iter case below\n   }\n   str.clear();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!in_.canAdvance(size)) {",
                "      protocol::TProtocolException::throwTruncatedData();",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20095",
        "func_name": "axiomatic-systems/Bento4/AP4_ElstAtom::AP4_ElstAtom",
        "description": "An issue was discovered in EnsureCapacity in Core/Ap4Array.h in Bento4 1.5.1-627. Crafted MP4 input triggers an attempt at excessive memory allocation, as demonstrated by mp42hls.",
        "git_url": "https://github.com/axiomatic-systems/Bento4/commit/8922f0dcc30b56936e2b12e819e52b86e3300bfa",
        "commit_title": "fix #341",
        "commit_text": "",
        "func_before": "AP4_ElstAtom::AP4_ElstAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_ELST, size, version, flags)\n{\n    AP4_UI32 entry_count;\n    stream.ReadUI32(entry_count);\n    m_Entries.EnsureCapacity(entry_count);\n    for (AP4_UI32 i=0; i<entry_count; i++) {\n        AP4_UI16 media_rate;\n        AP4_UI16 zero;\n        if (version == 0) {\n            AP4_UI32 segment_duration;\n            AP4_UI32 media_time;\n            stream.ReadUI32(segment_duration);\n            stream.ReadUI32(media_time);\n            stream.ReadUI16(media_rate);\n            stream.ReadUI16(zero);\n            m_Entries.Append(AP4_ElstEntry(segment_duration, (AP4_SI32)media_time, media_rate));\n        } else {\n            AP4_UI64 segment_duration;\n            AP4_UI64 media_time;\n            stream.ReadUI64(segment_duration);\n            stream.ReadUI64(media_time);\n            stream.ReadUI16(media_rate);\n            stream.ReadUI16(zero);\n            m_Entries.Append(AP4_ElstEntry(segment_duration, (AP4_SI64)media_time, media_rate));\n        }\n    }\n}",
        "func": "AP4_ElstAtom::AP4_ElstAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_ELST, size, version, flags)\n{\n    // read the number of entries\n    AP4_UI32 entry_count;\n    stream.ReadUI32(entry_count);\n\n    // compute bounds\n    AP4_UI32 max_entries;\n    if (version == 0) {\n        max_entries = (size - (AP4_FULL_ATOM_HEADER_SIZE + 4)) / 12;\n    } else {\n        max_entries = (size - (AP4_FULL_ATOM_HEADER_SIZE + 4)) / 20;\n    }\n    //if (entry_count > max_entries) {\n    //    entry_count = max_entries;\n    //}\n    \n    // read the entries\n    m_Entries.EnsureCapacity(entry_count);\n    for (AP4_UI32 i=0; i < entry_count; i++) {\n        AP4_UI16 media_rate;\n        AP4_UI16 zero;\n        if (version == 0) {\n            AP4_UI32 segment_duration;\n            AP4_UI32 media_time;\n            stream.ReadUI32(segment_duration);\n            stream.ReadUI32(media_time);\n            stream.ReadUI16(media_rate);\n            stream.ReadUI16(zero);\n            m_Entries.Append(AP4_ElstEntry(segment_duration, (AP4_SI32)media_time, media_rate));\n        } else {\n            AP4_UI64 segment_duration;\n            AP4_UI64 media_time;\n            stream.ReadUI64(segment_duration);\n            stream.ReadUI64(media_time);\n            stream.ReadUI16(media_rate);\n            stream.ReadUI16(zero);\n            m_Entries.Append(AP4_ElstEntry(segment_duration, (AP4_SI64)media_time, media_rate));\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,10 +4,24 @@\n                            AP4_ByteStream& stream) :\n     AP4_Atom(AP4_ATOM_TYPE_ELST, size, version, flags)\n {\n+    // read the number of entries\n     AP4_UI32 entry_count;\n     stream.ReadUI32(entry_count);\n+\n+    // compute bounds\n+    AP4_UI32 max_entries;\n+    if (version == 0) {\n+        max_entries = (size - (AP4_FULL_ATOM_HEADER_SIZE + 4)) / 12;\n+    } else {\n+        max_entries = (size - (AP4_FULL_ATOM_HEADER_SIZE + 4)) / 20;\n+    }\n+    //if (entry_count > max_entries) {\n+    //    entry_count = max_entries;\n+    //}\n+    \n+    // read the entries\n     m_Entries.EnsureCapacity(entry_count);\n-    for (AP4_UI32 i=0; i<entry_count; i++) {\n+    for (AP4_UI32 i=0; i < entry_count; i++) {\n         AP4_UI16 media_rate;\n         AP4_UI16 zero;\n         if (version == 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "    for (AP4_UI32 i=0; i<entry_count; i++) {"
            ],
            "added_lines": [
                "    // read the number of entries",
                "",
                "    // compute bounds",
                "    AP4_UI32 max_entries;",
                "    if (version == 0) {",
                "        max_entries = (size - (AP4_FULL_ATOM_HEADER_SIZE + 4)) / 12;",
                "    } else {",
                "        max_entries = (size - (AP4_FULL_ATOM_HEADER_SIZE + 4)) / 20;",
                "    }",
                "    //if (entry_count > max_entries) {",
                "    //    entry_count = max_entries;",
                "    //}",
                "    ",
                "    // read the entries",
                "    for (AP4_UI32 i=0; i < entry_count; i++) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20186",
        "func_name": "axiomatic-systems/Bento4/AP4_Sample::ReadData",
        "description": "An issue was discovered in Bento4 1.5.1-627. AP4_Sample::ReadData in Core/Ap4Sample.cpp allows attackers to trigger an attempted excessive memory allocation, related to AP4_DataBuffer::SetDataSize and AP4_DataBuffer::ReallocateBuffer in Core/Ap4DataBuffer.cpp.",
        "git_url": "https://github.com/axiomatic-systems/Bento4/commit/f7ba0dca622837bfab063e500f6013640e8e76e4",
        "commit_title": "fix #342",
        "commit_text": "",
        "func_before": "AP4_Result\nAP4_Sample::ReadData(AP4_DataBuffer& data, AP4_Size size, AP4_Size offset)\n{\n    // check that we have a stream\n    if (m_DataStream == NULL) return AP4_FAILURE;\n\n    // shortcut\n    if (size == 0) return AP4_SUCCESS;\n\n    // check the size\n    if (m_Size < size+offset) return AP4_FAILURE;\n\n    // set the buffer size\n    AP4_Result result = data.SetDataSize(size);\n    if (AP4_FAILED(result)) return result;\n\n    // get the data from the stream\n    result = m_DataStream->Seek(m_Offset+offset);\n    if (AP4_FAILED(result)) return result;\n    return m_DataStream->Read(data.UseData(), size);\n}",
        "func": "AP4_Result\nAP4_Sample::ReadData(AP4_DataBuffer& data, AP4_Size size, AP4_Size offset)\n{\n    // check that we have a stream\n    if (m_DataStream == NULL) return AP4_FAILURE;\n\n    // shortcut\n    if (size == 0) return AP4_SUCCESS;\n\n    // check the size\n    if (m_Size < size+offset) return AP4_FAILURE;\n\n    // check if there's enough data in the stream\n    AP4_LargeSize stream_size = 0;\n    AP4_Result result = m_DataStream->GetSize(stream_size);\n    if (AP4_SUCCEEDED(result)) {\n        if (size + offset > stream_size) {\n            return AP4_ERROR_OUT_OF_RANGE;\n        }\n    }\n    \n    // set the buffer size\n    result = data.SetDataSize(size);\n    if (AP4_FAILED(result)) return result;\n\n    // get the data from the stream\n    result = m_DataStream->Seek(m_Offset+offset);\n    if (AP4_FAILED(result)) return result;\n    return m_DataStream->Read(data.UseData(), size);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,17 @@\n     // check the size\n     if (m_Size < size+offset) return AP4_FAILURE;\n \n+    // check if there's enough data in the stream\n+    AP4_LargeSize stream_size = 0;\n+    AP4_Result result = m_DataStream->GetSize(stream_size);\n+    if (AP4_SUCCEEDED(result)) {\n+        if (size + offset > stream_size) {\n+            return AP4_ERROR_OUT_OF_RANGE;\n+        }\n+    }\n+    \n     // set the buffer size\n-    AP4_Result result = data.SetDataSize(size);\n+    result = data.SetDataSize(size);\n     if (AP4_FAILED(result)) return result;\n \n     // get the data from the stream",
        "diff_line_info": {
            "deleted_lines": [
                "    AP4_Result result = data.SetDataSize(size);"
            ],
            "added_lines": [
                "    // check if there's enough data in the stream",
                "    AP4_LargeSize stream_size = 0;",
                "    AP4_Result result = m_DataStream->GetSize(stream_size);",
                "    if (AP4_SUCCEEDED(result)) {",
                "        if (size + offset > stream_size) {",
                "            return AP4_ERROR_OUT_OF_RANGE;",
                "        }",
                "    }",
                "    ",
                "    result = data.SetDataSize(size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3153",
        "func_name": "ovn-org/ovn/build_lswitch_destination_lookup_bmcast",
        "description": "A flaw was found in Open Virtual Network where the service monitor MAC does not properly rate limit. This issue could allow an attacker to cause a denial of service, including on deployments with CoPP enabled and properly configured.",
        "git_url": "https://github.com/ovn-org/ovn/commit/9a3f7ed905e525ebdcb14541e775211cbb0203bd",
        "commit_title": "northd, controller: Add CoPP for SVC monitor",
        "commit_text": " The SVC monitor was exposed without any limitation. Add CoPP for the SVC monitor flow, which adds a way for CMSs to limit the traffic that this flow accepts. ",
        "func_before": "static void\nbuild_lswitch_destination_lookup_bmcast(struct ovn_datapath *od,\n                                        struct hmap *lflows,\n                                        struct ds *actions,\n                                        const struct shash *meter_groups)\n{\n    if (od->nbs) {\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110,\n                      \"eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)\",\n                      \"handle_svc_check(inport);\");\n\n        struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n        if (mcast_sw_info->enabled) {\n            ds_clear(actions);\n            ds_put_cstr(actions, \"igmp;\");\n            /* Punt IGMP traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"igmp\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Punt MLD traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"mldv1 || mldv2\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Flood all IP multicast traffic destined to 224.0.0.X to all\n             * ports - RFC 4541, section 2.1.2, item 2.\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip4.mcast && ip4.dst == 224.0.0.0/24\",\n                          \"outport = \\\"\"MC_FLOOD_L2\"\\\"; output;\");\n\n            /* Flood all IPv6 multicast traffic destined to reserved\n             * multicast IPs (RFC 4291, 2.7.1).\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip6.mcast_flood\",\n                          \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n\n            /* Forward uregistered IP multicast to routers with relay enabled\n             * and to any ports configured to flood IP multicast traffic.\n             * If configured to flood unregistered traffic this will be\n             * handled by the L2 multicast flow.\n             */\n            if (!mcast_sw_info->flood_unregistered) {\n                ds_clear(actions);\n\n                if (mcast_sw_info->flood_relay) {\n                    ds_put_cstr(actions,\n                                \"clone { \"\n                                    \"outport = \\\"\"MC_MROUTER_FLOOD\"\\\"; \"\n                                    \"output; \"\n                                \"}; \");\n                }\n\n                if (mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, \"outport =\\\"\"MC_STATIC\"\\\"; output;\");\n                }\n\n                /* Explicitly drop the traffic if relay or static flooding\n                 * is not configured.\n                 */\n                if (!mcast_sw_info->flood_relay &&\n                        !mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, debug_drop_action());\n                }\n\n                ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 80,\n                              \"ip4.mcast || ip6.mcast\",\n                              ds_cstr(actions));\n            }\n        }\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 70, \"eth.mcast\",\n                      \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n    }\n}",
        "func": "static void\nbuild_lswitch_destination_lookup_bmcast(struct ovn_datapath *od,\n                                        struct hmap *lflows,\n                                        struct ds *actions,\n                                        const struct shash *meter_groups)\n{\n    if (od->nbs) {\n\n        ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 110, \"eth.dst == \"\n                          \"$svc_monitor_mac && (tcp || icmp || icmp6)\",\n                          \"handle_svc_check(inport);\",\n                          copp_meter_get(COPP_SVC_MONITOR, od->nbs->copp,\n                                         meter_groups));\n\n        struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n        if (mcast_sw_info->enabled) {\n            ds_clear(actions);\n            ds_put_cstr(actions, \"igmp;\");\n            /* Punt IGMP traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"igmp\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Punt MLD traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"mldv1 || mldv2\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Flood all IP multicast traffic destined to 224.0.0.X to all\n             * ports - RFC 4541, section 2.1.2, item 2.\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip4.mcast && ip4.dst == 224.0.0.0/24\",\n                          \"outport = \\\"\"MC_FLOOD_L2\"\\\"; output;\");\n\n            /* Flood all IPv6 multicast traffic destined to reserved\n             * multicast IPs (RFC 4291, 2.7.1).\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip6.mcast_flood\",\n                          \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n\n            /* Forward uregistered IP multicast to routers with relay enabled\n             * and to any ports configured to flood IP multicast traffic.\n             * If configured to flood unregistered traffic this will be\n             * handled by the L2 multicast flow.\n             */\n            if (!mcast_sw_info->flood_unregistered) {\n                ds_clear(actions);\n\n                if (mcast_sw_info->flood_relay) {\n                    ds_put_cstr(actions,\n                                \"clone { \"\n                                    \"outport = \\\"\"MC_MROUTER_FLOOD\"\\\"; \"\n                                    \"output; \"\n                                \"}; \");\n                }\n\n                if (mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, \"outport =\\\"\"MC_STATIC\"\\\"; output;\");\n                }\n\n                /* Explicitly drop the traffic if relay or static flooding\n                 * is not configured.\n                 */\n                if (!mcast_sw_info->flood_relay &&\n                        !mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, debug_drop_action());\n                }\n\n                ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 80,\n                              \"ip4.mcast || ip6.mcast\",\n                              ds_cstr(actions));\n            }\n        }\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 70, \"eth.mcast\",\n                      \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,9 +6,11 @@\n {\n     if (od->nbs) {\n \n-        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110,\n-                      \"eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)\",\n-                      \"handle_svc_check(inport);\");\n+        ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 110, \"eth.dst == \"\n+                          \"$svc_monitor_mac && (tcp || icmp || icmp6)\",\n+                          \"handle_svc_check(inport);\",\n+                          copp_meter_get(COPP_SVC_MONITOR, od->nbs->copp,\n+                                         meter_groups));\n \n         struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110,",
                "                      \"eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)\",",
                "                      \"handle_svc_check(inport);\");"
            ],
            "added_lines": [
                "        ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 110, \"eth.dst == \"",
                "                          \"$svc_monitor_mac && (tcp || icmp || icmp6)\",",
                "                          \"handle_svc_check(inport);\",",
                "                          copp_meter_get(COPP_SVC_MONITOR, od->nbs->copp,",
                "                                         meter_groups));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-5371",
        "func_name": "wireshark/check_offset_addition",
        "description": "RTPS dissector memory leak in Wireshark 4.0.0 to 4.0.8 and 3.6.0 to 3.6.16 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/0de07f8fe4f8e06da9084485e64a24c8f85a20f4",
        "commit_title": "RTPS: Check for signed overflow",
        "commit_text": " The offset is a signed integer, and we use negative offsets to mean \"offset counting from the end of the tvb.\" That means that we can still have an excessive loop without unsigned overflow or running off the end of the tvb, if the result of adding a large unsigned integer to the offset results in a small negative number.  Just check if the result of the addition makes the offset move backwards.  Fix #19322 ",
        "func_before": "static guint32 check_offset_addition(guint32 offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)\n{\n    if (offset > G_MAXUINT32 - value) {\n        proto_tree_add_expert_format(tree, pinfo, &ei_rtps_value_too_large, tvb, 0, 0, \"Offset value too large: %u\", value);\n        THROW(ReportedBoundsError);\n    }\n    return offset + value;\n}",
        "func": "static gint check_offset_addition(gint offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)\n{\n    gint new_offset = offset + (gint)value;\n    if (new_offset < offset) {\n        proto_tree_add_expert_format(tree, pinfo, &ei_rtps_value_too_large, tvb, 0, 0, \"Offset value too large: %u\", value);\n        THROW(ReportedBoundsError);\n    }\n    return new_offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n-static guint32 check_offset_addition(guint32 offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)\n+static gint check_offset_addition(gint offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)\n {\n-    if (offset > G_MAXUINT32 - value) {\n+    gint new_offset = offset + (gint)value;\n+    if (new_offset < offset) {\n         proto_tree_add_expert_format(tree, pinfo, &ei_rtps_value_too_large, tvb, 0, 0, \"Offset value too large: %u\", value);\n         THROW(ReportedBoundsError);\n     }\n-    return offset + value;\n+    return new_offset;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static guint32 check_offset_addition(guint32 offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)",
                "    if (offset > G_MAXUINT32 - value) {",
                "    return offset + value;"
            ],
            "added_lines": [
                "static gint check_offset_addition(gint offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)",
                "    gint new_offset = offset + (gint)value;",
                "    if (new_offset < offset) {",
                "    return new_offset;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-45862",
        "func_name": "torvalds/linux/ms_lib_process_bootblock",
        "description": "An issue was discovered in drivers/usb/storage/ene_ub6250.c for the ENE UB6250 reader driver in the Linux kernel before 6.2.5. An object could potentially extend beyond the end of an allocation.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ce33e64c1788912976b61314b56935abd4bc97ef",
        "commit_title": "The allocation of PageBuffer is 512 bytes in size, but the dereferencing",
        "commit_text": "of struct ms_bootblock_idi (also size 512) happens at a calculated offset within the allocation, which means the object could potentially extend beyond the end of the allocation. Avoid this case by just allocating enough space to catch any accesses beyond the end. Seen with GCC 13:  ../drivers/usb/storage/ene_ub6250.c: In function 'ms_lib_process_bootblock': ../drivers/usb/storage/ene_ub6250.c:1050:44: warning: array subscript 'struct ms_bootblock_idi[0]' is partly outside array bounds of 'unsigned char[512]' [-Warray-bounds=]  1050 |                         if (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)       |                                            ^~ ../include/uapi/linux/byteorder/little_endian.h:37:51: note: in definition of macro '__le16_to_cpu'    37 | #define __le16_to_cpu(x) ((__force __u16)(__le16)(x))       |                                                   ^ ../drivers/usb/storage/ene_ub6250.c:1050:29: note: in expansion of macro 'le16_to_cpu'  1050 |                         if (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)       |                             ^~~~~~~~~~~ In file included from ../drivers/usb/storage/ene_ub6250.c:5: In function 'kmalloc',     inlined from 'ms_lib_process_bootblock' at ../drivers/usb/storage/ene_ub6250.c:942:15: ../include/linux/slab.h:580:24: note: at offset [256, 512] into object of size 512 allocated by 'kmalloc_trace'   580 |                 return kmalloc_trace(       |                        ^~~~~~~~~~~~~~   581 |                                 kmalloc_caches[kmalloc_type(flags)][index],       |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   582 |                                 flags, size);       |                                 ~~~~~~~~~~~~  Cc: Alan Stern <stern@rowland.harvard.edu> Link: https://lore.kernel.org/r/20230204183546.never.849-kees@kernel.org ",
        "func_before": "static int ms_lib_process_bootblock(struct us_data *us, u16 PhyBlock, u8 *PageData)\n{\n\tstruct ms_bootblock_sysent *SysEntry;\n\tstruct ms_bootblock_sysinf *SysInfo;\n\tu32 i, result;\n\tu8 PageNumber;\n\tu8 *PageBuffer;\n\tstruct ms_lib_type_extdat ExtraData;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tPageBuffer = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\n\tif (PageBuffer == NULL)\n\t\treturn (u32)-1;\n\n\tresult = (u32)-1;\n\n\tSysInfo = &(((struct ms_bootblock_page0 *)PageData)->sysinf);\n\n\tif ((SysInfo->bMsClass != MS_SYSINF_MSCLASS_TYPE_1) ||\n\t\t(be16_to_cpu(SysInfo->wPageSize) != MS_SYSINF_PAGE_SIZE) ||\n\t\t((SysInfo->bSecuritySupport & MS_SYSINF_SECURITY) == MS_SYSINF_SECURITY_SUPPORT) ||\n\t\t(SysInfo->bReserved1 != MS_SYSINF_RESERVED1) ||\n\t\t(SysInfo->bReserved2 != MS_SYSINF_RESERVED2) ||\n\t\t(SysInfo->bFormatType != MS_SYSINF_FORMAT_FAT) ||\n\t\t(SysInfo->bUsage != MS_SYSINF_USAGE_GENERAL))\n\t\tgoto exit;\n\t\t/* */\n\tswitch (info->MS_Lib.cardType = SysInfo->bCardType) {\n\tcase MS_SYSINF_CARDTYPE_RDONLY:\n\t\tms_lib_ctrl_set(info, MS_LIB_CTRL_RDONLY);\n\t\tbreak;\n\tcase MS_SYSINF_CARDTYPE_RDWR:\n\t\tms_lib_ctrl_reset(info, MS_LIB_CTRL_RDONLY);\n\t\tbreak;\n\tcase MS_SYSINF_CARDTYPE_HYBRID:\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\tinfo->MS_Lib.blockSize = be16_to_cpu(SysInfo->wBlockSize);\n\tinfo->MS_Lib.NumberOfPhyBlock = be16_to_cpu(SysInfo->wBlockNumber);\n\tinfo->MS_Lib.NumberOfLogBlock = be16_to_cpu(SysInfo->wTotalBlockNumber)-2;\n\tinfo->MS_Lib.PagesPerBlock = info->MS_Lib.blockSize * SIZE_OF_KIRO / MS_BYTES_PER_PAGE;\n\tinfo->MS_Lib.NumberOfSegment = info->MS_Lib.NumberOfPhyBlock / MS_PHYSICAL_BLOCKS_PER_SEGMENT;\n\tinfo->MS_Model = be16_to_cpu(SysInfo->wMemorySize);\n\n\t/*Allocate to all number of logicalblock and physicalblock */\n\tif (ms_lib_alloc_logicalmap(us))\n\t\tgoto exit;\n\n\t/* Mark the book block */\n\tms_lib_set_bootblockmark(us, PhyBlock);\n\n\tSysEntry = &(((struct ms_bootblock_page0 *)PageData)->sysent);\n\n\tfor (i = 0; i < MS_NUMBER_OF_SYSTEM_ENTRY; i++) {\n\t\tu32  EntryOffset, EntrySize;\n\n\t\tEntryOffset = be32_to_cpu(SysEntry->entry[i].dwStart);\n\n\t\tif (EntryOffset == 0xffffff)\n\t\t\tcontinue;\n\t\tEntrySize = be32_to_cpu(SysEntry->entry[i].dwSize);\n\n\t\tif (EntrySize == 0)\n\t\t\tcontinue;\n\n\t\tif (EntryOffset + MS_BYTES_PER_PAGE + EntrySize > info->MS_Lib.blockSize * (u32)SIZE_OF_KIRO)\n\t\t\tcontinue;\n\n\t\tif (i == 0) {\n\t\t\tu8 PrevPageNumber = 0;\n\t\t\tu16 phyblk;\n\n\t\t\tif (SysEntry->entry[i].bType != MS_SYSENT_TYPE_INVALID_BLOCK)\n\t\t\t\tgoto exit;\n\n\t\t\twhile (EntrySize > 0) {\n\n\t\t\t\tPageNumber = (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1);\n\t\t\t\tif (PageNumber != PrevPageNumber) {\n\t\t\t\t\tswitch (ms_read_readpage(us, PhyBlock, PageNumber, (u32 *)PageBuffer, &ExtraData)) {\n\t\t\t\t\tcase MS_STATUS_SUCCESS:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MS_STATUS_WRITE_PROTECT:\n\t\t\t\t\tcase MS_ERROR_FLASH_READ:\n\t\t\t\t\tcase MS_STATUS_ERROR:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tPrevPageNumber = PageNumber;\n\t\t\t\t}\n\n\t\t\t\tphyblk = be16_to_cpu(*(u16 *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)));\n\t\t\t\tif (phyblk < 0x0fff)\n\t\t\t\t\tms_lib_set_initialerrorblock(us, phyblk);\n\n\t\t\t\tEntryOffset += 2;\n\t\t\t\tEntrySize -= 2;\n\t\t\t}\n\t\t} else if (i == 1) {  /* CIS/IDI */\n\t\t\tstruct ms_bootblock_idi *idi;\n\n\t\t\tif (SysEntry->entry[i].bType != MS_SYSENT_TYPE_CIS_IDI)\n\t\t\t\tgoto exit;\n\n\t\t\tswitch (ms_read_readpage(us, PhyBlock, (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1), (u32 *)PageBuffer, &ExtraData)) {\n\t\t\tcase MS_STATUS_SUCCESS:\n\t\t\t\tbreak;\n\t\t\tcase MS_STATUS_WRITE_PROTECT:\n\t\t\tcase MS_ERROR_FLASH_READ:\n\t\t\tcase MS_STATUS_ERROR:\n\t\t\tdefault:\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tidi = &((struct ms_bootblock_cis_idi *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)))->idi.idi;\n\t\t\tif (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)\n\t\t\t\tgoto exit;\n\n\t\t\tinfo->MS_Lib.BytesPerSector = le16_to_cpu(idi->wIDIbytesPerSector);\n\t\t\tif (info->MS_Lib.BytesPerSector != MS_BYTES_PER_PAGE)\n\t\t\t\tgoto exit;\n\t\t}\n\t} /* End for .. */\n\n\tresult = 0;\n\nexit:\n\tif (result)\n\t\tms_lib_free_logicalmap(us);\n\n\tkfree(PageBuffer);\n\n\tresult = 0;\n\treturn result;\n}",
        "func": "static int ms_lib_process_bootblock(struct us_data *us, u16 PhyBlock, u8 *PageData)\n{\n\tstruct ms_bootblock_sysent *SysEntry;\n\tstruct ms_bootblock_sysinf *SysInfo;\n\tu32 i, result;\n\tu8 PageNumber;\n\tu8 *PageBuffer;\n\tstruct ms_lib_type_extdat ExtraData;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tPageBuffer = kzalloc(MS_BYTES_PER_PAGE * 2, GFP_KERNEL);\n\tif (PageBuffer == NULL)\n\t\treturn (u32)-1;\n\n\tresult = (u32)-1;\n\n\tSysInfo = &(((struct ms_bootblock_page0 *)PageData)->sysinf);\n\n\tif ((SysInfo->bMsClass != MS_SYSINF_MSCLASS_TYPE_1) ||\n\t\t(be16_to_cpu(SysInfo->wPageSize) != MS_SYSINF_PAGE_SIZE) ||\n\t\t((SysInfo->bSecuritySupport & MS_SYSINF_SECURITY) == MS_SYSINF_SECURITY_SUPPORT) ||\n\t\t(SysInfo->bReserved1 != MS_SYSINF_RESERVED1) ||\n\t\t(SysInfo->bReserved2 != MS_SYSINF_RESERVED2) ||\n\t\t(SysInfo->bFormatType != MS_SYSINF_FORMAT_FAT) ||\n\t\t(SysInfo->bUsage != MS_SYSINF_USAGE_GENERAL))\n\t\tgoto exit;\n\t\t/* */\n\tswitch (info->MS_Lib.cardType = SysInfo->bCardType) {\n\tcase MS_SYSINF_CARDTYPE_RDONLY:\n\t\tms_lib_ctrl_set(info, MS_LIB_CTRL_RDONLY);\n\t\tbreak;\n\tcase MS_SYSINF_CARDTYPE_RDWR:\n\t\tms_lib_ctrl_reset(info, MS_LIB_CTRL_RDONLY);\n\t\tbreak;\n\tcase MS_SYSINF_CARDTYPE_HYBRID:\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\tinfo->MS_Lib.blockSize = be16_to_cpu(SysInfo->wBlockSize);\n\tinfo->MS_Lib.NumberOfPhyBlock = be16_to_cpu(SysInfo->wBlockNumber);\n\tinfo->MS_Lib.NumberOfLogBlock = be16_to_cpu(SysInfo->wTotalBlockNumber)-2;\n\tinfo->MS_Lib.PagesPerBlock = info->MS_Lib.blockSize * SIZE_OF_KIRO / MS_BYTES_PER_PAGE;\n\tinfo->MS_Lib.NumberOfSegment = info->MS_Lib.NumberOfPhyBlock / MS_PHYSICAL_BLOCKS_PER_SEGMENT;\n\tinfo->MS_Model = be16_to_cpu(SysInfo->wMemorySize);\n\n\t/*Allocate to all number of logicalblock and physicalblock */\n\tif (ms_lib_alloc_logicalmap(us))\n\t\tgoto exit;\n\n\t/* Mark the book block */\n\tms_lib_set_bootblockmark(us, PhyBlock);\n\n\tSysEntry = &(((struct ms_bootblock_page0 *)PageData)->sysent);\n\n\tfor (i = 0; i < MS_NUMBER_OF_SYSTEM_ENTRY; i++) {\n\t\tu32  EntryOffset, EntrySize;\n\n\t\tEntryOffset = be32_to_cpu(SysEntry->entry[i].dwStart);\n\n\t\tif (EntryOffset == 0xffffff)\n\t\t\tcontinue;\n\t\tEntrySize = be32_to_cpu(SysEntry->entry[i].dwSize);\n\n\t\tif (EntrySize == 0)\n\t\t\tcontinue;\n\n\t\tif (EntryOffset + MS_BYTES_PER_PAGE + EntrySize > info->MS_Lib.blockSize * (u32)SIZE_OF_KIRO)\n\t\t\tcontinue;\n\n\t\tif (i == 0) {\n\t\t\tu8 PrevPageNumber = 0;\n\t\t\tu16 phyblk;\n\n\t\t\tif (SysEntry->entry[i].bType != MS_SYSENT_TYPE_INVALID_BLOCK)\n\t\t\t\tgoto exit;\n\n\t\t\twhile (EntrySize > 0) {\n\n\t\t\t\tPageNumber = (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1);\n\t\t\t\tif (PageNumber != PrevPageNumber) {\n\t\t\t\t\tswitch (ms_read_readpage(us, PhyBlock, PageNumber, (u32 *)PageBuffer, &ExtraData)) {\n\t\t\t\t\tcase MS_STATUS_SUCCESS:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MS_STATUS_WRITE_PROTECT:\n\t\t\t\t\tcase MS_ERROR_FLASH_READ:\n\t\t\t\t\tcase MS_STATUS_ERROR:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tPrevPageNumber = PageNumber;\n\t\t\t\t}\n\n\t\t\t\tphyblk = be16_to_cpu(*(u16 *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)));\n\t\t\t\tif (phyblk < 0x0fff)\n\t\t\t\t\tms_lib_set_initialerrorblock(us, phyblk);\n\n\t\t\t\tEntryOffset += 2;\n\t\t\t\tEntrySize -= 2;\n\t\t\t}\n\t\t} else if (i == 1) {  /* CIS/IDI */\n\t\t\tstruct ms_bootblock_idi *idi;\n\n\t\t\tif (SysEntry->entry[i].bType != MS_SYSENT_TYPE_CIS_IDI)\n\t\t\t\tgoto exit;\n\n\t\t\tswitch (ms_read_readpage(us, PhyBlock, (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1), (u32 *)PageBuffer, &ExtraData)) {\n\t\t\tcase MS_STATUS_SUCCESS:\n\t\t\t\tbreak;\n\t\t\tcase MS_STATUS_WRITE_PROTECT:\n\t\t\tcase MS_ERROR_FLASH_READ:\n\t\t\tcase MS_STATUS_ERROR:\n\t\t\tdefault:\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tidi = &((struct ms_bootblock_cis_idi *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)))->idi.idi;\n\t\t\tif (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)\n\t\t\t\tgoto exit;\n\n\t\t\tinfo->MS_Lib.BytesPerSector = le16_to_cpu(idi->wIDIbytesPerSector);\n\t\t\tif (info->MS_Lib.BytesPerSector != MS_BYTES_PER_PAGE)\n\t\t\t\tgoto exit;\n\t\t}\n\t} /* End for .. */\n\n\tresult = 0;\n\nexit:\n\tif (result)\n\t\tms_lib_free_logicalmap(us);\n\n\tkfree(PageBuffer);\n\n\tresult = 0;\n\treturn result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \tstruct ms_lib_type_extdat ExtraData;\n \tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n \n-\tPageBuffer = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\n+\tPageBuffer = kzalloc(MS_BYTES_PER_PAGE * 2, GFP_KERNEL);\n \tif (PageBuffer == NULL)\n \t\treturn (u32)-1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tPageBuffer = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);"
            ],
            "added_lines": [
                "\tPageBuffer = kzalloc(MS_BYTES_PER_PAGE * 2, GFP_KERNEL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22207",
        "func_name": "wireshark/dissect_CPMSetBindings",
        "description": "Excessive memory consumption in MS-WSP dissector in Wireshark 3.4.0 to 3.4.4 and 3.2.0 to 3.2.12 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b7a0650e061b5418ab4a8f72c6e4b00317aff623",
        "commit_title": "MS-WSP: Don't allocate huge amounts of memory.",
        "commit_text": " Add a couple of memory allocation sanity checks, one of which fixes #17331. ",
        "func_before": "static int dissect_CPMSetBindings(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, gboolean in, void *private_data)\n{\n\tgint offset = 16;\n\tstruct CPMSetBindingsIn request;\n\n\tcol_append_str(pinfo->cinfo, COL_INFO, \"SetBindings\");\n\tif (in) {\n\n\t\tstruct mswsp_ct *ct = NULL;\n\t\tstruct message_data *data = NULL;\n\t\tproto_item *ti;\n\t\tproto_tree *tree, *pad_tree;\n\t\tguint32 size, num, n;\n\t\tgint64 column_size;\n\n\t\tti = proto_tree_add_item(parent_tree, hf_mswsp_msg, tvb, offset, -1, ENC_NA);\n\t\ttree = proto_item_add_subtree(ti, ett_mswsp_msg);\n\n\t\tproto_item_set_text(ti, \"SetBindingsIn\");\n\n\t\tpad_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_mswsp_pad, &ti, \"Padding\");\n\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_hcursor, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\trequest.hcursor = tvb_get_letohl(tvb, offset);\n\t\toffset += 4;\n\t\trequest.brow = tvb_get_letohl(tvb, offset);\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_cbrow, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\toffset += 4;\n\n\t\tsize = tvb_get_letohl(tvb, offset);\n\t\trequest.bbindingdesc = size;\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_desc, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\toffset += 4;\n\n\t\trequest.dummy = tvb_get_letohl(tvb, offset);\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_dummy, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\toffset += 4;\n\n\t\tnum = tvb_get_letohl(tvb, offset);\n\t\trequest.ccolumns = num;\n\t\tti = proto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_ccolumns, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_acolumns, tvb, offset, size-4, ENC_NA);\n\n\t\t/* Sanity check size value */\n\t\tcolumn_size = num*MIN_CTABLECOL_SIZE;\n\t\tif (column_size > tvb_reported_length_remaining(tvb, offset))\n\t\t{\n\t\t\texpert_add_info(pinfo, ti, &ei_mswsp_msg_cpmsetbinding_ccolumns);\n\t\t\treturn tvb_reported_length(tvb);\n\t\t}\n\n\t\tct = get_create_converstation_data(pinfo);\n\n\t\trequest.acolumns = (struct CTableColumn*)wmem_alloc(wmem_file_scope(),\n\t\t\t\t\t\t   sizeof(struct CTableColumn) * num);\n\t\tfor (n=0; n<num; n++) {\n\t\t\toffset = parse_padding(tvb, offset, 4, pad_tree, \"padding_aColumns[%u]\", n);\n\t\t\toffset = parse_CTableColumn(tvb, pinfo, offset, tree, pad_tree, &request.acolumns[n],\"aColumns[%u]\", n);\n\t\t}\n\t\tdata = find_or_create_message_data(ct, pinfo,0xD0,in, private_data);\n\t\tif (data) {\n\t\t\tdata->content.bindingsin = request;\n\t\t}\n\n\t} else { /* server only returns status with header */\n\t}\n\n\treturn tvb_reported_length(tvb);\n}",
        "func": "static int dissect_CPMSetBindings(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, gboolean in, void *private_data)\n{\n\tgint offset = 16;\n\tstruct CPMSetBindingsIn request;\n\n\tcol_append_str(pinfo->cinfo, COL_INFO, \"SetBindings\");\n\tif (in) {\n\n\t\tstruct mswsp_ct *ct = NULL;\n\t\tstruct message_data *data = NULL;\n\t\tproto_item *ti;\n\t\tproto_tree *tree, *pad_tree;\n\t\tguint32 size, num, n;\n\t\tgint64 column_size;\n\n\t\tti = proto_tree_add_item(parent_tree, hf_mswsp_msg, tvb, offset, -1, ENC_NA);\n\t\ttree = proto_item_add_subtree(ti, ett_mswsp_msg);\n\n\t\tproto_item_set_text(ti, \"SetBindingsIn\");\n\n\t\tpad_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_mswsp_pad, &ti, \"Padding\");\n\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_hcursor, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\trequest.hcursor = tvb_get_letohl(tvb, offset);\n\t\toffset += 4;\n\t\trequest.brow = tvb_get_letohl(tvb, offset);\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_cbrow, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\toffset += 4;\n\n\t\tsize = tvb_get_letohl(tvb, offset);\n\t\trequest.bbindingdesc = size;\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_desc, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\toffset += 4;\n\n\t\trequest.dummy = tvb_get_letohl(tvb, offset);\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_dummy, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\toffset += 4;\n\n\t\tnum = tvb_get_letohl(tvb, offset);\n\t\trequest.ccolumns = num;\n\t\tti = proto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_ccolumns, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\t\toffset += 4;\n\n\t\tproto_tree_add_item(tree, hf_mswsp_msg_cpmsetbinding_acolumns, tvb, offset, size-4, ENC_NA);\n\n\t\t/* Sanity check size value */\n\t\tcolumn_size = num*MIN_CTABLECOL_SIZE;\n\t\tif (num > MAX_CTABLECOL_SIZE || column_size > tvb_reported_length_remaining(tvb, offset))\n\t\t{\n\t\t\texpert_add_info(pinfo, ti, &ei_mswsp_msg_cpmsetbinding_ccolumns);\n\t\t\treturn tvb_reported_length(tvb);\n\t\t}\n\n\t\tct = get_create_converstation_data(pinfo);\n\n\t\trequest.acolumns = (struct CTableColumn*)wmem_alloc(wmem_file_scope(),\n\t\t\t\t\t\t   sizeof(struct CTableColumn) * num);\n\t\tfor (n=0; n<num; n++) {\n\t\t\toffset = parse_padding(tvb, offset, 4, pad_tree, \"padding_aColumns[%u]\", n);\n\t\t\toffset = parse_CTableColumn(tvb, pinfo, offset, tree, pad_tree, &request.acolumns[n],\"aColumns[%u]\", n);\n\t\t}\n\t\tdata = find_or_create_message_data(ct, pinfo,0xD0,in, private_data);\n\t\tif (data) {\n\t\t\tdata->content.bindingsin = request;\n\t\t}\n\n\t} else { /* server only returns status with header */\n\t}\n\n\treturn tvb_reported_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n \n \t\t/* Sanity check size value */\n \t\tcolumn_size = num*MIN_CTABLECOL_SIZE;\n-\t\tif (column_size > tvb_reported_length_remaining(tvb, offset))\n+\t\tif (num > MAX_CTABLECOL_SIZE || column_size > tvb_reported_length_remaining(tvb, offset))\n \t\t{\n \t\t\texpert_add_info(pinfo, ti, &ei_mswsp_msg_cpmsetbinding_ccolumns);\n \t\t\treturn tvb_reported_length(tvb);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (column_size > tvb_reported_length_remaining(tvb, offset))"
            ],
            "added_lines": [
                "\t\tif (num > MAX_CTABLECOL_SIZE || column_size > tvb_reported_length_remaining(tvb, offset))"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22207",
        "func_name": "wireshark/vvalue_tvb_vector_internal",
        "description": "Excessive memory consumption in MS-WSP dissector in Wireshark 3.4.0 to 3.4.4 and 3.2.0 to 3.2.12 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b7a0650e061b5418ab4a8f72c6e4b00317aff623",
        "commit_title": "MS-WSP: Don't allocate huge amounts of memory.",
        "commit_text": " Add a couple of memory allocation sanity checks, one of which fixes #17331. ",
        "func_before": "static int vvalue_tvb_vector_internal(tvbuff_t *tvb, int offset, struct vt_vector *val, struct vtype_data *type, guint num)\n{\n\tconst int offset_in = offset;\n\tconst gboolean varsize = (type->size == -1);\n\tconst guint elsize = varsize ? (guint)sizeof(struct data_blob) : (guint)type->size;\n\tguint8 *data;\n\tint len;\n\tguint i;\n\n\t/*\n\t * Make sure we actually *have* the data we're going to fetch\n\t * here, before making a possibly-doomed attempt to allocate\n\t * memory for it.\n\t *\n\t * First, check for an overflow.\n\t */\n\tif ((guint64)elsize * (guint64)num > G_MAXUINT) {\n\t\t/*\n\t\t * We never have more than G_MAXUINT bytes in a tvbuff,\n\t\t * so this will *definitely* fail.\n\t\t */\n\t\tTHROW(ReportedBoundsError);\n\t}\n\n\t/*\n\t * No overflow; now make sure we at least have that data.\n\t */\n\ttvb_ensure_bytes_exist(tvb, offset, elsize * num);\n\n\t/*\n\t * OK, it exists; allocate a buffer into which to fetch it.\n\t */\n\tdata = (guint8*)wmem_alloc(wmem_packet_scope(), elsize * num);\n\n\tval->len = num;\n\tval->u.vt_ui1 = data;\n\tDISSECTOR_ASSERT((void*)&val->u == ((void*)&val->u.vt_ui1));\n\n\tfor (i=0; i<num; i++) {\n\t\tDISSECTOR_ASSERT_HINT(type->tvb_get != 0,\n\t\t\t\t      \"type that we don't know yet how to handle, please submit a bug with trace\");\n\t\tlen = type->tvb_get(tvb, offset, data);\n\t\tdata += elsize;\n\t\toffset += len;\n\t\tif (varsize && (offset % 4) ) { /* at begin or end of loop ??? */\n\t\t\tint padding = 4 - (offset % 4);\n\t\t\toffset += padding;\n\t\t}\n\t}\n\treturn offset - offset_in;\n}",
        "func": "static int vvalue_tvb_vector_internal(tvbuff_t *tvb, int offset, struct vt_vector *val, struct vtype_data *type, guint num)\n{\n\tconst int offset_in = offset;\n\tconst gboolean varsize = (type->size == -1);\n\tconst guint elsize = varsize ? (guint)sizeof(struct data_blob) : (guint)type->size;\n\tguint8 *data;\n\tint len;\n\tguint i;\n\n\t/*\n\t * Make sure we actually *have* the data we're going to fetch\n\t * here, before making a possibly-doomed attempt to allocate\n\t * memory for it.\n\t *\n\t * First, check for sane values.\n\t */\n\tif (num > MAX_VT_VECTOR_SIZE) {\n\t\tTHROW(ReportedBoundsError);\n\t}\n\n\t/*\n\t * No huge numbers from the wire; now make sure we at least have that data.\n\t */\n\ttvb_ensure_bytes_exist(tvb, offset, elsize * num);\n\n\t/*\n\t * OK, it exists; allocate a buffer into which to fetch it.\n\t */\n\tdata = (guint8*)wmem_alloc(wmem_packet_scope(), elsize * num);\n\n\tval->len = num;\n\tval->u.vt_ui1 = data;\n\tDISSECTOR_ASSERT((void*)&val->u == ((void*)&val->u.vt_ui1));\n\n\tfor (i=0; i<num; i++) {\n\t\tDISSECTOR_ASSERT_HINT(type->tvb_get != 0,\n\t\t\t\t      \"type that we don't know yet how to handle, please submit a bug with trace\");\n\t\tlen = type->tvb_get(tvb, offset, data);\n\t\tdata += elsize;\n\t\toffset += len;\n\t\tif (varsize && (offset % 4) ) { /* at begin or end of loop ??? */\n\t\t\tint padding = 4 - (offset % 4);\n\t\t\toffset += padding;\n\t\t}\n\t}\n\treturn offset - offset_in;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,18 +12,14 @@\n \t * here, before making a possibly-doomed attempt to allocate\n \t * memory for it.\n \t *\n-\t * First, check for an overflow.\n+\t * First, check for sane values.\n \t */\n-\tif ((guint64)elsize * (guint64)num > G_MAXUINT) {\n-\t\t/*\n-\t\t * We never have more than G_MAXUINT bytes in a tvbuff,\n-\t\t * so this will *definitely* fail.\n-\t\t */\n+\tif (num > MAX_VT_VECTOR_SIZE) {\n \t\tTHROW(ReportedBoundsError);\n \t}\n \n \t/*\n-\t * No overflow; now make sure we at least have that data.\n+\t * No huge numbers from the wire; now make sure we at least have that data.\n \t */\n \ttvb_ensure_bytes_exist(tvb, offset, elsize * num);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t * First, check for an overflow.",
                "\tif ((guint64)elsize * (guint64)num > G_MAXUINT) {",
                "\t\t/*",
                "\t\t * We never have more than G_MAXUINT bytes in a tvbuff,",
                "\t\t * so this will *definitely* fail.",
                "\t\t */",
                "\t * No overflow; now make sure we at least have that data."
            ],
            "added_lines": [
                "\t * First, check for sane values.",
                "\tif (num > MAX_VT_VECTOR_SIZE) {",
                "\t * No huge numbers from the wire; now make sure we at least have that data."
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3527",
        "func_name": "qemu-project/qemu/usbredir_handle_interrupt_out_data",
        "description": "A flaw was found in the USB redirector device (usb-redir) of QEMU. Small USB packets are combined into a single, large transfer request, to reduce the overhead and improve performance. The combined size of the bulk transfer is used to dynamically allocate a variable length array (VLA) on the stack without proper validation. Since the total size is not bounded, a malicious guest could use this flaw to influence the array length and cause the QEMU process to perform an excessive allocation on the stack, resulting in a denial of service.",
        "git_url": "https://gitlab.com/qemu-project/qemu/-/commit/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986",
        "commit_title": "usb/redir: avoid dynamic stack allocation (CVE-2021-3527)",
        "commit_text": " Use autofree heap allocation instead.  Message-Id: <20210503132915.2335822-3-kraxel@redhat.com> ",
        "func_before": "static void usbredir_handle_interrupt_out_data(USBRedirDevice *dev,\n                                               USBPacket *p, uint8_t ep)\n{\n    struct usb_redir_interrupt_packet_header interrupt_packet;\n    uint8_t buf[p->iov.size];\n\n    DPRINTF(\"interrupt-out ep %02X len %zd id %\"PRIu64\"\\n\", ep,\n            p->iov.size, p->id);\n\n    interrupt_packet.endpoint  = ep;\n    interrupt_packet.length    = p->iov.size;\n\n    usb_packet_copy(p, buf, p->iov.size);\n    usbredir_log_data(dev, \"interrupt data out:\", buf, p->iov.size);\n    usbredirparser_send_interrupt_packet(dev->parser, p->id,\n                                    &interrupt_packet, buf, p->iov.size);\n    usbredirparser_do_write(dev->parser);\n}",
        "func": "static void usbredir_handle_interrupt_out_data(USBRedirDevice *dev,\n                                               USBPacket *p, uint8_t ep)\n{\n    struct usb_redir_interrupt_packet_header interrupt_packet;\n    g_autofree uint8_t *buf = g_malloc(p->iov.size);\n\n    DPRINTF(\"interrupt-out ep %02X len %zd id %\"PRIu64\"\\n\", ep,\n            p->iov.size, p->id);\n\n    interrupt_packet.endpoint  = ep;\n    interrupt_packet.length    = p->iov.size;\n\n    usb_packet_copy(p, buf, p->iov.size);\n    usbredir_log_data(dev, \"interrupt data out:\", buf, p->iov.size);\n    usbredirparser_send_interrupt_packet(dev->parser, p->id,\n                                    &interrupt_packet, buf, p->iov.size);\n    usbredirparser_do_write(dev->parser);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n                                                USBPacket *p, uint8_t ep)\n {\n     struct usb_redir_interrupt_packet_header interrupt_packet;\n-    uint8_t buf[p->iov.size];\n+    g_autofree uint8_t *buf = g_malloc(p->iov.size);\n \n     DPRINTF(\"interrupt-out ep %02X len %zd id %\"PRIu64\"\\n\", ep,\n             p->iov.size, p->id);",
        "diff_line_info": {
            "deleted_lines": [
                "    uint8_t buf[p->iov.size];"
            ],
            "added_lines": [
                "    g_autofree uint8_t *buf = g_malloc(p->iov.size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3527",
        "func_name": "qemu-project/qemu/usbredir_handle_bulk_data",
        "description": "A flaw was found in the USB redirector device (usb-redir) of QEMU. Small USB packets are combined into a single, large transfer request, to reduce the overhead and improve performance. The combined size of the bulk transfer is used to dynamically allocate a variable length array (VLA) on the stack without proper validation. Since the total size is not bounded, a malicious guest could use this flaw to influence the array length and cause the QEMU process to perform an excessive allocation on the stack, resulting in a denial of service.",
        "git_url": "https://gitlab.com/qemu-project/qemu/-/commit/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986",
        "commit_title": "usb/redir: avoid dynamic stack allocation (CVE-2021-3527)",
        "commit_text": " Use autofree heap allocation instead.  Message-Id: <20210503132915.2335822-3-kraxel@redhat.com> ",
        "func_before": "static void usbredir_handle_bulk_data(USBRedirDevice *dev, USBPacket *p,\n                                      uint8_t ep)\n{\n    struct usb_redir_bulk_packet_header bulk_packet;\n    size_t size = usb_packet_size(p);\n    const int maxp = dev->endpoint[EP2I(ep)].max_packet_size;\n\n    if (usbredir_already_in_flight(dev, p->id)) {\n        p->status = USB_RET_ASYNC;\n        return;\n    }\n\n    if (dev->endpoint[EP2I(ep)].bulk_receiving_enabled) {\n        if (size != 0 && (size % maxp) == 0) {\n            usbredir_handle_buffered_bulk_in_data(dev, p, ep);\n            return;\n        }\n        WARNING(\"bulk recv invalid size %zd ep %02x, disabling\\n\", size, ep);\n        assert(dev->endpoint[EP2I(ep)].pending_async_packet == NULL);\n        usbredir_stop_bulk_receiving(dev, ep);\n        dev->endpoint[EP2I(ep)].bulk_receiving_enabled = 0;\n    }\n\n    DPRINTF(\"bulk-out ep %02X stream %u len %zd id %\"PRIu64\"\\n\",\n            ep, p->stream, size, p->id);\n\n    bulk_packet.endpoint  = ep;\n    bulk_packet.length    = size;\n    bulk_packet.stream_id = p->stream;\n    bulk_packet.length_high = size >> 16;\n    assert(bulk_packet.length_high == 0 ||\n           usbredirparser_peer_has_cap(dev->parser,\n                                       usb_redir_cap_32bits_bulk_length));\n\n    if (ep & USB_DIR_IN || size == 0) {\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n                                        &bulk_packet, NULL, 0);\n    } else {\n        uint8_t buf[size];\n        usb_packet_copy(p, buf, size);\n        usbredir_log_data(dev, \"bulk data out:\", buf, size);\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n                                        &bulk_packet, buf, size);\n    }\n    usbredirparser_do_write(dev->parser);\n    p->status = USB_RET_ASYNC;\n}",
        "func": "static void usbredir_handle_bulk_data(USBRedirDevice *dev, USBPacket *p,\n                                      uint8_t ep)\n{\n    struct usb_redir_bulk_packet_header bulk_packet;\n    size_t size = usb_packet_size(p);\n    const int maxp = dev->endpoint[EP2I(ep)].max_packet_size;\n\n    if (usbredir_already_in_flight(dev, p->id)) {\n        p->status = USB_RET_ASYNC;\n        return;\n    }\n\n    if (dev->endpoint[EP2I(ep)].bulk_receiving_enabled) {\n        if (size != 0 && (size % maxp) == 0) {\n            usbredir_handle_buffered_bulk_in_data(dev, p, ep);\n            return;\n        }\n        WARNING(\"bulk recv invalid size %zd ep %02x, disabling\\n\", size, ep);\n        assert(dev->endpoint[EP2I(ep)].pending_async_packet == NULL);\n        usbredir_stop_bulk_receiving(dev, ep);\n        dev->endpoint[EP2I(ep)].bulk_receiving_enabled = 0;\n    }\n\n    DPRINTF(\"bulk-out ep %02X stream %u len %zd id %\"PRIu64\"\\n\",\n            ep, p->stream, size, p->id);\n\n    bulk_packet.endpoint  = ep;\n    bulk_packet.length    = size;\n    bulk_packet.stream_id = p->stream;\n    bulk_packet.length_high = size >> 16;\n    assert(bulk_packet.length_high == 0 ||\n           usbredirparser_peer_has_cap(dev->parser,\n                                       usb_redir_cap_32bits_bulk_length));\n\n    if (ep & USB_DIR_IN || size == 0) {\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n                                        &bulk_packet, NULL, 0);\n    } else {\n        g_autofree uint8_t *buf = g_malloc(size);\n        usb_packet_copy(p, buf, size);\n        usbredir_log_data(dev, \"bulk data out:\", buf, size);\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n                                        &bulk_packet, buf, size);\n    }\n    usbredirparser_do_write(dev->parser);\n    p->status = USB_RET_ASYNC;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,7 @@\n         usbredirparser_send_bulk_packet(dev->parser, p->id,\n                                         &bulk_packet, NULL, 0);\n     } else {\n-        uint8_t buf[size];\n+        g_autofree uint8_t *buf = g_malloc(size);\n         usb_packet_copy(p, buf, size);\n         usbredir_log_data(dev, \"bulk data out:\", buf, size);\n         usbredirparser_send_bulk_packet(dev->parser, p->id,",
        "diff_line_info": {
            "deleted_lines": [
                "        uint8_t buf[size];"
            ],
            "added_lines": [
                "        g_autofree uint8_t *buf = g_malloc(size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3527",
        "func_name": "qemu-project/qemu/usbredir_handle_iso_data",
        "description": "A flaw was found in the USB redirector device (usb-redir) of QEMU. Small USB packets are combined into a single, large transfer request, to reduce the overhead and improve performance. The combined size of the bulk transfer is used to dynamically allocate a variable length array (VLA) on the stack without proper validation. Since the total size is not bounded, a malicious guest could use this flaw to influence the array length and cause the QEMU process to perform an excessive allocation on the stack, resulting in a denial of service.",
        "git_url": "https://gitlab.com/qemu-project/qemu/-/commit/7ec54f9eb62b5d177e30eb8b1cad795a5f8d8986",
        "commit_title": "usb/redir: avoid dynamic stack allocation (CVE-2021-3527)",
        "commit_text": " Use autofree heap allocation instead.  Message-Id: <20210503132915.2335822-3-kraxel@redhat.com> ",
        "func_before": "static void usbredir_handle_iso_data(USBRedirDevice *dev, USBPacket *p,\n                                     uint8_t ep)\n{\n    int status, len;\n    if (!dev->endpoint[EP2I(ep)].iso_started &&\n            !dev->endpoint[EP2I(ep)].iso_error) {\n        struct usb_redir_start_iso_stream_header start_iso = {\n            .endpoint = ep,\n        };\n        int pkts_per_sec;\n\n        if (dev->dev.speed == USB_SPEED_HIGH) {\n            pkts_per_sec = 8000 / dev->endpoint[EP2I(ep)].interval;\n        } else {\n            pkts_per_sec = 1000 / dev->endpoint[EP2I(ep)].interval;\n        }\n        /* Testing has shown that we need circa 60 ms buffer */\n        dev->endpoint[EP2I(ep)].bufpq_target_size = (pkts_per_sec * 60) / 1000;\n\n        /* Aim for approx 100 interrupts / second on the client to\n           balance latency and interrupt load */\n        start_iso.pkts_per_urb = pkts_per_sec / 100;\n        if (start_iso.pkts_per_urb < 1) {\n            start_iso.pkts_per_urb = 1;\n        } else if (start_iso.pkts_per_urb > 32) {\n            start_iso.pkts_per_urb = 32;\n        }\n\n        start_iso.no_urbs = DIV_ROUND_UP(\n                                     dev->endpoint[EP2I(ep)].bufpq_target_size,\n                                     start_iso.pkts_per_urb);\n        /* Output endpoints pre-fill only 1/2 of the packets, keeping the rest\n           as overflow buffer. Also see the usbredir protocol documentation */\n        if (!(ep & USB_DIR_IN)) {\n            start_iso.no_urbs *= 2;\n        }\n        if (start_iso.no_urbs > 16) {\n            start_iso.no_urbs = 16;\n        }\n\n        /* No id, we look at the ep when receiving a status back */\n        usbredirparser_send_start_iso_stream(dev->parser, 0, &start_iso);\n        usbredirparser_do_write(dev->parser);\n        DPRINTF(\"iso stream started pkts/sec %d pkts/urb %d urbs %d ep %02X\\n\",\n                pkts_per_sec, start_iso.pkts_per_urb, start_iso.no_urbs, ep);\n        dev->endpoint[EP2I(ep)].iso_started = 1;\n        dev->endpoint[EP2I(ep)].bufpq_prefilled = 0;\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n    }\n\n    if (ep & USB_DIR_IN) {\n        struct buf_packet *isop;\n\n        if (dev->endpoint[EP2I(ep)].iso_started &&\n                !dev->endpoint[EP2I(ep)].bufpq_prefilled) {\n            if (dev->endpoint[EP2I(ep)].bufpq_size <\n                    dev->endpoint[EP2I(ep)].bufpq_target_size) {\n                return;\n            }\n            dev->endpoint[EP2I(ep)].bufpq_prefilled = 1;\n        }\n\n        isop = QTAILQ_FIRST(&dev->endpoint[EP2I(ep)].bufpq);\n        if (isop == NULL) {\n            DPRINTF(\"iso-token-in ep %02X, no isop, iso_error: %d\\n\",\n                    ep, dev->endpoint[EP2I(ep)].iso_error);\n            /* Re-fill the buffer */\n            dev->endpoint[EP2I(ep)].bufpq_prefilled = 0;\n            /* Check iso_error for stream errors, otherwise its an underrun */\n            status = dev->endpoint[EP2I(ep)].iso_error;\n            dev->endpoint[EP2I(ep)].iso_error = 0;\n            p->status = status ? USB_RET_IOERROR : USB_RET_SUCCESS;\n            return;\n        }\n        DPRINTF2(\"iso-token-in ep %02X status %d len %d queue-size: %d\\n\", ep,\n                 isop->status, isop->len, dev->endpoint[EP2I(ep)].bufpq_size);\n\n        status = isop->status;\n        len = isop->len;\n        if (len > p->iov.size) {\n            ERROR(\"received iso data is larger then packet ep %02X (%d > %d)\\n\",\n                  ep, len, (int)p->iov.size);\n            len = p->iov.size;\n            status = usb_redir_babble;\n        }\n        usb_packet_copy(p, isop->data, len);\n        bufp_free(dev, isop, ep);\n        usbredir_handle_status(dev, p, status);\n    } else {\n        /* If the stream was not started because of a pending error don't\n           send the packet to the usb-host */\n        if (dev->endpoint[EP2I(ep)].iso_started) {\n            struct usb_redir_iso_packet_header iso_packet = {\n                .endpoint = ep,\n                .length = p->iov.size\n            };\n            uint8_t buf[p->iov.size];\n            /* No id, we look at the ep when receiving a status back */\n            usb_packet_copy(p, buf, p->iov.size);\n            usbredirparser_send_iso_packet(dev->parser, 0, &iso_packet,\n                                           buf, p->iov.size);\n            usbredirparser_do_write(dev->parser);\n        }\n        status = dev->endpoint[EP2I(ep)].iso_error;\n        dev->endpoint[EP2I(ep)].iso_error = 0;\n        DPRINTF2(\"iso-token-out ep %02X status %d len %zd\\n\", ep, status,\n                 p->iov.size);\n        usbredir_handle_status(dev, p, status);\n    }\n}",
        "func": "static void usbredir_handle_iso_data(USBRedirDevice *dev, USBPacket *p,\n                                     uint8_t ep)\n{\n    int status, len;\n    if (!dev->endpoint[EP2I(ep)].iso_started &&\n            !dev->endpoint[EP2I(ep)].iso_error) {\n        struct usb_redir_start_iso_stream_header start_iso = {\n            .endpoint = ep,\n        };\n        int pkts_per_sec;\n\n        if (dev->dev.speed == USB_SPEED_HIGH) {\n            pkts_per_sec = 8000 / dev->endpoint[EP2I(ep)].interval;\n        } else {\n            pkts_per_sec = 1000 / dev->endpoint[EP2I(ep)].interval;\n        }\n        /* Testing has shown that we need circa 60 ms buffer */\n        dev->endpoint[EP2I(ep)].bufpq_target_size = (pkts_per_sec * 60) / 1000;\n\n        /* Aim for approx 100 interrupts / second on the client to\n           balance latency and interrupt load */\n        start_iso.pkts_per_urb = pkts_per_sec / 100;\n        if (start_iso.pkts_per_urb < 1) {\n            start_iso.pkts_per_urb = 1;\n        } else if (start_iso.pkts_per_urb > 32) {\n            start_iso.pkts_per_urb = 32;\n        }\n\n        start_iso.no_urbs = DIV_ROUND_UP(\n                                     dev->endpoint[EP2I(ep)].bufpq_target_size,\n                                     start_iso.pkts_per_urb);\n        /* Output endpoints pre-fill only 1/2 of the packets, keeping the rest\n           as overflow buffer. Also see the usbredir protocol documentation */\n        if (!(ep & USB_DIR_IN)) {\n            start_iso.no_urbs *= 2;\n        }\n        if (start_iso.no_urbs > 16) {\n            start_iso.no_urbs = 16;\n        }\n\n        /* No id, we look at the ep when receiving a status back */\n        usbredirparser_send_start_iso_stream(dev->parser, 0, &start_iso);\n        usbredirparser_do_write(dev->parser);\n        DPRINTF(\"iso stream started pkts/sec %d pkts/urb %d urbs %d ep %02X\\n\",\n                pkts_per_sec, start_iso.pkts_per_urb, start_iso.no_urbs, ep);\n        dev->endpoint[EP2I(ep)].iso_started = 1;\n        dev->endpoint[EP2I(ep)].bufpq_prefilled = 0;\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n    }\n\n    if (ep & USB_DIR_IN) {\n        struct buf_packet *isop;\n\n        if (dev->endpoint[EP2I(ep)].iso_started &&\n                !dev->endpoint[EP2I(ep)].bufpq_prefilled) {\n            if (dev->endpoint[EP2I(ep)].bufpq_size <\n                    dev->endpoint[EP2I(ep)].bufpq_target_size) {\n                return;\n            }\n            dev->endpoint[EP2I(ep)].bufpq_prefilled = 1;\n        }\n\n        isop = QTAILQ_FIRST(&dev->endpoint[EP2I(ep)].bufpq);\n        if (isop == NULL) {\n            DPRINTF(\"iso-token-in ep %02X, no isop, iso_error: %d\\n\",\n                    ep, dev->endpoint[EP2I(ep)].iso_error);\n            /* Re-fill the buffer */\n            dev->endpoint[EP2I(ep)].bufpq_prefilled = 0;\n            /* Check iso_error for stream errors, otherwise its an underrun */\n            status = dev->endpoint[EP2I(ep)].iso_error;\n            dev->endpoint[EP2I(ep)].iso_error = 0;\n            p->status = status ? USB_RET_IOERROR : USB_RET_SUCCESS;\n            return;\n        }\n        DPRINTF2(\"iso-token-in ep %02X status %d len %d queue-size: %d\\n\", ep,\n                 isop->status, isop->len, dev->endpoint[EP2I(ep)].bufpq_size);\n\n        status = isop->status;\n        len = isop->len;\n        if (len > p->iov.size) {\n            ERROR(\"received iso data is larger then packet ep %02X (%d > %d)\\n\",\n                  ep, len, (int)p->iov.size);\n            len = p->iov.size;\n            status = usb_redir_babble;\n        }\n        usb_packet_copy(p, isop->data, len);\n        bufp_free(dev, isop, ep);\n        usbredir_handle_status(dev, p, status);\n    } else {\n        /* If the stream was not started because of a pending error don't\n           send the packet to the usb-host */\n        if (dev->endpoint[EP2I(ep)].iso_started) {\n            struct usb_redir_iso_packet_header iso_packet = {\n                .endpoint = ep,\n                .length = p->iov.size\n            };\n            g_autofree uint8_t *buf = g_malloc(p->iov.size);\n            /* No id, we look at the ep when receiving a status back */\n            usb_packet_copy(p, buf, p->iov.size);\n            usbredirparser_send_iso_packet(dev->parser, 0, &iso_packet,\n                                           buf, p->iov.size);\n            usbredirparser_do_write(dev->parser);\n        }\n        status = dev->endpoint[EP2I(ep)].iso_error;\n        dev->endpoint[EP2I(ep)].iso_error = 0;\n        DPRINTF2(\"iso-token-out ep %02X status %d len %zd\\n\", ep, status,\n                 p->iov.size);\n        usbredir_handle_status(dev, p, status);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -94,7 +94,7 @@\n                 .endpoint = ep,\n                 .length = p->iov.size\n             };\n-            uint8_t buf[p->iov.size];\n+            g_autofree uint8_t *buf = g_malloc(p->iov.size);\n             /* No id, we look at the ep when receiving a status back */\n             usb_packet_copy(p, buf, p->iov.size);\n             usbredirparser_send_iso_packet(dev->parser, 0, &iso_packet,",
        "diff_line_info": {
            "deleted_lines": [
                "            uint8_t buf[p->iov.size];"
            ],
            "added_lines": [
                "            g_autofree uint8_t *buf = g_malloc(p->iov.size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3527",
        "func_name": "qemu-project/qemu/usb_ep_combine_input_packets",
        "description": "A flaw was found in the USB redirector device (usb-redir) of QEMU. Small USB packets are combined into a single, large transfer request, to reduce the overhead and improve performance. The combined size of the bulk transfer is used to dynamically allocate a variable length array (VLA) on the stack without proper validation. Since the total size is not bounded, a malicious guest could use this flaw to influence the array length and cause the QEMU process to perform an excessive allocation on the stack, resulting in a denial of service.",
        "git_url": "https://gitlab.com/qemu-project/qemu/-/commit/05a40b172e4d691371534828078be47e7fff524c",
        "commit_title": "usb: limit combined packets to 1 MiB (CVE-2021-3527)",
        "commit_text": " usb-host and usb-redirect try to batch bulk transfers by combining many small usb packets into a single, large transfer request, to reduce the overhead and improve performance.  This patch adds a size limit of 1 MiB for those combined packets to restrict the host resources the guest can bind that way.  Message-Id: <20210503132915.2335822-6-kraxel@redhat.com> ",
        "func_before": "void usb_ep_combine_input_packets(USBEndpoint *ep)\n{\n    USBPacket *p, *u, *next, *prev = NULL, *first = NULL;\n    USBPort *port = ep->dev->port;\n    int totalsize;\n\n    assert(ep->pipeline);\n    assert(ep->pid == USB_TOKEN_IN);\n\n    QTAILQ_FOREACH_SAFE(p, &ep->queue, queue, next) {\n        /* Empty the queue on a halt */\n        if (ep->halted) {\n            p->status = USB_RET_REMOVE_FROM_QUEUE;\n            port->ops->complete(port, p);\n            continue;\n        }\n\n        /* Skip packets already submitted to the device */\n        if (p->state == USB_PACKET_ASYNC) {\n            prev = p;\n            continue;\n        }\n        usb_packet_check_state(p, USB_PACKET_QUEUED);\n\n        /*\n         * If the previous (combined) packet has the short_not_ok flag set\n         * stop, as we must not submit packets to the device after a transfer\n         * ending with short_not_ok packet.\n         */\n        if (prev && prev->short_not_ok) {\n            break;\n        }\n\n        if (first) {\n            if (first->combined == NULL) {\n                USBCombinedPacket *combined = g_new0(USBCombinedPacket, 1);\n\n                combined->first = first;\n                QTAILQ_INIT(&combined->packets);\n                qemu_iovec_init(&combined->iov, 2);\n                usb_combined_packet_add(combined, first);\n            }\n            usb_combined_packet_add(first->combined, p);\n        } else {\n            first = p;\n        }\n\n        /* Is this packet the last one of a (combined) transfer? */\n        totalsize = (p->combined) ? p->combined->iov.size : p->iov.size;\n        if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||\n                next == NULL ||\n                /* Work around for Linux usbfs bulk splitting + migration */\n                (totalsize == (16 * KiB - 36) && p->int_req)) {\n            usb_device_handle_data(ep->dev, first);\n            assert(first->status == USB_RET_ASYNC);\n            if (first->combined) {\n                QTAILQ_FOREACH(u, &first->combined->packets, combined_entry) {\n                    usb_packet_set_state(u, USB_PACKET_ASYNC);\n                }\n            } else {\n                usb_packet_set_state(first, USB_PACKET_ASYNC);\n            }\n            first = NULL;\n            prev = p;\n        }\n    }\n}",
        "func": "void usb_ep_combine_input_packets(USBEndpoint *ep)\n{\n    USBPacket *p, *u, *next, *prev = NULL, *first = NULL;\n    USBPort *port = ep->dev->port;\n    int totalsize;\n\n    assert(ep->pipeline);\n    assert(ep->pid == USB_TOKEN_IN);\n\n    QTAILQ_FOREACH_SAFE(p, &ep->queue, queue, next) {\n        /* Empty the queue on a halt */\n        if (ep->halted) {\n            p->status = USB_RET_REMOVE_FROM_QUEUE;\n            port->ops->complete(port, p);\n            continue;\n        }\n\n        /* Skip packets already submitted to the device */\n        if (p->state == USB_PACKET_ASYNC) {\n            prev = p;\n            continue;\n        }\n        usb_packet_check_state(p, USB_PACKET_QUEUED);\n\n        /*\n         * If the previous (combined) packet has the short_not_ok flag set\n         * stop, as we must not submit packets to the device after a transfer\n         * ending with short_not_ok packet.\n         */\n        if (prev && prev->short_not_ok) {\n            break;\n        }\n\n        if (first) {\n            if (first->combined == NULL) {\n                USBCombinedPacket *combined = g_new0(USBCombinedPacket, 1);\n\n                combined->first = first;\n                QTAILQ_INIT(&combined->packets);\n                qemu_iovec_init(&combined->iov, 2);\n                usb_combined_packet_add(combined, first);\n            }\n            usb_combined_packet_add(first->combined, p);\n        } else {\n            first = p;\n        }\n\n        /* Is this packet the last one of a (combined) transfer? */\n        totalsize = (p->combined) ? p->combined->iov.size : p->iov.size;\n        if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||\n                next == NULL ||\n                /* Work around for Linux usbfs bulk splitting + migration */\n                (totalsize == (16 * KiB - 36) && p->int_req) ||\n                /* Next package may grow combined package over 1MiB */\n                totalsize > 1 * MiB - ep->max_packet_size) {\n            usb_device_handle_data(ep->dev, first);\n            assert(first->status == USB_RET_ASYNC);\n            if (first->combined) {\n                QTAILQ_FOREACH(u, &first->combined->packets, combined_entry) {\n                    usb_packet_set_state(u, USB_PACKET_ASYNC);\n                }\n            } else {\n                usb_packet_set_state(first, USB_PACKET_ASYNC);\n            }\n            first = NULL;\n            prev = p;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,7 +50,9 @@\n         if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||\n                 next == NULL ||\n                 /* Work around for Linux usbfs bulk splitting + migration */\n-                (totalsize == (16 * KiB - 36) && p->int_req)) {\n+                (totalsize == (16 * KiB - 36) && p->int_req) ||\n+                /* Next package may grow combined package over 1MiB */\n+                totalsize > 1 * MiB - ep->max_packet_size) {\n             usb_device_handle_data(ep->dev, first);\n             assert(first->status == USB_RET_ASYNC);\n             if (first->combined) {",
        "diff_line_info": {
            "deleted_lines": [
                "                (totalsize == (16 * KiB - 36) && p->int_req)) {"
            ],
            "added_lines": [
                "                (totalsize == (16 * KiB - 36) && p->int_req) ||",
                "                /* Next package may grow combined package over 1MiB */",
                "                totalsize > 1 * MiB - ep->max_packet_size) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28848",
        "func_name": "mintty/do_winop",
        "description": "Mintty before 3.4.5 allows remote servers to cause a denial of service (Windows GUI hang) by telling the Mintty window to change its title repeatedly at high speed, which results in many SetWindowTextA or SetWindowTextW calls. In other words, it does not implement a usleep or similar delay upon processing a title change.",
        "git_url": "https://github.com/mintty/mintty/commit/bd52109993440b6996760aaccb66e68e782762b9",
        "commit_title": "tame some window operations, just in case",
        "commit_text": "",
        "func_before": "static void\ndo_winop(void)\n{\n  int arg1 = term.csi_argv[1], arg2 = term.csi_argv[2];\n  if (*cfg.suppress_win && contains(cfg.suppress_win, term.csi_argv[0]))\n    // skip suppressed window operation\n    return;\n  switch (term.csi_argv[0]) {\n    when 1: win_set_iconic(false);\n    when 2: win_set_iconic(true);\n    when 3: win_set_pos(arg1, arg2);\n    when 4: win_set_pixels(arg1, arg2);\n    when 5:\n      if (term.csi_argc != 1)\n        return;\n      win_set_zorder(true);  // top\n    when 6:\n      if (term.csi_argc != 1)\n        return;\n      win_set_zorder(false); // bottom\n    when 7: win_invalidate_all(false);  // refresh\n    when 8: {\n      int def1 = term.csi_argv_defined[1], def2 = term.csi_argv_defined[2];\n      int rows, cols;\n      win_get_screen_chars(&rows, &cols);\n      win_set_chars(arg1 ?: def1 ? rows : term.rows, arg2 ?: def2 ? cols : term.cols);\n    }\n    when 9: {\n      if (term.csi_argc != 2)\n        return;\n      // Ps = 9 ; 0  -> Restore maximized window.\n      // Ps = 9 ; 1  -> Maximize window (i.e., resize to screen size).\n      // Ps = 9 ; 2  -> Maximize window vertically.\n      // Ps = 9 ; 3  -> Maximize window horizontally.\n      int rows0 = term.rows0, cols0 = term.cols0;\n      if (arg1 == 2) {\n        // maximize window vertically\n        win_set_geom(0, -1, 0, -1);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 3) {\n        // maximize window horizontally\n        win_set_geom(-1, 0, -1, 0);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 1) {\n        win_maximise(1);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 0) {\n        win_maximise(0);\n        win_set_chars(rows0, cols0);\n      }\n    }\n    when 10:\n      if (term.csi_argc != 2)\n        return;\n      // Ps = 1 0 ; 0  -> Undo full-screen mode.\n      // Ps = 1 0 ; 1  -> Change to full-screen.\n      // Ps = 1 0 ; 2  -> Toggle full-screen.\n      if (arg1 == 2)\n        win_maximise(-2);\n      else if (arg1 == 1 || arg1 == 0)\n        win_maximise(arg1 ? 2 : 0);\n    when 11: child_write(win_is_iconic() ? \"\\e[2t\" : \"\\e[1t\", 4);\n    when 13: {\n      int x, y;\n      win_get_scrpos(&x, &y, arg1 == 2);\n      child_printf(\"\\e[3;%u;%ut\", (ushort)x, (ushort)y);\n    }\n    when 14: {\n      int height, width;\n      win_get_pixels(&height, &width, arg1 == 2);\n      child_printf(\"\\e[4;%d;%dt\", height, width);\n    }\n    when 15: {\n      int w, h;\n      search_monitors(&w, &h, 0, false, 0);\n      child_printf(\"\\e[5;%d;%dt\", h, w);\n    }\n    when 16: child_printf(\"\\e[6;%d;%dt\", cell_height, cell_width);\n    when 18: child_printf(\"\\e[8;%d;%dt\", term.rows, term.cols);\n    when 19: {\n#ifdef size_of_monitor_only\n#warning not what xterm reports\n      int rows, cols;\n      win_get_screen_chars(&rows, &cols);\n      child_printf(\"\\e[9;%d;%dt\", rows, cols);\n#else\n      int w, h;\n      search_monitors(&w, &h, 0, false, 0);\n      child_printf(\"\\e[9;%d;%dt\", h / cell_height, w / cell_width);\n#endif\n    }\n    when 22:\n      if (arg1 == 0 || arg1 == 2)\n        win_save_title();\n    when 23:\n      if (arg1 == 0 || arg1 == 2)\n        win_restore_title();\n  }\n}",
        "func": "static void\ndo_winop(void)\n{\n  int arg1 = term.csi_argv[1], arg2 = term.csi_argv[2];\n  if (*cfg.suppress_win && contains(cfg.suppress_win, term.csi_argv[0]))\n    // skip suppressed window operation\n    return;\n  switch (term.csi_argv[0]) {\n    when 1: win_set_iconic(false);\n    when 2: win_set_iconic(true);\n    when 3: win_set_pos(arg1, arg2);\n    when 4: win_set_pixels(arg1, arg2);\n    when 5:\n      if (term.csi_argc != 1)\n        return;\n      win_set_zorder(true);  // top\n    when 6:\n      if (term.csi_argc != 1)\n        return;\n      win_set_zorder(false); // bottom\n    when 7: win_invalidate_all(false);  // refresh\n    when 8: {\n      int def1 = term.csi_argv_defined[1], def2 = term.csi_argv_defined[2];\n      int rows, cols;\n      win_get_screen_chars(&rows, &cols);\n      win_set_chars(arg1 ?: def1 ? rows : term.rows, arg2 ?: def2 ? cols : term.cols);\n    }\n    when 9: {\n      if (term.csi_argc != 2)\n        return;\n      // Ps = 9 ; 0  -> Restore maximized window.\n      // Ps = 9 ; 1  -> Maximize window (i.e., resize to screen size).\n      // Ps = 9 ; 2  -> Maximize window vertically.\n      // Ps = 9 ; 3  -> Maximize window horizontally.\n      int rows0 = term.rows0, cols0 = term.cols0;\n      if (arg1 == 2) {\n        // maximize window vertically\n        win_set_geom(0, -1, 0, -1);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 3) {\n        // maximize window horizontally\n        win_set_geom(-1, 0, -1, 0);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 1) {\n        win_maximise(1);\n        term.rows0 = rows0; term.cols0 = cols0;\n      }\n      else if (arg1 == 0) {\n        win_maximise(0);\n        win_set_chars(rows0, cols0);\n      }\n      usleep(1000);\n    }\n    when 10:\n      if (term.csi_argc != 2)\n        return;\n      // Ps = 1 0 ; 0  -> Undo full-screen mode.\n      // Ps = 1 0 ; 1  -> Change to full-screen.\n      // Ps = 1 0 ; 2  -> Toggle full-screen.\n      if (arg1 == 2)\n        win_maximise(-2);\n      else if (arg1 == 1 || arg1 == 0)\n        win_maximise(arg1 ? 2 : 0);\n      usleep(1000);\n    when 11: child_write(win_is_iconic() ? \"\\e[2t\" : \"\\e[1t\", 4);\n    when 13: {\n      int x, y;\n      win_get_scrpos(&x, &y, arg1 == 2);\n      child_printf(\"\\e[3;%u;%ut\", (ushort)x, (ushort)y);\n    }\n    when 14: {\n      int height, width;\n      win_get_pixels(&height, &width, arg1 == 2);\n      child_printf(\"\\e[4;%d;%dt\", height, width);\n    }\n    when 15: {\n      int w, h;\n      search_monitors(&w, &h, 0, false, 0);\n      child_printf(\"\\e[5;%d;%dt\", h, w);\n    }\n    when 16: child_printf(\"\\e[6;%d;%dt\", cell_height, cell_width);\n    when 18: child_printf(\"\\e[8;%d;%dt\", term.rows, term.cols);\n    when 19: {\n#ifdef size_of_monitor_only\n#warning not what xterm reports\n      int rows, cols;\n      win_get_screen_chars(&rows, &cols);\n      child_printf(\"\\e[9;%d;%dt\", rows, cols);\n#else\n      int w, h;\n      search_monitors(&w, &h, 0, false, 0);\n      child_printf(\"\\e[9;%d;%dt\", h / cell_height, w / cell_width);\n#endif\n    }\n    when 22:\n      if (arg1 == 0 || arg1 == 2)\n        win_save_title();\n    when 23:\n      if (arg1 == 0 || arg1 == 2)\n        win_restore_title();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,6 +51,7 @@\n         win_maximise(0);\n         win_set_chars(rows0, cols0);\n       }\n+      usleep(1000);\n     }\n     when 10:\n       if (term.csi_argc != 2)\n@@ -62,6 +63,7 @@\n         win_maximise(-2);\n       else if (arg1 == 1 || arg1 == 0)\n         win_maximise(arg1 ? 2 : 0);\n+      usleep(1000);\n     when 11: child_write(win_is_iconic() ? \"\\e[2t\" : \"\\e[1t\", 4);\n     when 13: {\n       int x, y;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      usleep(1000);",
                "      usleep(1000);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-27596",
        "func_name": "OpenSIPS/opensips/stream_process",
        "description": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.8 and 3.2.5, OpenSIPS crashes when a malformed SDP body is sent multiple times to an OpenSIPS configuration that makes use of the `stream_process` function. This issue was discovered during coverage guided fuzzing of the function `codec_delete_except_re`. By abusing this vulnerability, an attacker is able to crash the server. It affects configurations containing functions that rely on the affected code, such as the function `codec_delete_except_re`. This issue has been fixed in version 3.1.8 and 3.2.5.",
        "git_url": "https://github.com/OpenSIPS/opensips/commit/dd051f8ed5ae3347fb1d556ced3c97822c9d8450",
        "commit_title": "[sipmsgops] fix codec_delete_XX() parsing",
        "commit_text": " Issue discovered during OpenSIPS Security Audit 2021/2022, by Alfred Farrugia & Sandro Gauci (Enable Security)  https://github.com/OpenSIPS/opensips/security/advisories/GHSA-3ghx-j39m-cw4f",
        "func_before": "static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\t\tstr * s, str* ss, regex_t* re, int op,int description)\n{\n\tstatic sdp_payload_attr_t static_payloads[] = {\n\t/* as per http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xml */\n\t{ NULL,0,{ \"0\",1},{\"PCMU\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 0 - PCMU/8000  */\n\t{ NULL,0,{ \"3\",1},{ \"GSM\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 3 -  GSM/8000  */\n\t{ NULL,0,{ \"4\",1},{\"G723\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 4 - G723/8000  */\n\t{ NULL,0,{ \"5\",1},{\"DVI4\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 5 - DVI4/8000  */\n\t{ NULL,0,{ \"6\",1},{\"DVI4\",4},{\"16000\",5},{NULL,0},{NULL,0} },   /* 6 - DVI4/16000 */\n\t{ NULL,0,{ \"7\",1},{ \"LPC\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 7 -  LPC/8000  */\n\t{ NULL,0,{ \"8\",1},{\"PCMA\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 8 - PCMA/8000  */\n\t{ NULL,0,{ \"9\",1},{\"G722\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 9 - G722/8000  */\n\t{ NULL,0,{\"10\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*10 -  L16/44100 */\n\t{ NULL,0,{\"11\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*11 -  L16/44100 */\n\t{ NULL,0,{\"12\",2},{\"QCELP\",5},{\"8000\",4},{NULL,0},{NULL,0} },   /*12 -QCELP/8000  */\n\t{ NULL,0,{\"13\",2},{  \"CN\",2},{ \"8000\",4},{NULL,0},{NULL,0} },   /*13 -   CN/8000  */\n\t{ NULL,0,{\"14\",2},{ \"MPA\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*14 -  MPA/90000 */\n\t{ NULL,0,{\"15\",2},{\"G728\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*15 - G728/8000  */\n\t{ NULL,0,{\"16\",2},{\"DVI4\",4},{\"11025\",5},{NULL,0},{NULL,0} },   /*16 - DVI4/11025 */\n\t{ NULL,0,{\"17\",2},{\"DVI4\",4},{\"22050\",5},{NULL,0},{NULL,0} },   /*17 - DVI4/22050 */\n\t{ NULL,0,{\"18\",2},{\"G729\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*18 - G729/8000  */\n\t{ NULL,0,{\"25\",2},{\"CelB\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*25 - CelB/8000  */\n\t{ NULL,0,{\"26\",2},{\"JPEG\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*26 - JPEG/90000 */\n\t{ NULL,0,{\"28\",2},{  \"nv\",2},{\"90000\",5},{NULL,0},{NULL,0} },   /*28 -   nv/90000 */\n\t{ NULL,0,{\"31\",2},{\"H261\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*31 - H261/90000 */\n\t{ NULL,0,{\"32\",2},{ \"MPV\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*32 -  MPV/90000 */\n\t{ NULL,0,{\"33\",2},{\"MP2T\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*33 - MP2T/90000 */\n\t{ NULL,0,{\"34\",2},{\"H263\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*34 - H263/90000 */\n\t{ NULL,0,{\"t38\",3},{\"t38\",3},{     \"\",0},{NULL,0},{NULL,0} },   /*T38- fax        */\n\t{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }\n\t};\n\tsdp_payload_attr_t *payload;\n\tchar *cur, *tmp, *buff, temp;\n\tstruct lump * lmp;\n\tstr found;\n\tint ret, i,match, buff_len, is_static;\n\tregmatch_t pmatch;\n\n\n\tlmp = get_associated_lump(msg, cell);\n\tif( lmp == NULL)\n\t{\n\t\tLM_ERR(\"There is no lump for this sdp cell\\n\");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\n\tbuff_len = 0;\n\tret = 0;\n\n\tbuff = pkg_malloc(lmp->len+1);\n\tif( buff == NULL)\n\t{\n\t\tLM_ERR(\"Out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\t/* search through each payload */\n\tis_static = 0;\n\tpayload = cell->payload_attr;\n\n\twhile(payload)\n\t{\n\t\tif( payload->rtp_enc.s == NULL\n\t\t || (payload->rtp_clock.s == NULL && ss != NULL)\n\t\t || payload->rtp_payload.s == NULL)\n\t\t{\n\t\t\tgoto next_payload;\n\t\t}\n\n\t\tmatch = 0;\n\n\t\tif( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )\n\t\t{\n\t\t\t/* try to match a regexp */\n\t\t\tif (is_static) {\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t} else {\n\t\t\t\ttemp = payload->rtp_enc.s[payload->rtp_enc.len];\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = 0;\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = temp;\n\t\t\t}\n\t\t}\n\n\t\tif( description == DESC_REGEXP_COMPLEMENT)\n\t\t\tmatch = !match;\n\n\t\tif( description == DESC_NAME  )\n\t\t{\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\tpayload->rtp_enc.len) == 0;\n\t\t}\n\n\t\tif( description == DESC_NAME_AND_CLOCK)\n\t\t{\n\t\t\t/* try to match name and clock if there is one */\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\n\t\t\t\tpayload->rtp_enc.len) == 0\n\t\t\t&&\n\t\t\t(ss == NULL || ( ss->len == payload->rtp_clock.len &&\n\t\t\tstrncasecmp( ss->s, payload->rtp_clock.s ,\n\t\t\t\tpayload->rtp_clock.len) == 0\n\t\t\t) );\n\t\t}\n\n\t\t/* if found, search its index in the m= line */\n\t\tif (match) {\n\n\t\t\tmatch = 0;\n\n\t\t\tcur = lmp->u.value;\n\t\t\twhile( !match && cur < lmp->u.value + lmp->len)\n\t\t\t{\n\t\t\t\t/* find the end of the number */\n\t\t\t\tfound.s = cur;\n\n\t\t\t\twhile(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )\n\t\t\t\t\tcur++;\n\n\t\t\t\tfound.len = cur - found.s;\n\n\t\t\t\t/* does it matches payload number */\n\t\t\t\tif ( found.len == payload->rtp_payload.len &&\n\t\t\t\tstrncmp( found.s,payload->rtp_payload.s,found.len) == 0) {\n\t\t\t\t\tmatch = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* continue on searching => skip spaces\n\t\t\t\t\t   if there still are any */\n\t\t\t\t\twhile( cur < lmp->u.value + lmp->len && * cur == ' '  )\n\t\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* have we found both payload and index */\n\t\t\tif (match) {\n\n\t\t\t\tif(op == FIND)\n\t\t\t\t{\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif( op == DELETE && !is_static )\n\t\t\t\t{\n\t\t\t\t\t/* find the full 'a=...' entry */\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\t/* take the previous whitespaces as well */\n\t\t\t\t\twhile (found.s > lmp->u.value && *(found.s - 1) == ' ') {\n\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* when trimming the very last payload, avoid trailing ws */\n\t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n\t\t\t\t\t\ttmp = found.s;\n\t\t\t\t\t\twhile (*(--tmp) == ' ') {\n\t\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* delete the string and update iterators */\n\t\t\t\t\tfor(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )\n\t\t\t\t\t\t*tmp  = *(tmp+found.len);\n\n\t\t\t\t\t//cur -= found.len;\n\t\t\t\t\tlmp->len -= found.len;\n\t\t\t\t}\n\n\t\t\t\t/* add the deleted number into a buffer to be addded later */\n\t\t\t\tif( op == ADD_TO_FRONT  || op == ADD_TO_BACK)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&buff[buff_len],\" \",1);\n\t\t\t\t\tbuff_len++;\n\n\t\t\t\t\tmemcpy(&buff[buff_len],payload->rtp_payload.s,\n\t\t\t\t\t\tpayload->rtp_payload.len);\n\n\t\t\t\t\tbuff_len += payload->rtp_payload.len;\n\t\t\t\t}\n\n\t\t\t\tret = 1;\n\t\t\t}\n\n\t\t}\n\n\t\t/* next payload */\n\tnext_payload:\n\t\tif (!is_static) {\n\t\t\tpayload = payload->next;\n\t\t\tif (payload==NULL) {\n\t\t\t\tpayload = static_payloads;\n\t\t\t\tis_static = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpayload ++;\n\t\t\tif (payload->rtp_payload.s==NULL)\n\t\t\t\tpayload=NULL;\n\t\t}\n\t}\n\n\n\tif( op == ADD_TO_FRONT && buff_len >0 )\n\t{\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor( i = lmp->len -1 ; i>=0;i--)\n\t\t\tlmp->u.value[i+buff_len] = lmp->u.value[i];\n\n\t\tmemcpy(lmp->u.value,buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\tif( op == ADD_TO_BACK && buff_len >0 )\n\t{\n\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tmemcpy(&lmp->u.value[lmp->len],buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\t/* if we ended up with a 0-length lump, then it means that all payloads\n\t * have been deleted, therefore we need to disable the media stream */\n\tif (lmp->len == 0) {\n\t\t/* replace the media port with 0 - we also replace the spaces before\n\t\t * and after the port, to make sure we have a larger buffer */\n\t\tlmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);\n\t\tif (!lmp) {\n\t\t\tLM_ERR(\"could not add lump to disable stream!\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\ttmp = pkg_malloc(3);\n\t\tif (!tmp) {\n\t\t\tLM_ERR(\"oom for port 0\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(tmp, \" 0 \", 3);\n\t\tif (!insert_new_lump_after(lmp, tmp, 3, 0))\n\t\t\tLM_ERR(\"could not insert lump to disable stream!\\n\");\n\t}\n\nend:\n\tpkg_free(buff);\n\treturn ret;\n}",
        "func": "static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell,\n\t\t\tstr * s, str* ss, regex_t* re, int op,int description)\n{\n\tstatic sdp_payload_attr_t static_payloads[] = {\n\t/* as per http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xml */\n\t{ NULL,0,{ \"0\",1},{\"PCMU\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 0 - PCMU/8000  */\n\t{ NULL,0,{ \"3\",1},{ \"GSM\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 3 -  GSM/8000  */\n\t{ NULL,0,{ \"4\",1},{\"G723\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 4 - G723/8000  */\n\t{ NULL,0,{ \"5\",1},{\"DVI4\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 5 - DVI4/8000  */\n\t{ NULL,0,{ \"6\",1},{\"DVI4\",4},{\"16000\",5},{NULL,0},{NULL,0} },   /* 6 - DVI4/16000 */\n\t{ NULL,0,{ \"7\",1},{ \"LPC\",3},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 7 -  LPC/8000  */\n\t{ NULL,0,{ \"8\",1},{\"PCMA\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 8 - PCMA/8000  */\n\t{ NULL,0,{ \"9\",1},{\"G722\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /* 9 - G722/8000  */\n\t{ NULL,0,{\"10\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*10 -  L16/44100 */\n\t{ NULL,0,{\"11\",2},{ \"L16\",3},{\"44100\",5},{NULL,0},{NULL,0} },   /*11 -  L16/44100 */\n\t{ NULL,0,{\"12\",2},{\"QCELP\",5},{\"8000\",4},{NULL,0},{NULL,0} },   /*12 -QCELP/8000  */\n\t{ NULL,0,{\"13\",2},{  \"CN\",2},{ \"8000\",4},{NULL,0},{NULL,0} },   /*13 -   CN/8000  */\n\t{ NULL,0,{\"14\",2},{ \"MPA\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*14 -  MPA/90000 */\n\t{ NULL,0,{\"15\",2},{\"G728\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*15 - G728/8000  */\n\t{ NULL,0,{\"16\",2},{\"DVI4\",4},{\"11025\",5},{NULL,0},{NULL,0} },   /*16 - DVI4/11025 */\n\t{ NULL,0,{\"17\",2},{\"DVI4\",4},{\"22050\",5},{NULL,0},{NULL,0} },   /*17 - DVI4/22050 */\n\t{ NULL,0,{\"18\",2},{\"G729\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*18 - G729/8000  */\n\t{ NULL,0,{\"25\",2},{\"CelB\",4},{ \"8000\",4},{NULL,0},{NULL,0} },   /*25 - CelB/8000  */\n\t{ NULL,0,{\"26\",2},{\"JPEG\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*26 - JPEG/90000 */\n\t{ NULL,0,{\"28\",2},{  \"nv\",2},{\"90000\",5},{NULL,0},{NULL,0} },   /*28 -   nv/90000 */\n\t{ NULL,0,{\"31\",2},{\"H261\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*31 - H261/90000 */\n\t{ NULL,0,{\"32\",2},{ \"MPV\",3},{\"90000\",5},{NULL,0},{NULL,0} },   /*32 -  MPV/90000 */\n\t{ NULL,0,{\"33\",2},{\"MP2T\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*33 - MP2T/90000 */\n\t{ NULL,0,{\"34\",2},{\"H263\",4},{\"90000\",5},{NULL,0},{NULL,0} },   /*34 - H263/90000 */\n\t{ NULL,0,{\"t38\",3},{\"t38\",3},{     \"\",0},{NULL,0},{NULL,0} },   /*T38- fax        */\n\t{ NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} }\n\t};\n\tsdp_payload_attr_t *payload;\n\tchar *cur, *tmp, *buff, temp;\n\tstruct lump * lmp;\n\tstr found;\n\tint ret, i,match, buff_len, is_static;\n\tregmatch_t pmatch;\n\n\n\tlmp = get_associated_lump(msg, cell);\n\tif( lmp == NULL)\n\t{\n\t\tLM_ERR(\"There is no lump for this sdp cell\\n\");\n\t\treturn -1;\n\t}\n\n\t/* is stream deleted ?? */\n\tif (lmp->len == 0)\n\t\treturn -1;\n\n\n\tbuff_len = 0;\n\tret = 0;\n\n\tbuff = pkg_malloc(lmp->len+1);\n\tif( buff == NULL)\n\t{\n\t\tLM_ERR(\"Out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\t/* search through each payload */\n\tis_static = 0;\n\tpayload = cell->payload_attr;\n\n\twhile(payload)\n\t{\n\t\tif( payload->rtp_enc.s == NULL\n\t\t || (payload->rtp_clock.s == NULL && ss != NULL)\n\t\t || payload->rtp_payload.s == NULL)\n\t\t{\n\t\t\tgoto next_payload;\n\t\t}\n\n\t\tmatch = 0;\n\n\t\tif( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT )\n\t\t{\n\t\t\t/* try to match a regexp */\n\t\t\tif (is_static) {\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t} else {\n\t\t\t\ttemp = payload->rtp_enc.s[payload->rtp_enc.len];\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = 0;\n\t\t\t\tmatch = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0;\n\t\t\t\tpayload->rtp_enc.s[payload->rtp_enc.len] = temp;\n\t\t\t}\n\t\t}\n\n\t\tif( description == DESC_REGEXP_COMPLEMENT)\n\t\t\tmatch = !match;\n\n\t\tif( description == DESC_NAME  )\n\t\t{\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\tpayload->rtp_enc.len) == 0;\n\t\t}\n\n\t\tif( description == DESC_NAME_AND_CLOCK)\n\t\t{\n\t\t\t/* try to match name and clock if there is one */\n\t\t\tmatch = s->len == payload->rtp_enc.len &&\n\t\t\tstrncasecmp( s->s, payload->rtp_enc.s ,\n\t\t\t\tpayload->rtp_enc.len) == 0\n\t\t\t&&\n\t\t\t(ss == NULL || ( ss->len == payload->rtp_clock.len &&\n\t\t\tstrncasecmp( ss->s, payload->rtp_clock.s ,\n\t\t\t\tpayload->rtp_clock.len) == 0\n\t\t\t) );\n\t\t}\n\n\t\t/* if found, search its index in the m= line */\n\t\tif (match) {\n\n\t\t\tmatch = 0;\n\n\t\t\tcur = lmp->u.value;\n\t\t\twhile( !match && cur < lmp->u.value + lmp->len)\n\t\t\t{\n\t\t\t\t/* find the end of the number */\n\t\t\t\tfound.s = cur;\n\n\t\t\t\twhile(  cur < lmp->u.value + lmp->len &&  *cur != ' ' )\n\t\t\t\t\tcur++;\n\n\t\t\t\tfound.len = cur - found.s;\n\n\t\t\t\t/* does it matches payload number */\n\t\t\t\tif ( found.len == payload->rtp_payload.len &&\n\t\t\t\tstrncmp( found.s,payload->rtp_payload.s,found.len) == 0) {\n\t\t\t\t\tmatch = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* continue on searching => skip spaces\n\t\t\t\t\t   if there still are any */\n\t\t\t\t\twhile( cur < lmp->u.value + lmp->len && * cur == ' '  )\n\t\t\t\t\t\tcur++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* have we found both payload and index */\n\t\t\tif (match) {\n\n\t\t\t\tif(op == FIND)\n\t\t\t\t{\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif( op == DELETE && !is_static )\n\t\t\t\t{\n\t\t\t\t\t/* find the full 'a=...' entry */\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\n\t\t\t\t\tif( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tLM_ERR(\"Unable to add delete lump for a=\\n\");\n\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\t/* take the previous whitespaces as well */\n\t\t\t\t\twhile (found.s > lmp->u.value && *(found.s - 1) == ' ') {\n\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* when trimming the very last payload, avoid trailing ws */\n\t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n\t\t\t\t\t\ttmp = found.s;\n\t\t\t\t\t\twhile (tmp>lmp->u.value && *(--tmp) == ' ') {\n\t\t\t\t\t\t\tfound.s--;\n\t\t\t\t\t\t\tfound.len++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* delete the string and update iterators */\n\t\t\t\t\tfor(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ )\n\t\t\t\t\t\t*tmp  = *(tmp+found.len);\n\n\t\t\t\t\t//cur -= found.len;\n\t\t\t\t\tlmp->len -= found.len;\n\t\t\t\t}\n\n\t\t\t\t/* add the deleted number into a buffer to be addded later */\n\t\t\t\tif( op == ADD_TO_FRONT  || op == ADD_TO_BACK)\n\t\t\t\t{\n\t\t\t\t\tmemcpy(&buff[buff_len],\" \",1);\n\t\t\t\t\tbuff_len++;\n\n\t\t\t\t\tmemcpy(&buff[buff_len],payload->rtp_payload.s,\n\t\t\t\t\t\tpayload->rtp_payload.len);\n\n\t\t\t\t\tbuff_len += payload->rtp_payload.len;\n\t\t\t\t}\n\n\t\t\t\tret = 1;\n\t\t\t}\n\n\t\t}\n\n\t\t/* next payload */\n\tnext_payload:\n\t\tif (!is_static) {\n\t\t\tpayload = payload->next;\n\t\t\tif (payload==NULL) {\n\t\t\t\tpayload = static_payloads;\n\t\t\t\tis_static = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpayload ++;\n\t\t\tif (payload->rtp_payload.s==NULL)\n\t\t\t\tpayload=NULL;\n\t\t}\n\t}\n\n\n\tif( op == ADD_TO_FRONT && buff_len >0 )\n\t{\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tfor( i = lmp->len -1 ; i>=0;i--)\n\t\t\tlmp->u.value[i+buff_len] = lmp->u.value[i];\n\n\t\tmemcpy(lmp->u.value,buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\tif( op == ADD_TO_BACK && buff_len >0 )\n\t{\n\n\t\tlmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len);\n\t\tif(!lmp->u.value) {\n\t\t\tLM_ERR(\"No more pkg memory\\n\");\n\t\t\tret = -1;\n\t\t\tgoto end;\n\t\t}\n\n\t\tmemcpy(&lmp->u.value[lmp->len],buff,buff_len);\n\n\t\tlmp->len += buff_len;\n\n\t}\n\n\t/* if we ended up with a 0-length lump, then it means that all payloads\n\t * have been deleted, therefore we need to disable the media stream */\n\tif (lmp->len == 0) {\n\t\t/* replace the media port with 0 - we also replace the spaces before\n\t\t * and after the port, to make sure we have a larger buffer */\n\t\tlmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0);\n\t\tif (!lmp) {\n\t\t\tLM_ERR(\"could not add lump to disable stream!\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\ttmp = pkg_malloc(3);\n\t\tif (!tmp) {\n\t\t\tLM_ERR(\"oom for port 0\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(tmp, \" 0 \", 3);\n\t\tif (!insert_new_lump_after(lmp, tmp, 3, 0))\n\t\t\tLM_ERR(\"could not insert lump to disable stream!\\n\");\n\t}\n\nend:\n\tpkg_free(buff);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -176,7 +176,7 @@\n \t\t\t\t\t/* when trimming the very last payload, avoid trailing ws */\n \t\t\t\t\tif (cur == lmp->u.value + lmp->len) {\n \t\t\t\t\t\ttmp = found.s;\n-\t\t\t\t\t\twhile (*(--tmp) == ' ') {\n+\t\t\t\t\t\twhile (tmp>lmp->u.value && *(--tmp) == ' ') {\n \t\t\t\t\t\t\tfound.s--;\n \t\t\t\t\t\t\tfound.len++;\n \t\t\t\t\t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t\twhile (*(--tmp) == ' ') {"
            ],
            "added_lines": [
                "\t\t\t\t\t\twhile (tmp>lmp->u.value && *(--tmp) == ' ') {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28428",
        "func_name": "michaelrsweet/pdfio/stream_read",
        "description": "PDFio is a C library for reading and writing PDF files. In versions 1.1.0 and prior, a denial of service vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. This is different from CVE-2023-24808. A patch for this issue is available in version 1.1.1.",
        "git_url": "https://github.com/michaelrsweet/pdfio/commit/97d4955666779dc5b0665e15dd951a5c12426a31",
        "commit_title": "Fix potential denial-of-service in flate stream code.",
        "commit_text": "",
        "func_before": "static ssize_t\t\t\t\t// O - Number of bytes read or `-1` on error\nstream_read(pdfio_stream_t *st,\t\t// I - Stream\n            char           *buffer,\t// I - Buffer\n            size_t         bytes)\t// I - Number of bytes to read\n{\n  ssize_t\trbytes;\t\t\t// Bytes read\n\n\n  if (st->filter == PDFIO_FILTER_NONE)\n  {\n    // No filtering, but limit reads to the length of the stream...\n    if (bytes > st->remaining)\n      rbytes = _pdfioFileRead(st->pdf, buffer, st->remaining);\n    else\n      rbytes = _pdfioFileRead(st->pdf, buffer, bytes);\n\n    if (rbytes > 0)\n    {\n      st->remaining -= (size_t)rbytes;\n\n      if (st->crypto_cb)\n        (st->crypto_cb)(&st->crypto_ctx, (uint8_t *)buffer, (uint8_t *)buffer, (size_t)rbytes);\n    }\n\n    return (rbytes);\n  }\n  else if (st->filter == PDFIO_FILTER_FLATE)\n  {\n    // Deflate compression...\n    int\tstatus;\t\t\t\t// Status of decompression\n\n    if (st->predictor == _PDFIO_PREDICTOR_NONE)\n    {\n      // Decompress into the buffer...\n      PDFIO_DEBUG(\"stream_read: No predictor.\\n\");\n\n      if (st->flate.avail_in == 0)\n      {\n\t// Read more from the file...\n\tif (sizeof(st->cbuffer) > st->remaining)\n\t  rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\telse\n\t  rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\tif (rbytes <= 0)\n\t  return (-1);\t\t\t// End of file...\n\n\tif (st->crypto_cb)\n\t  rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\tst->remaining      -= (size_t)rbytes;\n\tst->flate.next_in  = (Bytef *)st->cbuffer;\n\tst->flate.avail_in = (uInt)rbytes;\n      }\n\n      st->flate.next_out  = (Bytef *)buffer;\n      st->flate.avail_out = (uInt)bytes;\n\n      if ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\treturn (-1);\n      }\n\n      return (st->flate.next_out - (Bytef *)buffer);\n    }\n    else if (st->predictor == _PDFIO_PREDICTOR_TIFF2)\n    {\n      size_t\t\tpbpixel = st->pbpixel,\n\t\t\t\t\t// Size of pixel in bytes\n      \t\t\tremaining = st->pbsize;\n\t\t\t\t\t// Remaining bytes\n      unsigned char\t*bufptr = (unsigned char *)buffer,\n\t\t\t\t\t// Pointer into buffer\n\t\t\t*bufsecond = (unsigned char *)buffer + pbpixel,\n\t\t\t\t\t// Pointer to second pixel in buffer\n\t\t\t*sptr = st->psbuffer;\n\t\t\t\t\t// Current (raw) line\n\n      PDFIO_DEBUG(\"stream_read: TIFF predictor 2.\\n\");\n\n      if (bytes < st->pbsize)\n      {\n        _pdfioFileError(st->pdf, \"Read buffer too small for stream.\");\n        return (-1);\n      }\n\n      st->flate.next_out  = (Bytef *)sptr;\n      st->flate.avail_out = (uInt)st->pbsize;\n\n      while (st->flate.avail_out > 0)\n      {\n\tif (st->flate.avail_in == 0)\n\t{\n\t  // Read more from the file...\n\t  if (sizeof(st->cbuffer) > st->remaining)\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\t  else\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\t  if (rbytes <= 0)\n\t    return (-1);\t\t// End of file...\n\n\t  if (st->crypto_cb)\n\t    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\t  st->remaining      -= (size_t)rbytes;\n\t  st->flate.next_in  = (Bytef *)st->cbuffer;\n\t  st->flate.avail_in = (uInt)rbytes;\n\t}\n\n\tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n\t{\n\t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\t  return (-1);\n\t}\n\telse if (status == Z_STREAM_END)\n\t  break;\n      }\n\n      if (st->flate.avail_out > 0)\n        return (-1);\t\t\t// Early end of stream\n\n      for (; bufptr < bufsecond; remaining --, sptr ++)\n\t*bufptr++ = *sptr;\n      for (; remaining > 0; remaining --, sptr ++, bufptr ++)\n\t*bufptr = *sptr + bufptr[-(int)pbpixel];\n\n      return ((ssize_t)st->pbsize);\n    }\n    else\n    {\n      // PNG predictor\n      size_t\t\tpbpixel = st->pbpixel,\n\t\t\t\t\t// Size of pixel in bytes\n      \t\t\tremaining = st->pbsize - 1;\n\t\t\t\t\t// Remaining bytes\n      unsigned char\t*bufptr = (unsigned char *)buffer,\n\t\t\t\t\t// Pointer into buffer\n\t\t\t*bufsecond = (unsigned char *)buffer + pbpixel,\n\t\t\t\t\t// Pointer to second pixel in buffer\n\t\t\t*sptr = st->psbuffer + 1,\n\t\t\t\t\t// Current (raw) line\n\t\t\t*pptr = st->prbuffer;\n\t\t\t\t\t// Previous (raw) line\n\n      PDFIO_DEBUG(\"stream_read: PNG predictor.\\n\");\n\n      if (bytes < (st->pbsize - 1))\n      {\n        _pdfioFileError(st->pdf, \"Read buffer too small for stream.\");\n        return (-1);\n      }\n\n      st->flate.next_out  = (Bytef *)sptr - 1;\n      st->flate.avail_out = (uInt)st->pbsize;\n\n      while (st->flate.avail_out > 0)\n      {\n\tif (st->flate.avail_in == 0)\n\t{\n\t  // Read more from the file...\n\t  if (sizeof(st->cbuffer) > st->remaining)\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\t  else\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\t  if (rbytes <= 0)\n\t    return (-1);\t\t// End of file...\n\n\t  if (st->crypto_cb)\n\t    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\t  st->remaining      -= (size_t)rbytes;\n\t  st->flate.next_in  = (Bytef *)st->cbuffer;\n\t  st->flate.avail_in = (uInt)rbytes;\n\t}\n\n\tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n\t{\n\t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\t  return (-1);\n\t}\n\telse if (status == Z_STREAM_END)\n\t  break;\n      }\n\n      if (st->flate.avail_out > 0)\n      {\n\t// Early end of stream\n        PDFIO_DEBUG(\"stream_read: Early EOF (remaining=%u, avail_in=%d, avail_out=%d, data_type=%d, next_in=<%02X%02X%02X%02X...>).\\n\", (unsigned)st->remaining, st->flate.avail_in, st->flate.avail_out, st->flate.data_type, st->flate.next_in[0], st->flate.next_in[1], st->flate.next_in[2], st->flate.next_in[3]);\n        return (-1);\n      }\n\n      // Apply predictor for this line\n      PDFIO_DEBUG(\"stream_read: Line %02X %02X %02X %02X %02X.\\n\", sptr[-1], sptr[0], sptr[0], sptr[2], sptr[3]);\n\n      switch (sptr[-1])\n      {\n        case 0 : // None\n        case 10 : // None (for buggy PDF writers)\n            memcpy(buffer, sptr, remaining);\n            break;\n        case 1 : // Sub\n        case 11 : // Sub (for buggy PDF writers)\n            for (; bufptr < bufsecond; remaining --, sptr ++)\n              *bufptr++ = *sptr;\n            for (; remaining > 0; remaining --, sptr ++, bufptr ++)\n              *bufptr = *sptr + bufptr[-(int)pbpixel];\n            break;\n        case 2 : // Up\n        case 12 : // Up (for buggy PDF writers)\n            for (; remaining > 0; remaining --, sptr ++, pptr ++)\n              *bufptr++ = *sptr + *pptr;\n            break;\n        case 3 : // Average\n        case 13 : // Average (for buggy PDF writers)\n\t    for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)\n\t      *bufptr++ = *sptr + *pptr / 2;\n\t    for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)\n\t      *bufptr = *sptr + (bufptr[-(int)pbpixel] + *pptr) / 2;\n            break;\n        case 4 : // Paeth\n        case 14 : // Paeth (for buggy PDF writers)\n            for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)\n              *bufptr++ = *sptr + stream_paeth(0, *pptr, 0);\n            for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)\n              *bufptr = *sptr + stream_paeth(bufptr[-(int)pbpixel], *pptr, pptr[-(int)pbpixel]);\n            break;\n\n        default :\n            _pdfioFileError(st->pdf, \"Bad PNG filter %d in data stream.\", sptr[-1]);\n            return (-1);\n      }\n\n      // Copy the computed line and swap buffers...\n      memcpy(st->prbuffer, buffer, st->pbsize - 1);\n\n      // Return the number of bytes we copied for this line...\n      return ((ssize_t)(st->pbsize - 1));\n    }\n  }\n\n  // If we get here something bad happened...\n  return (-1);\n}",
        "func": "static ssize_t\t\t\t\t// O - Number of bytes read or `-1` on error\nstream_read(pdfio_stream_t *st,\t\t// I - Stream\n            char           *buffer,\t// I - Buffer\n            size_t         bytes)\t// I - Number of bytes to read\n{\n  ssize_t\trbytes;\t\t\t// Bytes read\n  uInt\t\tavail_in, avail_out;\t// Previous flate values\n\n\n  if (st->filter == PDFIO_FILTER_NONE)\n  {\n    // No filtering, but limit reads to the length of the stream...\n    if (bytes > st->remaining)\n      rbytes = _pdfioFileRead(st->pdf, buffer, st->remaining);\n    else\n      rbytes = _pdfioFileRead(st->pdf, buffer, bytes);\n\n    if (rbytes > 0)\n    {\n      st->remaining -= (size_t)rbytes;\n\n      if (st->crypto_cb)\n        (st->crypto_cb)(&st->crypto_ctx, (uint8_t *)buffer, (uint8_t *)buffer, (size_t)rbytes);\n    }\n\n    return (rbytes);\n  }\n  else if (st->filter == PDFIO_FILTER_FLATE)\n  {\n    // Deflate compression...\n    int\tstatus;\t\t\t\t// Status of decompression\n\n    if (st->predictor == _PDFIO_PREDICTOR_NONE)\n    {\n      // Decompress into the buffer...\n      PDFIO_DEBUG(\"stream_read: No predictor.\\n\");\n\n      if (st->flate.avail_in == 0)\n      {\n\t// Read more from the file...\n\tif (sizeof(st->cbuffer) > st->remaining)\n\t  rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\telse\n\t  rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\tif (rbytes <= 0)\n\t  return (-1);\t\t\t// End of file...\n\n\tif (st->crypto_cb)\n\t  rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\tst->remaining      -= (size_t)rbytes;\n\tst->flate.next_in  = (Bytef *)st->cbuffer;\n\tst->flate.avail_in = (uInt)rbytes;\n      }\n\n      st->flate.next_out  = (Bytef *)buffer;\n      st->flate.avail_out = (uInt)bytes;\n\n      avail_in  = st->flate.avail_in;\n      avail_out = st->flate.avail_out;\n\n      if ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n      {\n\t_pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\treturn (-1);\n      }\n      else if (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out)\n      {\n\t_pdfioFileError(st->pdf, \"Corrupt stream data.\");\n\treturn (-1);\n      }\n\n      return (st->flate.next_out - (Bytef *)buffer);\n    }\n    else if (st->predictor == _PDFIO_PREDICTOR_TIFF2)\n    {\n      size_t\t\tpbpixel = st->pbpixel,\n\t\t\t\t\t// Size of pixel in bytes\n      \t\t\tremaining = st->pbsize;\n\t\t\t\t\t// Remaining bytes\n      unsigned char\t*bufptr = (unsigned char *)buffer,\n\t\t\t\t\t// Pointer into buffer\n\t\t\t*bufsecond = (unsigned char *)buffer + pbpixel,\n\t\t\t\t\t// Pointer to second pixel in buffer\n\t\t\t*sptr = st->psbuffer;\n\t\t\t\t\t// Current (raw) line\n\n      PDFIO_DEBUG(\"stream_read: TIFF predictor 2.\\n\");\n\n      if (bytes < st->pbsize)\n      {\n        _pdfioFileError(st->pdf, \"Read buffer too small for stream.\");\n        return (-1);\n      }\n\n      st->flate.next_out  = (Bytef *)sptr;\n      st->flate.avail_out = (uInt)st->pbsize;\n\n      while (st->flate.avail_out > 0)\n      {\n\tif (st->flate.avail_in == 0)\n\t{\n\t  // Read more from the file...\n\t  if (sizeof(st->cbuffer) > st->remaining)\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\t  else\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\t  if (rbytes <= 0)\n\t    return (-1);\t\t// End of file...\n\n\t  if (st->crypto_cb)\n\t    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\t  st->remaining      -= (size_t)rbytes;\n\t  st->flate.next_in  = (Bytef *)st->cbuffer;\n\t  st->flate.avail_in = (uInt)rbytes;\n\t}\n\n        avail_in  = st->flate.avail_in;\n        avail_out = st->flate.avail_out;\n\n\tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n\t{\n\t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\t  return (-1);\n\t}\n\telse if (status == Z_STREAM_END || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))\n\t  break;\n      }\n\n      if (st->flate.avail_out > 0)\n        return (-1);\t\t\t// Early end of stream\n\n      for (; bufptr < bufsecond; remaining --, sptr ++)\n\t*bufptr++ = *sptr;\n      for (; remaining > 0; remaining --, sptr ++, bufptr ++)\n\t*bufptr = *sptr + bufptr[-(int)pbpixel];\n\n      return ((ssize_t)st->pbsize);\n    }\n    else\n    {\n      // PNG predictor\n      size_t\t\tpbpixel = st->pbpixel,\n\t\t\t\t\t// Size of pixel in bytes\n      \t\t\tremaining = st->pbsize - 1;\n\t\t\t\t\t// Remaining bytes\n      unsigned char\t*bufptr = (unsigned char *)buffer,\n\t\t\t\t\t// Pointer into buffer\n\t\t\t*bufsecond = (unsigned char *)buffer + pbpixel,\n\t\t\t\t\t// Pointer to second pixel in buffer\n\t\t\t*sptr = st->psbuffer + 1,\n\t\t\t\t\t// Current (raw) line\n\t\t\t*pptr = st->prbuffer;\n\t\t\t\t\t// Previous (raw) line\n\n      PDFIO_DEBUG(\"stream_read: PNG predictor.\\n\");\n\n      if (bytes < (st->pbsize - 1))\n      {\n        _pdfioFileError(st->pdf, \"Read buffer too small for stream.\");\n        return (-1);\n      }\n\n      st->flate.next_out  = (Bytef *)sptr - 1;\n      st->flate.avail_out = (uInt)st->pbsize;\n\n      while (st->flate.avail_out > 0)\n      {\n\tif (st->flate.avail_in == 0)\n\t{\n\t  // Read more from the file...\n\t  if (sizeof(st->cbuffer) > st->remaining)\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);\n\t  else\n\t    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));\n\n\t  if (rbytes <= 0)\n\t    return (-1);\t\t// End of file...\n\n\t  if (st->crypto_cb)\n\t    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);\n\n\t  st->remaining      -= (size_t)rbytes;\n\t  st->flate.next_in  = (Bytef *)st->cbuffer;\n\t  st->flate.avail_in = (uInt)rbytes;\n\t}\n\n        avail_in  = st->flate.avail_in;\n        avail_out = st->flate.avail_out;\n\n\tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n\t{\n\t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n\t  return (-1);\n\t}\n\telse if (status == Z_STREAM_END || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))\n\t  break;\n      }\n\n      if (st->flate.avail_out > 0)\n      {\n\t// Early end of stream\n        PDFIO_DEBUG(\"stream_read: Early EOF (remaining=%u, avail_in=%d, avail_out=%d, data_type=%d, next_in=<%02X%02X%02X%02X...>).\\n\", (unsigned)st->remaining, st->flate.avail_in, st->flate.avail_out, st->flate.data_type, st->flate.next_in[0], st->flate.next_in[1], st->flate.next_in[2], st->flate.next_in[3]);\n        return (-1);\n      }\n\n      // Apply predictor for this line\n      PDFIO_DEBUG(\"stream_read: Line %02X %02X %02X %02X %02X.\\n\", sptr[-1], sptr[0], sptr[0], sptr[2], sptr[3]);\n\n      switch (sptr[-1])\n      {\n        case 0 : // None\n        case 10 : // None (for buggy PDF writers)\n            memcpy(buffer, sptr, remaining);\n            break;\n        case 1 : // Sub\n        case 11 : // Sub (for buggy PDF writers)\n            for (; bufptr < bufsecond; remaining --, sptr ++)\n              *bufptr++ = *sptr;\n            for (; remaining > 0; remaining --, sptr ++, bufptr ++)\n              *bufptr = *sptr + bufptr[-(int)pbpixel];\n            break;\n        case 2 : // Up\n        case 12 : // Up (for buggy PDF writers)\n            for (; remaining > 0; remaining --, sptr ++, pptr ++)\n              *bufptr++ = *sptr + *pptr;\n            break;\n        case 3 : // Average\n        case 13 : // Average (for buggy PDF writers)\n\t    for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)\n\t      *bufptr++ = *sptr + *pptr / 2;\n\t    for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)\n\t      *bufptr = *sptr + (bufptr[-(int)pbpixel] + *pptr) / 2;\n            break;\n        case 4 : // Paeth\n        case 14 : // Paeth (for buggy PDF writers)\n            for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)\n              *bufptr++ = *sptr + stream_paeth(0, *pptr, 0);\n            for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)\n              *bufptr = *sptr + stream_paeth(bufptr[-(int)pbpixel], *pptr, pptr[-(int)pbpixel]);\n            break;\n\n        default :\n            _pdfioFileError(st->pdf, \"Bad PNG filter %d in data stream.\", sptr[-1]);\n            return (-1);\n      }\n\n      // Copy the computed line and swap buffers...\n      memcpy(st->prbuffer, buffer, st->pbsize - 1);\n\n      // Return the number of bytes we copied for this line...\n      return ((ssize_t)(st->pbsize - 1));\n    }\n  }\n\n  // If we get here something bad happened...\n  return (-1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n             size_t         bytes)\t// I - Number of bytes to read\n {\n   ssize_t\trbytes;\t\t\t// Bytes read\n+  uInt\t\tavail_in, avail_out;\t// Previous flate values\n \n \n   if (st->filter == PDFIO_FILTER_NONE)\n@@ -56,9 +57,17 @@\n       st->flate.next_out  = (Bytef *)buffer;\n       st->flate.avail_out = (uInt)bytes;\n \n+      avail_in  = st->flate.avail_in;\n+      avail_out = st->flate.avail_out;\n+\n       if ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n       {\n \t_pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n+\treturn (-1);\n+      }\n+      else if (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out)\n+      {\n+\t_pdfioFileError(st->pdf, \"Corrupt stream data.\");\n \treturn (-1);\n       }\n \n@@ -109,12 +118,15 @@\n \t  st->flate.avail_in = (uInt)rbytes;\n \t}\n \n+        avail_in  = st->flate.avail_in;\n+        avail_out = st->flate.avail_out;\n+\n \tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n \t{\n \t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n \t  return (-1);\n \t}\n-\telse if (status == Z_STREAM_END)\n+\telse if (status == Z_STREAM_END || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))\n \t  break;\n       }\n \n@@ -176,12 +188,15 @@\n \t  st->flate.avail_in = (uInt)rbytes;\n \t}\n \n+        avail_in  = st->flate.avail_in;\n+        avail_out = st->flate.avail_out;\n+\n \tif ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)\n \t{\n \t  _pdfioFileError(st->pdf, \"Unable to decompress stream data: %s\", zstrerror(status));\n \t  return (-1);\n \t}\n-\telse if (status == Z_STREAM_END)\n+\telse if (status == Z_STREAM_END || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))\n \t  break;\n       }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\telse if (status == Z_STREAM_END)",
                "\telse if (status == Z_STREAM_END)"
            ],
            "added_lines": [
                "  uInt\t\tavail_in, avail_out;\t// Previous flate values",
                "      avail_in  = st->flate.avail_in;",
                "      avail_out = st->flate.avail_out;",
                "",
                "\treturn (-1);",
                "      }",
                "      else if (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out)",
                "      {",
                "\t_pdfioFileError(st->pdf, \"Corrupt stream data.\");",
                "        avail_in  = st->flate.avail_in;",
                "        avail_out = st->flate.avail_out;",
                "",
                "\telse if (status == Z_STREAM_END || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))",
                "        avail_in  = st->flate.avail_in;",
                "        avail_out = st->flate.avail_out;",
                "",
                "\telse if (status == Z_STREAM_END || (avail_in == st->flate.avail_in && avail_out == st->flate.avail_out))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-29573",
        "func_name": "axiomatic-systems/Bento4/AP4_TrunAtom::AP4_TrunAtom",
        "description": "Bento4 v1.6.0-639 was discovered to contain an out-of-memory bug in the mp4info component.",
        "git_url": "https://github.com/axiomatic-systems/Bento4/commit/c9f5d42a260ff76b768e06bfa400d8bd6be965a2",
        "commit_title": "fix #840",
        "commit_text": "",
        "func_before": "AP4_TrunAtom::AP4_TrunAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_TRUN, size, version, flags)\n{\n    if (size < AP4_FULL_ATOM_HEADER_SIZE + 4) {\n        return;\n    }\n    AP4_UI32 sample_count = 0;\n    stream.ReadUI32(sample_count);\n    AP4_Size bytes_left = size - AP4_FULL_ATOM_HEADER_SIZE - 4;\n\n    // read optional fields\n    int optional_fields_count = (int)ComputeOptionalFieldsCount(flags);\n    if (flags & AP4_TRUN_FLAG_DATA_OFFSET_PRESENT) {\n        AP4_UI32 offset = 0;\n        if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(offset))) {\n            return;\n        }\n        m_DataOffset = (AP4_SI32)offset;\n        if (optional_fields_count == 0) {\n            return;\n        }\n        --optional_fields_count;\n        bytes_left -= 4;\n    }\n    if (flags & AP4_TRUN_FLAG_FIRST_SAMPLE_FLAGS_PRESENT) {\n        if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_FirstSampleFlags))) {\n            return;\n        }\n        if (optional_fields_count == 0) {\n            return;\n        }\n        --optional_fields_count;\n        bytes_left -= 4;\n    }\n    \n    // discard unknown optional fields \n    for (int i=0; i<optional_fields_count; i++) {\n        AP4_UI32 discard;\n        if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(discard))) {\n            return;\n        }\n        bytes_left -= 4;\n    }\n    \n    int record_fields_count = (int)ComputeRecordFieldsCount(flags);\n    if (record_fields_count && ((bytes_left / (record_fields_count*4)) < sample_count)) {\n        // not enough data for all samples, the format is invalid\n        return;\n    }\n    if (AP4_FAILED(m_Entries.SetItemCount(sample_count))) {\n        return;\n    }\n    for (unsigned int i=0; i<sample_count; i++) {\n        if (flags & AP4_TRUN_FLAG_SAMPLE_DURATION_PRESENT) {\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_Entries[i].sample_duration))) {\n                return;;\n            }\n            --record_fields_count;\n            bytes_left -= 4;\n        }\n        if (flags & AP4_TRUN_FLAG_SAMPLE_SIZE_PRESENT) {\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_Entries[i].sample_size))) {\n                return;\n            }\n            --record_fields_count;\n            bytes_left -= 4;\n        }\n        if (flags & AP4_TRUN_FLAG_SAMPLE_FLAGS_PRESENT) {\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_Entries[i].sample_flags))) {\n                return;\n            }\n            --record_fields_count;\n            bytes_left -= 4;\n        }\n        if (flags & AP4_TRUN_FLAG_SAMPLE_COMPOSITION_TIME_OFFSET_PRESENT) {\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_Entries[i].sample_composition_time_offset))) {\n                return;\n            }\n            --record_fields_count;\n            bytes_left -= 4;\n        }\n    \n        // skip unknown fields \n        for (int j=0;j<record_fields_count; j++) {\n            AP4_UI32 discard;\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(discard))) {\n                return;\n            }\n            bytes_left -= 4;\n        }\n    }\n}",
        "func": "AP4_TrunAtom::AP4_TrunAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_TRUN, size, version, flags)\n{\n    if (size < AP4_FULL_ATOM_HEADER_SIZE + 4) {\n        return;\n    }\n    AP4_UI32 sample_count = 0;\n    stream.ReadUI32(sample_count);\n    AP4_Size bytes_left = size - AP4_FULL_ATOM_HEADER_SIZE - 4;\n\n    // read optional fields\n    int optional_fields_count = (int)ComputeOptionalFieldsCount(flags);\n    if (flags & AP4_TRUN_FLAG_DATA_OFFSET_PRESENT) {\n        AP4_UI32 offset = 0;\n        if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(offset))) {\n            return;\n        }\n        m_DataOffset = (AP4_SI32)offset;\n        if (optional_fields_count == 0) {\n            return;\n        }\n        --optional_fields_count;\n        bytes_left -= 4;\n    }\n    if (flags & AP4_TRUN_FLAG_FIRST_SAMPLE_FLAGS_PRESENT) {\n        if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_FirstSampleFlags))) {\n            return;\n        }\n        if (optional_fields_count == 0) {\n            return;\n        }\n        --optional_fields_count;\n        bytes_left -= 4;\n    }\n    \n    // discard unknown optional fields \n    for (int i=0; i<optional_fields_count; i++) {\n        AP4_UI32 discard;\n        if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(discard))) {\n            return;\n        }\n        bytes_left -= 4;\n    }\n    \n    int record_fields_count = (int)ComputeRecordFieldsCount(flags);\n    if (!record_fields_count) {\n        // nothing to read\n        return;\n    }\n\n    if ((bytes_left / (record_fields_count*4)) < sample_count) {\n        // not enough data for all samples, the format is invalid\n        return;\n    }\n\n    if (AP4_FAILED(m_Entries.SetItemCount(sample_count))) {\n        return;\n    }\n        \n    for (unsigned int i=0; i<sample_count; i++) {\n        if (flags & AP4_TRUN_FLAG_SAMPLE_DURATION_PRESENT) {\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_Entries[i].sample_duration))) {\n                return;;\n            }\n            --record_fields_count;\n            bytes_left -= 4;\n        }\n        if (flags & AP4_TRUN_FLAG_SAMPLE_SIZE_PRESENT) {\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_Entries[i].sample_size))) {\n                return;\n            }\n            --record_fields_count;\n            bytes_left -= 4;\n        }\n        if (flags & AP4_TRUN_FLAG_SAMPLE_FLAGS_PRESENT) {\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_Entries[i].sample_flags))) {\n                return;\n            }\n            --record_fields_count;\n            bytes_left -= 4;\n        }\n        if (flags & AP4_TRUN_FLAG_SAMPLE_COMPOSITION_TIME_OFFSET_PRESENT) {\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_Entries[i].sample_composition_time_offset))) {\n                return;\n            }\n            --record_fields_count;\n            bytes_left -= 4;\n        }\n    \n        // skip unknown fields \n        for (int j=0;j<record_fields_count; j++) {\n            AP4_UI32 discard;\n            if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(discard))) {\n                return;\n            }\n            bytes_left -= 4;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,13 +46,20 @@\n     }\n     \n     int record_fields_count = (int)ComputeRecordFieldsCount(flags);\n-    if (record_fields_count && ((bytes_left / (record_fields_count*4)) < sample_count)) {\n+    if (!record_fields_count) {\n+        // nothing to read\n+        return;\n+    }\n+\n+    if ((bytes_left / (record_fields_count*4)) < sample_count) {\n         // not enough data for all samples, the format is invalid\n         return;\n     }\n+\n     if (AP4_FAILED(m_Entries.SetItemCount(sample_count))) {\n         return;\n     }\n+        \n     for (unsigned int i=0; i<sample_count; i++) {\n         if (flags & AP4_TRUN_FLAG_SAMPLE_DURATION_PRESENT) {\n             if (bytes_left < 4 || AP4_FAILED(stream.ReadUI32(m_Entries[i].sample_duration))) {",
        "diff_line_info": {
            "deleted_lines": [
                "    if (record_fields_count && ((bytes_left / (record_fields_count*4)) < sample_count)) {"
            ],
            "added_lines": [
                "    if (!record_fields_count) {",
                "        // nothing to read",
                "        return;",
                "    }",
                "",
                "    if ((bytes_left / (record_fields_count*4)) < sample_count) {",
                "",
                "        "
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2650",
        "func_name": "openssl/OBJ_obj2txt",
        "description": "Issue summary: Processing some specially crafted ASN.1 object identifiers or\ndata containing them may be very slow.\n\nImpact summary: Applications that use OBJ_obj2txt() directly, or use any of\nthe OpenSSL subsystems OCSP, PKCS7/SMIME, CMS, CMP/CRMF or TS with no message\nsize limit may experience notable to very long delays when processing those\nmessages, which may lead to a Denial of Service.\n\nAn OBJECT IDENTIFIER is composed of a series of numbers - sub-identifiers -\nmost of which have no size limit.  OBJ_obj2txt() may be used to translate\nan ASN.1 OBJECT IDENTIFIER given in DER encoding form (using the OpenSSL\ntype ASN1_OBJECT) to its canonical numeric text form, which are the\nsub-identifiers of the OBJECT IDENTIFIER in decimal form, separated by\nperiods.\n\nWhen one of the sub-identifiers in the OBJECT IDENTIFIER is very large\n(these are sizes that are seen as absurdly large, taking up tens or hundreds\nof KiBs), the translation to a decimal number in text may take a very long\ntime.  The time complexity is O(n^2) with 'n' being the size of the\nsub-identifiers in bytes (*).\n\nWith OpenSSL 3.0, support to fetch cryptographic algorithms using names /\nidentifiers in string form was introduced.  This includes using OBJECT\nIDENTIFIERs in canonical numeric text form as identifiers for fetching\nalgorithms.\n\nSuch OBJECT IDENTIFIERs may be received through the ASN.1 structure\nAlgorithmIdentifier, which is commonly used in multiple protocols to specify\nwhat cryptographic algorithm should be used to sign or verify, encrypt or\ndecrypt, or digest passed data.\n\nApplications that call OBJ_obj2txt() directly with untrusted data are\naffected, with any version of OpenSSL.  If the use is for the mere purpose\nof display, the severity is considered low.\n\nIn OpenSSL 3.0 and newer, this affects the subsystems OCSP, PKCS7/SMIME,\nCMS, CMP/CRMF or TS.  It also impacts anything that processes X.509\ncertificates, including simple things like verifying its signature.\n\nThe impact on TLS is relatively low, because all versions of OpenSSL have a\n100KiB limit on the peer's certificate chain.  Additionally, this only\nimpacts clients, or servers that have explicitly enabled client\nauthentication.\n\nIn OpenSSL 1.1.1 and 1.0.2, this only affects displaying diverse objects,\nsuch as X.509 certificates.  This is assumed to not happen in such a way\nthat it would cause a Denial of Service, so these versions are considered\nnot affected by this issue in such a way that it would be cause for concern,\nand the severity is therefore considered low.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=db779b0e10b047f2585615e0b8f2acdf21f8544a",
        "commit_title": "",
        "commit_text": "Restrict the size of OBJECT IDENTIFIERs that OBJ_obj2txt will translate  OBJ_obj2txt() would translate any size OBJECT IDENTIFIER to canonical numeric text form.  For gigantic sub-identifiers, this would take a very long time, the time complexity being O(n^2) where n is the size of that sub-identifier.  To mitigate this, a restriction on the size that OBJ_obj2txt() will translate to canonical numeric text form is added, based on RFC 2578 (STD 58), which says this:  > 3.5. OBJECT IDENTIFIER values > > An OBJECT IDENTIFIER value is an ordered list of non-negative numbers. > For the SMIv2, each number in the list is referred to as a sub-identifier, > there are at most 128 sub-identifiers in a value, and each sub-identifier > has a maximum value of 2^32-1 (4294967295 decimal).  Fixes otc/security#96 Fixes CVE-2023-2650  ",
        "func_before": "int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n{\n    int i, n = 0, len, nid, first, use_bn;\n    BIGNUM *bl;\n    unsigned long l;\n    const unsigned char *p;\n    char tbuf[DECIMAL_SIZE(i) + DECIMAL_SIZE(l) + 2];\n    const char *s;\n\n    /* Ensure that, at every state, |buf| is NUL-terminated. */\n    if (buf != NULL && buf_len > 0)\n        buf[0] = '\\0';\n\n    if (a == NULL || a->data == NULL)\n        return 0;\n\n    if (!no_name && (nid = OBJ_obj2nid(a)) != NID_undef) {\n        s = OBJ_nid2ln(nid);\n        if (s == NULL)\n            s = OBJ_nid2sn(nid);\n        if (s != NULL) {\n            if (buf != NULL)\n                OPENSSL_strlcpy(buf, s, buf_len);\n            return (int)strlen(s);\n        }\n    }\n\n    len = a->length;\n    p = a->data;\n\n    first = 1;\n    bl = NULL;\n\n    while (len > 0) {\n        l = 0;\n        use_bn = 0;\n        for (;;) {\n            unsigned char c = *p++;\n            len--;\n            if ((len == 0) && (c & 0x80))\n                goto err;\n            if (use_bn) {\n                if (!BN_add_word(bl, c & 0x7f))\n                    goto err;\n            } else\n                l |= c & 0x7f;\n            if (!(c & 0x80))\n                break;\n            if (!use_bn && (l > (ULONG_MAX >> 7L))) {\n                if (bl == NULL && (bl = BN_new()) == NULL)\n                    goto err;\n                if (!BN_set_word(bl, l))\n                    goto err;\n                use_bn = 1;\n            }\n            if (use_bn) {\n                if (!BN_lshift(bl, bl, 7))\n                    goto err;\n            } else\n                l <<= 7L;\n        }\n\n        if (first) {\n            first = 0;\n            if (l >= 80) {\n                i = 2;\n                if (use_bn) {\n                    if (!BN_sub_word(bl, 80))\n                        goto err;\n                } else\n                    l -= 80;\n            } else {\n                i = (int)(l / 40);\n                l -= (long)(i * 40);\n            }\n            if (buf && (buf_len > 1)) {\n                *buf++ = i + '0';\n                *buf = '\\0';\n                buf_len--;\n            }\n            n++;\n        }\n\n        if (use_bn) {\n            char *bndec;\n            bndec = BN_bn2dec(bl);\n            if (!bndec)\n                goto err;\n            i = strlen(bndec);\n            if (buf) {\n                if (buf_len > 1) {\n                    *buf++ = '.';\n                    *buf = '\\0';\n                    buf_len--;\n                }\n                OPENSSL_strlcpy(buf, bndec, buf_len);\n                if (i > buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n++;\n            n += i;\n            OPENSSL_free(bndec);\n        } else {\n            BIO_snprintf(tbuf, sizeof(tbuf), \".%lu\", l);\n            i = strlen(tbuf);\n            if (buf && (buf_len > 0)) {\n                OPENSSL_strlcpy(buf, tbuf, buf_len);\n                if (i > buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n += i;\n            l = 0;\n        }\n    }\n\n    BN_free(bl);\n    return n;\n\n err:\n    BN_free(bl);\n    return -1;\n}",
        "func": "int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n{\n    int i, n = 0, len, nid, first, use_bn;\n    BIGNUM *bl;\n    unsigned long l;\n    const unsigned char *p;\n    char tbuf[DECIMAL_SIZE(i) + DECIMAL_SIZE(l) + 2];\n    const char *s;\n\n    /* Ensure that, at every state, |buf| is NUL-terminated. */\n    if (buf != NULL && buf_len > 0)\n        buf[0] = '\\0';\n\n    if (a == NULL || a->data == NULL)\n        return 0;\n\n    if (!no_name && (nid = OBJ_obj2nid(a)) != NID_undef) {\n        s = OBJ_nid2ln(nid);\n        if (s == NULL)\n            s = OBJ_nid2sn(nid);\n        if (s != NULL) {\n            if (buf != NULL)\n                OPENSSL_strlcpy(buf, s, buf_len);\n            return (int)strlen(s);\n        }\n    }\n\n    len = a->length;\n    p = a->data;\n\n    first = 1;\n    bl = NULL;\n\n    /*\n     * RFC 2578 (STD 58) says this about OBJECT IDENTIFIERs:\n     *\n     * > 3.5. OBJECT IDENTIFIER values\n     * >\n     * > An OBJECT IDENTIFIER value is an ordered list of non-negative\n     * > numbers. For the SMIv2, each number in the list is referred to as a\n     * > sub-identifier, there are at most 128 sub-identifiers in a value,\n     * > and each sub-identifier has a maximum value of 2^32-1 (4294967295\n     * > decimal).\n     *\n     * So a legitimate OID according to this RFC is at most (32 * 128 / 7),\n     * i.e. 586 bytes long.\n     *\n     * Ref: https://datatracker.ietf.org/doc/html/rfc2578#section-3.5\n     */\n    if (len > 586)\n        goto err;\n\n    while (len > 0) {\n        l = 0;\n        use_bn = 0;\n        for (;;) {\n            unsigned char c = *p++;\n            len--;\n            if ((len == 0) && (c & 0x80))\n                goto err;\n            if (use_bn) {\n                if (!BN_add_word(bl, c & 0x7f))\n                    goto err;\n            } else\n                l |= c & 0x7f;\n            if (!(c & 0x80))\n                break;\n            if (!use_bn && (l > (ULONG_MAX >> 7L))) {\n                if (bl == NULL && (bl = BN_new()) == NULL)\n                    goto err;\n                if (!BN_set_word(bl, l))\n                    goto err;\n                use_bn = 1;\n            }\n            if (use_bn) {\n                if (!BN_lshift(bl, bl, 7))\n                    goto err;\n            } else\n                l <<= 7L;\n        }\n\n        if (first) {\n            first = 0;\n            if (l >= 80) {\n                i = 2;\n                if (use_bn) {\n                    if (!BN_sub_word(bl, 80))\n                        goto err;\n                } else\n                    l -= 80;\n            } else {\n                i = (int)(l / 40);\n                l -= (long)(i * 40);\n            }\n            if (buf && (buf_len > 1)) {\n                *buf++ = i + '0';\n                *buf = '\\0';\n                buf_len--;\n            }\n            n++;\n        }\n\n        if (use_bn) {\n            char *bndec;\n            bndec = BN_bn2dec(bl);\n            if (!bndec)\n                goto err;\n            i = strlen(bndec);\n            if (buf) {\n                if (buf_len > 1) {\n                    *buf++ = '.';\n                    *buf = '\\0';\n                    buf_len--;\n                }\n                OPENSSL_strlcpy(buf, bndec, buf_len);\n                if (i > buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n++;\n            n += i;\n            OPENSSL_free(bndec);\n        } else {\n            BIO_snprintf(tbuf, sizeof(tbuf), \".%lu\", l);\n            i = strlen(tbuf);\n            if (buf && (buf_len > 0)) {\n                OPENSSL_strlcpy(buf, tbuf, buf_len);\n                if (i > buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n += i;\n            l = 0;\n        }\n    }\n\n    BN_free(bl);\n    return n;\n\n err:\n    BN_free(bl);\n    return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,25 @@\n \n     first = 1;\n     bl = NULL;\n+\n+    /*\n+     * RFC 2578 (STD 58) says this about OBJECT IDENTIFIERs:\n+     *\n+     * > 3.5. OBJECT IDENTIFIER values\n+     * >\n+     * > An OBJECT IDENTIFIER value is an ordered list of non-negative\n+     * > numbers. For the SMIv2, each number in the list is referred to as a\n+     * > sub-identifier, there are at most 128 sub-identifiers in a value,\n+     * > and each sub-identifier has a maximum value of 2^32-1 (4294967295\n+     * > decimal).\n+     *\n+     * So a legitimate OID according to this RFC is at most (32 * 128 / 7),\n+     * i.e. 586 bytes long.\n+     *\n+     * Ref: https://datatracker.ietf.org/doc/html/rfc2578#section-3.5\n+     */\n+    if (len > 586)\n+        goto err;\n \n     while (len > 0) {\n         l = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    /*",
                "     * RFC 2578 (STD 58) says this about OBJECT IDENTIFIERs:",
                "     *",
                "     * > 3.5. OBJECT IDENTIFIER values",
                "     * >",
                "     * > An OBJECT IDENTIFIER value is an ordered list of non-negative",
                "     * > numbers. For the SMIv2, each number in the list is referred to as a",
                "     * > sub-identifier, there are at most 128 sub-identifiers in a value,",
                "     * > and each sub-identifier has a maximum value of 2^32-1 (4294967295",
                "     * > decimal).",
                "     *",
                "     * So a legitimate OID according to this RFC is at most (32 * 128 / 7),",
                "     * i.e. 586 bytes long.",
                "     *",
                "     * Ref: https://datatracker.ietf.org/doc/html/rfc2578#section-3.5",
                "     */",
                "    if (len > 586)",
                "        goto err;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11525",
        "func_name": "ImageMagick/RegisterRLEImage",
        "description": "The ReadCINImage function in coders/cin.c in ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1 allows remote attackers to cause a denial of service (memory consumption) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/fa3cf0b45980a4c2ea2345032fe43444dfb05bdb",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/519",
        "commit_text": "",
        "func_before": "ModuleExport size_t RegisterRLEImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"RLE\",\"RLE\",\"Utah Run length encoded image\");\n  entry->decoder=(DecodeImageHandler *) ReadRLEImage;\n  entry->magick=(IsImageFormatHandler *) IsRLE;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "func": "ModuleExport size_t RegisterRLEImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"RLE\",\"RLE\",\"Utah Run length encoded image\");\n  entry->decoder=(DecodeImageHandler *) ReadRLEImage;\n  entry->magick=(IsImageFormatHandler *) IsRLE;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   entry=AcquireMagickInfo(\"RLE\",\"RLE\",\"Utah Run length encoded image\");\n   entry->decoder=(DecodeImageHandler *) ReadRLEImage;\n   entry->magick=(IsImageFormatHandler *) IsRLE;\n-  entry->flags^=CoderBlobSupportFlag;\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   entry->flags^=CoderAdjoinFlag;\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);",
        "diff_line_info": {
            "deleted_lines": [
                "  entry->flags^=CoderBlobSupportFlag;"
            ],
            "added_lines": [
                "  entry->flags|=CoderDecoderSeekableStreamFlag;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11525",
        "func_name": "ImageMagick/RegisterCINImage",
        "description": "The ReadCINImage function in coders/cin.c in ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1 allows remote attackers to cause a denial of service (memory consumption) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/fa3cf0b45980a4c2ea2345032fe43444dfb05bdb",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/519",
        "commit_text": "",
        "func_before": "ModuleExport size_t RegisterCINImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CIN\",\"CIN\",\"Cineon Image File\");\n  entry->decoder=(DecodeImageHandler *) ReadCINImage;\n  entry->encoder=(EncodeImageHandler *) WriteCINImage;\n  entry->magick=(IsImageFormatHandler *) IsCIN;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "func": "ModuleExport size_t RegisterCINImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CIN\",\"CIN\",\"Cineon Image File\");\n  entry->decoder=(DecodeImageHandler *) ReadCINImage;\n  entry->encoder=(EncodeImageHandler *) WriteCINImage;\n  entry->magick=(IsImageFormatHandler *) IsCIN;\n  entry->flags|=CoderDecoderSeekableStreamFlag\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n   entry->decoder=(DecodeImageHandler *) ReadCINImage;\n   entry->encoder=(EncodeImageHandler *) WriteCINImage;\n   entry->magick=(IsImageFormatHandler *) IsCIN;\n+  entry->flags|=CoderDecoderSeekableStreamFlag\n   entry->flags^=CoderAdjoinFlag;\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  entry->flags|=CoderDecoderSeekableStreamFlag"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11525",
        "func_name": "ImageMagick/ReadCINImage",
        "description": "The ReadCINImage function in coders/cin.c in ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1 allows remote attackers to cause a denial of service (memory consumption) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/fa3cf0b45980a4c2ea2345032fe43444dfb05bdb",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/519",
        "commit_text": "",
        "func_before": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) ResetMagickMemory(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      profile=BlobToStringInfo((const unsigned char *) NULL,cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  quantum_info->quantum=32;\n  quantum_info->pack=MagickFalse;\n  quantum_type=RGBQuantum;\n  length=GetQuantumExtent(image,quantum_info,quantum_type);\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    pixels=(const unsigned char *) ReadBlobStream(image,length,\n      GetQuantumPixels(quantum_info),&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) ResetMagickMemory(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      profile=BlobToStringInfo((const unsigned char *) NULL,\n        cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  quantum_info->quantum=32;\n  quantum_info->pack=MagickFalse;\n  quantum_type=RGBQuantum;\n  length=GetQuantumExtent(image,quantum_info,quantum_type);\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    pixels=(const unsigned char *) ReadBlobStream(image,length,\n      GetQuantumPixels(quantum_info),&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -328,7 +328,10 @@\n       /*\n         User defined data.\n       */\n-      profile=BlobToStringInfo((const unsigned char *) NULL,cin.file.user_length);\n+      if (cin.file.user_length > GetBlobSize(image))\n+        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      profile=BlobToStringInfo((const unsigned char *) NULL,\n+        cin.file.user_length);\n       if (profile == (StringInfo *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       offset+=ReadBlob(image,GetStringInfoLength(profile),",
        "diff_line_info": {
            "deleted_lines": [
                "      profile=BlobToStringInfo((const unsigned char *) NULL,cin.file.user_length);"
            ],
            "added_lines": [
                "      if (cin.file.user_length > GetBlobSize(image))",
                "        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      profile=BlobToStringInfo((const unsigned char *) NULL,",
                "        cin.file.user_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12432",
        "func_name": "ImageMagick/ReadPCXImage",
        "description": "In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadPCXImage in coders/pcx.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/3ded916c5da6febe9660c3cfa44c3114567adf74",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/536",
        "commit_text": "",
        "func_before": "static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPCXException(severity,tag) \\\n{ \\\n  if (scanline != (unsigned char *) NULL) \\\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (page_table != (MagickOffsetType *) NULL) \\\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image\n    *image;\n\n  int\n    bits,\n    id,\n    mask;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *r;\n\n  size_t\n    one,\n    pcx_packets;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    packet,\n    pcx_colormap[768],\n    *pixels,\n    *scanline;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCX file.\n  */\n  page_table=(MagickOffsetType *) NULL;\n  scanline=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  if (LocaleCompare(image_info->magick,\"DCX\") == 0)\n    {\n      size_t\n        magic;\n\n      /*\n        Read the DCX page table.\n      */\n      magic=ReadBlobLSBLong(image);\n      if (magic != 987654321)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (id=0; id < 1024; id++)\n      {\n        page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);\n        if (page_table[id] == 0)\n          break;\n      }\n    }\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);\n      if (offset < 0)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  count=ReadBlob(image,1,&pcx_info.identifier);\n  for (id=1; id < 1024; id++)\n  {\n    int\n      bits_per_pixel;\n\n    /*\n      Verify PCX identifier.\n    */\n    pcx_info.version=(unsigned char) ReadBlobByte(image);\n    if ((count != 1) || (pcx_info.identifier != 0x0a))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.encoding=(unsigned char) ReadBlobByte(image);\n    bits_per_pixel=ReadBlobByte(image);\n    if (bits_per_pixel == -1)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;\n    pcx_info.left=ReadBlobLSBShort(image);\n    pcx_info.top=ReadBlobLSBShort(image);\n    pcx_info.right=ReadBlobLSBShort(image);\n    pcx_info.bottom=ReadBlobLSBShort(image);\n    pcx_info.horizontal_resolution=ReadBlobLSBShort(image);\n    pcx_info.vertical_resolution=ReadBlobLSBShort(image);\n    /*\n      Read PCX raster colormap.\n    */\n    image->columns=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.right-\n      pcx_info.left)+1UL;\n    image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-\n      pcx_info.top)+1UL;\n    if ((image->columns == 0) || (image->rows == 0) ||\n        ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&\n         (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    image->depth=pcx_info.bits_per_pixel;\n    image->units=PixelsPerInchResolution;\n    image->x_resolution=(double) pcx_info.horizontal_resolution;\n    image->y_resolution=(double) pcx_info.vertical_resolution;\n    image->colors=16;\n    count=ReadBlob(image,3*image->colors,pcx_colormap);\n    if (count != (ssize_t) (3*image->colors))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.reserved=(unsigned char) ReadBlobByte(image);\n    pcx_info.planes=(unsigned char) ReadBlobByte(image);\n    if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    if (pcx_info.planes == 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))\n      if ((pcx_info.version == 3) || (pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        image->colors=(size_t) MagickMin(one << (1UL*\n          (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);\n    if (AcquireImageColormap(image,image->colors) == MagickFalse)\n      ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))\n      image->storage_class=DirectClass;\n    p=pcx_colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      image->colormap[i].red=ScaleCharToQuantum(*p++);\n      image->colormap[i].green=ScaleCharToQuantum(*p++);\n      image->colormap[i].blue=ScaleCharToQuantum(*p++);\n    }\n    pcx_info.bytes_per_line=ReadBlobLSBShort(image);\n    pcx_info.palette_info=ReadBlobLSBShort(image);\n    pcx_info.horizontal_screensize=ReadBlobLSBShort(image);\n    pcx_info.vertical_screensize=ReadBlobLSBShort(image);\n    for (i=0; i < 54; i++)\n      (void) ReadBlobByte(image);\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Read image data.\n    */\n    if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;\n    if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) pcx_packets*pcx_info.planes;\n    if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >\n        (pcx_packets*8U))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,\n      pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));\n    pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));\n    if ((scanline == (unsigned char *) NULL) ||\n        (pixel_info == (MemoryInfo *) NULL))\n      {\n        if (scanline != (unsigned char *) NULL)\n          scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Uncompress image data.\n    */\n    p=pixels;\n    if (pcx_info.encoding == 0)\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        *p++=packet;\n        pcx_packets--;\n      }\n    else\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        if ((packet & 0xc0) != 0xc0)\n          {\n            *p++=packet;\n            pcx_packets--;\n            continue;\n          }\n        count=(ssize_t) (packet & 0x3f);\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for ( ; count != 0; count--)\n        {\n          *p++=packet;\n          pcx_packets--;\n          if (pcx_packets == 0)\n            break;\n        }\n      }\n    if (image->storage_class == DirectClass)\n      image->matte=pcx_info.planes > 3 ? MagickTrue : MagickFalse;\n    else\n      if ((pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        {\n          /*\n            Initialize image colormap.\n          */\n          if (image->colors > 256)\n            ThrowPCXException(CorruptImageError,\"ColormapExceeds256Colors\");\n          if ((pcx_info.bits_per_pixel*pcx_info.planes) == 1)\n            {\n              /*\n                Monochrome colormap.\n              */\n              image->colormap[0].red=(Quantum) 0;\n              image->colormap[0].green=(Quantum) 0;\n              image->colormap[0].blue=(Quantum) 0;\n              image->colormap[1].red=QuantumRange;\n              image->colormap[1].green=QuantumRange;\n              image->colormap[1].blue=QuantumRange;\n            }\n          else\n            if (image->colors > 16)\n              {\n                /*\n                  256 color images have their color map at the end of the file.\n                */\n                pcx_info.colormap_signature=(unsigned char) ReadBlobByte(image);\n                count=ReadBlob(image,3*image->colors,pcx_colormap);\n                p=pcx_colormap;\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum(*p++);\n                  image->colormap[i].green=ScaleCharToQuantum(*p++);\n                  image->colormap[i].blue=ScaleCharToQuantum(*p++);\n                }\n            }\n        }\n    /*\n      Convert PCX raster image to pixel packets.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=pixels+(y*pcx_info.bytes_per_line*pcx_info.planes);\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      indexes=GetAuthenticIndexQueue(image);\n      r=scanline;\n      if (image->storage_class == DirectClass)\n        for (i=0; i < pcx_info.planes; i++)\n        {\n          r=scanline+i;\n          for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n          {\n            switch (i)\n            {\n              case 0:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 1:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 2:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 3:\n              default:\n              {\n                *r=(*p++);\n                break;\n              }\n            }\n            r+=pcx_info.planes;\n          }\n        }\n      else\n        if (pcx_info.planes > 1)\n          {\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *r++=0;\n            for (i=0; i < pcx_info.planes; i++)\n            {\n              r=scanline;\n              for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n              {\n                 bits=(*p++);\n                 for (mask=0x80; mask != 0; mask>>=1)\n                 {\n                   if (bits & mask)\n                     *r|=1 << i;\n                   r++;\n                 }\n               }\n            }\n          }\n        else\n          switch (pcx_info.bits_per_pixel)\n          {\n            case 1:\n            {\n              register ssize_t\n                bit;\n\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                for (bit=7; bit >= 0; bit--)\n                  *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                p++;\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  for (bit=7; bit >= (ssize_t) (8-(image->columns % 8)); bit--)\n                    *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                  p++;\n                }\n              break;\n            }\n            case 2:\n            {\n              for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n              {\n                *r++=(*p >> 6) & 0x3;\n                *r++=(*p >> 4) & 0x3;\n                *r++=(*p >> 2) & 0x3;\n                *r++=(*p) & 0x3;\n                p++;\n              }\n              if ((image->columns % 4) != 0)\n                {\n                  for (i=3; i >= (ssize_t) (4-(image->columns % 4)); i--)\n                    *r++=(unsigned char) ((*p >> (i*2)) & 0x03);\n                  p++;\n                }\n              break;\n            }\n            case 4:\n            {\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                *r++=(*p >> 4) & 0xf;\n                *r++=(*p) & 0xf;\n                p++;\n              }\n              if ((image->columns % 2) != 0)\n                *r++=(*p++ >> 4) & 0xf;\n              break;\n            }\n            case 8:\n            {\n              (void) CopyMagickMemory(r,p,image->columns);\n              break;\n            }\n            default:\n              break;\n          }\n      /*\n        Transfer image scanline.\n      */\n      r=scanline;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (image->storage_class == PseudoClass)\n          SetPixelIndex(indexes+x,*r++);\n        else\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*r++));\n            SetPixelGreen(q,ScaleCharToQuantum(*r++));\n            SetPixelBlue(q,ScaleCharToQuantum(*r++));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum(*r++));\n          }\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (page_table[id] == 0)\n      break;\n    offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);\n    if (offset < 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,1,&pcx_info.identifier);\n    if ((count != 0) && (pcx_info.identifier == 0x0a))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (page_table != (MagickOffsetType *) NULL)\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPCXException(severity,tag) \\\n{ \\\n  if (scanline != (unsigned char *) NULL) \\\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (page_table != (MagickOffsetType *) NULL) \\\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image\n    *image;\n\n  int\n    bits,\n    id,\n    mask;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *r;\n\n  size_t\n    one,\n    pcx_packets;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    packet,\n    pcx_colormap[768],\n    *pixels,\n    *scanline;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCX file.\n  */\n  page_table=(MagickOffsetType *) NULL;\n  scanline=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  if (LocaleCompare(image_info->magick,\"DCX\") == 0)\n    {\n      size_t\n        magic;\n\n      /*\n        Read the DCX page table.\n      */\n      magic=ReadBlobLSBLong(image);\n      if (magic != 987654321)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (id=0; id < 1024; id++)\n      {\n        page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);\n        if (page_table[id] == 0)\n          break;\n      }\n    }\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);\n      if (offset < 0)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  count=ReadBlob(image,1,&pcx_info.identifier);\n  for (id=1; id < 1024; id++)\n  {\n    int\n      bits_per_pixel;\n\n    /*\n      Verify PCX identifier.\n    */\n    pcx_info.version=(unsigned char) ReadBlobByte(image);\n    if ((count != 1) || (pcx_info.identifier != 0x0a))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.encoding=(unsigned char) ReadBlobByte(image);\n    bits_per_pixel=ReadBlobByte(image);\n    if (bits_per_pixel == -1)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;\n    pcx_info.left=ReadBlobLSBShort(image);\n    pcx_info.top=ReadBlobLSBShort(image);\n    pcx_info.right=ReadBlobLSBShort(image);\n    pcx_info.bottom=ReadBlobLSBShort(image);\n    pcx_info.horizontal_resolution=ReadBlobLSBShort(image);\n    pcx_info.vertical_resolution=ReadBlobLSBShort(image);\n    /*\n      Read PCX raster colormap.\n    */\n    image->columns=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.right-\n      pcx_info.left)+1UL;\n    image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-\n      pcx_info.top)+1UL;\n    if ((image->columns == 0) || (image->rows == 0) ||\n        ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&\n         (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    image->depth=pcx_info.bits_per_pixel;\n    image->units=PixelsPerInchResolution;\n    image->x_resolution=(double) pcx_info.horizontal_resolution;\n    image->y_resolution=(double) pcx_info.vertical_resolution;\n    image->colors=16;\n    count=ReadBlob(image,3*image->colors,pcx_colormap);\n    if (count != (ssize_t) (3*image->colors))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.reserved=(unsigned char) ReadBlobByte(image);\n    pcx_info.planes=(unsigned char) ReadBlobByte(image);\n    if (pcx_info.planes > 6)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    if (pcx_info.planes == 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))\n      if ((pcx_info.version == 3) || (pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        image->colors=(size_t) MagickMin(one << (1UL*\n          (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);\n    if (AcquireImageColormap(image,image->colors) == MagickFalse)\n      ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))\n      image->storage_class=DirectClass;\n    p=pcx_colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      image->colormap[i].red=ScaleCharToQuantum(*p++);\n      image->colormap[i].green=ScaleCharToQuantum(*p++);\n      image->colormap[i].blue=ScaleCharToQuantum(*p++);\n    }\n    pcx_info.bytes_per_line=ReadBlobLSBShort(image);\n    pcx_info.palette_info=ReadBlobLSBShort(image);\n    pcx_info.horizontal_screensize=ReadBlobLSBShort(image);\n    pcx_info.vertical_screensize=ReadBlobLSBShort(image);\n    for (i=0; i < 54; i++)\n      (void) ReadBlobByte(image);\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Read image data.\n    */\n    if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;\n    if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) pcx_packets*pcx_info.planes;\n    if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >\n        (pcx_packets*8U))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,\n      pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));\n    pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));\n    if ((scanline == (unsigned char *) NULL) ||\n        (pixel_info == (MemoryInfo *) NULL))\n      {\n        if (scanline != (unsigned char *) NULL)\n          scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Uncompress image data.\n    */\n    p=pixels;\n    if (pcx_info.encoding == 0)\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        *p++=packet;\n        pcx_packets--;\n      }\n    else\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        if ((packet & 0xc0) != 0xc0)\n          {\n            *p++=packet;\n            pcx_packets--;\n            continue;\n          }\n        count=(ssize_t) (packet & 0x3f);\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for ( ; count != 0; count--)\n        {\n          *p++=packet;\n          pcx_packets--;\n          if (pcx_packets == 0)\n            break;\n        }\n      }\n    if (image->storage_class == DirectClass)\n      image->matte=pcx_info.planes > 3 ? MagickTrue : MagickFalse;\n    else\n      if ((pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        {\n          /*\n            Initialize image colormap.\n          */\n          if (image->colors > 256)\n            ThrowPCXException(CorruptImageError,\"ColormapExceeds256Colors\");\n          if ((pcx_info.bits_per_pixel*pcx_info.planes) == 1)\n            {\n              /*\n                Monochrome colormap.\n              */\n              image->colormap[0].red=(Quantum) 0;\n              image->colormap[0].green=(Quantum) 0;\n              image->colormap[0].blue=(Quantum) 0;\n              image->colormap[1].red=QuantumRange;\n              image->colormap[1].green=QuantumRange;\n              image->colormap[1].blue=QuantumRange;\n            }\n          else\n            if (image->colors > 16)\n              {\n                /*\n                  256 color images have their color map at the end of the file.\n                */\n                pcx_info.colormap_signature=(unsigned char) ReadBlobByte(image);\n                count=ReadBlob(image,3*image->colors,pcx_colormap);\n                p=pcx_colormap;\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum(*p++);\n                  image->colormap[i].green=ScaleCharToQuantum(*p++);\n                  image->colormap[i].blue=ScaleCharToQuantum(*p++);\n                }\n            }\n        }\n    /*\n      Convert PCX raster image to pixel packets.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=pixels+(y*pcx_info.bytes_per_line*pcx_info.planes);\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      indexes=GetAuthenticIndexQueue(image);\n      r=scanline;\n      if (image->storage_class == DirectClass)\n        for (i=0; i < pcx_info.planes; i++)\n        {\n          r=scanline+i;\n          for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n          {\n            switch (i)\n            {\n              case 0:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 1:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 2:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 3:\n              default:\n              {\n                *r=(*p++);\n                break;\n              }\n            }\n            r+=pcx_info.planes;\n          }\n        }\n      else\n        if (pcx_info.planes > 1)\n          {\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *r++=0;\n            for (i=0; i < pcx_info.planes; i++)\n            {\n              r=scanline;\n              for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n              {\n                 bits=(*p++);\n                 for (mask=0x80; mask != 0; mask>>=1)\n                 {\n                   if (bits & mask)\n                     *r|=1 << i;\n                   r++;\n                 }\n               }\n            }\n          }\n        else\n          switch (pcx_info.bits_per_pixel)\n          {\n            case 1:\n            {\n              register ssize_t\n                bit;\n\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                for (bit=7; bit >= 0; bit--)\n                  *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                p++;\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  for (bit=7; bit >= (ssize_t) (8-(image->columns % 8)); bit--)\n                    *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                  p++;\n                }\n              break;\n            }\n            case 2:\n            {\n              for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n              {\n                *r++=(*p >> 6) & 0x3;\n                *r++=(*p >> 4) & 0x3;\n                *r++=(*p >> 2) & 0x3;\n                *r++=(*p) & 0x3;\n                p++;\n              }\n              if ((image->columns % 4) != 0)\n                {\n                  for (i=3; i >= (ssize_t) (4-(image->columns % 4)); i--)\n                    *r++=(unsigned char) ((*p >> (i*2)) & 0x03);\n                  p++;\n                }\n              break;\n            }\n            case 4:\n            {\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                *r++=(*p >> 4) & 0xf;\n                *r++=(*p) & 0xf;\n                p++;\n              }\n              if ((image->columns % 2) != 0)\n                *r++=(*p++ >> 4) & 0xf;\n              break;\n            }\n            case 8:\n            {\n              (void) CopyMagickMemory(r,p,image->columns);\n              break;\n            }\n            default:\n              break;\n          }\n      /*\n        Transfer image scanline.\n      */\n      r=scanline;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (image->storage_class == PseudoClass)\n          SetPixelIndex(indexes+x,*r++);\n        else\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*r++));\n            SetPixelGreen(q,ScaleCharToQuantum(*r++));\n            SetPixelBlue(q,ScaleCharToQuantum(*r++));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum(*r++));\n          }\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (page_table[id] == 0)\n      break;\n    offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);\n    if (offset < 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,1,&pcx_info.identifier);\n    if ((count != 0) && (pcx_info.identifier == 0x0a))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (page_table != (MagickOffsetType *) NULL)\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -157,6 +157,8 @@\n       ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     pcx_info.reserved=(unsigned char) ReadBlobByte(image);\n     pcx_info.planes=(unsigned char) ReadBlobByte(image);\n+    if (pcx_info.planes > 6)\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)\n       ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     if (pcx_info.planes == 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (pcx_info.planes > 6)",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12432",
        "func_name": "ImageMagick/AcquireVirtualMemory",
        "description": "In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadPCXImage in coders/pcx.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/3ded916c5da6febe9660c3cfa44c3114567adf74",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/536",
        "commit_text": "",
        "func_before": "MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n\n  size_t\n    extent;\n\n  static ssize_t\n    virtual_anonymous_memory = (-1);\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickSignature;\n  if (virtual_anonymous_memory < 0)\n    {\n      char\n        *value;\n\n      /*\n        Does the security policy require anonymous mapping for pixel cache?\n      */\n      virtual_anonymous_memory=0;\n      value=GetPolicyValue(\"system:memory-map\");\n      if (LocaleCompare(value,\"anonymous\") == 0)\n        {\n#if defined(MAGICKCORE_HAVE_MMAP) && defined(MAP_ANONYMOUS)\n          virtual_anonymous_memory=1;\n#endif\n        }\n      value=DestroyString(value);\n    }\n  if (virtual_anonymous_memory <= 0)\n    {\n      if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n        {\n          memory_info->blob=AcquireAlignedMemory(1,extent);\n          if (memory_info->blob != NULL)\n            {\n              memory_info->type=AlignedVirtualMemory;\n              return(memory_info);\n            }\n        }\n      RelinquishMagickResource(MemoryResource,extent);\n    }\n  else\n    {\n      if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n        {\n          /*\n            Acquire anonymous memory map.\n          */\n          memory_info->blob=MapBlob(-1,IOMode,0,extent);\n          if (memory_info->blob != NULL)\n            {\n              memory_info->type=MapVirtualMemory;\n              return(memory_info);\n            }\n          if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n            {\n              int\n                file;\n\n              /*\n                Anonymous memory mapping failed, try file-backed memory mapping.\n                If the MapResource request failed, there is no point in trying\n                file-backed memory mapping.\n              */\n              file=AcquireUniqueFileResource(memory_info->filename);\n              if (file != -1)\n                {\n                  MagickOffsetType\n                    offset;\n\n                  offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n                  if ((offset == (MagickOffsetType) (extent-1)) &&\n                      (write(file,\"\",1) == 1))\n                    {\n                      memory_info->blob=MapBlob(file,IOMode,0,extent);\n                      if (memory_info->blob != NULL)\n                        {\n                          (void) close(file);\n                          memory_info->type=MapVirtualMemory;\n                          return(memory_info);\n                        }\n                    }\n                  /*\n                    File-backed memory mapping fail, delete the temporary file.\n                  */\n                  (void) close(file);\n                  (void) RelinquishUniqueFileResource(memory_info->filename);\n                  *memory_info->filename='\\0';\n                }\n            }\n          RelinquishMagickResource(DiskResource,extent);\n        }\n      RelinquishMagickResource(MapResource,extent);\n    }\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}",
        "func": "MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n\n  size_t\n    extent;\n\n  static ssize_t\n    virtual_anonymous_memory = (-1);\n\n  if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickSignature;\n  if (virtual_anonymous_memory < 0)\n    {\n      char\n        *value;\n\n      /*\n        Does the security policy require anonymous mapping for pixel cache?\n      */\n      virtual_anonymous_memory=0;\n      value=GetPolicyValue(\"system:memory-map\");\n      if (LocaleCompare(value,\"anonymous\") == 0)\n        {\n#if defined(MAGICKCORE_HAVE_MMAP) && defined(MAP_ANONYMOUS)\n          virtual_anonymous_memory=1;\n#endif\n        }\n      value=DestroyString(value);\n    }\n  if (virtual_anonymous_memory <= 0)\n    {\n      if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n        {\n          memory_info->blob=AcquireAlignedMemory(1,extent);\n          if (memory_info->blob != NULL)\n            {\n              memory_info->type=AlignedVirtualMemory;\n              return(memory_info);\n            }\n        }\n      RelinquishMagickResource(MemoryResource,extent);\n    }\n  else\n    {\n      if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n        {\n          /*\n            Acquire anonymous memory map.\n          */\n          memory_info->blob=MapBlob(-1,IOMode,0,extent);\n          if (memory_info->blob != NULL)\n            {\n              memory_info->type=MapVirtualMemory;\n              return(memory_info);\n            }\n          if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n            {\n              int\n                file;\n\n              /*\n                Anonymous memory mapping failed, try file-backed memory mapping.\n                If the MapResource request failed, there is no point in trying\n                file-backed memory mapping.\n              */\n              file=AcquireUniqueFileResource(memory_info->filename);\n              if (file != -1)\n                {\n                  MagickOffsetType\n                    offset;\n\n                  offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n                  if ((offset == (MagickOffsetType) (extent-1)) &&\n                      (write(file,\"\",1) == 1))\n                    {\n                      memory_info->blob=MapBlob(file,IOMode,0,extent);\n                      if (memory_info->blob != NULL)\n                        {\n                          (void) close(file);\n                          memory_info->type=MapVirtualMemory;\n                          return(memory_info);\n                        }\n                    }\n                  /*\n                    File-backed memory mapping fail, delete the temporary file.\n                  */\n                  (void) close(file);\n                  (void) RelinquishUniqueFileResource(memory_info->filename);\n                  *memory_info->filename='\\0';\n                }\n            }\n          RelinquishMagickResource(DiskResource,extent);\n        }\n      RelinquishMagickResource(MapResource,extent);\n    }\n  if ((memory_info->blob == NULL) &&\n      (AcquireMagickResource(MemoryResource,extent) != MagickFalse))\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n      RelinquishMagickResource(MemoryResource,extent);\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -104,11 +104,13 @@\n         }\n       RelinquishMagickResource(MapResource,extent);\n     }\n-  if (memory_info->blob == NULL)\n+  if ((memory_info->blob == NULL) &&\n+      (AcquireMagickResource(MemoryResource,extent) != MagickFalse))\n     {\n       memory_info->blob=AcquireMagickMemory(extent);\n       if (memory_info->blob != NULL)\n         memory_info->type=UnalignedVirtualMemory;\n+      RelinquishMagickResource(MemoryResource,extent);\n     }\n   if (memory_info->blob == NULL)\n     memory_info=RelinquishVirtualMemory(memory_info);",
        "diff_line_info": {
            "deleted_lines": [
                "  if (memory_info->blob == NULL)"
            ],
            "added_lines": [
                "  if ((memory_info->blob == NULL) &&",
                "      (AcquireMagickResource(MemoryResource,extent) != MagickFalse))",
                "      RelinquishMagickResource(MemoryResource,extent);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12435",
        "func_name": "ImageMagick/RegisterSUNImage",
        "description": "In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadSUNImage in coders/sun.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/2dd8d55742fce7d079b6a16039c18e49c091224f",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/543",
        "commit_text": "",
        "func_before": "ModuleExport size_t RegisterSUNImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"SUN\",\"RAS\",\"SUN Rasterfile\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->magick=(IsImageFormatHandler *) IsSUN;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"SUN\",\"SUN\",\"SUN Rasterfile\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "func": "ModuleExport size_t RegisterSUNImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"SUN\",\"RAS\",\"SUN Rasterfile\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->magick=(IsImageFormatHandler *) IsSUN;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"SUN\",\"SUN\",\"SUN Rasterfile\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,10 +7,12 @@\n   entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n   entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n   entry->magick=(IsImageFormatHandler *) IsSUN;\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   (void) RegisterMagickInfo(entry);\n   entry=AcquireMagickInfo(\"SUN\",\"SUN\",\"SUN Rasterfile\");\n   entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n   entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  entry->flags|=CoderDecoderSeekableStreamFlag;",
                "  entry->flags|=CoderDecoderSeekableStreamFlag;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12435",
        "func_name": "ImageMagick/ReadSUNImage",
        "description": "In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadSUNImage in coders/sun.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/2dd8d55742fce7d079b6a16039c18e49c091224f",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/543",
        "commit_text": "",
        "func_before": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    height,\n    pixels_length,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&\n        (sun_info.depth != 24) && (sun_info.depth != 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if (sun_info.length == 0)\n      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n    number_pixels=(MagickSizeType) (image->columns*image->rows);\n    if ((sun_info.type != RT_ENCODED) &&\n        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,\n      sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    height=sun_info.height;\n    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n        ((bytes_per_line/sun_info.depth) != sun_info.width))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    quantum=sun_info.depth == 1 ? 15 : 7;\n    bytes_per_line+=quantum;\n    bytes_per_line<<=1;\n    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    bytes_per_line>>=4;\n    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    pixels_length=height*bytes_per_line;\n    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,\n      sizeof(*sun_pixels));\n    if (sun_pixels == (unsigned char *) NULL)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));\n    if (sun_info.type == RT_ENCODED)\n      {\n        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    else\n      {\n        if (sun_info.length > pixels_length)\n          {\n            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n            ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n          }\n        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n      }\n    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,ConstrainColormapIndex(image,*p,exception),q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            bytes_per_pixel++;\n          if (bytes_per_line == 0)\n            bytes_per_line=bytes_per_pixel*image->columns;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    height,\n    pixels_length,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&\n        (sun_info.depth != 24) && (sun_info.depth != 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        if (sun_info.maplength > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if (sun_info.length == 0)\n      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n    number_pixels=(MagickSizeType) (image->columns*image->rows);\n    if ((sun_info.type != RT_ENCODED) &&\n        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,\n      sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    height=sun_info.height;\n    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n        ((bytes_per_line/sun_info.depth) != sun_info.width))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    quantum=sun_info.depth == 1 ? 15 : 7;\n    bytes_per_line+=quantum;\n    bytes_per_line<<=1;\n    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    bytes_per_line>>=4;\n    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    pixels_length=height*bytes_per_line;\n    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,\n      sizeof(*sun_pixels));\n    if (sun_pixels == (unsigned char *) NULL)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));\n    if (sun_info.type == RT_ENCODED)\n      {\n        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    else\n      {\n        if (sun_info.length > pixels_length)\n          {\n            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n            ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n          }\n        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n      }\n    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,ConstrainColormapIndex(image,*p,exception),q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            bytes_per_pixel++;\n          if (bytes_per_line == 0)\n            bytes_per_line=bytes_per_pixel*image->columns;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -119,6 +119,8 @@\n         size_t\n           one;\n \n+        if (sun_info.maplength > GetBlobSize(image))\n+          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         image->colors=sun_info.maplength;\n         one=1;\n         if (sun_info.maptype == RMT_NONE)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (sun_info.maplength > GetBlobSize(image))",
                "          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12435",
        "func_name": "ImageMagick/RegisterSUNImage",
        "description": "In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadSUNImage in coders/sun.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/44cb8dfd4cbe6fc475c863a5946cff64e34c2088",
        "commit_title": ".https://github.com/ImageMagick/ImageMagick/issues/543",
        "commit_text": "",
        "func_before": "ModuleExport size_t RegisterSUNImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"RAS\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->magick=(IsImageFormatHandler *) IsSUN;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"SUN\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "func": "ModuleExport size_t RegisterSUNImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"RAS\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->magick=(IsImageFormatHandler *) IsSUN;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->seekable_stream=MagickTrue;\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"SUN\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->seekable_stream=MagickTrue;\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,12 +8,14 @@\n   entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n   entry->magick=(IsImageFormatHandler *) IsSUN;\n   entry->description=ConstantString(\"SUN Rasterfile\");\n+  entry->seekable_stream=MagickTrue;\n   entry->module=ConstantString(\"SUN\");\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"SUN\");\n   entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n   entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n   entry->description=ConstantString(\"SUN Rasterfile\");\n+  entry->seekable_stream=MagickTrue;\n   entry->module=ConstantString(\"SUN\");\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  entry->seekable_stream=MagickTrue;",
                "  entry->seekable_stream=MagickTrue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12435",
        "func_name": "ImageMagick/ReadSUNImage",
        "description": "In ImageMagick 7.0.6-1, a memory exhaustion vulnerability was found in the function ReadSUNImage in coders/sun.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/44cb8dfd4cbe6fc475c863a5946cff64e34c2088",
        "commit_title": ".https://github.com/ImageMagick/ImageMagick/issues/543",
        "commit_text": "",
        "func_before": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    height,\n    pixels_length,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&\n        (sun_info.depth != 24) && (sun_info.depth != 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=ScaleCharToQuantum(sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        break;\n      }\n      default:\n        break;\n    }\n    image->matte=sun_info.depth == 32 ? MagickTrue : MagickFalse;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    if (sun_info.length == 0)\n      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n    number_pixels=(MagickSizeType) (image->columns*image->rows);\n    if ((sun_info.type != RT_ENCODED) &&\n        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,\n      sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    height=sun_info.height;\n    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n        ((bytes_per_line/sun_info.depth) != sun_info.width))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    quantum=sun_info.depth == 1 ? 15 : 7;\n    bytes_per_line+=quantum;\n    bytes_per_line<<=1;\n    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    bytes_per_line>>=4;\n    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    pixels_length=height*bytes_per_line;\n    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,\n      sizeof(*sun_pixels));\n    if (sun_pixels == (unsigned char *) NULL)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));\n    if (sun_info.type == RT_ENCODED)\n      {\n        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    else\n      {\n        if (sun_info.length > pixels_length)\n          {\n            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n            ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n          }\n        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n      }\n    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n            SetPixelIndex(indexes+x+7-bit,((*p) & (0x01 << bit) ? 0x00 : 0x01));\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n              SetPixelIndex(indexes+x+7-bit,(*p) & (0x01 << bit) ? 0x00 : 0x01);\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(indexes+x,ConstrainColormapIndex(image,*p));\n              p++;\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->matte != MagickFalse)\n            bytes_per_pixel++;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->matte != MagickFalse)\n                SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                }\n              else\n                {\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    GetPixelRed(q)].red);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    GetPixelGreen(q)].green);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    GetPixelBlue(q)].blue);\n                }\n              q++;\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    height,\n    pixels_length,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&\n        (sun_info.depth != 24) && (sun_info.depth != 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        if (sun_info.maplength > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=ScaleCharToQuantum(sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=ScaleCharToQuantum(sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        break;\n      }\n      default:\n        break;\n    }\n    image->matte=sun_info.depth == 32 ? MagickTrue : MagickFalse;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    if (sun_info.length == 0)\n      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n    number_pixels=(MagickSizeType) (image->columns*image->rows);\n    if ((sun_info.type != RT_ENCODED) &&\n        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,\n      sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    height=sun_info.height;\n    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n        ((bytes_per_line/sun_info.depth) != sun_info.width))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    quantum=sun_info.depth == 1 ? 15 : 7;\n    bytes_per_line+=quantum;\n    bytes_per_line<<=1;\n    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    bytes_per_line>>=4;\n    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    pixels_length=height*bytes_per_line;\n    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,\n      sizeof(*sun_pixels));\n    if (sun_pixels == (unsigned char *) NULL)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));\n    if (sun_info.type == RT_ENCODED)\n      {\n        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    else\n      {\n        if (sun_info.length > pixels_length)\n          {\n            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n            ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n          }\n        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n      }\n    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n            SetPixelIndex(indexes+x+7-bit,((*p) & (0x01 << bit) ? 0x00 : 0x01));\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n              SetPixelIndex(indexes+x+7-bit,(*p) & (0x01 << bit) ? 0x00 : 0x01);\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(indexes+x,ConstrainColormapIndex(image,*p));\n              p++;\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->matte != MagickFalse)\n            bytes_per_pixel++;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->matte != MagickFalse)\n                SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                }\n              else\n                {\n                  SetPixelRed(q,ScaleCharToQuantum(*p++));\n                  SetPixelGreen(q,ScaleCharToQuantum(*p++));\n                  SetPixelBlue(q,ScaleCharToQuantum(*p++));\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    GetPixelRed(q)].red);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    GetPixelGreen(q)].green);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    GetPixelBlue(q)].blue);\n                }\n              q++;\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -122,6 +122,8 @@\n         size_t\n           one;\n \n+        if (sun_info.maplength > GetBlobSize(image))\n+          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         image->colors=sun_info.maplength;\n         one=1;\n         if (sun_info.maptype == RMT_NONE)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (sun_info.maplength > GetBlobSize(image))",
                "          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12563",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.6-2, a memory exhaustion vulnerability was found in the function ReadPSDImage in coders/psd.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ac38f521356b576ab57c2e74cc541548d80a8bdc",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/599",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -89,7 +89,8 @@\n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n     {\n MATLAB_KO:\n-      clone_info=DestroyImageInfo(clone_info);\n+      if (clone_info != (ImageInfo *) NULL)\n+        clone_info=DestroyImageInfo(clone_info);\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      clone_info=DestroyImageInfo(clone_info);"
            ],
            "added_lines": [
                "      if (clone_info != (ImageInfo *) NULL)",
                "        clone_info=DestroyImageInfo(clone_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12643",
        "func_name": "ImageMagick/ReadOneJNGImage",
        "description": "ImageMagick 7.0.6-1 has a memory exhaustion vulnerability in ReadOneJNGImage in coders\\png.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d9ccd8227c4c88a907cda5278408b73552cb0c07",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/549",
        "commit_text": "",
        "func_before": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const Quantum\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image,exception);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MagickPathExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\n                \"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info,exception);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info,exception);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->resolution.x=(double) mng_get_long(p);\n            image->resolution.y=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->resolution.x=image->resolution.x/100.0f;\n                image->resolution.y=image->resolution.y/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         alpha samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MagickPathExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n\n  image->rows=jng_height;\n  image->columns=jng_width;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    for (x=(ssize_t) image->columns; x != 0; x--)\n    {\n      SetPixelRed(image,GetPixelRed(jng_image,s),q);\n      SetPixelGreen(image,GetPixelGreen(jng_image,s),q);\n      SetPixelBlue(image,GetPixelBlue(jng_image,s),q);\n      q+=GetPixelChannels(image);\n      s+=GetPixelChannels(jng_image);\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) CloseBlob(alpha_image);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading alpha from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MagickPathExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n               exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->alpha_trait != UndefinedPixelTrait)\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    image->alpha_trait=BlendPixelTrait;\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage()\");\n\n  return(image);\n}",
        "func": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const Quantum\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image,exception);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MagickPathExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\n                \"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info,exception);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info,exception);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->resolution.x=(double) mng_get_long(p);\n            image->resolution.y=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->resolution.x=image->resolution.x/100.0f;\n                image->resolution.y=image->resolution.y/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         alpha samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MagickPathExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n\n  image->rows=jng_height;\n  image->columns=jng_width;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    for (x=(ssize_t) image->columns; x != 0; x--)\n    {\n      SetPixelRed(image,GetPixelRed(jng_image,s),q);\n      SetPixelGreen(image,GetPixelGreen(jng_image,s),q);\n      SetPixelBlue(image,GetPixelBlue(jng_image,s),q);\n      q+=GetPixelChannels(image);\n      s+=GetPixelChannels(jng_image);\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) CloseBlob(alpha_image);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading alpha from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MagickPathExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n               exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->alpha_trait != UndefinedPixelTrait)\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    image->alpha_trait=BlendPixelTrait;\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage()\");\n\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -131,6 +131,8 @@\n \n     if (length != 0)\n       {\n+        if (length > GetBlobSize(image))\n+          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n           sizeof(*chunk));\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (length > GetBlobSize(image))",
                "          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13133",
        "func_name": "ImageMagick/load_level",
        "description": "In ImageMagick 7.0.6-8, the load_level function in coders/xcf.c lacks offset validation, which allows attackers to cause a denial of service (load_tile memory exhaustion) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/19dbe11c5060f66abb393d1945107c5f54894fa8",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/679",
        "commit_text": "",
        "func_before": "static MagickBooleanType load_level(Image *image,XCFDocInfo *inDocInfo,\n  XCFLayerInfo *inLayerInfo,ExceptionInfo *exception)\n{\n  int\n    destLeft = 0,\n    destTop = 0;\n\n  Image*\n    tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    saved_pos,\n    offset,\n    offset2;\n\n  register ssize_t\n    i;\n\n  size_t\n    width,\n    height,\n    ntiles,\n    ntile_rows,\n    ntile_cols,\n    tile_image_width,\n    tile_image_height;\n\n  /* start reading the data */\n  width=ReadBlobMSBLong(image);\n  height=ReadBlobMSBLong(image);\n\n  /* read in the first tile offset.\n   *  if it is '0', then this tile level is empty\n   *  and we can simply return.\n   */\n  offset=(MagickOffsetType) ReadBlobMSBLong(image);\n  if (offset == 0)\n    return(MagickTrue);\n  /* Initialise the reference for the in-memory tile-compression\n   */\n  ntile_rows=(height+TILE_HEIGHT-1)/TILE_HEIGHT;\n  ntile_cols=(width+TILE_WIDTH-1)/TILE_WIDTH;\n  ntiles=ntile_rows*ntile_cols;\n  for (i = 0; i < (ssize_t) ntiles; i++)\n  {\n    status=MagickFalse;\n    if (offset == 0)\n      ThrowBinaryException(CorruptImageError,\"NotEnoughTiles\",image->filename);\n    /* save the current position as it is where the\n     *  next tile offset is stored.\n     */\n    saved_pos=TellBlob(image);\n    /* read in the offset of the next tile so we can calculate the amount\n       of data needed for this tile*/\n    offset2=(MagickOffsetType)ReadBlobMSBLong(image);\n    /* if the offset is 0 then we need to read in the maximum possible\n       allowing for negative compression */\n    if (offset2 == 0)\n      offset2=(MagickOffsetType) (offset + TILE_WIDTH * TILE_WIDTH * 4* 1.5);\n    /* seek to the tile offset */\n    if (SeekBlob(image, offset, SEEK_SET) != offset)\n      ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n        image->filename);\n\n      /*\n        Allocate the image for the tile.  NOTE: the last tile in a row or\n        column may not be a full tile!\n      */\n      tile_image_width=(size_t) (destLeft == (int) ntile_cols-1 ?\n        (int) width % TILE_WIDTH : TILE_WIDTH);\n      if (tile_image_width == 0)\n        tile_image_width=TILE_WIDTH;\n      tile_image_height = (size_t) (destTop == (int) ntile_rows-1 ?\n        (int) height % TILE_HEIGHT : TILE_HEIGHT);\n      if (tile_image_height == 0)\n        tile_image_height=TILE_HEIGHT;\n      tile_image=CloneImage(inLayerInfo->image,tile_image_width,\n        tile_image_height,MagickTrue,exception);\n\n      /* read in the tile */\n      switch (inDocInfo->compression)\n      {\n        case COMPRESS_NONE:\n          if (load_tile(image,tile_image,inDocInfo,inLayerInfo,(size_t) (offset2-offset),exception) == 0)\n            status=MagickTrue;\n          break;\n        case COMPRESS_RLE:\n          if (load_tile_rle (image,tile_image,inDocInfo,inLayerInfo,\n              (int) (offset2-offset),exception) == 0)\n            status=MagickTrue;\n          break;\n        case COMPRESS_ZLIB:\n          ThrowBinaryException(CoderError,\"ZipCompressNotSupported\",\n            image->filename)\n        case COMPRESS_FRACTAL:\n          ThrowBinaryException(CoderError,\"FractalCompressNotSupported\",\n            image->filename)\n      }\n\n      /* composite the tile onto the layer's image, and then destroy it */\n      (void) CompositeImage(inLayerInfo->image,tile_image,CopyCompositeOp,\n        MagickTrue,destLeft * TILE_WIDTH,destTop*TILE_HEIGHT,exception);\n      tile_image=DestroyImage(tile_image);\n\n      /* adjust tile position */\n      destLeft++;\n      if (destLeft >= (int) ntile_cols)\n        {\n          destLeft = 0;\n          destTop++;\n        }\n      if (status != MagickFalse)\n        return(MagickFalse);\n      /* restore the saved position so we'll be ready to\n       *  read the next offset.\n       */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      /* read in the offset of the next tile */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n    }\n  if (offset != 0)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename)\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType load_level(Image *image,XCFDocInfo *inDocInfo,\n  XCFLayerInfo *inLayerInfo,ExceptionInfo *exception)\n{\n  int\n    destLeft = 0,\n    destTop = 0;\n\n  Image*\n    tile_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    saved_pos,\n    offset,\n    offset2;\n\n  register ssize_t\n    i;\n\n  size_t\n    width,\n    height,\n    ntiles,\n    ntile_rows,\n    ntile_cols,\n    tile_image_width,\n    tile_image_height;\n\n  /* start reading the data */\n  width=ReadBlobMSBLong(image);\n  height=ReadBlobMSBLong(image);\n\n  /* read in the first tile offset.\n   *  if it is '0', then this tile level is empty\n   *  and we can simply return.\n   */\n  offset=(MagickOffsetType) ReadBlobMSBLong(image);\n  if (offset == 0)\n    return(MagickTrue);\n  /* Initialise the reference for the in-memory tile-compression\n   */\n  ntile_rows=(height+TILE_HEIGHT-1)/TILE_HEIGHT;\n  ntile_cols=(width+TILE_WIDTH-1)/TILE_WIDTH;\n  ntiles=ntile_rows*ntile_cols;\n  for (i = 0; i < (ssize_t) ntiles; i++)\n  {\n    status=MagickFalse;\n    if (offset == 0)\n      ThrowBinaryException(CorruptImageError,\"NotEnoughTiles\",image->filename);\n    /* save the current position as it is where the\n     *  next tile offset is stored.\n     */\n    saved_pos=TellBlob(image);\n    /* read in the offset of the next tile so we can calculate the amount\n       of data needed for this tile*/\n    offset2=(MagickOffsetType)ReadBlobMSBLong(image);\n    /* if the offset is 0 then we need to read in the maximum possible\n       allowing for negative compression */\n    if (offset2 == 0)\n      offset2=(MagickOffsetType) (offset + TILE_WIDTH * TILE_WIDTH * 4* 1.5);\n    /* seek to the tile offset */\n    if (offset2 > GetBlobSize(image))\n      ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n        image->filename);\n    if (SeekBlob(image, offset, SEEK_SET) != offset)\n      ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n        image->filename);\n\n      /*\n        Allocate the image for the tile.  NOTE: the last tile in a row or\n        column may not be a full tile!\n      */\n      tile_image_width=(size_t) (destLeft == (int) ntile_cols-1 ?\n        (int) width % TILE_WIDTH : TILE_WIDTH);\n      if (tile_image_width == 0)\n        tile_image_width=TILE_WIDTH;\n      tile_image_height = (size_t) (destTop == (int) ntile_rows-1 ?\n        (int) height % TILE_HEIGHT : TILE_HEIGHT);\n      if (tile_image_height == 0)\n        tile_image_height=TILE_HEIGHT;\n      tile_image=CloneImage(inLayerInfo->image,tile_image_width,\n        tile_image_height,MagickTrue,exception);\n\n      /* read in the tile */\n      switch (inDocInfo->compression)\n      {\n        case COMPRESS_NONE:\n          if (load_tile(image,tile_image,inDocInfo,inLayerInfo,(size_t) (offset2-offset),exception) == 0)\n            status=MagickTrue;\n          break;\n        case COMPRESS_RLE:\n          if (load_tile_rle (image,tile_image,inDocInfo,inLayerInfo,\n              (int) (offset2-offset),exception) == 0)\n            status=MagickTrue;\n          break;\n        case COMPRESS_ZLIB:\n          ThrowBinaryException(CoderError,\"ZipCompressNotSupported\",\n            image->filename)\n        case COMPRESS_FRACTAL:\n          ThrowBinaryException(CoderError,\"FractalCompressNotSupported\",\n            image->filename)\n      }\n\n      /* composite the tile onto the layer's image, and then destroy it */\n      (void) CompositeImage(inLayerInfo->image,tile_image,CopyCompositeOp,\n        MagickTrue,destLeft * TILE_WIDTH,destTop*TILE_HEIGHT,exception);\n      tile_image=DestroyImage(tile_image);\n\n      /* adjust tile position */\n      destLeft++;\n      if (destLeft >= (int) ntile_cols)\n        {\n          destLeft = 0;\n          destTop++;\n        }\n      if (status != MagickFalse)\n        return(MagickFalse);\n      /* restore the saved position so we'll be ready to\n       *  read the next offset.\n       */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      /* read in the offset of the next tile */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n    }\n  if (offset != 0)\n    ThrowBinaryException(CorruptImageError,\"CorruptImage\",image->filename)\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -61,6 +61,9 @@\n     if (offset2 == 0)\n       offset2=(MagickOffsetType) (offset + TILE_WIDTH * TILE_WIDTH * 4* 1.5);\n     /* seek to the tile offset */\n+    if (offset2 > GetBlobSize(image))\n+      ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n+        image->filename);\n     if (SeekBlob(image, offset, SEEK_SET) != offset)\n       ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n         image->filename);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (offset2 > GetBlobSize(image))",
                "      ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",",
                "        image->filename);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12875",
        "func_name": "ImageMagick/ReadOneLayer",
        "description": "The WritePixelCachePixels function in ImageMagick 7.0.6-6 allows remote attackers to cause a denial of service (CPU consumption) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6f95e543c80319721e22d623bb23712cd29afa9e",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/659",
        "commit_text": "",
        "func_before": "static MagickBooleanType ReadOneLayer(const ImageInfo *image_info,Image* image,\n  XCFDocInfo* inDocInfo,XCFLayerInfo *outLayer,const ssize_t layer)\n{\n  MagickOffsetType\n    offset;\n\n  unsigned int\n    foundPropEnd = 0;\n\n  size_t\n    hierarchy_offset,\n    layer_mask_offset;\n\n  /* clear the block! */\n  (void) ResetMagickMemory( outLayer, 0, sizeof( XCFLayerInfo ) );\n  /* read in the layer width, height, type and name */\n  outLayer->width = ReadBlobMSBLong(image);\n  outLayer->height = ReadBlobMSBLong(image);\n  outLayer->type = ReadBlobMSBLong(image);\n  (void) ReadBlobStringWithLongSize(image, outLayer->name,\n    sizeof(outLayer->name));\n  if (EOFBlob(image) != MagickFalse)\n    ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n      image->filename);\n  /* read the layer properties! */\n  foundPropEnd = 0;\n  while ( (foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse) ) {\n  PropType    prop_type = (PropType) ReadBlobMSBLong(image);\n  size_t  prop_size = ReadBlobMSBLong(image);\n    switch (prop_type)\n    {\n    case PROP_END:\n      foundPropEnd = 1;\n      break;\n    case PROP_ACTIVE_LAYER:\n      outLayer->active = 1;\n      break;\n    case PROP_FLOATING_SELECTION:\n      outLayer->floating_offset = ReadBlobMSBLong(image);\n      break;\n    case PROP_OPACITY:\n      outLayer->alpha = ReadBlobMSBLong(image);\n      break;\n    case PROP_VISIBLE:\n      outLayer->visible = ReadBlobMSBLong(image);\n      break;\n    case PROP_LINKED:\n      outLayer->linked = ReadBlobMSBLong(image);\n      break;\n    case PROP_PRESERVE_TRANSPARENCY:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n    case PROP_APPLY_MASK:\n      outLayer->apply_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_EDIT_MASK:\n      outLayer->edit_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_SHOW_MASK:\n      outLayer->show_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_OFFSETS:\n      outLayer->offset_x = ReadBlobMSBSignedLong(image);\n      outLayer->offset_y = ReadBlobMSBSignedLong(image);\n      break;\n    case PROP_MODE:\n      outLayer->mode = ReadBlobMSBLong(image);\n      break;\n    case PROP_TATTOO:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n     case PROP_PARASITES:\n     {\n       if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n         ThrowFileException(&image->exception,CorruptImageError,\n           \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n       ssize_t base = info->cp;\n       GimpParasite *p;\n       while (info->cp - base < prop_size)\n       {\n       p = xcf_load_parasite(info);\n       gimp_drawable_parasite_attach(GIMP_DRAWABLE(layer), p);\n       gimp_parasite_free(p);\n       }\n       if (info->cp - base != prop_size)\n       g_message (\"Error detected while loading a layer's parasites\");\n       */\n     }\n     break;\n    default:\n      /* g_message (\"unexpected/unknown layer property: %d (skipping)\",\n         prop_type); */\n\n      {\n      int buf[16];\n      ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n        {\n        amount = (ssize_t) MagickMin(16, prop_size);\n        amount = ReadBlob(image, (size_t) amount, (unsigned char *) &buf);\n        if (!amount)\n          ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n            image->filename);\n        prop_size -= (size_t) MagickMin(16, (size_t) amount);\n        }\n      }\n      break;\n    }\n  }\n\n  if (foundPropEnd == MagickFalse)\n    return(MagickFalse);\n  /* allocate the image for this layer */\n  if (image_info->number_scenes != 0)\n    {\n      ssize_t\n        scene;\n\n      scene=inDocInfo->number_layers-layer-1;\n      if (scene > (ssize_t) (image_info->scene+image_info->number_scenes-1))\n        {\n          outLayer->image=CloneImage(image,0,0,MagickTrue,&image->exception);\n          if (outLayer->image == (Image *) NULL)\n            return(MagickFalse);\n          InitXCFImage(outLayer);\n          return(MagickTrue);\n        }\n    }\n  /* allocate the image for this layer */\n  outLayer->image=CloneImage(image,outLayer->width, outLayer->height,MagickTrue,\n     &image->exception);\n  if (outLayer->image == (Image *) NULL)\n    return(MagickFalse);\n  /* clear the image based on the layer opacity */\n  outLayer->image->background_color.opacity=\n    ScaleCharToQuantum((unsigned char) (255-outLayer->alpha));\n  (void) SetImageBackgroundColor(outLayer->image);\n\n  InitXCFImage(outLayer);\n\n  /* set the compositing mode */\n  outLayer->image->compose = GIMPBlendModeToCompositeOperator( outLayer->mode );\n  if ( outLayer->visible == MagickFalse )\n    {\n      /* BOGUS: should really be separate member var! */\n      outLayer->image->compose = NoCompositeOp;\n    }\n\n  /* read the hierarchy and layer mask offsets */\n  hierarchy_offset = ReadBlobMSBLong(image);\n  layer_mask_offset = ReadBlobMSBLong(image);\n\n  /* read in the hierarchy */\n  offset=SeekBlob(image, (MagickOffsetType) hierarchy_offset, SEEK_SET);\n  if (offset != (MagickOffsetType) hierarchy_offset)\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageError,\"InvalidImageHeader\",\"`%s'\",image->filename);\n  if (load_hierarchy (image, inDocInfo, outLayer) == 0)\n    return(MagickFalse);\n\n  /* read in the layer mask */\n  if (layer_mask_offset != 0)\n    {\n      offset=SeekBlob(image, (MagickOffsetType) layer_mask_offset, SEEK_SET);\n\n#if 0  /* BOGUS: support layer masks! */\n      layer_mask = xcf_load_layer_mask (info, gimage);\n      if (layer_mask == 0)\n  goto error;\n\n      /* set the offsets of the layer_mask */\n      GIMP_DRAWABLE (layer_mask)->offset_x = GIMP_DRAWABLE (layer)->offset_x;\n      GIMP_DRAWABLE (layer_mask)->offset_y = GIMP_DRAWABLE (layer)->offset_y;\n\n      gimp_layer_add_mask (layer, layer_mask, MagickFalse);\n\n      layer->mask->apply_mask = apply_mask;\n      layer->mask->edit_mask  = edit_mask;\n      layer->mask->show_mask  = show_mask;\n#endif\n  }\n\n  /* attach the floating selection... */\n#if 0  /* BOGUS: we may need to read this, even if we don't support it! */\n  if (add_floating_sel)\n    {\n      GimpLayer *floating_sel;\n\n      floating_sel = info->floating_sel;\n      floating_sel_attach (floating_sel, GIMP_DRAWABLE (layer));\n    }\n#endif\n\n  return MagickTrue;\n}",
        "func": "static MagickBooleanType ReadOneLayer(const ImageInfo *image_info,Image* image,\n  XCFDocInfo* inDocInfo,XCFLayerInfo *outLayer,const ssize_t layer)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  unsigned int\n    foundPropEnd = 0;\n\n  size_t\n    hierarchy_offset,\n    layer_mask_offset;\n\n  /* clear the block! */\n  (void) ResetMagickMemory( outLayer, 0, sizeof( XCFLayerInfo ) );\n  /* read in the layer width, height, type and name */\n  outLayer->width = ReadBlobMSBLong(image);\n  outLayer->height = ReadBlobMSBLong(image);\n  outLayer->type = ReadBlobMSBLong(image);\n  (void) ReadBlobStringWithLongSize(image, outLayer->name,\n    sizeof(outLayer->name));\n  if (EOFBlob(image) != MagickFalse)\n    ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n      image->filename);\n  /* read the layer properties! */\n  foundPropEnd = 0;\n  while ( (foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse) ) {\n  PropType    prop_type = (PropType) ReadBlobMSBLong(image);\n  size_t  prop_size = ReadBlobMSBLong(image);\n    switch (prop_type)\n    {\n    case PROP_END:\n      foundPropEnd = 1;\n      break;\n    case PROP_ACTIVE_LAYER:\n      outLayer->active = 1;\n      break;\n    case PROP_FLOATING_SELECTION:\n      outLayer->floating_offset = ReadBlobMSBLong(image);\n      break;\n    case PROP_OPACITY:\n      outLayer->alpha = ReadBlobMSBLong(image);\n      break;\n    case PROP_VISIBLE:\n      outLayer->visible = ReadBlobMSBLong(image);\n      break;\n    case PROP_LINKED:\n      outLayer->linked = ReadBlobMSBLong(image);\n      break;\n    case PROP_PRESERVE_TRANSPARENCY:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n    case PROP_APPLY_MASK:\n      outLayer->apply_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_EDIT_MASK:\n      outLayer->edit_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_SHOW_MASK:\n      outLayer->show_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_OFFSETS:\n      outLayer->offset_x = ReadBlobMSBSignedLong(image);\n      outLayer->offset_y = ReadBlobMSBSignedLong(image);\n      break;\n    case PROP_MODE:\n      outLayer->mode = ReadBlobMSBLong(image);\n      break;\n    case PROP_TATTOO:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n     case PROP_PARASITES:\n     {\n       if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n         ThrowFileException(&image->exception,CorruptImageError,\n           \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n       ssize_t base = info->cp;\n       GimpParasite *p;\n       while (info->cp - base < prop_size)\n       {\n       p = xcf_load_parasite(info);\n       gimp_drawable_parasite_attach(GIMP_DRAWABLE(layer), p);\n       gimp_parasite_free(p);\n       }\n       if (info->cp - base != prop_size)\n       g_message (\"Error detected while loading a layer's parasites\");\n       */\n     }\n     break;\n    default:\n      /* g_message (\"unexpected/unknown layer property: %d (skipping)\",\n         prop_type); */\n\n      {\n      int buf[16];\n      ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n        {\n        amount = (ssize_t) MagickMin(16, prop_size);\n        amount = ReadBlob(image, (size_t) amount, (unsigned char *) &buf);\n        if (!amount)\n          ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n            image->filename);\n        prop_size -= (size_t) MagickMin(16, (size_t) amount);\n        }\n      }\n      break;\n    }\n  }\n\n  if (foundPropEnd == MagickFalse)\n    return(MagickFalse);\n  /* allocate the image for this layer */\n  if (image_info->number_scenes != 0)\n    {\n      ssize_t\n        scene;\n\n      scene=inDocInfo->number_layers-layer-1;\n      if (scene > (ssize_t) (image_info->scene+image_info->number_scenes-1))\n        {\n          outLayer->image=CloneImage(image,0,0,MagickTrue,&image->exception);\n          if (outLayer->image == (Image *) NULL)\n            return(MagickFalse);\n          InitXCFImage(outLayer);\n          return(MagickTrue);\n        }\n    }\n  /* allocate the image for this layer */\n  outLayer->image=CloneImage(image,outLayer->width, outLayer->height,MagickTrue,\n     &image->exception);\n  if (outLayer->image == (Image *) NULL)\n    return(MagickFalse);\n  status=SetImageExtent(outLayer->image,outLayer->image->columns,\n    outLayer->image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(&image->exception,&outLayer->image->exception);\n      outLayer->image=DestroyImageList(outLayer->image);\n      return(MagickFalse);\n    }\n  /* clear the image based on the layer opacity */\n  outLayer->image->background_color.opacity=\n    ScaleCharToQuantum((unsigned char) (255-outLayer->alpha));\n  (void) SetImageBackgroundColor(outLayer->image);\n\n  InitXCFImage(outLayer);\n\n  /* set the compositing mode */\n  outLayer->image->compose = GIMPBlendModeToCompositeOperator( outLayer->mode );\n  if ( outLayer->visible == MagickFalse )\n    {\n      /* BOGUS: should really be separate member var! */\n      outLayer->image->compose = NoCompositeOp;\n    }\n\n  /* read the hierarchy and layer mask offsets */\n  hierarchy_offset = ReadBlobMSBLong(image);\n  layer_mask_offset = ReadBlobMSBLong(image);\n\n  /* read in the hierarchy */\n  offset=SeekBlob(image, (MagickOffsetType) hierarchy_offset, SEEK_SET);\n  if (offset != (MagickOffsetType) hierarchy_offset)\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageError,\"InvalidImageHeader\",\"`%s'\",image->filename);\n  if (load_hierarchy (image, inDocInfo, outLayer) == 0)\n    return(MagickFalse);\n\n  /* read in the layer mask */\n  if (layer_mask_offset != 0)\n    {\n      offset=SeekBlob(image, (MagickOffsetType) layer_mask_offset, SEEK_SET);\n\n#if 0  /* BOGUS: support layer masks! */\n      layer_mask = xcf_load_layer_mask (info, gimage);\n      if (layer_mask == 0)\n  goto error;\n\n      /* set the offsets of the layer_mask */\n      GIMP_DRAWABLE (layer_mask)->offset_x = GIMP_DRAWABLE (layer)->offset_x;\n      GIMP_DRAWABLE (layer_mask)->offset_y = GIMP_DRAWABLE (layer)->offset_y;\n\n      gimp_layer_add_mask (layer, layer_mask, MagickFalse);\n\n      layer->mask->apply_mask = apply_mask;\n      layer->mask->edit_mask  = edit_mask;\n      layer->mask->show_mask  = show_mask;\n#endif\n  }\n\n  /* attach the floating selection... */\n#if 0  /* BOGUS: we may need to read this, even if we don't support it! */\n  if (add_floating_sel)\n    {\n      GimpLayer *floating_sel;\n\n      floating_sel = info->floating_sel;\n      floating_sel_attach (floating_sel, GIMP_DRAWABLE (layer));\n    }\n#endif\n\n  return MagickTrue;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n static MagickBooleanType ReadOneLayer(const ImageInfo *image_info,Image* image,\n   XCFDocInfo* inDocInfo,XCFLayerInfo *outLayer,const ssize_t layer)\n {\n+  MagickBooleanType\n+    status;\n+\n   MagickOffsetType\n     offset;\n \n@@ -135,6 +138,14 @@\n      &image->exception);\n   if (outLayer->image == (Image *) NULL)\n     return(MagickFalse);\n+  status=SetImageExtent(outLayer->image,outLayer->image->columns,\n+    outLayer->image->rows);\n+  if (status == MagickFalse)\n+    {\n+      InheritException(&image->exception,&outLayer->image->exception);\n+      outLayer->image=DestroyImageList(outLayer->image);\n+      return(MagickFalse);\n+    }\n   /* clear the image based on the layer opacity */\n   outLayer->image->background_color.opacity=\n     ScaleCharToQuantum((unsigned char) (255-outLayer->alpha));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  MagickBooleanType",
                "    status;",
                "",
                "  status=SetImageExtent(outLayer->image,outLayer->image->columns,",
                "    outLayer->image->rows);",
                "  if (status == MagickFalse)",
                "    {",
                "      InheritException(&image->exception,&outLayer->image->exception);",
                "      outLayer->image=DestroyImageList(outLayer->image);",
                "      return(MagickFalse);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12875",
        "func_name": "ImageMagick/ReadXCFImage",
        "description": "The WritePixelCachePixels function in ImageMagick 7.0.6-6 allows remote attackers to cause a denial of service (CPU consumption) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6f95e543c80319721e22d623bb23712cd29afa9e",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/659",
        "commit_text": "",
        "func_before": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          ssize_t j;\n\n          for (j=0; j <= current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n  }\n\n  (void) CloseBlob(image);\n  if (GetNextImageInList(image) != (Image *) NULL)\n    DestroyImage(RemoveFirstImageFromList(&image));\n  if (image_type == GIMP_GRAY)\n    image->type=GrayscaleType;\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          ssize_t j;\n\n          for (j=0; j <= current_layer; j++)\n            if (layer_info[j].image != (Image *) NULL)\n              layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n  }\n\n  (void) CloseBlob(image);\n  if (GetNextImageInList(image) != (Image *) NULL)\n    DestroyImage(RemoveFirstImageFromList(&image));\n  if (image_type == GIMP_GRAY)\n    image->type=GrayscaleType;\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -337,7 +337,8 @@\n           ssize_t j;\n \n           for (j=0; j <= current_layer; j++)\n-            layer_info[j].image=DestroyImage(layer_info[j].image);\n+            if (layer_info[j].image != (Image *) NULL)\n+              layer_info[j].image=DestroyImage(layer_info[j].image);\n           layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "            layer_info[j].image=DestroyImage(layer_info[j].image);"
            ],
            "added_lines": [
                "            if (layer_info[j].image != (Image *) NULL)",
                "              layer_info[j].image=DestroyImage(layer_info[j].image);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14107",
        "func_name": "nih-at/libzip/_zip_read_eocd64",
        "description": "The _zip_read_eocd64 function in zip_open.c in libzip before 1.3.0 mishandles EOCD records, which allows remote attackers to cause a denial of service (memory allocation failure in _zip_cdir_grow in zip_dirent.c) via a crafted ZIP archive.",
        "git_url": "https://github.com/nih-at/libzip/commit/9b46957ec98d85a572e9ef98301247f39338a3b5",
        "commit_title": "Make eocd checks more consistent between zip and zip64 cases.",
        "commit_text": "",
        "func_before": "static zip_cdir_t *\n_zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n    zip_uint64_t offset;\n    zip_uint8_t eocd[EOCD64LEN];\n    zip_uint64_t eocd_offset;\n    zip_uint64_t size, nentry, i, eocdloc_offset;\n    bool free_buffer;\n    zip_uint32_t num_disks, num_disks64, eocd_disk, eocd_disk64;\n\n    eocdloc_offset = _zip_buffer_offset(buffer);\n\n    _zip_buffer_get(buffer, 4); /* magic already verified */\n\n    num_disks = _zip_buffer_get_16(buffer);\n    eocd_disk = _zip_buffer_get_16(buffer);\n    eocd_offset = _zip_buffer_get_64(buffer);\n\n    if (eocd_offset > ZIP_INT64_MAX || eocd_offset + EOCD64LEN < eocd_offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n\n    if (eocd_offset + EOCD64LEN > eocdloc_offset + buf_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if (eocd_offset >= buf_offset && eocd_offset + EOCD64LEN <= buf_offset + _zip_buffer_size(buffer)) {\n        _zip_buffer_set_offset(buffer, eocd_offset - buf_offset);\n        free_buffer = false;\n    }\n    else {\n        if (zip_source_seek(src, (zip_int64_t)eocd_offset, SEEK_SET) < 0) {\n            _zip_error_set_from_source(error, src);\n            return NULL;\n        }\n        if ((buffer = _zip_buffer_new_from_source(src, EOCD64LEN, eocd, error)) == NULL) {\n            return NULL;\n        }\n        free_buffer = true;\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), EOCD64_MAGIC, 4) != 0) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n\n    if ((flags & ZIP_CHECKCONS) && size + eocd_offset + 12 != buf_offset + eocdloc_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    _zip_buffer_get(buffer, 4); /* skip version made by/needed */\n\n    num_disks64 = _zip_buffer_get_32(buffer);\n    eocd_disk64 = _zip_buffer_get_32(buffer);\n\n    /* if eocd values are 0xffff, we have to use eocd64 values.\n       otherwise, if the values are not the same, it's inconsistent;\n       in any case, if the value is not 0, we don't support it */\n    if (num_disks == 0xffff) {\n\tnum_disks = num_disks64;\n    }\n    if (eocd_disk == 0xffff) {\n\teocd_disk = eocd_disk64;\n    }\n    if ((flags & ZIP_CHECKCONS) && (eocd_disk != eocd_disk64 || num_disks != num_disks64)) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n    if (num_disks != 0 || eocd_disk != 0) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    nentry = _zip_buffer_get_64(buffer);\n    i = _zip_buffer_get_64(buffer);\n\n    if (nentry != i) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n    offset = _zip_buffer_get_64(buffer);\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    if (free_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    if (offset > ZIP_INT64_MAX || offset+size < offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n    if ((flags & ZIP_CHECKCONS) && offset+size != eocd_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if ((cd=_zip_cdir_new(nentry, error)) == NULL)\n\treturn NULL;\n\n    cd->is_zip64 = true;\n    cd->size = size;\n    cd->offset = offset;\n\n    return cd;\n}",
        "func": "static zip_cdir_t *\n_zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n    zip_uint64_t offset;\n    zip_uint8_t eocd[EOCD64LEN];\n    zip_uint64_t eocd_offset;\n    zip_uint64_t size, nentry, i, eocdloc_offset;\n    bool free_buffer;\n    zip_uint32_t num_disks, num_disks64, eocd_disk, eocd_disk64;\n\n    eocdloc_offset = _zip_buffer_offset(buffer);\n\n    _zip_buffer_get(buffer, 4); /* magic already verified */\n\n    num_disks = _zip_buffer_get_16(buffer);\n    eocd_disk = _zip_buffer_get_16(buffer);\n    eocd_offset = _zip_buffer_get_64(buffer);\n\n    if (eocd_offset > ZIP_INT64_MAX || eocd_offset + EOCD64LEN < eocd_offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n\n    if (eocd_offset + EOCD64LEN > eocdloc_offset + buf_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if (eocd_offset >= buf_offset && eocd_offset + EOCD64LEN <= buf_offset + _zip_buffer_size(buffer)) {\n        _zip_buffer_set_offset(buffer, eocd_offset - buf_offset);\n        free_buffer = false;\n    }\n    else {\n        if (zip_source_seek(src, (zip_int64_t)eocd_offset, SEEK_SET) < 0) {\n            _zip_error_set_from_source(error, src);\n            return NULL;\n        }\n        if ((buffer = _zip_buffer_new_from_source(src, EOCD64LEN, eocd, error)) == NULL) {\n            return NULL;\n        }\n        free_buffer = true;\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), EOCD64_MAGIC, 4) != 0) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n\n    if ((flags & ZIP_CHECKCONS) && size + eocd_offset + 12 != buf_offset + eocdloc_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    _zip_buffer_get(buffer, 4); /* skip version made by/needed */\n\n    num_disks64 = _zip_buffer_get_32(buffer);\n    eocd_disk64 = _zip_buffer_get_32(buffer);\n\n    /* if eocd values are 0xffff, we have to use eocd64 values.\n       otherwise, if the values are not the same, it's inconsistent;\n       in any case, if the value is not 0, we don't support it */\n    if (num_disks == 0xffff) {\n\tnum_disks = num_disks64;\n    }\n    if (eocd_disk == 0xffff) {\n\teocd_disk = eocd_disk64;\n    }\n    if ((flags & ZIP_CHECKCONS) && (eocd_disk != eocd_disk64 || num_disks != num_disks64)) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n    if (num_disks != 0 || eocd_disk != 0) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    nentry = _zip_buffer_get_64(buffer);\n    i = _zip_buffer_get_64(buffer);\n\n    if (nentry != i) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n    offset = _zip_buffer_get_64(buffer);\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    if (free_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    if (offset > ZIP_INT64_MAX || offset+size < offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n    if (offset+size > buf_offset + eocd_offset) {\n\t/* cdir spans past EOCD record */\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n    if ((flags & ZIP_CHECKCONS) && offset+size != buf_offset + eocd_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if ((cd=_zip_cdir_new(nentry, error)) == NULL)\n\treturn NULL;\n\n    cd->is_zip64 = true;\n    cd->size = size;\n    cd->offset = offset;\n\n    return cd;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -119,7 +119,12 @@\n         zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n         return NULL;\n     }\n-    if ((flags & ZIP_CHECKCONS) && offset+size != eocd_offset) {\n+    if (offset+size > buf_offset + eocd_offset) {\n+\t/* cdir spans past EOCD record */\n+\tzip_error_set(error, ZIP_ER_INCONS, 0);\n+\treturn NULL;\n+    }\n+    if ((flags & ZIP_CHECKCONS) && offset+size != buf_offset + eocd_offset) {\n \tzip_error_set(error, ZIP_ER_INCONS, 0);\n \treturn NULL;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if ((flags & ZIP_CHECKCONS) && offset+size != eocd_offset) {"
            ],
            "added_lines": [
                "    if (offset+size > buf_offset + eocd_offset) {",
                "\t/* cdir spans past EOCD record */",
                "\tzip_error_set(error, ZIP_ER_INCONS, 0);",
                "\treturn NULL;",
                "    }",
                "    if ((flags & ZIP_CHECKCONS) && offset+size != buf_offset + eocd_offset) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12691",
        "func_name": "ImageMagick/load_tile",
        "description": "The ReadOneLayer function in coders/xcf.c in ImageMagick 7.0.6-6 allows remote attackers to cause a denial of service (memory consumption) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/68bbe7b8b226ed79e339296793f68f1b2bebc519",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/656",
        "commit_text": "",
        "func_before": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length)\n{\n  ExceptionInfo\n    *exception;\n\n  ssize_t\n    y;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    extent;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *graydata;\n\n  XCFPixelPacket\n    *xcfdata,\n    *xcfodata;\n\n  extent=0;\n  if (inDocInfo->image_type == GIMP_GRAY)\n    extent=tile_image->columns*tile_image->rows*sizeof(*graydata);\n  else\n    if (inDocInfo->image_type == GIMP_RGB)\n      extent=tile_image->columns*tile_image->rows*sizeof(*xcfdata);\n  if (extent > data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  xcfdata=(XCFPixelPacket *) AcquireQuantumMemory(MagickMax(data_length,\n    tile_image->columns*tile_image->rows),sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelPacket *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */\n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  exception=(&image->exception);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelRed(q,ScaleCharToQuantum(*graydata));\n          SetPixelGreen(q,GetPixelRed(q));\n          SetPixelBlue(q,GetPixelRed(q));\n          SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha));\n          graydata++;\n          q++;\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(xcfdata->red));\n            SetPixelGreen(q,ScaleCharToQuantum(xcfdata->green));\n            SetPixelBlue(q,ScaleCharToQuantum(xcfdata->blue));\n            SetPixelAlpha(q,xcfdata->alpha == 255U ? TransparentOpacity :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha));\n            xcfdata++;\n            q++;\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelPacket *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}",
        "func": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length)\n{\n  ExceptionInfo\n    *exception;\n\n  ssize_t\n    y;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    extent;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *graydata;\n\n  XCFPixelPacket\n    *xcfdata,\n    *xcfodata;\n\n  extent=0;\n  if (inDocInfo->image_type == GIMP_GRAY)\n    extent=tile_image->columns*tile_image->rows*sizeof(*graydata);\n  else\n    if (inDocInfo->image_type == GIMP_RGB)\n      extent=tile_image->columns*tile_image->rows*sizeof(*xcfdata);\n  if (extent > data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  xcfdata=(XCFPixelPacket *) AcquireQuantumMemory(MagickMax(data_length,\n    tile_image->columns*tile_image->rows),sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelPacket *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */\n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    {\n      xcfodata=(XCFPixelPacket *) RelinquishMagickMemory(xcfodata);\n      ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n        image->filename);\n    }\n  exception=(&image->exception);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelRed(q,ScaleCharToQuantum(*graydata));\n          SetPixelGreen(q,GetPixelRed(q));\n          SetPixelBlue(q,GetPixelRed(q));\n          SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha));\n          graydata++;\n          q++;\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(xcfdata->red));\n            SetPixelGreen(q,ScaleCharToQuantum(xcfdata->green));\n            SetPixelBlue(q,ScaleCharToQuantum(xcfdata->blue));\n            SetPixelAlpha(q,xcfdata->alpha == 255U ? TransparentOpacity :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha));\n            xcfdata++;\n            q++;\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelPacket *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,8 +44,11 @@\n   graydata=(unsigned char *) xcfdata;  /* used by gray and indexed */\n   count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n   if (count != (ssize_t) data_length)\n-    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n-      image->filename);\n+    {\n+      xcfodata=(XCFPixelPacket *) RelinquishMagickMemory(xcfodata);\n+      ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n+        image->filename);\n+    }\n   exception=(&image->exception);\n   for (y=0; y < (ssize_t) tile_image->rows; y++)\n   {",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",",
                "      image->filename);"
            ],
            "added_lines": [
                "    {",
                "      xcfodata=(XCFPixelPacket *) RelinquishMagickMemory(xcfodata);",
                "      ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",",
                "        image->filename);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12691",
        "func_name": "ImageMagick/ReadXCFImage",
        "description": "The ReadOneLayer function in coders/xcf.c in ImageMagick 7.0.6-6 allows remote attackers to cause a denial of service (memory consumption) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/68bbe7b8b226ed79e339296793f68f1b2bebc519",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/656",
        "commit_text": "",
        "func_before": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          int j;\n\n          for (j=0; j < current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n  }\n\n  (void) CloseBlob(image);\n  if (GetNextImageInList(image) != (Image *) NULL)\n    DestroyImage(RemoveFirstImageFromList(&image));\n  if (image_type == GIMP_GRAY)\n    image->type=GrayscaleType;\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[14];\n\n  Image\n    *image;\n\n  int\n    foundPropEnd = 0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i;\n\n  size_t\n    image_type,\n    length;\n\n  ssize_t\n    count;\n\n  XCFDocInfo\n    doc_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  count=ReadBlob(image,14,(unsigned char *) magick);\n  if ((count != 14) ||\n      (LocaleNCompare((char *) magick,\"gimp xcf\",8) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));\n  doc_info.exception=exception;\n  doc_info.width=ReadBlobMSBLong(image);\n  doc_info.height=ReadBlobMSBLong(image);\n  if ((doc_info.width > 262144) || (doc_info.height > 262144))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  doc_info.image_type=ReadBlobMSBLong(image);\n  /*\n    Initialize image attributes.\n  */\n  image->columns=doc_info.width;\n  image->rows=doc_info.height;\n  image_type=doc_info.image_type;\n  doc_info.file_size=GetBlobSize(image);\n  image->compression=NoCompression;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image_type == GIMP_RGB)\n    ;\n  else\n    if (image_type == GIMP_GRAY)\n      image->colorspace=GRAYColorspace;\n    else\n      if (image_type == GIMP_INDEXED)\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n  (void) SetImageOpacity(image,OpaqueOpacity); \n  (void) SetImageBackgroundColor(image);\n  /*\n    Read properties.\n  */\n  while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))\n  {\n    PropType prop_type = (PropType) ReadBlobMSBLong(image);\n    size_t prop_size = ReadBlobMSBLong(image);\n\n    switch (prop_type)\n    {\n      case PROP_END:\n        foundPropEnd=1;\n        break;\n      case PROP_COLORMAP:\n      {\n        /* Cannot rely on prop_size here--the value is set incorrectly\n           by some Gimp versions.\n        */\n        size_t num_colours = ReadBlobMSBLong(image);\n        if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n    /*\n      if (info->file_version == 0)\n      {\n        gint i;\n\n        g_message (_(\"XCF warning: version 0 of XCF file format\\n\"\n           \"did not save indexed colormaps correctly.\\n\"\n           \"Substituting grayscale map.\"));\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        xcf_seek_pos (info, info->cp + gimage->num_cols);\n        for (i = 0; i<gimage->num_cols; i++)\n          {\n            gimage->cmap[i*3+0] = i;\n            gimage->cmap[i*3+1] = i;\n            gimage->cmap[i*3+2] = i;\n          }\n      }\n      else\n      {\n        info->cp +=\n          xcf_read_int32 (info->fp, (guint32*) &gimage->num_cols, 1);\n        gimage->cmap = g_new (guchar, gimage->num_cols*3);\n        info->cp +=\n          xcf_read_int8 (info->fp,\n                   (guint8*) gimage->cmap, gimage->num_cols*3);\n      }\n     */\n        break;\n      }\n      case PROP_COMPRESSION:\n      {\n        doc_info.compression = ReadBlobByte(image);\n        if ((doc_info.compression != COMPRESS_NONE) &&\n            (doc_info.compression != COMPRESS_RLE) &&\n            (doc_info.compression != COMPRESS_ZLIB) &&\n            (doc_info.compression != COMPRESS_FRACTAL))\n          ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n      }\n      break;\n\n      case PROP_GUIDES:\n      {\n         /* just skip it - we don't care about guides */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n      }\n      break;\n\n    case PROP_RESOLUTION:\n      {\n        /* float xres = (float) */ (void) ReadBlobMSBLong(image);\n        /* float yres = (float) */ (void) ReadBlobMSBLong(image);\n\n        /*\n        if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION ||\n            yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION)\n        {\n        g_message (\"Warning, resolution out of range in XCF file\");\n        xres = gimage->gimp->config->default_xresolution;\n        yres = gimage->gimp->config->default_yresolution;\n        }\n        */\n\n\n        /* BOGUS: we don't write these yet because we aren't\n              reading them properly yet :(\n              image->x_resolution = xres;\n              image->y_resolution = yres;\n        */\n      }\n      break;\n\n    case PROP_TATTOO:\n      {\n        /* we need to read it, even if we ignore it */\n        /*size_t  tattoo_state = */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PARASITES:\n      {\n        /* BOGUS: we may need these for IPTC stuff */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n        /*\n      gssize_t         base = info->cp;\n      GimpParasite *p;\n\n      while (info->cp - base < prop_size)\n        {\n          p = xcf_load_parasite (info);\n          gimp_image_parasite_attach (gimage, p);\n          gimp_parasite_free (p);\n        }\n      if (info->cp - base != prop_size)\n        g_message (\"Error detected while loading an image's parasites\");\n      */\n          }\n      break;\n\n    case PROP_UNIT:\n      {\n        /* BOGUS: ignore for now... */\n      /*size_t unit =  */ (void) ReadBlobMSBLong(image);\n      }\n      break;\n\n    case PROP_PATHS:\n      {\n      /* BOGUS: just skip it for now */\n        if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n          ThrowFileException(&image->exception,CorruptImageError,\n            \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n      PathList *paths = xcf_load_bzpaths (gimage, info);\n      gimp_image_set_paths (gimage, paths);\n      */\n      }\n      break;\n\n    case PROP_USER_UNIT:\n      {\n        char  unit_string[1000];\n        /*BOGUS: ignored for now */\n        /*float  factor = (float) */ (void) ReadBlobMSBLong(image);\n        /* size_t digits =  */ (void) ReadBlobMSBLong(image);\n        for (i=0; i<5; i++)\n         (void) ReadBlobStringWithLongSize(image, unit_string,\n           sizeof(unit_string));\n      }\n     break;\n\n      default:\n      {\n        int buf[16];\n        ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n      {\n        amount=(ssize_t) MagickMin(16, prop_size);\n        amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);\n        if (!amount)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n        prop_size -= (size_t) MagickMin(16,(size_t) amount);\n      }\n    }\n    break;\n  }\n  }\n  if (foundPropEnd == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    {\n      ; /* do nothing, were just pinging! */\n    }\n  else\n    {\n      int\n        current_layer = 0,\n        foundAllLayers = MagickFalse,\n        number_layers = 0;\n\n      MagickOffsetType\n        oldPos=TellBlob(image);\n\n      XCFLayerInfo\n        *layer_info;\n\n      /*\n        The read pointer.\n      */\n      do\n      {\n        ssize_t offset = ReadBlobMSBSignedLong(image);\n        if (offset == 0)\n          foundAllLayers=MagickTrue;\n        else\n          number_layers++;\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n    } while (foundAllLayers == MagickFalse);\n    doc_info.number_layers=number_layers;\n    offset=SeekBlob(image,oldPos,SEEK_SET); /* restore the position! */\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /* allocate our array of layer info blocks */\n    length=(size_t) number_layers;\n    layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,\n      sizeof(*layer_info));\n    if (layer_info == (XCFLayerInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));\n    for ( ; ; )\n    {\n      MagickBooleanType\n        layer_ok;\n\n      MagickOffsetType\n        offset,\n        saved_pos;\n\n      /* read in the offset of the next layer */\n      offset=(MagickOffsetType) ReadBlobMSBLong(image);\n      /* if the offset is 0 then we are at the end\n      *  of the layer list.\n      */\n      if (offset == 0)\n        break;\n      /* save the current position as it is where the\n      *  next layer offset is stored.\n      */\n      saved_pos=TellBlob(image);\n      /* seek to the layer offset */\n      if (SeekBlob(image,offset,SEEK_SET) != offset)\n        ThrowReaderException(ResourceLimitError,\"NotEnoughPixelData\");\n      /* read in the layer */\n      layer_ok=ReadOneLayer(image_info,image,&doc_info,\n        &layer_info[current_layer],current_layer);\n      if (layer_ok == MagickFalse)\n        {\n          ssize_t j;\n\n          for (j=0; j <= current_layer; j++)\n            layer_info[j].image=DestroyImage(layer_info[j].image);\n          layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      offset=SeekBlob(image, saved_pos, SEEK_SET);\n      current_layer++;\n    }\n#if 0\n        {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        signed int  j;\n        for (j=number_layers-1; j>=0; j--) {\n          /* BOGUS: need to consider layer blending modes!! */\n\n          if ( layer_info[j].visible ) { /* only visible ones, please! */\n            CompositeImage(image, OverCompositeOp, layer_info[j].image,\n                     layer_info[j].offset_x, layer_info[j].offset_y );\n             layer_info[j].image =DestroyImage( layer_info[j].image );\n\n            /* If we do this, we'll get REAL gray images! */\n            if ( image_type == GIMP_GRAY ) {\n              QuantizeInfo  qi;\n              GetQuantizeInfo(&qi);\n              qi.colorspace = GRAYColorspace;\n              QuantizeImage( &qi, layer_info[j].image );\n            }\n          }\n        }\n      }\n#else\n      {\n        /* NOTE: XCF layers are REVERSED from composite order! */\n        ssize_t  j;\n\n        /* now reverse the order of the layers as they are put\n           into subimages\n        */\n        for (j=(long) number_layers-1; j >= 0; j--)\n          AppendImageToList(&image,layer_info[j].image);\n      }\n#endif\n\n    layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n\n#if 0  /* BOGUS: do we need the channels?? */\n    while (MagickTrue)\n    {\n      /* read in the offset of the next channel */\n      info->cp += xcf_read_int32 (info->fp, &offset, 1);\n\n      /* if the offset is 0 then we are at the end\n      *  of the channel list.\n      */\n      if (offset == 0)\n        break;\n\n      /* save the current position as it is where the\n      *  next channel offset is stored.\n      */\n      saved_pos = info->cp;\n\n      /* seek to the channel offset */\n      xcf_seek_pos (info, offset);\n\n      /* read in the layer */\n      channel = xcf_load_channel (info, gimage);\n      if (channel == 0)\n        goto error;\n\n      num_successful_elements++;\n\n      /* add the channel to the image if its not the selection */\n      if (channel != gimage->selection_mask)\n        gimp_image_add_channel (gimage, channel, -1);\n\n      /* restore the saved position so we'll be ready to\n      *  read the next offset.\n      */\n      xcf_seek_pos (info, saved_pos);\n    }\n#endif\n  }\n\n  (void) CloseBlob(image);\n  if (GetNextImageInList(image) != (Image *) NULL)\n    DestroyImage(RemoveFirstImageFromList(&image));\n  if (image_type == GIMP_GRAY)\n    image->type=GrayscaleType;\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -334,9 +334,9 @@\n         &layer_info[current_layer],current_layer);\n       if (layer_ok == MagickFalse)\n         {\n-          int j;\n-\n-          for (j=0; j < current_layer; j++)\n+          ssize_t j;\n+\n+          for (j=0; j <= current_layer; j++)\n             layer_info[j].image=DestroyImage(layer_info[j].image);\n           layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
        "diff_line_info": {
            "deleted_lines": [
                "          int j;",
                "",
                "          for (j=0; j < current_layer; j++)"
            ],
            "added_lines": [
                "          ssize_t j;",
                "",
                "          for (j=0; j <= current_layer; j++)"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12692",
        "func_name": "ImageMagick/RegisterVIFFImage",
        "description": "The ReadVIFFImage function in coders/viff.c in ImageMagick 7.0.6-6 allows remote attackers to cause a denial of service (memory consumption) via a crafted VIFF file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/4a25fe5447bfb3a1918a2e9d595928e853b09d2e",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/653",
        "commit_text": "",
        "func_before": "ModuleExport size_t RegisterVIFFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"VIFF\",\"VIFF\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->magick=(IsImageFormatHandler *) IsVIFF;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"VIFF\",\"XV\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "func": "ModuleExport size_t RegisterVIFFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"VIFF\",\"VIFF\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->magick=(IsImageFormatHandler *) IsVIFF;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"VIFF\",\"XV\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,10 +7,12 @@\n   entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n   entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n   entry->magick=(IsImageFormatHandler *) IsVIFF;\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   (void) RegisterMagickInfo(entry);\n   entry=AcquireMagickInfo(\"VIFF\",\"XV\",\"Khoros Visualization image\");\n   entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n   entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n+  entry->flags|=CoderDecoderSeekableStreamFlag;\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  entry->flags|=CoderDecoderSeekableStreamFlag;",
                "  entry->flags|=CoderDecoderSeekableStreamFlag;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12692",
        "func_name": "ImageMagick/ReadVIFFImage",
        "description": "The ReadVIFFImage function in coders/viff.c in ImageMagick 7.0.6-6 allows remote attackers to cause a denial of service (memory consumption) via a crafted VIFF file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/4a25fe5447bfb3a1918a2e9d595928e853b09d2e",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/653",
        "commit_text": "",
        "func_before": "static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=ReadBlobSignedLong(image);\n    viff_info.y_offset=ReadBlobSignedLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n      DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (HeapOverflowSanityCheck(number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red,q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green,q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue,q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=ReadBlobSignedLong(image);\n    viff_info.y_offset=ReadBlobSignedLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n      DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (HeapOverflowSanityCheck(number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    if ((bytes_per_pixel*max_packets) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red,q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green,q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue,q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -371,6 +371,8 @@\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n       }\n+    if ((bytes_per_pixel*max_packets) > GetBlobSize(image))\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n       max_packets),bytes_per_pixel*sizeof(*pixels));\n     if (pixels == (unsigned char *) NULL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if ((bytes_per_pixel*max_packets) > GetBlobSize(image))",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-22894",
        "func_name": "jerryscript-project/jerryscript/ecma_builtin_array_flatten_into_array",
        "description": "Jerryscript 3.0.0 was discovered to contain a stack overflow via ecma_lcache_lookup in /jerry-core/ecma/base/ecma-lcache.c.",
        "git_url": "https://github.com/jerryscript-project/jerryscript/commit/99c81be1a20f736b025a25a9061c89de09241120",
        "commit_title": "Add stack-overflow check for Array.prototype.{flat, flatMap}",
        "commit_text": " This patch fixes #4890  JerryScript-DCO-1.0-Signed-off-by: Robert Fancsik robert.fancsik@h-lab.eu",
        "func_before": "static ecma_value_t\necma_builtin_array_flatten_into_array (ecma_value_t target, /**< target will contains source's elements  */\n                                       ecma_object_t *source, /**< source object */\n                                       ecma_length_t source_len, /**< source object length */\n                                       ecma_length_t start, /**< remaining recursion depth */\n                                       ecma_number_t depth, /**< start index offset */\n                                       ecma_value_t mapped_value, /**< mapped value  */\n                                       ecma_value_t thisArg) /**< this arg */\n{\n  /* 7. */\n  ecma_length_t target_index = start;\n\n  /* 9. */\n  for (ecma_length_t source_index = 0; source_index < source_len; source_index++)\n  {\n    /* a. */\n    ecma_value_t element = ecma_op_object_find_by_index (source, source_index);\n\n    if (ECMA_IS_VALUE_ERROR (element))\n    {\n      return element;\n    }\n\n    if (!ecma_is_value_found (element))\n    {\n      continue;\n    }\n\n    /* b-c. */\n    if (!ecma_is_value_undefined (mapped_value))\n    {\n      /* i-ii. */\n      ecma_value_t source_val = ecma_make_length_value (source_index);\n      ecma_value_t args[] = { element, source_val, ecma_make_object_value (source) };\n      ecma_value_t temp_element = ecma_op_function_call (ecma_get_object_from_value (mapped_value), thisArg, args, 3);\n\n      ecma_free_value (element);\n      ecma_free_value (source_val);\n\n      if (ECMA_IS_VALUE_ERROR (temp_element))\n      {\n        return temp_element;\n      }\n\n      element = temp_element;\n    }\n\n    /* iv-v. */\n    if (depth > 0)\n    {\n      ecma_value_t is_array = ecma_is_value_array (element);\n\n      if (ECMA_IS_VALUE_ERROR (is_array))\n      {\n        ecma_free_value (element);\n        return is_array;\n      }\n\n      if (ecma_is_value_true (is_array))\n      {\n        ecma_object_t *element_obj = ecma_get_object_from_value (element);\n        ecma_length_t element_len;\n        ecma_value_t len_value = ecma_op_object_get_length (element_obj, &element_len);\n\n        if (ECMA_IS_VALUE_ERROR (len_value))\n        {\n          ecma_deref_object (element_obj);\n          return len_value;\n        }\n\n        ecma_value_t target_index_val = ecma_builtin_array_flatten_into_array (target,\n                                                                               element_obj,\n                                                                               element_len,\n                                                                               target_index,\n                                                                               depth - 1,\n                                                                               ECMA_VALUE_UNDEFINED,\n                                                                               ECMA_VALUE_UNDEFINED);\n\n        ecma_deref_object (element_obj);\n\n        if (ECMA_IS_VALUE_ERROR (target_index_val))\n        {\n          return target_index_val;\n        }\n\n        target_index = (ecma_length_t) ecma_get_number_from_value (target_index_val);\n        continue;\n      }\n    }\n\n    /* vi. */\n    const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n    ecma_value_t element_temp =\n      ecma_builtin_helper_def_prop_by_index (ecma_get_object_from_value (target), target_index, element, flags);\n\n    ecma_free_value (element);\n\n    if (ECMA_IS_VALUE_ERROR (element_temp))\n    {\n      return element_temp;\n    }\n\n    target_index++;\n  }\n  /* 10. */\n  return ecma_make_length_value (target_index);\n}",
        "func": "static ecma_value_t\necma_builtin_array_flatten_into_array (ecma_value_t target, /**< target will contains source's elements  */\n                                       ecma_object_t *source, /**< source object */\n                                       ecma_length_t source_len, /**< source object length */\n                                       ecma_length_t start, /**< remaining recursion depth */\n                                       ecma_number_t depth, /**< start index offset */\n                                       ecma_value_t mapped_value, /**< mapped value  */\n                                       ecma_value_t thisArg) /**< this arg */\n{\n  ECMA_CHECK_STACK_USAGE ();\n\n  /* 7. */\n  ecma_length_t target_index = start;\n\n  /* 9. */\n  for (ecma_length_t source_index = 0; source_index < source_len; source_index++)\n  {\n    /* a. */\n    ecma_value_t element = ecma_op_object_find_by_index (source, source_index);\n\n    if (ECMA_IS_VALUE_ERROR (element))\n    {\n      return element;\n    }\n\n    if (!ecma_is_value_found (element))\n    {\n      continue;\n    }\n\n    /* b-c. */\n    if (!ecma_is_value_undefined (mapped_value))\n    {\n      /* i-ii. */\n      ecma_value_t source_val = ecma_make_length_value (source_index);\n      ecma_value_t args[] = { element, source_val, ecma_make_object_value (source) };\n      ecma_value_t temp_element = ecma_op_function_call (ecma_get_object_from_value (mapped_value), thisArg, args, 3);\n\n      ecma_free_value (element);\n      ecma_free_value (source_val);\n\n      if (ECMA_IS_VALUE_ERROR (temp_element))\n      {\n        return temp_element;\n      }\n\n      element = temp_element;\n    }\n\n    /* iv-v. */\n    if (depth > 0)\n    {\n      ecma_value_t is_array = ecma_is_value_array (element);\n\n      if (ECMA_IS_VALUE_ERROR (is_array))\n      {\n        ecma_free_value (element);\n        return is_array;\n      }\n\n      if (ecma_is_value_true (is_array))\n      {\n        ecma_object_t *element_obj = ecma_get_object_from_value (element);\n        ecma_length_t element_len;\n        ecma_value_t len_value = ecma_op_object_get_length (element_obj, &element_len);\n\n        if (ECMA_IS_VALUE_ERROR (len_value))\n        {\n          ecma_deref_object (element_obj);\n          return len_value;\n        }\n\n        ecma_value_t target_index_val = ecma_builtin_array_flatten_into_array (target,\n                                                                               element_obj,\n                                                                               element_len,\n                                                                               target_index,\n                                                                               depth - 1,\n                                                                               ECMA_VALUE_UNDEFINED,\n                                                                               ECMA_VALUE_UNDEFINED);\n\n        ecma_deref_object (element_obj);\n\n        if (ECMA_IS_VALUE_ERROR (target_index_val))\n        {\n          return target_index_val;\n        }\n\n        target_index = (ecma_length_t) ecma_get_number_from_value (target_index_val);\n        continue;\n      }\n    }\n\n    /* vi. */\n    const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;\n    ecma_value_t element_temp =\n      ecma_builtin_helper_def_prop_by_index (ecma_get_object_from_value (target), target_index, element, flags);\n\n    ecma_free_value (element);\n\n    if (ECMA_IS_VALUE_ERROR (element_temp))\n    {\n      return element_temp;\n    }\n\n    target_index++;\n  }\n  /* 10. */\n  return ecma_make_length_value (target_index);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,8 @@\n                                        ecma_value_t mapped_value, /**< mapped value  */\n                                        ecma_value_t thisArg) /**< this arg */\n {\n+  ECMA_CHECK_STACK_USAGE ();\n+\n   /* 7. */\n   ecma_length_t target_index = start;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  ECMA_CHECK_STACK_USAGE ();",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15212",
        "func_name": "tensorflow/ResizeOutputTensor",
        "description": "In TensorFlow Lite before versions 2.2.1 and 2.3.1, models using segment sum can trigger writes outside of bounds of heap allocated buffers by inserting negative elements in the segment ids tensor. Users having access to `segment_ids_data` can alter `output_index` and then write to outside of `output_data` buffer. This might result in a segmentation fault but it can also be used to further corrupt the memory and can be chained with other vulnerabilities to create more advanced exploits. The issue is patched in commit 204945b19e44b57906c9344c0d00120eeeae178a and is released in TensorFlow versions 2.2.1, or 2.3.1. A potential workaround would be to add a custom `Verifier` to the model loading code to ensure that the segment ids are all positive, although this only handles the case when the segment ids are stored statically in the model. A similar validation could be done if the segment ids are generated at runtime between inference steps. If the segment ids are generated as outputs of a tensor during inference steps, then there are no possible workaround and users are advised to upgrade to patched code.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/204945b19e44b57906c9344c0d00120eeeae178a",
        "commit_title": "[tflite] Validate segment ids for segment_sum.",
        "commit_text": " Segment identifiers in segment_sum should be in a 1-D tensor of same size as the first dimension of the input. The values of the tensor should be integers from {0, 1, 2, ... k-1}, where k is the first dimension of the input. The segment identifiers must not contain jumps and must be increasing.  See https://www.tensorflow.org/api_docs/python/tf/math#Segmentation as the source for these constraints.  PiperOrigin-RevId: 332510942",
        "func_before": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}",
        "func": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  // Segment ids should be of same cardinality as first input dimension and they\n  // should be increasing by at most 1, from 0 (e.g., [0, 0, 1, 2, 3] is valid)\n  const int segment_id_size = segment_ids->dims->data[0];\n  TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);\n  int previous_segment_id = -1;\n  for (int i = 0; i < segment_id_size; i++) {\n    const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];\n    if (i == 0) {\n      TF_LITE_ENSURE_EQ(context, current_segment_id, 0);\n    } else {\n      int delta = current_segment_id - previous_segment_id;\n      TF_LITE_ENSURE(context, delta == 0 || delta == 1);\n    }\n    previous_segment_id = current_segment_id;\n  }\n\n  const int max_index = previous_segment_id;\n\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,11 +2,24 @@\n                                 const TfLiteTensor* data,\n                                 const TfLiteTensor* segment_ids,\n                                 TfLiteTensor* output) {\n-  int max_index = -1;\n+  // Segment ids should be of same cardinality as first input dimension and they\n+  // should be increasing by at most 1, from 0 (e.g., [0, 0, 1, 2, 3] is valid)\n   const int segment_id_size = segment_ids->dims->data[0];\n-  if (segment_id_size > 0) {\n-    max_index = segment_ids->data.i32[segment_id_size - 1];\n+  TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);\n+  int previous_segment_id = -1;\n+  for (int i = 0; i < segment_id_size; i++) {\n+    const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];\n+    if (i == 0) {\n+      TF_LITE_ENSURE_EQ(context, current_segment_id, 0);\n+    } else {\n+      int delta = current_segment_id - previous_segment_id;\n+      TF_LITE_ENSURE(context, delta == 0 || delta == 1);\n+    }\n+    previous_segment_id = current_segment_id;\n   }\n+\n+  const int max_index = previous_segment_id;\n+\n   const int data_rank = NumDimensions(data);\n   TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n   output_shape->data[0] = max_index + 1;",
        "diff_line_info": {
            "deleted_lines": [
                "  int max_index = -1;",
                "  if (segment_id_size > 0) {",
                "    max_index = segment_ids->data.i32[segment_id_size - 1];"
            ],
            "added_lines": [
                "  // Segment ids should be of same cardinality as first input dimension and they",
                "  // should be increasing by at most 1, from 0 (e.g., [0, 0, 1, 2, 3] is valid)",
                "  TF_LITE_ENSURE_EQ(context, segment_id_size, data->dims->data[0]);",
                "  int previous_segment_id = -1;",
                "  for (int i = 0; i < segment_id_size; i++) {",
                "    const int current_segment_id = GetTensorData<int32_t>(segment_ids)[i];",
                "    if (i == 0) {",
                "      TF_LITE_ENSURE_EQ(context, current_segment_id, 0);",
                "    } else {",
                "      int delta = current_segment_id - previous_segment_id;",
                "      TF_LITE_ENSURE(context, delta == 0 || delta == 1);",
                "    }",
                "    previous_segment_id = current_segment_id;",
                "",
                "  const int max_index = previous_segment_id;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/dissect_fb_zero_tag",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/3ff940652962c099b73ae3233322b8697b0d10ab",
        "commit_title": "FBZERO: Make sure our offset advances.",
        "commit_text": " Make sure our offset advances so that we don't infinitely loop. Fixes #16887. ",
        "func_before": "static guint32\ndissect_fb_zero_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *fb_zero_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(fb_zero_tree, hf_fb_zero_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_fb_zero_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_letohl(tvb, offset);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_fb_zero_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_fb_zero_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VERS:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_vers, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_fb_zero_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_TIME:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_time, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_letohl(tvb, tag_offset_start + tag_offset));\n                tag_offset += 4;\n            break;\n            case TAG_ALPN:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_alpn, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_fb_zero_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n\n            default:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_fb_zero_tag_undecoded,\n                                 \"Dissector for FB Zero Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                tag_offset += tag_len;\n            break;\n        }\n\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset);\n            tag_offset = offset_end;\n        }\n\n        tag_number--;\n    }\n    return offset + total_tag_len;\n\n}",
        "func": "static guint32\ndissect_fb_zero_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *fb_zero_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(fb_zero_tree, hf_fb_zero_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_fb_zero_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_letohl(tvb, offset);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_fb_zero_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_fb_zero_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VERS:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_vers, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_fb_zero_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_TIME:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_time, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_letohl(tvb, tag_offset_start + tag_offset));\n                tag_offset += 4;\n            break;\n            case TAG_ALPN:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_alpn, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_fb_zero_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n\n            default:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_fb_zero_tag_undecoded,\n                                 \"Dissector for FB Zero Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                goto end;\n            break;\n        }\n\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset);\n            // XXX Return instead?\n            goto end;\n        }\n\n        tag_number--;\n    }\n\n    end:\n    if (offset + total_tag_len <= offset) {\n        expert_add_info_format(pinfo, fb_zero_tree, &ei_fb_zero_length_invalid,\n                         \"Invalid total tag length: %u\", total_tag_len);\n        return offset + tvb_reported_length_remaining(tvb, offset);\n    }\n    return offset + total_tag_len;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -104,18 +104,26 @@\n                                  \"Dissector for FB Zero Tag\"\n                                  \" %s (%s) code not implemented, Contact\"\n                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n-                tag_offset += tag_len;\n+                goto end;\n             break;\n         }\n \n         if(tag_offset != offset_end){\n             /* Wrong Tag len... */\n             proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset);\n-            tag_offset = offset_end;\n+            // XXX Return instead?\n+            goto end;\n         }\n \n         tag_number--;\n     }\n+\n+    end:\n+    if (offset + total_tag_len <= offset) {\n+        expert_add_info_format(pinfo, fb_zero_tree, &ei_fb_zero_length_invalid,\n+                         \"Invalid total tag length: %u\", total_tag_len);\n+        return offset + tvb_reported_length_remaining(tvb, offset);\n+    }\n     return offset + total_tag_len;\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "                tag_offset += tag_len;",
                "            tag_offset = offset_end;"
            ],
            "added_lines": [
                "                goto end;",
                "            // XXX Return instead?",
                "            goto end;",
                "",
                "    end:",
                "    if (offset + total_tag_len <= offset) {",
                "        expert_add_info_format(pinfo, fb_zero_tree, &ei_fb_zero_length_invalid,",
                "                         \"Invalid total tag length: %u\", total_tag_len);",
                "        return offset + tvb_reported_length_remaining(tvb, offset);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/proto_register_fb_zero",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/3ff940652962c099b73ae3233322b8697b0d10ab",
        "commit_title": "FBZERO: Make sure our offset advances.",
        "commit_text": " Make sure our offset advances so that we don't infinitely loop. Fixes #16887. ",
        "func_before": "void\nproto_register_fb_zero(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_fb_zero_puflags,\n            { \"Public Flags\", \"fb_zero.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_fb_zero_puflags_vrsn,\n            { \"Version\", \"fb_zero.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the FB Zero protocol\", HFILL }\n        },\n        { &hf_fb_zero_puflags_unknown,\n            { \"Unknown\", \"fb_zero.puflags.unknown\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_UNKN,\n              NULL, HFILL }\n        },\n\n        { &hf_fb_zero_version,\n            { \"Version\", \"fb_zero.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the ZB Zero (Always QTV)\", HFILL }\n        },\n        { &hf_fb_zero_length,\n            { \"Length\", \"fb_zero.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag,\n            { \"Tag\", \"fb_zero.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_number,\n            { \"Tag Number\", \"fb_zero.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tags,\n            { \"Tag/value\", \"fb_zero.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_type,\n            { \"Tag Type\", \"fb_zero.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_offset_end,\n            { \"Tag offset end\", \"fb_zero.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_length,\n            { \"Tag length\", \"fb_zero.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_value,\n            { \"Tag/value\", \"fb_zero.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_sni,\n            { \"Server Name Indication\", \"fb_zero.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_fb_zero_tag_vers,\n            { \"Version\", \"fb_zero.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of FB Zero supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_sno,\n            { \"Server nonce\", \"fb_zero.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_aead,\n            { \"Authenticated encryption algorithms\", \"fb_zero.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_fb_zero_tag_scid,\n            { \"Server Config ID\", \"fb_zero.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_fb_zero_tag_time,\n            { \"Time\", \"fb_zero.tag.time\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_alpn,\n            { \"ALPN\", \"fb_zero.tag.alpn\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Application-Layer Protocol Negotiation supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_pubs,\n            { \"Public value\", \"fb_zero.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_fb_zero_tag_kexs,\n            { \"Key exchange algorithms\", \"fb_zero.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_fb_zero_tag_nonc,\n            { \"Client nonce\", \"fb_zero.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_fb_zero_tag_unknown,\n            { \"Unknown tag\", \"fb_zero.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_padding,\n            { \"Padding\", \"fb_zero.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_payload,\n            { \"Payload\", \"fb_zero.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Fb Zero Payload..\", HFILL }\n        },\n        { &hf_fb_zero_unknown,\n            { \"Unknown\", \"fb_zero.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Unknown Data\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_fb_zero,\n        &ett_fb_zero_puflags,\n        &ett_fb_zero_prflags,\n        &ett_fb_zero_ft,\n        &ett_fb_zero_ftflags,\n        &ett_fb_zero_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_fb_zero_tag_undecoded, { \"fb_zero.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for FB Zero Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_fb_zero_tag_length, { \"fb_zero.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_fb_zero_tag_unknown, { \"fb_zero.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n    };\n\n    expert_module_t *expert_fb_zero;\n\n    proto_fb_zero = proto_register_protocol(\"(Facebook) Zero Protocol\", \"FBZERO\", \"fb_zero\");\n\n    fb_zero_handle = register_dissector(\"fb_zero\", dissect_fb_zero, proto_fb_zero);\n\n    proto_register_field_array(proto_fb_zero, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    expert_fb_zero = expert_register_protocol(proto_fb_zero);\n    expert_register_field_array(expert_fb_zero, ei, array_length(ei));\n}",
        "func": "void\nproto_register_fb_zero(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_fb_zero_puflags,\n            { \"Public Flags\", \"fb_zero.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_fb_zero_puflags_vrsn,\n            { \"Version\", \"fb_zero.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the FB Zero protocol\", HFILL }\n        },\n        { &hf_fb_zero_puflags_unknown,\n            { \"Unknown\", \"fb_zero.puflags.unknown\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_UNKN,\n              NULL, HFILL }\n        },\n\n        { &hf_fb_zero_version,\n            { \"Version\", \"fb_zero.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the ZB Zero (Always QTV)\", HFILL }\n        },\n        { &hf_fb_zero_length,\n            { \"Length\", \"fb_zero.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag,\n            { \"Tag\", \"fb_zero.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_number,\n            { \"Tag Number\", \"fb_zero.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tags,\n            { \"Tag/value\", \"fb_zero.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_type,\n            { \"Tag Type\", \"fb_zero.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_offset_end,\n            { \"Tag offset end\", \"fb_zero.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_length,\n            { \"Tag length\", \"fb_zero.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_value,\n            { \"Tag/value\", \"fb_zero.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_sni,\n            { \"Server Name Indication\", \"fb_zero.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_fb_zero_tag_vers,\n            { \"Version\", \"fb_zero.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of FB Zero supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_sno,\n            { \"Server nonce\", \"fb_zero.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_aead,\n            { \"Authenticated encryption algorithms\", \"fb_zero.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_fb_zero_tag_scid,\n            { \"Server Config ID\", \"fb_zero.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_fb_zero_tag_time,\n            { \"Time\", \"fb_zero.tag.time\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_alpn,\n            { \"ALPN\", \"fb_zero.tag.alpn\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Application-Layer Protocol Negotiation supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_pubs,\n            { \"Public value\", \"fb_zero.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_fb_zero_tag_kexs,\n            { \"Key exchange algorithms\", \"fb_zero.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_fb_zero_tag_nonc,\n            { \"Client nonce\", \"fb_zero.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_fb_zero_tag_unknown,\n            { \"Unknown tag\", \"fb_zero.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_padding,\n            { \"Padding\", \"fb_zero.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_payload,\n            { \"Payload\", \"fb_zero.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Fb Zero Payload..\", HFILL }\n        },\n        { &hf_fb_zero_unknown,\n            { \"Unknown\", \"fb_zero.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Unknown Data\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_fb_zero,\n        &ett_fb_zero_puflags,\n        &ett_fb_zero_prflags,\n        &ett_fb_zero_ft,\n        &ett_fb_zero_ftflags,\n        &ett_fb_zero_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_fb_zero_tag_undecoded, { \"fb_zero.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for FB Zero Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_fb_zero_tag_length, { \"fb_zero.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_fb_zero_tag_unknown, { \"fb_zero.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n        { &ei_fb_zero_length_invalid, { \"fb_zero.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},\n    };\n\n    expert_module_t *expert_fb_zero;\n\n    proto_fb_zero = proto_register_protocol(\"(Facebook) Zero Protocol\", \"FBZERO\", \"fb_zero\");\n\n    fb_zero_handle = register_dissector(\"fb_zero\", dissect_fb_zero, proto_fb_zero);\n\n    proto_register_field_array(proto_fb_zero, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    expert_fb_zero = expert_register_protocol(proto_fb_zero);\n    expert_register_field_array(expert_fb_zero, ei, array_length(ei));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -149,6 +149,7 @@\n         { &ei_fb_zero_tag_undecoded, { \"fb_zero.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for FB Zero Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n         { &ei_fb_zero_tag_length, { \"fb_zero.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n         { &ei_fb_zero_tag_unknown, { \"fb_zero.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n+        { &ei_fb_zero_length_invalid, { \"fb_zero.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},\n     };\n \n     expert_module_t *expert_fb_zero;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        { &ei_fb_zero_length_invalid, { \"fb_zero.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/proto_register_gquic",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b287e7165e8aa89cde6ae37e7c257c5d87d16b9b",
        "commit_title": "GQUIC: make sure our tag offset advances.",
        "commit_text": " Make sure gquic tag offset advances so that we don't infinitely loop. ",
        "func_before": "void\nproto_register_gquic(void)\n{\n    module_t *gquic_module;\n\n    static hf_register_info hf[] = {\n        /* Long/Short header for Q046 */\n        { &hf_gquic_header_form,\n          { \"Header Form\", \"gquic.header_form\",\n            FT_UINT8, BASE_DEC, VALS(gquic_short_long_header_vals), 0x80,\n            \"The most significant bit (0x80) of the first octet is set to 1 for long headers and 0 for short headers.\", HFILL }\n        },\n        { &hf_gquic_fixed_bit,\n          { \"Fixed Bit\", \"gquic.fixed_bit\",\n            FT_BOOLEAN, 8, NULL, 0x40,\n            \"Must be 1\", HFILL }\n        },\n        { &hf_gquic_long_packet_type,\n          { \"Packet Type\", \"gquic.long.packet_type\",\n            FT_UINT8, BASE_DEC, VALS(gquic_long_packet_type_vals), 0x30,\n            \"Long Header Packet Type\", HFILL }\n        },\n        { &hf_gquic_long_reserved,\n          { \"Reserved\", \"gquic.long.reserved\",\n            FT_UINT8, BASE_DEC, NULL, 0x0c,\n            \"Reserved bits\", HFILL }\n        },\n        { &hf_gquic_packet_number_length,\n          { \"Packet Number Length\", \"gquic.packet_number_length\",\n            FT_UINT8, BASE_DEC, VALS(gquic_packet_number_lengths), 0x03,\n            \"Packet Number field length\", HFILL }\n\t},\n        { &hf_gquic_dcil,\n          { \"Destination Connection ID Length\", \"gquic.dcil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0xF0,\n            NULL, HFILL }\n        },\n        { &hf_gquic_scil,\n          { \"Source Connection ID Length\", \"gquic.scil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0x0F,\n            NULL, HFILL }\n        },\n\n        /* Public header for < Q046 */\n        { &hf_gquic_puflags,\n            { \"Public Flags\", \"gquic.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_gquic_puflags_vrsn,\n            { \"Version\", \"gquic.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the (Google)QUIC protocol\", HFILL }\n        },\n        { &hf_gquic_puflags_rst,\n            { \"Reset\", \"gquic.puflags.reset\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_RST,\n              \"Signifies that this packet is a public reset packet\", HFILL }\n        },\n        { &hf_gquic_puflags_dnonce,\n            { \"Diversification nonce\", \"gquic.puflags.nonce\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_DNONCE,\n              \"Indicates the presence of a 32 byte diversification nonce\", HFILL }\n        },\n        { &hf_gquic_puflags_cid,\n            { \"CID Length\", \"gquic.puflags.cid\",\n              FT_BOOLEAN, 8, TFS(&puflags_cid_tfs), PUFLAGS_CID,\n              \"Indicates the full 8 byte Connection ID is present\", HFILL }\n        },\n        { &hf_gquic_puflags_cid_old,\n            { \"CID Length\", \"gquic.puflags.cid.old\",\n              FT_UINT8, BASE_HEX, VALS(puflags_cid_old_vals), PUFLAGS_CID_OLD,\n              \"Signifies the Length of CID\", HFILL }\n        },\n        { &hf_gquic_puflags_pkn,\n            { \"Packet Number Length\", \"gquic.puflags.pkn\",\n              FT_UINT8, BASE_HEX, VALS(puflags_pkn_vals), PUFLAGS_PKN,\n              \"Signifies the Length of packet number\", HFILL }\n        },\n        { &hf_gquic_puflags_mpth,\n            { \"Multipath\", \"gquic.puflags.mpth\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_MPTH,\n              \"Reserved for multipath use\", HFILL }\n        },\n        { &hf_gquic_puflags_rsv,\n            { \"Reserved\", \"gquic.puflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n        { &hf_gquic_cid,\n            { \"CID\", \"gquic.cid\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Connection ID 64 bit pseudo random number\", HFILL }\n        },\n        { &hf_gquic_version,\n            { \"Version\", \"gquic.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the (Google)QUIC\", HFILL }\n        },\n        { &hf_gquic_diversification_nonce,\n            { \"Diversification nonce\", \"gquic.diversification_nonce\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_packet_number,\n            { \"Packet Number\", \"gquic.packet_number\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"The lower 8, 16, 32, or 48 bits of the packet number\", HFILL }\n        },\n\n        { &hf_gquic_prflags,\n            { \"Private Flags\", \"gquic.prflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet Private flags\", HFILL }\n        },\n\n        { &hf_gquic_prflags_entropy,\n            { \"Entropy\", \"gquic.prflags.entropy\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_ENTROPY,\n              \"For data packets, signifies that this packet contains the 1 bit of entropy, for fec packets, contains the xor of the entropy of protected packets\", HFILL }\n        },\n        { &hf_gquic_prflags_fecg,\n            { \"FEC Group\", \"gquic.prflags.fecg\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FECG,\n              \"Indicates whether the fec byte is present.\", HFILL }\n        },\n        { &hf_gquic_prflags_fec,\n            { \"FEC\", \"gquic.prflags.fec\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FEC,\n              \"Signifies that this packet represents an FEC packet\", HFILL }\n        },\n        { &hf_gquic_prflags_rsv,\n            { \"Reserved\", \"gquic.prflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PRFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n\n        { &hf_gquic_message_authentication_hash,\n            { \"Message Authentication Hash\", \"gquic.message_authentication_hash\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"The hash is an FNV1a-128 hash, serialized in little endian order\", HFILL }\n        },\n        { &hf_gquic_frame,\n            { \"Frame\", \"gquic.frame\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type,\n            { \"Frame Type\", \"gquic.frame_type\",\n              FT_UINT8 ,BASE_RANGE_STRING | BASE_HEX, RVALS(frame_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding_length,\n            { \"Padding Length\", \"gquic.frame_type.padding.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding,\n            { \"Padding\", \"gquic.frame_type.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Must be zero\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.rsts.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Stream ID of the stream being terminated\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.rsts.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of the end of data for this stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_error_code,\n            { \"Error code\", \"gquic.frame_type.rsts.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &rststream_error_code_vals_ext, 0x0,\n              \"Indicates why the stream is being closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_error_code,\n            { \"Error code\", \"gquic.frame_type.cc.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.cc.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.cc.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_error_code,\n            { \"Error code\", \"gquic.frame_type.goaway.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_last_good_stream_id,\n            { \"Last Good Stream ID\", \"gquic.frame_type.goaway.last_good_stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"last Stream ID which was accepted by the sender of the GOAWAY message\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.goaway.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.goaway.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.wu.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"ID of the stream whose flow control windows is begin updated, or 0 to specify the connection-level flow control window\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.wu.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of data which can be sent on the given stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_blocked_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.blocked.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Indicating the stream which is flow control blocked\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_send_entropy,\n            { \"Send Entropy\", \"gquic.frame_type.sw.send_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all sent packets up to the packet with packet number one less than the least unacked packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_least_unacked_delta,\n            { \"Least unacked delta\", \"gquic.frame_type.sw.least_unacked_delta\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"A variable length packet number delta with the same length as the packet header's packet number\", HFILL }\n        },\n        { &hf_gquic_crypto_offset,\n            { \"Offset\", \"gquic.crypto.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Byte offset into the stream\", HFILL }\n        },\n        { &hf_gquic_crypto_length,\n            { \"Length\", \"gquic.crypto.length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Length of the Crypto Data field\", HFILL }\n        },\n        { &hf_gquic_crypto_crypto_data,\n            { \"Crypto Data\", \"gquic.crypto.crypto_data\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              \"The cryptographic message data\", HFILL }\n        },\n        { &hf_gquic_frame_type_stream,\n            { \"Stream\", \"gquic.frame_type.stream\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_f,\n            { \"FIN\", \"gquic.frame_type.stream.f\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM_F,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_d,\n            { \"Data Length\", \"gquic.frame_type.stream.d\",\n              FT_BOOLEAN, 8, TFS(&len_data_vals), FTFLAGS_STREAM_D,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ooo,\n            { \"Offset Length\", \"gquic.frame_type.stream.ooo\",\n              FT_UINT8, BASE_DEC, VALS(len_offset_vals), FTFLAGS_STREAM_OOO,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ss,\n            { \"Stream Length\", \"gquic.frame_type.stream.ss\",\n              FT_UINT8, BASE_DEC, VALS(len_stream_vals), FTFLAGS_STREAM_SS,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack,\n            { \"ACK\", \"gquic.frame_type.ack\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_n,\n            { \"NACK\", \"gquic.frame_type.ack.n\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_N,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_u,\n            { \"Unused\", \"gquic.frame_type.ack.u\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_U,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_t,\n            { \"Truncated\", \"gquic.frame_type.ack.t\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_T,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ll,\n            { \"Largest Observed Length\", \"gquic.frame_type.ack.ll\",\n              FT_UINT8, BASE_DEC, VALS(len_largest_observed_vals), FTFLAGS_ACK_LL,\n              \"Length of the Largest Observed field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_mm,\n            { \"Missing Packet Length\", \"gquic.frame_type.ack.mm\",\n              FT_UINT8, BASE_DEC, VALS(len_missing_packet_vals), FTFLAGS_ACK_MM,\n              \"Length of the Missing Packet Number Delta field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        /* ACK before Q034 */\n        { &hf_gquic_frame_type_ack_received_entropy,\n            { \"Received Entropy\", \"gquic.frame_type.ack.received_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all received packets up to the largest observed packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_observed,\n            { \"Largest Observed\", \"gquic.frame_type.ack.largest_observed\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_delay_time,\n            { \"Ack Delay time\", \"gquic.frame_type.ack.ack_delay_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest observed was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_timestamp,\n            { \"Num Timestamp\", \"gquic.frame_type.ack.num_timestamp\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of TCP timestamps that are included in this frame\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_observed,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_observed\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_timestamp,\n            { \"First Timestamp\", \"gquic.frame_type.ack.first_timestamp\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_previous_timestamp,\n            { \"Time since Previous timestamp\", \"gquic.frame_type.ack.time_since_previous_timestamp\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"This is the time delta from the previous timestamp\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_ranges,\n            { \"Num Ranges\", \"gquic.frame_type.ack.num_ranges\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of missing packet ranges between largest observed and least unacked\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_missing_packet,\n            { \"Missing Packet Packet Number Delta\", \"gquic.frame_type.ack.missing_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_range_length,\n            { \"Range Length\", \"gquic.frame_type.ack.range_length\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of sequential nacks in the range\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_revived,\n            { \"Num Revived\", \"gquic.frame_type.ack.num_revived\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of revived packets, recovered via FEC\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_revived_packet,\n            { \"Revived Packet Packet Number\", \"gquic.frame_type.ack.revived_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing a packet the peer has revived via FEC\", HFILL }\n        },\n        /* ACK after Q034 */\n        { &hf_gquic_frame_type_ack_largest_acked,\n            { \"Largest Acked\", \"gquic.frame_type.ack.largest_acked\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_acked_delta_time,\n            { \"Largest Acked Delta Time\", \"gquic.frame_type.ack.largest_acked_delta_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest acked was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_blocks,\n            { \"Num blocks\", \"gquic.frame_type.ack.num_blocks\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_ack_block_length,\n            { \"First Ack block length\", \"gquic.frame_type.ack.first_ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_gap_to_next_block,\n            { \"Gap to next block\", \"gquic.frame_type.ack.gap_to_next_block\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of packets between ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_block_length,\n            { \"Ack block length\", \"gquic.frame_type.ack.ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_acked,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_acked\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_largest_acked,\n            { \"Time Since Largest Acked\", \"gquic.frame_type.ack.time_since_largest_acked\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n\n\n\n        { &hf_gquic_stream_id,\n            { \"Stream ID\", \"gquic.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_offset,\n            { \"Offset\", \"gquic.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_data_len,\n            { \"Data Length\", \"gquic.data_len\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag,\n            { \"Tag\", \"gquic.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_number,\n            { \"Tag Number\", \"gquic.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tags,\n            { \"Tag/value\", \"gquic.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_type,\n            { \"Tag Type\", \"gquic.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_offset_end,\n            { \"Tag offset end\", \"gquic.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_length,\n            { \"Tag length\", \"gquic.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_value,\n            { \"Tag/value\", \"gquic.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sni,\n            { \"Server Name Indication\", \"gquic.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_gquic_tag_pad,\n            { \"Padding\", \"gquic.tag.pad\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Pad.....\", HFILL }\n        },\n        { &hf_gquic_tag_ver,\n            { \"Version\", \"gquic.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of gquic supported\", HFILL }\n        },\n        { &hf_gquic_tag_pdmd,\n            { \"Proof demand\", \"gquic.tag.pdmd\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"a list of tags describing the types of proof acceptable to the client, in preference order\", HFILL }\n        },\n        { &hf_gquic_tag_ccs,\n            { \"Common certificate sets\", \"gquic.tag.ccs\",\n              FT_UINT64, BASE_HEX, NULL, 0x0,\n              \"A series of 64-bit, FNV-1a hashes of sets of common certificates that the client possesses\", HFILL }\n        },\n        { &hf_gquic_tag_uaid,\n            { \"Client's User Agent ID\", \"gquic.tag.uaid\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_stk,\n            { \"Source-address token\", \"gquic.tag.stk\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sno,\n            { \"Server nonce\", \"gquic.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_prof,\n            { \"Proof (Signature)\", \"gquic.tag.prof\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg,\n            { \"Server Config Tag\", \"gquic.tag.scfg\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg_number,\n            { \"Number Server Config Tag\", \"gquic.tag.scfg.number\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rrej,\n            { \"Reasons for server sending\", \"gquic.tag.rrej\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &handshake_failure_reason_vals_ext, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_crt,\n            { \"Certificate chain\", \"gquic.tag.crt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_aead,\n            { \"Authenticated encryption algorithms\", \"gquic.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_gquic_tag_scid,\n            { \"Server Config ID\", \"gquic.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_gquic_tag_pubs,\n            { \"Public value\", \"gquic.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_gquic_tag_kexs,\n            { \"Key exchange algorithms\", \"gquic.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_gquic_tag_obit,\n            { \"Server orbit\", \"gquic.tag.obit\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_expy,\n            { \"Expiry\", \"gquic.tag.expy\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit expiry time for the server config in UNIX epoch seconds\", HFILL }\n        },\n        { &hf_gquic_tag_nonc,\n            { \"Client nonce\", \"gquic.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_gquic_tag_mspc,\n            { \"Max streams per connection\", \"gquic.tag.mspc\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tcid,\n            { \"Connection ID truncation\", \"gquic.tag.tcid\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_srbf,\n            { \"Socket receive buffer\", \"gquic.tag.srbf\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_icsl,\n            { \"Idle connection state\", \"gquic.tag.icsl\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scls,\n            { \"Silently close on timeout\", \"gquic.tag.scls\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_copt,\n            { \"Connection options\", \"gquic.tag.copt\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ccrt,\n            { \"Cached certificates\", \"gquic.tag.ccrt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_irtt,\n            { \"Estimated initial RTT\", \"gquic.tag.irtt\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"in us\", HFILL }\n        },\n        { &hf_gquic_tag_cfcw,\n            { \"Initial session/connection\", \"gquic.tag.cfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sfcw,\n            { \"Initial stream flow control\", \"gquic.tag.sfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cetv,\n            { \"Client encrypted tag-value\", \"gquic.tag.cetv\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_xlct,\n            { \"Expected leaf certificate\", \"gquic.tag.xlct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_nonp,\n            { \"Client Proof nonce\", \"gquic.tag.nonp\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_csct,\n            { \"Signed cert timestamp\", \"gquic.tag.csct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ctim,\n            { \"Client Timestamp\", \"gquic.tag.ctim\",\n              FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rnon,\n            { \"Public reset nonce proof\", \"gquic.tag.rnon\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rseq,\n            { \"Rejected Packet Number\", \"gquic.tag.rseq\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit packet number\", HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_type,\n            { \"Client IP Address Type\", \"gquic.tag.caddr.addr.type\",\n              FT_UINT16, BASE_DEC, VALS(cadr_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv4,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv4\",\n              FT_IPv4, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv6,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv6\",\n              FT_IPv6, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_port,\n            { \"Client Port (Source)\", \"gquic.tag.caddr.port\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mids,\n            { \"Max incoming dynamic streams\", \"gquic.tag.mids\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_fhol,\n            { \"Force Head Of Line blocking\", \"gquic.tag.fhol\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sttl,\n            { \"Server Config TTL\", \"gquic.tag.sttl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_smhl,\n            { \"Support Max Header List (size)\", \"gquic.tag.smhl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tbkp,\n            { \"Token Binding Key Params.\", \"gquic.tag.tbkp\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mad0,\n            { \"Max Ack Delay\", \"gquic.tag.mad0\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n\n        { &hf_gquic_tag_unknown,\n            { \"Unknown tag\", \"gquic.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_padding,\n            { \"Padding\", \"gquic.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_stream_data,\n            { \"Stream Data\", \"gquic.stream_data\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_payload,\n            { \"Payload\", \"gquic.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"(Google) QUIC Payload..\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_gquic,\n        &ett_gquic_puflags,\n        &ett_gquic_prflags,\n        &ett_gquic_ft,\n        &ett_gquic_ftflags,\n        &ett_gquic_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_gquic_tag_undecoded, { \"gquic.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for (Google)QUIC Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n        { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},\n        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}\n    };\n\n    expert_module_t *expert_gquic;\n\n    proto_gquic = proto_register_protocol(\"GQUIC (Google Quick UDP Internet Connections)\", \"GQUIC\", \"gquic\");\n\n    proto_register_field_array(proto_gquic, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    gquic_module = prefs_register_protocol(proto_gquic, NULL);\n\n    prefs_register_bool_preference(gquic_module, \"debug.quic\",\n                       \"Force decode of all (Google) QUIC Payload\",\n                       \"Help for debug...\",\n                       &g_gquic_debug);\n\n    expert_gquic = expert_register_protocol(proto_gquic);\n    expert_register_field_array(expert_gquic, ei, array_length(ei));\n\n    gquic_handle = register_dissector(\"gquic\", dissect_gquic, proto_gquic);\n}",
        "func": "void\nproto_register_gquic(void)\n{\n    module_t *gquic_module;\n\n    static hf_register_info hf[] = {\n        /* Long/Short header for Q046 */\n        { &hf_gquic_header_form,\n          { \"Header Form\", \"gquic.header_form\",\n            FT_UINT8, BASE_DEC, VALS(gquic_short_long_header_vals), 0x80,\n            \"The most significant bit (0x80) of the first octet is set to 1 for long headers and 0 for short headers.\", HFILL }\n        },\n        { &hf_gquic_fixed_bit,\n          { \"Fixed Bit\", \"gquic.fixed_bit\",\n            FT_BOOLEAN, 8, NULL, 0x40,\n            \"Must be 1\", HFILL }\n        },\n        { &hf_gquic_long_packet_type,\n          { \"Packet Type\", \"gquic.long.packet_type\",\n            FT_UINT8, BASE_DEC, VALS(gquic_long_packet_type_vals), 0x30,\n            \"Long Header Packet Type\", HFILL }\n        },\n        { &hf_gquic_long_reserved,\n          { \"Reserved\", \"gquic.long.reserved\",\n            FT_UINT8, BASE_DEC, NULL, 0x0c,\n            \"Reserved bits\", HFILL }\n        },\n        { &hf_gquic_packet_number_length,\n          { \"Packet Number Length\", \"gquic.packet_number_length\",\n            FT_UINT8, BASE_DEC, VALS(gquic_packet_number_lengths), 0x03,\n            \"Packet Number field length\", HFILL }\n\t},\n        { &hf_gquic_dcil,\n          { \"Destination Connection ID Length\", \"gquic.dcil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0xF0,\n            NULL, HFILL }\n        },\n        { &hf_gquic_scil,\n          { \"Source Connection ID Length\", \"gquic.scil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0x0F,\n            NULL, HFILL }\n        },\n\n        /* Public header for < Q046 */\n        { &hf_gquic_puflags,\n            { \"Public Flags\", \"gquic.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_gquic_puflags_vrsn,\n            { \"Version\", \"gquic.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the (Google)QUIC protocol\", HFILL }\n        },\n        { &hf_gquic_puflags_rst,\n            { \"Reset\", \"gquic.puflags.reset\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_RST,\n              \"Signifies that this packet is a public reset packet\", HFILL }\n        },\n        { &hf_gquic_puflags_dnonce,\n            { \"Diversification nonce\", \"gquic.puflags.nonce\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_DNONCE,\n              \"Indicates the presence of a 32 byte diversification nonce\", HFILL }\n        },\n        { &hf_gquic_puflags_cid,\n            { \"CID Length\", \"gquic.puflags.cid\",\n              FT_BOOLEAN, 8, TFS(&puflags_cid_tfs), PUFLAGS_CID,\n              \"Indicates the full 8 byte Connection ID is present\", HFILL }\n        },\n        { &hf_gquic_puflags_cid_old,\n            { \"CID Length\", \"gquic.puflags.cid.old\",\n              FT_UINT8, BASE_HEX, VALS(puflags_cid_old_vals), PUFLAGS_CID_OLD,\n              \"Signifies the Length of CID\", HFILL }\n        },\n        { &hf_gquic_puflags_pkn,\n            { \"Packet Number Length\", \"gquic.puflags.pkn\",\n              FT_UINT8, BASE_HEX, VALS(puflags_pkn_vals), PUFLAGS_PKN,\n              \"Signifies the Length of packet number\", HFILL }\n        },\n        { &hf_gquic_puflags_mpth,\n            { \"Multipath\", \"gquic.puflags.mpth\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_MPTH,\n              \"Reserved for multipath use\", HFILL }\n        },\n        { &hf_gquic_puflags_rsv,\n            { \"Reserved\", \"gquic.puflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n        { &hf_gquic_cid,\n            { \"CID\", \"gquic.cid\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Connection ID 64 bit pseudo random number\", HFILL }\n        },\n        { &hf_gquic_version,\n            { \"Version\", \"gquic.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the (Google)QUIC\", HFILL }\n        },\n        { &hf_gquic_diversification_nonce,\n            { \"Diversification nonce\", \"gquic.diversification_nonce\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_packet_number,\n            { \"Packet Number\", \"gquic.packet_number\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"The lower 8, 16, 32, or 48 bits of the packet number\", HFILL }\n        },\n\n        { &hf_gquic_prflags,\n            { \"Private Flags\", \"gquic.prflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet Private flags\", HFILL }\n        },\n\n        { &hf_gquic_prflags_entropy,\n            { \"Entropy\", \"gquic.prflags.entropy\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_ENTROPY,\n              \"For data packets, signifies that this packet contains the 1 bit of entropy, for fec packets, contains the xor of the entropy of protected packets\", HFILL }\n        },\n        { &hf_gquic_prflags_fecg,\n            { \"FEC Group\", \"gquic.prflags.fecg\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FECG,\n              \"Indicates whether the fec byte is present.\", HFILL }\n        },\n        { &hf_gquic_prflags_fec,\n            { \"FEC\", \"gquic.prflags.fec\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FEC,\n              \"Signifies that this packet represents an FEC packet\", HFILL }\n        },\n        { &hf_gquic_prflags_rsv,\n            { \"Reserved\", \"gquic.prflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PRFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n\n        { &hf_gquic_message_authentication_hash,\n            { \"Message Authentication Hash\", \"gquic.message_authentication_hash\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"The hash is an FNV1a-128 hash, serialized in little endian order\", HFILL }\n        },\n        { &hf_gquic_frame,\n            { \"Frame\", \"gquic.frame\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type,\n            { \"Frame Type\", \"gquic.frame_type\",\n              FT_UINT8 ,BASE_RANGE_STRING | BASE_HEX, RVALS(frame_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding_length,\n            { \"Padding Length\", \"gquic.frame_type.padding.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding,\n            { \"Padding\", \"gquic.frame_type.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Must be zero\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.rsts.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Stream ID of the stream being terminated\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.rsts.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of the end of data for this stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_error_code,\n            { \"Error code\", \"gquic.frame_type.rsts.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &rststream_error_code_vals_ext, 0x0,\n              \"Indicates why the stream is being closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_error_code,\n            { \"Error code\", \"gquic.frame_type.cc.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.cc.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.cc.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_error_code,\n            { \"Error code\", \"gquic.frame_type.goaway.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_last_good_stream_id,\n            { \"Last Good Stream ID\", \"gquic.frame_type.goaway.last_good_stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"last Stream ID which was accepted by the sender of the GOAWAY message\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.goaway.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.goaway.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.wu.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"ID of the stream whose flow control windows is begin updated, or 0 to specify the connection-level flow control window\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.wu.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of data which can be sent on the given stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_blocked_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.blocked.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Indicating the stream which is flow control blocked\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_send_entropy,\n            { \"Send Entropy\", \"gquic.frame_type.sw.send_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all sent packets up to the packet with packet number one less than the least unacked packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_least_unacked_delta,\n            { \"Least unacked delta\", \"gquic.frame_type.sw.least_unacked_delta\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"A variable length packet number delta with the same length as the packet header's packet number\", HFILL }\n        },\n        { &hf_gquic_crypto_offset,\n            { \"Offset\", \"gquic.crypto.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Byte offset into the stream\", HFILL }\n        },\n        { &hf_gquic_crypto_length,\n            { \"Length\", \"gquic.crypto.length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Length of the Crypto Data field\", HFILL }\n        },\n        { &hf_gquic_crypto_crypto_data,\n            { \"Crypto Data\", \"gquic.crypto.crypto_data\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              \"The cryptographic message data\", HFILL }\n        },\n        { &hf_gquic_frame_type_stream,\n            { \"Stream\", \"gquic.frame_type.stream\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_f,\n            { \"FIN\", \"gquic.frame_type.stream.f\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM_F,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_d,\n            { \"Data Length\", \"gquic.frame_type.stream.d\",\n              FT_BOOLEAN, 8, TFS(&len_data_vals), FTFLAGS_STREAM_D,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ooo,\n            { \"Offset Length\", \"gquic.frame_type.stream.ooo\",\n              FT_UINT8, BASE_DEC, VALS(len_offset_vals), FTFLAGS_STREAM_OOO,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ss,\n            { \"Stream Length\", \"gquic.frame_type.stream.ss\",\n              FT_UINT8, BASE_DEC, VALS(len_stream_vals), FTFLAGS_STREAM_SS,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack,\n            { \"ACK\", \"gquic.frame_type.ack\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_n,\n            { \"NACK\", \"gquic.frame_type.ack.n\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_N,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_u,\n            { \"Unused\", \"gquic.frame_type.ack.u\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_U,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_t,\n            { \"Truncated\", \"gquic.frame_type.ack.t\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_T,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ll,\n            { \"Largest Observed Length\", \"gquic.frame_type.ack.ll\",\n              FT_UINT8, BASE_DEC, VALS(len_largest_observed_vals), FTFLAGS_ACK_LL,\n              \"Length of the Largest Observed field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_mm,\n            { \"Missing Packet Length\", \"gquic.frame_type.ack.mm\",\n              FT_UINT8, BASE_DEC, VALS(len_missing_packet_vals), FTFLAGS_ACK_MM,\n              \"Length of the Missing Packet Number Delta field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        /* ACK before Q034 */\n        { &hf_gquic_frame_type_ack_received_entropy,\n            { \"Received Entropy\", \"gquic.frame_type.ack.received_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all received packets up to the largest observed packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_observed,\n            { \"Largest Observed\", \"gquic.frame_type.ack.largest_observed\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_delay_time,\n            { \"Ack Delay time\", \"gquic.frame_type.ack.ack_delay_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest observed was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_timestamp,\n            { \"Num Timestamp\", \"gquic.frame_type.ack.num_timestamp\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of TCP timestamps that are included in this frame\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_observed,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_observed\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_timestamp,\n            { \"First Timestamp\", \"gquic.frame_type.ack.first_timestamp\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_previous_timestamp,\n            { \"Time since Previous timestamp\", \"gquic.frame_type.ack.time_since_previous_timestamp\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"This is the time delta from the previous timestamp\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_ranges,\n            { \"Num Ranges\", \"gquic.frame_type.ack.num_ranges\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of missing packet ranges between largest observed and least unacked\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_missing_packet,\n            { \"Missing Packet Packet Number Delta\", \"gquic.frame_type.ack.missing_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_range_length,\n            { \"Range Length\", \"gquic.frame_type.ack.range_length\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of sequential nacks in the range\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_revived,\n            { \"Num Revived\", \"gquic.frame_type.ack.num_revived\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of revived packets, recovered via FEC\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_revived_packet,\n            { \"Revived Packet Packet Number\", \"gquic.frame_type.ack.revived_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing a packet the peer has revived via FEC\", HFILL }\n        },\n        /* ACK after Q034 */\n        { &hf_gquic_frame_type_ack_largest_acked,\n            { \"Largest Acked\", \"gquic.frame_type.ack.largest_acked\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_acked_delta_time,\n            { \"Largest Acked Delta Time\", \"gquic.frame_type.ack.largest_acked_delta_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest acked was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_blocks,\n            { \"Num blocks\", \"gquic.frame_type.ack.num_blocks\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_ack_block_length,\n            { \"First Ack block length\", \"gquic.frame_type.ack.first_ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_gap_to_next_block,\n            { \"Gap to next block\", \"gquic.frame_type.ack.gap_to_next_block\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of packets between ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_block_length,\n            { \"Ack block length\", \"gquic.frame_type.ack.ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_acked,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_acked\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_largest_acked,\n            { \"Time Since Largest Acked\", \"gquic.frame_type.ack.time_since_largest_acked\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n\n\n\n        { &hf_gquic_stream_id,\n            { \"Stream ID\", \"gquic.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_offset,\n            { \"Offset\", \"gquic.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_data_len,\n            { \"Data Length\", \"gquic.data_len\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag,\n            { \"Tag\", \"gquic.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_number,\n            { \"Tag Number\", \"gquic.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tags,\n            { \"Tag/value\", \"gquic.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_type,\n            { \"Tag Type\", \"gquic.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_offset_end,\n            { \"Tag offset end\", \"gquic.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_length,\n            { \"Tag length\", \"gquic.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_value,\n            { \"Tag/value\", \"gquic.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sni,\n            { \"Server Name Indication\", \"gquic.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_gquic_tag_pad,\n            { \"Padding\", \"gquic.tag.pad\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Pad.....\", HFILL }\n        },\n        { &hf_gquic_tag_ver,\n            { \"Version\", \"gquic.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of gquic supported\", HFILL }\n        },\n        { &hf_gquic_tag_pdmd,\n            { \"Proof demand\", \"gquic.tag.pdmd\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"a list of tags describing the types of proof acceptable to the client, in preference order\", HFILL }\n        },\n        { &hf_gquic_tag_ccs,\n            { \"Common certificate sets\", \"gquic.tag.ccs\",\n              FT_UINT64, BASE_HEX, NULL, 0x0,\n              \"A series of 64-bit, FNV-1a hashes of sets of common certificates that the client possesses\", HFILL }\n        },\n        { &hf_gquic_tag_uaid,\n            { \"Client's User Agent ID\", \"gquic.tag.uaid\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_stk,\n            { \"Source-address token\", \"gquic.tag.stk\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sno,\n            { \"Server nonce\", \"gquic.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_prof,\n            { \"Proof (Signature)\", \"gquic.tag.prof\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg,\n            { \"Server Config Tag\", \"gquic.tag.scfg\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg_number,\n            { \"Number Server Config Tag\", \"gquic.tag.scfg.number\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rrej,\n            { \"Reasons for server sending\", \"gquic.tag.rrej\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &handshake_failure_reason_vals_ext, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_crt,\n            { \"Certificate chain\", \"gquic.tag.crt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_aead,\n            { \"Authenticated encryption algorithms\", \"gquic.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_gquic_tag_scid,\n            { \"Server Config ID\", \"gquic.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_gquic_tag_pubs,\n            { \"Public value\", \"gquic.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_gquic_tag_kexs,\n            { \"Key exchange algorithms\", \"gquic.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_gquic_tag_obit,\n            { \"Server orbit\", \"gquic.tag.obit\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_expy,\n            { \"Expiry\", \"gquic.tag.expy\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit expiry time for the server config in UNIX epoch seconds\", HFILL }\n        },\n        { &hf_gquic_tag_nonc,\n            { \"Client nonce\", \"gquic.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_gquic_tag_mspc,\n            { \"Max streams per connection\", \"gquic.tag.mspc\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tcid,\n            { \"Connection ID truncation\", \"gquic.tag.tcid\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_srbf,\n            { \"Socket receive buffer\", \"gquic.tag.srbf\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_icsl,\n            { \"Idle connection state\", \"gquic.tag.icsl\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scls,\n            { \"Silently close on timeout\", \"gquic.tag.scls\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_copt,\n            { \"Connection options\", \"gquic.tag.copt\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ccrt,\n            { \"Cached certificates\", \"gquic.tag.ccrt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_irtt,\n            { \"Estimated initial RTT\", \"gquic.tag.irtt\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"in us\", HFILL }\n        },\n        { &hf_gquic_tag_cfcw,\n            { \"Initial session/connection\", \"gquic.tag.cfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sfcw,\n            { \"Initial stream flow control\", \"gquic.tag.sfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cetv,\n            { \"Client encrypted tag-value\", \"gquic.tag.cetv\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_xlct,\n            { \"Expected leaf certificate\", \"gquic.tag.xlct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_nonp,\n            { \"Client Proof nonce\", \"gquic.tag.nonp\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_csct,\n            { \"Signed cert timestamp\", \"gquic.tag.csct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ctim,\n            { \"Client Timestamp\", \"gquic.tag.ctim\",\n              FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rnon,\n            { \"Public reset nonce proof\", \"gquic.tag.rnon\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rseq,\n            { \"Rejected Packet Number\", \"gquic.tag.rseq\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit packet number\", HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_type,\n            { \"Client IP Address Type\", \"gquic.tag.caddr.addr.type\",\n              FT_UINT16, BASE_DEC, VALS(cadr_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv4,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv4\",\n              FT_IPv4, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv6,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv6\",\n              FT_IPv6, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_port,\n            { \"Client Port (Source)\", \"gquic.tag.caddr.port\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mids,\n            { \"Max incoming dynamic streams\", \"gquic.tag.mids\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_fhol,\n            { \"Force Head Of Line blocking\", \"gquic.tag.fhol\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sttl,\n            { \"Server Config TTL\", \"gquic.tag.sttl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_smhl,\n            { \"Support Max Header List (size)\", \"gquic.tag.smhl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tbkp,\n            { \"Token Binding Key Params.\", \"gquic.tag.tbkp\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mad0,\n            { \"Max Ack Delay\", \"gquic.tag.mad0\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n\n        { &hf_gquic_tag_unknown,\n            { \"Unknown tag\", \"gquic.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_padding,\n            { \"Padding\", \"gquic.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_stream_data,\n            { \"Stream Data\", \"gquic.stream_data\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_payload,\n            { \"Payload\", \"gquic.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"(Google) QUIC Payload..\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_gquic,\n        &ett_gquic_puflags,\n        &ett_gquic_prflags,\n        &ett_gquic_ft,\n        &ett_gquic_ftflags,\n        &ett_gquic_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_gquic_tag_undecoded, { \"gquic.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for (Google)QUIC Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n        { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},\n        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},\n        { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}\n    };\n\n    expert_module_t *expert_gquic;\n\n    proto_gquic = proto_register_protocol(\"GQUIC (Google Quick UDP Internet Connections)\", \"GQUIC\", \"gquic\");\n\n    proto_register_field_array(proto_gquic, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    gquic_module = prefs_register_protocol(proto_gquic, NULL);\n\n    prefs_register_bool_preference(gquic_module, \"debug.quic\",\n                       \"Force decode of all (Google) QUIC Payload\",\n                       \"Help for debug...\",\n                       &g_gquic_debug);\n\n    expert_gquic = expert_register_protocol(proto_gquic);\n    expert_register_field_array(expert_gquic, ei, array_length(ei));\n\n    gquic_handle = register_dissector(\"gquic\", dissect_gquic, proto_gquic);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -738,7 +738,8 @@\n         { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n         { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n         { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},\n-        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}\n+        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},\n+        { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}\n     };\n \n     expert_module_t *expert_gquic;",
        "diff_line_info": {
            "deleted_lines": [
                "        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}"
            ],
            "added_lines": [
                "        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},",
                "        { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/dissect_gquic_tag",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b287e7165e8aa89cde6ae37e7c257c5d87d16b9b",
        "commit_title": "GQUIC: make sure our tag offset advances.",
        "commit_text": " Make sure gquic tag offset advances so that we don't infinitely loop. ",
        "func_before": "static guint32\ndissect_gquic_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *gquic_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(gquic_tree, hf_gquic_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_gquic_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_gquic_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_gquic_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_PAD:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pad, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VER:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_ver, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_CCS:\n                while(offset_end - tag_offset >= 8){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_ccs, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                    tag_offset += 8;\n                }\n            break;\n            case TAG_PDMD:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_pdmd, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_UAID:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_uaid, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_STK:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_stk, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PROF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_prof, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SCFG:{\n                guint32 scfg_tag_number;\n\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                tag_offset += 4;\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg_number, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                scfg_tag_number = tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n\n                dissect_gquic_tag(tvb, pinfo, tag_tree, tag_offset_start + tag_offset, scfg_tag_number);\n                tag_offset += tag_len - 4 - 4;\n                }\n            break;\n            case TAG_RREJ:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_rrej, tvb, tag_offset_start + tag_offset, 4,  ENC_LITTLE_ENDIAN);\n                    proto_item_append_text(ti_tag, \", Code %s\", val_to_str_ext(tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN), &handshake_failure_reason_vals_ext, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_crt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_gquic_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_gquic_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_OBIT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_obit, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_EXPY:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_expy, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_MSPC:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mspc, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_tcid, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SRBF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_srbf, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_ICSL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_icsl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SCLS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scls, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_COPT:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_copt, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CCRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ccrt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_IRTT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_irtt, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_SFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CETV:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cetv, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_XLCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_xlct, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                tag_offset += 8;\n            break;\n            case TAG_NONP:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonp, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_CSCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_csct, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_CTIM:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ctim, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN|ENC_TIME_SECS_NSECS);\n                tag_offset += 8;\n            break;\n            case TAG_RNON: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rnon, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_RSEQ: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rseq, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_CADR: /* Public Reset Tag */{\n                guint32 addr_type;\n                proto_tree_add_item_ret_uint(tag_tree, hf_gquic_tag_cadr_addr_type, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN, &addr_type);\n                tag_offset += 2;\n                switch(addr_type){\n                    case 2: /* IPv4 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv4, tvb, tag_offset_start + tag_offset, 4, ENC_NA);\n                    tag_offset += 4;\n                    break;\n                    case 10: /* IPv6 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv6, tvb, tag_offset_start + tag_offset, 16, ENC_NA);\n                    tag_offset += 16;\n                    break;\n                    default: /* Unknown */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr, tvb, tag_offset_start + tag_offset, tag_len - 2 - 2, ENC_NA);\n                    tag_offset += tag_len + 2 + 2 ;\n                    break;\n                }\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_port, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n            }\n            break;\n            case TAG_MIDS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mids, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_FHOL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_fhol, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_STTL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sttl, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_SMHL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_smhl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TBKP:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_tbkp, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_MAD0:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mad0, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            default:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_gquic_tag_undecoded,\n                                 \"Dissector for (Google) QUIC Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                tag_offset += tag_len;\n            break;\n        }\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len);\n            tag_offset = offset_end;\n        }\n\n        tag_number--;\n    }\n    return offset + total_tag_len;\n\n}",
        "func": "static guint32\ndissect_gquic_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *gquic_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(gquic_tree, hf_gquic_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_gquic_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_gquic_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_gquic_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_PAD:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pad, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VER:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_ver, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_CCS:\n                while(offset_end - tag_offset >= 8){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_ccs, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                    tag_offset += 8;\n                }\n            break;\n            case TAG_PDMD:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_pdmd, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_UAID:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_uaid, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_STK:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_stk, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PROF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_prof, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SCFG:{\n                guint32 scfg_tag_number;\n\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                tag_offset += 4;\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg_number, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                scfg_tag_number = tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n\n                dissect_gquic_tag(tvb, pinfo, tag_tree, tag_offset_start + tag_offset, scfg_tag_number);\n                tag_offset += tag_len - 4 - 4;\n                }\n            break;\n            case TAG_RREJ:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_rrej, tvb, tag_offset_start + tag_offset, 4,  ENC_LITTLE_ENDIAN);\n                    proto_item_append_text(ti_tag, \", Code %s\", val_to_str_ext(tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN), &handshake_failure_reason_vals_ext, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_crt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_gquic_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_gquic_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_OBIT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_obit, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_EXPY:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_expy, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_MSPC:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mspc, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_tcid, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SRBF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_srbf, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_ICSL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_icsl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SCLS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scls, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_COPT:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_copt, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CCRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ccrt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_IRTT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_irtt, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_SFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CETV:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cetv, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_XLCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_xlct, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                tag_offset += 8;\n            break;\n            case TAG_NONP:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonp, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_CSCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_csct, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_CTIM:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ctim, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN|ENC_TIME_SECS_NSECS);\n                tag_offset += 8;\n            break;\n            case TAG_RNON: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rnon, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_RSEQ: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rseq, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_CADR: /* Public Reset Tag */{\n                guint32 addr_type;\n                proto_tree_add_item_ret_uint(tag_tree, hf_gquic_tag_cadr_addr_type, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN, &addr_type);\n                tag_offset += 2;\n                switch(addr_type){\n                    case 2: /* IPv4 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv4, tvb, tag_offset_start + tag_offset, 4, ENC_NA);\n                    tag_offset += 4;\n                    break;\n                    case 10: /* IPv6 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv6, tvb, tag_offset_start + tag_offset, 16, ENC_NA);\n                    tag_offset += 16;\n                    break;\n                    default: /* Unknown */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr, tvb, tag_offset_start + tag_offset, tag_len - 2 - 2, ENC_NA);\n                    tag_offset += tag_len + 2 + 2 ;\n                    break;\n                }\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_port, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n            }\n            break;\n            case TAG_MIDS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mids, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_FHOL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_fhol, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_STTL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sttl, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_SMHL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_smhl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TBKP:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_tbkp, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_MAD0:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mad0, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            default:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_gquic_tag_undecoded,\n                                 \"Dissector for (Google) QUIC Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                goto end;\n            break;\n        }\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len);\n            tag_offset = offset_end;\n        }\n\n        tag_number--;\n    }\n\n    end:\n    if (offset + total_tag_len <= offset) {\n        expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,\n                                \"Invalid total tag length: %u\", total_tag_len);\n        return offset + tvb_reported_length_remaining(tvb, offset);\n    }\n    return offset + total_tag_len;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -278,7 +278,7 @@\n                                  \"Dissector for (Google) QUIC Tag\"\n                                  \" %s (%s) code not implemented, Contact\"\n                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n-                tag_offset += tag_len;\n+                goto end;\n             break;\n         }\n         if(tag_offset != offset_end){\n@@ -289,6 +289,13 @@\n \n         tag_number--;\n     }\n+\n+    end:\n+    if (offset + total_tag_len <= offset) {\n+        expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,\n+                                \"Invalid total tag length: %u\", total_tag_len);\n+        return offset + tvb_reported_length_remaining(tvb, offset);\n+    }\n     return offset + total_tag_len;\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "                tag_offset += tag_len;"
            ],
            "added_lines": [
                "                goto end;",
                "",
                "    end:",
                "    if (offset + total_tag_len <= offset) {",
                "        expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,",
                "                                \"Invalid total tag length: %u\", total_tag_len);",
                "        return offset + tvb_reported_length_remaining(tvb, offset);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-8037",
        "func_name": "the-tcpdump-group/tcpdump/ppp_hdlc",
        "description": "The ppp decapsulator in tcpdump 4.9.3 can be convinced to allocate a large amount of memory.",
        "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/32027e199368dad9508965aae8cd8de5b6ab5231",
        "commit_title": "PPP: When un-escaping, don't allocate a too-large buffer.",
        "commit_text": " The buffer should be big enough to hold the captured data, but it doesn't need to be big enough to hold the entire on-the-network packet, if we haven't captured all of it.  (backported from commit e4add0b010ed6f2180dcb05a13026242ed935334)",
        "func_before": "static void\nppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tint i, proto;\n\tconst void *se;\n\n        if (length <= 0)\n                return;\n\n\tb = (u_char *)malloc(length);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1 || !ND_TTEST(*s))\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}",
        "func": "static void\nppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_int caplen = ndo->ndo_snapend - p;\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i;\n\tint proto;\n\tconst void *se;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length <= 0)\n                return;\n\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,15 +2,20 @@\n ppp_hdlc(netdissect_options *ndo,\n          const u_char *p, int length)\n {\n+\tu_int caplen = ndo->ndo_snapend - p;\n \tu_char *b, *t, c;\n \tconst u_char *s;\n-\tint i, proto;\n+\tu_int i;\n+\tint proto;\n \tconst void *se;\n+\n+\tif (caplen == 0)\n+\t\treturn;\n \n         if (length <= 0)\n                 return;\n \n-\tb = (u_char *)malloc(length);\n+\tb = (u_char *)malloc(caplen);\n \tif (b == NULL)\n \t\treturn;\n \n@@ -19,10 +24,10 @@\n \t * Do this so that we dont overwrite the original packet\n \t * contents.\n \t */\n-\tfor (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {\n+\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n \t\tc = *s++;\n \t\tif (c == 0x7d) {\n-\t\t\tif (i <= 1 || !ND_TTEST(*s))\n+\t\t\tif (i <= 1)\n \t\t\t\tbreak;\n \t\t\ti--;\n \t\t\tc = *s++ ^ 0x20;",
        "diff_line_info": {
            "deleted_lines": [
                "\tint i, proto;",
                "\tb = (u_char *)malloc(length);",
                "\tfor (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {",
                "\t\t\tif (i <= 1 || !ND_TTEST(*s))"
            ],
            "added_lines": [
                "\tu_int caplen = ndo->ndo_snapend - p;",
                "\tu_int i;",
                "\tint proto;",
                "",
                "\tif (caplen == 0)",
                "\t\treturn;",
                "\tb = (u_char *)malloc(caplen);",
                "\tfor (s = p, t = b, i = caplen; i != 0; i--) {",
                "\t\t\tif (i <= 1)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-26931",
        "func_name": "torvalds/linux/xen_blkbk_map",
        "description": "An issue was discovered in the Linux kernel 2.6.39 through 5.10.16, as used in Xen. Block, net, and SCSI backends consider certain errors a plain bug, deliberately causing a kernel crash. For errors potentially being at least under the influence of guests (such as out of memory conditions), it isn't correct to assume a plain bug. Memory allocations potentially causing such crashes occur only when Linux is running in PV mode, though. This affects drivers/block/xen-blkback/blkback.c and drivers/xen/xen-scsiback.c.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=5a264285ed1cd32e26d9de4f3c8c6855e467fd63",
        "commit_title": "In particular -ENOMEM may come back here, from set_foreign_p2m_mapping().",
        "commit_text": "Don't make problems worse, the more that handling elsewhere (together with map's status fields now indicating whether a mapping wasn't even attempted, and hence has to be considered failed) doesn't require this odd way of dealing with errors.  This is part of XSA-362.  Cc: stable@vger.kernel.org ",
        "func_before": "static int xen_blkbk_map(struct xen_blkif_ring *ring,\n\t\t\t struct grant_page *pages[],\n\t\t\t int num, bool ro)\n{\n\tstruct gnttab_map_grant_ref map[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages_to_gnt[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt = NULL;\n\tphys_addr_t addr = 0;\n\tint i, seg_idx, new_map_idx;\n\tint segs_to_map = 0;\n\tint ret = 0;\n\tint last_map = 0, map_until = 0;\n\tint use_persistent_gnts;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tuse_persistent_gnts = (blkif->vbd.feature_gnt_persistent);\n\n\t/*\n\t * Fill out preq.nr_sects with proper amount of sectors, and setup\n\t * assign map[..] with the PFN of the page in our domain with the\n\t * corresponding grant reference for each page.\n\t */\nagain:\n\tfor (i = map_until; i < num; i++) {\n\t\tuint32_t flags;\n\n\t\tif (use_persistent_gnts) {\n\t\t\tpersistent_gnt = get_persistent_gnt(\n\t\t\t\tring,\n\t\t\t\tpages[i]->gref);\n\t\t}\n\n\t\tif (persistent_gnt) {\n\t\t\t/*\n\t\t\t * We are using persistent grants and\n\t\t\t * the grant is already mapped\n\t\t\t */\n\t\t\tpages[i]->page = persistent_gnt->page;\n\t\t\tpages[i]->persistent_gnt = persistent_gnt;\n\t\t} else {\n\t\t\tif (gnttab_page_cache_get(&ring->free_pages,\n\t\t\t\t\t\t  &pages[i]->page))\n\t\t\t\tgoto out_of_memory;\n\t\t\taddr = vaddr(pages[i]->page);\n\t\t\tpages_to_gnt[segs_to_map] = pages[i]->page;\n\t\t\tpages[i]->persistent_gnt = NULL;\n\t\t\tflags = GNTMAP_host_map;\n\t\t\tif (!use_persistent_gnts && ro)\n\t\t\t\tflags |= GNTMAP_readonly;\n\t\t\tgnttab_set_map_op(&map[segs_to_map++], addr,\n\t\t\t\t\t  flags, pages[i]->gref,\n\t\t\t\t\t  blkif->domid);\n\t\t}\n\t\tmap_until = i + 1;\n\t\tif (segs_to_map == BLKIF_MAX_SEGMENTS_PER_REQUEST)\n\t\t\tbreak;\n\t}\n\n\tif (segs_to_map) {\n\t\tret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);\n\t\tBUG_ON(ret);\n\t}\n\n\t/*\n\t * Now swizzle the MFN in our domain with the MFN from the other domain\n\t * so that when we access vaddr(pending_req,i) it has the contents of\n\t * the page from the other domain.\n\t */\n\tfor (seg_idx = last_map, new_map_idx = 0; seg_idx < map_until; seg_idx++) {\n\t\tif (!pages[seg_idx]->persistent_gnt) {\n\t\t\t/* This is a newly mapped grant */\n\t\t\tBUG_ON(new_map_idx >= segs_to_map);\n\t\t\tif (unlikely(map[new_map_idx].status != 0)) {\n\t\t\t\tpr_debug(\"invalid buffer -- could not remap it\\n\");\n\t\t\t\tgnttab_page_cache_put(&ring->free_pages,\n\t\t\t\t\t\t      &pages[seg_idx]->page, 1);\n\t\t\t\tpages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;\n\t\t\t\tret |= 1;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->handle = map[new_map_idx].handle;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (use_persistent_gnts &&\n\t\t    ring->persistent_gnt_c < max_pgrants) {\n\t\t\t/*\n\t\t\t * We are using persistent grants, the grant is\n\t\t\t * not mapped but we might have room for it.\n\t\t\t */\n\t\t\tpersistent_gnt = kmalloc(sizeof(struct persistent_gnt),\n\t\t\t\t                 GFP_KERNEL);\n\t\t\tif (!persistent_gnt) {\n\t\t\t\t/*\n\t\t\t\t * If we don't have enough memory to\n\t\t\t\t * allocate the persistent_gnt struct\n\t\t\t\t * map this grant non-persistenly\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpersistent_gnt->gnt = map[new_map_idx].ref;\n\t\t\tpersistent_gnt->handle = map[new_map_idx].handle;\n\t\t\tpersistent_gnt->page = pages[seg_idx]->page;\n\t\t\tif (add_persistent_gnt(ring,\n\t\t\t                       persistent_gnt)) {\n\t\t\t\tkfree(persistent_gnt);\n\t\t\t\tpersistent_gnt = NULL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->persistent_gnt = persistent_gnt;\n\t\t\tpr_debug(\"grant %u added to the tree of persistent grants, using %u/%u\\n\",\n\t\t\t\t persistent_gnt->gnt, ring->persistent_gnt_c,\n\t\t\t\t max_pgrants);\n\t\t\tgoto next;\n\t\t}\n\t\tif (use_persistent_gnts && !blkif->vbd.overflow_max_grants) {\n\t\t\tblkif->vbd.overflow_max_grants = 1;\n\t\t\tpr_debug(\"domain %u, device %#x is using maximum number of persistent grants\\n\",\n\t\t\t         blkif->domid, blkif->vbd.handle);\n\t\t}\n\t\t/*\n\t\t * We could not map this grant persistently, so use it as\n\t\t * a non-persistent grant.\n\t\t */\nnext:\n\t\tnew_map_idx++;\n\t}\n\tsegs_to_map = 0;\n\tlast_map = map_until;\n\tif (map_until != num)\n\t\tgoto again;\n\n\treturn ret;\n\nout_of_memory:\n\tpr_alert(\"%s: out of memory\\n\", __func__);\n\tgnttab_page_cache_put(&ring->free_pages, pages_to_gnt, segs_to_map);\n\tfor (i = last_map; i < num; i++)\n\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;\n\treturn -ENOMEM;\n}",
        "func": "static int xen_blkbk_map(struct xen_blkif_ring *ring,\n\t\t\t struct grant_page *pages[],\n\t\t\t int num, bool ro)\n{\n\tstruct gnttab_map_grant_ref map[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct page *pages_to_gnt[BLKIF_MAX_SEGMENTS_PER_REQUEST];\n\tstruct persistent_gnt *persistent_gnt = NULL;\n\tphys_addr_t addr = 0;\n\tint i, seg_idx, new_map_idx;\n\tint segs_to_map = 0;\n\tint ret = 0;\n\tint last_map = 0, map_until = 0;\n\tint use_persistent_gnts;\n\tstruct xen_blkif *blkif = ring->blkif;\n\n\tuse_persistent_gnts = (blkif->vbd.feature_gnt_persistent);\n\n\t/*\n\t * Fill out preq.nr_sects with proper amount of sectors, and setup\n\t * assign map[..] with the PFN of the page in our domain with the\n\t * corresponding grant reference for each page.\n\t */\nagain:\n\tfor (i = map_until; i < num; i++) {\n\t\tuint32_t flags;\n\n\t\tif (use_persistent_gnts) {\n\t\t\tpersistent_gnt = get_persistent_gnt(\n\t\t\t\tring,\n\t\t\t\tpages[i]->gref);\n\t\t}\n\n\t\tif (persistent_gnt) {\n\t\t\t/*\n\t\t\t * We are using persistent grants and\n\t\t\t * the grant is already mapped\n\t\t\t */\n\t\t\tpages[i]->page = persistent_gnt->page;\n\t\t\tpages[i]->persistent_gnt = persistent_gnt;\n\t\t} else {\n\t\t\tif (gnttab_page_cache_get(&ring->free_pages,\n\t\t\t\t\t\t  &pages[i]->page))\n\t\t\t\tgoto out_of_memory;\n\t\t\taddr = vaddr(pages[i]->page);\n\t\t\tpages_to_gnt[segs_to_map] = pages[i]->page;\n\t\t\tpages[i]->persistent_gnt = NULL;\n\t\t\tflags = GNTMAP_host_map;\n\t\t\tif (!use_persistent_gnts && ro)\n\t\t\t\tflags |= GNTMAP_readonly;\n\t\t\tgnttab_set_map_op(&map[segs_to_map++], addr,\n\t\t\t\t\t  flags, pages[i]->gref,\n\t\t\t\t\t  blkif->domid);\n\t\t}\n\t\tmap_until = i + 1;\n\t\tif (segs_to_map == BLKIF_MAX_SEGMENTS_PER_REQUEST)\n\t\t\tbreak;\n\t}\n\n\tif (segs_to_map)\n\t\tret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);\n\n\t/*\n\t * Now swizzle the MFN in our domain with the MFN from the other domain\n\t * so that when we access vaddr(pending_req,i) it has the contents of\n\t * the page from the other domain.\n\t */\n\tfor (seg_idx = last_map, new_map_idx = 0; seg_idx < map_until; seg_idx++) {\n\t\tif (!pages[seg_idx]->persistent_gnt) {\n\t\t\t/* This is a newly mapped grant */\n\t\t\tBUG_ON(new_map_idx >= segs_to_map);\n\t\t\tif (unlikely(map[new_map_idx].status != 0)) {\n\t\t\t\tpr_debug(\"invalid buffer -- could not remap it\\n\");\n\t\t\t\tgnttab_page_cache_put(&ring->free_pages,\n\t\t\t\t\t\t      &pages[seg_idx]->page, 1);\n\t\t\t\tpages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;\n\t\t\t\tret |= !ret;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->handle = map[new_map_idx].handle;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (use_persistent_gnts &&\n\t\t    ring->persistent_gnt_c < max_pgrants) {\n\t\t\t/*\n\t\t\t * We are using persistent grants, the grant is\n\t\t\t * not mapped but we might have room for it.\n\t\t\t */\n\t\t\tpersistent_gnt = kmalloc(sizeof(struct persistent_gnt),\n\t\t\t\t                 GFP_KERNEL);\n\t\t\tif (!persistent_gnt) {\n\t\t\t\t/*\n\t\t\t\t * If we don't have enough memory to\n\t\t\t\t * allocate the persistent_gnt struct\n\t\t\t\t * map this grant non-persistenly\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpersistent_gnt->gnt = map[new_map_idx].ref;\n\t\t\tpersistent_gnt->handle = map[new_map_idx].handle;\n\t\t\tpersistent_gnt->page = pages[seg_idx]->page;\n\t\t\tif (add_persistent_gnt(ring,\n\t\t\t                       persistent_gnt)) {\n\t\t\t\tkfree(persistent_gnt);\n\t\t\t\tpersistent_gnt = NULL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tpages[seg_idx]->persistent_gnt = persistent_gnt;\n\t\t\tpr_debug(\"grant %u added to the tree of persistent grants, using %u/%u\\n\",\n\t\t\t\t persistent_gnt->gnt, ring->persistent_gnt_c,\n\t\t\t\t max_pgrants);\n\t\t\tgoto next;\n\t\t}\n\t\tif (use_persistent_gnts && !blkif->vbd.overflow_max_grants) {\n\t\t\tblkif->vbd.overflow_max_grants = 1;\n\t\t\tpr_debug(\"domain %u, device %#x is using maximum number of persistent grants\\n\",\n\t\t\t         blkif->domid, blkif->vbd.handle);\n\t\t}\n\t\t/*\n\t\t * We could not map this grant persistently, so use it as\n\t\t * a non-persistent grant.\n\t\t */\nnext:\n\t\tnew_map_idx++;\n\t}\n\tsegs_to_map = 0;\n\tlast_map = map_until;\n\tif (map_until != num)\n\t\tgoto again;\n\n\treturn ret;\n\nout_of_memory:\n\tpr_alert(\"%s: out of memory\\n\", __func__);\n\tgnttab_page_cache_put(&ring->free_pages, pages_to_gnt, segs_to_map);\n\tfor (i = last_map; i < num; i++)\n\t\tpages[i]->handle = BLKBACK_INVALID_HANDLE;\n\treturn -ENOMEM;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,10 +56,8 @@\n \t\t\tbreak;\n \t}\n \n-\tif (segs_to_map) {\n+\tif (segs_to_map)\n \t\tret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);\n-\t\tBUG_ON(ret);\n-\t}\n \n \t/*\n \t * Now swizzle the MFN in our domain with the MFN from the other domain\n@@ -75,7 +73,7 @@\n \t\t\t\tgnttab_page_cache_put(&ring->free_pages,\n \t\t\t\t\t\t      &pages[seg_idx]->page, 1);\n \t\t\t\tpages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;\n-\t\t\t\tret |= 1;\n+\t\t\t\tret |= !ret;\n \t\t\t\tgoto next;\n \t\t\t}\n \t\t\tpages[seg_idx]->handle = map[new_map_idx].handle;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (segs_to_map) {",
                "\t\tBUG_ON(ret);",
                "\t}",
                "\t\t\t\tret |= 1;"
            ],
            "added_lines": [
                "\tif (segs_to_map)",
                "\t\t\t\tret |= !ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22174",
        "func_name": "wireshark/parse_report_descriptor",
        "description": "Crash in USB HID dissector in Wireshark 3.4.0 to 3.4.2 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/785e291c1be04beebae3f3603752f5737dc1694d",
        "commit_title": "USB HID: Avoid allocating a huge amount of memory (second try).",
        "commit_text": " 10204490d7 / MR 80 ensured that we didn't grow field.usages due to an underflow, but it neglected to check for a sane array size. Add another check to make sure we don't wmem_array_grow() too much. Fixes #17165 and fixes #16809 more completely. ",
        "func_before": "static gboolean\nparse_report_descriptor(report_descriptor_t *rdesc)\n{\n    hid_field_t field;\n    guint8 *data = rdesc->desc_body;\n    unsigned int tag, type, size;\n    guint8 prefix;\n    guint32 defined = 0, usage = 0, usage_min = 0, usage_max = 0;\n    wmem_allocator_t *scope = wmem_file_scope();\n    gboolean first_item = TRUE;\n\n    memset(&field, 0, sizeof(field));\n    field.usages = wmem_array_new(scope, sizeof(guint32));\n    rdesc->fields_in = wmem_array_new(scope, sizeof(hid_field_t));\n    rdesc->fields_out = wmem_array_new(scope, sizeof(hid_field_t));\n\n    int i = 0;\n    while (i < rdesc->desc_length)\n    {\n        prefix = data[i];\n        tag = (prefix & 0b11110000) >> 4;\n        type = (prefix & 0b00001100) >> 2;\n        size = prefix & 0b00000011;\n\n        if (size == 3)  /* HID spec: 6.2.2.2 - Short Items */\n            size = 4;\n\n        switch (type)\n        {\n            case USBHID_ITEMTYPE_MAIN:\n                switch (tag)\n                {\n                    case USBHID_MAINITEM_TAG_INPUT:\n                        field.properties = hid_unpack_value(data, i, size);\n\n                        if ((defined & HID_REQUIRED_MASK) != HID_REQUIRED_MASK)\n                            goto err;\n\n                        /* new field */\n                        wmem_array_append_one(rdesc->fields_in, field);\n\n                        field.usages = wmem_array_new(scope, sizeof(guint32));\n                        first_item = FALSE;\n\n                        /* only keep the global items */\n                        defined &= HID_GLOBAL_MASK;\n                        break;\n\n                    case USBHID_MAINITEM_TAG_OUTPUT:\n                        field.properties = hid_unpack_value(data, i, size);\n\n                        if ((defined & HID_REQUIRED_MASK) != HID_REQUIRED_MASK)\n                            goto err;\n\n                        /* new field */\n                        wmem_array_append_one(rdesc->fields_out, field);\n\n                        field.usages = wmem_array_new(scope, sizeof(guint32));\n                        first_item = FALSE;\n\n                        defined &= HID_GLOBAL_MASK;\n                        break;\n\n                    case USBHID_MAINITEM_TAG_FEATURE:\n                        /*\n                        field.properties = hid_unpack_value(data, i, size);\n                        TODO\n                        */\n                        break;\n\n                    case USBHID_MAINITEM_TAG_COLLECTION:\n                        /* clear usages */\n                        wmem_free(scope, field.usages);\n                        field.usages = wmem_array_new(scope, sizeof(guint32));\n                        break;\n\n                    default:\n                        break;\n                }\n                break;\n\n            case USBHID_ITEMTYPE_GLOBAL:\n                switch (tag)\n                {\n                    case USBHID_GLOBALITEM_TAG_USAGE_PAGE:\n                        field.usage_page = hid_unpack_value(data, i, size);\n                        defined |= HID_USAGE_PAGE;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_LOG_MIN:\n                        if (hid_unpack_signed(data, i, size, &field.logical_min))\n                            goto err;\n                        defined |= HID_LOGICAL_MIN;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_LOG_MAX:\n                        if (hid_unpack_signed(data, i, size, &field.logical_max))\n                            goto err;\n                        defined |= HID_LOGICAL_MAX;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_REPORT_SIZE:\n                        field.report_size = hid_unpack_value(data, i, size);\n                        defined |= HID_REPORT_SIZE;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_REPORT_ID:\n                        if (!first_item && !rdesc->uses_report_id)\n                            goto err;\n\n                        rdesc->uses_report_id = TRUE;\n\n                        field.report_id = hid_unpack_value(data, i, size);\n                        defined |= HID_REPORT_ID;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_REPORT_COUNT:\n                        field.report_count = hid_unpack_value(data, i, size);\n                        defined |= HID_REPORT_COUNT;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_PUSH:\n                    case USBHID_GLOBALITEM_TAG_POP:\n                        /* TODO */\n                        goto err;\n\n                    default:\n                        break;\n                }\n                break;\n\n            case USBHID_ITEMTYPE_LOCAL:\n                switch (tag)\n                {\n                    case USBHID_LOCALITEM_TAG_USAGE:\n                        if (!(defined & HID_USAGE_PAGE))\n                            return FALSE;\n\n                        usage = hid_unpack_value(data, i, size);\n\n                        wmem_array_append_one(field.usages, usage);\n                        break;\n\n                    case USBHID_LOCALITEM_TAG_USAGE_MIN:\n                        usage_min = hid_unpack_value(data, i, size);\n                        defined |= HID_USAGE_MIN;\n                        break;\n\n                    case USBHID_LOCALITEM_TAG_USAGE_MAX:\n                        if (!(defined & HID_USAGE_MIN))\n                            return FALSE;\n\n                        usage_max = hid_unpack_value(data, i, size);\n                        if (usage_min > usage_max) {\n                            goto err;\n                        }\n\n                        /* min and max are inclusive */\n                        wmem_array_grow(field.usages, usage_max - usage_min + 1);\n                        for (guint32 j = usage_min; j <= usage_max; j++) {\n                            wmem_array_append_one(field.usages, j);\n                        }\n\n                        defined ^= HID_USAGE_MIN;\n                        break;\n\n                    default: /* TODO */\n                        goto err;\n                }\n                break;\n\n            default: /* reserved */\n                goto err;\n        }\n\n        i += size + 1;\n    }\n\n    return TRUE;\n\nerr:\n    for (unsigned int j = 0; j < wmem_array_get_count(rdesc->fields_in); j++)\n        wmem_free(scope, ((hid_field_t*) wmem_array_index(rdesc->fields_in, j))->usages);\n\n    for (unsigned int j = 0; j < wmem_array_get_count(rdesc->fields_out); j++)\n        wmem_free(scope, ((hid_field_t*) wmem_array_index(rdesc->fields_out, j))->usages);\n\n    wmem_free(scope, rdesc->fields_in);\n    wmem_free(scope, rdesc->fields_out);\n    return FALSE;\n}",
        "func": "static gboolean\nparse_report_descriptor(report_descriptor_t *rdesc)\n{\n    hid_field_t field;\n    guint8 *data = rdesc->desc_body;\n    unsigned int tag, type, size;\n    guint8 prefix;\n    guint32 defined = 0, usage = 0, usage_min = 0, usage_max = 0;\n    wmem_allocator_t *scope = wmem_file_scope();\n    gboolean first_item = TRUE;\n\n    memset(&field, 0, sizeof(field));\n    field.usages = wmem_array_new(scope, sizeof(guint32));\n    rdesc->fields_in = wmem_array_new(scope, sizeof(hid_field_t));\n    rdesc->fields_out = wmem_array_new(scope, sizeof(hid_field_t));\n\n    int i = 0;\n    while (i < rdesc->desc_length)\n    {\n        prefix = data[i];\n        tag = (prefix & 0b11110000) >> 4;\n        type = (prefix & 0b00001100) >> 2;\n        size = prefix & 0b00000011;\n\n        if (size == 3)  /* HID spec: 6.2.2.2 - Short Items */\n            size = 4;\n\n        switch (type)\n        {\n            case USBHID_ITEMTYPE_MAIN:\n                switch (tag)\n                {\n                    case USBHID_MAINITEM_TAG_INPUT:\n                        field.properties = hid_unpack_value(data, i, size);\n\n                        if ((defined & HID_REQUIRED_MASK) != HID_REQUIRED_MASK)\n                            goto err;\n\n                        /* new field */\n                        wmem_array_append_one(rdesc->fields_in, field);\n\n                        field.usages = wmem_array_new(scope, sizeof(guint32));\n                        first_item = FALSE;\n\n                        /* only keep the global items */\n                        defined &= HID_GLOBAL_MASK;\n                        break;\n\n                    case USBHID_MAINITEM_TAG_OUTPUT:\n                        field.properties = hid_unpack_value(data, i, size);\n\n                        if ((defined & HID_REQUIRED_MASK) != HID_REQUIRED_MASK)\n                            goto err;\n\n                        /* new field */\n                        wmem_array_append_one(rdesc->fields_out, field);\n\n                        field.usages = wmem_array_new(scope, sizeof(guint32));\n                        first_item = FALSE;\n\n                        defined &= HID_GLOBAL_MASK;\n                        break;\n\n                    case USBHID_MAINITEM_TAG_FEATURE:\n                        /*\n                        field.properties = hid_unpack_value(data, i, size);\n                        TODO\n                        */\n                        break;\n\n                    case USBHID_MAINITEM_TAG_COLLECTION:\n                        /* clear usages */\n                        wmem_free(scope, field.usages);\n                        field.usages = wmem_array_new(scope, sizeof(guint32));\n                        break;\n\n                    default:\n                        break;\n                }\n                break;\n\n            case USBHID_ITEMTYPE_GLOBAL:\n                switch (tag)\n                {\n                    case USBHID_GLOBALITEM_TAG_USAGE_PAGE:\n                        field.usage_page = hid_unpack_value(data, i, size);\n                        defined |= HID_USAGE_PAGE;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_LOG_MIN:\n                        if (hid_unpack_signed(data, i, size, &field.logical_min))\n                            goto err;\n                        defined |= HID_LOGICAL_MIN;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_LOG_MAX:\n                        if (hid_unpack_signed(data, i, size, &field.logical_max))\n                            goto err;\n                        defined |= HID_LOGICAL_MAX;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_REPORT_SIZE:\n                        field.report_size = hid_unpack_value(data, i, size);\n                        defined |= HID_REPORT_SIZE;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_REPORT_ID:\n                        if (!first_item && !rdesc->uses_report_id)\n                            goto err;\n\n                        rdesc->uses_report_id = TRUE;\n\n                        field.report_id = hid_unpack_value(data, i, size);\n                        defined |= HID_REPORT_ID;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_REPORT_COUNT:\n                        field.report_count = hid_unpack_value(data, i, size);\n                        defined |= HID_REPORT_COUNT;\n                        break;\n\n                    case USBHID_GLOBALITEM_TAG_PUSH:\n                    case USBHID_GLOBALITEM_TAG_POP:\n                        /* TODO */\n                        goto err;\n\n                    default:\n                        break;\n                }\n                break;\n\n            case USBHID_ITEMTYPE_LOCAL:\n                switch (tag)\n                {\n                    case USBHID_LOCALITEM_TAG_USAGE:\n                        if (!(defined & HID_USAGE_PAGE))\n                            return FALSE;\n\n                        usage = hid_unpack_value(data, i, size);\n\n                        wmem_array_append_one(field.usages, usage);\n                        break;\n\n                    case USBHID_LOCALITEM_TAG_USAGE_MIN:\n                        usage_min = hid_unpack_value(data, i, size);\n                        defined |= HID_USAGE_MIN;\n                        break;\n\n                    case USBHID_LOCALITEM_TAG_USAGE_MAX:\n                        if (!(defined & HID_USAGE_MIN))\n                            return FALSE;\n\n                        usage_max = hid_unpack_value(data, i, size);\n                        if (usage_min > usage_max) {\n                            goto err;\n                        }\n\n                        if (wmem_array_get_count(field.usages) + usage_max - usage_min >= MAX_REPORT_DESCRIPTOR_COUNT) {\n                            goto err;\n                        }\n\n                        /* min and max are inclusive */\n                        wmem_array_grow(field.usages, usage_max - usage_min + 1);\n                        for (guint32 j = usage_min; j <= usage_max; j++) {\n                            wmem_array_append_one(field.usages, j);\n                        }\n\n                        defined ^= HID_USAGE_MIN;\n                        break;\n\n                    default: /* TODO */\n                        goto err;\n                }\n                break;\n\n            default: /* reserved */\n                goto err;\n        }\n\n        i += size + 1;\n    }\n\n    return TRUE;\n\nerr:\n    for (unsigned int j = 0; j < wmem_array_get_count(rdesc->fields_in); j++)\n        wmem_free(scope, ((hid_field_t*) wmem_array_index(rdesc->fields_in, j))->usages);\n\n    for (unsigned int j = 0; j < wmem_array_get_count(rdesc->fields_out); j++)\n        wmem_free(scope, ((hid_field_t*) wmem_array_index(rdesc->fields_out, j))->usages);\n\n    wmem_free(scope, rdesc->fields_in);\n    wmem_free(scope, rdesc->fields_out);\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -155,6 +155,10 @@\n                             goto err;\n                         }\n \n+                        if (wmem_array_get_count(field.usages) + usage_max - usage_min >= MAX_REPORT_DESCRIPTOR_COUNT) {\n+                            goto err;\n+                        }\n+\n                         /* min and max are inclusive */\n                         wmem_array_grow(field.usages, usage_max - usage_min + 1);\n                         for (guint32 j = usage_min; j <= usage_max; j++) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                        if (wmem_array_get_count(field.usages) + usage_max - usage_min >= MAX_REPORT_DESCRIPTOR_COUNT) {",
                "                            goto err;",
                "                        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28038",
        "func_name": "torvalds/linux/xenvif_tx_action",
        "description": "An issue was discovered in the Linux kernel through 5.11.3, as used with Xen PV. A certain part of the netback driver lacks necessary treatment of errors such as failed memory allocations (as a result of changes to the handling of grant mapping errors). A host OS denial of service may occur during misbehavior of a networking frontend driver. NOTE: this issue exists because of an incomplete fix for CVE-2021-26931.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=2991397d23ec597405b116d96de3813420bdcbc3",
        "commit_title": "Commit 3194a1746e8a (\"xen-netback: don't \"handle\" error by BUG()\")",
        "commit_text": "dropped respective a BUG_ON() without noticing that with this the variable's value wouldn't be consumed anymore. With gnttab_set_map_op() setting all status fields to a non-zero value, in case of an error no slot should have a status of GNTST_okay (zero).  This is part of XSA-367.  Cc: <stable@vger.kernel.org> Link: https://lore.kernel.org/r/d933f495-619a-0086-5fb4-1ec3cf81a8fc@suse.com ",
        "func_before": "int xenvif_tx_action(struct xenvif_queue *queue, int budget)\n{\n\tunsigned nr_mops, nr_cops = 0;\n\tint work_done, ret;\n\n\tif (unlikely(!tx_work_todo(queue)))\n\t\treturn 0;\n\n\txenvif_tx_build_gops(queue, budget, &nr_cops, &nr_mops);\n\n\tif (nr_cops == 0)\n\t\treturn 0;\n\n\tgnttab_batch_copy(queue->tx_copy_ops, nr_cops);\n\tif (nr_mops != 0)\n\t\tret = gnttab_map_refs(queue->tx_map_ops,\n\t\t\t\t      NULL,\n\t\t\t\t      queue->pages_to_map,\n\t\t\t\t      nr_mops);\n\n\twork_done = xenvif_tx_submit(queue);\n\n\treturn work_done;\n}",
        "func": "int xenvif_tx_action(struct xenvif_queue *queue, int budget)\n{\n\tunsigned nr_mops, nr_cops = 0;\n\tint work_done, ret;\n\n\tif (unlikely(!tx_work_todo(queue)))\n\t\treturn 0;\n\n\txenvif_tx_build_gops(queue, budget, &nr_cops, &nr_mops);\n\n\tif (nr_cops == 0)\n\t\treturn 0;\n\n\tgnttab_batch_copy(queue->tx_copy_ops, nr_cops);\n\tif (nr_mops != 0) {\n\t\tret = gnttab_map_refs(queue->tx_map_ops,\n\t\t\t\t      NULL,\n\t\t\t\t      queue->pages_to_map,\n\t\t\t\t      nr_mops);\n\t\tif (ret) {\n\t\t\tunsigned int i;\n\n\t\t\tnetdev_err(queue->vif->dev, \"Map fail: nr %u ret %d\\n\",\n\t\t\t\t   nr_mops, ret);\n\t\t\tfor (i = 0; i < nr_mops; ++i)\n\t\t\t\tWARN_ON_ONCE(queue->tx_map_ops[i].status ==\n\t\t\t\t             GNTST_okay);\n\t\t}\n\t}\n\n\twork_done = xenvif_tx_submit(queue);\n\n\treturn work_done;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,11 +12,21 @@\n \t\treturn 0;\n \n \tgnttab_batch_copy(queue->tx_copy_ops, nr_cops);\n-\tif (nr_mops != 0)\n+\tif (nr_mops != 0) {\n \t\tret = gnttab_map_refs(queue->tx_map_ops,\n \t\t\t\t      NULL,\n \t\t\t\t      queue->pages_to_map,\n \t\t\t\t      nr_mops);\n+\t\tif (ret) {\n+\t\t\tunsigned int i;\n+\n+\t\t\tnetdev_err(queue->vif->dev, \"Map fail: nr %u ret %d\\n\",\n+\t\t\t\t   nr_mops, ret);\n+\t\t\tfor (i = 0; i < nr_mops; ++i)\n+\t\t\t\tWARN_ON_ONCE(queue->tx_map_ops[i].status ==\n+\t\t\t\t             GNTST_okay);\n+\t\t}\n+\t}\n \n \twork_done = xenvif_tx_submit(queue);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (nr_mops != 0)"
            ],
            "added_lines": [
                "\tif (nr_mops != 0) {",
                "\t\tif (ret) {",
                "\t\t\tunsigned int i;",
                "",
                "\t\t\tnetdev_err(queue->vif->dev, \"Map fail: nr %u ret %d\\n\",",
                "\t\t\t\t   nr_mops, ret);",
                "\t\t\tfor (i = 0; i < nr_mops; ++i)",
                "\t\t\t\tWARN_ON_ONCE(queue->tx_map_ops[i].status ==",
                "\t\t\t\t             GNTST_okay);",
                "\t\t}",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24994",
        "func_name": "libass/parse_tags",
        "description": "Stack overflow in the parse_tag function in libass/ass_parse.c in libass before 0.15.0 allows remote attackers to cause a denial of service or remote code execution via a crafted file.",
        "git_url": "https://github.com/libass/libass/commit/6835731c2fe4164a0c50bc91d12c43b2a2b4e799",
        "commit_title": "parse_tags: don't recurse for nested \\t()",
        "commit_text": " This fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=4892 (stack overflow on deeply nested \\t()).  This is possible because parentheses do not nest and the first ')' terminates the whole tag. Thus something like \\t(\\t(\\t(\\t(\\t() can be read in a simple loop with no recursion required. Recursion is also not required if the ')' is missing entirely and the outermost \\t(... never ends.  See https://github.com/libass/libass/pull/296 for more backstory.",
        "func_before": "char *parse_tags(ASS_Renderer *render_priv, char *p, char *end, double pwr)\n{\n    for (char *q; p < end; p = q) {\n        while (*p != '\\\\' && p != end)\n            ++p;\n        if (*p != '\\\\')\n            break;\n        ++p;\n        if (p != end)\n            skip_spaces(&p);\n\n        q = p;\n        while (*q != '(' && *q != '\\\\' && q != end)\n            ++q;\n        if (q == p)\n            continue;\n\n        char *name_end = q;\n\n        // Store one extra element to be able to detect excess arguments\n        struct arg args[MAX_VALID_NARGS + 1];\n        int nargs = 0;\n        for (int i = 0; i <= MAX_VALID_NARGS; ++i)\n            args[i].start = args[i].end = \"\";\n\n        // Split parenthesized arguments. Do this for all tags and before\n        // any non-parenthesized argument because that's what VSFilter does.\n        if (*q == '(') {\n            ++q;\n            while (1) {\n                if (q != end)\n                    skip_spaces(&q);\n\n                // Split on commas. If there is a backslash, ignore any\n                // commas following it and lump everything starting from\n                // the last comma, through the backslash and all the way\n                // to the end of the argument string into a single argument.\n\n                char *r = q;\n                while (*r != ',' && *r != '\\\\' && *r != ')' && r != end)\n                    ++r;\n\n                if (*r == ',') {\n                    push_arg(args, &nargs, q, r);\n                    q = r + 1;\n                } else {\n                    // Swallow the rest of the parenthesized string. This could\n                    // be either a backslash-argument or simply the last argument.\n                    while (*r != ')' && r != end)\n                        ++r;\n                    push_arg(args, &nargs, q, r);\n                    q = r;\n                    // The closing parenthesis could be missing.\n                    if (q != end)\n                        ++q;\n                    break;\n                }\n            }\n        }\n\n#define tag(name) (mystrcmp(&p, (name)) && (push_arg(args, &nargs, p, name_end), 1))\n#define complex_tag(name) mystrcmp(&p, (name))\n\n        // New tags introduced in vsfilter 2.39\n        if (tag(\"xbord\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.border_x * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->Outline;\n            render_priv->state.border_x = val;\n        } else if (tag(\"ybord\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.border_y * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->Outline;\n            render_priv->state.border_y = val;\n        } else if (tag(\"xshad\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;\n            } else\n                val = render_priv->state.style->Shadow;\n            render_priv->state.shadow_x = val;\n        } else if (tag(\"yshad\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.shadow_y * (1 - pwr) + val * pwr;\n            } else\n                val = render_priv->state.style->Shadow;\n            render_priv->state.shadow_y = val;\n        } else if (tag(\"fax\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.fax =\n                    val * pwr + render_priv->state.fax * (1 - pwr);\n            } else\n                render_priv->state.fax = 0.;\n        } else if (tag(\"fay\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.fay =\n                    val * pwr + render_priv->state.fay * (1 - pwr);\n            } else\n                render_priv->state.fay = 0.;\n        } else if (complex_tag(\"iclip\")) {\n            if (nargs == 4) {\n                int x0, y0, x1, y1;\n                x0 = argtoi(args[0]);\n                y0 = argtoi(args[1]);\n                x1 = argtoi(args[2]);\n                y1 = argtoi(args[3]);\n                render_priv->state.clip_x0 =\n                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;\n                render_priv->state.clip_x1 =\n                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;\n                render_priv->state.clip_y0 =\n                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;\n                render_priv->state.clip_y1 =\n                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;\n                render_priv->state.clip_mode = 1;\n            } else if (!render_priv->state.clip_drawing) {\n                if (parse_vector_clip(render_priv, args, nargs))\n                    render_priv->state.clip_drawing_mode = 1;\n            }\n        } else if (tag(\"blur\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.blur * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n                val = (val > BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;\n                render_priv->state.blur = val;\n            } else\n                render_priv->state.blur = 0.0;\n            // ASS standard tags\n        } else if (tag(\"fscx\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args) / 100;\n                val = render_priv->state.scale_x * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->ScaleX;\n            render_priv->state.scale_x = val;\n        } else if (tag(\"fscy\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args) / 100;\n                val = render_priv->state.scale_y * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->ScaleY;\n            render_priv->state.scale_y = val;\n        } else if (tag(\"fsc\")) {\n            render_priv->state.scale_x = render_priv->state.style->ScaleX;\n            render_priv->state.scale_y = render_priv->state.style->ScaleY;\n        } else if (tag(\"fsp\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.hspacing =\n                    render_priv->state.hspacing * (1 - pwr) + val * pwr;\n            } else\n                render_priv->state.hspacing = render_priv->state.style->Spacing;\n        } else if (tag(\"fs\")) {\n            double val = 0;\n            if (nargs) {\n                val = argtod(*args);\n                if (*args->start == '+' || *args->start == '-')\n                    val = render_priv->state.font_size * (1 + pwr * val / 10);\n                else\n                    val = render_priv->state.font_size * (1 - pwr) + val * pwr;\n            }\n            if (val <= 0)\n                val = render_priv->state.style->FontSize;\n            if (render_priv->state.font)\n                change_font_size(render_priv, val);\n        } else if (tag(\"bord\")) {\n            double val, xval, yval;\n            if (nargs) {\n                val = argtod(*args);\n                xval = render_priv->state.border_x * (1 - pwr) + val * pwr;\n                yval = render_priv->state.border_y * (1 - pwr) + val * pwr;\n                xval = (xval < 0) ? 0 : xval;\n                yval = (yval < 0) ? 0 : yval;\n            } else\n                xval = yval = render_priv->state.style->Outline;\n            render_priv->state.border_x = xval;\n            render_priv->state.border_y = yval;\n        } else if (complex_tag(\"move\")) {\n            double x1, x2, y1, y2;\n            long long t1, t2, delta_t, t;\n            double x, y;\n            double k;\n            if (nargs == 4 || nargs == 6) {\n                x1 = argtod(args[0]);\n                y1 = argtod(args[1]);\n                x2 = argtod(args[2]);\n                y2 = argtod(args[3]);\n                t1 = t2 = 0;\n                if (nargs == 6) {\n                    t1 = argtoll(args[4]);\n                    t2 = argtoll(args[5]);\n                    if (t1 > t2) {\n                        long long tmp = t2;\n                        t2 = t1;\n                        t1 = tmp;\n                    }\n                }\n            } else\n                continue;\n            if (t1 <= 0 && t2 <= 0) {\n                t1 = 0;\n                t2 = render_priv->state.event->Duration;\n            }\n            delta_t = t2 - t1;\n            t = render_priv->time - render_priv->state.event->Start;\n            if (t <= t1)\n                k = 0.;\n            else if (t >= t2)\n                k = 1.;\n            else\n                k = ((double) (t - t1)) / delta_t;\n            x = k * (x2 - x1) + x1;\n            y = k * (y2 - y1) + y1;\n            if (render_priv->state.evt_type != EVENT_POSITIONED) {\n                render_priv->state.pos_x = x;\n                render_priv->state.pos_y = y;\n                render_priv->state.detect_collisions = 0;\n                render_priv->state.evt_type = EVENT_POSITIONED;\n            }\n        } else if (tag(\"frx\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.frx =\n                    val * pwr + render_priv->state.frx * (1 - pwr);\n            } else\n                render_priv->state.frx = 0.;\n        } else if (tag(\"fry\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.fry =\n                    val * pwr + render_priv->state.fry * (1 - pwr);\n            } else\n                render_priv->state.fry = 0.;\n        } else if (tag(\"frz\") || tag(\"fr\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.frz =\n                    val * pwr + render_priv->state.frz * (1 - pwr);\n            } else\n                render_priv->state.frz =\n                    M_PI * render_priv->state.style->Angle / 180.;\n        } else if (tag(\"fn\")) {\n            char *family;\n            char *start = args->start;\n            if (nargs && strncmp(start, \"0\", args->end - start)) {\n                skip_spaces(&start);\n                family = strndup(start, args->end - start);\n            } else\n                family = strdup(render_priv->state.style->FontName);\n            free(render_priv->state.family);\n            render_priv->state.family = family;\n            update_font(render_priv);\n        } else if (tag(\"alpha\")) {\n            int i;\n            if (nargs) {\n                int32_t a = parse_alpha_tag(args->start);\n                for (i = 0; i < 4; ++i)\n                    change_alpha(&render_priv->state.c[i], a, pwr);\n            } else {\n                change_alpha(&render_priv->state.c[0],\n                             _a(render_priv->state.style->PrimaryColour), 1);\n                change_alpha(&render_priv->state.c[1],\n                             _a(render_priv->state.style->SecondaryColour), 1);\n                change_alpha(&render_priv->state.c[2],\n                             _a(render_priv->state.style->OutlineColour), 1);\n                change_alpha(&render_priv->state.c[3],\n                             _a(render_priv->state.style->BackColour), 1);\n            }\n            // FIXME: simplify\n        } else if (tag(\"an\")) {\n            int val = argtoi(*args);\n            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {\n                if (val >= 1 && val <= 9)\n                    render_priv->state.alignment = numpad2align(val);\n                else\n                    render_priv->state.alignment =\n                        render_priv->state.style->Alignment;\n                render_priv->state.parsed_tags |= PARSED_A;\n            }\n        } else if (tag(\"a\")) {\n            int val = argtoi(*args);\n            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {\n                if (val >= 1 && val <= 11)\n                    // take care of a vsfilter quirk:\n                    // handle illegal \\a8 and \\a4 like \\a5\n                    render_priv->state.alignment = ((val & 3) == 0) ? 5 : val;\n                else\n                    render_priv->state.alignment =\n                        render_priv->state.style->Alignment;\n                render_priv->state.parsed_tags |= PARSED_A;\n            }\n        } else if (complex_tag(\"pos\")) {\n            double v1, v2;\n            if (nargs == 2) {\n                v1 = argtod(args[0]);\n                v2 = argtod(args[1]);\n            } else\n                continue;\n            if (render_priv->state.evt_type == EVENT_POSITIONED) {\n                ass_msg(render_priv->library, MSGL_V, \"Subtitle has a new \\\\pos \"\n                       \"after \\\\move or \\\\pos, ignoring\");\n            } else {\n                render_priv->state.evt_type = EVENT_POSITIONED;\n                render_priv->state.detect_collisions = 0;\n                render_priv->state.pos_x = v1;\n                render_priv->state.pos_y = v2;\n            }\n        } else if (complex_tag(\"fade\") || complex_tag(\"fad\")) {\n            int a1, a2, a3;\n            long long t1, t2, t3, t4;\n            if (nargs == 2) {\n                // 2-argument version (\\fad, according to specs)\n                a1 = 0xFF;\n                a2 = 0;\n                a3 = 0xFF;\n                t1 = -1;\n                t2 = argtoll(args[0]);\n                t3 = argtoll(args[1]);\n                t4 = -1;\n            } else if (nargs == 7) {\n                // 7-argument version (\\fade)\n                a1 = argtoi(args[0]);\n                a2 = argtoi(args[1]);\n                a3 = argtoi(args[2]);\n                t1 = argtoll(args[3]);\n                t2 = argtoll(args[4]);\n                t3 = argtoll(args[5]);\n                t4 = argtoll(args[6]);\n            } else\n                continue;\n            if (t1 == -1 && t4 == -1) {\n                t1 = 0;\n                t4 = render_priv->state.event->Duration;\n                t3 = t4 - t3;\n            }\n            if ((render_priv->state.parsed_tags & PARSED_FADE) == 0) {\n                render_priv->state.fade =\n                    interpolate_alpha(render_priv->time -\n                            render_priv->state.event->Start, t1, t2,\n                            t3, t4, a1, a2, a3);\n                render_priv->state.parsed_tags |= PARSED_FADE;\n            }\n        } else if (complex_tag(\"org\")) {\n            double v1, v2;\n            if (nargs == 2) {\n                v1 = argtod(args[0]);\n                v2 = argtod(args[1]);\n            } else\n                continue;\n            if (!render_priv->state.have_origin) {\n                render_priv->state.org_x = v1;\n                render_priv->state.org_y = v2;\n                render_priv->state.have_origin = 1;\n                render_priv->state.detect_collisions = 0;\n            }\n        } else if (complex_tag(\"t\")) {\n            double accel;\n            int cnt = nargs - 1;\n            long long t1, t2, t, delta_t;\n            double k;\n            if (cnt == 3) {\n                t1 = argtoll(args[0]);\n                t2 = argtoll(args[1]);\n                accel = argtod(args[2]);\n            } else if (cnt == 2) {\n                t1 = argtoll(args[0]);\n                t2 = argtoll(args[1]);\n                accel = 1.;\n            } else if (cnt == 1) {\n                t1 = 0;\n                t2 = 0;\n                accel = argtod(args[0]);\n            } else if (cnt == 0) {\n                t1 = 0;\n                t2 = 0;\n                accel = 1.;\n            } else\n                continue;\n            render_priv->state.detect_collisions = 0;\n            if (t2 == 0)\n                t2 = render_priv->state.event->Duration;\n            delta_t = t2 - t1;\n            t = render_priv->time - render_priv->state.event->Start;        // FIXME: move to render_context\n            if (t <= t1)\n                k = 0.;\n            else if (t >= t2)\n                k = 1.;\n            else {\n                assert(delta_t != 0.);\n                k = pow(((double) (t - t1)) / delta_t, accel);\n            }\n            p = args[cnt].start;\n            p = parse_tags(render_priv, p, args[cnt].end, k);    // maybe k*pwr ? no, specs forbid nested \\t's\n        } else if (complex_tag(\"clip\")) {\n            if (nargs == 4) {\n                int x0, y0, x1, y1;\n                x0 = argtoi(args[0]);\n                y0 = argtoi(args[1]);\n                x1 = argtoi(args[2]);\n                y1 = argtoi(args[3]);\n                render_priv->state.clip_x0 =\n                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;\n                render_priv->state.clip_x1 =\n                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;\n                render_priv->state.clip_y0 =\n                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;\n                render_priv->state.clip_y1 =\n                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;\n                render_priv->state.clip_mode = 0;\n            } else if (!render_priv->state.clip_drawing) {\n                if (parse_vector_clip(render_priv, args, nargs))\n                    render_priv->state.clip_drawing_mode = 0;\n            }\n        } else if (tag(\"c\") || tag(\"1c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[0], val, pwr);\n            } else\n                change_color(&render_priv->state.c[0],\n                             render_priv->state.style->PrimaryColour, 1);\n        } else if (tag(\"2c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[1], val, pwr);\n            } else\n                change_color(&render_priv->state.c[1],\n                             render_priv->state.style->SecondaryColour, 1);\n        } else if (tag(\"3c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[2], val, pwr);\n            } else\n                change_color(&render_priv->state.c[2],\n                             render_priv->state.style->OutlineColour, 1);\n        } else if (tag(\"4c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[3], val, pwr);\n            } else\n                change_color(&render_priv->state.c[3],\n                             render_priv->state.style->BackColour, 1);\n        } else if (tag(\"1a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[0], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[0],\n                             _a(render_priv->state.style->PrimaryColour), 1);\n        } else if (tag(\"2a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[1], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[1],\n                             _a(render_priv->state.style->SecondaryColour), 1);\n        } else if (tag(\"3a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[2], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[2],\n                             _a(render_priv->state.style->OutlineColour), 1);\n        } else if (tag(\"4a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[3], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[3],\n                             _a(render_priv->state.style->BackColour), 1);\n        } else if (tag(\"r\")) {\n            if (nargs) {\n                int len = args->end - args->start;\n                reset_render_context(render_priv,\n                        lookup_style_strict(render_priv->track, args->start, len));\n            } else\n                reset_render_context(render_priv, NULL);\n        } else if (tag(\"be\")) {\n            double dval;\n            if (nargs) {\n                int val;\n                dval = argtod(*args);\n                // VSFilter always adds +0.5, even if the value is negative\n                val = (int) (render_priv->state.be * (1 - pwr) + dval * pwr + 0.5);\n                // Clamp to a safe upper limit, since high values need excessive CPU\n                val = (val < 0) ? 0 : val;\n                val = (val > MAX_BE) ? MAX_BE : val;\n                render_priv->state.be = val;\n            } else\n                render_priv->state.be = 0;\n        } else if (tag(\"b\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1 || val >= 100))\n                val = render_priv->state.style->Bold;\n            render_priv->state.bold = val;\n            update_font(render_priv);\n        } else if (tag(\"i\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->Italic;\n            render_priv->state.italic = val;\n            update_font(render_priv);\n        } else if (tag(\"kf\") || tag(\"K\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE_KF;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"ko\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE_KO;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"k\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"shad\")) {\n            double val, xval, yval;\n            if (nargs) {\n                val = argtod(*args);\n                xval = render_priv->state.shadow_x * (1 - pwr) + val * pwr;\n                yval = render_priv->state.shadow_y * (1 - pwr) + val * pwr;\n                // VSFilter compatibility: clip for \\shad but not for \\[xy]shad\n                xval = (xval < 0) ? 0 : xval;\n                yval = (yval < 0) ? 0 : yval;\n            } else\n                xval = yval = render_priv->state.style->Shadow;\n            render_priv->state.shadow_x = xval;\n            render_priv->state.shadow_y = yval;\n        } else if (tag(\"s\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->StrikeOut;\n            if (val)\n                render_priv->state.flags |= DECO_STRIKETHROUGH;\n            else\n                render_priv->state.flags &= ~DECO_STRIKETHROUGH;\n        } else if (tag(\"u\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->Underline;\n            if (val)\n                render_priv->state.flags |= DECO_UNDERLINE;\n            else\n                render_priv->state.flags &= ~DECO_UNDERLINE;\n        } else if (tag(\"pbo\")) {\n            double val = argtod(*args);\n            render_priv->state.pbo = val;\n        } else if (tag(\"p\")) {\n            int val = argtoi(*args);\n            val = (val < 0) ? 0 : val;\n            render_priv->state.drawing_scale = val;\n        } else if (tag(\"q\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val >= 0 && val <= 3))\n                val = render_priv->track->WrapStyle;\n            render_priv->state.wrap_style = val;\n        } else if (tag(\"fe\")) {\n            int val;\n            if (nargs)\n                val = argtoi(*args);\n            else\n                val = render_priv->state.style->Encoding;\n            render_priv->state.font_encoding = val;\n        }\n    }\n\n    return p;\n}",
        "func": "char *parse_tags(ASS_Renderer *render_priv, char *p, char *end, double pwr)\n{\n    for (char *q; p < end; p = q) {\n        while (*p != '\\\\' && p != end)\n            ++p;\n        if (*p != '\\\\')\n            break;\n        ++p;\n        if (p != end)\n            skip_spaces(&p);\n\n        q = p;\n        while (*q != '(' && *q != '\\\\' && q != end)\n            ++q;\n        if (q == p)\n            continue;\n\n        char *name_end = q;\n\n        // Store one extra element to be able to detect excess arguments\n        struct arg args[MAX_VALID_NARGS + 1];\n        int nargs = 0;\n        for (int i = 0; i <= MAX_VALID_NARGS; ++i)\n            args[i].start = args[i].end = \"\";\n\n        // Split parenthesized arguments. Do this for all tags and before\n        // any non-parenthesized argument because that's what VSFilter does.\n        if (*q == '(') {\n            ++q;\n            while (1) {\n                if (q != end)\n                    skip_spaces(&q);\n\n                // Split on commas. If there is a backslash, ignore any\n                // commas following it and lump everything starting from\n                // the last comma, through the backslash and all the way\n                // to the end of the argument string into a single argument.\n\n                char *r = q;\n                while (*r != ',' && *r != '\\\\' && *r != ')' && r != end)\n                    ++r;\n\n                if (*r == ',') {\n                    push_arg(args, &nargs, q, r);\n                    q = r + 1;\n                } else {\n                    // Swallow the rest of the parenthesized string. This could\n                    // be either a backslash-argument or simply the last argument.\n                    while (*r != ')' && r != end)\n                        ++r;\n                    push_arg(args, &nargs, q, r);\n                    q = r;\n                    // The closing parenthesis could be missing.\n                    if (q != end)\n                        ++q;\n                    break;\n                }\n            }\n        }\n\n#define tag(name) (mystrcmp(&p, (name)) && (push_arg(args, &nargs, p, name_end), 1))\n#define complex_tag(name) mystrcmp(&p, (name))\n\n        // New tags introduced in vsfilter 2.39\n        if (tag(\"xbord\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.border_x * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->Outline;\n            render_priv->state.border_x = val;\n        } else if (tag(\"ybord\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.border_y * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->Outline;\n            render_priv->state.border_y = val;\n        } else if (tag(\"xshad\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;\n            } else\n                val = render_priv->state.style->Shadow;\n            render_priv->state.shadow_x = val;\n        } else if (tag(\"yshad\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.shadow_y * (1 - pwr) + val * pwr;\n            } else\n                val = render_priv->state.style->Shadow;\n            render_priv->state.shadow_y = val;\n        } else if (tag(\"fax\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.fax =\n                    val * pwr + render_priv->state.fax * (1 - pwr);\n            } else\n                render_priv->state.fax = 0.;\n        } else if (tag(\"fay\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.fay =\n                    val * pwr + render_priv->state.fay * (1 - pwr);\n            } else\n                render_priv->state.fay = 0.;\n        } else if (complex_tag(\"iclip\")) {\n            if (nargs == 4) {\n                int x0, y0, x1, y1;\n                x0 = argtoi(args[0]);\n                y0 = argtoi(args[1]);\n                x1 = argtoi(args[2]);\n                y1 = argtoi(args[3]);\n                render_priv->state.clip_x0 =\n                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;\n                render_priv->state.clip_x1 =\n                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;\n                render_priv->state.clip_y0 =\n                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;\n                render_priv->state.clip_y1 =\n                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;\n                render_priv->state.clip_mode = 1;\n            } else if (!render_priv->state.clip_drawing) {\n                if (parse_vector_clip(render_priv, args, nargs))\n                    render_priv->state.clip_drawing_mode = 1;\n            }\n        } else if (tag(\"blur\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val = render_priv->state.blur * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n                val = (val > BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;\n                render_priv->state.blur = val;\n            } else\n                render_priv->state.blur = 0.0;\n            // ASS standard tags\n        } else if (tag(\"fscx\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args) / 100;\n                val = render_priv->state.scale_x * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->ScaleX;\n            render_priv->state.scale_x = val;\n        } else if (tag(\"fscy\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args) / 100;\n                val = render_priv->state.scale_y * (1 - pwr) + val * pwr;\n                val = (val < 0) ? 0 : val;\n            } else\n                val = render_priv->state.style->ScaleY;\n            render_priv->state.scale_y = val;\n        } else if (tag(\"fsc\")) {\n            render_priv->state.scale_x = render_priv->state.style->ScaleX;\n            render_priv->state.scale_y = render_priv->state.style->ScaleY;\n        } else if (tag(\"fsp\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                render_priv->state.hspacing =\n                    render_priv->state.hspacing * (1 - pwr) + val * pwr;\n            } else\n                render_priv->state.hspacing = render_priv->state.style->Spacing;\n        } else if (tag(\"fs\")) {\n            double val = 0;\n            if (nargs) {\n                val = argtod(*args);\n                if (*args->start == '+' || *args->start == '-')\n                    val = render_priv->state.font_size * (1 + pwr * val / 10);\n                else\n                    val = render_priv->state.font_size * (1 - pwr) + val * pwr;\n            }\n            if (val <= 0)\n                val = render_priv->state.style->FontSize;\n            if (render_priv->state.font)\n                change_font_size(render_priv, val);\n        } else if (tag(\"bord\")) {\n            double val, xval, yval;\n            if (nargs) {\n                val = argtod(*args);\n                xval = render_priv->state.border_x * (1 - pwr) + val * pwr;\n                yval = render_priv->state.border_y * (1 - pwr) + val * pwr;\n                xval = (xval < 0) ? 0 : xval;\n                yval = (yval < 0) ? 0 : yval;\n            } else\n                xval = yval = render_priv->state.style->Outline;\n            render_priv->state.border_x = xval;\n            render_priv->state.border_y = yval;\n        } else if (complex_tag(\"move\")) {\n            double x1, x2, y1, y2;\n            long long t1, t2, delta_t, t;\n            double x, y;\n            double k;\n            if (nargs == 4 || nargs == 6) {\n                x1 = argtod(args[0]);\n                y1 = argtod(args[1]);\n                x2 = argtod(args[2]);\n                y2 = argtod(args[3]);\n                t1 = t2 = 0;\n                if (nargs == 6) {\n                    t1 = argtoll(args[4]);\n                    t2 = argtoll(args[5]);\n                    if (t1 > t2) {\n                        long long tmp = t2;\n                        t2 = t1;\n                        t1 = tmp;\n                    }\n                }\n            } else\n                continue;\n            if (t1 <= 0 && t2 <= 0) {\n                t1 = 0;\n                t2 = render_priv->state.event->Duration;\n            }\n            delta_t = t2 - t1;\n            t = render_priv->time - render_priv->state.event->Start;\n            if (t <= t1)\n                k = 0.;\n            else if (t >= t2)\n                k = 1.;\n            else\n                k = ((double) (t - t1)) / delta_t;\n            x = k * (x2 - x1) + x1;\n            y = k * (y2 - y1) + y1;\n            if (render_priv->state.evt_type != EVENT_POSITIONED) {\n                render_priv->state.pos_x = x;\n                render_priv->state.pos_y = y;\n                render_priv->state.detect_collisions = 0;\n                render_priv->state.evt_type = EVENT_POSITIONED;\n            }\n        } else if (tag(\"frx\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.frx =\n                    val * pwr + render_priv->state.frx * (1 - pwr);\n            } else\n                render_priv->state.frx = 0.;\n        } else if (tag(\"fry\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.fry =\n                    val * pwr + render_priv->state.fry * (1 - pwr);\n            } else\n                render_priv->state.fry = 0.;\n        } else if (tag(\"frz\") || tag(\"fr\")) {\n            double val;\n            if (nargs) {\n                val = argtod(*args);\n                val *= M_PI / 180;\n                render_priv->state.frz =\n                    val * pwr + render_priv->state.frz * (1 - pwr);\n            } else\n                render_priv->state.frz =\n                    M_PI * render_priv->state.style->Angle / 180.;\n        } else if (tag(\"fn\")) {\n            char *family;\n            char *start = args->start;\n            if (nargs && strncmp(start, \"0\", args->end - start)) {\n                skip_spaces(&start);\n                family = strndup(start, args->end - start);\n            } else\n                family = strdup(render_priv->state.style->FontName);\n            free(render_priv->state.family);\n            render_priv->state.family = family;\n            update_font(render_priv);\n        } else if (tag(\"alpha\")) {\n            int i;\n            if (nargs) {\n                int32_t a = parse_alpha_tag(args->start);\n                for (i = 0; i < 4; ++i)\n                    change_alpha(&render_priv->state.c[i], a, pwr);\n            } else {\n                change_alpha(&render_priv->state.c[0],\n                             _a(render_priv->state.style->PrimaryColour), 1);\n                change_alpha(&render_priv->state.c[1],\n                             _a(render_priv->state.style->SecondaryColour), 1);\n                change_alpha(&render_priv->state.c[2],\n                             _a(render_priv->state.style->OutlineColour), 1);\n                change_alpha(&render_priv->state.c[3],\n                             _a(render_priv->state.style->BackColour), 1);\n            }\n            // FIXME: simplify\n        } else if (tag(\"an\")) {\n            int val = argtoi(*args);\n            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {\n                if (val >= 1 && val <= 9)\n                    render_priv->state.alignment = numpad2align(val);\n                else\n                    render_priv->state.alignment =\n                        render_priv->state.style->Alignment;\n                render_priv->state.parsed_tags |= PARSED_A;\n            }\n        } else if (tag(\"a\")) {\n            int val = argtoi(*args);\n            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {\n                if (val >= 1 && val <= 11)\n                    // take care of a vsfilter quirk:\n                    // handle illegal \\a8 and \\a4 like \\a5\n                    render_priv->state.alignment = ((val & 3) == 0) ? 5 : val;\n                else\n                    render_priv->state.alignment =\n                        render_priv->state.style->Alignment;\n                render_priv->state.parsed_tags |= PARSED_A;\n            }\n        } else if (complex_tag(\"pos\")) {\n            double v1, v2;\n            if (nargs == 2) {\n                v1 = argtod(args[0]);\n                v2 = argtod(args[1]);\n            } else\n                continue;\n            if (render_priv->state.evt_type == EVENT_POSITIONED) {\n                ass_msg(render_priv->library, MSGL_V, \"Subtitle has a new \\\\pos \"\n                       \"after \\\\move or \\\\pos, ignoring\");\n            } else {\n                render_priv->state.evt_type = EVENT_POSITIONED;\n                render_priv->state.detect_collisions = 0;\n                render_priv->state.pos_x = v1;\n                render_priv->state.pos_y = v2;\n            }\n        } else if (complex_tag(\"fade\") || complex_tag(\"fad\")) {\n            int a1, a2, a3;\n            long long t1, t2, t3, t4;\n            if (nargs == 2) {\n                // 2-argument version (\\fad, according to specs)\n                a1 = 0xFF;\n                a2 = 0;\n                a3 = 0xFF;\n                t1 = -1;\n                t2 = argtoll(args[0]);\n                t3 = argtoll(args[1]);\n                t4 = -1;\n            } else if (nargs == 7) {\n                // 7-argument version (\\fade)\n                a1 = argtoi(args[0]);\n                a2 = argtoi(args[1]);\n                a3 = argtoi(args[2]);\n                t1 = argtoll(args[3]);\n                t2 = argtoll(args[4]);\n                t3 = argtoll(args[5]);\n                t4 = argtoll(args[6]);\n            } else\n                continue;\n            if (t1 == -1 && t4 == -1) {\n                t1 = 0;\n                t4 = render_priv->state.event->Duration;\n                t3 = t4 - t3;\n            }\n            if ((render_priv->state.parsed_tags & PARSED_FADE) == 0) {\n                render_priv->state.fade =\n                    interpolate_alpha(render_priv->time -\n                            render_priv->state.event->Start, t1, t2,\n                            t3, t4, a1, a2, a3);\n                render_priv->state.parsed_tags |= PARSED_FADE;\n            }\n        } else if (complex_tag(\"org\")) {\n            double v1, v2;\n            if (nargs == 2) {\n                v1 = argtod(args[0]);\n                v2 = argtod(args[1]);\n            } else\n                continue;\n            if (!render_priv->state.have_origin) {\n                render_priv->state.org_x = v1;\n                render_priv->state.org_y = v2;\n                render_priv->state.have_origin = 1;\n                render_priv->state.detect_collisions = 0;\n            }\n        } else if (complex_tag(\"t\")) {\n            double accel;\n            int cnt = nargs - 1;\n            long long t1, t2, t, delta_t;\n            double k;\n            if (cnt == 3) {\n                t1 = argtoll(args[0]);\n                t2 = argtoll(args[1]);\n                accel = argtod(args[2]);\n            } else if (cnt == 2) {\n                t1 = argtoll(args[0]);\n                t2 = argtoll(args[1]);\n                accel = 1.;\n            } else if (cnt == 1) {\n                t1 = 0;\n                t2 = 0;\n                accel = argtod(args[0]);\n            } else if (cnt == 0) {\n                t1 = 0;\n                t2 = 0;\n                accel = 1.;\n            } else\n                continue;\n            render_priv->state.detect_collisions = 0;\n            if (t2 == 0)\n                t2 = render_priv->state.event->Duration;\n            delta_t = t2 - t1;\n            t = render_priv->time - render_priv->state.event->Start;        // FIXME: move to render_context\n            if (t <= t1)\n                k = 0.;\n            else if (t >= t2)\n                k = 1.;\n            else {\n                assert(delta_t != 0.);\n                k = pow(((double) (t - t1)) / delta_t, accel);\n            }\n            p = args[cnt].start;\n            if (args[cnt].end < end) {\n                p = parse_tags(render_priv, p, args[cnt].end, k);\n            } else {\n                assert(q == end);\n                // No other tags can possibly follow this \\t tag,\n                // so we don't need to restore pwr after parsing \\t.\n                // The recursive call is now essentially a tail call,\n                // so optimize it away.\n                pwr = k;\n                q = p;\n            }\n        } else if (complex_tag(\"clip\")) {\n            if (nargs == 4) {\n                int x0, y0, x1, y1;\n                x0 = argtoi(args[0]);\n                y0 = argtoi(args[1]);\n                x1 = argtoi(args[2]);\n                y1 = argtoi(args[3]);\n                render_priv->state.clip_x0 =\n                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;\n                render_priv->state.clip_x1 =\n                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;\n                render_priv->state.clip_y0 =\n                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;\n                render_priv->state.clip_y1 =\n                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;\n                render_priv->state.clip_mode = 0;\n            } else if (!render_priv->state.clip_drawing) {\n                if (parse_vector_clip(render_priv, args, nargs))\n                    render_priv->state.clip_drawing_mode = 0;\n            }\n        } else if (tag(\"c\") || tag(\"1c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[0], val, pwr);\n            } else\n                change_color(&render_priv->state.c[0],\n                             render_priv->state.style->PrimaryColour, 1);\n        } else if (tag(\"2c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[1], val, pwr);\n            } else\n                change_color(&render_priv->state.c[1],\n                             render_priv->state.style->SecondaryColour, 1);\n        } else if (tag(\"3c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[2], val, pwr);\n            } else\n                change_color(&render_priv->state.c[2],\n                             render_priv->state.style->OutlineColour, 1);\n        } else if (tag(\"4c\")) {\n            if (nargs) {\n                uint32_t val = parse_color_tag(args->start);\n                change_color(&render_priv->state.c[3], val, pwr);\n            } else\n                change_color(&render_priv->state.c[3],\n                             render_priv->state.style->BackColour, 1);\n        } else if (tag(\"1a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[0], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[0],\n                             _a(render_priv->state.style->PrimaryColour), 1);\n        } else if (tag(\"2a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[1], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[1],\n                             _a(render_priv->state.style->SecondaryColour), 1);\n        } else if (tag(\"3a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[2], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[2],\n                             _a(render_priv->state.style->OutlineColour), 1);\n        } else if (tag(\"4a\")) {\n            if (nargs) {\n                uint32_t val = parse_alpha_tag(args->start);\n                change_alpha(&render_priv->state.c[3], val, pwr);\n            } else\n                change_alpha(&render_priv->state.c[3],\n                             _a(render_priv->state.style->BackColour), 1);\n        } else if (tag(\"r\")) {\n            if (nargs) {\n                int len = args->end - args->start;\n                reset_render_context(render_priv,\n                        lookup_style_strict(render_priv->track, args->start, len));\n            } else\n                reset_render_context(render_priv, NULL);\n        } else if (tag(\"be\")) {\n            double dval;\n            if (nargs) {\n                int val;\n                dval = argtod(*args);\n                // VSFilter always adds +0.5, even if the value is negative\n                val = (int) (render_priv->state.be * (1 - pwr) + dval * pwr + 0.5);\n                // Clamp to a safe upper limit, since high values need excessive CPU\n                val = (val < 0) ? 0 : val;\n                val = (val > MAX_BE) ? MAX_BE : val;\n                render_priv->state.be = val;\n            } else\n                render_priv->state.be = 0;\n        } else if (tag(\"b\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1 || val >= 100))\n                val = render_priv->state.style->Bold;\n            render_priv->state.bold = val;\n            update_font(render_priv);\n        } else if (tag(\"i\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->Italic;\n            render_priv->state.italic = val;\n            update_font(render_priv);\n        } else if (tag(\"kf\") || tag(\"K\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE_KF;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"ko\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE_KO;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"k\")) {\n            double val = 100;\n            if (nargs)\n                val = argtod(*args);\n            render_priv->state.effect_type = EF_KARAOKE;\n            if (render_priv->state.effect_timing)\n                render_priv->state.effect_skip_timing +=\n                    render_priv->state.effect_timing;\n            render_priv->state.effect_timing = val * 10;\n        } else if (tag(\"shad\")) {\n            double val, xval, yval;\n            if (nargs) {\n                val = argtod(*args);\n                xval = render_priv->state.shadow_x * (1 - pwr) + val * pwr;\n                yval = render_priv->state.shadow_y * (1 - pwr) + val * pwr;\n                // VSFilter compatibility: clip for \\shad but not for \\[xy]shad\n                xval = (xval < 0) ? 0 : xval;\n                yval = (yval < 0) ? 0 : yval;\n            } else\n                xval = yval = render_priv->state.style->Shadow;\n            render_priv->state.shadow_x = xval;\n            render_priv->state.shadow_y = yval;\n        } else if (tag(\"s\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->StrikeOut;\n            if (val)\n                render_priv->state.flags |= DECO_STRIKETHROUGH;\n            else\n                render_priv->state.flags &= ~DECO_STRIKETHROUGH;\n        } else if (tag(\"u\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val == 0 || val == 1))\n                val = render_priv->state.style->Underline;\n            if (val)\n                render_priv->state.flags |= DECO_UNDERLINE;\n            else\n                render_priv->state.flags &= ~DECO_UNDERLINE;\n        } else if (tag(\"pbo\")) {\n            double val = argtod(*args);\n            render_priv->state.pbo = val;\n        } else if (tag(\"p\")) {\n            int val = argtoi(*args);\n            val = (val < 0) ? 0 : val;\n            render_priv->state.drawing_scale = val;\n        } else if (tag(\"q\")) {\n            int val = argtoi(*args);\n            if (!nargs || !(val >= 0 && val <= 3))\n                val = render_priv->track->WrapStyle;\n            render_priv->state.wrap_style = val;\n        } else if (tag(\"fe\")) {\n            int val;\n            if (nargs)\n                val = argtoi(*args);\n            else\n                val = render_priv->state.style->Encoding;\n            render_priv->state.font_encoding = val;\n        }\n    }\n\n    return p;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -418,7 +418,17 @@\n                 k = pow(((double) (t - t1)) / delta_t, accel);\n             }\n             p = args[cnt].start;\n-            p = parse_tags(render_priv, p, args[cnt].end, k);    // maybe k*pwr ? no, specs forbid nested \\t's\n+            if (args[cnt].end < end) {\n+                p = parse_tags(render_priv, p, args[cnt].end, k);\n+            } else {\n+                assert(q == end);\n+                // No other tags can possibly follow this \\t tag,\n+                // so we don't need to restore pwr after parsing \\t.\n+                // The recursive call is now essentially a tail call,\n+                // so optimize it away.\n+                pwr = k;\n+                q = p;\n+            }\n         } else if (complex_tag(\"clip\")) {\n             if (nargs == 4) {\n                 int x0, y0, x1, y1;",
        "diff_line_info": {
            "deleted_lines": [
                "            p = parse_tags(render_priv, p, args[cnt].end, k);    // maybe k*pwr ? no, specs forbid nested \\t's"
            ],
            "added_lines": [
                "            if (args[cnt].end < end) {",
                "                p = parse_tags(render_priv, p, args[cnt].end, k);",
                "            } else {",
                "                assert(q == end);",
                "                // No other tags can possibly follow this \\t tag,",
                "                // so we don't need to restore pwr after parsing \\t.",
                "                // The recursive call is now essentially a tail call,",
                "                // so optimize it away.",
                "                pwr = k;",
                "                q = p;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48064",
        "func_name": "binutils-gdb/find_debug_info",
        "description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=8f2c64de86bc3d7556121fe296dd679000283931",
        "commit_title": "",
        "commit_text": "PR29922, SHT_NOBITS section avoids section size sanity check  \tPR 29922 \t* dwarf2.c (find_debug_info): Ignore sections without \tSEC_HAS_CONTENTS. ",
        "func_before": "static asection *\nfind_debug_info (bfd *abfd, const struct dwarf_debug_section *debug_sections,\n\t\t asection *after_sec)\n{\n  asection *msec;\n  const char *look;\n\n  if (after_sec == NULL)\n    {\n      look = debug_sections[debug_info].uncompressed_name;\n      msec = bfd_get_section_by_name (abfd, look);\n      if (msec != NULL)\n\treturn msec;\n\n      look = debug_sections[debug_info].compressed_name;\n      msec = bfd_get_section_by_name (abfd, look);\n      if (msec != NULL)\n        return msec;\n\n      for (msec = abfd->sections; msec != NULL; msec = msec->next)\n\tif (startswith (msec->name, GNU_LINKONCE_INFO))\n\t  return msec;\n\n      return NULL;\n    }\n\n  for (msec = after_sec->next; msec != NULL; msec = msec->next)\n    {\n      look = debug_sections[debug_info].uncompressed_name;\n      if (strcmp (msec->name, look) == 0)\n\treturn msec;\n\n      look = debug_sections[debug_info].compressed_name;\n      if (look != NULL && strcmp (msec->name, look) == 0)\n\treturn msec;\n\n      if (startswith (msec->name, GNU_LINKONCE_INFO))\n\treturn msec;\n    }\n\n  return NULL;\n}",
        "func": "static asection *\nfind_debug_info (bfd *abfd, const struct dwarf_debug_section *debug_sections,\n\t\t asection *after_sec)\n{\n  asection *msec;\n  const char *look;\n\n  if (after_sec == NULL)\n    {\n      look = debug_sections[debug_info].uncompressed_name;\n      msec = bfd_get_section_by_name (abfd, look);\n      /* Testing SEC_HAS_CONTENTS is an anti-fuzzer measure.  Of\n\t course debug sections always have contents.  */\n      if (msec != NULL && (msec->flags & SEC_HAS_CONTENTS) != 0)\n\treturn msec;\n\n      look = debug_sections[debug_info].compressed_name;\n      msec = bfd_get_section_by_name (abfd, look);\n      if (msec != NULL && (msec->flags & SEC_HAS_CONTENTS) != 0)\n        return msec;\n\n      for (msec = abfd->sections; msec != NULL; msec = msec->next)\n\tif ((msec->flags & SEC_HAS_CONTENTS) != 0\n\t    && startswith (msec->name, GNU_LINKONCE_INFO))\n\t  return msec;\n\n      return NULL;\n    }\n\n  for (msec = after_sec->next; msec != NULL; msec = msec->next)\n    {\n      if ((msec->flags & SEC_HAS_CONTENTS) == 0)\n\tcontinue;\n\n      look = debug_sections[debug_info].uncompressed_name;\n      if (strcmp (msec->name, look) == 0)\n\treturn msec;\n\n      look = debug_sections[debug_info].compressed_name;\n      if (look != NULL && strcmp (msec->name, look) == 0)\n\treturn msec;\n\n      if (startswith (msec->name, GNU_LINKONCE_INFO))\n\treturn msec;\n    }\n\n  return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,16 +9,19 @@\n     {\n       look = debug_sections[debug_info].uncompressed_name;\n       msec = bfd_get_section_by_name (abfd, look);\n-      if (msec != NULL)\n+      /* Testing SEC_HAS_CONTENTS is an anti-fuzzer measure.  Of\n+\t course debug sections always have contents.  */\n+      if (msec != NULL && (msec->flags & SEC_HAS_CONTENTS) != 0)\n \treturn msec;\n \n       look = debug_sections[debug_info].compressed_name;\n       msec = bfd_get_section_by_name (abfd, look);\n-      if (msec != NULL)\n+      if (msec != NULL && (msec->flags & SEC_HAS_CONTENTS) != 0)\n         return msec;\n \n       for (msec = abfd->sections; msec != NULL; msec = msec->next)\n-\tif (startswith (msec->name, GNU_LINKONCE_INFO))\n+\tif ((msec->flags & SEC_HAS_CONTENTS) != 0\n+\t    && startswith (msec->name, GNU_LINKONCE_INFO))\n \t  return msec;\n \n       return NULL;\n@@ -26,6 +29,9 @@\n \n   for (msec = after_sec->next; msec != NULL; msec = msec->next)\n     {\n+      if ((msec->flags & SEC_HAS_CONTENTS) == 0)\n+\tcontinue;\n+\n       look = debug_sections[debug_info].uncompressed_name;\n       if (strcmp (msec->name, look) == 0)\n \treturn msec;",
        "diff_line_info": {
            "deleted_lines": [
                "      if (msec != NULL)",
                "      if (msec != NULL)",
                "\tif (startswith (msec->name, GNU_LINKONCE_INFO))"
            ],
            "added_lines": [
                "      /* Testing SEC_HAS_CONTENTS is an anti-fuzzer measure.  Of",
                "\t course debug sections always have contents.  */",
                "      if (msec != NULL && (msec->flags & SEC_HAS_CONTENTS) != 0)",
                "      if (msec != NULL && (msec->flags & SEC_HAS_CONTENTS) != 0)",
                "\tif ((msec->flags & SEC_HAS_CONTENTS) != 0",
                "\t    && startswith (msec->name, GNU_LINKONCE_INFO))",
                "      if ((msec->flags & SEC_HAS_CONTENTS) == 0)",
                "\tcontinue;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9251",
        "func_name": "GNOME/libxml2/xz_head",
        "description": "The xz_decomp function in xzlib.c in libxml2 2.9.8, if --with-lzma is used, allows remote attackers to cause a denial of service (infinite loop) via a crafted XML file that triggers LZMA_MEMLIMIT_ERROR, as demonstrated by xmllint, a different vulnerability than CVE-2015-8035.",
        "git_url": "https://github.com/GNOME/libxml2/commit/e2a9122b8dde53d320750451e9907a7dcb2ca8bb",
        "commit_title": "Set memory limit for LZMA decompression",
        "commit_text": " Otherwise malicious LZMA compressed files could consume large amounts of memory when decompressed.  According to the xz man page, files compressed with `xz -9` currently require 65 MB to decompress, so set the limit to 100 MB.  Should fix bug 786696.",
        "func_before": "static int\nxz_head(xz_statep state)\n{\n    lzma_stream *strm = &(state->strm);\n    lzma_stream init = LZMA_STREAM_INIT;\n    int flags;\n    unsigned len;\n\n    /* allocate read buffers and inflate memory */\n    if (state->size == 0) {\n        /* allocate buffers */\n        state->in = xmlMalloc(state->want);\n        state->out = xmlMalloc(state->want << 1);\n        if (state->in == NULL || state->out == NULL) {\n            if (state->out != NULL)\n                xmlFree(state->out);\n            if (state->in != NULL)\n                xmlFree(state->in);\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        state->size = state->want;\n\n        /* allocate decoder memory */\n        state->strm = init;\n        state->strm.avail_in = 0;\n        state->strm.next_in = NULL;\n        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {\n            xmlFree(state->out);\n            xmlFree(state->in);\n            state->size = 0;\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n#ifdef HAVE_ZLIB_H\n        /* allocate inflate memory */\n        state->zstrm.zalloc = Z_NULL;\n        state->zstrm.zfree = Z_NULL;\n        state->zstrm.opaque = Z_NULL;\n        state->zstrm.avail_in = 0;\n        state->zstrm.next_in = Z_NULL;\n        if (state->init == 0) {\n            if (inflateInit2(&(state->zstrm), -15) != Z_OK) {/* raw inflate */\n                xmlFree(state->out);\n                xmlFree(state->in);\n                state->size = 0;\n                xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n                return -1;\n            }\n            state->init = 1;\n        }\n#endif\n    }\n\n    /* get some data in the input buffer */\n    if (strm->avail_in == 0) {\n        if (xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0)\n            return 0;\n    }\n\n    /* look for the xz magic header bytes */\n    if (is_format_xz(state) || is_format_lzma(state)) {\n        state->how = LZMA;\n        state->direct = 0;\n        return 0;\n    }\n#ifdef HAVE_ZLIB_H\n    /* look for the gzip magic header bytes 31 and 139 */\n    if (strm->next_in[0] == 31) {\n        strm->avail_in--;\n        strm->next_in++;\n        if (strm->avail_in == 0 && xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in && strm->next_in[0] == 139) {\n            /* we have a gzip header, woo hoo! */\n            strm->avail_in--;\n            strm->next_in++;\n\n            /* skip rest of header */\n            if (NEXT() != 8) {  /* compression method */\n                xz_error(state, LZMA_DATA_ERROR,\n                         \"unknown compression method\");\n                return -1;\n            }\n            flags = NEXT();\n            if (flags & 0xe0) { /* reserved flag bits */\n                xz_error(state, LZMA_DATA_ERROR,\n                         \"unknown header flags set\");\n                return -1;\n            }\n            NEXT();             /* modification time */\n            NEXT();\n            NEXT();\n            NEXT();\n            NEXT();             /* extra flags */\n            NEXT();             /* operating system */\n            if (flags & 4) {    /* extra field */\n                len = (unsigned) NEXT();\n                len += (unsigned) NEXT() << 8;\n                while (len--)\n                    if (NEXT() < 0)\n                        break;\n            }\n            if (flags & 8)      /* file name */\n                while (NEXT() > 0) ;\n            if (flags & 16)     /* comment */\n                while (NEXT() > 0) ;\n            if (flags & 2) {    /* header crc */\n                NEXT();\n                NEXT();\n            }\n            /* an unexpected end of file is not checked for here -- it will be\n             * noticed on the first request for uncompressed data */\n\n            /* set up for decompression */\n            inflateReset(&state->zstrm);\n            state->zstrm.adler = crc32(0L, Z_NULL, 0);\n            state->how = GZIP;\n            state->direct = 0;\n            return 0;\n        } else {\n            /* not a gzip file -- save first byte (31) and fall to raw i/o */\n            state->out[0] = 31;\n            state->have = 1;\n        }\n    }\n#endif\n\n    /* doing raw i/o, save start of raw data for seeking, copy any leftover\n     * input to output -- this assumes that the output buffer is larger than\n     * the input buffer, which also assures space for gzungetc() */\n    state->raw = state->pos;\n    state->next = state->out;\n    if (strm->avail_in) {\n        memcpy(state->next + state->have, strm->next_in, strm->avail_in);\n        state->have += strm->avail_in;\n        strm->avail_in = 0;\n    }\n    state->how = COPY;\n    state->direct = 1;\n    return 0;\n}",
        "func": "static int\nxz_head(xz_statep state)\n{\n    lzma_stream *strm = &(state->strm);\n    lzma_stream init = LZMA_STREAM_INIT;\n    int flags;\n    unsigned len;\n\n    /* allocate read buffers and inflate memory */\n    if (state->size == 0) {\n        /* allocate buffers */\n        state->in = xmlMalloc(state->want);\n        state->out = xmlMalloc(state->want << 1);\n        if (state->in == NULL || state->out == NULL) {\n            if (state->out != NULL)\n                xmlFree(state->out);\n            if (state->in != NULL)\n                xmlFree(state->in);\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        state->size = state->want;\n\n        /* allocate decoder memory */\n        state->strm = init;\n        state->strm.avail_in = 0;\n        state->strm.next_in = NULL;\n        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {\n            xmlFree(state->out);\n            xmlFree(state->in);\n            state->size = 0;\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n#ifdef HAVE_ZLIB_H\n        /* allocate inflate memory */\n        state->zstrm.zalloc = Z_NULL;\n        state->zstrm.zfree = Z_NULL;\n        state->zstrm.opaque = Z_NULL;\n        state->zstrm.avail_in = 0;\n        state->zstrm.next_in = Z_NULL;\n        if (state->init == 0) {\n            if (inflateInit2(&(state->zstrm), -15) != Z_OK) {/* raw inflate */\n                xmlFree(state->out);\n                xmlFree(state->in);\n                state->size = 0;\n                xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n                return -1;\n            }\n            state->init = 1;\n        }\n#endif\n    }\n\n    /* get some data in the input buffer */\n    if (strm->avail_in == 0) {\n        if (xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0)\n            return 0;\n    }\n\n    /* look for the xz magic header bytes */\n    if (is_format_xz(state) || is_format_lzma(state)) {\n        state->how = LZMA;\n        state->direct = 0;\n        return 0;\n    }\n#ifdef HAVE_ZLIB_H\n    /* look for the gzip magic header bytes 31 and 139 */\n    if (strm->next_in[0] == 31) {\n        strm->avail_in--;\n        strm->next_in++;\n        if (strm->avail_in == 0 && xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in && strm->next_in[0] == 139) {\n            /* we have a gzip header, woo hoo! */\n            strm->avail_in--;\n            strm->next_in++;\n\n            /* skip rest of header */\n            if (NEXT() != 8) {  /* compression method */\n                xz_error(state, LZMA_DATA_ERROR,\n                         \"unknown compression method\");\n                return -1;\n            }\n            flags = NEXT();\n            if (flags & 0xe0) { /* reserved flag bits */\n                xz_error(state, LZMA_DATA_ERROR,\n                         \"unknown header flags set\");\n                return -1;\n            }\n            NEXT();             /* modification time */\n            NEXT();\n            NEXT();\n            NEXT();\n            NEXT();             /* extra flags */\n            NEXT();             /* operating system */\n            if (flags & 4) {    /* extra field */\n                len = (unsigned) NEXT();\n                len += (unsigned) NEXT() << 8;\n                while (len--)\n                    if (NEXT() < 0)\n                        break;\n            }\n            if (flags & 8)      /* file name */\n                while (NEXT() > 0) ;\n            if (flags & 16)     /* comment */\n                while (NEXT() > 0) ;\n            if (flags & 2) {    /* header crc */\n                NEXT();\n                NEXT();\n            }\n            /* an unexpected end of file is not checked for here -- it will be\n             * noticed on the first request for uncompressed data */\n\n            /* set up for decompression */\n            inflateReset(&state->zstrm);\n            state->zstrm.adler = crc32(0L, Z_NULL, 0);\n            state->how = GZIP;\n            state->direct = 0;\n            return 0;\n        } else {\n            /* not a gzip file -- save first byte (31) and fall to raw i/o */\n            state->out[0] = 31;\n            state->have = 1;\n        }\n    }\n#endif\n\n    /* doing raw i/o, save start of raw data for seeking, copy any leftover\n     * input to output -- this assumes that the output buffer is larger than\n     * the input buffer, which also assures space for gzungetc() */\n    state->raw = state->pos;\n    state->next = state->out;\n    if (strm->avail_in) {\n        memcpy(state->next + state->have, strm->next_in, strm->avail_in);\n        state->have += strm->avail_in;\n        strm->avail_in = 0;\n    }\n    state->how = COPY;\n    state->direct = 1;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n         state->strm = init;\n         state->strm.avail_in = 0;\n         state->strm.next_in = NULL;\n-        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {\n+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {\n             xmlFree(state->out);\n             xmlFree(state->in);\n             state->size = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {"
            ],
            "added_lines": [
                "        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-13114",
        "func_name": "libexif/exif_mnote_data_canon_load",
        "description": "An issue was discovered in libexif before 0.6.22. An unrestricted size in handling Canon EXIF MakerNote data could lead to consumption of large amounts of compute time for decoding EXIF data.",
        "git_url": "https://github.com/libexif/libexif/commit/e6a38a1a23ba94d139b1fa2cd4519fdcfe3c9bab",
        "commit_title": "Add a failsafe on the maximum number of Canon MakerNote subtags.",
        "commit_text": " A malicious file could be crafted to cause extremely large values in some tags without tripping any buffer range checks.  This is bad with the libexif representation of Canon MakerNotes because some arrays are turned into individual tags that the application must loop around.  The largest value I've seen for failsafe_size in a (very small) sample of valid Canon files is <5000.  The limit is set two orders of magnitude larger to avoid tripping up falsely in case some models use much larger values.  Patch from Google.  CVE-2020-13114",
        "func_before": "static void\nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_canon_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse the entries */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tmemset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}",
        "func": "static void\nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\tlong failsafe_size = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_canon_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse the entries */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tmemset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Track the size of decoded tag data. A malicious file could\n\t\t * be crafted to cause extremely large values here without\n\t\t * tripping any buffer range checks.  This is especially bad\n\t\t * with the libexif representation of Canon MakerNotes because\n\t\t * some arrays are turned into individual tags that the\n\t\t * application must loop around. */\n\t\tfailsafe_size += mnote_canon_entry_count_values(&n->entries[tcount]);\n\n\t\tif (failsafe_size > FAILSAFE_SIZE_MAX) {\n\t\t\t/* Abort if the total size of the data in the tags extraordinarily large, */\n\t\t\texif_mem_free (ne->mem, n->entries[tcount].data);\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\t  \"ExifMnoteCanon\", \"Failsafe tag size overflow (%lu > %ld)\",\n\t\t\t\t\t  failsafe_size, FAILSAFE_SIZE_MAX);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,7 @@\n \tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n \tExifShort c;\n \tsize_t i, tcount, o, datao;\n+\tlong failsafe_size = 0;\n \n \tif (!n || !buf || !buf_size) {\n \t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n@@ -96,6 +97,23 @@\n \t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n \t\t}\n \n+\t\t/* Track the size of decoded tag data. A malicious file could\n+\t\t * be crafted to cause extremely large values here without\n+\t\t * tripping any buffer range checks.  This is especially bad\n+\t\t * with the libexif representation of Canon MakerNotes because\n+\t\t * some arrays are turned into individual tags that the\n+\t\t * application must loop around. */\n+\t\tfailsafe_size += mnote_canon_entry_count_values(&n->entries[tcount]);\n+\n+\t\tif (failsafe_size > FAILSAFE_SIZE_MAX) {\n+\t\t\t/* Abort if the total size of the data in the tags extraordinarily large, */\n+\t\t\texif_mem_free (ne->mem, n->entries[tcount].data);\n+\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n+\t\t\t\t\t  \"ExifMnoteCanon\", \"Failsafe tag size overflow (%lu > %ld)\",\n+\t\t\t\t\t  failsafe_size, FAILSAFE_SIZE_MAX);\n+\t\t\tbreak;\n+\t\t}\n+\n \t\t/* Tag was successfully parsed */\n \t\t++tcount;\n \t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tlong failsafe_size = 0;",
                "\t\t/* Track the size of decoded tag data. A malicious file could",
                "\t\t * be crafted to cause extremely large values here without",
                "\t\t * tripping any buffer range checks.  This is especially bad",
                "\t\t * with the libexif representation of Canon MakerNotes because",
                "\t\t * some arrays are turned into individual tags that the",
                "\t\t * application must loop around. */",
                "\t\tfailsafe_size += mnote_canon_entry_count_values(&n->entries[tcount]);",
                "",
                "\t\tif (failsafe_size > FAILSAFE_SIZE_MAX) {",
                "\t\t\t/* Abort if the total size of the data in the tags extraordinarily large, */",
                "\t\t\texif_mem_free (ne->mem, n->entries[tcount].data);",
                "\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,",
                "\t\t\t\t\t  \"ExifMnoteCanon\", \"Failsafe tag size overflow (%lu > %ld)\",",
                "\t\t\t\t\t  failsafe_size, FAILSAFE_SIZE_MAX);",
                "\t\t\tbreak;",
                "\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14405",
        "func_name": "LibVNC/libvncserver/HandleRFBServerMessage",
        "description": "An issue was discovered in LibVNCServer before 0.9.13. libvncclient/rfbproto.c does not limit TextChat size.",
        "git_url": "https://github.com/LibVNC/libvncserver/commit/8937203441ee241c4ace85da687b7d6633a12365",
        "commit_title": "libvncclient/rfbproto: limit max textchat size",
        "commit_text": " Addresses GitHub Security Lab (GHSL) Vulnerability Report `GHSL-2020-063`.  Re #275",
        "func_before": "rfbBool\nHandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc(msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}",
        "func": "rfbBool\nHandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc(msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n\t  if(msg.tc.length > MAX_TEXTCHAT_SIZE)\n\t      return FALSE;\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -556,6 +556,8 @@\n               client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n           break;\n       default:\n+\t  if(msg.tc.length > MAX_TEXTCHAT_SIZE)\n+\t      return FALSE;\n           buffer=malloc(msg.tc.length+1);\n           if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n           {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t  if(msg.tc.length > MAX_TEXTCHAT_SIZE)",
                "\t      return FALSE;"
            ]
        }
    }
]