[
    {
        "cve_id": "CVE-2022-25299",
        "func_name": "cesanta/mongoose/mg_http_upload",
        "description": "This affects the package cesanta/mongoose before 7.6. The unsafe handling of file names during upload using mg_http_upload() method may enable attackers to write files to arbitrary locations outside the designated target folder.",
        "git_url": "https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
        "commit_title": "Protect against the directory traversal in mg_upload()",
        "commit_text": "",
        "func_before": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}",
        "func": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,12 +8,12 @@\n     return -1;\n   } else {\n     FILE *fp;\n-    size_t oft = strtoul(offset, NULL, 0);\n+    long oft = strtol(offset, NULL, 0);\n     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n-    LOG(LL_DEBUG,\n-        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n+    remove_double_dots(path);\n+    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n-      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n+      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n       return -2;\n     } else {\n       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
        "diff_line_info": {
            "deleted_lines": [
                "    size_t oft = strtoul(offset, NULL, 0);",
                "    LOG(LL_DEBUG,",
                "        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
                "      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);"
            ],
            "added_lines": [
                "    long oft = strtol(offset, NULL, 0);",
                "    remove_double_dots(path);",
                "    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
                "      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25299",
        "func_name": "cesanta/mongoose/mg_http_upload",
        "description": "This affects the package cesanta/mongoose before 7.6. The unsafe handling of file names during upload using mg_http_upload() method may enable attackers to write files to arbitrary locations outside the designated target folder.",
        "git_url": "https://github.com/cesanta/mongoose/commit/c65c8fdaaa257e0487ab0aaae9e8f6b439335945",
        "commit_title": "Protect against the directory traversal in mg_upload()",
        "commit_text": "",
        "func_before": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}",
        "func": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,12 +8,12 @@\n     return -1;\n   } else {\n     FILE *fp;\n-    size_t oft = strtoul(offset, NULL, 0);\n+    long oft = strtol(offset, NULL, 0);\n     snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n-    LOG(LL_DEBUG,\n-        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n+    remove_double_dots(path);\n+    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n     if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n-      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n+      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n       return -2;\n     } else {\n       fwrite(hm->body.ptr, 1, hm->body.len, fp);",
        "diff_line_info": {
            "deleted_lines": [
                "    size_t oft = strtoul(offset, NULL, 0);",
                "    LOG(LL_DEBUG,",
                "        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));",
                "      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);"
            ],
            "added_lines": [
                "    long oft = strtol(offset, NULL, 0);",
                "    remove_double_dots(path);",
                "    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));",
                "      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3995",
        "func_name": "util-linux/is_fuse_usermount",
        "description": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.",
        "git_url": "https://github.com/util-linux/util-linux/commit/57202f5713afa2af20ffbb6ab5331481d0396f8d",
        "commit_title": "libmount: fix UID check for FUSE umount [CVE-2021-3995]",
        "commit_text": " Improper UID check allows an unprivileged user to unmount FUSE filesystems of users with similar UID. ",
        "func_before": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\n\t*errsv = 0;\n\n\tif (!type)\n\t\treturn 0;\n\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\n\t/* get user_id= from mount table */\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\n\t/* get current user */\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tuid = getuid();\n\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}",
        "func": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tuid_t uid, entry_uid;\n\n\t*errsv = 0;\n\n\tif (!type)\n\t\treturn 0;\n\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\n\t/* get user_id= from mount table */\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_uid(optstr, \"user_id\", &entry_uid) != 0)\n\t\treturn 0;\n\n\t/* get current user */\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tuid = getuid();\n\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\treturn uid == entry_uid;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,7 @@\n \tstruct libmnt_ns *ns_old;\n \tconst char *type = mnt_fs_get_fstype(cxt->fs);\n \tconst char *optstr;\n-\tchar *user_id = NULL;\n-\tsize_t sz;\n-\tuid_t uid;\n-\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n+\tuid_t uid, entry_uid;\n \n \t*errsv = 0;\n \n@@ -23,11 +20,7 @@\n \toptstr = mnt_fs_get_fs_options(cxt->fs);\n \tif (!optstr)\n \t\treturn 0;\n-\n-\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n-\t\treturn 0;\n-\n-\tif (sz == 0 || user_id == NULL)\n+\tif (mnt_optstr_get_uid(optstr, \"user_id\", &entry_uid) != 0)\n \t\treturn 0;\n \n \t/* get current user */\n@@ -44,6 +37,5 @@\n \t\treturn 0;\n \t}\n \n-\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n-\treturn strncmp(user_id, uidstr, sz) == 0;\n+\treturn uid == entry_uid;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar *user_id = NULL;",
                "\tsize_t sz;",
                "\tuid_t uid;",
                "\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];",
                "",
                "\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)",
                "\t\treturn 0;",
                "",
                "\tif (sz == 0 || user_id == NULL)",
                "\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);",
                "\treturn strncmp(user_id, uidstr, sz) == 0;"
            ],
            "added_lines": [
                "\tuid_t uid, entry_uid;",
                "\tif (mnt_optstr_get_uid(optstr, \"user_id\", &entry_uid) != 0)",
                "\treturn uid == entry_uid;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3996",
        "func_name": "util-linux/mnt_parse_mountinfo_line",
        "description": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.",
        "git_url": "https://github.com/util-linux/util-linux/commit/166e87368ae88bf31112a30e078cceae637f4cdb",
        "commit_title": "libmount: remove support for deleted mount table entries",
        "commit_text": " The \"(deleted)\" suffix has been originally used by kernel for deleted mountpoints. Since kernel commit 9d4d65748a5ca26ea8650e50ba521295549bf4e3 (Dec 2014) kernel does not use this suffix for mount stuff in /proc at all. Let's remove this support from libmount too. ",
        "func_before": "static int mnt_parse_mountinfo_line(struct libmnt_fs *fs, const char *s)\n{\n\tint rc = 0;\n\tunsigned int maj, min;\n\tchar *p;\n\n\tfs->flags |= MNT_FS_KERNEL;\n\n\t/* (1) id */\n\ts = next_s32(s, &fs->id, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [id]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (2) parent */\n\ts = next_s32(s, &fs->parent, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [parent]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (3) maj:min */\n\tif (sscanf(s, \"%u:%u\", &maj, &min) != 2) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [maj:min]\"));\n\t\tgoto fail;\n\t}\n\tfs->devno = makedev(maj, min);\n\ts = skip_nonspearator(s);\n\ts = skip_separator(s);\n\n\t/* (4) mountroot */\n\tfs->root = unmangle(s, &s);\n\tif (!fs->root) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [mountroot]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (5) target */\n\tfs->target = unmangle(s, &s);\n\tif (!fs->target) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [target]\"));\n\t\tgoto fail;\n\t}\n\n\t/* remove \"\\040(deleted)\" suffix */\n\tp = (char *) endswith(fs->target, PATH_DELETED_SUFFIX);\n\tif (p && *p) {\n\t\t*p = '\\0';\n\t\tfs->flags |= MNT_FS_DELETED;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (6) vfs options (fs-independent) */\n\tfs->vfs_optstr = unmangle(s, &s);\n\tif (!fs->vfs_optstr) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [VFS options]\"));\n\t\tgoto fail;\n\t}\n\n\t/* (7) optional fields, terminated by \" - \" */\n\tp = strstr(s, \" - \");\n\tif (!p) {\n\t\tDBG(TAB, ul_debug(\"mountinfo parse error: separator not found\"));\n\t\treturn -EINVAL;\n\t}\n\tif (p > s + 1)\n\t\tfs->opt_fields = strndup(s + 1, p - s - 1);\n\n\ts = skip_separator(p + 3);\n\n\t/* (8) FS type */\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_fstype_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [fstype]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\t/* (9) source -- maybe empty string */\n\tif (!s || !*s) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [source]\"));\n\t\tgoto fail;\n\t} else if (*s == ' ' && *(s+1) == ' ') {\n\t\tif ((rc = mnt_fs_set_source(fs, \"\"))) {\n\t\t\tDBG(TAB, ul_debug(\"tab parse error: [empty source]\"));\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\ts = skip_separator(s);\n\t\tp = unmangle(s, &s);\n\t\tif (!p || (rc = __mnt_fs_set_source_ptr(fs, p))) {\n\t\t\tDBG(TAB, ul_debug(\"tab parse error: [regular source]\"));\n\t\t\tfree(p);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (10) fs options (fs specific) */\n\tfs->fs_optstr = unmangle(s, &s);\n\tif (!fs->fs_optstr) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [FS options]\"));\n\t\tgoto fail;\n\t}\n\n\t/* merge VFS and FS options to one string */\n\tfs->optstr = mnt_fs_strdup_options(fs);\n\tif (!fs->optstr) {\n\t\trc = -ENOMEM;\n\t\tDBG(TAB, ul_debug(\"tab parse error: [merge VFS and FS options]\"));\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tif (rc == 0)\n\t\trc = -EINVAL;\n\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n\treturn rc;\n}",
        "func": "static int mnt_parse_mountinfo_line(struct libmnt_fs *fs, const char *s)\n{\n\tint rc = 0;\n\tunsigned int maj, min;\n\tchar *p;\n\n\tfs->flags |= MNT_FS_KERNEL;\n\n\t/* (1) id */\n\ts = next_s32(s, &fs->id, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [id]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (2) parent */\n\ts = next_s32(s, &fs->parent, &rc);\n\tif (!s || !*s || rc) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [parent]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (3) maj:min */\n\tif (sscanf(s, \"%u:%u\", &maj, &min) != 2) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [maj:min]\"));\n\t\tgoto fail;\n\t}\n\tfs->devno = makedev(maj, min);\n\ts = skip_nonspearator(s);\n\ts = skip_separator(s);\n\n\t/* (4) mountroot */\n\tfs->root = unmangle(s, &s);\n\tif (!fs->root) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [mountroot]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (5) target */\n\tfs->target = unmangle(s, &s);\n\tif (!fs->target) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [target]\"));\n\t\tgoto fail;\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (6) vfs options (fs-independent) */\n\tfs->vfs_optstr = unmangle(s, &s);\n\tif (!fs->vfs_optstr) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [VFS options]\"));\n\t\tgoto fail;\n\t}\n\n\t/* (7) optional fields, terminated by \" - \" */\n\tp = strstr(s, \" - \");\n\tif (!p) {\n\t\tDBG(TAB, ul_debug(\"mountinfo parse error: separator not found\"));\n\t\treturn -EINVAL;\n\t}\n\tif (p > s + 1)\n\t\tfs->opt_fields = strndup(s + 1, p - s - 1);\n\n\ts = skip_separator(p + 3);\n\n\t/* (8) FS type */\n\tp = unmangle(s, &s);\n\tif (!p || (rc = __mnt_fs_set_fstype_ptr(fs, p))) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [fstype]\"));\n\t\tfree(p);\n\t\tgoto fail;\n\t}\n\n\t/* (9) source -- maybe empty string */\n\tif (!s || !*s) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [source]\"));\n\t\tgoto fail;\n\t} else if (*s == ' ' && *(s+1) == ' ') {\n\t\tif ((rc = mnt_fs_set_source(fs, \"\"))) {\n\t\t\tDBG(TAB, ul_debug(\"tab parse error: [empty source]\"));\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\ts = skip_separator(s);\n\t\tp = unmangle(s, &s);\n\t\tif (!p || (rc = __mnt_fs_set_source_ptr(fs, p))) {\n\t\t\tDBG(TAB, ul_debug(\"tab parse error: [regular source]\"));\n\t\t\tfree(p);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\ts = skip_separator(s);\n\n\t/* (10) fs options (fs specific) */\n\tfs->fs_optstr = unmangle(s, &s);\n\tif (!fs->fs_optstr) {\n\t\tDBG(TAB, ul_debug(\"tab parse error: [FS options]\"));\n\t\tgoto fail;\n\t}\n\n\t/* merge VFS and FS options to one string */\n\tfs->optstr = mnt_fs_strdup_options(fs);\n\tif (!fs->optstr) {\n\t\trc = -ENOMEM;\n\t\tDBG(TAB, ul_debug(\"tab parse error: [merge VFS and FS options]\"));\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tif (rc == 0)\n\t\trc = -EINVAL;\n\tDBG(TAB, ul_debug(\"tab parse error on: '%s' [rc=%d]\", s, rc));\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,13 +47,6 @@\n \tif (!fs->target) {\n \t\tDBG(TAB, ul_debug(\"tab parse error: [target]\"));\n \t\tgoto fail;\n-\t}\n-\n-\t/* remove \"\\040(deleted)\" suffix */\n-\tp = (char *) endswith(fs->target, PATH_DELETED_SUFFIX);\n-\tif (p && *p) {\n-\t\t*p = '\\0';\n-\t\tfs->flags |= MNT_FS_DELETED;\n \t}\n \n \ts = skip_separator(s);",
        "diff_line_info": {
            "deleted_lines": [
                "\t}",
                "",
                "\t/* remove \"\\040(deleted)\" suffix */",
                "\tp = (char *) endswith(fs->target, PATH_DELETED_SUFFIX);",
                "\tif (p && *p) {",
                "\t\t*p = '\\0';",
                "\t\tfs->flags |= MNT_FS_DELETED;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-3996",
        "func_name": "util-linux/main",
        "description": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.",
        "git_url": "https://github.com/util-linux/util-linux/commit/166e87368ae88bf31112a30e078cceae637f4cdb",
        "commit_title": "libmount: remove support for deleted mount table entries",
        "commit_text": " The \"(deleted)\" suffix has been originally used by kernel for deleted mountpoints. Since kernel commit 9d4d65748a5ca26ea8650e50ba521295549bf4e3 (Dec 2014) kernel does not use this suffix for mount stuff in /proc at all. Let's remove this support from libmount too. ",
        "func_before": "int main(int argc, char *argv[])\n{\n\tstruct libmnt_table *tb = NULL;\n\tchar **tabfiles = NULL;\n\tint direction = MNT_ITER_FORWARD;\n\tint verify = 0;\n\tint c, rc = -1, timeout = -1;\n\tint ntabfiles = 0, tabtype = 0;\n\tchar *outarg = NULL;\n\tsize_t i;\n\tint force_tree = 0, istree = 0;\n\n\tstruct libscols_table *table = NULL;\n\n\tenum {\n\t\tFINDMNT_OPT_VERBOSE = CHAR_MAX + 1,\n\t\tFINDMNT_OPT_TREE,\n\t\tFINDMNT_OPT_OUTPUT_ALL,\n\t\tFINDMNT_OPT_PSEUDO,\n\t\tFINDMNT_OPT_REAL,\n\t\tFINDMNT_OPT_VFS_ALL,\n\t\tFINDMNT_OPT_SHADOWED,\n\t\tFINDMNT_OPT_DELETED,\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\",\t    no_argument,       NULL, 'A'\t\t },\n\t\t{ \"ascii\",\t    no_argument,       NULL, 'a'\t\t },\n\t\t{ \"bytes\",\t    no_argument,       NULL, 'b'\t\t },\n\t\t{ \"canonicalize\",   no_argument,       NULL, 'c'\t\t },\n\t\t{ \"deleted\",        no_argument,       NULL, FINDMNT_OPT_DELETED },\n\t\t{ \"direction\",\t    required_argument, NULL, 'd'\t\t },\n\t\t{ \"df\",\t\t    no_argument,       NULL, 'D'\t\t },\n\t\t{ \"evaluate\",\t    no_argument,       NULL, 'e'\t\t },\n\t\t{ \"first-only\",\t    no_argument,       NULL, 'f'\t\t },\n\t\t{ \"fstab\",\t    no_argument,       NULL, 's'\t\t },\n\t\t{ \"help\",\t    no_argument,       NULL, 'h'\t\t },\n\t\t{ \"invert\",\t    no_argument,       NULL, 'i'\t\t },\n\t\t{ \"json\",\t    no_argument,       NULL, 'J'\t\t },\n\t\t{ \"kernel\",\t    no_argument,       NULL, 'k'\t\t },\n\t\t{ \"list\",\t    no_argument,       NULL, 'l'\t\t },\n\t\t{ \"mountpoint\",\t    required_argument, NULL, 'M'\t\t },\n\t\t{ \"mtab\",\t    no_argument,       NULL, 'm'\t\t },\n\t\t{ \"noheadings\",\t    no_argument,       NULL, 'n'\t\t },\n\t\t{ \"notruncate\",\t    no_argument,       NULL, 'u'\t\t },\n\t\t{ \"options\",\t    required_argument, NULL, 'O'\t\t },\n\t\t{ \"output\",\t    required_argument, NULL, 'o'\t\t },\n\t\t{ \"output-all\",\t    no_argument,       NULL, FINDMNT_OPT_OUTPUT_ALL },\n\t\t{ \"poll\",\t    optional_argument, NULL, 'p'\t\t },\n\t\t{ \"pairs\",\t    no_argument,       NULL, 'P'\t\t },\n\t\t{ \"raw\",\t    no_argument,       NULL, 'r'\t\t },\n\t\t{ \"types\",\t    required_argument, NULL, 't'\t\t },\n\t\t{ \"nocanonicalize\", no_argument,       NULL, 'C'\t\t },\n\t\t{ \"nofsroot\",\t    no_argument,       NULL, 'v'\t\t },\n\t\t{ \"submounts\",\t    no_argument,       NULL, 'R'\t\t },\n\t\t{ \"source\",\t    required_argument, NULL, 'S'\t\t },\n\t\t{ \"tab-file\",\t    required_argument, NULL, 'F'\t\t },\n\t\t{ \"task\",\t    required_argument, NULL, 'N'\t\t },\n\t\t{ \"target\",\t    required_argument, NULL, 'T'\t\t },\n\t\t{ \"timeout\",\t    required_argument, NULL, 'w'\t\t },\n\t\t{ \"uniq\",\t    no_argument,       NULL, 'U'\t\t },\n\t\t{ \"verify\",\t    no_argument,       NULL, 'x'\t\t },\n\t\t{ \"version\",\t    no_argument,       NULL, 'V'\t\t },\n\t\t{ \"verbose\",\t    no_argument,       NULL, FINDMNT_OPT_VERBOSE },\n\t\t{ \"tree\",\t    no_argument,       NULL, FINDMNT_OPT_TREE\t },\n\t\t{ \"real\",\t    no_argument,       NULL, FINDMNT_OPT_REAL\t },\n\t\t{ \"pseudo\",\t    no_argument,       NULL, FINDMNT_OPT_PSEUDO\t },\n\t\t{ \"vfs-all\",\t    no_argument,       NULL, FINDMNT_OPT_VFS_ALL },\n\t\t{ \"shadowed\",       no_argument,       NULL, FINDMNT_OPT_SHADOWED },\n\t\t{ NULL, 0, NULL, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {\t/* rows and cols in ASCII order */\n\t\t{ 'C', 'c'},\t\t\t/* [no]canonicalize */\n\t\t{ 'C', 'e' },\t\t\t/* nocanonicalize, evaluate */\n\t\t{ 'J', 'P', 'r','x' },\t\t/* json,pairs,raw,verify */\n\t\t{ 'M', 'T' },\t\t\t/* mountpoint, target */\n\t\t{ 'N','k','m','s' },\t\t/* task,kernel,mtab,fstab */\n\t\t{ 'P','l','r','x' },\t\t/* pairs,list,raw,verify */\n\t\t{ 'p','x' },\t\t\t/* poll,verify */\n\t\t{ 'm','p','s' },\t\t/* mtab,poll,fstab */\n\t\t{ FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL },\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tclose_stdout_atexit();\n\n\t/* default output format */\n\tflags |= FL_TREE;\n\n\twhile ((c = getopt_long(argc, argv,\n\t\t\t\t\"AabCcDd:ehiJfF:o:O:p::PklmM:nN:rst:uvRS:T:Uw:Vx\",\n\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'A':\n\t\t\tflags |= FL_ALL;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tflags |= FL_ASCII;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tflags |= FL_BYTES;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tflags |= FL_NOCACHE;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags |= FL_CANONICALIZE;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tflags &= ~FL_TREE;\n\t\t\tflags |= FL_DF;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (!strcmp(optarg, \"forward\"))\n\t\t\t\tdirection = MNT_ITER_FORWARD;\n\t\t\telse if (!strcmp(optarg, \"backward\"))\n\t\t\t\tdirection = MNT_ITER_BACKWARD;\n\t\t\telse\n\t\t\t\terrx(EXIT_FAILURE,\n\t\t\t\t\t_(\"unknown direction '%s'\"), optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tflags |= FL_EVALUATE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tflags |= FL_INVERT;\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tflags |= FL_JSON;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tflags |= FL_FIRSTONLY;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttabfiles = append_tabfile(tabfiles, &ntabfiles, optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tdisable_columns_truncate();\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutarg = optarg;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_OUTPUT_ALL:\n\t\t\tfor (ncolumns = 0; ncolumns < ARRAY_SIZE(infos); ncolumns++) {\n\t\t\t\tif (is_tabdiff_column(ncolumns))\n\t\t\t\t\tcontinue;\n\t\t\t\tcolumns[ncolumns] = ncolumns;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tset_match(COL_OPTIONS, optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (optarg) {\n\t\t\t\tnactions = string_to_idarray(optarg,\n\t\t\t\t\t\tactions, ARRAY_SIZE(actions),\n\t\t\t\t\t\tpoll_action_name_to_id);\n\t\t\t\tif (nactions < 0)\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tflags |= FL_POLL;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tflags |= FL_EXPORT;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'm':\t\t/* mtab */\n\t\t\ttabtype = TABTYPE_MTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 's':\t\t/* fstab */\n\t\t\ttabtype = TABTYPE_FSTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'k':\t\t/* kernel (mountinfo) */\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tset_match(COL_FSTYPE, optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tflags |= FL_RAW;\t/* enable raw */\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tflags |= FL_NOHEADINGS;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\ttabfiles = append_pid_tabfile(tabfiles, &ntabfiles,\n\t\t\t\t\tstrtou32_or_err(optarg,\n\t\t\t\t\t\t_(\"invalid TID argument\")));\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tflags |= FL_NOFSROOT;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tflags |= FL_SUBMOUNTS;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tset_source_match(optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tflags |= FL_STRICTTARGET;\n\t\t\t/* fallthrough */\n\t\tcase 'T':\n\t\t\tset_match(COL_TARGET, optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tflags |= FL_UNIQ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttimeout = strtos32_or_err(optarg, _(\"invalid timeout argument\"));\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tverify = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VERBOSE:\n\t\t\tflags |= FL_VERBOSE;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_TREE:\n\t\t\tforce_tree = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_PSEUDO:\n\t\t\tflags |= FL_PSEUDO;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_REAL:\n\t\t\tflags |= FL_REAL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VFS_ALL:\n\t\t\tflags |= FL_VFS_ALL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_SHADOWED:\n\t\t\tflags |= FL_SHADOWED;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_DELETED:\n\t\t\tflags |= FL_DELETED;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\tcase 'V':\n\t\t\tprint_version(EXIT_SUCCESS);\n\t\tdefault:\n\t\t\terrtryhelp(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (!ncolumns && (flags & FL_DF)) {\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_SIZE);\n\t\tadd_column(columns, ncolumns++, COL_USED);\n\t\tadd_column(columns, ncolumns++, COL_AVAIL);\n\t\tadd_column(columns, ncolumns++, COL_USEPERC);\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t}\n\n\t/* default columns */\n\tif (!ncolumns) {\n\t\tif (flags & FL_POLL)\n\t\t\tadd_column(columns, ncolumns++, COL_ACTION);\n\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_OPTIONS);\n\t}\n\n\tif (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),\n\t\t\t\t\t &ncolumns, column_name_to_id) < 0)\n\t\treturn EXIT_FAILURE;\n\n\tif (!tabtype)\n\t\ttabtype = verify ? TABTYPE_FSTAB : TABTYPE_KERNEL;\n\n\tif ((flags & FL_POLL) && ntabfiles > 1)\n\t\terrx(EXIT_FAILURE, _(\"--poll accepts only one file, but more specified by --tab-file\"));\n\n\tif (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET)))\n\t\terrx(EXIT_FAILURE, _(\n\t\t\t\"options --target and --source can't be used together \"\n\t\t\t\"with command line element that is not an option\"));\n\n\tif (optind < argc)\n\t\tset_source_match(argv[optind++]);\t/* dev/tag/mountpoint/maj:min */\n\tif (optind < argc)\n\t\tset_match(COL_TARGET, argv[optind++]);\t/* mountpoint */\n\n\tif ((flags & FL_SUBMOUNTS) && is_listall_mode())\n\t\t/* don't care about submounts if list all mounts */\n\t\tflags &= ~FL_SUBMOUNTS;\n\n\tif (!(flags & FL_SUBMOUNTS) && ((flags & FL_FIRSTONLY)\n\t    || get_match(COL_TARGET)\n\t    || get_match(COL_SOURCE)\n\t    || get_match(COL_MAJMIN)))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOSWAPMATCH) &&\n\t    !get_match(COL_TARGET) && get_match(COL_SOURCE)) {\n\t\t/*\n\t\t * Check if we can swap source and target, it's\n\t\t * not possible if the source is LABEL=/UUID=\n\t\t */\n\t\tconst char *x = get_match(COL_SOURCE);\n\n\t\tif (!strncmp(x, \"LABEL=\", 6) || !strncmp(x, \"UUID=\", 5) ||\n\t\t    !strncmp(x, \"PARTLABEL=\", 10) || !strncmp(x, \"PARTUUID=\", 9))\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t}\n\n\t/*\n\t * initialize libmount\n\t */\n\tmnt_init_debug(0);\n\n\ttb = parse_tabfiles(tabfiles, ntabfiles, tabtype);\n\tif (!tb)\n\t\tgoto leave;\n\n\tif (tabtype == TABTYPE_MTAB && tab_is_kernel(tb))\n\t\ttabtype = TABTYPE_KERNEL;\n\n\tistree = tab_is_tree(tb);\n\tif (istree && force_tree)\n\t\tflags |= FL_TREE;\n\n\tif ((flags & FL_TREE) && (ntabfiles > 1 || !istree))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOCACHE)) {\n\t\tcache = mnt_new_cache();\n\t\tif (!cache) {\n\t\t\twarn(_(\"failed to initialize libmount cache\"));\n\t\t\tgoto leave;\n\t\t}\n\t\tmnt_table_set_cache(tb, cache);\n\n\t\tif (tabtype != TABTYPE_KERNEL)\n\t\t\tcache_set_targets(cache);\n\t}\n\n\tif (flags & FL_UNIQ)\n\t\tmnt_table_uniq_fs(tb, MNT_UNIQ_KEEPTREE, uniq_fs_target_cmp);\n\n\tif (verify) {\n\t\trc = verify_table(tb);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * initialize libsmartcols\n\t */\n\tscols_init_debug(0);\n\ttable = scols_new_table();\n\tif (!table) {\n\t\twarn(_(\"failed to allocate output table\"));\n\t\tgoto leave;\n\t}\n\tscols_table_enable_raw(table,        !!(flags & FL_RAW));\n\tscols_table_enable_export(table,     !!(flags & FL_EXPORT));\n\tscols_table_enable_json(table,       !!(flags & FL_JSON));\n\tscols_table_enable_ascii(table,      !!(flags & FL_ASCII));\n\tscols_table_enable_noheadings(table, !!(flags & FL_NOHEADINGS));\n\n\tif (flags & FL_JSON)\n\t\tscols_table_set_name(table, \"filesystems\");\n\n\tfor (i = 0; i < ncolumns; i++) {\n\t\tstruct libscols_column *cl;\n\t\tint fl = get_column_flags(i);\n\t\tint id = get_column_id(i);\n\n\t\tif (!(flags & FL_TREE))\n\t\t\tfl &= ~SCOLS_FL_TREE;\n\n\t\tif (!(flags & FL_POLL) && is_tabdiff_column(id)) {\n\t\t\twarnx(_(\"%s column is requested, but --poll \"\n\t\t\t       \"is not enabled\"), get_column_name(i));\n\t\t\tgoto leave;\n\t\t}\n\t\tcl = scols_table_new_column(table, get_column_name(i),\n\t\t\t\t\tget_column_whint(i), fl);\n\t\tif (!cl)\t{\n\t\t\twarn(_(\"failed to allocate output column\"));\n\t\t\tgoto leave;\n\t\t}\n\t\t/* multi-line cells (now used for SOURCES) */\n\t\tif (fl & SCOLS_FL_WRAP) {\n\t\t\tscols_column_set_wrapfunc(cl,\n\t\t\t\t\t\tscols_wrapnl_chunksize,\n\t\t\t\t\t\tscols_wrapnl_nextchunk,\n\t\t\t\t\t\tNULL);\n\t\t\tscols_column_set_safechars(cl, \"\\n\");\n\t\t}\n\t\tif (flags & FL_JSON) {\n\t\t\tswitch (id) {\n\t\t\tcase COL_SIZE:\n\t\t\tcase COL_AVAIL:\n\t\t\tcase COL_USED:\n\t\t\t\tif (!(flags & FL_BYTES))\n\t\t\t\t\tbreak;\n\t\t\t\t/* fallthrough */\n\t\t\tcase COL_ID:\n\t\t\tcase COL_PARENT:\n\t\t\tcase COL_FREQ:\n\t\t\tcase COL_PASSNO:\n\t\t\tcase COL_TID:\n\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_NUMBER);\n\t\t\t\tbreak;\n\t\t\tcase COL_DELETED:\n\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_BOOLEAN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fl & SCOLS_FL_WRAP)\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING);\n\t\t\t\telse\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_STRING);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Fill in data to the output table\n\t */\n\tif (flags & FL_POLL) {\n\t\t/* poll mode (accept the first tabfile only) */\n\t\trc = poll_table(tb, tabfiles ? *tabfiles : _PATH_PROC_MOUNTINFO, timeout, table, direction);\n\n\t} else if ((flags & FL_TREE) && !(flags & FL_SUBMOUNTS)) {\n\t\t/* whole tree */\n\t\trc = create_treenode(table, tb, NULL, NULL);\n\t} else {\n\t\t/* whole list of sub-tree */\n\t\trc = add_matching_lines(tb, table, direction);\n\n\t\tif (rc != 0\n\t\t    && tabtype == TABTYPE_KERNEL\n\t\t    && (flags & FL_NOSWAPMATCH)\n\t\t    && !(flags & FL_STRICTTARGET)\n\t\t    && get_match(COL_TARGET)) {\n\t\t\t/*\n\t\t\t * Found nothing, maybe the --target is regular file,\n\t\t\t * try it again with extra functionality for target\n\t\t\t * match\n\t\t\t */\n\t\t\tenable_extra_target_match(tb);\n\t\t\trc = add_matching_lines(tb, table, direction);\n\t\t}\n\t}\n\n\t/*\n\t * Print the output table for non-poll modes\n\t */\n\tif (!rc && !(flags & FL_POLL))\n\t\tscols_print_table(table);\nleave:\n\tscols_unref_table(table);\n\n\tmnt_unref_table(tb);\n\tmnt_unref_cache(cache);\n\n\tfree(tabfiles);\n#ifdef HAVE_LIBUDEV\n\tudev_unref(udev);\n#endif\n\treturn rc ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
        "func": "int main(int argc, char *argv[])\n{\n\tstruct libmnt_table *tb = NULL;\n\tchar **tabfiles = NULL;\n\tint direction = MNT_ITER_FORWARD;\n\tint verify = 0;\n\tint c, rc = -1, timeout = -1;\n\tint ntabfiles = 0, tabtype = 0;\n\tchar *outarg = NULL;\n\tsize_t i;\n\tint force_tree = 0, istree = 0;\n\n\tstruct libscols_table *table = NULL;\n\n\tenum {\n\t\tFINDMNT_OPT_VERBOSE = CHAR_MAX + 1,\n\t\tFINDMNT_OPT_TREE,\n\t\tFINDMNT_OPT_OUTPUT_ALL,\n\t\tFINDMNT_OPT_PSEUDO,\n\t\tFINDMNT_OPT_REAL,\n\t\tFINDMNT_OPT_VFS_ALL,\n\t\tFINDMNT_OPT_SHADOWED\n\t};\n\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\",\t    no_argument,       NULL, 'A'\t\t },\n\t\t{ \"ascii\",\t    no_argument,       NULL, 'a'\t\t },\n\t\t{ \"bytes\",\t    no_argument,       NULL, 'b'\t\t },\n\t\t{ \"canonicalize\",   no_argument,       NULL, 'c'\t\t },\n\t\t{ \"direction\",\t    required_argument, NULL, 'd'\t\t },\n\t\t{ \"df\",\t\t    no_argument,       NULL, 'D'\t\t },\n\t\t{ \"evaluate\",\t    no_argument,       NULL, 'e'\t\t },\n\t\t{ \"first-only\",\t    no_argument,       NULL, 'f'\t\t },\n\t\t{ \"fstab\",\t    no_argument,       NULL, 's'\t\t },\n\t\t{ \"help\",\t    no_argument,       NULL, 'h'\t\t },\n\t\t{ \"invert\",\t    no_argument,       NULL, 'i'\t\t },\n\t\t{ \"json\",\t    no_argument,       NULL, 'J'\t\t },\n\t\t{ \"kernel\",\t    no_argument,       NULL, 'k'\t\t },\n\t\t{ \"list\",\t    no_argument,       NULL, 'l'\t\t },\n\t\t{ \"mountpoint\",\t    required_argument, NULL, 'M'\t\t },\n\t\t{ \"mtab\",\t    no_argument,       NULL, 'm'\t\t },\n\t\t{ \"noheadings\",\t    no_argument,       NULL, 'n'\t\t },\n\t\t{ \"notruncate\",\t    no_argument,       NULL, 'u'\t\t },\n\t\t{ \"options\",\t    required_argument, NULL, 'O'\t\t },\n\t\t{ \"output\",\t    required_argument, NULL, 'o'\t\t },\n\t\t{ \"output-all\",\t    no_argument,       NULL, FINDMNT_OPT_OUTPUT_ALL },\n\t\t{ \"poll\",\t    optional_argument, NULL, 'p'\t\t },\n\t\t{ \"pairs\",\t    no_argument,       NULL, 'P'\t\t },\n\t\t{ \"raw\",\t    no_argument,       NULL, 'r'\t\t },\n\t\t{ \"types\",\t    required_argument, NULL, 't'\t\t },\n\t\t{ \"nocanonicalize\", no_argument,       NULL, 'C'\t\t },\n\t\t{ \"nofsroot\",\t    no_argument,       NULL, 'v'\t\t },\n\t\t{ \"submounts\",\t    no_argument,       NULL, 'R'\t\t },\n\t\t{ \"source\",\t    required_argument, NULL, 'S'\t\t },\n\t\t{ \"tab-file\",\t    required_argument, NULL, 'F'\t\t },\n\t\t{ \"task\",\t    required_argument, NULL, 'N'\t\t },\n\t\t{ \"target\",\t    required_argument, NULL, 'T'\t\t },\n\t\t{ \"timeout\",\t    required_argument, NULL, 'w'\t\t },\n\t\t{ \"uniq\",\t    no_argument,       NULL, 'U'\t\t },\n\t\t{ \"verify\",\t    no_argument,       NULL, 'x'\t\t },\n\t\t{ \"version\",\t    no_argument,       NULL, 'V'\t\t },\n\t\t{ \"verbose\",\t    no_argument,       NULL, FINDMNT_OPT_VERBOSE },\n\t\t{ \"tree\",\t    no_argument,       NULL, FINDMNT_OPT_TREE\t },\n\t\t{ \"real\",\t    no_argument,       NULL, FINDMNT_OPT_REAL\t },\n\t\t{ \"pseudo\",\t    no_argument,       NULL, FINDMNT_OPT_PSEUDO\t },\n\t\t{ \"vfs-all\",\t    no_argument,       NULL, FINDMNT_OPT_VFS_ALL },\n\t\t{ \"shadowed\",       no_argument,       NULL, FINDMNT_OPT_SHADOWED },\n\t\t{ NULL, 0, NULL, 0 }\n\t};\n\n\tstatic const ul_excl_t excl[] = {\t/* rows and cols in ASCII order */\n\t\t{ 'C', 'c'},\t\t\t/* [no]canonicalize */\n\t\t{ 'C', 'e' },\t\t\t/* nocanonicalize, evaluate */\n\t\t{ 'J', 'P', 'r','x' },\t\t/* json,pairs,raw,verify */\n\t\t{ 'M', 'T' },\t\t\t/* mountpoint, target */\n\t\t{ 'N','k','m','s' },\t\t/* task,kernel,mtab,fstab */\n\t\t{ 'P','l','r','x' },\t\t/* pairs,list,raw,verify */\n\t\t{ 'p','x' },\t\t\t/* poll,verify */\n\t\t{ 'm','p','s' },\t\t/* mtab,poll,fstab */\n\t\t{ FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL },\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tclose_stdout_atexit();\n\n\t/* default output format */\n\tflags |= FL_TREE;\n\n\twhile ((c = getopt_long(argc, argv,\n\t\t\t\t\"AabCcDd:ehiJfF:o:O:p::PklmM:nN:rst:uvRS:T:Uw:Vx\",\n\t\t\t\tlongopts, NULL)) != -1) {\n\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\n\t\tswitch(c) {\n\t\tcase 'A':\n\t\t\tflags |= FL_ALL;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tflags |= FL_ASCII;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tflags |= FL_BYTES;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tflags |= FL_NOCACHE;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags |= FL_CANONICALIZE;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tflags &= ~FL_TREE;\n\t\t\tflags |= FL_DF;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (!strcmp(optarg, \"forward\"))\n\t\t\t\tdirection = MNT_ITER_FORWARD;\n\t\t\telse if (!strcmp(optarg, \"backward\"))\n\t\t\t\tdirection = MNT_ITER_BACKWARD;\n\t\t\telse\n\t\t\t\terrx(EXIT_FAILURE,\n\t\t\t\t\t_(\"unknown direction '%s'\"), optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tflags |= FL_EVALUATE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tflags |= FL_INVERT;\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tflags |= FL_JSON;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tflags |= FL_FIRSTONLY;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttabfiles = append_tabfile(tabfiles, &ntabfiles, optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tdisable_columns_truncate();\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutarg = optarg;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_OUTPUT_ALL:\n\t\t\tfor (ncolumns = 0; ncolumns < ARRAY_SIZE(infos); ncolumns++) {\n\t\t\t\tif (is_tabdiff_column(ncolumns))\n\t\t\t\t\tcontinue;\n\t\t\t\tcolumns[ncolumns] = ncolumns;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tset_match(COL_OPTIONS, optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (optarg) {\n\t\t\t\tnactions = string_to_idarray(optarg,\n\t\t\t\t\t\tactions, ARRAY_SIZE(actions),\n\t\t\t\t\t\tpoll_action_name_to_id);\n\t\t\t\tif (nactions < 0)\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tflags |= FL_POLL;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tflags |= FL_EXPORT;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'm':\t\t/* mtab */\n\t\t\ttabtype = TABTYPE_MTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 's':\t\t/* fstab */\n\t\t\ttabtype = TABTYPE_FSTAB;\n\t\t\tflags &= ~FL_TREE;\n\t\t\tbreak;\n\t\tcase 'k':\t\t/* kernel (mountinfo) */\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tset_match(COL_FSTYPE, optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tflags |= FL_RAW;\t/* enable raw */\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tflags &= ~FL_TREE;\t/* disable the default */\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tflags |= FL_NOHEADINGS;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\ttabtype = TABTYPE_KERNEL;\n\t\t\ttabfiles = append_pid_tabfile(tabfiles, &ntabfiles,\n\t\t\t\t\tstrtou32_or_err(optarg,\n\t\t\t\t\t\t_(\"invalid TID argument\")));\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tflags |= FL_NOFSROOT;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tflags |= FL_SUBMOUNTS;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tset_source_match(optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tflags |= FL_STRICTTARGET;\n\t\t\t/* fallthrough */\n\t\tcase 'T':\n\t\t\tset_match(COL_TARGET, optarg);\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tflags |= FL_UNIQ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttimeout = strtos32_or_err(optarg, _(\"invalid timeout argument\"));\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tverify = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VERBOSE:\n\t\t\tflags |= FL_VERBOSE;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_TREE:\n\t\t\tforce_tree = 1;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_PSEUDO:\n\t\t\tflags |= FL_PSEUDO;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_REAL:\n\t\t\tflags |= FL_REAL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_VFS_ALL:\n\t\t\tflags |= FL_VFS_ALL;\n\t\t\tbreak;\n\t\tcase FINDMNT_OPT_SHADOWED:\n\t\t\tflags |= FL_SHADOWED;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\tcase 'V':\n\t\t\tprint_version(EXIT_SUCCESS);\n\t\tdefault:\n\t\t\terrtryhelp(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (!ncolumns && (flags & FL_DF)) {\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_SIZE);\n\t\tadd_column(columns, ncolumns++, COL_USED);\n\t\tadd_column(columns, ncolumns++, COL_AVAIL);\n\t\tadd_column(columns, ncolumns++, COL_USEPERC);\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t}\n\n\t/* default columns */\n\tif (!ncolumns) {\n\t\tif (flags & FL_POLL)\n\t\t\tadd_column(columns, ncolumns++, COL_ACTION);\n\n\t\tadd_column(columns, ncolumns++, COL_TARGET);\n\t\tadd_column(columns, ncolumns++, COL_SOURCE);\n\t\tadd_column(columns, ncolumns++, COL_FSTYPE);\n\t\tadd_column(columns, ncolumns++, COL_OPTIONS);\n\t}\n\n\tif (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns),\n\t\t\t\t\t &ncolumns, column_name_to_id) < 0)\n\t\treturn EXIT_FAILURE;\n\n\tif (!tabtype)\n\t\ttabtype = verify ? TABTYPE_FSTAB : TABTYPE_KERNEL;\n\n\tif ((flags & FL_POLL) && ntabfiles > 1)\n\t\terrx(EXIT_FAILURE, _(\"--poll accepts only one file, but more specified by --tab-file\"));\n\n\tif (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET)))\n\t\terrx(EXIT_FAILURE, _(\n\t\t\t\"options --target and --source can't be used together \"\n\t\t\t\"with command line element that is not an option\"));\n\n\tif (optind < argc)\n\t\tset_source_match(argv[optind++]);\t/* dev/tag/mountpoint/maj:min */\n\tif (optind < argc)\n\t\tset_match(COL_TARGET, argv[optind++]);\t/* mountpoint */\n\n\tif ((flags & FL_SUBMOUNTS) && is_listall_mode())\n\t\t/* don't care about submounts if list all mounts */\n\t\tflags &= ~FL_SUBMOUNTS;\n\n\tif (!(flags & FL_SUBMOUNTS) && ((flags & FL_FIRSTONLY)\n\t    || get_match(COL_TARGET)\n\t    || get_match(COL_SOURCE)\n\t    || get_match(COL_MAJMIN)))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOSWAPMATCH) &&\n\t    !get_match(COL_TARGET) && get_match(COL_SOURCE)) {\n\t\t/*\n\t\t * Check if we can swap source and target, it's\n\t\t * not possible if the source is LABEL=/UUID=\n\t\t */\n\t\tconst char *x = get_match(COL_SOURCE);\n\n\t\tif (!strncmp(x, \"LABEL=\", 6) || !strncmp(x, \"UUID=\", 5) ||\n\t\t    !strncmp(x, \"PARTLABEL=\", 10) || !strncmp(x, \"PARTUUID=\", 9))\n\t\t\tflags |= FL_NOSWAPMATCH;\n\t}\n\n\t/*\n\t * initialize libmount\n\t */\n\tmnt_init_debug(0);\n\n\ttb = parse_tabfiles(tabfiles, ntabfiles, tabtype);\n\tif (!tb)\n\t\tgoto leave;\n\n\tif (tabtype == TABTYPE_MTAB && tab_is_kernel(tb))\n\t\ttabtype = TABTYPE_KERNEL;\n\n\tistree = tab_is_tree(tb);\n\tif (istree && force_tree)\n\t\tflags |= FL_TREE;\n\n\tif ((flags & FL_TREE) && (ntabfiles > 1 || !istree))\n\t\tflags &= ~FL_TREE;\n\n\tif (!(flags & FL_NOCACHE)) {\n\t\tcache = mnt_new_cache();\n\t\tif (!cache) {\n\t\t\twarn(_(\"failed to initialize libmount cache\"));\n\t\t\tgoto leave;\n\t\t}\n\t\tmnt_table_set_cache(tb, cache);\n\n\t\tif (tabtype != TABTYPE_KERNEL)\n\t\t\tcache_set_targets(cache);\n\t}\n\n\tif (flags & FL_UNIQ)\n\t\tmnt_table_uniq_fs(tb, MNT_UNIQ_KEEPTREE, uniq_fs_target_cmp);\n\n\tif (verify) {\n\t\trc = verify_table(tb);\n\t\tgoto leave;\n\t}\n\n\t/*\n\t * initialize libsmartcols\n\t */\n\tscols_init_debug(0);\n\ttable = scols_new_table();\n\tif (!table) {\n\t\twarn(_(\"failed to allocate output table\"));\n\t\tgoto leave;\n\t}\n\tscols_table_enable_raw(table,        !!(flags & FL_RAW));\n\tscols_table_enable_export(table,     !!(flags & FL_EXPORT));\n\tscols_table_enable_json(table,       !!(flags & FL_JSON));\n\tscols_table_enable_ascii(table,      !!(flags & FL_ASCII));\n\tscols_table_enable_noheadings(table, !!(flags & FL_NOHEADINGS));\n\n\tif (flags & FL_JSON)\n\t\tscols_table_set_name(table, \"filesystems\");\n\n\tfor (i = 0; i < ncolumns; i++) {\n\t\tstruct libscols_column *cl;\n\t\tint fl = get_column_flags(i);\n\t\tint id = get_column_id(i);\n\n\t\tif (!(flags & FL_TREE))\n\t\t\tfl &= ~SCOLS_FL_TREE;\n\n\t\tif (!(flags & FL_POLL) && is_tabdiff_column(id)) {\n\t\t\twarnx(_(\"%s column is requested, but --poll \"\n\t\t\t       \"is not enabled\"), get_column_name(i));\n\t\t\tgoto leave;\n\t\t}\n\t\tcl = scols_table_new_column(table, get_column_name(i),\n\t\t\t\t\tget_column_whint(i), fl);\n\t\tif (!cl)\t{\n\t\t\twarn(_(\"failed to allocate output column\"));\n\t\t\tgoto leave;\n\t\t}\n\t\t/* multi-line cells (now used for SOURCES) */\n\t\tif (fl & SCOLS_FL_WRAP) {\n\t\t\tscols_column_set_wrapfunc(cl,\n\t\t\t\t\t\tscols_wrapnl_chunksize,\n\t\t\t\t\t\tscols_wrapnl_nextchunk,\n\t\t\t\t\t\tNULL);\n\t\t\tscols_column_set_safechars(cl, \"\\n\");\n\t\t}\n\t\tif (flags & FL_JSON) {\n\t\t\tswitch (id) {\n\t\t\tcase COL_SIZE:\n\t\t\tcase COL_AVAIL:\n\t\t\tcase COL_USED:\n\t\t\t\tif (!(flags & FL_BYTES))\n\t\t\t\t\tbreak;\n\t\t\t\t/* fallthrough */\n\t\t\tcase COL_ID:\n\t\t\tcase COL_PARENT:\n\t\t\tcase COL_FREQ:\n\t\t\tcase COL_PASSNO:\n\t\t\tcase COL_TID:\n\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_NUMBER);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fl & SCOLS_FL_WRAP)\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING);\n\t\t\t\telse\n\t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_STRING);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Fill in data to the output table\n\t */\n\tif (flags & FL_POLL) {\n\t\t/* poll mode (accept the first tabfile only) */\n\t\trc = poll_table(tb, tabfiles ? *tabfiles : _PATH_PROC_MOUNTINFO, timeout, table, direction);\n\n\t} else if ((flags & FL_TREE) && !(flags & FL_SUBMOUNTS)) {\n\t\t/* whole tree */\n\t\trc = create_treenode(table, tb, NULL, NULL);\n\t} else {\n\t\t/* whole list of sub-tree */\n\t\trc = add_matching_lines(tb, table, direction);\n\n\t\tif (rc != 0\n\t\t    && tabtype == TABTYPE_KERNEL\n\t\t    && (flags & FL_NOSWAPMATCH)\n\t\t    && !(flags & FL_STRICTTARGET)\n\t\t    && get_match(COL_TARGET)) {\n\t\t\t/*\n\t\t\t * Found nothing, maybe the --target is regular file,\n\t\t\t * try it again with extra functionality for target\n\t\t\t * match\n\t\t\t */\n\t\t\tenable_extra_target_match(tb);\n\t\t\trc = add_matching_lines(tb, table, direction);\n\t\t}\n\t}\n\n\t/*\n\t * Print the output table for non-poll modes\n\t */\n\tif (!rc && !(flags & FL_POLL))\n\t\tscols_print_table(table);\nleave:\n\tscols_unref_table(table);\n\n\tmnt_unref_table(tb);\n\tmnt_unref_cache(cache);\n\n\tfree(tabfiles);\n#ifdef HAVE_LIBUDEV\n\tudev_unref(udev);\n#endif\n\treturn rc ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,8 +19,7 @@\n \t\tFINDMNT_OPT_PSEUDO,\n \t\tFINDMNT_OPT_REAL,\n \t\tFINDMNT_OPT_VFS_ALL,\n-\t\tFINDMNT_OPT_SHADOWED,\n-\t\tFINDMNT_OPT_DELETED,\n+\t\tFINDMNT_OPT_SHADOWED\n \t};\n \n \tstatic const struct option longopts[] = {\n@@ -28,7 +27,6 @@\n \t\t{ \"ascii\",\t    no_argument,       NULL, 'a'\t\t },\n \t\t{ \"bytes\",\t    no_argument,       NULL, 'b'\t\t },\n \t\t{ \"canonicalize\",   no_argument,       NULL, 'c'\t\t },\n-\t\t{ \"deleted\",        no_argument,       NULL, FINDMNT_OPT_DELETED },\n \t\t{ \"direction\",\t    required_argument, NULL, 'd'\t\t },\n \t\t{ \"df\",\t\t    no_argument,       NULL, 'D'\t\t },\n \t\t{ \"evaluate\",\t    no_argument,       NULL, 'e'\t\t },\n@@ -247,9 +245,6 @@\n \t\tcase FINDMNT_OPT_SHADOWED:\n \t\t\tflags |= FL_SHADOWED;\n \t\t\tbreak;\n-\t\tcase FINDMNT_OPT_DELETED:\n-\t\t\tflags |= FL_DELETED;\n-\t\t\tbreak;\n \t\tcase 'h':\n \t\t\tusage();\n \t\tcase 'V':\n@@ -422,9 +417,6 @@\n \t\t\tcase COL_TID:\n \t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_NUMBER);\n \t\t\t\tbreak;\n-\t\t\tcase COL_DELETED:\n-\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_BOOLEAN);\n-\t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tif (fl & SCOLS_FL_WRAP)\n \t\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tFINDMNT_OPT_SHADOWED,",
                "\t\tFINDMNT_OPT_DELETED,",
                "\t\t{ \"deleted\",        no_argument,       NULL, FINDMNT_OPT_DELETED },",
                "\t\tcase FINDMNT_OPT_DELETED:",
                "\t\t\tflags |= FL_DELETED;",
                "\t\t\tbreak;",
                "\t\t\tcase COL_DELETED:",
                "\t\t\t\tscols_column_set_json_type(cl, SCOLS_JSON_BOOLEAN);",
                "\t\t\t\tbreak;"
            ],
            "added_lines": [
                "\t\tFINDMNT_OPT_SHADOWED"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3996",
        "func_name": "util-linux/usage",
        "description": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.",
        "git_url": "https://github.com/util-linux/util-linux/commit/166e87368ae88bf31112a30e078cceae637f4cdb",
        "commit_title": "libmount: remove support for deleted mount table entries",
        "commit_text": " The \"(deleted)\" suffix has been originally used by kernel for deleted mountpoints. Since kernel commit 9d4d65748a5ca26ea8650e50ba521295549bf4e3 (Dec 2014) kernel does not use this suffix for mount stuff in /proc at all. Let's remove this support from libmount too. ",
        "func_before": "static void __attribute__((__noreturn__)) usage(void)\n{\n\tFILE *out = stdout;\n\tsize_t i;\n\n\tfputs(USAGE_HEADER, out);\n\tfprintf(out, _(\n\t\" %1$s [options]\\n\"\n\t\" %1$s [options] <device> | <mountpoint>\\n\"\n\t\" %1$s [options] <device> <mountpoint>\\n\"\n\t\" %1$s [options] [--source <device>] [--target <path> | --mountpoint <dir>]\\n\"),\n\t\tprogram_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tfputs(_(\"Find a (mounted) filesystem.\\n\"), out);\n\n\tfputs(USAGE_OPTIONS, out);\n\tfputs(_(\" -s, --fstab            search in static table of filesystems\\n\"), out);\n\tfputs(_(\" -m, --mtab             search in table of mounted filesystems\\n\"\n\t\t\"                          (includes user space mount options)\\n\"), out);\n\tfputs(_(\" -k, --kernel           search in kernel table of mounted\\n\"\n\t\t\"                          filesystems (default)\\n\"), out);\n\tfputc('\\n', out);\n\tfputs(_(\" -p, --poll[=<list>]    monitor changes in table of mounted filesystems\\n\"), out);\n\tfputs(_(\" -w, --timeout <num>    upper limit in milliseconds that --poll will block\\n\"), out);\n\tfputc('\\n', out);\n\n\tfputs(_(\" -A, --all              disable all built-in filters, print all filesystems\\n\"), out);\n\tfputs(_(\" -a, --ascii            use ASCII chars for tree formatting\\n\"), out);\n\tfputs(_(\" -b, --bytes            print sizes in bytes rather than in human readable format\\n\"), out);\n\tfputs(_(\" -C, --nocanonicalize   don't canonicalize when comparing paths\\n\"), out);\n\tfputs(_(\" -c, --canonicalize     canonicalize printed paths\\n\"), out);\n\tfputs(_(\"     --deleted          print filesystems with mountpoint marked as deleted\\n\"), out);\n\tfputs(_(\" -D, --df               imitate the output of df(1)\\n\"), out);\n\tfputs(_(\" -d, --direction <word> direction of search, 'forward' or 'backward'\\n\"), out);\n\tfputs(_(\" -e, --evaluate         convert tags (LABEL,UUID,PARTUUID,PARTLABEL) \\n\"\n\t        \"                          to device names\\n\"), out);\n\tfputs(_(\" -F, --tab-file <path>  alternative file for -s, -m or -k options\\n\"), out);\n\tfputs(_(\" -f, --first-only       print the first found filesystem only\\n\"), out);\n\tfputs(_(\" -i, --invert           invert the sense of matching\\n\"), out);\n\tfputs(_(\" -J, --json             use JSON output format\\n\"), out);\n\tfputs(_(\" -l, --list             use list format output\\n\"), out);\n\tfputs(_(\" -N, --task <tid>       use alternative namespace (/proc/<tid>/mountinfo file)\\n\"), out);\n\tfputs(_(\" -n, --noheadings       don't print column headings\\n\"), out);\n\tfputs(_(\" -O, --options <list>   limit the set of filesystems by mount options\\n\"), out);\n\tfputs(_(\" -o, --output <list>    the output columns to be shown\\n\"), out);\n\tfputs(_(\"     --output-all       output all available columns\\n\"), out);\n\tfputs(_(\" -P, --pairs            use key=\\\"value\\\" output format\\n\"), out);\n\tfputs(_(\"     --pseudo           print only pseudo-filesystems\\n\"), out);\n\tfputs(_(\"     --shadowed         print only filesystems over-mounted by another filesystem\\n\"), out);\n\tfputs(_(\" -R, --submounts        print all submounts for the matching filesystems\\n\"), out);\n\tfputs(_(\" -r, --raw              use raw output format\\n\"), out);\n\tfputs(_(\"     --real             print only real filesystems\\n\"), out);\n\tfputs(_(\" -S, --source <string>  the device to mount (by name, maj:min, \\n\"\n\t        \"                          LABEL=, UUID=, PARTUUID=, PARTLABEL=)\\n\"), out);\n\tfputs(_(\" -T, --target <path>    the path to the filesystem to use\\n\"), out);\n\tfputs(_(\"     --tree             enable tree format output if possible\\n\"), out);\n\tfputs(_(\" -M, --mountpoint <dir> the mountpoint directory\\n\"), out);\n\tfputs(_(\" -t, --types <list>     limit the set of filesystems by FS types\\n\"), out);\n\tfputs(_(\" -U, --uniq             ignore filesystems with duplicate target\\n\"), out);\n\tfputs(_(\" -u, --notruncate       don't truncate text in columns\\n\"), out);\n\tfputs(_(\" -v, --nofsroot         don't print [/dir] for bind or btrfs mounts\\n\"), out);\n\n\tfputc('\\n', out);\n\tfputs(_(\" -x, --verify           verify mount table content (default is fstab)\\n\"), out);\n\tfputs(_(\"     --verbose          print more details\\n\"), out);\n\tfputs(_(\"     --vfs-all          print all VFS options\\n\"), out);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tprintf(USAGE_HELP_OPTIONS(24));\n\n\tfputs(USAGE_COLUMNS, out);\n\tfor (i = 0; i < ARRAY_SIZE(infos); i++)\n\t\tfprintf(out, \" %11s  %s\\n\", infos[i].name, _(infos[i].help));\n\n\tprintf(USAGE_MAN_TAIL(\"findmnt(8)\"));\n\n\texit(EXIT_SUCCESS);\n}",
        "func": "static void __attribute__((__noreturn__)) usage(void)\n{\n\tFILE *out = stdout;\n\tsize_t i;\n\n\tfputs(USAGE_HEADER, out);\n\tfprintf(out, _(\n\t\" %1$s [options]\\n\"\n\t\" %1$s [options] <device> | <mountpoint>\\n\"\n\t\" %1$s [options] <device> <mountpoint>\\n\"\n\t\" %1$s [options] [--source <device>] [--target <path> | --mountpoint <dir>]\\n\"),\n\t\tprogram_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tfputs(_(\"Find a (mounted) filesystem.\\n\"), out);\n\n\tfputs(USAGE_OPTIONS, out);\n\tfputs(_(\" -s, --fstab            search in static table of filesystems\\n\"), out);\n\tfputs(_(\" -m, --mtab             search in table of mounted filesystems\\n\"\n\t\t\"                          (includes user space mount options)\\n\"), out);\n\tfputs(_(\" -k, --kernel           search in kernel table of mounted\\n\"\n\t\t\"                          filesystems (default)\\n\"), out);\n\tfputc('\\n', out);\n\tfputs(_(\" -p, --poll[=<list>]    monitor changes in table of mounted filesystems\\n\"), out);\n\tfputs(_(\" -w, --timeout <num>    upper limit in milliseconds that --poll will block\\n\"), out);\n\tfputc('\\n', out);\n\n\tfputs(_(\" -A, --all              disable all built-in filters, print all filesystems\\n\"), out);\n\tfputs(_(\" -a, --ascii            use ASCII chars for tree formatting\\n\"), out);\n\tfputs(_(\" -b, --bytes            print sizes in bytes rather than in human readable format\\n\"), out);\n\tfputs(_(\" -C, --nocanonicalize   don't canonicalize when comparing paths\\n\"), out);\n\tfputs(_(\" -c, --canonicalize     canonicalize printed paths\\n\"), out);\n\tfputs(_(\" -D, --df               imitate the output of df(1)\\n\"), out);\n\tfputs(_(\" -d, --direction <word> direction of search, 'forward' or 'backward'\\n\"), out);\n\tfputs(_(\" -e, --evaluate         convert tags (LABEL,UUID,PARTUUID,PARTLABEL) \\n\"\n\t        \"                          to device names\\n\"), out);\n\tfputs(_(\" -F, --tab-file <path>  alternative file for -s, -m or -k options\\n\"), out);\n\tfputs(_(\" -f, --first-only       print the first found filesystem only\\n\"), out);\n\tfputs(_(\" -i, --invert           invert the sense of matching\\n\"), out);\n\tfputs(_(\" -J, --json             use JSON output format\\n\"), out);\n\tfputs(_(\" -l, --list             use list format output\\n\"), out);\n\tfputs(_(\" -N, --task <tid>       use alternative namespace (/proc/<tid>/mountinfo file)\\n\"), out);\n\tfputs(_(\" -n, --noheadings       don't print column headings\\n\"), out);\n\tfputs(_(\" -O, --options <list>   limit the set of filesystems by mount options\\n\"), out);\n\tfputs(_(\" -o, --output <list>    the output columns to be shown\\n\"), out);\n\tfputs(_(\"     --output-all       output all available columns\\n\"), out);\n\tfputs(_(\" -P, --pairs            use key=\\\"value\\\" output format\\n\"), out);\n\tfputs(_(\"     --pseudo           print only pseudo-filesystems\\n\"), out);\n\tfputs(_(\"     --shadowed         print only filesystems over-mounted by another filesystem\\n\"), out);\n\tfputs(_(\" -R, --submounts        print all submounts for the matching filesystems\\n\"), out);\n\tfputs(_(\" -r, --raw              use raw output format\\n\"), out);\n\tfputs(_(\"     --real             print only real filesystems\\n\"), out);\n\tfputs(_(\" -S, --source <string>  the device to mount (by name, maj:min, \\n\"\n\t        \"                          LABEL=, UUID=, PARTUUID=, PARTLABEL=)\\n\"), out);\n\tfputs(_(\" -T, --target <path>    the path to the filesystem to use\\n\"), out);\n\tfputs(_(\"     --tree             enable tree format output if possible\\n\"), out);\n\tfputs(_(\" -M, --mountpoint <dir> the mountpoint directory\\n\"), out);\n\tfputs(_(\" -t, --types <list>     limit the set of filesystems by FS types\\n\"), out);\n\tfputs(_(\" -U, --uniq             ignore filesystems with duplicate target\\n\"), out);\n\tfputs(_(\" -u, --notruncate       don't truncate text in columns\\n\"), out);\n\tfputs(_(\" -v, --nofsroot         don't print [/dir] for bind or btrfs mounts\\n\"), out);\n\n\tfputc('\\n', out);\n\tfputs(_(\" -x, --verify           verify mount table content (default is fstab)\\n\"), out);\n\tfputs(_(\"     --verbose          print more details\\n\"), out);\n\tfputs(_(\"     --vfs-all          print all VFS options\\n\"), out);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tprintf(USAGE_HELP_OPTIONS(24));\n\n\tfputs(USAGE_COLUMNS, out);\n\tfor (i = 0; i < ARRAY_SIZE(infos); i++)\n\t\tfprintf(out, \" %11s  %s\\n\", infos[i].name, _(infos[i].help));\n\n\tprintf(USAGE_MAN_TAIL(\"findmnt(8)\"));\n\n\texit(EXIT_SUCCESS);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,6 @@\n \tfputs(_(\" -b, --bytes            print sizes in bytes rather than in human readable format\\n\"), out);\n \tfputs(_(\" -C, --nocanonicalize   don't canonicalize when comparing paths\\n\"), out);\n \tfputs(_(\" -c, --canonicalize     canonicalize printed paths\\n\"), out);\n-\tfputs(_(\"     --deleted          print filesystems with mountpoint marked as deleted\\n\"), out);\n \tfputs(_(\" -D, --df               imitate the output of df(1)\\n\"), out);\n \tfputs(_(\" -d, --direction <word> direction of search, 'forward' or 'backward'\\n\"), out);\n \tfputs(_(\" -e, --evaluate         convert tags (LABEL,UUID,PARTUUID,PARTLABEL) \\n\"",
        "diff_line_info": {
            "deleted_lines": [
                "\tfputs(_(\"     --deleted          print filesystems with mountpoint marked as deleted\\n\"), out);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-3996",
        "func_name": "util-linux/get_data",
        "description": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.",
        "git_url": "https://github.com/util-linux/util-linux/commit/166e87368ae88bf31112a30e078cceae637f4cdb",
        "commit_title": "libmount: remove support for deleted mount table entries",
        "commit_text": " The \"(deleted)\" suffix has been originally used by kernel for deleted mountpoints. Since kernel commit 9d4d65748a5ca26ea8650e50ba521295549bf4e3 (Dec 2014) kernel does not use this suffix for mount stuff in /proc at all. Let's remove this support from libmount too. ",
        "func_before": "static char *get_data(struct libmnt_fs *fs, int num)\n{\n\tchar *str = NULL;\n\tconst char *t = NULL, *v = NULL;\n\tint col_id = get_column_id(num);\n\n\tswitch (col_id) {\n\tcase COL_SOURCES:\n\t\t/* print all devices with the same tag (LABEL, UUID) */\n\t\tif ((flags & FL_EVALUATE) &&\n\t\t    mnt_fs_get_tag(fs, &t, &v) == 0) {\n\t\t\tblkid_dev_iterate iter;\n\t\t\tblkid_dev dev;\n\t\t\tblkid_cache cache = NULL;\n\t\t\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\t\t\tint i = 0;\n\n\t\t\tif (blkid_get_cache(&cache, NULL) < 0)\n\t\t\t\tbreak;\n\n\t\t\tblkid_probe_all(cache);\n\n\t\t\titer = blkid_dev_iterate_begin(cache);\n\t\t\tblkid_dev_set_search(iter, t, v);\n\t\t\twhile (blkid_dev_next(iter, &dev) == 0) {\n\t\t\t\tdev = blkid_verify(cache, dev);\n\t\t\t\tif (!dev)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (i != 0)\n\t\t\t\t\tul_buffer_append_data(&buf, \"\\n\", 1);\n\t\t\t\tul_buffer_append_string(&buf, blkid_dev_devname(dev));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tblkid_dev_iterate_end(iter);\n\t\t\tstr = ul_buffer_get_data(&buf, NULL, NULL);\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tcase COL_SOURCE:\n\t{\n\t\tconst char *root = mnt_fs_get_root(fs);\n\t\tconst char *spec = mnt_fs_get_srcpath(fs);\n\t\tchar *cn = NULL;\n\n\t\tif (spec && (flags & FL_CANONICALIZE))\n\t\t\tspec = cn = mnt_resolve_path(spec, cache);\n\t\tif (!spec) {\n\t\t\tspec = mnt_fs_get_source(fs);\n\n\t\t\tif (spec && (flags & FL_EVALUATE))\n\t\t\t\tspec = cn = mnt_resolve_spec(spec, cache);\n\t\t}\n\t\tif (root && spec && !(flags & FL_NOFSROOT) && strcmp(root, \"/\") != 0)\n\t\t\txasprintf(&str, \"%s[%s]\", spec, root);\n\t\telse if (spec)\n\t\t\tstr = xstrdup(spec);\n\t\tif (!cache)\n\t\t\tfree(cn);\n\t\tbreak;\n\t}\n\n\tcase COL_TARGET:\n\t\tif (mnt_fs_get_target(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_target(fs));\n\t\tbreak;\n\tcase COL_FSTYPE:\n\t\tif (mnt_fs_get_fstype(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_fstype(fs));\n\t\tbreak;\n\tcase COL_OPTIONS:\n\t\tif (mnt_fs_get_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_options(fs));\n\t\tbreak;\n\tcase COL_VFS_OPTIONS:\n\t\tif (flags & FL_VFS_ALL)\n\t\t\tstr = mnt_fs_get_vfs_options_all(fs);\n\t\telse if (mnt_fs_get_vfs_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_vfs_options(fs));\n\t\tbreak;\n\tcase COL_FS_OPTIONS:\n\t\tif (mnt_fs_get_fs_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_fs_options(fs));\n\t\tbreak;\n\tcase COL_OPT_FIELDS:\n\t\tif (mnt_fs_get_optional_fields(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_optional_fields(fs));\n\t\tbreak;\n\tcase COL_UUID:\n\t\tstr = get_tag(fs, \"UUID\", col_id);\n\t\tbreak;\n\tcase COL_PARTUUID:\n\t\tstr = get_tag(fs, \"PARTUUID\", col_id);\n\t\tbreak;\n\tcase COL_LABEL:\n\t\tstr = get_tag(fs, \"LABEL\", col_id);\n\t\tbreak;\n\tcase COL_PARTLABEL:\n\t\tstr = get_tag(fs, \"PARTLABEL\", col_id);\n\t\tbreak;\n\n\tcase COL_MAJMIN:\n\t{\n\t\tdev_t devno = mnt_fs_get_devno(fs);\n\t\tif (!devno)\n\t\t\tbreak;\n\n\t\tif ((flags & FL_RAW) || (flags & FL_EXPORT) || (flags & FL_JSON))\n\t\t\txasprintf(&str, \"%u:%u\", major(devno), minor(devno));\n\t\telse\n\t\t\txasprintf(&str, \"%3u:%-3u\", major(devno), minor(devno));\n\t\tbreak;\n\t}\n\tcase COL_SIZE:\n\tcase COL_AVAIL:\n\tcase COL_USED:\n\tcase COL_USEPERC:\n\t\tstr = get_vfs_attr(fs, col_id);\n\t\tbreak;\n\tcase COL_FSROOT:\n\t\tif (mnt_fs_get_root(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_root(fs));\n\t\tbreak;\n\tcase COL_TID:\n\t\tif (mnt_fs_get_tid(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_tid(fs));\n\t\tbreak;\n\tcase COL_ID:\n\t\tif (mnt_fs_get_id(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_id(fs));\n\t\tbreak;\n\tcase COL_PARENT:\n\t\tif (mnt_fs_get_parent_id(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_parent_id(fs));\n\t\tbreak;\n\tcase COL_PROPAGATION:\n\t\tif (mnt_fs_is_kernel(fs)) {\n\t\t\tunsigned long fl = 0;\n\t\t\tchar *n = NULL;\n\n\t\t\tif (mnt_fs_get_propagation(fs, &fl) != 0)\n\t\t\t\tbreak;\n\n\t\t\tn = xstrdup((fl & MS_SHARED) ? \"shared\" : \"private\");\n\n\t\t\tif (fl & MS_SLAVE) {\n\t\t\t\txasprintf(&str, \"%s,slave\", n);\n\t\t\t\tfree(n);\n\t\t\t\tn = str;\n\t\t\t}\n\t\t\tif (fl & MS_UNBINDABLE) {\n\t\t\t\txasprintf(&str, \"%s,unbindable\", n);\n\t\t\t\tfree(n);\n\t\t\t\tn = str;\n\t\t\t}\n\t\t\tstr = n;\n\t\t}\n\t\tbreak;\n\tcase COL_FREQ:\n\t\tif (!mnt_fs_is_kernel(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_freq(fs));\n\t\tbreak;\n\tcase COL_PASSNO:\n\t\tif (!mnt_fs_is_kernel(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_passno(fs));\n\t\tbreak;\n\tcase COL_DELETED:\n\t\tstr = xstrdup(mnt_fs_is_deleted(fs) ? \"1\" : \"0\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn str;\n}",
        "func": "static char *get_data(struct libmnt_fs *fs, int num)\n{\n\tchar *str = NULL;\n\tconst char *t = NULL, *v = NULL;\n\tint col_id = get_column_id(num);\n\n\tswitch (col_id) {\n\tcase COL_SOURCES:\n\t\t/* print all devices with the same tag (LABEL, UUID) */\n\t\tif ((flags & FL_EVALUATE) &&\n\t\t    mnt_fs_get_tag(fs, &t, &v) == 0) {\n\t\t\tblkid_dev_iterate iter;\n\t\t\tblkid_dev dev;\n\t\t\tblkid_cache cache = NULL;\n\t\t\tstruct ul_buffer buf = UL_INIT_BUFFER;\n\t\t\tint i = 0;\n\n\t\t\tif (blkid_get_cache(&cache, NULL) < 0)\n\t\t\t\tbreak;\n\n\t\t\tblkid_probe_all(cache);\n\n\t\t\titer = blkid_dev_iterate_begin(cache);\n\t\t\tblkid_dev_set_search(iter, t, v);\n\t\t\twhile (blkid_dev_next(iter, &dev) == 0) {\n\t\t\t\tdev = blkid_verify(cache, dev);\n\t\t\t\tif (!dev)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (i != 0)\n\t\t\t\t\tul_buffer_append_data(&buf, \"\\n\", 1);\n\t\t\t\tul_buffer_append_string(&buf, blkid_dev_devname(dev));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tblkid_dev_iterate_end(iter);\n\t\t\tstr = ul_buffer_get_data(&buf, NULL, NULL);\n\t\t\tbreak;\n\t\t}\n\t\t/* fallthrough */\n\tcase COL_SOURCE:\n\t{\n\t\tconst char *root = mnt_fs_get_root(fs);\n\t\tconst char *spec = mnt_fs_get_srcpath(fs);\n\t\tchar *cn = NULL;\n\n\t\tif (spec && (flags & FL_CANONICALIZE))\n\t\t\tspec = cn = mnt_resolve_path(spec, cache);\n\t\tif (!spec) {\n\t\t\tspec = mnt_fs_get_source(fs);\n\n\t\t\tif (spec && (flags & FL_EVALUATE))\n\t\t\t\tspec = cn = mnt_resolve_spec(spec, cache);\n\t\t}\n\t\tif (root && spec && !(flags & FL_NOFSROOT) && strcmp(root, \"/\") != 0)\n\t\t\txasprintf(&str, \"%s[%s]\", spec, root);\n\t\telse if (spec)\n\t\t\tstr = xstrdup(spec);\n\t\tif (!cache)\n\t\t\tfree(cn);\n\t\tbreak;\n\t}\n\n\tcase COL_TARGET:\n\t\tif (mnt_fs_get_target(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_target(fs));\n\t\tbreak;\n\tcase COL_FSTYPE:\n\t\tif (mnt_fs_get_fstype(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_fstype(fs));\n\t\tbreak;\n\tcase COL_OPTIONS:\n\t\tif (mnt_fs_get_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_options(fs));\n\t\tbreak;\n\tcase COL_VFS_OPTIONS:\n\t\tif (flags & FL_VFS_ALL)\n\t\t\tstr = mnt_fs_get_vfs_options_all(fs);\n\t\telse if (mnt_fs_get_vfs_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_vfs_options(fs));\n\t\tbreak;\n\tcase COL_FS_OPTIONS:\n\t\tif (mnt_fs_get_fs_options(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_fs_options(fs));\n\t\tbreak;\n\tcase COL_OPT_FIELDS:\n\t\tif (mnt_fs_get_optional_fields(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_optional_fields(fs));\n\t\tbreak;\n\tcase COL_UUID:\n\t\tstr = get_tag(fs, \"UUID\", col_id);\n\t\tbreak;\n\tcase COL_PARTUUID:\n\t\tstr = get_tag(fs, \"PARTUUID\", col_id);\n\t\tbreak;\n\tcase COL_LABEL:\n\t\tstr = get_tag(fs, \"LABEL\", col_id);\n\t\tbreak;\n\tcase COL_PARTLABEL:\n\t\tstr = get_tag(fs, \"PARTLABEL\", col_id);\n\t\tbreak;\n\n\tcase COL_MAJMIN:\n\t{\n\t\tdev_t devno = mnt_fs_get_devno(fs);\n\t\tif (!devno)\n\t\t\tbreak;\n\n\t\tif ((flags & FL_RAW) || (flags & FL_EXPORT) || (flags & FL_JSON))\n\t\t\txasprintf(&str, \"%u:%u\", major(devno), minor(devno));\n\t\telse\n\t\t\txasprintf(&str, \"%3u:%-3u\", major(devno), minor(devno));\n\t\tbreak;\n\t}\n\tcase COL_SIZE:\n\tcase COL_AVAIL:\n\tcase COL_USED:\n\tcase COL_USEPERC:\n\t\tstr = get_vfs_attr(fs, col_id);\n\t\tbreak;\n\tcase COL_FSROOT:\n\t\tif (mnt_fs_get_root(fs))\n\t\t\tstr = xstrdup(mnt_fs_get_root(fs));\n\t\tbreak;\n\tcase COL_TID:\n\t\tif (mnt_fs_get_tid(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_tid(fs));\n\t\tbreak;\n\tcase COL_ID:\n\t\tif (mnt_fs_get_id(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_id(fs));\n\t\tbreak;\n\tcase COL_PARENT:\n\t\tif (mnt_fs_get_parent_id(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_parent_id(fs));\n\t\tbreak;\n\tcase COL_PROPAGATION:\n\t\tif (mnt_fs_is_kernel(fs)) {\n\t\t\tunsigned long fl = 0;\n\t\t\tchar *n = NULL;\n\n\t\t\tif (mnt_fs_get_propagation(fs, &fl) != 0)\n\t\t\t\tbreak;\n\n\t\t\tn = xstrdup((fl & MS_SHARED) ? \"shared\" : \"private\");\n\n\t\t\tif (fl & MS_SLAVE) {\n\t\t\t\txasprintf(&str, \"%s,slave\", n);\n\t\t\t\tfree(n);\n\t\t\t\tn = str;\n\t\t\t}\n\t\t\tif (fl & MS_UNBINDABLE) {\n\t\t\t\txasprintf(&str, \"%s,unbindable\", n);\n\t\t\t\tfree(n);\n\t\t\t\tn = str;\n\t\t\t}\n\t\t\tstr = n;\n\t\t}\n\t\tbreak;\n\tcase COL_FREQ:\n\t\tif (!mnt_fs_is_kernel(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_freq(fs));\n\t\tbreak;\n\tcase COL_PASSNO:\n\t\tif (!mnt_fs_is_kernel(fs))\n\t\t\txasprintf(&str, \"%d\", mnt_fs_get_passno(fs));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn str;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -163,9 +163,6 @@\n \t\tif (!mnt_fs_is_kernel(fs))\n \t\t\txasprintf(&str, \"%d\", mnt_fs_get_passno(fs));\n \t\tbreak;\n-\tcase COL_DELETED:\n-\t\tstr = xstrdup(mnt_fs_is_deleted(fs) ? \"1\" : \"0\");\n-\t\tbreak;\n \tdefault:\n \t\tbreak;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tcase COL_DELETED:",
                "\t\tstr = xstrdup(mnt_fs_is_deleted(fs) ? \"1\" : \"0\");",
                "\t\tbreak;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-3996",
        "func_name": "util-linux/match_func",
        "description": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.",
        "git_url": "https://github.com/util-linux/util-linux/commit/166e87368ae88bf31112a30e078cceae637f4cdb",
        "commit_title": "libmount: remove support for deleted mount table entries",
        "commit_text": " The \"(deleted)\" suffix has been originally used by kernel for deleted mountpoints. Since kernel commit 9d4d65748a5ca26ea8650e50ba521295549bf4e3 (Dec 2014) kernel does not use this suffix for mount stuff in /proc at all. Let's remove this support from libmount too. ",
        "func_before": "static int match_func(struct libmnt_fs *fs,\n\t\t      void *data __attribute__ ((__unused__)))\n{\n\tint rc = flags & FL_INVERT ? 1 : 0;\n\tconst char *m;\n\tvoid *md;\n\n\tm = get_match(COL_FSTYPE);\n\tif (m && !mnt_fs_match_fstype(fs, m))\n\t\treturn rc;\n\n\tm = get_match(COL_OPTIONS);\n\tif (m && !mnt_fs_match_options(fs, m))\n\t\treturn rc;\n\n\tmd = get_match_data(COL_MAJMIN);\n\tif (md && mnt_fs_get_devno(fs) != *((dev_t *) md))\n\t\treturn rc;\n\n\tm = get_match(COL_TARGET);\n\tif (m && !mnt_fs_match_target(fs, m, cache))\n\t\treturn rc;\n\n\tm = get_match(COL_SOURCE);\n\tif (m && !mnt_fs_match_source(fs, m, cache))\n\t\treturn rc;\n\n\tif ((flags & FL_DF) && !(flags & FL_ALL)) {\n\t\tconst char *type = mnt_fs_get_fstype(fs);\n\n\t\tif (type && strstr(type, \"tmpfs\"))\t/* tmpfs is wanted */\n\t\t\treturn !rc;\n\n\t\tif (mnt_fs_is_pseudofs(fs))\n\t\t\treturn rc;\n\t}\n\n\tif ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\n\tif ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\n\tif ((flags & FL_SHADOWED)) {\n\t\tstruct libmnt_table *tb = NULL;\n\n\t\tmnt_fs_get_table(fs, &tb);\n\t\tif (tb && mnt_table_over_fs(tb, fs, NULL) != 0)\n\t\t\treturn rc;\n\t}\n\n\tif ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs))\n\t\treturn rc;\n\n\treturn !rc;\n}",
        "func": "static int match_func(struct libmnt_fs *fs,\n\t\t      void *data __attribute__ ((__unused__)))\n{\n\tint rc = flags & FL_INVERT ? 1 : 0;\n\tconst char *m;\n\tvoid *md;\n\n\tm = get_match(COL_FSTYPE);\n\tif (m && !mnt_fs_match_fstype(fs, m))\n\t\treturn rc;\n\n\tm = get_match(COL_OPTIONS);\n\tif (m && !mnt_fs_match_options(fs, m))\n\t\treturn rc;\n\n\tmd = get_match_data(COL_MAJMIN);\n\tif (md && mnt_fs_get_devno(fs) != *((dev_t *) md))\n\t\treturn rc;\n\n\tm = get_match(COL_TARGET);\n\tif (m && !mnt_fs_match_target(fs, m, cache))\n\t\treturn rc;\n\n\tm = get_match(COL_SOURCE);\n\tif (m && !mnt_fs_match_source(fs, m, cache))\n\t\treturn rc;\n\n\tif ((flags & FL_DF) && !(flags & FL_ALL)) {\n\t\tconst char *type = mnt_fs_get_fstype(fs);\n\n\t\tif (type && strstr(type, \"tmpfs\"))\t/* tmpfs is wanted */\n\t\t\treturn !rc;\n\n\t\tif (mnt_fs_is_pseudofs(fs))\n\t\t\treturn rc;\n\t}\n\n\tif ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\n\tif ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\n\tif ((flags & FL_SHADOWED)) {\n\t\tstruct libmnt_table *tb = NULL;\n\n\t\tmnt_fs_get_table(fs, &tb);\n\t\tif (tb && mnt_table_over_fs(tb, fs, NULL) != 0)\n\t\t\treturn rc;\n\t}\n\n\treturn !rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,8 +49,5 @@\n \t\t\treturn rc;\n \t}\n \n-\tif ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs))\n-\t\treturn rc;\n-\n \treturn !rc;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs))",
                "\t\treturn rc;",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-3287",
        "func_name": "fwupd/fu_plugin_set_secure_config_value",
        "description": "When creating an OPERATOR user account on the BMC, the redfish plugin saved the auto-generated password to /etc/fwupd/redfish.conf without proper restriction, allowing any user on the system to read the same configuration file.",
        "git_url": "https://github.com/fwupd/fwupd/commit/ea676855f2119e36d433fbd2ed604039f53b2091",
        "commit_title": "Never save the Redfish passwords to a file readable by users",
        "commit_text": " When the redfish plugin automatically creates an OPERATOR user account on the BMC we save the autogenerated password to /etc/fwupd/redfish.conf, ensuring it is chmod'ed to 0660 before writing the file with g_key_file_save_to_file().  Under the covers, g_key_file_save_to_file() calls g_file_set_contents() with the keyfile string data. I was under the impression that G_FILE_CREATE_REPLACE_DESTINATION was being used to copy permissions, but alas not.  GLib instead calls g_file_set_contents_full() with the mode hardcoded to 0666, which undoes the previous chmod().  Use g_file_set_contents_full() with the correct mode for newer GLib versions, and provide a fallback with the same semantics for older versions.",
        "func_before": "gboolean\nfu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tgint ret;\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n\t\treturn FALSE;\n\t}\n\tret = g_chmod(conf_path, 0660);\n\tif (ret == -1) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t    \"failed to set permissions on %s\",\n\t\t\t    conf_path);\n\t\treturn FALSE;\n\t}\n\n\treturn fu_plugin_set_config_value(self, key, value, error);\n}",
        "func": "gboolean\nfu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tg_autofree gchar *data = NULL;\n\tg_autoptr(GKeyFile) keyfile = g_key_file_new();\n\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n\t\treturn FALSE;\n\t}\n\tif (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_KEEP_COMMENTS, error))\n\t\treturn FALSE;\n\tg_key_file_set_string(keyfile, fu_plugin_get_name(self), key, value);\n\tdata = g_key_file_to_data(keyfile, NULL, error);\n\tif (data == NULL)\n\t\treturn FALSE;\n\treturn g_file_set_contents_full(conf_path,\n\t\t\t\t\tdata,\n\t\t\t\t\t-1,\n\t\t\t\t\tG_FILE_SET_CONTENTS_CONSISTENT,\n\t\t\t\t\t0660,\n\t\t\t\t\terror);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,8 @@\n \t\t\t\t  GError **error)\n {\n \tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n-\tgint ret;\n+\tg_autofree gchar *data = NULL;\n+\tg_autoptr(GKeyFile) keyfile = g_key_file_new();\n \n \tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n \tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n@@ -14,15 +15,16 @@\n \t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n \t\treturn FALSE;\n \t}\n-\tret = g_chmod(conf_path, 0660);\n-\tif (ret == -1) {\n-\t\tg_set_error(error,\n-\t\t\t    FWUPD_ERROR,\n-\t\t\t    FWUPD_ERROR_INTERNAL,\n-\t\t\t    \"failed to set permissions on %s\",\n-\t\t\t    conf_path);\n+\tif (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_KEEP_COMMENTS, error))\n \t\treturn FALSE;\n-\t}\n-\n-\treturn fu_plugin_set_config_value(self, key, value, error);\n+\tg_key_file_set_string(keyfile, fu_plugin_get_name(self), key, value);\n+\tdata = g_key_file_to_data(keyfile, NULL, error);\n+\tif (data == NULL)\n+\t\treturn FALSE;\n+\treturn g_file_set_contents_full(conf_path,\n+\t\t\t\t\tdata,\n+\t\t\t\t\t-1,\n+\t\t\t\t\tG_FILE_SET_CONTENTS_CONSISTENT,\n+\t\t\t\t\t0660,\n+\t\t\t\t\terror);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tgint ret;",
                "\tret = g_chmod(conf_path, 0660);",
                "\tif (ret == -1) {",
                "\t\tg_set_error(error,",
                "\t\t\t    FWUPD_ERROR,",
                "\t\t\t    FWUPD_ERROR_INTERNAL,",
                "\t\t\t    \"failed to set permissions on %s\",",
                "\t\t\t    conf_path);",
                "\t}",
                "",
                "\treturn fu_plugin_set_config_value(self, key, value, error);"
            ],
            "added_lines": [
                "\tg_autofree gchar *data = NULL;",
                "\tg_autoptr(GKeyFile) keyfile = g_key_file_new();",
                "\tif (!g_key_file_load_from_file(keyfile, conf_path, G_KEY_FILE_KEEP_COMMENTS, error))",
                "\tg_key_file_set_string(keyfile, fu_plugin_get_name(self), key, value);",
                "\tdata = g_key_file_to_data(keyfile, NULL, error);",
                "\tif (data == NULL)",
                "\t\treturn FALSE;",
                "\treturn g_file_set_contents_full(conf_path,",
                "\t\t\t\t\tdata,",
                "\t\t\t\t\t-1,",
                "\t\t\t\t\tG_FILE_SET_CONTENTS_CONSISTENT,",
                "\t\t\t\t\t0660,",
                "\t\t\t\t\terror);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25297",
        "func_name": "drogonframework/drogon/HttpFileImpl::save",
        "description": "This affects the package drogonframework/drogon before 1.7.5. The unsafe handling of file names during upload using HttpFile::save() method may enable attackers to write files to arbitrary locations outside the designated target folder.",
        "git_url": "https://github.com/drogonframework/drogon/commit/3c785326c63a34aa1799a639ae185bc9453cb447",
        "commit_title": "Prevent malformed upload path causing arbitrary write (#1174)",
        "commit_text": "",
        "func_before": "int HttpFileImpl::save(const std::string &path) const\n{\n    assert(!path.empty());\n    if (fileName_.empty())\n        return -1;\n    filesystem::path fsPath(utils::toNativePath(path));\n    if (!fsPath.is_absolute() &&\n        (!fsPath.has_parent_path() ||\n         (fsPath.begin()->string() != \".\" && fsPath.begin()->string() != \"..\")))\n    {\n        filesystem::path fsUploadPath(utils::toNativePath(\n            HttpAppFrameworkImpl::instance().getUploadPath()));\n        fsPath = fsUploadPath / fsPath;\n    }\n    filesystem::path fsFileName(utils::toNativePath(fileName_));\n    if (!filesystem::exists(fsPath))\n    {\n        LOG_TRACE << \"create path:\" << fsPath;\n        drogon::error_code err;\n        filesystem::create_directories(fsPath, err);\n        if (err)\n        {\n            LOG_SYSERR;\n            return -1;\n        }\n    }\n    return saveTo(fsPath / fsFileName);\n}",
        "func": "int HttpFileImpl::save(const std::string &path) const\n{\n    assert(!path.empty());\n    if (fileName_.empty())\n        return -1;\n    filesystem::path fsUploadDir(utils::toNativePath(path));\n\n    if (!fsUploadDir.is_absolute() && (!fsUploadDir.has_parent_path() ||\n                                       (fsUploadDir.begin()->string() != \".\" &&\n                                        fsUploadDir.begin()->string() != \"..\")))\n    {\n        fsUploadDir = utils::toNativePath(\n                          HttpAppFrameworkImpl::instance().getUploadPath()) /\n                      fsUploadDir;\n    }\n\n    fsUploadDir = filesystem::weakly_canonical(fsUploadDir);\n\n    if (!filesystem::exists(fsUploadDir))\n    {\n        LOG_TRACE << \"create path:\" << fsUploadDir;\n        drogon::error_code err;\n        filesystem::create_directories(fsUploadDir, err);\n        if (err)\n        {\n            LOG_SYSERR;\n            return -1;\n        }\n    }\n\n    filesystem::path fsSaveToPath(filesystem::weakly_canonical(\n        fsUploadDir / utils::toNativePath(fileName_)));\n\n    if (!std::equal(fsUploadDir.begin(),\n                    fsUploadDir.end(),\n                    fsSaveToPath.begin()))\n    {\n        LOG_ERROR\n            << \"Attempt writing outside of upload directory detected. Path: \"\n            << fileName_;\n        return -1;\n    }\n\n    return saveTo(fsSaveToPath);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,26 +3,43 @@\n     assert(!path.empty());\n     if (fileName_.empty())\n         return -1;\n-    filesystem::path fsPath(utils::toNativePath(path));\n-    if (!fsPath.is_absolute() &&\n-        (!fsPath.has_parent_path() ||\n-         (fsPath.begin()->string() != \".\" && fsPath.begin()->string() != \"..\")))\n+    filesystem::path fsUploadDir(utils::toNativePath(path));\n+\n+    if (!fsUploadDir.is_absolute() && (!fsUploadDir.has_parent_path() ||\n+                                       (fsUploadDir.begin()->string() != \".\" &&\n+                                        fsUploadDir.begin()->string() != \"..\")))\n     {\n-        filesystem::path fsUploadPath(utils::toNativePath(\n-            HttpAppFrameworkImpl::instance().getUploadPath()));\n-        fsPath = fsUploadPath / fsPath;\n+        fsUploadDir = utils::toNativePath(\n+                          HttpAppFrameworkImpl::instance().getUploadPath()) /\n+                      fsUploadDir;\n     }\n-    filesystem::path fsFileName(utils::toNativePath(fileName_));\n-    if (!filesystem::exists(fsPath))\n+\n+    fsUploadDir = filesystem::weakly_canonical(fsUploadDir);\n+\n+    if (!filesystem::exists(fsUploadDir))\n     {\n-        LOG_TRACE << \"create path:\" << fsPath;\n+        LOG_TRACE << \"create path:\" << fsUploadDir;\n         drogon::error_code err;\n-        filesystem::create_directories(fsPath, err);\n+        filesystem::create_directories(fsUploadDir, err);\n         if (err)\n         {\n             LOG_SYSERR;\n             return -1;\n         }\n     }\n-    return saveTo(fsPath / fsFileName);\n+\n+    filesystem::path fsSaveToPath(filesystem::weakly_canonical(\n+        fsUploadDir / utils::toNativePath(fileName_)));\n+\n+    if (!std::equal(fsUploadDir.begin(),\n+                    fsUploadDir.end(),\n+                    fsSaveToPath.begin()))\n+    {\n+        LOG_ERROR\n+            << \"Attempt writing outside of upload directory detected. Path: \"\n+            << fileName_;\n+        return -1;\n+    }\n+\n+    return saveTo(fsSaveToPath);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    filesystem::path fsPath(utils::toNativePath(path));",
                "    if (!fsPath.is_absolute() &&",
                "        (!fsPath.has_parent_path() ||",
                "         (fsPath.begin()->string() != \".\" && fsPath.begin()->string() != \"..\")))",
                "        filesystem::path fsUploadPath(utils::toNativePath(",
                "            HttpAppFrameworkImpl::instance().getUploadPath()));",
                "        fsPath = fsUploadPath / fsPath;",
                "    filesystem::path fsFileName(utils::toNativePath(fileName_));",
                "    if (!filesystem::exists(fsPath))",
                "        LOG_TRACE << \"create path:\" << fsPath;",
                "        filesystem::create_directories(fsPath, err);",
                "    return saveTo(fsPath / fsFileName);"
            ],
            "added_lines": [
                "    filesystem::path fsUploadDir(utils::toNativePath(path));",
                "",
                "    if (!fsUploadDir.is_absolute() && (!fsUploadDir.has_parent_path() ||",
                "                                       (fsUploadDir.begin()->string() != \".\" &&",
                "                                        fsUploadDir.begin()->string() != \"..\")))",
                "        fsUploadDir = utils::toNativePath(",
                "                          HttpAppFrameworkImpl::instance().getUploadPath()) /",
                "                      fsUploadDir;",
                "",
                "    fsUploadDir = filesystem::weakly_canonical(fsUploadDir);",
                "",
                "    if (!filesystem::exists(fsUploadDir))",
                "        LOG_TRACE << \"create path:\" << fsUploadDir;",
                "        filesystem::create_directories(fsUploadDir, err);",
                "",
                "    filesystem::path fsSaveToPath(filesystem::weakly_canonical(",
                "        fsUploadDir / utils::toNativePath(fileName_)));",
                "",
                "    if (!std::equal(fsUploadDir.begin(),",
                "                    fsUploadDir.end(),",
                "                    fsSaveToPath.begin()))",
                "    {",
                "        LOG_ERROR",
                "            << \"Attempt writing outside of upload directory detected. Path: \"",
                "            << fileName_;",
                "        return -1;",
                "    }",
                "",
                "    return saveTo(fsSaveToPath);"
            ]
        }
    }
]