[
    {
        "cve_id": "CVE-2019-12450",
        "func_name": "GNOME/glib/file_copy_fallback",
        "description": "file_copy_fallback in gio/gfile.c in GNOME GLib 2.15.0 through 2.61.1 does not properly restrict file permissions while a copy operation is in progress. Instead, default permissions are used.",
        "git_url": "https://github.com/GNOME/glib/commit/d8f8f4d637ce43f8699ba94c9b7648beda0ca174",
        "commit_title": "gfile: Limit access to files when copying",
        "commit_text": " file_copy_fallback creates new files with default permissions and set the correct permissions after the operation is finished. This might cause that the files can be accessible by more users during the operation than expected. Use G_FILE_CREATE_PRIVATE for the new files to limit access to those files.",
        "func_before": "static gboolean\nfile_copy_fallback (GFile                  *source,\n                    GFile                  *destination,\n                    GFileCopyFlags          flags,\n                    GCancellable           *cancellable,\n                    GFileProgressCallback   progress_callback,\n                    gpointer                progress_callback_data,\n                    GError                **error)\n{\n  gboolean ret = FALSE;\n  GFileInputStream *file_in = NULL;\n  GInputStream *in = NULL;\n  GOutputStream *out = NULL;\n  GFileInfo *info = NULL;\n  const char *target;\n  char *attrs_to_read;\n  gboolean do_set_attributes = FALSE;\n\n  /* need to know the file type */\n  info = g_file_query_info (source,\n                            G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                            cancellable,\n                            error);\n  if (!info)\n    goto out;\n\n  /* Maybe copy the symlink? */\n  if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&\n      g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)\n    {\n      target = g_file_info_get_symlink_target (info);\n      if (target)\n        {\n          if (!copy_symlink (destination, flags, cancellable, target, error))\n            goto out;\n\n          ret = TRUE;\n          goto out;\n        }\n        /* ... else fall back on a regular file copy */\n    }\n  /* Handle \"special\" files (pipes, device nodes, ...)? */\n  else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)\n    {\n      /* FIXME: could try to recreate device nodes and others? */\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n                           _(\"Can’t copy special file\"));\n      goto out;\n    }\n\n  /* Everything else should just fall back on a regular copy. */\n\n  file_in = open_source_for_copy (source, destination, flags, cancellable, error);\n  if (!file_in)\n    goto out;\n  in = G_INPUT_STREAM (file_in);\n\n  if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read,\n                                      cancellable, error))\n    goto out;\n\n  if (attrs_to_read != NULL)\n    {\n      GError *tmp_error = NULL;\n\n      /* Ok, ditch the previous lightweight info (on Unix we just\n       * called lstat()); at this point we gather all the information\n       * we need about the source from the opened file descriptor.\n       */\n      g_object_unref (info);\n\n      info = g_file_input_stream_query_info (file_in, attrs_to_read,\n                                             cancellable, &tmp_error);\n      if (!info)\n        {\n          /* Not all gvfs backends implement query_info_on_read(), we\n           * can just fall back to the pathname again.\n           * https://bugzilla.gnome.org/706254\n           */\n          if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&tmp_error);\n              info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable, error);\n            }\n          else\n            {\n              g_free (attrs_to_read);\n              g_propagate_error (error, tmp_error);\n              goto out;\n            }\n        }\n      g_free (attrs_to_read);\n      if (!info)\n        goto out;\n\n      do_set_attributes = TRUE;\n    }\n\n  /* In the local file path, we pass down the source info which\n   * includes things like unix::mode, to ensure that the target file\n   * is not created with different permissions from the source file.\n   *\n   * If a future API like g_file_replace_with_info() is added, switch\n   * this code to use that.\n   */\n  if (G_IS_LOCAL_FILE (destination))\n    {\n      if (flags & G_FILE_COPY_OVERWRITE)\n        out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                   FALSE, NULL,\n                                                                   flags & G_FILE_COPY_BACKUP,\n                                                                   G_FILE_CREATE_REPLACE_DESTINATION,\n                                                                   info,\n                                                                   cancellable, error);\n      else\n        out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                  FALSE, 0, info,\n                                                                  cancellable, error);\n    }\n  else if (flags & G_FILE_COPY_OVERWRITE)\n    {\n      out = (GOutputStream *)g_file_replace (destination,\n                                             NULL,\n                                             flags & G_FILE_COPY_BACKUP,\n                                             G_FILE_CREATE_REPLACE_DESTINATION,\n                                             cancellable, error);\n    }\n  else\n    {\n      out = (GOutputStream *)g_file_create (destination, 0, cancellable, error);\n    }\n\n  if (!out)\n    goto out;\n\n#ifdef __linux__\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *reflink_err = NULL;\n\n      if (!btrfs_reflink_with_progress (in, out, info, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &reflink_err))\n        {\n          if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&reflink_err);\n            }\n          else\n            {\n              g_propagate_error (error, reflink_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n#endif\n\n#ifdef HAVE_SPLICE\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *splice_err = NULL;\n\n      if (!splice_stream_with_progress (in, out, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &splice_err))\n        {\n          if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&splice_err);\n            }\n          else\n            {\n              g_propagate_error (error, splice_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n\n#endif\n\n  /* A plain read/write loop */\n  if (!copy_stream_with_progress (in, out, source, cancellable,\n                                  progress_callback, progress_callback_data,\n                                  error))\n    goto out;\n\n  ret = TRUE;\n out:\n  if (in)\n    {\n      /* Don't care about errors in source here */\n      (void) g_input_stream_close (in, cancellable, NULL);\n      g_object_unref (in);\n    }\n\n  if (out)\n    {\n      /* But write errors on close are bad! */\n      if (!g_output_stream_close (out, cancellable, ret ? error : NULL))\n        ret = FALSE;\n      g_object_unref (out);\n    }\n\n  /* Ignore errors here. Failure to copy metadata is not a hard error */\n  /* TODO: set these attributes /before/ we do the rename() on Unix */\n  if (ret && do_set_attributes)\n    {\n      g_file_set_attributes_from_info (destination,\n                                       info,\n                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                       cancellable,\n                                       NULL);\n    }\n\n  g_clear_object (&info);\n\n  return ret;\n}",
        "func": "static gboolean\nfile_copy_fallback (GFile                  *source,\n                    GFile                  *destination,\n                    GFileCopyFlags          flags,\n                    GCancellable           *cancellable,\n                    GFileProgressCallback   progress_callback,\n                    gpointer                progress_callback_data,\n                    GError                **error)\n{\n  gboolean ret = FALSE;\n  GFileInputStream *file_in = NULL;\n  GInputStream *in = NULL;\n  GOutputStream *out = NULL;\n  GFileInfo *info = NULL;\n  const char *target;\n  char *attrs_to_read;\n  gboolean do_set_attributes = FALSE;\n\n  /* need to know the file type */\n  info = g_file_query_info (source,\n                            G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                            cancellable,\n                            error);\n  if (!info)\n    goto out;\n\n  /* Maybe copy the symlink? */\n  if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) &&\n      g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK)\n    {\n      target = g_file_info_get_symlink_target (info);\n      if (target)\n        {\n          if (!copy_symlink (destination, flags, cancellable, target, error))\n            goto out;\n\n          ret = TRUE;\n          goto out;\n        }\n        /* ... else fall back on a regular file copy */\n    }\n  /* Handle \"special\" files (pipes, device nodes, ...)? */\n  else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL)\n    {\n      /* FIXME: could try to recreate device nodes and others? */\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n                           _(\"Can’t copy special file\"));\n      goto out;\n    }\n\n  /* Everything else should just fall back on a regular copy. */\n\n  file_in = open_source_for_copy (source, destination, flags, cancellable, error);\n  if (!file_in)\n    goto out;\n  in = G_INPUT_STREAM (file_in);\n\n  if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read,\n                                      cancellable, error))\n    goto out;\n\n  if (attrs_to_read != NULL)\n    {\n      GError *tmp_error = NULL;\n\n      /* Ok, ditch the previous lightweight info (on Unix we just\n       * called lstat()); at this point we gather all the information\n       * we need about the source from the opened file descriptor.\n       */\n      g_object_unref (info);\n\n      info = g_file_input_stream_query_info (file_in, attrs_to_read,\n                                             cancellable, &tmp_error);\n      if (!info)\n        {\n          /* Not all gvfs backends implement query_info_on_read(), we\n           * can just fall back to the pathname again.\n           * https://bugzilla.gnome.org/706254\n           */\n          if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&tmp_error);\n              info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable, error);\n            }\n          else\n            {\n              g_free (attrs_to_read);\n              g_propagate_error (error, tmp_error);\n              goto out;\n            }\n        }\n      g_free (attrs_to_read);\n      if (!info)\n        goto out;\n\n      do_set_attributes = TRUE;\n    }\n\n  /* In the local file path, we pass down the source info which\n   * includes things like unix::mode, to ensure that the target file\n   * is not created with different permissions from the source file.\n   *\n   * If a future API like g_file_replace_with_info() is added, switch\n   * this code to use that.\n   */\n  if (G_IS_LOCAL_FILE (destination))\n    {\n      if (flags & G_FILE_COPY_OVERWRITE)\n        out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                   FALSE, NULL,\n                                                                   flags & G_FILE_COPY_BACKUP,\n                                                                   G_FILE_CREATE_REPLACE_DESTINATION |\n                                                                   G_FILE_CREATE_PRIVATE, info,\n                                                                   cancellable, error);\n      else\n        out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                  FALSE, G_FILE_CREATE_PRIVATE, info,\n                                                                  cancellable, error);\n    }\n  else if (flags & G_FILE_COPY_OVERWRITE)\n    {\n      out = (GOutputStream *)g_file_replace (destination,\n                                             NULL,\n                                             flags & G_FILE_COPY_BACKUP,\n                                             G_FILE_CREATE_REPLACE_DESTINATION |\n                                             G_FILE_CREATE_PRIVATE,\n                                             cancellable, error);\n    }\n  else\n    {\n      out = (GOutputStream *)g_file_create (destination, G_FILE_CREATE_PRIVATE, cancellable, error);\n    }\n\n  if (!out)\n    goto out;\n\n#ifdef __linux__\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *reflink_err = NULL;\n\n      if (!btrfs_reflink_with_progress (in, out, info, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &reflink_err))\n        {\n          if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&reflink_err);\n            }\n          else\n            {\n              g_propagate_error (error, reflink_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n#endif\n\n#ifdef HAVE_SPLICE\n  if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out))\n    {\n      GError *splice_err = NULL;\n\n      if (!splice_stream_with_progress (in, out, cancellable,\n                                        progress_callback, progress_callback_data,\n                                        &splice_err))\n        {\n          if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED))\n            {\n              g_clear_error (&splice_err);\n            }\n          else\n            {\n              g_propagate_error (error, splice_err);\n              goto out;\n            }\n        }\n      else\n        {\n          ret = TRUE;\n          goto out;\n        }\n    }\n\n#endif\n\n  /* A plain read/write loop */\n  if (!copy_stream_with_progress (in, out, source, cancellable,\n                                  progress_callback, progress_callback_data,\n                                  error))\n    goto out;\n\n  ret = TRUE;\n out:\n  if (in)\n    {\n      /* Don't care about errors in source here */\n      (void) g_input_stream_close (in, cancellable, NULL);\n      g_object_unref (in);\n    }\n\n  if (out)\n    {\n      /* But write errors on close are bad! */\n      if (!g_output_stream_close (out, cancellable, ret ? error : NULL))\n        ret = FALSE;\n      g_object_unref (out);\n    }\n\n  /* Ignore errors here. Failure to copy metadata is not a hard error */\n  /* TODO: set these attributes /before/ we do the rename() on Unix */\n  if (ret && do_set_attributes)\n    {\n      g_file_set_attributes_from_info (destination,\n                                       info,\n                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                       cancellable,\n                                       NULL);\n    }\n\n  g_clear_object (&info);\n\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -111,12 +111,12 @@\n         out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n                                                                    FALSE, NULL,\n                                                                    flags & G_FILE_COPY_BACKUP,\n-                                                                   G_FILE_CREATE_REPLACE_DESTINATION,\n-                                                                   info,\n+                                                                   G_FILE_CREATE_REPLACE_DESTINATION |\n+                                                                   G_FILE_CREATE_PRIVATE, info,\n                                                                    cancellable, error);\n       else\n         out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)),\n-                                                                  FALSE, 0, info,\n+                                                                  FALSE, G_FILE_CREATE_PRIVATE, info,\n                                                                   cancellable, error);\n     }\n   else if (flags & G_FILE_COPY_OVERWRITE)\n@@ -124,12 +124,13 @@\n       out = (GOutputStream *)g_file_replace (destination,\n                                              NULL,\n                                              flags & G_FILE_COPY_BACKUP,\n-                                             G_FILE_CREATE_REPLACE_DESTINATION,\n+                                             G_FILE_CREATE_REPLACE_DESTINATION |\n+                                             G_FILE_CREATE_PRIVATE,\n                                              cancellable, error);\n     }\n   else\n     {\n-      out = (GOutputStream *)g_file_create (destination, 0, cancellable, error);\n+      out = (GOutputStream *)g_file_create (destination, G_FILE_CREATE_PRIVATE, cancellable, error);\n     }\n \n   if (!out)",
        "diff_line_info": {
            "deleted_lines": [
                "                                                                   G_FILE_CREATE_REPLACE_DESTINATION,",
                "                                                                   info,",
                "                                                                  FALSE, 0, info,",
                "                                             G_FILE_CREATE_REPLACE_DESTINATION,",
                "      out = (GOutputStream *)g_file_create (destination, 0, cancellable, error);"
            ],
            "added_lines": [
                "                                                                   G_FILE_CREATE_REPLACE_DESTINATION |",
                "                                                                   G_FILE_CREATE_PRIVATE, info,",
                "                                                                  FALSE, G_FILE_CREATE_PRIVATE, info,",
                "                                             G_FILE_CREATE_REPLACE_DESTINATION |",
                "                                             G_FILE_CREATE_PRIVATE,",
                "      out = (GOutputStream *)g_file_create (destination, G_FILE_CREATE_PRIVATE, cancellable, error);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12795",
        "func_name": "GNOME/gvfs/g_vfs_daemon_init",
        "description": "daemon/gvfsdaemon.c in gvfsd from GNOME gvfs before 1.38.3, 1.40.x before 1.40.2, and 1.41.x before 1.41.3 opened a private D-Bus server socket without configuring an authorization rule. A local attacker could connect to this server socket and issue D-Bus method calls. (Note that the server socket only accepts a single connection, so the attacker would have to discover the server and connect to the socket before its owner does.)",
        "git_url": "https://github.com/GNOME/gvfs/commit/d8c9138bf240975848b1c54db648ec4cd516a48f",
        "commit_title": "gvfsdaemon: Check that the connecting client is the same user",
        "commit_text": " Otherwise, an attacker who learns the abstract socket address from netstat(8) or similar could connect to it and issue D-Bus method calls. ",
        "func_before": "static void\ng_vfs_daemon_init (GVfsDaemon *daemon)\n{\n  GError *error;\n  gint max_threads = 1; /* TODO: handle max threads */\n\n  daemon->thread_pool = g_thread_pool_new (job_handler_callback,\n\t\t\t\t\t   daemon,\n\t\t\t\t\t   max_threads,\n\t\t\t\t\t   FALSE, NULL);\n  /* TODO: verify thread_pool != NULL in a nicer way */\n  g_assert (daemon->thread_pool != NULL);\n\n  g_mutex_init (&daemon->lock);\n\n  daemon->mount_counter = 0;\n  \n  daemon->jobs = NULL;\n  daemon->registered_paths =\n    g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t   g_free, (GDestroyNotify)registered_path_free);\n\n  /* This is where we store active client connections so when a new filter is registered,\n   * we re-register them on all active connections */\n  daemon->client_connections =\n    g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, NULL);\n\n  daemon->conn = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  g_assert (daemon->conn != NULL);\n\n  daemon->daemon_skeleton = gvfs_dbus_daemon_skeleton_new ();\n  g_signal_connect (daemon->daemon_skeleton, \"handle-get-connection\", G_CALLBACK (handle_get_connection), daemon);\n  g_signal_connect (daemon->daemon_skeleton, \"handle-cancel\", G_CALLBACK (handle_cancel), daemon);\n  g_signal_connect (daemon->daemon_skeleton, \"handle-list-monitor-implementations\", G_CALLBACK (handle_list_monitor_implementations), daemon);\n  \n  error = NULL;\n  if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton),\n                                         daemon->conn,\n                                         G_VFS_DBUS_DAEMON_PATH,\n                                         &error))\n    {\n      g_warning (\"Error exporting daemon interface: %s (%s, %d)\\n\",\n                  error->message, g_quark_to_string (error->domain), error->code);\n      g_error_free (error);\n    }\n\n  daemon->mountable_skeleton = gvfs_dbus_mountable_skeleton_new ();\n  g_signal_connect (daemon->mountable_skeleton, \"handle-mount\", G_CALLBACK (daemon_handle_mount), daemon);\n  \n  error = NULL;\n  if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton),\n      daemon->conn,\n                                         G_VFS_DBUS_MOUNTABLE_PATH,\n                                         &error))\n    {\n      g_warning (\"Error exporting mountable interface: %s (%s, %d)\\n\",\n                  error->message, g_quark_to_string (error->domain), error->code);\n      g_error_free (error);\n    }\n}",
        "func": "static void\ng_vfs_daemon_init (GVfsDaemon *daemon)\n{\n  GError *error;\n  gint max_threads = 1; /* TODO: handle max threads */\n\n  daemon->thread_pool = g_thread_pool_new (job_handler_callback,\n\t\t\t\t\t   daemon,\n\t\t\t\t\t   max_threads,\n\t\t\t\t\t   FALSE, NULL);\n  /* TODO: verify thread_pool != NULL in a nicer way */\n  g_assert (daemon->thread_pool != NULL);\n\n  g_mutex_init (&daemon->lock);\n\n  daemon->mount_counter = 0;\n  \n  daemon->jobs = NULL;\n  daemon->registered_paths =\n    g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t   g_free, (GDestroyNotify)registered_path_free);\n\n  /* This is where we store active client connections so when a new filter is registered,\n   * we re-register them on all active connections */\n  daemon->client_connections =\n    g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, NULL);\n\n  daemon->conn = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  g_assert (daemon->conn != NULL);\n  daemon->auth_observer = g_dbus_auth_observer_new ();\n  g_signal_connect (daemon->auth_observer, \"authorize-authenticated-peer\", G_CALLBACK (authorize_authenticated_peer_cb), NULL);\n\n  daemon->daemon_skeleton = gvfs_dbus_daemon_skeleton_new ();\n  g_signal_connect (daemon->daemon_skeleton, \"handle-get-connection\", G_CALLBACK (handle_get_connection), daemon);\n  g_signal_connect (daemon->daemon_skeleton, \"handle-cancel\", G_CALLBACK (handle_cancel), daemon);\n  g_signal_connect (daemon->daemon_skeleton, \"handle-list-monitor-implementations\", G_CALLBACK (handle_list_monitor_implementations), daemon);\n  \n  error = NULL;\n  if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton),\n                                         daemon->conn,\n                                         G_VFS_DBUS_DAEMON_PATH,\n                                         &error))\n    {\n      g_warning (\"Error exporting daemon interface: %s (%s, %d)\\n\",\n                  error->message, g_quark_to_string (error->domain), error->code);\n      g_error_free (error);\n    }\n\n  daemon->mountable_skeleton = gvfs_dbus_mountable_skeleton_new ();\n  g_signal_connect (daemon->mountable_skeleton, \"handle-mount\", G_CALLBACK (daemon_handle_mount), daemon);\n  \n  error = NULL;\n  if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton),\n      daemon->conn,\n                                         G_VFS_DBUS_MOUNTABLE_PATH,\n                                         &error))\n    {\n      g_warning (\"Error exporting mountable interface: %s (%s, %d)\\n\",\n                  error->message, g_quark_to_string (error->domain), error->code);\n      g_error_free (error);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,8 @@\n \n   daemon->conn = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n   g_assert (daemon->conn != NULL);\n+  daemon->auth_observer = g_dbus_auth_observer_new ();\n+  g_signal_connect (daemon->auth_observer, \"authorize-authenticated-peer\", G_CALLBACK (authorize_authenticated_peer_cb), NULL);\n \n   daemon->daemon_skeleton = gvfs_dbus_daemon_skeleton_new ();\n   g_signal_connect (daemon->daemon_skeleton, \"handle-get-connection\", G_CALLBACK (handle_get_connection), daemon);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  daemon->auth_observer = g_dbus_auth_observer_new ();",
                "  g_signal_connect (daemon->auth_observer, \"authorize-authenticated-peer\", G_CALLBACK (authorize_authenticated_peer_cb), NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12795",
        "func_name": "GNOME/gvfs/g_vfs_daemon_finalize",
        "description": "daemon/gvfsdaemon.c in gvfsd from GNOME gvfs before 1.38.3, 1.40.x before 1.40.2, and 1.41.x before 1.41.3 opened a private D-Bus server socket without configuring an authorization rule. A local attacker could connect to this server socket and issue D-Bus method calls. (Note that the server socket only accepts a single connection, so the attacker would have to discover the server and connect to the socket before its owner does.)",
        "git_url": "https://github.com/GNOME/gvfs/commit/d8c9138bf240975848b1c54db648ec4cd516a48f",
        "commit_title": "gvfsdaemon: Check that the connecting client is the same user",
        "commit_text": " Otherwise, an attacker who learns the abstract socket address from netstat(8) or similar could connect to it and issue D-Bus method calls. ",
        "func_before": "static void\ng_vfs_daemon_finalize (GObject *object)\n{\n  GVfsDaemon *daemon;\n\n  daemon = G_VFS_DAEMON (object);\n\n  /* There may be some jobs outstanding if we've been force unmounted. */\n  if (daemon->jobs)\n    g_warning (\"daemon->jobs != NULL when finalizing daemon!\");\n\n  if (daemon->name_watcher)\n    g_bus_unwatch_name (daemon->name_watcher);\n  \n  if (daemon->daemon_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton));\n      g_object_unref (daemon->daemon_skeleton);\n    }\n  if (daemon->mountable_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton));\n      g_object_unref (daemon->mountable_skeleton);\n    }\n  if (daemon->conn != NULL)\n    g_object_unref (daemon->conn);\n  \n  g_hash_table_destroy (daemon->registered_paths);\n  g_hash_table_destroy (daemon->client_connections);\n  g_mutex_clear (&daemon->lock);\n\n  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize)\n    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);\n}",
        "func": "static void\ng_vfs_daemon_finalize (GObject *object)\n{\n  GVfsDaemon *daemon;\n\n  daemon = G_VFS_DAEMON (object);\n\n  /* There may be some jobs outstanding if we've been force unmounted. */\n  if (daemon->jobs)\n    g_warning (\"daemon->jobs != NULL when finalizing daemon!\");\n\n  if (daemon->name_watcher)\n    g_bus_unwatch_name (daemon->name_watcher);\n  \n  if (daemon->daemon_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton));\n      g_object_unref (daemon->daemon_skeleton);\n    }\n  if (daemon->mountable_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton));\n      g_object_unref (daemon->mountable_skeleton);\n    }\n  if (daemon->conn != NULL)\n    g_object_unref (daemon->conn);\n  if (daemon->auth_observer != NULL)\n    g_object_unref (daemon->auth_observer);\n  \n  g_hash_table_destroy (daemon->registered_paths);\n  g_hash_table_destroy (daemon->client_connections);\n  g_mutex_clear (&daemon->lock);\n\n  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize)\n    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,8 @@\n     }\n   if (daemon->conn != NULL)\n     g_object_unref (daemon->conn);\n+  if (daemon->auth_observer != NULL)\n+    g_object_unref (daemon->auth_observer);\n   \n   g_hash_table_destroy (daemon->registered_paths);\n   g_hash_table_destroy (daemon->client_connections);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (daemon->auth_observer != NULL)",
                "    g_object_unref (daemon->auth_observer);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12795",
        "func_name": "GNOME/gvfs/handle_get_connection",
        "description": "daemon/gvfsdaemon.c in gvfsd from GNOME gvfs before 1.38.3, 1.40.x before 1.40.2, and 1.41.x before 1.41.3 opened a private D-Bus server socket without configuring an authorization rule. A local attacker could connect to this server socket and issue D-Bus method calls. (Note that the server socket only accepts a single connection, so the attacker would have to discover the server and connect to the socket before its owner does.)",
        "git_url": "https://github.com/GNOME/gvfs/commit/d8c9138bf240975848b1c54db648ec4cd516a48f",
        "commit_title": "gvfsdaemon: Check that the connecting client is the same user",
        "commit_text": " Otherwise, an attacker who learns the abstract socket address from netstat(8) or similar could connect to it and issue D-Bus method calls. ",
        "func_before": "static gboolean\nhandle_get_connection (GVfsDBusDaemon *object,\n                       GDBusMethodInvocation *invocation,\n                       gpointer user_data)\n{\n  GVfsDaemon *daemon = G_VFS_DAEMON (user_data);\n  GDBusServer *server;\n  GError *error;\n  gchar *address1;\n  NewConnectionData *data;\n  char *socket_dir;\n  gchar *guid;\n  \n  generate_address (&address1, &socket_dir);\n\n  data = g_new (NewConnectionData, 1);\n  data->daemon = daemon;\n  data->socket_dir = socket_dir;\n  data->conn = NULL;\n\n  guid = g_dbus_generate_guid ();\n  error = NULL;\n  server = g_dbus_server_new_sync (address1,\n                                   G_DBUS_SERVER_FLAGS_NONE,\n                                   guid,\n                                   NULL, /* GDBusAuthObserver */\n                                   NULL, /* GCancellable */\n                                   &error);\n  g_free (guid);\n\n  if (server == NULL)\n    {\n      g_dbus_method_invocation_return_gerror (invocation, error);\n      g_printerr (\"daemon: Error creating server at address %s: %s\\n\", address1, error->message);\n      g_error_free (error);\n      goto error_out;\n    }\n\n  g_dbus_server_start (server);\n  data->server = server;\n\n  g_signal_connect (server, \"new-connection\", G_CALLBACK (daemon_new_connection_func), data);\n  \n  gvfs_dbus_daemon_complete_get_connection (object,\n                                            invocation,\n                                            address1,\n                                            \"\");\n\n  g_free (address1);\n  return TRUE;\n\n error_out:\n  new_connection_data_free (data);\n  g_free (address1);\n  return TRUE;\n}",
        "func": "static gboolean\nhandle_get_connection (GVfsDBusDaemon *object,\n                       GDBusMethodInvocation *invocation,\n                       gpointer user_data)\n{\n  GVfsDaemon *daemon = G_VFS_DAEMON (user_data);\n  GDBusServer *server;\n  GError *error;\n  gchar *address1;\n  NewConnectionData *data;\n  char *socket_dir;\n  gchar *guid;\n  \n  generate_address (&address1, &socket_dir);\n\n  data = g_new (NewConnectionData, 1);\n  data->daemon = daemon;\n  data->socket_dir = socket_dir;\n  data->conn = NULL;\n\n  guid = g_dbus_generate_guid ();\n  error = NULL;\n  server = g_dbus_server_new_sync (address1,\n                                   G_DBUS_SERVER_FLAGS_NONE,\n                                   guid,\n                                   daemon->auth_observer,\n                                   NULL, /* GCancellable */\n                                   &error);\n  g_free (guid);\n\n  if (server == NULL)\n    {\n      g_dbus_method_invocation_return_gerror (invocation, error);\n      g_printerr (\"daemon: Error creating server at address %s: %s\\n\", address1, error->message);\n      g_error_free (error);\n      goto error_out;\n    }\n\n  g_dbus_server_start (server);\n  data->server = server;\n\n  g_signal_connect (server, \"new-connection\", G_CALLBACK (daemon_new_connection_func), data);\n  \n  gvfs_dbus_daemon_complete_get_connection (object,\n                                            invocation,\n                                            address1,\n                                            \"\");\n\n  g_free (address1);\n  return TRUE;\n\n error_out:\n  new_connection_data_free (data);\n  g_free (address1);\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n   server = g_dbus_server_new_sync (address1,\n                                    G_DBUS_SERVER_FLAGS_NONE,\n                                    guid,\n-                                   NULL, /* GDBusAuthObserver */\n+                                   daemon->auth_observer,\n                                    NULL, /* GCancellable */\n                                    &error);\n   g_free (guid);",
        "diff_line_info": {
            "deleted_lines": [
                "                                   NULL, /* GDBusAuthObserver */"
            ],
            "added_lines": [
                "                                   daemon->auth_observer,"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/ax25_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0614e2b73768b502fc32a75349823356d98aae2c",
        "commit_title": "When creating a raw AF_AX25 socket, CAP_NET_RAW needs to be checked",
        "commit_text": "first.  ",
        "func_before": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "func": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,6 +51,8 @@\n \t\tbreak;\n \n \tcase SOCK_RAW:\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tbreak;\n \tdefault:\n \t\treturn -ESOCKTNOSUPPORT;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "kernel/git/tip/tip/ax25_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=2c675dab816278a1724c1e93b384c2f05a11cb31",
        "commit_title": "commit 0614e2b73768b502fc32a75349823356d98aae2c upstream.",
        "commit_text": " When creating a raw AF_AX25 socket, CAP_NET_RAW needs to be checked first.  ",
        "func_before": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = sk->sk_protinfo = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "func": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = sk->sk_protinfo = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,6 +51,8 @@\n \t\tbreak;\n \n \tcase SOCK_RAW:\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tbreak;\n \tdefault:\n \t\treturn -ESOCKTNOSUPPORT;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/ax25_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "func": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,6 +51,8 @@\n \t\tbreak;\n \n \tcase SOCK_RAW:\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tbreak;\n \tdefault:\n \t\treturn -ESOCKTNOSUPPORT;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/base_sock_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "func": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n \n \tif (sock->type != SOCK_RAW)\n \t\treturn -ESOCKTNOSUPPORT;\n+\tif (!capable(CAP_NET_RAW))\n+\t\treturn -EPERM;\n \n \tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n \tif (!sk)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!capable(CAP_NET_RAW))",
                "\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/llcp_sock_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "func": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &llcp_rawsock_ops;\n\t} else {\n\t\tsock->ops = &llcp_sock_ops;\n\t}\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,10 +10,13 @@\n \t    sock->type != SOCK_RAW)\n \t\treturn -ESOCKTNOSUPPORT;\n \n-\tif (sock->type == SOCK_RAW)\n+\tif (sock->type == SOCK_RAW) {\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tsock->ops = &llcp_rawsock_ops;\n-\telse\n+\t} else {\n \t\tsock->ops = &llcp_sock_ops;\n+\t}\n \n \tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n \tif (sk == NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (sock->type == SOCK_RAW)",
                "\telse"
            ],
            "added_lines": [
                "\tif (sock->type == SOCK_RAW) {",
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;",
                "\t} else {",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/atalk_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}",
        "func": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\n\trc = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,11 @@\n \t */\n \tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n \t\tgoto out;\n+\n+\trc = -EPERM;\n+\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n+\t\tgoto out;\n+\n \trc = -ENOMEM;\n \tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n \tif (!sk)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\trc = -EPERM;",
                "\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))",
                "\t\tgoto out;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/base_sock_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "func": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n \n \tif (sock->type != SOCK_RAW)\n \t\treturn -ESOCKTNOSUPPORT;\n+\tif (!capable(CAP_NET_RAW))\n+\t\treturn -EPERM;\n \n \tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n \tif (!sk)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!capable(CAP_NET_RAW))",
                "\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17053",
        "func_name": "torvalds/linux/ieee802154_create",
        "description": "ieee802154_create in net/ieee802154/socket.c in the AF_IEEE802154 network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-e69dbd4619e7.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=e69dbd4619e7674c1679cba49afd9dd9ac347eef",
        "commit_title": "When creating a raw AF_IEEE802154 socket, CAP_NET_RAW needs to be",
        "commit_text": "checked first.  ",
        "func_before": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\n\tsock->ops = ops;\n\n\tsock_init_data(sock, sk);\n\t/* FIXME: sk->sk_destruct */\n\tsk->sk_family = PF_IEEE802154;\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}",
        "func": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\tgoto out;\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\n\tsock->ops = ops;\n\n\tsock_init_data(sock, sk);\n\t/* FIXME: sk->sk_destruct */\n\tsk->sk_family = PF_IEEE802154;\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,9 @@\n \n \tswitch (sock->type) {\n \tcase SOCK_RAW:\n+\t\trc = -EPERM;\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\tgoto out;\n \t\tproto = &ieee802154_raw_prot;\n \t\tops = &ieee802154_raw_ops;\n \t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\trc = -EPERM;",
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\tgoto out;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17054",
        "func_name": "torvalds/linux/atalk_create",
        "description": "atalk_create in net/appletalk/ddp.c in the AF_APPLETALK network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-6cc03e8aa36c.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6cc03e8aa36c51f3b26a0d21a3c4ce2809c842ac",
        "commit_title": "When creating a raw AF_APPLETALK socket, CAP_NET_RAW needs to be checked",
        "commit_text": "first.  ",
        "func_before": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}",
        "func": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\n\trc = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,11 @@\n \t */\n \tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n \t\tgoto out;\n+\n+\trc = -EPERM;\n+\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n+\t\tgoto out;\n+\n \trc = -ENOMEM;\n \tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n \tif (!sk)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\trc = -EPERM;",
                "\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))",
                "\t\tgoto out;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17056",
        "func_name": "torvalds/linux/llcp_sock_create",
        "description": "llcp_sock_create in net/nfc/llcp_sock.c in the AF_NFC network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-3a359798b176.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3a359798b176183ef09efb7a3dc59abad1cc7104",
        "commit_title": "When creating a raw AF_NFC socket, CAP_NET_RAW needs to be checked",
        "commit_text": "first.  ",
        "func_before": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "func": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &llcp_rawsock_ops;\n\t} else {\n\t\tsock->ops = &llcp_sock_ops;\n\t}\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,10 +10,13 @@\n \t    sock->type != SOCK_RAW)\n \t\treturn -ESOCKTNOSUPPORT;\n \n-\tif (sock->type == SOCK_RAW)\n+\tif (sock->type == SOCK_RAW) {\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tsock->ops = &llcp_rawsock_ops;\n-\telse\n+\t} else {\n \t\tsock->ops = &llcp_sock_ops;\n+\t}\n \n \tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n \tif (sk == NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (sock->type == SOCK_RAW)",
                "\telse"
            ],
            "added_lines": [
                "\tif (sock->type == SOCK_RAW) {",
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;",
                "\t} else {",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24301",
        "func_name": "minetest/Server::handleCommand_InventoryAction",
        "description": "In Minetest before 5.4.0, players can add or subtract items from a different player's inventory.",
        "git_url": "https://github.com/minetest/minetest/commit/3693b6871eba268ecc79b3f52d00d3cefe761131",
        "commit_title": "Prevent players accessing inventories of other players (#10341)",
        "commit_text": "",
        "func_before": "void Server::handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player =\n\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->from_inv.name == player->getName());\n\n\t\tbool to_inv_is_current_player =\n\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->to_inv.name == player->getName());\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}",
        "func": "void Server::handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player = false;\n\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->from_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tfrom_inv_is_current_player = true;\n\t\t}\n\t\t\n\t\tbool to_inv_is_current_player = false;\n\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->to_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tto_inv_is_current_player = true;\n\t\t}\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,13 +56,19 @@\n \t\tif (ma->from_inv != ma->to_inv)\n \t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n \n-\t\tbool from_inv_is_current_player =\n-\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n-\t\t\t(ma->from_inv.name == player->getName());\n-\n-\t\tbool to_inv_is_current_player =\n-\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n-\t\t\t(ma->to_inv.name == player->getName());\n+\t\tbool from_inv_is_current_player = false;\n+\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n+\t\t\tif (ma->from_inv.name != player->getName())\n+\t\t\t\treturn;\n+\t\t\tfrom_inv_is_current_player = true;\n+\t\t}\n+\t\t\n+\t\tbool to_inv_is_current_player = false;\n+\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n+\t\t\tif (ma->to_inv.name != player->getName())\n+\t\t\t\treturn;\n+\t\t\tto_inv_is_current_player = true;\n+\t\t}\n \n \t\tInventoryLocation *remote = from_inv_is_current_player ?\n \t\t\t&ma->to_inv : &ma->from_inv;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tbool from_inv_is_current_player =",
                "\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&",
                "\t\t\t(ma->from_inv.name == player->getName());",
                "",
                "\t\tbool to_inv_is_current_player =",
                "\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&",
                "\t\t\t(ma->to_inv.name == player->getName());"
            ],
            "added_lines": [
                "\t\tbool from_inv_is_current_player = false;",
                "\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {",
                "\t\t\tif (ma->from_inv.name != player->getName())",
                "\t\t\t\treturn;",
                "\t\t\tfrom_inv_is_current_player = true;",
                "\t\t}",
                "\t\t",
                "\t\tbool to_inv_is_current_player = false;",
                "\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {",
                "\t\t\tif (ma->to_inv.name != player->getName())",
                "\t\t\t\treturn;",
                "\t\t\tto_inv_is_current_player = true;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0336",
        "func_name": "samba-team/samba/samldb_spn_uniqueness_check",
        "description": "The Samba AD DC includes checks when adding service principals names (SPNs) to an account to ensure that SPNs do not alias with those already in the database. Some of these checks are able to be bypassed if an account modification re-adds an SPN that was previously present on that account, such as one added when a computer is joined to a domain. An attacker who has the ability to write to an account can exploit this to perform a denial-of-service attack by adding an SPN that matches an existing service. Additionally, an attacker who can intercept traffic can impersonate existing services, resulting in a loss of confidentiality and integrity.",
        "git_url": "https://github.com/samba-team/samba/commit/1a5dc817c0c9379bbaab14c676681b42b0039a3c",
        "commit_title": "CVE-2022-0336: s4/dsdb/samldb: Don't return early when an SPN is re-added to an object",
        "commit_text": " If an added SPN already exists on an object, we still want to check the rest of the element values for conflicts.  BUG: https://bugzilla.samba.org/show_bug.cgi?id=14950 ",
        "func_before": "static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\t/* we have no sPNMappings, hence no aliases */\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}",
        "func": "static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\t/* we have no sPNMappings, hence no aliases */\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,8 +29,7 @@\n \t\t\t\t\t\t ac->msg->dn);\n \t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n \t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n-\t\t\ttalloc_free(tmp_ctx);\n-\t\t\treturn LDB_SUCCESS;\n+\t\t\tcontinue;\n \t\t}\n \t\tif (ret != LDB_SUCCESS) {\n \t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\ttalloc_free(tmp_ctx);",
                "\t\t\treturn LDB_SUCCESS;"
            ],
            "added_lines": [
                "\t\t\tcontinue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15852",
        "func_name": "torvalds/linux/native_tss_update_io_bitmap",
        "description": "An issue was discovered in the Linux kernel 5.5 through 5.7.9, as used in Xen through 4.13.x for x86 PV guests. An attacker may be granted the I/O port permissions of an unrelated task. This occurs because tss_invalidate_io_bitmap mishandling causes a loss of synchronization between the I/O bitmaps of TSS and Xen, aka CID-cadfad870154.",
        "git_url": "https://github.com/torvalds/linux/commit/cadfad870154e14f745ec845708bc17d166065f2",
        "commit_title": "x86/ioperm: Fix io bitmap invalidation on Xen PV",
        "commit_text": " tss_invalidate_io_bitmap() wasn't wired up properly through the pvop machinery, so the TSS and Xen's io bitmap would get out of sync whenever disabling a valid io bitmap.  Add a new pvop for tss_invalidate_io_bitmap() to fix it.  This is XSA-329.  Cc: stable@vger.kernel.org Link: https://lkml.kernel.org/r/d53075590e1f91c19f8af705059d3ff99424c020.1595030016.git.luto@kernel.org",
        "func_before": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\n\t\t/*\n\t\t * Only copy bitmap data when the sequence number differs. The\n\t\t * update time is accounted to the incoming task.\n\t\t */\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\n\t\t/* Enable the bitmap */\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\n\t/*\n\t * Make sure that the TSS limit is covering the IO bitmap. It might have\n\t * been cut down by a VMEXIT to 0x67 which would cause a subsequent I/O\n\t * access from user space to trigger a #GP because tbe bitmap is outside\n\t * the TSS limit.\n\t */\n\trefresh_tss_limit();\n}",
        "func": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\tnative_tss_invalidate_io_bitmap();\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\n\t\t/*\n\t\t * Only copy bitmap data when the sequence number differs. The\n\t\t * update time is accounted to the incoming task.\n\t\t */\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\n\t\t/* Enable the bitmap */\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\n\t/*\n\t * Make sure that the TSS limit is covering the IO bitmap. It might have\n\t * been cut down by a VMEXIT to 0x67 which would cause a subsequent I/O\n\t * access from user space to trigger a #GP because tbe bitmap is outside\n\t * the TSS limit.\n\t */\n\trefresh_tss_limit();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tu16 *base = &tss->x86_tss.io_bitmap_base;\n \n \tif (!test_thread_flag(TIF_IO_BITMAP)) {\n-\t\ttss_invalidate_io_bitmap(tss);\n+\t\tnative_tss_invalidate_io_bitmap();\n \t\treturn;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\ttss_invalidate_io_bitmap(tss);"
            ],
            "added_lines": [
                "\t\tnative_tss_invalidate_io_bitmap();"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15852",
        "func_name": "torvalds/linux/switch_to_bitmap",
        "description": "An issue was discovered in the Linux kernel 5.5 through 5.7.9, as used in Xen through 4.13.x for x86 PV guests. An attacker may be granted the I/O port permissions of an unrelated task. This occurs because tss_invalidate_io_bitmap mishandling causes a loss of synchronization between the I/O bitmaps of TSS and Xen, aka CID-cadfad870154.",
        "git_url": "https://github.com/torvalds/linux/commit/cadfad870154e14f745ec845708bc17d166065f2",
        "commit_title": "x86/ioperm: Fix io bitmap invalidation on Xen PV",
        "commit_text": " tss_invalidate_io_bitmap() wasn't wired up properly through the pvop machinery, so the TSS and Xen's io bitmap would get out of sync whenever disabling a valid io bitmap.  Add a new pvop for tss_invalidate_io_bitmap() to fix it.  This is XSA-329.  Cc: stable@vger.kernel.org Link: https://lkml.kernel.org/r/d53075590e1f91c19f8af705059d3ff99424c020.1595030016.git.luto@kernel.org",
        "func_before": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\t/*\n\t * Invalidate I/O bitmap if the previous task used it. This prevents\n\t * any possible leakage of an active I/O bitmap.\n\t *\n\t * If the next task has an I/O bitmap it will handle it on exit to\n\t * user mode.\n\t */\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}",
        "func": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\t/*\n\t * Invalidate I/O bitmap if the previous task used it. This prevents\n\t * any possible leakage of an active I/O bitmap.\n\t *\n\t * If the next task has an I/O bitmap it will handle it on exit to\n\t * user mode.\n\t */\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,5 +8,5 @@\n \t * user mode.\n \t */\n \tif (tifp & _TIF_IO_BITMAP)\n-\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n+\t\ttss_invalidate_io_bitmap();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));"
            ],
            "added_lines": [
                "\t\ttss_invalidate_io_bitmap();"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24716",
        "func_name": "openzfs/zfs/zfs_groupmember",
        "description": "OpenZFS before 2.0.0-rc1, when used on FreeBSD, allows execute permissions for all directories.",
        "git_url": "https://github.com/openzfs/zfs/commit/716b53d0a14c72bda16c0872565dd1909757e73f",
        "commit_title": "FreeBSD: Fix UNIX permissions checking",
        "commit_text": " Closes #10727",
        "func_before": "boolean_t\nzfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n#ifdef HAVE_KSID\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\tuid_t\t\tgid;\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\tuint32_t\trid = FUID_RID(id);\n\n\t\tksid_groups = ksidlist->ksl_sids;\n\n\t\tfor (i = 0; i != ksidlist->ksl_nsid; i++) {\n\t\t\tif (idx == 0) {\n\t\t\t\tif (id != IDMAP_WK_CREATOR_GROUP_GID &&\n\t\t\t\t    id == ksid_groups[i].ks_id) {\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *domain;\n\n\t\t\t\tdomain = zfs_fuid_find_by_idx(zfsvfs, idx);\n\t\t\t\tASSERT(domain != NULL);\n\n\t\t\t\tif (strcmp(domain,\n\t\t\t\t    IDMAP_WK_CREATOR_SID_AUTHORITY) == 0)\n\t\t\t\t\treturn (B_FALSE);\n\n\t\t\t\tif ((strcmp(domain,\n\t\t\t\t    ksid_groups[i].ks_domain->kd_name) == 0) &&\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Not found in ksidlist, check posix groups\n\t */\n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);\n\treturn (groupmember(gid, cr));\n#else\n\treturn (B_TRUE);\n#endif\n}",
        "func": "boolean_t\nzfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n#ifdef HAVE_KSID\n\tuid_t\t\tgid;\n\n#ifdef illumos\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\tuint32_t\trid = FUID_RID(id);\n\n\t\tksid_groups = ksidlist->ksl_sids;\n\n\t\tfor (i = 0; i != ksidlist->ksl_nsid; i++) {\n\t\t\tif (idx == 0) {\n\t\t\t\tif (id != IDMAP_WK_CREATOR_GROUP_GID &&\n\t\t\t\t    id == ksid_groups[i].ks_id) {\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *domain;\n\n\t\t\t\tdomain = zfs_fuid_find_by_idx(zfsvfs, idx);\n\t\t\t\tASSERT(domain != NULL);\n\n\t\t\t\tif (strcmp(domain,\n\t\t\t\t    IDMAP_WK_CREATOR_SID_AUTHORITY) == 0)\n\t\t\t\t\treturn (B_FALSE);\n\n\t\t\t\tif ((strcmp(domain,\n\t\t\t\t    ksid_groups[i].ks_domain->kd_name) == 0) &&\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n#endif /* illumos */\n\n\t/*\n\t * Not found in ksidlist, check posix groups\n\t */\n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);\n\treturn (groupmember(gid, cr));\n#else\n\treturn (B_TRUE);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,11 @@\n zfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n {\n #ifdef HAVE_KSID\n+\tuid_t\t\tgid;\n+\n+#ifdef illumos\n \tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n \tksidlist_t\t*ksidlist = crgetsidlist(cr);\n-\tuid_t\t\tgid;\n \n \tif (ksid && ksidlist) {\n \t\tint\t\ti;\n@@ -37,6 +39,7 @@\n \t\t\t}\n \t\t}\n \t}\n+#endif /* illumos */\n \n \t/*\n \t * Not found in ksidlist, check posix groups",
        "diff_line_info": {
            "deleted_lines": [
                "\tuid_t\t\tgid;"
            ],
            "added_lines": [
                "\tuid_t\t\tgid;",
                "",
                "#ifdef illumos",
                "#endif /* illumos */"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24716",
        "func_name": "openzfs/zfs/zfs_fuid_create",
        "description": "OpenZFS before 2.0.0-rc1, when used on FreeBSD, allows execute permissions for all directories.",
        "git_url": "https://github.com/openzfs/zfs/commit/716b53d0a14c72bda16c0872565dd1909757e73f",
        "commit_title": "FreeBSD: Fix UNIX permissions checking",
        "commit_text": " Closes #10727",
        "func_before": "uint64_t\nzfs_fuid_create(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr,\n    zfs_fuid_type_t type, zfs_fuid_info_t **fuidpp)\n{\n#ifdef HAVE_KSID\n\tconst char *domain;\n\tchar *kdomain;\n\tuint32_t fuid_idx = FUID_INDEX(id);\n\tuint32_t rid;\n\tidmap_stat status;\n\tuint64_t idx = 0;\n\tzfs_fuid_t *zfuid = NULL;\n\tzfs_fuid_info_t *fuidp = NULL;\n\n\t/*\n\t * If POSIX ID, or entry is already a FUID then\n\t * just return the id\n\t *\n\t * We may also be handed an already FUID'ized id via\n\t * chmod.\n\t */\n\n\tif (!zfsvfs->z_use_fuids || !IS_EPHEMERAL(id) || fuid_idx != 0)\n\t\treturn (id);\n\n\tif (zfsvfs->z_replay) {\n\t\tfuidp = zfsvfs->z_fuid_replay;\n\n\t\t/*\n\t\t * If we are passed an ephemeral id, but no\n\t\t * fuid_info was logged then return NOBODY.\n\t\t * This is most likely a result of idmap service\n\t\t * not being available.\n\t\t */\n\t\tif (fuidp == NULL)\n\t\t\treturn (UID_NOBODY);\n\n\t\tVERIFY3U(type, >=, ZFS_OWNER);\n\t\tVERIFY3U(type, <=, ZFS_ACE_GROUP);\n\n\t\tswitch (type) {\n\t\tcase ZFS_ACE_USER:\n\t\tcase ZFS_ACE_GROUP:\n\t\t\tzfuid = list_head(&fuidp->z_fuids);\n\t\t\trid = FUID_RID(zfuid->z_logfuid);\n\t\t\tidx = FUID_INDEX(zfuid->z_logfuid);\n\t\t\tbreak;\n\t\tcase ZFS_OWNER:\n\t\t\trid = FUID_RID(fuidp->z_fuid_owner);\n\t\t\tidx = FUID_INDEX(fuidp->z_fuid_owner);\n\t\t\tbreak;\n\t\tcase ZFS_GROUP:\n\t\t\trid = FUID_RID(fuidp->z_fuid_group);\n\t\t\tidx = FUID_INDEX(fuidp->z_fuid_group);\n\t\t\tbreak;\n\t\t};\n\t\tdomain = fuidp->z_domain_table[idx - 1];\n\t} else {\n\t\tif (type == ZFS_OWNER || type == ZFS_ACE_USER)\n\t\t\tstatus = kidmap_getsidbyuid(crgetzone(cr), id,\n\t\t\t    &domain, &rid);\n\t\telse\n\t\t\tstatus = kidmap_getsidbygid(crgetzone(cr), id,\n\t\t\t    &domain, &rid);\n\n\t\tif (status != 0) {\n\t\t\t/*\n\t\t\t * When returning nobody we will need to\n\t\t\t * make a dummy fuid table entry for logging\n\t\t\t * purposes.\n\t\t\t */\n\t\t\trid = UID_NOBODY;\n\t\t\tdomain = nulldomain;\n\t\t}\n\t}\n\n\tidx = zfs_fuid_find_by_domain(zfsvfs, domain, &kdomain, B_TRUE);\n\n\tif (!zfsvfs->z_replay)\n\t\tzfs_fuid_node_add(fuidpp, kdomain,\n\t\t    rid, idx, id, type);\n\telse if (zfuid != NULL) {\n\t\tlist_remove(&fuidp->z_fuids, zfuid);\n\t\tkmem_free(zfuid, sizeof (zfs_fuid_t));\n\t}\n\treturn (FUID_ENCODE(idx, rid));\n#else\n\t/*\n\t * The Linux port only supports POSIX IDs, use the passed id.\n\t */\n\treturn (id);\n#endif\n}",
        "func": "uint64_t\nzfs_fuid_create(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr,\n    zfs_fuid_type_t type, zfs_fuid_info_t **fuidpp)\n{\n#ifdef HAVE_KSID\n\tconst char *domain;\n\tchar *kdomain;\n\tuint32_t fuid_idx = FUID_INDEX(id);\n\tuint32_t rid = 0;\n\tidmap_stat status;\n\tuint64_t idx = UID_NOBODY;\n\tzfs_fuid_t *zfuid = NULL;\n\tzfs_fuid_info_t *fuidp = NULL;\n\n\t/*\n\t * If POSIX ID, or entry is already a FUID then\n\t * just return the id\n\t *\n\t * We may also be handed an already FUID'ized id via\n\t * chmod.\n\t */\n\n\tif (!zfsvfs->z_use_fuids || !IS_EPHEMERAL(id) || fuid_idx != 0)\n\t\treturn (id);\n\n\tif (zfsvfs->z_replay) {\n\t\tfuidp = zfsvfs->z_fuid_replay;\n\n\t\t/*\n\t\t * If we are passed an ephemeral id, but no\n\t\t * fuid_info was logged then return NOBODY.\n\t\t * This is most likely a result of idmap service\n\t\t * not being available.\n\t\t */\n\t\tif (fuidp == NULL)\n\t\t\treturn (UID_NOBODY);\n\n\t\tVERIFY3U(type, >=, ZFS_OWNER);\n\t\tVERIFY3U(type, <=, ZFS_ACE_GROUP);\n\n\t\tswitch (type) {\n\t\tcase ZFS_ACE_USER:\n\t\tcase ZFS_ACE_GROUP:\n\t\t\tzfuid = list_head(&fuidp->z_fuids);\n\t\t\trid = FUID_RID(zfuid->z_logfuid);\n\t\t\tidx = FUID_INDEX(zfuid->z_logfuid);\n\t\t\tbreak;\n\t\tcase ZFS_OWNER:\n\t\t\trid = FUID_RID(fuidp->z_fuid_owner);\n\t\t\tidx = FUID_INDEX(fuidp->z_fuid_owner);\n\t\t\tbreak;\n\t\tcase ZFS_GROUP:\n\t\t\trid = FUID_RID(fuidp->z_fuid_group);\n\t\t\tidx = FUID_INDEX(fuidp->z_fuid_group);\n\t\t\tbreak;\n\t\t};\n\t\tdomain = fuidp->z_domain_table[idx - 1];\n\t} else {\n\t\tif (type == ZFS_OWNER || type == ZFS_ACE_USER)\n\t\t\tstatus = kidmap_getsidbyuid(crgetzone(cr), id,\n\t\t\t    &domain, &rid);\n\t\telse\n\t\t\tstatus = kidmap_getsidbygid(crgetzone(cr), id,\n\t\t\t    &domain, &rid);\n\n\t\tif (status != 0) {\n\t\t\t/*\n\t\t\t * When returning nobody we will need to\n\t\t\t * make a dummy fuid table entry for logging\n\t\t\t * purposes.\n\t\t\t */\n\t\t\trid = UID_NOBODY;\n\t\t\tdomain = nulldomain;\n\t\t}\n\t}\n\n\tidx = zfs_fuid_find_by_domain(zfsvfs, domain, &kdomain, B_TRUE);\n\n\tif (!zfsvfs->z_replay)\n\t\tzfs_fuid_node_add(fuidpp, kdomain,\n\t\t    rid, idx, id, type);\n\telse if (zfuid != NULL) {\n\t\tlist_remove(&fuidp->z_fuids, zfuid);\n\t\tkmem_free(zfuid, sizeof (zfs_fuid_t));\n\t}\n\treturn (FUID_ENCODE(idx, rid));\n#else\n\t/*\n\t * The Linux port only supports POSIX IDs, use the passed id.\n\t */\n\treturn (id);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,9 +6,9 @@\n \tconst char *domain;\n \tchar *kdomain;\n \tuint32_t fuid_idx = FUID_INDEX(id);\n-\tuint32_t rid;\n+\tuint32_t rid = 0;\n \tidmap_stat status;\n-\tuint64_t idx = 0;\n+\tuint64_t idx = UID_NOBODY;\n \tzfs_fuid_t *zfuid = NULL;\n \tzfs_fuid_info_t *fuidp = NULL;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tuint32_t rid;",
                "\tuint64_t idx = 0;"
            ],
            "added_lines": [
                "\tuint32_t rid = 0;",
                "\tuint64_t idx = UID_NOBODY;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24716",
        "func_name": "openzfs/zfs/zfs_fuid_map_id",
        "description": "OpenZFS before 2.0.0-rc1, when used on FreeBSD, allows execute permissions for all directories.",
        "git_url": "https://github.com/openzfs/zfs/commit/716b53d0a14c72bda16c0872565dd1909757e73f",
        "commit_title": "FreeBSD: Fix UNIX permissions checking",
        "commit_text": " Closes #10727",
        "func_before": "uid_t\nzfs_fuid_map_id(zfsvfs_t *zfsvfs, uint64_t fuid,\n    cred_t *cr, zfs_fuid_type_t type)\n{\n#ifdef HAVE_KSID\n\tuint32_t index = FUID_INDEX(fuid);\n\tconst char *domain;\n\tuid_t id;\n\n\tif (index == 0)\n\t\treturn (fuid);\n\n\tdomain = zfs_fuid_find_by_idx(zfsvfs, index);\n\tASSERT(domain != NULL);\n\n\tif (type == ZFS_OWNER || type == ZFS_ACE_USER) {\n\t\t(void) kidmap_getuidbysid(crgetzone(cr), domain,\n\t\t    FUID_RID(fuid), &id);\n\t} else {\n\t\t(void) kidmap_getgidbysid(crgetzone(cr), domain,\n\t\t    FUID_RID(fuid), &id);\n\t}\n\treturn (id);\n#else\n\t/*\n\t * The Linux port only supports POSIX IDs, use the passed id.\n\t */\n\treturn (fuid);\n#endif /* HAVE_KSID */\n}",
        "func": "uid_t\nzfs_fuid_map_id(zfsvfs_t *zfsvfs, uint64_t fuid,\n    cred_t *cr, zfs_fuid_type_t type)\n{\n\tuint32_t index = FUID_INDEX(fuid);\n\n\tif (index == 0)\n\t\treturn (fuid);\n\n\treturn (UID_NOBODY);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,29 +2,10 @@\n zfs_fuid_map_id(zfsvfs_t *zfsvfs, uint64_t fuid,\n     cred_t *cr, zfs_fuid_type_t type)\n {\n-#ifdef HAVE_KSID\n \tuint32_t index = FUID_INDEX(fuid);\n-\tconst char *domain;\n-\tuid_t id;\n \n \tif (index == 0)\n \t\treturn (fuid);\n \n-\tdomain = zfs_fuid_find_by_idx(zfsvfs, index);\n-\tASSERT(domain != NULL);\n-\n-\tif (type == ZFS_OWNER || type == ZFS_ACE_USER) {\n-\t\t(void) kidmap_getuidbysid(crgetzone(cr), domain,\n-\t\t    FUID_RID(fuid), &id);\n-\t} else {\n-\t\t(void) kidmap_getgidbysid(crgetzone(cr), domain,\n-\t\t    FUID_RID(fuid), &id);\n-\t}\n-\treturn (id);\n-#else\n-\t/*\n-\t * The Linux port only supports POSIX IDs, use the passed id.\n-\t */\n-\treturn (fuid);\n-#endif /* HAVE_KSID */\n+\treturn (UID_NOBODY);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef HAVE_KSID",
                "\tconst char *domain;",
                "\tuid_t id;",
                "\tdomain = zfs_fuid_find_by_idx(zfsvfs, index);",
                "\tASSERT(domain != NULL);",
                "",
                "\tif (type == ZFS_OWNER || type == ZFS_ACE_USER) {",
                "\t\t(void) kidmap_getuidbysid(crgetzone(cr), domain,",
                "\t\t    FUID_RID(fuid), &id);",
                "\t} else {",
                "\t\t(void) kidmap_getgidbysid(crgetzone(cr), domain,",
                "\t\t    FUID_RID(fuid), &id);",
                "\t}",
                "\treturn (id);",
                "#else",
                "\t/*",
                "\t * The Linux port only supports POSIX IDs, use the passed id.",
                "\t */",
                "\treturn (fuid);",
                "#endif /* HAVE_KSID */"
            ],
            "added_lines": [
                "\treturn (UID_NOBODY);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24716",
        "func_name": "openzfs/zfs/zfs_fastaccesschk_execute",
        "description": "OpenZFS before 2.0.0-rc1, when used on FreeBSD, allows execute permissions for all directories.",
        "git_url": "https://github.com/openzfs/zfs/commit/716b53d0a14c72bda16c0872565dd1909757e73f",
        "commit_title": "FreeBSD: Fix UNIX permissions checking",
        "commit_text": " Closes #10727",
        "func_before": "int\nzfs_fastaccesschk_execute(znode_t *zdp, cred_t *cr)\n{\n\tboolean_t owner = B_FALSE;\n\tboolean_t groupmbr = B_FALSE;\n\tboolean_t is_attr;\n\tuid_t uid = crgetuid(cr);\n\n\tif (zdp->z_pflags & ZFS_AV_QUARANTINED)\n\t\treturn (1);\n\n\tis_attr = ((zdp->z_pflags & ZFS_XATTR) &&\n\t    (ZTOV(zdp)->v_type == VDIR));\n\tif (is_attr)\n\t\treturn (1);\n\n\tif (zdp->z_pflags & ZFS_NO_EXECS_DENIED)\n\t\treturn (0);\n\n\tmutex_enter(&zdp->z_acl_lock);\n\tif (FUID_INDEX(zdp->z_uid) != 0 || FUID_INDEX(zdp->z_gid) != 0) {\n\t\tgoto out_slow;\n\t}\n\n\tif (uid == zdp->z_uid) {\n\t\towner = B_TRUE;\n\t\tif (zdp->z_mode & S_IXUSR) {\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto out_slow;\n\t\t}\n\t}\n\tif (groupmember(zdp->z_gid, cr)) {\n\t\tgroupmbr = B_TRUE;\n\t\tif (zdp->z_mode & S_IXGRP) {\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto out_slow;\n\t\t}\n\t}\n\tif (!owner && !groupmbr) {\n\t\tif (zdp->z_mode & S_IXOTH) {\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tmutex_exit(&zdp->z_acl_lock);\n\treturn (0);\nout_slow:\n\tmutex_exit(&zdp->z_acl_lock);\n\treturn (1);\n}",
        "func": "int\nzfs_fastaccesschk_execute(znode_t *zdp, cred_t *cr)\n{\n\tboolean_t is_attr;\n\n\tif (zdp->z_pflags & ZFS_AV_QUARANTINED)\n\t\treturn (1);\n\n\tis_attr = ((zdp->z_pflags & ZFS_XATTR) &&\n\t    (ZTOV(zdp)->v_type == VDIR));\n\tif (is_attr)\n\t\treturn (1);\n\n\tif (zdp->z_pflags & ZFS_NO_EXECS_DENIED)\n\t\treturn (0);\n\n\treturn (1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,7 @@\n int\n zfs_fastaccesschk_execute(znode_t *zdp, cred_t *cr)\n {\n-\tboolean_t owner = B_FALSE;\n-\tboolean_t groupmbr = B_FALSE;\n \tboolean_t is_attr;\n-\tuid_t uid = crgetuid(cr);\n \n \tif (zdp->z_pflags & ZFS_AV_QUARANTINED)\n \t\treturn (1);\n@@ -17,36 +14,5 @@\n \tif (zdp->z_pflags & ZFS_NO_EXECS_DENIED)\n \t\treturn (0);\n \n-\tmutex_enter(&zdp->z_acl_lock);\n-\tif (FUID_INDEX(zdp->z_uid) != 0 || FUID_INDEX(zdp->z_gid) != 0) {\n-\t\tgoto out_slow;\n-\t}\n-\n-\tif (uid == zdp->z_uid) {\n-\t\towner = B_TRUE;\n-\t\tif (zdp->z_mode & S_IXUSR) {\n-\t\t\tgoto out;\n-\t\t} else {\n-\t\t\tgoto out_slow;\n-\t\t}\n-\t}\n-\tif (groupmember(zdp->z_gid, cr)) {\n-\t\tgroupmbr = B_TRUE;\n-\t\tif (zdp->z_mode & S_IXGRP) {\n-\t\t\tgoto out;\n-\t\t} else {\n-\t\t\tgoto out_slow;\n-\t\t}\n-\t}\n-\tif (!owner && !groupmbr) {\n-\t\tif (zdp->z_mode & S_IXOTH) {\n-\t\t\tgoto out;\n-\t\t}\n-\t}\n-out:\n-\tmutex_exit(&zdp->z_acl_lock);\n-\treturn (0);\n-out_slow:\n-\tmutex_exit(&zdp->z_acl_lock);\n \treturn (1);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tboolean_t owner = B_FALSE;",
                "\tboolean_t groupmbr = B_FALSE;",
                "\tuid_t uid = crgetuid(cr);",
                "\tmutex_enter(&zdp->z_acl_lock);",
                "\tif (FUID_INDEX(zdp->z_uid) != 0 || FUID_INDEX(zdp->z_gid) != 0) {",
                "\t\tgoto out_slow;",
                "\t}",
                "",
                "\tif (uid == zdp->z_uid) {",
                "\t\towner = B_TRUE;",
                "\t\tif (zdp->z_mode & S_IXUSR) {",
                "\t\t\tgoto out;",
                "\t\t} else {",
                "\t\t\tgoto out_slow;",
                "\t\t}",
                "\t}",
                "\tif (groupmember(zdp->z_gid, cr)) {",
                "\t\tgroupmbr = B_TRUE;",
                "\t\tif (zdp->z_mode & S_IXGRP) {",
                "\t\t\tgoto out;",
                "\t\t} else {",
                "\t\t\tgoto out_slow;",
                "\t\t}",
                "\t}",
                "\tif (!owner && !groupmbr) {",
                "\t\tif (zdp->z_mode & S_IXOTH) {",
                "\t\t\tgoto out;",
                "\t\t}",
                "\t}",
                "out:",
                "\tmutex_exit(&zdp->z_acl_lock);",
                "\treturn (0);",
                "out_slow:",
                "\tmutex_exit(&zdp->z_acl_lock);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-34182",
        "func_name": "tsl0922/ttyd/main",
        "description": "An issue in ttyd v.1.6.3 allows attacker to execute arbitrary code via default configuration permissions.",
        "git_url": "https://github.com/tsl0922/ttyd/commit/39206089c0094dcf075e07b19e7eda9ada47d020",
        "commit_title": "server: do not expose port to public by default",
        "commit_text": " CVE-2021-34182 #692",
        "func_before": "int main(int argc, char **argv) {\n  if (argc == 1) {\n    print_help();\n    return 0;\n  }\n#ifdef _WIN32\n  if (!conpty_init()) {\n    fprintf(stderr, \"ERROR: ConPTY init failed! Make sure you are on Windows 10 1809 or later.\");\n    return 1;\n  }\n#endif\n\n  int start = calc_command_start(argc, argv);\n  server = server_new(argc, argv, start);\n\n  struct lws_context_creation_info info;\n  memset(&info, 0, sizeof(info));\n  info.port = 7681;\n  info.iface = NULL;\n  info.protocols = protocols;\n  info.gid = -1;\n  info.uid = -1;\n  info.max_http_header_pool = 16;\n  info.options = LWS_SERVER_OPTION_LIBUV | LWS_SERVER_OPTION_VALIDATE_UTF8 | LWS_SERVER_OPTION_DISABLE_IPV6;\n#ifndef LWS_WITHOUT_EXTENSIONS\n  info.extensions = extensions;\n#endif\n  info.max_http_header_data = 65535;\n\n  int debug_level = LLL_ERR | LLL_WARN | LLL_NOTICE;\n  char iface[128] = \"\";\n  char socket_owner[128] = \"\";\n  bool browser = false;\n  bool ssl = false;\n  char cert_path[1024] = \"\";\n  char key_path[1024] = \"\";\n  char ca_path[1024] = \"\";\n\n  struct json_object *client_prefs = json_object_new_object();\n\n#ifdef _WIN32\n  json_object_object_add(client_prefs, \"isWindows\", json_object_new_boolean(true));\n#endif\n\n  // parse command line options\n  int c;\n  while ((c = getopt_long(start, argv, opt_string, options, NULL)) != -1) {\n    switch (c) {\n      case 'h':\n        print_help();\n        return 0;\n      case 'v':\n        printf(\"ttyd version %s\\n\", TTYD_VERSION);\n        return 0;\n      case 'd':\n        debug_level = parse_int(\"debug\", optarg);\n        break;\n      case 'a':\n        server->url_arg = true;\n        break;\n      case 'R':\n        server->readonly = true;\n        break;\n      case 'O':\n        server->check_origin = true;\n        break;\n      case 'm':\n        server->max_clients = parse_int(\"max-clients\", optarg);\n        break;\n      case 'o':\n        server->once = true;\n        break;\n      case 'B':\n        browser = true;\n        break;\n      case 'p':\n        info.port = parse_int(\"port\", optarg);\n        if (info.port < 0) {\n          fprintf(stderr, \"ttyd: invalid port: %s\\n\", optarg);\n          return -1;\n        }\n        break;\n      case 'i':\n        strncpy(iface, optarg, sizeof(iface) - 1);\n        iface[sizeof(iface) - 1] = '\\0';\n        break;\n      case 'U':\n        strncpy(socket_owner, optarg, sizeof(socket_owner) - 1);\n        socket_owner[sizeof(socket_owner) - 1] = '\\0';\n        break;\n      case 'c':\n        if (strchr(optarg, ':') == NULL) {\n          fprintf(stderr, \"ttyd: invalid credential, format: username:password\\n\");\n          return -1;\n        }\n        char b64_text[256];\n        lws_b64_encode_string(optarg, strlen(optarg), b64_text, sizeof(b64_text));\n        server->credential = strdup(b64_text);\n        break;\n      case 'H':\n        server->auth_header = strdup(optarg);\n        break;\n      case 'u':\n        info.uid = parse_int(\"uid\", optarg);\n        break;\n      case 'g':\n        info.gid = parse_int(\"gid\", optarg);\n        break;\n      case 's': {\n        int sig = get_sig(optarg);\n        if (sig > 0) {\n          server->sig_code = sig;\n          get_sig_name(sig, server->sig_name, sizeof(server->sig_name));\n        } else {\n          fprintf(stderr, \"ttyd: invalid signal: %s\\n\", optarg);\n          return -1;\n        }\n      } break;\n      case 'w':\n        server->cwd = strdup(optarg);\n        break;\n      case 'I':\n        if (!strncmp(optarg, \"~/\", 2)) {\n          const char *home = getenv(\"HOME\");\n          server->index = malloc(strlen(home) + strlen(optarg) - 1);\n          sprintf(server->index, \"%s%s\", home, optarg + 1);\n        } else {\n          server->index = strdup(optarg);\n        }\n        struct stat st;\n        if (stat(server->index, &st) == -1) {\n          fprintf(stderr, \"Can not stat index.html: %s, error: %s\\n\", server->index, strerror(errno));\n          return -1;\n        }\n        if (S_ISDIR(st.st_mode)) {\n          fprintf(stderr, \"Invalid index.html path: %s, is it a dir?\\n\", server->index);\n          return -1;\n        }\n        break;\n      case 'b': {\n        char path[128];\n        strncpy(path, optarg, 128);\n        size_t len = strlen(path);\n        while (len && path[len - 1] == '/') path[--len] = 0;  // trim trailing /\n        if (!len) break;\n#define sc(f)                                  \\\n  strncpy(path + len, endpoints.f, 128 - len); \\\n  endpoints.f = strdup(path);\n        sc(ws) sc(index) sc(token) sc(parent)\n#undef sc\n      } break;\n#if LWS_LIBRARY_VERSION_NUMBER >= 4000000\n      case 'P': {\n        int interval = parse_int(\"ping-interval\", optarg);\n        if (interval < 0) {\n          fprintf(stderr, \"ttyd: invalid ping interval: %s\\n\", optarg);\n          return -1;\n        }\n        retry.secs_since_valid_ping = interval;\n        retry.secs_since_valid_hangup = interval + 7;\n      } break;\n#endif\n      case '6':\n        info.options &= ~(LWS_SERVER_OPTION_DISABLE_IPV6);\n        break;\n#if defined(LWS_OPENSSL_SUPPORT) || defined(LWS_WITH_TLS)\n      case 'S':\n        ssl = true;\n        break;\n      case 'C':\n        strncpy(cert_path, optarg, sizeof(cert_path) - 1);\n        cert_path[sizeof(cert_path) - 1] = '\\0';\n        break;\n      case 'K':\n        strncpy(key_path, optarg, sizeof(key_path) - 1);\n        key_path[sizeof(key_path) - 1] = '\\0';\n        break;\n      case 'A':\n        strncpy(ca_path, optarg, sizeof(ca_path) - 1);\n        ca_path[sizeof(ca_path) - 1] = '\\0';\n        break;\n#endif\n      case 'T':\n        strncpy(server->terminal_type, optarg, sizeof(server->terminal_type) - 1);\n        server->terminal_type[sizeof(server->terminal_type) - 1] = '\\0';\n        break;\n      case '?':\n        break;\n      case 't':\n        optind--;\n        for (; optind < start && *argv[optind] != '-'; optind++) {\n          char *option = optarg;\n          char *key = strsep(&option, \"=\");\n          if (key == NULL) {\n            fprintf(stderr, \"ttyd: invalid client option: %s, format: key=value\\n\", optarg);\n            return -1;\n          }\n          char *value = strsep(&option, \"=\");\n          if (value == NULL) {\n            fprintf(stderr, \"ttyd: invalid client option: %s, format: key=value\\n\", optarg);\n            return -1;\n          }\n          struct json_object *obj = json_tokener_parse(value);\n          json_object_object_add(client_prefs, key, obj != NULL ? obj : json_object_new_string(value));\n        }\n        break;\n      default:\n        print_help();\n        return -1;\n    }\n  }\n  server->prefs_json = strdup(json_object_to_json_string(client_prefs));\n  json_object_put(client_prefs);\n\n  if (server->command == NULL || strlen(server->command) == 0) {\n    fprintf(stderr, \"ttyd: missing start command\\n\");\n    return -1;\n  }\n\n  lws_set_log_level(debug_level, NULL);\n\n  char server_hdr[128] = \"\";\n  sprintf(server_hdr, \"ttyd/%s (libwebsockets/%s)\", TTYD_VERSION, LWS_LIBRARY_VERSION);\n  info.server_string = server_hdr;\n\n#if LWS_LIBRARY_VERSION_NUMBER < 4000000\n  info.ws_ping_pong_interval = 5;\n#else\n  info.retry_and_idle_policy = &retry;\n#endif\n\n  if (strlen(iface) > 0) {\n    info.iface = iface;\n    if (endswith(info.iface, \".sock\") || endswith(info.iface, \".socket\")) {\n#if defined(LWS_USE_UNIX_SOCK) || defined(LWS_WITH_UNIX_SOCK)\n      info.options |= LWS_SERVER_OPTION_UNIX_SOCK;\n      info.port = 0;  // warmcat/libwebsockets#1985\n      strncpy(server->socket_path, info.iface, sizeof(server->socket_path) - 1);\n      if (strlen(socket_owner) > 0) {\n        info.unix_socket_perms = socket_owner;\n      }\n#else\n      fprintf(stderr, \"libwebsockets is not compiled with UNIX domain socket support\");\n      return -1;\n#endif\n    }\n  }\n\n#if defined(LWS_OPENSSL_SUPPORT) || defined(LWS_WITH_TLS)\n  if (ssl) {\n    info.ssl_cert_filepath = cert_path;\n    info.ssl_private_key_filepath = key_path;\n    #ifndef LWS_WITH_MBEDTLS\n    info.ssl_options_set = SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1;\n    #endif\n    if (strlen(ca_path) > 0) {\n      info.ssl_ca_filepath = ca_path;\n      info.options |= LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT;\n    }\n    info.options |= LWS_SERVER_OPTION_ALLOW_NON_SSL_ON_SSL_PORT | LWS_SERVER_OPTION_REDIRECT_HTTP_TO_HTTPS;\n  }\n#endif\n\n  lwsl_notice(\"ttyd %s (libwebsockets %s)\\n\", TTYD_VERSION, LWS_LIBRARY_VERSION);\n  print_config();\n\n  // lws custom header requires lower case name, and terminating :\n  if (server->auth_header != NULL) {\n    size_t auth_header_len = strlen(server->auth_header);\n    server->auth_header = xrealloc(server->auth_header, auth_header_len + 2);\n    strcat(server->auth_header + auth_header_len, \":\");\n    lowercase(server->auth_header);\n  }\n\n  void *foreign_loops[1];\n  foreign_loops[0] = server->loop;\n  info.foreign_loops = foreign_loops;\n  info.options |= LWS_SERVER_OPTION_EXPLICIT_VHOSTS;\n\n  context = lws_create_context(&info);\n  if (context == NULL) {\n    lwsl_err(\"libwebsockets context creation failed\\n\");\n    return 1;\n  }\n\n  struct lws_vhost *vhost = lws_create_vhost(context, &info);\n  if (vhost == NULL) {\n    lwsl_err(\"libwebsockets vhost creation failed\\n\");\n    return 1;\n  }\n  int port = lws_get_vhost_listen_port(vhost);\n  lwsl_notice(\" Listening on port: %d\\n\", port);\n\n  if (browser) {\n    char url[30];\n    sprintf(url, \"%s://localhost:%d\", ssl ? \"https\" : \"http\", port);\n    open_uri(url);\n  }\n\n#define sig_count 2\n  int sig_nums[] = {SIGINT, SIGTERM};\n  uv_signal_t signals[sig_count];\n  for (int i = 0; i < sig_count; i++) {\n    uv_signal_init(server->loop, &signals[i]);\n    uv_signal_start(&signals[i], signal_cb, sig_nums[i]);\n  }\n\n  lws_service(context, 0);\n\n  for (int i = 0; i < sig_count; i++) {\n    uv_signal_stop(&signals[i]);\n  }\n#undef sig_count\n\n  lws_context_destroy(context);\n\n  // cleanup\n  server_free(server);\n\n  return 0;\n}",
        "func": "int main(int argc, char **argv) {\n  if (argc == 1) {\n    print_help();\n    return 0;\n  }\n#ifdef _WIN32\n  if (!conpty_init()) {\n    fprintf(stderr, \"ERROR: ConPTY init failed! Make sure you are on Windows 10 1809 or later.\");\n    return 1;\n  }\n#endif\n\n  int start = calc_command_start(argc, argv);\n  server = server_new(argc, argv, start);\n\n  struct lws_context_creation_info info;\n  memset(&info, 0, sizeof(info));\n  info.port = 7681;\n  info.iface = NULL;\n  info.protocols = protocols;\n  info.gid = -1;\n  info.uid = -1;\n  info.max_http_header_pool = 16;\n  info.options = LWS_SERVER_OPTION_LIBUV | LWS_SERVER_OPTION_VALIDATE_UTF8 | LWS_SERVER_OPTION_DISABLE_IPV6;\n#ifndef LWS_WITHOUT_EXTENSIONS\n  info.extensions = extensions;\n#endif\n  info.max_http_header_data = 65535;\n\n  int debug_level = LLL_ERR | LLL_WARN | LLL_NOTICE;\n  char iface[128] = \"127.0.0.1\";\n  char socket_owner[128] = \"\";\n  bool browser = false;\n  bool ssl = false;\n  char cert_path[1024] = \"\";\n  char key_path[1024] = \"\";\n  char ca_path[1024] = \"\";\n\n  struct json_object *client_prefs = json_object_new_object();\n\n#ifdef _WIN32\n  json_object_object_add(client_prefs, \"isWindows\", json_object_new_boolean(true));\n#endif\n\n  // parse command line options\n  int c;\n  while ((c = getopt_long(start, argv, opt_string, options, NULL)) != -1) {\n    switch (c) {\n      case 'h':\n        print_help();\n        return 0;\n      case 'v':\n        printf(\"ttyd version %s\\n\", TTYD_VERSION);\n        return 0;\n      case 'd':\n        debug_level = parse_int(\"debug\", optarg);\n        break;\n      case 'a':\n        server->url_arg = true;\n        break;\n      case 'R':\n        server->readonly = true;\n        break;\n      case 'O':\n        server->check_origin = true;\n        break;\n      case 'm':\n        server->max_clients = parse_int(\"max-clients\", optarg);\n        break;\n      case 'o':\n        server->once = true;\n        break;\n      case 'B':\n        browser = true;\n        break;\n      case 'p':\n        info.port = parse_int(\"port\", optarg);\n        if (info.port < 0) {\n          fprintf(stderr, \"ttyd: invalid port: %s\\n\", optarg);\n          return -1;\n        }\n        break;\n      case 'i':\n        strncpy(iface, optarg, sizeof(iface) - 1);\n        iface[sizeof(iface) - 1] = '\\0';\n        break;\n      case 'U':\n        strncpy(socket_owner, optarg, sizeof(socket_owner) - 1);\n        socket_owner[sizeof(socket_owner) - 1] = '\\0';\n        break;\n      case 'c':\n        if (strchr(optarg, ':') == NULL) {\n          fprintf(stderr, \"ttyd: invalid credential, format: username:password\\n\");\n          return -1;\n        }\n        char b64_text[256];\n        lws_b64_encode_string(optarg, strlen(optarg), b64_text, sizeof(b64_text));\n        server->credential = strdup(b64_text);\n        break;\n      case 'H':\n        server->auth_header = strdup(optarg);\n        break;\n      case 'u':\n        info.uid = parse_int(\"uid\", optarg);\n        break;\n      case 'g':\n        info.gid = parse_int(\"gid\", optarg);\n        break;\n      case 's': {\n        int sig = get_sig(optarg);\n        if (sig > 0) {\n          server->sig_code = sig;\n          get_sig_name(sig, server->sig_name, sizeof(server->sig_name));\n        } else {\n          fprintf(stderr, \"ttyd: invalid signal: %s\\n\", optarg);\n          return -1;\n        }\n      } break;\n      case 'w':\n        server->cwd = strdup(optarg);\n        break;\n      case 'I':\n        if (!strncmp(optarg, \"~/\", 2)) {\n          const char *home = getenv(\"HOME\");\n          server->index = malloc(strlen(home) + strlen(optarg) - 1);\n          sprintf(server->index, \"%s%s\", home, optarg + 1);\n        } else {\n          server->index = strdup(optarg);\n        }\n        struct stat st;\n        if (stat(server->index, &st) == -1) {\n          fprintf(stderr, \"Can not stat index.html: %s, error: %s\\n\", server->index, strerror(errno));\n          return -1;\n        }\n        if (S_ISDIR(st.st_mode)) {\n          fprintf(stderr, \"Invalid index.html path: %s, is it a dir?\\n\", server->index);\n          return -1;\n        }\n        break;\n      case 'b': {\n        char path[128];\n        strncpy(path, optarg, 128);\n        size_t len = strlen(path);\n        while (len && path[len - 1] == '/') path[--len] = 0;  // trim trailing /\n        if (!len) break;\n#define sc(f)                                  \\\n  strncpy(path + len, endpoints.f, 128 - len); \\\n  endpoints.f = strdup(path);\n        sc(ws) sc(index) sc(token) sc(parent)\n#undef sc\n      } break;\n#if LWS_LIBRARY_VERSION_NUMBER >= 4000000\n      case 'P': {\n        int interval = parse_int(\"ping-interval\", optarg);\n        if (interval < 0) {\n          fprintf(stderr, \"ttyd: invalid ping interval: %s\\n\", optarg);\n          return -1;\n        }\n        retry.secs_since_valid_ping = interval;\n        retry.secs_since_valid_hangup = interval + 7;\n      } break;\n#endif\n      case '6':\n        info.options &= ~(LWS_SERVER_OPTION_DISABLE_IPV6);\n        break;\n#if defined(LWS_OPENSSL_SUPPORT) || defined(LWS_WITH_TLS)\n      case 'S':\n        ssl = true;\n        break;\n      case 'C':\n        strncpy(cert_path, optarg, sizeof(cert_path) - 1);\n        cert_path[sizeof(cert_path) - 1] = '\\0';\n        break;\n      case 'K':\n        strncpy(key_path, optarg, sizeof(key_path) - 1);\n        key_path[sizeof(key_path) - 1] = '\\0';\n        break;\n      case 'A':\n        strncpy(ca_path, optarg, sizeof(ca_path) - 1);\n        ca_path[sizeof(ca_path) - 1] = '\\0';\n        break;\n#endif\n      case 'T':\n        strncpy(server->terminal_type, optarg, sizeof(server->terminal_type) - 1);\n        server->terminal_type[sizeof(server->terminal_type) - 1] = '\\0';\n        break;\n      case '?':\n        break;\n      case 't':\n        optind--;\n        for (; optind < start && *argv[optind] != '-'; optind++) {\n          char *option = optarg;\n          char *key = strsep(&option, \"=\");\n          if (key == NULL) {\n            fprintf(stderr, \"ttyd: invalid client option: %s, format: key=value\\n\", optarg);\n            return -1;\n          }\n          char *value = strsep(&option, \"=\");\n          if (value == NULL) {\n            fprintf(stderr, \"ttyd: invalid client option: %s, format: key=value\\n\", optarg);\n            return -1;\n          }\n          struct json_object *obj = json_tokener_parse(value);\n          json_object_object_add(client_prefs, key, obj != NULL ? obj : json_object_new_string(value));\n        }\n        break;\n      default:\n        print_help();\n        return -1;\n    }\n  }\n  server->prefs_json = strdup(json_object_to_json_string(client_prefs));\n  json_object_put(client_prefs);\n\n  if (server->command == NULL || strlen(server->command) == 0) {\n    fprintf(stderr, \"ttyd: missing start command\\n\");\n    return -1;\n  }\n\n  lws_set_log_level(debug_level, NULL);\n\n  char server_hdr[128] = \"\";\n  sprintf(server_hdr, \"ttyd/%s (libwebsockets/%s)\", TTYD_VERSION, LWS_LIBRARY_VERSION);\n  info.server_string = server_hdr;\n\n#if LWS_LIBRARY_VERSION_NUMBER < 4000000\n  info.ws_ping_pong_interval = 5;\n#else\n  info.retry_and_idle_policy = &retry;\n#endif\n\n  if (strlen(iface) > 0) {\n    info.iface = iface;\n    if (endswith(info.iface, \".sock\") || endswith(info.iface, \".socket\")) {\n#if defined(LWS_USE_UNIX_SOCK) || defined(LWS_WITH_UNIX_SOCK)\n      info.options |= LWS_SERVER_OPTION_UNIX_SOCK;\n      info.port = 0;  // warmcat/libwebsockets#1985\n      strncpy(server->socket_path, info.iface, sizeof(server->socket_path) - 1);\n      if (strlen(socket_owner) > 0) {\n        info.unix_socket_perms = socket_owner;\n      }\n#else\n      fprintf(stderr, \"libwebsockets is not compiled with UNIX domain socket support\");\n      return -1;\n#endif\n    }\n  }\n\n#if defined(LWS_OPENSSL_SUPPORT) || defined(LWS_WITH_TLS)\n  if (ssl) {\n    info.ssl_cert_filepath = cert_path;\n    info.ssl_private_key_filepath = key_path;\n    #ifndef LWS_WITH_MBEDTLS\n    info.ssl_options_set = SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1;\n    #endif\n    if (strlen(ca_path) > 0) {\n      info.ssl_ca_filepath = ca_path;\n      info.options |= LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT;\n    }\n    info.options |= LWS_SERVER_OPTION_ALLOW_NON_SSL_ON_SSL_PORT | LWS_SERVER_OPTION_REDIRECT_HTTP_TO_HTTPS;\n  }\n#endif\n\n  lwsl_notice(\"ttyd %s (libwebsockets %s)\\n\", TTYD_VERSION, LWS_LIBRARY_VERSION);\n  print_config();\n\n  // lws custom header requires lower case name, and terminating :\n  if (server->auth_header != NULL) {\n    size_t auth_header_len = strlen(server->auth_header);\n    server->auth_header = xrealloc(server->auth_header, auth_header_len + 2);\n    strcat(server->auth_header + auth_header_len, \":\");\n    lowercase(server->auth_header);\n  }\n\n  void *foreign_loops[1];\n  foreign_loops[0] = server->loop;\n  info.foreign_loops = foreign_loops;\n  info.options |= LWS_SERVER_OPTION_EXPLICIT_VHOSTS;\n\n  context = lws_create_context(&info);\n  if (context == NULL) {\n    lwsl_err(\"libwebsockets context creation failed\\n\");\n    return 1;\n  }\n\n  struct lws_vhost *vhost = lws_create_vhost(context, &info);\n  if (vhost == NULL) {\n    lwsl_err(\"libwebsockets vhost creation failed\\n\");\n    return 1;\n  }\n  int port = lws_get_vhost_listen_port(vhost);\n  lwsl_notice(\" Listening on port: %d\\n\", port);\n\n  if (browser) {\n    char url[30];\n    sprintf(url, \"%s://localhost:%d\", ssl ? \"https\" : \"http\", port);\n    open_uri(url);\n  }\n\n#define sig_count 2\n  int sig_nums[] = {SIGINT, SIGTERM};\n  uv_signal_t signals[sig_count];\n  for (int i = 0; i < sig_count; i++) {\n    uv_signal_init(server->loop, &signals[i]);\n    uv_signal_start(&signals[i], signal_cb, sig_nums[i]);\n  }\n\n  lws_service(context, 0);\n\n  for (int i = 0; i < sig_count; i++) {\n    uv_signal_stop(&signals[i]);\n  }\n#undef sig_count\n\n  lws_context_destroy(context);\n\n  // cleanup\n  server_free(server);\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n   info.max_http_header_data = 65535;\n \n   int debug_level = LLL_ERR | LLL_WARN | LLL_NOTICE;\n-  char iface[128] = \"\";\n+  char iface[128] = \"127.0.0.1\";\n   char socket_owner[128] = \"\";\n   bool browser = false;\n   bool ssl = false;",
        "diff_line_info": {
            "deleted_lines": [
                "  char iface[128] = \"\";"
            ],
            "added_lines": [
                "  char iface[128] = \"127.0.0.1\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-27650",
        "func_name": "containers/crun/crun_command_exec",
        "description": "A flaw was found in crun where containers were incorrectly started with non-empty default permissions. A vulnerability was found in Moby (Docker Engine) where containers were started incorrectly with non-empty inheritable Linux process capabilities. This flaw allows an attacker with access to programs with inheritable file capabilities to elevate those capabilities to the permitted set when execve(2) runs.",
        "git_url": "https://github.com/containers/crun/commit/1aeeed2e4fdeffb4875c0d0b439915894594c8c6",
        "commit_title": "exec: --cap do not set inheritable capabilities",
        "commit_text": " Closes: CVE-2022-27650 ",
        "func_before": "int\ncrun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n\n          process->capabilities = capabilities;\n        }\n\n      // noNewPriviledges will remain `false` if basespec has `false` unless specified\n      // Default is always `true` in generated basespec config\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n\n      exec_opts.process = process;\n    }\n\n  exec_opts.cgroup = exec_options.cgroup;\n\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "func": "int\ncrun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n\n          process->capabilities = capabilities;\n        }\n\n      // noNewPriviledges will remain `false` if basespec has `false` unless specified\n      // Default is always `true` in generated basespec config\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n\n      exec_opts.process = process;\n    }\n\n  exec_opts.cgroup = exec_options.cgroup;\n\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,8 +65,8 @@\n           capabilities->effective = exec_options.cap;\n           capabilities->effective_len = exec_options.cap_size;\n \n-          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n-          capabilities->inheritable_len = exec_options.cap_size;\n+          capabilities->inheritable = NULL;\n+          capabilities->inheritable_len = 0;\n \n           capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n           capabilities->bounding_len = exec_options.cap_size;",
        "diff_line_info": {
            "deleted_lines": [
                "          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);",
                "          capabilities->inheritable_len = exec_options.cap_size;"
            ],
            "added_lines": [
                "          capabilities->inheritable = NULL;",
                "          capabilities->inheritable_len = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26088",
        "func_name": "torvalds/linux/rawsock_create",
        "description": "A missing CAP_NET_RAW check in NFC socket creation in net/nfc/rawsock.c in the Linux kernel before 5.8.2 could be used by local attackers to create raw sockets, bypassing security mechanisms, aka CID-26896f01467a.",
        "git_url": "https://github.com/torvalds/linux/commit/26896f01467a28651f7a536143fe5ac8449d4041",
        "commit_title": "net/nfc/rawsock.c: add CAP_NET_RAW check.",
        "commit_text": " When creating a raw AF_NFC socket, CAP_NET_RAW needs to be checked first. ",
        "func_before": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\n\treturn 0;\n}",
        "func": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &rawsock_raw_ops;\n\t} else {\n\t\tsock->ops = &rawsock_ops;\n\t}\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,10 +8,13 @@\n \tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n \t\treturn -ESOCKTNOSUPPORT;\n \n-\tif (sock->type == SOCK_RAW)\n+\tif (sock->type == SOCK_RAW) {\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tsock->ops = &rawsock_raw_ops;\n-\telse\n+\t} else {\n \t\tsock->ops = &rawsock_ops;\n+\t}\n \n \tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n \tif (!sk)",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (sock->type == SOCK_RAW)",
                "\telse"
            ],
            "added_lines": [
                "\tif (sock->type == SOCK_RAW) {",
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;",
                "\t} else {",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-24031",
        "func_name": "facebook/zstd/FIO_openDstFile",
        "description": "In the Zstandard command-line utility prior to v1.4.1, output files were created with default permissions. Correct file permissions (matching the input) would only be set at completion time. Output files could therefore be readable or writable to unintended parties.",
        "git_url": "https://github.com/facebook/zstd/commit/3968160a916a759c3d3418da533e1b4f8b795343",
        "commit_title": "[programs] set chmod 600 after opening destination file",
        "commit_text": " This resolves a race condition where zstd or unzstd may expose read permissions beyond the original file allowed.  Mode 600 is used temporarily during the compression and decompression write stage and the new file inherits the original file’s mode at the end.  Fixes #1630",
        "func_before": "static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName)\n{\n    assert(dstFileName != NULL);\n    if (!strcmp (dstFileName, stdoutmark)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(stdout);\n        if (prefs->sparseFileSupport == 1) {\n            prefs->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return stdout;\n    }\n\n    /* ensure dst is not the same as src */\n    if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (prefs->sparseFileSupport == 1) {\n        prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT;\n    }\n\n    if (UTIL_isRegularFile(dstFileName)) {\n        /* Check if destination file already exists */\n        FILE* const fCheck = fopen( dstFileName, \"rb\" );\n        if (!strcmp(dstFileName, nulmark)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        dstFileName);\n        }\n        if (fCheck != NULL) {  /* dst file exists, authorization prompt */\n            fclose(fCheck);\n            if (!prefs->overwrite) {\n                if (g_display_prefs.displayLevel <= 1) {\n                    /* No interaction possible */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            dstFileName);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        dstFileName);\n                {   int ch = getchar();\n                    if ((ch!='Y') && (ch!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* flush rest of input line */\n                    while ((ch!=EOF) && (ch!='\\n')) ch = getchar();\n            }   }\n            /* need to unlink */\n            FIO_remove(dstFileName);\n    }   }\n\n    {   FILE* const f = fopen( dstFileName, \"wb\" );\n        if (f == NULL)\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n        return f;\n    }\n}",
        "func": "static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName)\n{\n    assert(dstFileName != NULL);\n    if (!strcmp (dstFileName, stdoutmark)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(stdout);\n        if (prefs->sparseFileSupport == 1) {\n            prefs->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return stdout;\n    }\n\n    /* ensure dst is not the same as src */\n    if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (prefs->sparseFileSupport == 1) {\n        prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT;\n    }\n\n    if (UTIL_isRegularFile(dstFileName)) {\n        /* Check if destination file already exists */\n        FILE* const fCheck = fopen( dstFileName, \"rb\" );\n        if (!strcmp(dstFileName, nulmark)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        dstFileName);\n        }\n        if (fCheck != NULL) {  /* dst file exists, authorization prompt */\n            fclose(fCheck);\n            if (!prefs->overwrite) {\n                if (g_display_prefs.displayLevel <= 1) {\n                    /* No interaction possible */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            dstFileName);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        dstFileName);\n                {   int ch = getchar();\n                    if ((ch!='Y') && (ch!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* flush rest of input line */\n                    while ((ch!=EOF) && (ch!='\\n')) ch = getchar();\n            }   }\n            /* need to unlink */\n            FIO_remove(dstFileName);\n    }   }\n\n    {   FILE* const f = fopen( dstFileName, \"wb\" );\n        if (f == NULL)\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n        chmod(dstFileName, 00600);\n        return f;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,6 +54,7 @@\n     {   FILE* const f = fopen( dstFileName, \"wb\" );\n         if (f == NULL)\n             DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n+        chmod(dstFileName, 00600);\n         return f;\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        chmod(dstFileName, 00600);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-24031",
        "func_name": "facebook/zstd/FIO_openDstFile",
        "description": "In the Zstandard command-line utility prior to v1.4.1, output files were created with default permissions. Correct file permissions (matching the input) would only be set at completion time. Output files could therefore be readable or writable to unintended parties.",
        "git_url": "https://github.com/facebook/zstd/commit/af80f6dfacafcc2c916ecd57731107221e1f9986",
        "commit_title": "[programs] Don’t try to chmod a dst file if it can’t be opened",
        "commit_text": " Repairs an oversight in my last commit, thanks @Cyan4973",
        "func_before": "static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName)\n{\n    assert(dstFileName != NULL);\n    if (!strcmp (dstFileName, stdoutmark)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(stdout);\n        if (prefs->sparseFileSupport == 1) {\n            prefs->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return stdout;\n    }\n\n    /* ensure dst is not the same as src */\n    if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (prefs->sparseFileSupport == 1) {\n        prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT;\n    }\n\n    if (UTIL_isRegularFile(dstFileName)) {\n        /* Check if destination file already exists */\n        FILE* const fCheck = fopen( dstFileName, \"rb\" );\n        if (!strcmp(dstFileName, nulmark)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        dstFileName);\n        }\n        if (fCheck != NULL) {  /* dst file exists, authorization prompt */\n            fclose(fCheck);\n            if (!prefs->overwrite) {\n                if (g_display_prefs.displayLevel <= 1) {\n                    /* No interaction possible */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            dstFileName);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        dstFileName);\n                {   int ch = getchar();\n                    if ((ch!='Y') && (ch!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* flush rest of input line */\n                    while ((ch!=EOF) && (ch!='\\n')) ch = getchar();\n            }   }\n            /* need to unlink */\n            FIO_remove(dstFileName);\n    }   }\n\n    {   FILE* const f = fopen( dstFileName, \"wb\" );\n        if (f == NULL)\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n        chmod(dstFileName, 00600);\n        return f;\n    }\n}",
        "func": "static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName)\n{\n    assert(dstFileName != NULL);\n    if (!strcmp (dstFileName, stdoutmark)) {\n        DISPLAYLEVEL(4,\"Using stdout for output \\n\");\n        SET_BINARY_MODE(stdout);\n        if (prefs->sparseFileSupport == 1) {\n            prefs->sparseFileSupport = 0;\n            DISPLAYLEVEL(4, \"Sparse File Support is automatically disabled on stdout ; try --sparse \\n\");\n        }\n        return stdout;\n    }\n\n    /* ensure dst is not the same as src */\n    if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) {\n        DISPLAYLEVEL(1, \"zstd: Refusing to open an output file which will overwrite the input file \\n\");\n        return NULL;\n    }\n\n    if (prefs->sparseFileSupport == 1) {\n        prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT;\n    }\n\n    if (UTIL_isRegularFile(dstFileName)) {\n        /* Check if destination file already exists */\n        FILE* const fCheck = fopen( dstFileName, \"rb\" );\n        if (!strcmp(dstFileName, nulmark)) {\n            EXM_THROW(40, \"%s is unexpectedly categorized as a regular file\",\n                        dstFileName);\n        }\n        if (fCheck != NULL) {  /* dst file exists, authorization prompt */\n            fclose(fCheck);\n            if (!prefs->overwrite) {\n                if (g_display_prefs.displayLevel <= 1) {\n                    /* No interaction possible */\n                    DISPLAY(\"zstd: %s already exists; not overwritten  \\n\",\n                            dstFileName);\n                    return NULL;\n                }\n                DISPLAY(\"zstd: %s already exists; overwrite (y/N) ? \",\n                        dstFileName);\n                {   int ch = getchar();\n                    if ((ch!='Y') && (ch!='y')) {\n                        DISPLAY(\"    not overwritten  \\n\");\n                        return NULL;\n                    }\n                    /* flush rest of input line */\n                    while ((ch!=EOF) && (ch!='\\n')) ch = getchar();\n            }   }\n            /* need to unlink */\n            FIO_remove(dstFileName);\n    }   }\n\n    {   FILE* const f = fopen( dstFileName, \"wb\" );\n        if (f == NULL) {\n            DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n        } else {\n            chmod(dstFileName, 00600);\n        }\n        return f;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -52,9 +52,11 @@\n     }   }\n \n     {   FILE* const f = fopen( dstFileName, \"wb\" );\n-        if (f == NULL)\n+        if (f == NULL) {\n             DISPLAYLEVEL(1, \"zstd: %s: %s\\n\", dstFileName, strerror(errno));\n-        chmod(dstFileName, 00600);\n+        } else {\n+            chmod(dstFileName, 00600);\n+        }\n         return f;\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (f == NULL)",
                "        chmod(dstFileName, 00600);"
            ],
            "added_lines": [
                "        if (f == NULL) {",
                "        } else {",
                "            chmod(dstFileName, 00600);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14156",
        "func_name": "openbmc/phosphor-host-ipmid/PasswdMgr::updatePasswdSpecialFile",
        "description": "user_channel/passwd_mgr.cpp in OpenBMC phosphor-host-ipmid before 2020-04-03 does not ensure that /etc/ipmi-pass has strong file permissions.",
        "git_url": "https://github.com/openbmc/phosphor-host-ipmid/commit/b265455a2518ece7c004b43c144199ec980fc620",
        "commit_title": "Use more restrictive permissions on /etc/ipmi-pass",
        "commit_text": " This forces the permissions on /etc/ipmi-pass to be 0600 or RW only by owner. This is to prevent non-owners from reading the file, even though it is obfuscated to make it harder for ipmi passwords to leak.  Tested: change ipmi passwords and see that the /etc/ipmi-pass file has         0600 permissions. ",
        "func_before": "int PasswdMgr::updatePasswdSpecialFile(const std::string& userName,\n                                       const std::string& newUserName)\n{\n    phosphor::user::shadow::Lock lock();\n\n    size_t bytesWritten = 0;\n    size_t inBytesLen = 0;\n    size_t isUsrFound = false;\n    const EVP_CIPHER* cipher = EVP_aes_128_cbc();\n    std::vector<uint8_t> dataBuf;\n\n    // Read the encrypted file and get the file data\n    // Check user existance and return if not exist.\n    if (readPasswdFileData(dataBuf) != 0)\n    {\n        log<level::DEBUG>(\"Error in reading the encrypted pass file\");\n        return -EIO;\n    }\n\n    if (dataBuf.size() != 0)\n    {\n        inBytesLen =\n            dataBuf.size() + newUserName.size() + EVP_CIPHER_block_size(cipher);\n    }\n\n    std::vector<uint8_t> inBytes(inBytesLen);\n    if (inBytesLen != 0)\n    {\n        char* outPtr = reinterpret_cast<char*>(dataBuf.data());\n        char* nToken = NULL;\n        char* linePtr = strtok_r(outPtr, \"\\n\", &nToken);\n        while (linePtr != NULL)\n        {\n            size_t userEPos = 0;\n\n            std::string lineStr(linePtr);\n            if ((userEPos = lineStr.find(\":\")) != std::string::npos)\n            {\n                if (userName.compare(lineStr.substr(0, userEPos)) == 0)\n                {\n                    isUsrFound = true;\n                    if (!newUserName.empty())\n                    {\n                        bytesWritten += std::snprintf(\n                            reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                            (inBytesLen - bytesWritten), \"%s%s\\n\",\n                            newUserName.c_str(),\n                            lineStr.substr(userEPos, lineStr.size()).data());\n                    }\n                }\n                else\n                {\n                    bytesWritten += std::snprintf(\n                        reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                        (inBytesLen - bytesWritten), \"%s\\n\", lineStr.data());\n                }\n            }\n            linePtr = strtok_r(NULL, \"\\n\", &nToken);\n        }\n        inBytesLen = bytesWritten;\n    }\n    if (!isUsrFound)\n    {\n        log<level::DEBUG>(\"User doesn't exist\");\n        return 0;\n    }\n\n    // Read the key buff from key file\n    std::array<uint8_t, maxKeySize> keyBuff;\n    std::ifstream keyFile(encryptKeyFileName, std::ios::in | std::ios::binary);\n    if (!keyFile.good())\n    {\n        log<level::DEBUG>(\"Error in opening encryption key file\");\n        return -EIO;\n    }\n    keyFile.read(reinterpret_cast<char*>(keyBuff.data()), keyBuff.size());\n    if (keyFile.fail())\n    {\n        log<level::DEBUG>(\"Error in reading encryption key file\");\n        return -EIO;\n    }\n    keyFile.close();\n\n    // Read the original passwd file mode\n    struct stat st = {};\n    if (stat(passwdFileName, &st) != 0)\n    {\n        log<level::DEBUG>(\"Error in getting password file fstat()\");\n        return -EIO;\n    }\n\n    // Create temporary file for write\n    std::string pwdFile(passwdFileName);\n    std::vector<char> tempFileName(pwdFile.begin(), pwdFile.end());\n    std::vector<char> fileTemplate = {'_', '_', 'X', 'X', 'X',\n                                      'X', 'X', 'X', '\\0'};\n    tempFileName.insert(tempFileName.end(), fileTemplate.begin(),\n                        fileTemplate.end());\n    int fd = mkstemp((char*)tempFileName.data());\n    if (fd == -1)\n    {\n        log<level::DEBUG>(\"Error creating temp file\");\n        return -EIO;\n    }\n\n    std::string strTempFileName(tempFileName.data());\n    // Open the temp file for writing from provided fd\n    // By \"true\", remove it at exit if still there.\n    // This is needed to cleanup the temp file at exception\n    phosphor::user::File temp(fd, strTempFileName, \"w\", true);\n    if ((temp)() == NULL)\n    {\n        close(fd);\n        log<level::DEBUG>(\"Error creating temp file\");\n        return -EIO;\n    }\n\n    // Set the file mode as of actual ipmi-pass file.\n    if (fchmod(fileno((temp)()), st.st_mode) < 0)\n    {\n        log<level::DEBUG>(\"Error setting fchmod for temp file\");\n        return -EIO;\n    }\n\n    const EVP_MD* digest = EVP_sha256();\n    size_t hashLen = EVP_MD_block_size(digest);\n    std::vector<uint8_t> hash(hashLen);\n    size_t ivLen = EVP_CIPHER_iv_length(cipher);\n    std::vector<uint8_t> iv(ivLen);\n    std::array<uint8_t, EVP_MAX_KEY_LENGTH> key;\n    size_t keyLen = key.size();\n    std::array<uint8_t, EVP_MAX_MD_SIZE> mac;\n    size_t macLen = mac.size();\n\n    // Create random hash and generate hash key which will be used for\n    // encryption.\n    if (RAND_bytes(hash.data(), hashLen) != 1)\n    {\n        log<level::DEBUG>(\"Hash genertion failed, bailing out\");\n        return -EIO;\n    }\n    if (NULL == HMAC(digest, keyBuff.data(), keyBuff.size(), hash.data(),\n                     hashLen, key.data(),\n                     reinterpret_cast<unsigned int*>(&keyLen)))\n    {\n        log<level::DEBUG>(\"Failed to create MAC for authentication\");\n        return -EIO;\n    }\n\n    // Generate IV values\n    if (RAND_bytes(iv.data(), ivLen) != 1)\n    {\n        log<level::DEBUG>(\"UV genertion failed, bailing out\");\n        return -EIO;\n    }\n\n    // Encrypt the input data\n    std::vector<uint8_t> outBytes(inBytesLen + EVP_MAX_BLOCK_LENGTH);\n    size_t outBytesLen = 0;\n    if (inBytesLen != 0)\n    {\n        if (encryptDecryptData(true, EVP_aes_128_cbc(), key.data(), keyLen,\n                               iv.data(), ivLen, inBytes.data(), inBytesLen,\n                               mac.data(), &macLen, outBytes.data(),\n                               &outBytesLen) != 0)\n        {\n            log<level::DEBUG>(\"Error while encrypting the data\");\n            return -EIO;\n        }\n        outBytes[outBytesLen] = 0;\n    }\n    OPENSSL_cleanse(key.data(), keyLen);\n\n    // Update the meta password structure.\n    MetaPassStruct metaData = {META_PASSWD_SIG, {0, 0}, 0, 0, 0, 0, 0};\n    metaData.hashSize = hashLen;\n    metaData.ivSize = ivLen;\n    metaData.dataSize = bytesWritten;\n    metaData.padSize = outBytesLen - bytesWritten;\n    metaData.macSize = macLen;\n\n    if (fwrite(&metaData, 1, sizeof(metaData), (temp)()) != sizeof(metaData))\n    {\n        log<level::DEBUG>(\"Error in writing meta data\");\n        return -EIO;\n    }\n\n    if (fwrite(&hash[0], 1, hashLen, (temp)()) != hashLen)\n    {\n        log<level::DEBUG>(\"Error in writing hash data\");\n        return -EIO;\n    }\n\n    if (fwrite(&iv[0], 1, ivLen, (temp)()) != ivLen)\n    {\n        log<level::DEBUG>(\"Error in writing IV data\");\n        return -EIO;\n    }\n\n    if (fwrite(&outBytes[0], 1, outBytesLen, (temp)()) != outBytesLen)\n    {\n        log<level::DEBUG>(\"Error in writing encrypted data\");\n        return -EIO;\n    }\n\n    if (fwrite(&mac[0], 1, macLen, (temp)()) != macLen)\n    {\n        log<level::DEBUG>(\"Error in writing MAC data\");\n        return -EIO;\n    }\n\n    if (fflush((temp)()))\n    {\n        log<level::DEBUG>(\n            \"File fflush error while writing entries to special file\");\n        return -EIO;\n    }\n\n    OPENSSL_cleanse(iv.data(), ivLen);\n\n    // Rename the tmp  file to actual file\n    if (std::rename(strTempFileName.data(), passwdFileName) != 0)\n    {\n        log<level::DEBUG>(\"Failed to rename tmp file to ipmi-pass\");\n        return -EIO;\n    }\n\n    return 0;\n}",
        "func": "int PasswdMgr::updatePasswdSpecialFile(const std::string& userName,\n                                       const std::string& newUserName)\n{\n    phosphor::user::shadow::Lock lock();\n\n    size_t bytesWritten = 0;\n    size_t inBytesLen = 0;\n    size_t isUsrFound = false;\n    const EVP_CIPHER* cipher = EVP_aes_128_cbc();\n    std::vector<uint8_t> dataBuf;\n\n    // Read the encrypted file and get the file data\n    // Check user existance and return if not exist.\n    if (readPasswdFileData(dataBuf) != 0)\n    {\n        log<level::DEBUG>(\"Error in reading the encrypted pass file\");\n        return -EIO;\n    }\n\n    if (dataBuf.size() != 0)\n    {\n        inBytesLen =\n            dataBuf.size() + newUserName.size() + EVP_CIPHER_block_size(cipher);\n    }\n\n    std::vector<uint8_t> inBytes(inBytesLen);\n    if (inBytesLen != 0)\n    {\n        char* outPtr = reinterpret_cast<char*>(dataBuf.data());\n        char* nToken = NULL;\n        char* linePtr = strtok_r(outPtr, \"\\n\", &nToken);\n        while (linePtr != NULL)\n        {\n            size_t userEPos = 0;\n\n            std::string lineStr(linePtr);\n            if ((userEPos = lineStr.find(\":\")) != std::string::npos)\n            {\n                if (userName.compare(lineStr.substr(0, userEPos)) == 0)\n                {\n                    isUsrFound = true;\n                    if (!newUserName.empty())\n                    {\n                        bytesWritten += std::snprintf(\n                            reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                            (inBytesLen - bytesWritten), \"%s%s\\n\",\n                            newUserName.c_str(),\n                            lineStr.substr(userEPos, lineStr.size()).data());\n                    }\n                }\n                else\n                {\n                    bytesWritten += std::snprintf(\n                        reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                        (inBytesLen - bytesWritten), \"%s\\n\", lineStr.data());\n                }\n            }\n            linePtr = strtok_r(NULL, \"\\n\", &nToken);\n        }\n        inBytesLen = bytesWritten;\n    }\n    if (!isUsrFound)\n    {\n        log<level::DEBUG>(\"User doesn't exist\");\n        return 0;\n    }\n\n    // Read the key buff from key file\n    std::array<uint8_t, maxKeySize> keyBuff;\n    std::ifstream keyFile(encryptKeyFileName, std::ios::in | std::ios::binary);\n    if (!keyFile.good())\n    {\n        log<level::DEBUG>(\"Error in opening encryption key file\");\n        return -EIO;\n    }\n    keyFile.read(reinterpret_cast<char*>(keyBuff.data()), keyBuff.size());\n    if (keyFile.fail())\n    {\n        log<level::DEBUG>(\"Error in reading encryption key file\");\n        return -EIO;\n    }\n    keyFile.close();\n\n    // Read the original passwd file mode\n    struct stat st = {};\n    if (stat(passwdFileName, &st) != 0)\n    {\n        log<level::DEBUG>(\"Error in getting password file fstat()\");\n        return -EIO;\n    }\n\n    // Create temporary file for write\n    std::string pwdFile(passwdFileName);\n    std::vector<char> tempFileName(pwdFile.begin(), pwdFile.end());\n    std::vector<char> fileTemplate = {'_', '_', 'X', 'X', 'X',\n                                      'X', 'X', 'X', '\\0'};\n    tempFileName.insert(tempFileName.end(), fileTemplate.begin(),\n                        fileTemplate.end());\n    int fd = mkstemp((char*)tempFileName.data());\n    if (fd == -1)\n    {\n        log<level::DEBUG>(\"Error creating temp file\");\n        return -EIO;\n    }\n\n    std::string strTempFileName(tempFileName.data());\n    // Open the temp file for writing from provided fd\n    // By \"true\", remove it at exit if still there.\n    // This is needed to cleanup the temp file at exception\n    phosphor::user::File temp(fd, strTempFileName, \"w\", true);\n    if ((temp)() == NULL)\n    {\n        close(fd);\n        log<level::DEBUG>(\"Error creating temp file\");\n        return -EIO;\n    }\n\n    // Set the file mode as read-write for owner only\n    if (fchmod(fileno((temp)()), S_IRUSR | S_IWUSR) < 0)\n    {\n        log<level::DEBUG>(\"Error setting fchmod for temp file\");\n        return -EIO;\n    }\n\n    const EVP_MD* digest = EVP_sha256();\n    size_t hashLen = EVP_MD_block_size(digest);\n    std::vector<uint8_t> hash(hashLen);\n    size_t ivLen = EVP_CIPHER_iv_length(cipher);\n    std::vector<uint8_t> iv(ivLen);\n    std::array<uint8_t, EVP_MAX_KEY_LENGTH> key;\n    size_t keyLen = key.size();\n    std::array<uint8_t, EVP_MAX_MD_SIZE> mac;\n    size_t macLen = mac.size();\n\n    // Create random hash and generate hash key which will be used for\n    // encryption.\n    if (RAND_bytes(hash.data(), hashLen) != 1)\n    {\n        log<level::DEBUG>(\"Hash genertion failed, bailing out\");\n        return -EIO;\n    }\n    if (NULL == HMAC(digest, keyBuff.data(), keyBuff.size(), hash.data(),\n                     hashLen, key.data(),\n                     reinterpret_cast<unsigned int*>(&keyLen)))\n    {\n        log<level::DEBUG>(\"Failed to create MAC for authentication\");\n        return -EIO;\n    }\n\n    // Generate IV values\n    if (RAND_bytes(iv.data(), ivLen) != 1)\n    {\n        log<level::DEBUG>(\"UV genertion failed, bailing out\");\n        return -EIO;\n    }\n\n    // Encrypt the input data\n    std::vector<uint8_t> outBytes(inBytesLen + EVP_MAX_BLOCK_LENGTH);\n    size_t outBytesLen = 0;\n    if (inBytesLen != 0)\n    {\n        if (encryptDecryptData(true, EVP_aes_128_cbc(), key.data(), keyLen,\n                               iv.data(), ivLen, inBytes.data(), inBytesLen,\n                               mac.data(), &macLen, outBytes.data(),\n                               &outBytesLen) != 0)\n        {\n            log<level::DEBUG>(\"Error while encrypting the data\");\n            return -EIO;\n        }\n        outBytes[outBytesLen] = 0;\n    }\n    OPENSSL_cleanse(key.data(), keyLen);\n\n    // Update the meta password structure.\n    MetaPassStruct metaData = {META_PASSWD_SIG, {0, 0}, 0, 0, 0, 0, 0};\n    metaData.hashSize = hashLen;\n    metaData.ivSize = ivLen;\n    metaData.dataSize = bytesWritten;\n    metaData.padSize = outBytesLen - bytesWritten;\n    metaData.macSize = macLen;\n\n    if (fwrite(&metaData, 1, sizeof(metaData), (temp)()) != sizeof(metaData))\n    {\n        log<level::DEBUG>(\"Error in writing meta data\");\n        return -EIO;\n    }\n\n    if (fwrite(&hash[0], 1, hashLen, (temp)()) != hashLen)\n    {\n        log<level::DEBUG>(\"Error in writing hash data\");\n        return -EIO;\n    }\n\n    if (fwrite(&iv[0], 1, ivLen, (temp)()) != ivLen)\n    {\n        log<level::DEBUG>(\"Error in writing IV data\");\n        return -EIO;\n    }\n\n    if (fwrite(&outBytes[0], 1, outBytesLen, (temp)()) != outBytesLen)\n    {\n        log<level::DEBUG>(\"Error in writing encrypted data\");\n        return -EIO;\n    }\n\n    if (fwrite(&mac[0], 1, macLen, (temp)()) != macLen)\n    {\n        log<level::DEBUG>(\"Error in writing MAC data\");\n        return -EIO;\n    }\n\n    if (fflush((temp)()))\n    {\n        log<level::DEBUG>(\n            \"File fflush error while writing entries to special file\");\n        return -EIO;\n    }\n\n    OPENSSL_cleanse(iv.data(), ivLen);\n\n    // Rename the tmp  file to actual file\n    if (std::rename(strTempFileName.data(), passwdFileName) != 0)\n    {\n        log<level::DEBUG>(\"Failed to rename tmp file to ipmi-pass\");\n        return -EIO;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -115,8 +115,8 @@\n         return -EIO;\n     }\n \n-    // Set the file mode as of actual ipmi-pass file.\n-    if (fchmod(fileno((temp)()), st.st_mode) < 0)\n+    // Set the file mode as read-write for owner only\n+    if (fchmod(fileno((temp)()), S_IRUSR | S_IWUSR) < 0)\n     {\n         log<level::DEBUG>(\"Error setting fchmod for temp file\");\n         return -EIO;",
        "diff_line_info": {
            "deleted_lines": [
                "    // Set the file mode as of actual ipmi-pass file.",
                "    if (fchmod(fileno((temp)()), st.st_mode) < 0)"
            ],
            "added_lines": [
                "    // Set the file mode as read-write for owner only",
                "    if (fchmod(fileno((temp)()), S_IRUSR | S_IWUSR) < 0)"
            ]
        }
    }
]