[
    {
        "cve_id": "CVE-2022-2125",
        "func_name": "vim/get_lisp_indent",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/0e8e938d497260dd57be67b4966cb27a5f72376f",
        "commit_title": "patch 8.2.5122: lisp indenting my run over the end of the line",
        "commit_text": " Problem:    Lisp indenting my run over the end of the line. Solution:   Check for NUL earlier.",
        "func_before": "int\nget_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    that++;\n\t\t    amount++;\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}",
        "func": "int\nget_lisp_indent(void)\n{\n    pos_T\t*pos, realpos, paren;\n    int\t\tamount;\n    char_u\t*that;\n    colnr_T\tcol;\n    colnr_T\tfirsttry;\n    int\t\tparencount, quotecount;\n    int\t\tvi_lisp;\n\n    // Set vi_lisp to use the vi-compatible method\n    vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);\n\n    realpos = curwin->w_cursor;\n    curwin->w_cursor.col = 0;\n\n    if ((pos = findmatch(NULL, '(')) == NULL)\n\tpos = findmatch(NULL, '[');\n    else\n    {\n\tparen = *pos;\n\tpos = findmatch(NULL, '[');\n\tif (pos == NULL || LT_POSP(pos, &paren))\n\t    pos = &paren;\n    }\n    if (pos != NULL)\n    {\n\t// Extra trick: Take the indent of the first previous non-white\n\t// line that is at the same () level.\n\tamount = -1;\n\tparencount = 0;\n\n\twhile (--curwin->w_cursor.lnum >= pos->lnum)\n\t{\n\t    if (linewhite(curwin->w_cursor.lnum))\n\t\tcontinue;\n\t    for (that = ml_get_curline(); *that != NUL; ++that)\n\t    {\n\t\tif (*that == ';')\n\t\t{\n\t\t    while (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\\\\')\n\t\t{\n\t\t    if (*(that + 1) != NUL)\n\t\t\t++that;\n\t\t    continue;\n\t\t}\n\t\tif (*that == '\"' && *(that + 1) != NUL)\n\t\t{\n\t\t    while (*++that && *that != '\"')\n\t\t    {\n\t\t\t// skipping escaped characters in the string\n\t\t\tif (*that == '\\\\')\n\t\t\t{\n\t\t\t    if (*++that == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (that[1] == NUL)\n\t\t\t    {\n\t\t\t\t++that;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (*that == NUL)\n\t\t\tbreak;\n\t\t}\n\t\tif (*that == '(' || *that == '[')\n\t\t    ++parencount;\n\t\telse if (*that == ')' || *that == ']')\n\t\t    --parencount;\n\t    }\n\t    if (parencount == 0)\n\t    {\n\t\tamount = get_indent();\n\t\tbreak;\n\t    }\n\t}\n\n\tif (amount == -1)\n\t{\n\t    curwin->w_cursor.lnum = pos->lnum;\n\t    curwin->w_cursor.col = pos->col;\n\t    col = pos->col;\n\n\t    that = ml_get_curline();\n\n\t    if (vi_lisp && get_indent() == 0)\n\t\tamount = 2;\n\t    else\n\t    {\n\t\tchar_u *line = that;\n\n\t\tamount = 0;\n\t\twhile (*that && col)\n\t\t{\n\t\t    amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount);\n\t\t    col--;\n\t\t}\n\n\t\t// Some keywords require \"body\" indenting rules (the\n\t\t// non-standard-lisp ones are Scheme special forms):\n\t\t//\n\t\t// (let ((a 1))    instead    (let ((a 1))\n\t\t//   (...))\t      of\t   (...))\n\n\t\tif (!vi_lisp && (*that == '(' || *that == '[')\n\t\t\t\t\t\t      && lisp_match(that + 1))\n\t\t    amount += 2;\n\t\telse\n\t\t{\n\t\t    that++;\n\t\t    amount++;\n\t\t    firsttry = amount;\n\n\t\t    while (VIM_ISWHITE(*that))\n\t\t    {\n\t\t\tamount += lbr_chartabsize(line, that, (colnr_T)amount);\n\t\t\t++that;\n\t\t    }\n\n\t\t    if (*that && *that != ';') // not a comment line\n\t\t    {\n\t\t\t// test *that != '(' to accommodate first let/do\n\t\t\t// argument if it is more than one line\n\t\t\tif (!vi_lisp && *that != '(' && *that != '[')\n\t\t\t    firsttry++;\n\n\t\t\tparencount = 0;\n\t\t\tquotecount = 0;\n\n\t\t\tif (vi_lisp\n\t\t\t\t|| (*that != '\"'\n\t\t\t\t    && *that != '\\''\n\t\t\t\t    && *that != '#'\n\t\t\t\t    && (*that < '0' || *that > '9')))\n\t\t\t{\n\t\t\t    while (*that\n\t\t\t\t    && (!VIM_ISWHITE(*that)\n\t\t\t\t\t|| quotecount\n\t\t\t\t\t|| parencount)\n\t\t\t\t    && (!((*that == '(' || *that == '[')\n\t\t\t\t\t    && !quotecount\n\t\t\t\t\t    && !parencount\n\t\t\t\t\t    && vi_lisp)))\n\t\t\t    {\n\t\t\t\tif (*that == '\"')\n\t\t\t\t    quotecount = !quotecount;\n\t\t\t\tif ((*that == '(' || *that == '[')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    ++parencount;\n\t\t\t\tif ((*that == ')' || *that == ']')\n\t\t\t\t\t\t\t       && !quotecount)\n\t\t\t\t    --parencount;\n\t\t\t\tif (*that == '\\\\' && *(that+1) != NUL)\n\t\t\t\t    amount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t\tamount += lbr_chartabsize_adv(\n\t\t\t\t\t\tline, &that, (colnr_T)amount);\n\t\t\t    }\n\t\t\t}\n\t\t\twhile (VIM_ISWHITE(*that))\n\t\t\t{\n\t\t\t    amount += lbr_chartabsize(\n\t\t\t\t\t\t line, that, (colnr_T)amount);\n\t\t\t    that++;\n\t\t\t}\n\t\t\tif (!*that || *that == ';')\n\t\t\t    amount = firsttry;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n\tamount = 0;\t// no matching '(' or '[' found, use zero indent\n\n    curwin->w_cursor = realpos;\n\n    return amount;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,6 +65,8 @@\n \t\t\t    }\n \t\t\t}\n \t\t    }\n+\t\t    if (*that == NUL)\n+\t\t\tbreak;\n \t\t}\n \t\tif (*that == '(' || *that == '[')\n \t\t    ++parencount;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t    if (*that == NUL)",
                "\t\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2182",
        "func_name": "vim/parse_cmd_address",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/f7c7c3fad6d2135d558f3b36d0d1a943118aeb5e",
        "commit_title": "patch 8.2.5150: read past the end of the first line with \":0;'{\"",
        "commit_text": " Problem:    Read past the end of the first line with \":0;'{\". Solution:   When on line zero check the column is valid for line one.",
        "func_before": "int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n    int\t\tneed_check_cursor = FALSE;\n    int\t\tret = FAIL;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    goto theend;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\tgoto theend;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    goto theend;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly.\n\t\t// Check the cursor position before returning.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t\tneed_check_cursor = TRUE;\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    ret = OK;\n\ntheend:\n    if (need_check_cursor)\n\tcheck_cursor();\n    return ret;\n}",
        "func": "int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n    int\t\tneed_check_cursor = FALSE;\n    int\t\tret = FAIL;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    goto theend;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\tgoto theend;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    goto theend;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly\n\t\t// (where zero usually means to use the first line).\n\t\t// Check the cursor position before returning.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t\telse\n\t\t    check_cursor_col();\n\t\tneed_check_cursor = TRUE;\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    ret = OK;\n\ntheend:\n    if (need_check_cursor)\n\tcheck_cursor();\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -128,10 +128,13 @@\n \t\tcurwin->w_cursor.lnum = eap->line2;\n \n \t\t// Don't leave the cursor on an illegal line or column, but do\n-\t\t// accept zero as address, so 0;/PATTERN/ works correctly.\n+\t\t// accept zero as address, so 0;/PATTERN/ works correctly\n+\t\t// (where zero usually means to use the first line).\n \t\t// Check the cursor position before returning.\n \t\tif (eap->line2 > 0)\n \t\t    check_cursor();\n+\t\telse\n+\t\t    check_cursor_col();\n \t\tneed_check_cursor = TRUE;\n \t    }\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t// accept zero as address, so 0;/PATTERN/ works correctly."
            ],
            "added_lines": [
                "\t\t// accept zero as address, so 0;/PATTERN/ works correctly",
                "\t\t// (where zero usually means to use the first line).",
                "\t\telse",
                "\t\t    check_cursor_col();"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2207",
        "func_name": "vim/ins_bs",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/0971c7a4e537ea120a6bb2195960be8d0815e97b",
        "commit_title": "patch 8.2.5162: reading before the start of the line with BS in Replace mode",
        "commit_text": " Problem:    Reading before the start of the line with BS in Replace mode. Solution:   Check the cursor column is more than zero.",
        "func_before": "static int\nins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}",
        "func": "static int\nins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol && curwin->w_cursor.col > 0\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -245,7 +245,7 @@\n #endif\n \n \t    // delete characters until we are at or before want_vcol\n-\t    while (vcol > want_vcol\n+\t    while (vcol > want_vcol && curwin->w_cursor.col > 0\n \t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n \t\tins_bs_one(&vcol);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t    while (vcol > want_vcol"
            ],
            "added_lines": [
                "\t    while (vcol > want_vcol && curwin->w_cursor.col > 0"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2264",
        "func_name": "vim/do_put",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.",
        "git_url": "https://github.com/vim/vim/commit/d25f003342aca9889067f2e839963dfeccf1fe05",
        "commit_title": "patch 9.0.0011: reading beyond the end of the line with put command",
        "commit_text": " Problem:    Reading beyond the end of the line with put command. Solution:   Adjust the end mark position.",
        "func_before": "void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, padd with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    // Skip mark_adjust when adding lines after the last one, there\n\t    // can't be marks there. But still needed in diff mode.\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}",
        "func": "void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, padd with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    // Skip mark_adjust when adding lines after the last one, there\n\t    // can't be marks there. But still needed in diff mode.\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -395,6 +395,8 @@\n \t\t    vim_memset(ptr, ' ', (size_t)spaces);\n \t\t    ptr += spaces;\n \t\t}\n+\t\telse\n+\t\t    totlen -= spaces;  // didn't use these spaces\n \t    }\n \n \t    // may insert some spaces after the new text",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\telse",
                "\t\t    totlen -= spaces;  // didn't use these spaces"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2284",
        "func_name": "vim/win_close",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.",
        "git_url": "https://github.com/vim/vim/commit/3d51ce18ab1be4f9f6061568a4e7fabf00b21794",
        "commit_title": "patch 9.0.0017: accessing memory beyond the end of the line",
        "commit_text": " Problem:    Accessing memory beyond the end of the line. Solution:   Stop Visual mode when closing a window.",
        "func_before": "int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}",
        "func": "int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    reset_VIsual_and_resel();\t// stop Visual mode\n\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    if (help_window)\n    {\n\t// Closing the help window moves the cursor back to the current window\n\t// of the snapshot.\n\twin_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);\n\n\tif (win_valid(prev_win))\n\t    wp = prev_win;\n    }\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,6 +73,8 @@\n \t */\n \tif (wp->w_buffer != curbuf)\n \t{\n+\t    reset_VIsual_and_resel();\t// stop Visual mode\n+\n \t    other_buffer = TRUE;\n \t    win->w_closing = TRUE;\n \t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    reset_VIsual_and_resel();\t// stop Visual mode",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2343",
        "func_name": "vim/ins_compl_infercase_gettext",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0044.",
        "git_url": "https://github.com/vim/vim/commit/caea66442d86e7bbba3bf3dc202c3c0d549b9853",
        "commit_title": "patch 9.0.0045: reading past end of completion with a long line",
        "commit_text": " Problem:    Reading past end of completion with a long line and 'infercase'             set. Solution:   Allocate the string if needed.",
        "func_before": "static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tactual_len,\n\tint\tactual_compl_length,\n\tint\tmin_len)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, actual_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < actual_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = actual_compl_length; i < actual_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = actual_compl_length; i < actual_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    // Multi-byte characters can occupy up to five bytes more than\n    // ASCII characters, and we also need one byte for NUL, so stay\n    // six bytes away from the edge of IObuff.\n    p = IObuff;\n    i = 0;\n    while (i < actual_len && (p - IObuff + 6) < IOSIZE)\n\tif (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    *p = NUL;\n\n    vim_free(wca);\n\n    return IObuff;\n}",
        "func": "static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tchar_len,\n\tint\tcompl_char_len,\n\tint\tmin_len,\n\tchar_u  **tofree)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n    garray_T\tgap;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, char_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < char_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    p = IObuff;\n    i = 0;\n    ga_init2(&gap, 1, 500);\n    while (i < char_len)\n    {\n\tif (gap.ga_data != NULL)\n\t{\n\t    if (ga_grow(&gap, 10) == FAIL)\n\t    {\n\t\tga_clear(&gap);\n\t\treturn (char_u *)\"[failed]\";\n\t    }\n\t    p = (char_u *)gap.ga_data + gap.ga_len;\n\t    if (has_mbyte)\n\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n\t    else\n\t    {\n\t\t*p = wca[i++];\n\t\t++gap.ga_len;\n\t    }\n\t}\n\telse if ((p - IObuff) + 6 >= IOSIZE)\n\t{\n\t    // Multi-byte characters can occupy up to five bytes more than\n\t    // ASCII characters, and we also need one byte for NUL, so when\n\t    // getting to six bytes from the edge of IObuff switch to using a\n\t    // growarray.  Add the character in the next round.\n\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n\t\treturn (char_u *)\"[failed]\";\n\t    STRCPY(gap.ga_data, IObuff);\n\t    gap.ga_len = STRLEN(IObuff);\n\t}\n\telse if (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    }\n    vim_free(wca);\n\n    if (gap.ga_data != NULL)\n    {\n\t*tofree = gap.ga_data;\n\treturn gap.ga_data;\n    }\n\n    *p = NUL;\n    return IObuff;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,25 +1,27 @@\n static char_u *\n ins_compl_infercase_gettext(\n \tchar_u\t*str,\n-\tint\tactual_len,\n-\tint\tactual_compl_length,\n-\tint\tmin_len)\n+\tint\tchar_len,\n+\tint\tcompl_char_len,\n+\tint\tmin_len,\n+\tchar_u  **tofree)\n {\n     int\t\t*wca;\t\t\t// Wide character array.\n     char_u\t*p;\n     int\t\ti, c;\n     int\t\thas_lower = FALSE;\n     int\t\twas_letter = FALSE;\n+    garray_T\tgap;\n \n     IObuff[0] = NUL;\n \n     // Allocate wide character array for the completion and fill it.\n-    wca = ALLOC_MULT(int, actual_len);\n+    wca = ALLOC_MULT(int, char_len);\n     if (wca == NULL)\n \treturn IObuff;\n \n     p = str;\n-    for (i = 0; i < actual_len; ++i)\n+    for (i = 0; i < char_len; ++i)\n \tif (has_mbyte)\n \t    wca[i] = mb_ptr2char_adv(&p);\n \telse\n@@ -39,7 +41,7 @@\n \t    if (MB_ISUPPER(wca[i]))\n \t    {\n \t\t// Rule 1 is satisfied.\n-\t\tfor (i = actual_compl_length; i < actual_len; ++i)\n+\t\tfor (i = compl_char_len; i < char_len; ++i)\n \t\t    wca[i] = MB_TOLOWER(wca[i]);\n \t\tbreak;\n \t    }\n@@ -60,7 +62,7 @@\n \t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n \t    {\n \t\t// Rule 2 is satisfied.\n-\t\tfor (i = actual_compl_length; i < actual_len; ++i)\n+\t\tfor (i = compl_char_len; i < char_len; ++i)\n \t\t    wca[i] = MB_TOUPPER(wca[i]);\n \t\tbreak;\n \t    }\n@@ -83,19 +85,51 @@\n     }\n \n     // Generate encoding specific output from wide character array.\n-    // Multi-byte characters can occupy up to five bytes more than\n-    // ASCII characters, and we also need one byte for NUL, so stay\n-    // six bytes away from the edge of IObuff.\n     p = IObuff;\n     i = 0;\n-    while (i < actual_len && (p - IObuff + 6) < IOSIZE)\n-\tif (has_mbyte)\n+    ga_init2(&gap, 1, 500);\n+    while (i < char_len)\n+    {\n+\tif (gap.ga_data != NULL)\n+\t{\n+\t    if (ga_grow(&gap, 10) == FAIL)\n+\t    {\n+\t\tga_clear(&gap);\n+\t\treturn (char_u *)\"[failed]\";\n+\t    }\n+\t    p = (char_u *)gap.ga_data + gap.ga_len;\n+\t    if (has_mbyte)\n+\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n+\t    else\n+\t    {\n+\t\t*p = wca[i++];\n+\t\t++gap.ga_len;\n+\t    }\n+\t}\n+\telse if ((p - IObuff) + 6 >= IOSIZE)\n+\t{\n+\t    // Multi-byte characters can occupy up to five bytes more than\n+\t    // ASCII characters, and we also need one byte for NUL, so when\n+\t    // getting to six bytes from the edge of IObuff switch to using a\n+\t    // growarray.  Add the character in the next round.\n+\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n+\t\treturn (char_u *)\"[failed]\";\n+\t    STRCPY(gap.ga_data, IObuff);\n+\t    gap.ga_len = STRLEN(IObuff);\n+\t}\n+\telse if (has_mbyte)\n \t    p += (*mb_char2bytes)(wca[i++], p);\n \telse\n \t    *(p++) = wca[i++];\n-    *p = NUL;\n-\n+    }\n     vim_free(wca);\n \n+    if (gap.ga_data != NULL)\n+    {\n+\t*tofree = gap.ga_data;\n+\treturn gap.ga_data;\n+    }\n+\n+    *p = NUL;\n     return IObuff;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tint\tactual_len,",
                "\tint\tactual_compl_length,",
                "\tint\tmin_len)",
                "    wca = ALLOC_MULT(int, actual_len);",
                "    for (i = 0; i < actual_len; ++i)",
                "\t\tfor (i = actual_compl_length; i < actual_len; ++i)",
                "\t\tfor (i = actual_compl_length; i < actual_len; ++i)",
                "    // Multi-byte characters can occupy up to five bytes more than",
                "    // ASCII characters, and we also need one byte for NUL, so stay",
                "    // six bytes away from the edge of IObuff.",
                "    while (i < actual_len && (p - IObuff + 6) < IOSIZE)",
                "\tif (has_mbyte)",
                "    *p = NUL;",
                ""
            ],
            "added_lines": [
                "\tint\tchar_len,",
                "\tint\tcompl_char_len,",
                "\tint\tmin_len,",
                "\tchar_u  **tofree)",
                "    garray_T\tgap;",
                "    wca = ALLOC_MULT(int, char_len);",
                "    for (i = 0; i < char_len; ++i)",
                "\t\tfor (i = compl_char_len; i < char_len; ++i)",
                "\t\tfor (i = compl_char_len; i < char_len; ++i)",
                "    ga_init2(&gap, 1, 500);",
                "    while (i < char_len)",
                "    {",
                "\tif (gap.ga_data != NULL)",
                "\t{",
                "\t    if (ga_grow(&gap, 10) == FAIL)",
                "\t    {",
                "\t\tga_clear(&gap);",
                "\t\treturn (char_u *)\"[failed]\";",
                "\t    }",
                "\t    p = (char_u *)gap.ga_data + gap.ga_len;",
                "\t    if (has_mbyte)",
                "\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);",
                "\t    else",
                "\t    {",
                "\t\t*p = wca[i++];",
                "\t\t++gap.ga_len;",
                "\t    }",
                "\t}",
                "\telse if ((p - IObuff) + 6 >= IOSIZE)",
                "\t{",
                "\t    // Multi-byte characters can occupy up to five bytes more than",
                "\t    // ASCII characters, and we also need one byte for NUL, so when",
                "\t    // getting to six bytes from the edge of IObuff switch to using a",
                "\t    // growarray.  Add the character in the next round.",
                "\t    if (ga_grow(&gap, IOSIZE) == FAIL)",
                "\t\treturn (char_u *)\"[failed]\";",
                "\t    STRCPY(gap.ga_data, IObuff);",
                "\t    gap.ga_len = STRLEN(IObuff);",
                "\t}",
                "\telse if (has_mbyte)",
                "    }",
                "    if (gap.ga_data != NULL)",
                "    {",
                "\t*tofree = gap.ga_data;",
                "\treturn gap.ga_data;",
                "    }",
                "",
                "    *p = NUL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2343",
        "func_name": "vim/ins_compl_add_infercase",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0044.",
        "git_url": "https://github.com/vim/vim/commit/caea66442d86e7bbba3bf3dc202c3c0d549b9853",
        "commit_title": "patch 9.0.0045: reading past end of completion with a long line",
        "commit_text": " Problem:    Reading past end of completion with a long line and 'infercase'             set. Solution:   Allocate the string if needed.",
        "func_before": "int\nins_compl_add_infercase(\n    char_u\t*str_arg,\n    int\t\tlen,\n    int\t\ticase,\n    char_u\t*fname,\n    int\t\tdir,\n    int\t\tcont_s_ipos)  // next ^X<> will set initial_pos\n{\n    char_u\t*str = str_arg;\n    char_u\t*p;\n    int\t\tactual_len;\t\t// Take multi-byte characters\n    int\t\tactual_compl_length;\t// into account.\n    int\t\tmin_len;\n    int\t\tflags = 0;\n\n    if (p_ic && curbuf->b_p_inf && len > 0)\n    {\n\t// Infer case of completed part.\n\n\t// Find actual length of completion.\n\tif (has_mbyte)\n\t{\n\t    p = str;\n\t    actual_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++actual_len;\n\t    }\n\t}\n\telse\n\t    actual_len = len;\n\n\t// Find actual length of original text.\n\tif (has_mbyte)\n\t{\n\t    p = compl_orig_text;\n\t    actual_compl_length = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++actual_compl_length;\n\t    }\n\t}\n\telse\n\t    actual_compl_length = compl_length;\n\n\t// \"actual_len\" may be smaller than \"actual_compl_length\" when using\n\t// thesaurus, only use the minimum when comparing.\n\tmin_len = actual_len < actual_compl_length\n\t\t\t\t\t   ? actual_len : actual_compl_length;\n\n\tstr = ins_compl_infercase_gettext(str, actual_len, actual_compl_length,\n\t\t\t\t\t\t\t\tmin_len);\n    }\n    if (cont_s_ipos)\n\tflags |= CP_CONT_S_IPOS;\n    if (icase)\n\tflags |= CP_ICASE;\n\n    return ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n}",
        "func": "int\nins_compl_add_infercase(\n    char_u\t*str_arg,\n    int\t\tlen,\n    int\t\ticase,\n    char_u\t*fname,\n    int\t\tdir,\n    int\t\tcont_s_ipos)  // next ^X<> will set initial_pos\n{\n    char_u\t*str = str_arg;\n    char_u\t*p;\n    int\t\tchar_len;\t\t// count multi-byte characters\n    int\t\tcompl_char_len;\n    int\t\tmin_len;\n    int\t\tflags = 0;\n    int\t\tres;\n    char_u\t*tofree = NULL;\n\n    if (p_ic && curbuf->b_p_inf && len > 0)\n    {\n\t// Infer case of completed part.\n\n\t// Find actual length of completion.\n\tif (has_mbyte)\n\t{\n\t    p = str;\n\t    char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++char_len;\n\t    }\n\t}\n\telse\n\t    char_len = len;\n\n\t// Find actual length of original text.\n\tif (has_mbyte)\n\t{\n\t    p = compl_orig_text;\n\t    compl_char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++compl_char_len;\n\t    }\n\t}\n\telse\n\t    compl_char_len = compl_length;\n\n\t// \"char_len\" may be smaller than \"compl_char_len\" when using\n\t// thesaurus, only use the minimum when comparing.\n\tmin_len = char_len < compl_char_len ? char_len : compl_char_len;\n\n\tstr = ins_compl_infercase_gettext(str, char_len,\n\t\t\t\t\t  compl_char_len, min_len, &tofree);\n    }\n    if (cont_s_ipos)\n\tflags |= CP_CONT_S_IPOS;\n    if (icase)\n\tflags |= CP_ICASE;\n\n    res = ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n    vim_free(tofree);\n    return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,10 +9,12 @@\n {\n     char_u\t*str = str_arg;\n     char_u\t*p;\n-    int\t\tactual_len;\t\t// Take multi-byte characters\n-    int\t\tactual_compl_length;\t// into account.\n+    int\t\tchar_len;\t\t// count multi-byte characters\n+    int\t\tcompl_char_len;\n     int\t\tmin_len;\n     int\t\tflags = 0;\n+    int\t\tres;\n+    char_u\t*tofree = NULL;\n \n     if (p_ic && curbuf->b_p_inf && len > 0)\n     {\n@@ -22,42 +24,43 @@\n \tif (has_mbyte)\n \t{\n \t    p = str;\n-\t    actual_len = 0;\n+\t    char_len = 0;\n \t    while (*p != NUL)\n \t    {\n \t\tMB_PTR_ADV(p);\n-\t\t++actual_len;\n+\t\t++char_len;\n \t    }\n \t}\n \telse\n-\t    actual_len = len;\n+\t    char_len = len;\n \n \t// Find actual length of original text.\n \tif (has_mbyte)\n \t{\n \t    p = compl_orig_text;\n-\t    actual_compl_length = 0;\n+\t    compl_char_len = 0;\n \t    while (*p != NUL)\n \t    {\n \t\tMB_PTR_ADV(p);\n-\t\t++actual_compl_length;\n+\t\t++compl_char_len;\n \t    }\n \t}\n \telse\n-\t    actual_compl_length = compl_length;\n+\t    compl_char_len = compl_length;\n \n-\t// \"actual_len\" may be smaller than \"actual_compl_length\" when using\n+\t// \"char_len\" may be smaller than \"compl_char_len\" when using\n \t// thesaurus, only use the minimum when comparing.\n-\tmin_len = actual_len < actual_compl_length\n-\t\t\t\t\t   ? actual_len : actual_compl_length;\n+\tmin_len = char_len < compl_char_len ? char_len : compl_char_len;\n \n-\tstr = ins_compl_infercase_gettext(str, actual_len, actual_compl_length,\n-\t\t\t\t\t\t\t\tmin_len);\n+\tstr = ins_compl_infercase_gettext(str, char_len,\n+\t\t\t\t\t  compl_char_len, min_len, &tofree);\n     }\n     if (cont_s_ipos)\n \tflags |= CP_CONT_S_IPOS;\n     if (icase)\n \tflags |= CP_ICASE;\n \n-    return ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n+    res = ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n+    vim_free(tofree);\n+    return res;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    int\t\tactual_len;\t\t// Take multi-byte characters",
                "    int\t\tactual_compl_length;\t// into account.",
                "\t    actual_len = 0;",
                "\t\t++actual_len;",
                "\t    actual_len = len;",
                "\t    actual_compl_length = 0;",
                "\t\t++actual_compl_length;",
                "\t    actual_compl_length = compl_length;",
                "\t// \"actual_len\" may be smaller than \"actual_compl_length\" when using",
                "\tmin_len = actual_len < actual_compl_length",
                "\t\t\t\t\t   ? actual_len : actual_compl_length;",
                "\tstr = ins_compl_infercase_gettext(str, actual_len, actual_compl_length,",
                "\t\t\t\t\t\t\t\tmin_len);",
                "    return ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);"
            ],
            "added_lines": [
                "    int\t\tchar_len;\t\t// count multi-byte characters",
                "    int\t\tcompl_char_len;",
                "    int\t\tres;",
                "    char_u\t*tofree = NULL;",
                "\t    char_len = 0;",
                "\t\t++char_len;",
                "\t    char_len = len;",
                "\t    compl_char_len = 0;",
                "\t\t++compl_char_len;",
                "\t    compl_char_len = compl_length;",
                "\t// \"char_len\" may be smaller than \"compl_char_len\" when using",
                "\tmin_len = char_len < compl_char_len ? char_len : compl_char_len;",
                "\tstr = ins_compl_infercase_gettext(str, char_len,",
                "\t\t\t\t\t  compl_char_len, min_len, &tofree);",
                "    res = ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);",
                "    vim_free(tofree);",
                "    return res;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2344",
        "func_name": "vim/ins_compl_add",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0045.",
        "git_url": "https://github.com/vim/vim/commit/baefde14550231f6468ac2ed2ed495bc381c0c92",
        "commit_title": "patch 9.0.0046: reading past end of completion with duplicate match",
        "commit_text": " Problem:    Reading past end of completion with duplicate match. Solution:   Check string length",
        "func_before": "static int\nins_compl_add(\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*fname,\n    char_u\t**cptext,\t    // extra text for popup menu or NULL\n    typval_T\t*user_data UNUSED,  // \"user_data\" entry or NULL\n    int\t\tcdir,\n    int\t\tflags_arg,\n    int\t\tadup)\t\t// accept duplicate match\n{\n    compl_T\t*match;\n    int\t\tdir = (cdir == 0 ? compl_direction : cdir);\n    int\t\tflags = flags_arg;\n\n    if (flags & CP_FAST)\n\tfast_breakcheck();\n    else\n\tui_breakcheck();\n    if (got_int)\n\treturn FAIL;\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // If the same match is already present, don't add it.\n    if (compl_first_match != NULL && !adup)\n    {\n\tmatch = compl_first_match;\n\tdo\n\t{\n\t    if (!match_at_original_text(match)\n\t\t    && STRNCMP(match->cp_str, str, len) == 0\n\t\t    && match->cp_str[len] == NUL)\n\t\treturn NOTDONE;\n\t    match = match->cp_next;\n\t} while (match != NULL && !is_first_match(match));\n    }\n\n    // Remove any popup menu before changing the list of matches.\n    ins_compl_del_pum();\n\n    // Allocate a new match structure.\n    // Copy the values to the new match structure.\n    match = ALLOC_CLEAR_ONE(compl_T);\n    if (match == NULL)\n\treturn FAIL;\n    match->cp_number = -1;\n    if (flags & CP_ORIGINAL_TEXT)\n\tmatch->cp_number = 0;\n    if ((match->cp_str = vim_strnsave(str, len)) == NULL)\n    {\n\tvim_free(match);\n\treturn FAIL;\n    }\n\n    // match-fname is:\n    // - compl_curr_match->cp_fname if it is a string equal to fname.\n    // - a copy of fname, CP_FREE_FNAME is set to free later THE allocated mem.\n    // - NULL otherwise.\t--Acevedo\n    if (fname != NULL\n\t    && compl_curr_match != NULL\n\t    && compl_curr_match->cp_fname != NULL\n\t    && STRCMP(fname, compl_curr_match->cp_fname) == 0)\n\tmatch->cp_fname = compl_curr_match->cp_fname;\n    else if (fname != NULL)\n    {\n\tmatch->cp_fname = vim_strsave(fname);\n\tflags |= CP_FREE_FNAME;\n    }\n    else\n\tmatch->cp_fname = NULL;\n    match->cp_flags = flags;\n\n    if (cptext != NULL)\n    {\n\tint i;\n\n\tfor (i = 0; i < CPT_COUNT; ++i)\n\t    if (cptext[i] != NULL && *cptext[i] != NUL)\n\t\tmatch->cp_text[i] = vim_strsave(cptext[i]);\n    }\n#ifdef FEAT_EVAL\n    if (user_data != NULL)\n\tmatch->cp_user_data = *user_data;\n#endif\n\n    // Link the new match structure after (FORWARD) or before (BACKWARD) the\n    // current match in the list of matches .\n    if (compl_first_match == NULL)\n\tmatch->cp_next = match->cp_prev = NULL;\n    else if (dir == FORWARD)\n    {\n\tmatch->cp_next = compl_curr_match->cp_next;\n\tmatch->cp_prev = compl_curr_match;\n    }\n    else\t// BACKWARD\n    {\n\tmatch->cp_next = compl_curr_match;\n\tmatch->cp_prev = compl_curr_match->cp_prev;\n    }\n    if (match->cp_next)\n\tmatch->cp_next->cp_prev = match;\n    if (match->cp_prev)\n\tmatch->cp_prev->cp_next = match;\n    else\t// if there's nothing before, it is the first match\n\tcompl_first_match = match;\n    compl_curr_match = match;\n\n    // Find the longest common string if still doing that.\n    if (compl_get_longest && (flags & CP_ORIGINAL_TEXT) == 0)\n\tins_compl_longest_match(match);\n\n    return OK;\n}",
        "func": "static int\nins_compl_add(\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*fname,\n    char_u\t**cptext,\t    // extra text for popup menu or NULL\n    typval_T\t*user_data UNUSED,  // \"user_data\" entry or NULL\n    int\t\tcdir,\n    int\t\tflags_arg,\n    int\t\tadup)\t\t// accept duplicate match\n{\n    compl_T\t*match;\n    int\t\tdir = (cdir == 0 ? compl_direction : cdir);\n    int\t\tflags = flags_arg;\n\n    if (flags & CP_FAST)\n\tfast_breakcheck();\n    else\n\tui_breakcheck();\n    if (got_int)\n\treturn FAIL;\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // If the same match is already present, don't add it.\n    if (compl_first_match != NULL && !adup)\n    {\n\tmatch = compl_first_match;\n\tdo\n\t{\n\t    if (!match_at_original_text(match)\n\t\t    && STRNCMP(match->cp_str, str, len) == 0\n\t\t    && ((int)STRLEN(match->cp_str) <= len\n\t\t\t\t\t\t || match->cp_str[len] == NUL))\n\t\treturn NOTDONE;\n\t    match = match->cp_next;\n\t} while (match != NULL && !is_first_match(match));\n    }\n\n    // Remove any popup menu before changing the list of matches.\n    ins_compl_del_pum();\n\n    // Allocate a new match structure.\n    // Copy the values to the new match structure.\n    match = ALLOC_CLEAR_ONE(compl_T);\n    if (match == NULL)\n\treturn FAIL;\n    match->cp_number = -1;\n    if (flags & CP_ORIGINAL_TEXT)\n\tmatch->cp_number = 0;\n    if ((match->cp_str = vim_strnsave(str, len)) == NULL)\n    {\n\tvim_free(match);\n\treturn FAIL;\n    }\n\n    // match-fname is:\n    // - compl_curr_match->cp_fname if it is a string equal to fname.\n    // - a copy of fname, CP_FREE_FNAME is set to free later THE allocated mem.\n    // - NULL otherwise.\t--Acevedo\n    if (fname != NULL\n\t    && compl_curr_match != NULL\n\t    && compl_curr_match->cp_fname != NULL\n\t    && STRCMP(fname, compl_curr_match->cp_fname) == 0)\n\tmatch->cp_fname = compl_curr_match->cp_fname;\n    else if (fname != NULL)\n    {\n\tmatch->cp_fname = vim_strsave(fname);\n\tflags |= CP_FREE_FNAME;\n    }\n    else\n\tmatch->cp_fname = NULL;\n    match->cp_flags = flags;\n\n    if (cptext != NULL)\n    {\n\tint i;\n\n\tfor (i = 0; i < CPT_COUNT; ++i)\n\t    if (cptext[i] != NULL && *cptext[i] != NUL)\n\t\tmatch->cp_text[i] = vim_strsave(cptext[i]);\n    }\n#ifdef FEAT_EVAL\n    if (user_data != NULL)\n\tmatch->cp_user_data = *user_data;\n#endif\n\n    // Link the new match structure after (FORWARD) or before (BACKWARD) the\n    // current match in the list of matches .\n    if (compl_first_match == NULL)\n\tmatch->cp_next = match->cp_prev = NULL;\n    else if (dir == FORWARD)\n    {\n\tmatch->cp_next = compl_curr_match->cp_next;\n\tmatch->cp_prev = compl_curr_match;\n    }\n    else\t// BACKWARD\n    {\n\tmatch->cp_next = compl_curr_match;\n\tmatch->cp_prev = compl_curr_match->cp_prev;\n    }\n    if (match->cp_next)\n\tmatch->cp_next->cp_prev = match;\n    if (match->cp_prev)\n\tmatch->cp_prev->cp_next = match;\n    else\t// if there's nothing before, it is the first match\n\tcompl_first_match = match;\n    compl_curr_match = match;\n\n    // Find the longest common string if still doing that.\n    if (compl_get_longest && (flags & CP_ORIGINAL_TEXT) == 0)\n\tins_compl_longest_match(match);\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,8 @@\n \t{\n \t    if (!match_at_original_text(match)\n \t\t    && STRNCMP(match->cp_str, str, len) == 0\n-\t\t    && match->cp_str[len] == NUL)\n+\t\t    && ((int)STRLEN(match->cp_str) <= len\n+\t\t\t\t\t\t || match->cp_str[len] == NUL))\n \t\treturn NOTDONE;\n \t    match = match->cp_next;\n \t} while (match != NULL && !is_first_match(match));",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    && match->cp_str[len] == NUL)"
            ],
            "added_lines": [
                "\t\t    && ((int)STRLEN(match->cp_str) <= len",
                "\t\t\t\t\t\t || match->cp_str[len] == NUL))"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14816",
        "func_name": "torvalds/linux/mwifiex_update_vs_ie",
        "description": "There is heap-based buffer overflow in kernel, all versions up to, excluding 5.3, in the marvell wifi chip driver in Linux kernel, that allows local users to cause a denial of service(system crash) or possibly execute arbitrary code.",
        "git_url": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a",
        "commit_title": "mwifiex: Fix three heap overflow at parsing element in cfg80211_ap_settings",
        "commit_text": " mwifiex_update_vs_ie(),mwifiex_set_uap_rates() and mwifiex_set_wmm_params() call memcpy() without checking the destination size.Since the source is given from user-space, this may trigger a heap buffer overflow.  Fix them by putting the length check before performing memcpy().  This fix addresses CVE-2019-14814,CVE-2019-14815,CVE-2019-14816. ",
        "func_before": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}",
        "func": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,9 @@\n \t\t}\n \n \t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n+\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n+\t\t\tIEEE_MAX_IE_SIZE)\n+\t\t\treturn -EINVAL;\n \t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n \t\t       vs_ie, vs_ie->len + 2);\n \t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >",
                "\t\t\tIEEE_MAX_IE_SIZE)",
                "\t\t\treturn -EINVAL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14816",
        "func_name": "torvalds/linux/mwifiex_set_wmm_params",
        "description": "There is heap-based buffer overflow in kernel, all versions up to, excluding 5.3, in the marvell wifi chip driver in Linux kernel, that allows local users to cause a denial of service(system crash) or possibly execute arbitrary code.",
        "git_url": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a",
        "commit_title": "mwifiex: Fix three heap overflow at parsing element in cfg80211_ap_settings",
        "commit_text": " mwifiex_update_vs_ie(),mwifiex_set_uap_rates() and mwifiex_set_wmm_params() call memcpy() without checking the destination size.Since the source is given from user-space, this may trigger a heap buffer overflow.  Fix them by putting the length check before performing memcpy().  This fix addresses CVE-2019-14814,CVE-2019-14815,CVE-2019-14816. ",
        "func_before": "void\nmwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}",
        "func": "void\nmwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,8 @@\n \t\t\t\t\t    params->beacon.tail_len);\n \tif (vendor_ie) {\n \t\twmm_ie = vendor_ie;\n+\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n+\t\t\treturn;\n \t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n \t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n \t\tpriv->wmm_enabled = 1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))",
                "\t\t\treturn;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14816",
        "func_name": "torvalds/linux/mwifiex_set_uap_rates",
        "description": "There is heap-based buffer overflow in kernel, all versions up to, excluding 5.3, in the marvell wifi chip driver in Linux kernel, that allows local users to cause a denial of service(system crash) or possibly execute arbitrary code.",
        "git_url": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a",
        "commit_title": "mwifiex: Fix three heap overflow at parsing element in cfg80211_ap_settings",
        "commit_text": " mwifiex_update_vs_ie(),mwifiex_set_uap_rates() and mwifiex_set_wmm_params() call memcpy() without checking the destination size.Since the source is given from user-space, this may trigger a heap buffer overflow.  Fix them by putting the length check before performing memcpy().  This fix addresses CVE-2019-14814,CVE-2019-14815,CVE-2019-14816. ",
        "func_before": "void\nmwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\n\treturn;\n}",
        "func": "void\nmwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\t}\n\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,8 @@\n \n \trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n \tif (rate_ie) {\n+\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)\n+\t\t\treturn;\n \t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n \t\trate_len = rate_ie->len;\n \t}\n@@ -17,8 +19,11 @@\n \trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n \t\t\t\t\t   params->beacon.tail,\n \t\t\t\t\t   params->beacon.tail_len);\n-\tif (rate_ie)\n+\tif (rate_ie) {\n+\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)\n+\t\t\treturn;\n \t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n+\t}\n \n \treturn;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (rate_ie)"
            ],
            "added_lines": [
                "\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)",
                "\t\t\treturn;",
                "\tif (rate_ie) {",
                "\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)",
                "\t\t\treturn;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0392",
        "func_name": "vim/bracketed_paste",
        "description": "Heap-based Buffer Overflow in GitHub repository vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/806d037671e133bd28a7864248763f643967973a",
        "commit_title": "patch 8.2.4218: illegal memory access with bracketed paste in Ex mode",
        "commit_text": " Problem:    Illegal memory access with bracketed paste in Ex mode. Solution:   Reserve space for the trailing NUL.",
        "func_before": "int\nbracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    if (gap != NULL && ga_grow(gap, idx) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}",
        "func": "int\nbracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    // add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -52,7 +52,8 @@\n \t\t    break;\n \n \t\tcase PASTE_EX:\n-\t\t    if (gap != NULL && ga_grow(gap, idx) == OK)\n+\t\t    // add one for the NUL that is going to be appended\n+\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n \t\t    {\n \t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n \t\t\t\t\t\t\t     buf, (size_t)idx);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    if (gap != NULL && ga_grow(gap, idx) == OK)"
            ],
            "added_lines": [
                "\t\t    // add one for the NUL that is going to be appended",
                "\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0407",
        "func_name": "vim/yank_copy_line",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/44db8213d38c39877d2148eff6a72f4beccfb94e",
        "commit_title": "patch 8.2.4219: reading before the start of the line",
        "commit_text": " Problem:    Reading before the start of the line. Solution:   Check boundary before trying to read the character.",
        "func_before": "static int\nyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}",
        "func": "static int\nyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n     {\n \tint s = bd->textlen + bd->endspaces;\n \n-\twhile (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)\n+\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n \t{\n \t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n \t    pnew--;",
        "diff_line_info": {
            "deleted_lines": [
                "\twhile (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)"
            ],
            "added_lines": [
                "\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0417",
        "func_name": "vim/tabstop_set",
        "description": "Heap-based Buffer Overflow GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/652dee448618589de5528a9e9a36995803f5557a",
        "commit_title": "patch 8.2.4245: \":retab 0\" may cause illegal memory access",
        "commit_text": " Problem:    \":retab 0\" may cause illegal memory access. Solution:   Limit the value of 'tabstop' to 10000.",
        "func_before": "int\ntabstop_set(char_u *var, int **array)\n{\n    int\t    valcount = 1;\n    int\t    t;\n    char_u  *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn OK;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_argument_must_be_positive));\n\t\telse\n\t\t    semsg(_(e_invalid_argument_str), cp);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\tsemsg(_(e_invalid_argument_str), var);\n\treturn FAIL;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FAIL;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\tint n = atoi((char *)cp);\n\n\t// Catch negative values, overflow and ridiculous big values.\n\tif (n < 0 || n > 9999)\n\t{\n\t    semsg(_(e_invalid_argument_str), cp);\n\t    vim_free(*array);\n\t    *array = NULL;\n\t    return FAIL;\n\t}\n\t(*array)[t++] = n;\n\twhile (*cp != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return OK;\n}",
        "func": "int\ntabstop_set(char_u *var, int **array)\n{\n    int\t    valcount = 1;\n    int\t    t;\n    char_u  *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn OK;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_argument_must_be_positive));\n\t\telse\n\t\t    semsg(_(e_invalid_argument_str), cp);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\tsemsg(_(e_invalid_argument_str), var);\n\treturn FAIL;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FAIL;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\tint n = atoi((char *)cp);\n\n\t// Catch negative values, overflow and ridiculous big values.\n\tif (n < 0 || n > TABSTOP_MAX)\n\t{\n\t    semsg(_(e_invalid_argument_str), cp);\n\t    vim_free(*array);\n\t    *array = NULL;\n\t    return FAIL;\n\t}\n\t(*array)[t++] = n;\n\twhile (*cp != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n \tint n = atoi((char *)cp);\n \n \t// Catch negative values, overflow and ridiculous big values.\n-\tif (n < 0 || n > 9999)\n+\tif (n < 0 || n > TABSTOP_MAX)\n \t{\n \t    semsg(_(e_invalid_argument_str), cp);\n \t    vim_free(*array);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (n < 0 || n > 9999)"
            ],
            "added_lines": [
                "\tif (n < 0 || n > TABSTOP_MAX)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0417",
        "func_name": "vim/ex_retab",
        "description": "Heap-based Buffer Overflow GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/652dee448618589de5528a9e9a36995803f5557a",
        "commit_title": "patch 8.2.4245: \":retab 0\" may cause illegal memory access",
        "commit_text": " Problem:    \":retab 0\" may cause illegal memory access. Solution:   Limit the value of 'tabstop' to 10000.",
        "func_before": "void\nex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > 9999)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interrupted));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}",
        "func": "void\nex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > TABSTOP_MAX)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interrupted));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,7 +53,7 @@\n \temsg(_(e_argument_must_be_positive));\n \treturn;\n     }\n-    if (new_ts < 0 || new_ts > 9999)\n+    if (new_ts < 0 || new_ts > TABSTOP_MAX)\n     {\n \tsemsg(_(e_invalid_argument_str), eap->arg);\n \treturn;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (new_ts < 0 || new_ts > 9999)"
            ],
            "added_lines": [
                "    if (new_ts < 0 || new_ts > TABSTOP_MAX)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0417",
        "func_name": "vim/paste_option_changed",
        "description": "Heap-based Buffer Overflow GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/652dee448618589de5528a9e9a36995803f5557a",
        "commit_title": "patch 8.2.4245: \":retab 0\" may cause illegal memory access",
        "commit_text": " Problem:    \":retab 0\" may cause illegal memory access. Solution:   Limit the value of 'tabstop' to 10000.",
        "func_before": "static void\npaste_option_changed(void)\n{\n    static int\told_p_paste = FALSE;\n    static int\tsave_sm = 0;\n    static int\tsave_sta = 0;\n#ifdef FEAT_CMDL_INFO\n    static int\tsave_ru = 0;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    static int\tsave_ri = 0;\n    static int\tsave_hkmap = 0;\n#endif\n    buf_T\t*buf;\n\n    if (p_paste)\n    {\n\t/*\n\t * Paste switched from off to on.\n\t * Save the current values, so they can be restored later.\n\t */\n\tif (!old_p_paste)\n\t{\n\t    // save options for each buffer\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tbuf->b_p_tw_nopaste = buf->b_p_tw;\n\t\tbuf->b_p_wm_nopaste = buf->b_p_wm;\n\t\tbuf->b_p_sts_nopaste = buf->b_p_sts;\n\t\tbuf->b_p_ai_nopaste = buf->b_p_ai;\n\t\tbuf->b_p_et_nopaste = buf->b_p_et;\n#ifdef FEAT_VARTABS\n\t\tif (buf->b_p_vsts_nopaste)\n\t\t    vim_free(buf->b_p_vsts_nopaste);\n\t\tbuf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option\n\t\t\t\t     ? vim_strsave(buf->b_p_vsts) : NULL;\n#endif\n\t    }\n\n\t    // save global options\n\t    save_sm = p_sm;\n\t    save_sta = p_sta;\n#ifdef FEAT_CMDL_INFO\n\t    save_ru = p_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    save_ri = p_ri;\n\t    save_hkmap = p_hkmap;\n#endif\n\t    // save global values for local buffer options\n\t    p_ai_nopaste = p_ai;\n\t    p_et_nopaste = p_et;\n\t    p_sts_nopaste = p_sts;\n\t    p_tw_nopaste = p_tw;\n\t    p_wm_nopaste = p_wm;\n#ifdef FEAT_VARTABS\n\t    if (p_vsts_nopaste)\n\t\tvim_free(p_vsts_nopaste);\n\t    p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL;\n#endif\n\t}\n\n\t/*\n\t * Always set the option values, also when 'paste' is set when it is\n\t * already on.\n\t */\n\t// set options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = 0;\t    // textwidth is 0\n\t    buf->b_p_wm = 0;\t    // wrapmargin is 0\n\t    buf->b_p_sts = 0;\t    // softtabstop is 0\n\t    buf->b_p_ai = 0;\t    // no auto-indent\n\t    buf->b_p_et = 0;\t    // no expandtab\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    buf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// set global options\n\tp_sm = 0;\t\t    // no showmatch\n\tp_sta = 0;\t\t    // no smarttab\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru)\n\t    status_redraw_all();    // redraw to remove the ruler\n\tp_ru = 0;\t\t    // no ruler\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = 0;\t\t    // no reverse insert\n\tp_hkmap = 0;\t\t    // no Hebrew keyboard\n#endif\n\t// set global values for local buffer options\n\tp_tw = 0;\n\tp_wm = 0;\n\tp_sts = 0;\n\tp_ai = 0;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = empty_option;\n#endif\n    }\n\n    /*\n     * Paste switched from on to off: Restore saved values.\n     */\n    else if (old_p_paste)\n    {\n\t// restore options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = buf->b_p_tw_nopaste;\n\t    buf->b_p_wm = buf->b_p_wm_nopaste;\n\t    buf->b_p_sts = buf->b_p_sts_nopaste;\n\t    buf->b_p_ai = buf->b_p_ai_nopaste;\n\t    buf->b_p_et = buf->b_p_et_nopaste;\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n\t\t\t ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n\t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// restore global options\n\tp_sm = save_sm;\n\tp_sta = save_sta;\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru != save_ru)\n\t    status_redraw_all();    // redraw to draw the ruler\n\tp_ru = save_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = save_ri;\n\tp_hkmap = save_hkmap;\n#endif\n\t// set global values for local buffer options\n\tp_ai = p_ai_nopaste;\n\tp_et = p_et_nopaste;\n\tp_sts = p_sts_nopaste;\n\tp_tw = p_tw_nopaste;\n\tp_wm = p_wm_nopaste;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;\n#endif\n    }\n\n    old_p_paste = p_paste;\n}",
        "func": "static void\npaste_option_changed(void)\n{\n    static int\told_p_paste = FALSE;\n    static int\tsave_sm = 0;\n    static int\tsave_sta = 0;\n#ifdef FEAT_CMDL_INFO\n    static int\tsave_ru = 0;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    static int\tsave_ri = 0;\n    static int\tsave_hkmap = 0;\n#endif\n    buf_T\t*buf;\n\n    if (p_paste)\n    {\n\t/*\n\t * Paste switched from off to on.\n\t * Save the current values, so they can be restored later.\n\t */\n\tif (!old_p_paste)\n\t{\n\t    // save options for each buffer\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tbuf->b_p_tw_nopaste = buf->b_p_tw;\n\t\tbuf->b_p_wm_nopaste = buf->b_p_wm;\n\t\tbuf->b_p_sts_nopaste = buf->b_p_sts;\n\t\tbuf->b_p_ai_nopaste = buf->b_p_ai;\n\t\tbuf->b_p_et_nopaste = buf->b_p_et;\n#ifdef FEAT_VARTABS\n\t\tif (buf->b_p_vsts_nopaste)\n\t\t    vim_free(buf->b_p_vsts_nopaste);\n\t\tbuf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option\n\t\t\t\t     ? vim_strsave(buf->b_p_vsts) : NULL;\n#endif\n\t    }\n\n\t    // save global options\n\t    save_sm = p_sm;\n\t    save_sta = p_sta;\n#ifdef FEAT_CMDL_INFO\n\t    save_ru = p_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    save_ri = p_ri;\n\t    save_hkmap = p_hkmap;\n#endif\n\t    // save global values for local buffer options\n\t    p_ai_nopaste = p_ai;\n\t    p_et_nopaste = p_et;\n\t    p_sts_nopaste = p_sts;\n\t    p_tw_nopaste = p_tw;\n\t    p_wm_nopaste = p_wm;\n#ifdef FEAT_VARTABS\n\t    if (p_vsts_nopaste)\n\t\tvim_free(p_vsts_nopaste);\n\t    p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL;\n#endif\n\t}\n\n\t/*\n\t * Always set the option values, also when 'paste' is set when it is\n\t * already on.\n\t */\n\t// set options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = 0;\t    // textwidth is 0\n\t    buf->b_p_wm = 0;\t    // wrapmargin is 0\n\t    buf->b_p_sts = 0;\t    // softtabstop is 0\n\t    buf->b_p_ai = 0;\t    // no auto-indent\n\t    buf->b_p_et = 0;\t    // no expandtab\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = empty_option;\n\t    VIM_CLEAR(buf->b_p_vsts_array);\n#endif\n\t}\n\n\t// set global options\n\tp_sm = 0;\t\t    // no showmatch\n\tp_sta = 0;\t\t    // no smarttab\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru)\n\t    status_redraw_all();    // redraw to remove the ruler\n\tp_ru = 0;\t\t    // no ruler\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = 0;\t\t    // no reverse insert\n\tp_hkmap = 0;\t\t    // no Hebrew keyboard\n#endif\n\t// set global values for local buffer options\n\tp_tw = 0;\n\tp_wm = 0;\n\tp_sts = 0;\n\tp_ai = 0;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = empty_option;\n#endif\n    }\n\n    /*\n     * Paste switched from on to off: Restore saved values.\n     */\n    else if (old_p_paste)\n    {\n\t// restore options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = buf->b_p_tw_nopaste;\n\t    buf->b_p_wm = buf->b_p_wm_nopaste;\n\t    buf->b_p_sts = buf->b_p_sts_nopaste;\n\t    buf->b_p_ai = buf->b_p_ai_nopaste;\n\t    buf->b_p_et = buf->b_p_et_nopaste;\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n\t\t\t ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;\n\t    vim_free(buf->b_p_vsts_array);\n\t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n\t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = NULL;\n#endif\n\t}\n\n\t// restore global options\n\tp_sm = save_sm;\n\tp_sta = save_sta;\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru != save_ru)\n\t    status_redraw_all();    // redraw to draw the ruler\n\tp_ru = save_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = save_ri;\n\tp_hkmap = save_hkmap;\n#endif\n\t// set global values for local buffer options\n\tp_ai = p_ai_nopaste;\n\tp_et = p_et_nopaste;\n\tp_sts = p_sts_nopaste;\n\tp_tw = p_tw_nopaste;\n\tp_wm = p_wm_nopaste;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;\n#endif\n    }\n\n    old_p_paste = p_paste;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,9 +76,7 @@\n \t    if (buf->b_p_vsts)\n \t\tfree_string_option(buf->b_p_vsts);\n \t    buf->b_p_vsts = empty_option;\n-\t    if (buf->b_p_vsts_array)\n-\t\tvim_free(buf->b_p_vsts_array);\n-\t    buf->b_p_vsts_array = 0;\n+\t    VIM_CLEAR(buf->b_p_vsts_array);\n #endif\n \t}\n \n@@ -124,12 +122,11 @@\n \t\tfree_string_option(buf->b_p_vsts);\n \t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n \t\t\t ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;\n-\t    if (buf->b_p_vsts_array)\n-\t\tvim_free(buf->b_p_vsts_array);\n+\t    vim_free(buf->b_p_vsts_array);\n \t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n \t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n \t    else\n-\t\tbuf->b_p_vsts_array = 0;\n+\t\tbuf->b_p_vsts_array = NULL;\n #endif\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t    if (buf->b_p_vsts_array)",
                "\t\tvim_free(buf->b_p_vsts_array);",
                "\t    buf->b_p_vsts_array = 0;",
                "\t    if (buf->b_p_vsts_array)",
                "\t\tvim_free(buf->b_p_vsts_array);",
                "\t\tbuf->b_p_vsts_array = 0;"
            ],
            "added_lines": [
                "\t    VIM_CLEAR(buf->b_p_vsts_array);",
                "\t    vim_free(buf->b_p_vsts_array);",
                "\t\tbuf->b_p_vsts_array = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0417",
        "func_name": "vim/buf_copy_options",
        "description": "Heap-based Buffer Overflow GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/652dee448618589de5528a9e9a36995803f5557a",
        "commit_title": "patch 8.2.4245: \":retab 0\" may cause illegal memory access",
        "commit_text": " Problem:    \":retab 0\" may cause illegal memory access. Solution:   Limit the value of 'tabstop' to 10000.",
        "func_before": "void\nbuf_copy_options(buf_T *buf, int flags)\n{\n    int\t\tshould_copy = TRUE;\n    char_u\t*save_p_isk = NULL;\t    // init for GCC\n    int\t\tdont_do_help;\n    int\t\tdid_isk = FALSE;\n\n    /*\n     * Skip this when the option defaults have not been set yet.  Happens when\n     * main() allocates the first buffer.\n     */\n    if (p_cpo != NULL)\n    {\n\t/*\n\t * Always copy when entering and 'cpo' contains 'S'.\n\t * Don't copy when already initialized.\n\t * Don't copy when 'cpo' contains 's' and not entering.\n\t * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n\t * yes\t  yes\t       X\t X\tTRUE\n\t * yes\t  no\t      yes\t X\tFALSE\n\t * no\t   X\t      yes\t X\tFALSE\n\t *  X\t  no\t      no\tyes\tFALSE\n\t *  X\t  no\t      no\tno\tTRUE\n\t * no\t  yes\t      no\t X\tTRUE\n\t */\n\tif ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n\t\t&& (buf->b_p_initialized\n\t\t    || (!(flags & BCO_ENTER)\n\t\t\t&& vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n\t    should_copy = FALSE;\n\n\tif (should_copy || (flags & BCO_ALWAYS))\n\t{\n#ifdef FEAT_EVAL\n\t    CLEAR_FIELD(buf->b_p_script_ctx);\n\t    init_buf_opt_idx();\n#endif\n\t    // Don't copy the options specific to a help buffer when\n\t    // BCO_NOHELP is given or the options were initialized already\n\t    // (jumping back to a help file with CTRL-T or CTRL-O)\n\t    dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n\t\t\t\t\t\t       || buf->b_p_initialized;\n\t    if (dont_do_help)\t\t// don't free b_p_isk\n\t    {\n\t\tsave_p_isk = buf->b_p_isk;\n\t\tbuf->b_p_isk = NULL;\n\t    }\n\t    /*\n\t     * Always free the allocated strings.  If not already initialized,\n\t     * reset 'readonly' and copy 'fileformat'.\n\t     */\n\t    if (!buf->b_p_initialized)\n\t    {\n\t\tfree_buf_options(buf, TRUE);\n\t\tbuf->b_p_ro = FALSE;\t\t// don't copy readonly\n\t\tbuf->b_p_tx = p_tx;\n\t\tbuf->b_p_fenc = vim_strsave(p_fenc);\n\t\tswitch (*p_ffs)\n\t\t{\n\t\t    case 'm':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;\n\t\t    case 'd':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;\n\t\t    case 'u':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;\n\t\t    default:\n\t\t\tbuf->b_p_ff = vim_strsave(p_ff);\n\t\t}\n\t\tif (buf->b_p_ff != NULL)\n\t\t    buf->b_start_ffc = *buf->b_p_ff;\n\t\tbuf->b_p_bh = empty_option;\n\t\tbuf->b_p_bt = empty_option;\n\t    }\n\t    else\n\t\tfree_buf_options(buf, FALSE);\n\n\t    buf->b_p_ai = p_ai;\n\t    COPY_OPT_SCTX(buf, BV_AI);\n\t    buf->b_p_ai_nopaste = p_ai_nopaste;\n\t    buf->b_p_sw = p_sw;\n\t    COPY_OPT_SCTX(buf, BV_SW);\n\t    buf->b_p_tw = p_tw;\n\t    COPY_OPT_SCTX(buf, BV_TW);\n\t    buf->b_p_tw_nopaste = p_tw_nopaste;\n\t    buf->b_p_tw_nobin = p_tw_nobin;\n\t    buf->b_p_wm = p_wm;\n\t    COPY_OPT_SCTX(buf, BV_WM);\n\t    buf->b_p_wm_nopaste = p_wm_nopaste;\n\t    buf->b_p_wm_nobin = p_wm_nobin;\n\t    buf->b_p_bin = p_bin;\n\t    COPY_OPT_SCTX(buf, BV_BIN);\n\t    buf->b_p_bomb = p_bomb;\n\t    COPY_OPT_SCTX(buf, BV_BOMB);\n\t    buf->b_p_fixeol = p_fixeol;\n\t    COPY_OPT_SCTX(buf, BV_FIXEOL);\n\t    buf->b_p_et = p_et;\n\t    COPY_OPT_SCTX(buf, BV_ET);\n\t    buf->b_p_et_nobin = p_et_nobin;\n\t    buf->b_p_et_nopaste = p_et_nopaste;\n\t    buf->b_p_ml = p_ml;\n\t    COPY_OPT_SCTX(buf, BV_ML);\n\t    buf->b_p_ml_nobin = p_ml_nobin;\n\t    buf->b_p_inf = p_inf;\n\t    COPY_OPT_SCTX(buf, BV_INF);\n\t    if (cmdmod.cmod_flags & CMOD_NOSWAPFILE)\n\t\tbuf->b_p_swf = FALSE;\n\t    else\n\t    {\n\t\tbuf->b_p_swf = p_swf;\n\t\tCOPY_OPT_SCTX(buf, BV_SWF);\n\t    }\n\t    buf->b_p_cpt = vim_strsave(p_cpt);\n\t    COPY_OPT_SCTX(buf, BV_CPT);\n#ifdef BACKSLASH_IN_FILENAME\n\t    buf->b_p_csl = vim_strsave(p_csl);\n\t    COPY_OPT_SCTX(buf, BV_CSL);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_cfu = vim_strsave(p_cfu);\n\t    COPY_OPT_SCTX(buf, BV_CFU);\n\t    set_buflocal_cfu_callback(buf);\n\t    buf->b_p_ofu = vim_strsave(p_ofu);\n\t    COPY_OPT_SCTX(buf, BV_OFU);\n\t    set_buflocal_ofu_callback(buf);\n#endif\n#ifdef FEAT_EVAL\n\t    buf->b_p_tfu = vim_strsave(p_tfu);\n\t    COPY_OPT_SCTX(buf, BV_TFU);\n\t    set_buflocal_tfu_callback(buf);\n#endif\n\t    buf->b_p_sts = p_sts;\n\t    COPY_OPT_SCTX(buf, BV_STS);\n\t    buf->b_p_sts_nopaste = p_sts_nopaste;\n#ifdef FEAT_VARTABS\n\t    buf->b_p_vsts = vim_strsave(p_vsts);\n\t    COPY_OPT_SCTX(buf, BV_VSTS);\n\t    if (p_vsts && p_vsts != empty_option)\n\t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n\t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n\t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n#endif\n\t    buf->b_p_sn = p_sn;\n\t    COPY_OPT_SCTX(buf, BV_SN);\n\t    buf->b_p_com = vim_strsave(p_com);\n\t    COPY_OPT_SCTX(buf, BV_COM);\n#ifdef FEAT_FOLDING\n\t    buf->b_p_cms = vim_strsave(p_cms);\n\t    COPY_OPT_SCTX(buf, BV_CMS);\n#endif\n\t    buf->b_p_fo = vim_strsave(p_fo);\n\t    COPY_OPT_SCTX(buf, BV_FO);\n\t    buf->b_p_flp = vim_strsave(p_flp);\n\t    COPY_OPT_SCTX(buf, BV_FLP);\n\t    // NOTE: Valgrind may report a bogus memory leak for 'nrformats'\n\t    // when it is set to 8 bytes in defaults.vim.\n\t    buf->b_p_nf = vim_strsave(p_nf);\n\t    COPY_OPT_SCTX(buf, BV_NF);\n\t    buf->b_p_mps = vim_strsave(p_mps);\n\t    COPY_OPT_SCTX(buf, BV_MPS);\n#ifdef FEAT_SMARTINDENT\n\t    buf->b_p_si = p_si;\n\t    COPY_OPT_SCTX(buf, BV_SI);\n#endif\n\t    buf->b_p_ci = p_ci;\n\t    COPY_OPT_SCTX(buf, BV_CI);\n#ifdef FEAT_CINDENT\n\t    buf->b_p_cin = p_cin;\n\t    COPY_OPT_SCTX(buf, BV_CIN);\n\t    buf->b_p_cink = vim_strsave(p_cink);\n\t    COPY_OPT_SCTX(buf, BV_CINK);\n\t    buf->b_p_cino = vim_strsave(p_cino);\n\t    COPY_OPT_SCTX(buf, BV_CINO);\n#endif\n\t    // Don't copy 'filetype', it must be detected\n\t    buf->b_p_ft = empty_option;\n\t    buf->b_p_pi = p_pi;\n\t    COPY_OPT_SCTX(buf, BV_PI);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    buf->b_p_cinw = vim_strsave(p_cinw);\n\t    COPY_OPT_SCTX(buf, BV_CINW);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lisp = p_lisp;\n\t    COPY_OPT_SCTX(buf, BV_LISP);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // Don't copy 'syntax', it must be set\n\t    buf->b_p_syn = empty_option;\n\t    buf->b_p_smc = p_smc;\n\t    COPY_OPT_SCTX(buf, BV_SMC);\n\t    buf->b_s.b_syn_isk = empty_option;\n#endif\n#ifdef FEAT_SPELL\n\t    buf->b_s.b_p_spc = vim_strsave(p_spc);\n\t    COPY_OPT_SCTX(buf, BV_SPC);\n\t    (void)compile_cap_prog(&buf->b_s);\n\t    buf->b_s.b_p_spf = vim_strsave(p_spf);\n\t    COPY_OPT_SCTX(buf, BV_SPF);\n\t    buf->b_s.b_p_spl = vim_strsave(p_spl);\n\t    COPY_OPT_SCTX(buf, BV_SPL);\n\t    buf->b_s.b_p_spo = vim_strsave(p_spo);\n\t    COPY_OPT_SCTX(buf, BV_SPO);\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\t    buf->b_p_inde = vim_strsave(p_inde);\n\t    COPY_OPT_SCTX(buf, BV_INDE);\n\t    buf->b_p_indk = vim_strsave(p_indk);\n\t    COPY_OPT_SCTX(buf, BV_INDK);\n#endif\n\t    buf->b_p_fp = empty_option;\n#if defined(FEAT_EVAL)\n\t    buf->b_p_fex = vim_strsave(p_fex);\n\t    COPY_OPT_SCTX(buf, BV_FEX);\n#endif\n#ifdef FEAT_CRYPT\n\t    buf->b_p_key = vim_strsave(p_key);\n\t    COPY_OPT_SCTX(buf, BV_KEY);\n#endif\n#ifdef FEAT_SEARCHPATH\n\t    buf->b_p_sua = vim_strsave(p_sua);\n\t    COPY_OPT_SCTX(buf, BV_SUA);\n#endif\n#ifdef FEAT_KEYMAP\n\t    buf->b_p_keymap = vim_strsave(p_keymap);\n\t    COPY_OPT_SCTX(buf, BV_KMAP);\n\t    buf->b_kmap_state |= KEYMAP_INIT;\n#endif\n#ifdef FEAT_TERMINAL\n\t    buf->b_p_twsl = p_twsl;\n\t    COPY_OPT_SCTX(buf, BV_TWSL);\n#endif\n\t    // This isn't really an option, but copying the langmap and IME\n\t    // state from the current buffer is better than resetting it.\n\t    buf->b_p_iminsert = p_iminsert;\n\t    COPY_OPT_SCTX(buf, BV_IMI);\n\t    buf->b_p_imsearch = p_imsearch;\n\t    COPY_OPT_SCTX(buf, BV_IMS);\n\n\t    // options that are normally global but also have a local value\n\t    // are not copied, start using the global value\n\t    buf->b_p_ar = -1;\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    buf->b_p_bkc = empty_option;\n\t    buf->b_bkc_flags = 0;\n#ifdef FEAT_QUICKFIX\n\t    buf->b_p_gp = empty_option;\n\t    buf->b_p_mp = empty_option;\n\t    buf->b_p_efm = empty_option;\n#endif\n\t    buf->b_p_ep = empty_option;\n\t    buf->b_p_kp = empty_option;\n\t    buf->b_p_path = empty_option;\n\t    buf->b_p_tags = empty_option;\n\t    buf->b_p_tc = empty_option;\n\t    buf->b_tc_flags = 0;\n#ifdef FEAT_FIND_ID\n\t    buf->b_p_def = empty_option;\n\t    buf->b_p_inc = empty_option;\n# ifdef FEAT_EVAL\n\t    buf->b_p_inex = vim_strsave(p_inex);\n\t    COPY_OPT_SCTX(buf, BV_INEX);\n# endif\n#endif\n\t    buf->b_p_dict = empty_option;\n\t    buf->b_p_tsr = empty_option;\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_tsrfu = empty_option;\n#endif\n#ifdef FEAT_TEXTOBJ\n\t    buf->b_p_qe = vim_strsave(p_qe);\n\t    COPY_OPT_SCTX(buf, BV_QE);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    buf->b_p_bexpr = empty_option;\n#endif\n#if defined(FEAT_CRYPT)\n\t    buf->b_p_cm = empty_option;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t    buf->b_p_udf = p_udf;\n\t    COPY_OPT_SCTX(buf, BV_UDF);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lw = empty_option;\n#endif\n\t    buf->b_p_menc = empty_option;\n\n\t    /*\n\t     * Don't copy the options set by ex_help(), use the saved values,\n\t     * when going from a help buffer to a non-help buffer.\n\t     * Don't touch these at all when BCO_NOHELP is used and going from\n\t     * or to a help buffer.\n\t     */\n\t    if (dont_do_help)\n\t    {\n\t\tbuf->b_p_isk = save_p_isk;\n#ifdef FEAT_VARTABS\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t    }\n\t    else\n\t    {\n\t\tbuf->b_p_isk = vim_strsave(p_isk);\n\t\tCOPY_OPT_SCTX(buf, BV_ISK);\n\t\tdid_isk = TRUE;\n\t\tbuf->b_p_ts = p_ts;\n\t\tCOPY_OPT_SCTX(buf, BV_TS);\n#ifdef FEAT_VARTABS\n\t\tbuf->b_p_vts = vim_strsave(p_vts);\n\t\tCOPY_OPT_SCTX(buf, BV_VTS);\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t\tbuf->b_help = FALSE;\n\t\tif (buf->b_p_bt[0] == 'h')\n\t\t    clear_string_option(&buf->b_p_bt);\n\t\tbuf->b_p_ma = p_ma;\n\t\tCOPY_OPT_SCTX(buf, BV_MA);\n\t    }\n\t}\n\n\t/*\n\t * When the options should be copied (ignoring BCO_ALWAYS), set the\n\t * flag that indicates that the options have been initialized.\n\t */\n\tif (should_copy)\n\t    buf->b_p_initialized = TRUE;\n    }\n\n    check_buf_options(buf);\t    // make sure we don't have NULLs\n    if (did_isk)\n\t(void)buf_init_chartab(buf, FALSE);\n}",
        "func": "void\nbuf_copy_options(buf_T *buf, int flags)\n{\n    int\t\tshould_copy = TRUE;\n    char_u\t*save_p_isk = NULL;\t    // init for GCC\n    int\t\tdont_do_help;\n    int\t\tdid_isk = FALSE;\n\n    /*\n     * Skip this when the option defaults have not been set yet.  Happens when\n     * main() allocates the first buffer.\n     */\n    if (p_cpo != NULL)\n    {\n\t/*\n\t * Always copy when entering and 'cpo' contains 'S'.\n\t * Don't copy when already initialized.\n\t * Don't copy when 'cpo' contains 's' and not entering.\n\t * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n\t * yes\t  yes\t       X\t X\tTRUE\n\t * yes\t  no\t      yes\t X\tFALSE\n\t * no\t   X\t      yes\t X\tFALSE\n\t *  X\t  no\t      no\tyes\tFALSE\n\t *  X\t  no\t      no\tno\tTRUE\n\t * no\t  yes\t      no\t X\tTRUE\n\t */\n\tif ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n\t\t&& (buf->b_p_initialized\n\t\t    || (!(flags & BCO_ENTER)\n\t\t\t&& vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n\t    should_copy = FALSE;\n\n\tif (should_copy || (flags & BCO_ALWAYS))\n\t{\n#ifdef FEAT_EVAL\n\t    CLEAR_FIELD(buf->b_p_script_ctx);\n\t    init_buf_opt_idx();\n#endif\n\t    // Don't copy the options specific to a help buffer when\n\t    // BCO_NOHELP is given or the options were initialized already\n\t    // (jumping back to a help file with CTRL-T or CTRL-O)\n\t    dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n\t\t\t\t\t\t       || buf->b_p_initialized;\n\t    if (dont_do_help)\t\t// don't free b_p_isk\n\t    {\n\t\tsave_p_isk = buf->b_p_isk;\n\t\tbuf->b_p_isk = NULL;\n\t    }\n\t    /*\n\t     * Always free the allocated strings.  If not already initialized,\n\t     * reset 'readonly' and copy 'fileformat'.\n\t     */\n\t    if (!buf->b_p_initialized)\n\t    {\n\t\tfree_buf_options(buf, TRUE);\n\t\tbuf->b_p_ro = FALSE;\t\t// don't copy readonly\n\t\tbuf->b_p_tx = p_tx;\n\t\tbuf->b_p_fenc = vim_strsave(p_fenc);\n\t\tswitch (*p_ffs)\n\t\t{\n\t\t    case 'm':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;\n\t\t    case 'd':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;\n\t\t    case 'u':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;\n\t\t    default:\n\t\t\tbuf->b_p_ff = vim_strsave(p_ff);\n\t\t}\n\t\tif (buf->b_p_ff != NULL)\n\t\t    buf->b_start_ffc = *buf->b_p_ff;\n\t\tbuf->b_p_bh = empty_option;\n\t\tbuf->b_p_bt = empty_option;\n\t    }\n\t    else\n\t\tfree_buf_options(buf, FALSE);\n\n\t    buf->b_p_ai = p_ai;\n\t    COPY_OPT_SCTX(buf, BV_AI);\n\t    buf->b_p_ai_nopaste = p_ai_nopaste;\n\t    buf->b_p_sw = p_sw;\n\t    COPY_OPT_SCTX(buf, BV_SW);\n\t    buf->b_p_tw = p_tw;\n\t    COPY_OPT_SCTX(buf, BV_TW);\n\t    buf->b_p_tw_nopaste = p_tw_nopaste;\n\t    buf->b_p_tw_nobin = p_tw_nobin;\n\t    buf->b_p_wm = p_wm;\n\t    COPY_OPT_SCTX(buf, BV_WM);\n\t    buf->b_p_wm_nopaste = p_wm_nopaste;\n\t    buf->b_p_wm_nobin = p_wm_nobin;\n\t    buf->b_p_bin = p_bin;\n\t    COPY_OPT_SCTX(buf, BV_BIN);\n\t    buf->b_p_bomb = p_bomb;\n\t    COPY_OPT_SCTX(buf, BV_BOMB);\n\t    buf->b_p_fixeol = p_fixeol;\n\t    COPY_OPT_SCTX(buf, BV_FIXEOL);\n\t    buf->b_p_et = p_et;\n\t    COPY_OPT_SCTX(buf, BV_ET);\n\t    buf->b_p_et_nobin = p_et_nobin;\n\t    buf->b_p_et_nopaste = p_et_nopaste;\n\t    buf->b_p_ml = p_ml;\n\t    COPY_OPT_SCTX(buf, BV_ML);\n\t    buf->b_p_ml_nobin = p_ml_nobin;\n\t    buf->b_p_inf = p_inf;\n\t    COPY_OPT_SCTX(buf, BV_INF);\n\t    if (cmdmod.cmod_flags & CMOD_NOSWAPFILE)\n\t\tbuf->b_p_swf = FALSE;\n\t    else\n\t    {\n\t\tbuf->b_p_swf = p_swf;\n\t\tCOPY_OPT_SCTX(buf, BV_SWF);\n\t    }\n\t    buf->b_p_cpt = vim_strsave(p_cpt);\n\t    COPY_OPT_SCTX(buf, BV_CPT);\n#ifdef BACKSLASH_IN_FILENAME\n\t    buf->b_p_csl = vim_strsave(p_csl);\n\t    COPY_OPT_SCTX(buf, BV_CSL);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_cfu = vim_strsave(p_cfu);\n\t    COPY_OPT_SCTX(buf, BV_CFU);\n\t    set_buflocal_cfu_callback(buf);\n\t    buf->b_p_ofu = vim_strsave(p_ofu);\n\t    COPY_OPT_SCTX(buf, BV_OFU);\n\t    set_buflocal_ofu_callback(buf);\n#endif\n#ifdef FEAT_EVAL\n\t    buf->b_p_tfu = vim_strsave(p_tfu);\n\t    COPY_OPT_SCTX(buf, BV_TFU);\n\t    set_buflocal_tfu_callback(buf);\n#endif\n\t    buf->b_p_sts = p_sts;\n\t    COPY_OPT_SCTX(buf, BV_STS);\n\t    buf->b_p_sts_nopaste = p_sts_nopaste;\n#ifdef FEAT_VARTABS\n\t    buf->b_p_vsts = vim_strsave(p_vsts);\n\t    COPY_OPT_SCTX(buf, BV_VSTS);\n\t    if (p_vsts && p_vsts != empty_option)\n\t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = NULL;\n\t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n\t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n#endif\n\t    buf->b_p_sn = p_sn;\n\t    COPY_OPT_SCTX(buf, BV_SN);\n\t    buf->b_p_com = vim_strsave(p_com);\n\t    COPY_OPT_SCTX(buf, BV_COM);\n#ifdef FEAT_FOLDING\n\t    buf->b_p_cms = vim_strsave(p_cms);\n\t    COPY_OPT_SCTX(buf, BV_CMS);\n#endif\n\t    buf->b_p_fo = vim_strsave(p_fo);\n\t    COPY_OPT_SCTX(buf, BV_FO);\n\t    buf->b_p_flp = vim_strsave(p_flp);\n\t    COPY_OPT_SCTX(buf, BV_FLP);\n\t    // NOTE: Valgrind may report a bogus memory leak for 'nrformats'\n\t    // when it is set to 8 bytes in defaults.vim.\n\t    buf->b_p_nf = vim_strsave(p_nf);\n\t    COPY_OPT_SCTX(buf, BV_NF);\n\t    buf->b_p_mps = vim_strsave(p_mps);\n\t    COPY_OPT_SCTX(buf, BV_MPS);\n#ifdef FEAT_SMARTINDENT\n\t    buf->b_p_si = p_si;\n\t    COPY_OPT_SCTX(buf, BV_SI);\n#endif\n\t    buf->b_p_ci = p_ci;\n\t    COPY_OPT_SCTX(buf, BV_CI);\n#ifdef FEAT_CINDENT\n\t    buf->b_p_cin = p_cin;\n\t    COPY_OPT_SCTX(buf, BV_CIN);\n\t    buf->b_p_cink = vim_strsave(p_cink);\n\t    COPY_OPT_SCTX(buf, BV_CINK);\n\t    buf->b_p_cino = vim_strsave(p_cino);\n\t    COPY_OPT_SCTX(buf, BV_CINO);\n#endif\n\t    // Don't copy 'filetype', it must be detected\n\t    buf->b_p_ft = empty_option;\n\t    buf->b_p_pi = p_pi;\n\t    COPY_OPT_SCTX(buf, BV_PI);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    buf->b_p_cinw = vim_strsave(p_cinw);\n\t    COPY_OPT_SCTX(buf, BV_CINW);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lisp = p_lisp;\n\t    COPY_OPT_SCTX(buf, BV_LISP);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // Don't copy 'syntax', it must be set\n\t    buf->b_p_syn = empty_option;\n\t    buf->b_p_smc = p_smc;\n\t    COPY_OPT_SCTX(buf, BV_SMC);\n\t    buf->b_s.b_syn_isk = empty_option;\n#endif\n#ifdef FEAT_SPELL\n\t    buf->b_s.b_p_spc = vim_strsave(p_spc);\n\t    COPY_OPT_SCTX(buf, BV_SPC);\n\t    (void)compile_cap_prog(&buf->b_s);\n\t    buf->b_s.b_p_spf = vim_strsave(p_spf);\n\t    COPY_OPT_SCTX(buf, BV_SPF);\n\t    buf->b_s.b_p_spl = vim_strsave(p_spl);\n\t    COPY_OPT_SCTX(buf, BV_SPL);\n\t    buf->b_s.b_p_spo = vim_strsave(p_spo);\n\t    COPY_OPT_SCTX(buf, BV_SPO);\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\t    buf->b_p_inde = vim_strsave(p_inde);\n\t    COPY_OPT_SCTX(buf, BV_INDE);\n\t    buf->b_p_indk = vim_strsave(p_indk);\n\t    COPY_OPT_SCTX(buf, BV_INDK);\n#endif\n\t    buf->b_p_fp = empty_option;\n#if defined(FEAT_EVAL)\n\t    buf->b_p_fex = vim_strsave(p_fex);\n\t    COPY_OPT_SCTX(buf, BV_FEX);\n#endif\n#ifdef FEAT_CRYPT\n\t    buf->b_p_key = vim_strsave(p_key);\n\t    COPY_OPT_SCTX(buf, BV_KEY);\n#endif\n#ifdef FEAT_SEARCHPATH\n\t    buf->b_p_sua = vim_strsave(p_sua);\n\t    COPY_OPT_SCTX(buf, BV_SUA);\n#endif\n#ifdef FEAT_KEYMAP\n\t    buf->b_p_keymap = vim_strsave(p_keymap);\n\t    COPY_OPT_SCTX(buf, BV_KMAP);\n\t    buf->b_kmap_state |= KEYMAP_INIT;\n#endif\n#ifdef FEAT_TERMINAL\n\t    buf->b_p_twsl = p_twsl;\n\t    COPY_OPT_SCTX(buf, BV_TWSL);\n#endif\n\t    // This isn't really an option, but copying the langmap and IME\n\t    // state from the current buffer is better than resetting it.\n\t    buf->b_p_iminsert = p_iminsert;\n\t    COPY_OPT_SCTX(buf, BV_IMI);\n\t    buf->b_p_imsearch = p_imsearch;\n\t    COPY_OPT_SCTX(buf, BV_IMS);\n\n\t    // options that are normally global but also have a local value\n\t    // are not copied, start using the global value\n\t    buf->b_p_ar = -1;\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    buf->b_p_bkc = empty_option;\n\t    buf->b_bkc_flags = 0;\n#ifdef FEAT_QUICKFIX\n\t    buf->b_p_gp = empty_option;\n\t    buf->b_p_mp = empty_option;\n\t    buf->b_p_efm = empty_option;\n#endif\n\t    buf->b_p_ep = empty_option;\n\t    buf->b_p_kp = empty_option;\n\t    buf->b_p_path = empty_option;\n\t    buf->b_p_tags = empty_option;\n\t    buf->b_p_tc = empty_option;\n\t    buf->b_tc_flags = 0;\n#ifdef FEAT_FIND_ID\n\t    buf->b_p_def = empty_option;\n\t    buf->b_p_inc = empty_option;\n# ifdef FEAT_EVAL\n\t    buf->b_p_inex = vim_strsave(p_inex);\n\t    COPY_OPT_SCTX(buf, BV_INEX);\n# endif\n#endif\n\t    buf->b_p_dict = empty_option;\n\t    buf->b_p_tsr = empty_option;\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_tsrfu = empty_option;\n#endif\n#ifdef FEAT_TEXTOBJ\n\t    buf->b_p_qe = vim_strsave(p_qe);\n\t    COPY_OPT_SCTX(buf, BV_QE);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    buf->b_p_bexpr = empty_option;\n#endif\n#if defined(FEAT_CRYPT)\n\t    buf->b_p_cm = empty_option;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t    buf->b_p_udf = p_udf;\n\t    COPY_OPT_SCTX(buf, BV_UDF);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lw = empty_option;\n#endif\n\t    buf->b_p_menc = empty_option;\n\n\t    /*\n\t     * Don't copy the options set by ex_help(), use the saved values,\n\t     * when going from a help buffer to a non-help buffer.\n\t     * Don't touch these at all when BCO_NOHELP is used and going from\n\t     * or to a help buffer.\n\t     */\n\t    if (dont_do_help)\n\t    {\n\t\tbuf->b_p_isk = save_p_isk;\n#ifdef FEAT_VARTABS\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t    }\n\t    else\n\t    {\n\t\tbuf->b_p_isk = vim_strsave(p_isk);\n\t\tCOPY_OPT_SCTX(buf, BV_ISK);\n\t\tdid_isk = TRUE;\n\t\tbuf->b_p_ts = p_ts;\n\t\tCOPY_OPT_SCTX(buf, BV_TS);\n#ifdef FEAT_VARTABS\n\t\tbuf->b_p_vts = vim_strsave(p_vts);\n\t\tCOPY_OPT_SCTX(buf, BV_VTS);\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t\tbuf->b_help = FALSE;\n\t\tif (buf->b_p_bt[0] == 'h')\n\t\t    clear_string_option(&buf->b_p_bt);\n\t\tbuf->b_p_ma = p_ma;\n\t\tCOPY_OPT_SCTX(buf, BV_MA);\n\t    }\n\t}\n\n\t/*\n\t * When the options should be copied (ignoring BCO_ALWAYS), set the\n\t * flag that indicates that the options have been initialized.\n\t */\n\tif (should_copy)\n\t    buf->b_p_initialized = TRUE;\n    }\n\n    check_buf_options(buf);\t    // make sure we don't have NULLs\n    if (did_isk)\n\t(void)buf_init_chartab(buf, FALSE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -138,7 +138,7 @@\n \t    if (p_vsts && p_vsts != empty_option)\n \t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);\n \t    else\n-\t\tbuf->b_p_vsts_array = 0;\n+\t\tbuf->b_p_vsts_array = NULL;\n \t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n \t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tbuf->b_p_vsts_array = 0;"
            ],
            "added_lines": [
                "\t\tbuf->b_p_vsts_array = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0417",
        "func_name": "vim/set_num_option",
        "description": "Heap-based Buffer Overflow GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/652dee448618589de5528a9e9a36995803f5557a",
        "commit_title": "patch 8.2.4245: \":retab 0\" may cause illegal memory access",
        "commit_text": " Problem:    \":retab 0\" may cause illegal memory access. Solution:   Limit the value of 'tabstop' to 10000.",
        "func_before": "static char *\nset_num_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    long\tvalue,\t\t\t// new value\n    char\t*errbuf,\t\t// buffer for error messages\n    size_t\terrbuflen,\t\t// length of \"errbuf\"\n    int\t\topt_flags)\t\t// OPT_LOCAL, OPT_GLOBAL,\n\t\t\t\t\t// OPT_MODELINE, etc.\n{\n    char\t*errmsg = NULL;\n    long\told_value = *(long *)varp;\n#if defined(FEAT_EVAL)\n    long\told_global_value = 0;\t// only used when setting a local and\n\t\t\t\t\t// global option\n#endif\n    long\told_Rows = Rows;\t// remember old Rows\n    long\told_Columns = Columns;\t// remember old Columns\n    long\t*pp = (long *)varp;\n\n    // Disallow changing some options from secure mode.\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_not_allowed_here;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(long *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *pp = value;\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    if (curbuf->b_p_sw < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n#ifdef FEAT_VARTABS\n\t// Use the first 'vartabstop' value, or 'tabstop' if vts isn't in use.\n\tcurbuf->b_p_sw = tabstop_count(curbuf->b_p_vts_array) > 0\n\t               ? tabstop_first(curbuf->b_p_vts_array)\n\t\t       : curbuf->b_p_ts;\n#else\n\tcurbuf->b_p_sw = curbuf->b_p_ts;\n#endif\n    }\n\n    /*\n     * Number options that need some action when changed\n     */\n    if (pp == &p_wh || pp == &p_hh)\n    {\n\t// 'winheight' and 'helpheight'\n\tif (p_wh < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wh = 1;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight_cannot_be_smaller_than_winminheight;\n\t    p_wh = p_wmh;\n\t}\n\tif (p_hh < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_hh = 0;\n\t}\n\n\t// Change window height NOW\n\tif (!ONE_WINDOW)\n\t{\n\t    if (pp == &p_wh && curwin->w_height < p_wh)\n\t\twin_setheight((int)p_wh);\n\t    if (pp == &p_hh && curbuf->b_help && curwin->w_height < p_hh)\n\t\twin_setheight((int)p_hh);\n\t}\n    }\n    else if (pp == &p_wmh)\n    {\n\t// 'winminheight'\n\tif (p_wmh < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wmh = 0;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight_cannot_be_smaller_than_winminheight;\n\t    p_wmh = p_wh;\n\t}\n\twin_setminheight();\n    }\n    else if (pp == &p_wiw)\n    {\n\t// 'winwidth'\n\tif (p_wiw < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wiw = 1;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth_cannot_be_smaller_than_winminwidth;\n\t    p_wiw = p_wmw;\n\t}\n\n\t// Change window width NOW\n\tif (!ONE_WINDOW && curwin->w_width < p_wiw)\n\t    win_setwidth((int)p_wiw);\n    }\n    else if (pp == &p_wmw)\n    {\n\t// 'winminwidth'\n\tif (p_wmw < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wmw = 0;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth_cannot_be_smaller_than_winminwidth;\n\t    p_wmw = p_wiw;\n\t}\n\twin_setminwidth();\n    }\n\n    // (re)set last window status line\n    else if (pp == &p_ls)\n    {\n\tlast_status(FALSE);\n    }\n\n    // (re)set tab page line\n    else if (pp == &p_stal)\n    {\n\tshell_new_rows();\t// recompute window positions and heights\n    }\n\n#ifdef FEAT_GUI\n    else if (pp == &p_linespace)\n    {\n\t// Recompute gui.char_height and resize the Vim window to keep the\n\t// same number of lines.\n\tif (gui.in_use && gui_mch_adjust_charheight() == OK)\n\t    gui_set_shellsize(FALSE, FALSE, RESIZE_VERT);\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    // 'foldlevel'\n    else if (pp == &curwin->w_p_fdl)\n    {\n\tif (curwin->w_p_fdl < 0)\n\t    curwin->w_p_fdl = 0;\n\tnewFoldLevel();\n    }\n\n    // 'foldminlines'\n    else if (pp == &curwin->w_p_fml)\n    {\n\tfoldUpdateAll(curwin);\n    }\n\n    // 'foldnestmax'\n    else if (pp == &curwin->w_p_fdn)\n    {\n\tif (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n\n    // 'foldcolumn'\n    else if (pp == &curwin->w_p_fdc)\n    {\n\tif (curwin->w_p_fdc < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_fdc = 0;\n\t}\n\telse if (curwin->w_p_fdc > 12)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_fdc = 12;\n\t}\n    }\n#endif // FEAT_FOLDING\n\n#if defined(FEAT_FOLDING) || defined(FEAT_CINDENT)\n    // 'shiftwidth' or 'tabstop'\n    else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)\n    {\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n# ifdef FEAT_CINDENT\n\t// When 'shiftwidth' changes, or it's zero and 'tabstop' changes:\n\t// parse 'cinoptions'.\n\tif (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0)\n\t    parse_cino(curbuf);\n# endif\n    }\n#endif\n\n    // 'maxcombine'\n    else if (pp == &p_mco)\n    {\n\tif (p_mco > MAX_MCO)\n\t    p_mco = MAX_MCO;\n\telse if (p_mco < 0)\n\t    p_mco = 0;\n\tscreenclear();\t    // will re-allocate the screen\n    }\n\n    else if (pp == &curbuf->b_p_iminsert)\n    {\n\tif (curbuf->b_p_iminsert < 0 || curbuf->b_p_iminsert > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t}\n\tp_iminsert = curbuf->b_p_iminsert;\n\tif (termcap_active)\t// don't do this in the alternate screen\n\t    showmode();\n#if defined(FEAT_KEYMAP)\n\t// Show/unshow value of 'keymap' in status lines.\n\tstatus_redraw_curbuf();\n#endif\n    }\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    // 'imstyle'\n    else if (pp == &p_imst)\n    {\n\tif (p_imst != IM_ON_THE_SPOT && p_imst != IM_OVER_THE_SPOT)\n\t    errmsg = e_invalid_argument;\n    }\n#endif\n\n    else if (pp == &p_window)\n    {\n\tif (p_window < 1)\n\t    p_window = 1;\n\telse if (p_window >= Rows)\n\t    p_window = Rows - 1;\n    }\n\n    else if (pp == &curbuf->b_p_imsearch)\n    {\n\tif (curbuf->b_p_imsearch < -1 || curbuf->b_p_imsearch > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curbuf->b_p_imsearch = B_IMODE_NONE;\n\t}\n\tp_imsearch = curbuf->b_p_imsearch;\n    }\n\n    // if 'titlelen' has changed, redraw the title\n    else if (pp == &p_titlelen)\n    {\n\tif (p_titlelen < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_titlelen = 85;\n\t}\n\tif (starting != NO_SCREEN && old_value != p_titlelen)\n\t    need_maketitle = TRUE;\n    }\n\n    // if p_ch changed value, change the command line height\n    else if (pp == &p_ch)\n    {\n\tif (p_ch < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_ch = 1;\n\t}\n\tif (p_ch > Rows - min_rows() + 1)\n\t    p_ch = Rows - min_rows() + 1;\n\n\t// Only compute the new window layout when startup has been\n\t// completed. Otherwise the frame sizes may be wrong.\n\tif (p_ch != old_value && full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t   )\n\t    command_height();\n    }\n\n    // when 'updatecount' changes from zero to non-zero, open swap files\n    else if (pp == &p_uc)\n    {\n\tif (p_uc < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_uc = 100;\n\t}\n\tif (p_uc && !old_value)\n\t    ml_open_files();\n    }\n#ifdef FEAT_CONCEAL\n    else if (pp == &curwin->w_p_cole)\n    {\n\tif (curwin->w_p_cole < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_cole = 0;\n\t}\n\telse if (curwin->w_p_cole > 3)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_cole = 3;\n\t}\n    }\n#endif\n#ifdef MZSCHEME_GUI_THREADS\n    else if (pp == &p_mzq)\n\tmzvim_reset_timer();\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\n    // 'pyxversion'\n    else if (pp == &p_pyx)\n    {\n\tif (p_pyx != 0 && p_pyx != 2 && p_pyx != 3)\n\t    errmsg = e_invalid_argument;\n    }\n#endif\n\n    // sync undo before 'undolevels' changes\n    else if (pp == &p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tp_ul = old_value;\n\tu_sync(TRUE);\n\tp_ul = value;\n    }\n    else if (pp == &curbuf->b_p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tcurbuf->b_p_ul = old_value;\n\tu_sync(TRUE);\n\tcurbuf->b_p_ul = value;\n    }\n\n#ifdef FEAT_LINEBREAK\n    // 'numberwidth' must be positive\n    else if (pp == &curwin->w_p_nuw)\n    {\n\tif (curwin->w_p_nuw < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_nuw = 1;\n\t}\n\tif (curwin->w_p_nuw > 20)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_nuw = 20;\n\t}\n\tcurwin->w_nrwidth_line_count = 0; // trigger a redraw\n    }\n#endif\n\n    else if (pp == &curbuf->b_p_tw)\n    {\n\tif (curbuf->b_p_tw < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curbuf->b_p_tw = 0;\n\t}\n#ifdef FEAT_SYN_HL\n\t{\n\t    win_T\t*wp;\n\t    tabpage_T\t*tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\tcheck_colorcolumn(wp);\n\t}\n#endif\n    }\n\n    /*\n     * Check the bounds for numeric options here\n     */\n    if (Rows < min_rows() && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf(errbuf, errbuflen,\n\t\t\t       _(e_need_at_least_nr_lines), min_rows());\n\t    errmsg = errbuf;\n\t}\n\tRows = min_rows();\n    }\n    if (Columns < MIN_COLUMNS && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf(errbuf, errbuflen,\n\t\t\t    _(e_need_at_least_nr_columns), MIN_COLUMNS);\n\t    errmsg = errbuf;\n\t}\n\tColumns = MIN_COLUMNS;\n    }\n    limit_screen_size();\n\n    /*\n     * If the screen (shell) height has been changed, assume it is the\n     * physical screenheight.\n     */\n    if (old_Rows != Rows || old_Columns != Columns)\n    {\n\t// Changing the screen size is not allowed while updating the screen.\n\tif (updating_screen)\n\t    *pp = old_value;\n\telse if (full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t    )\n\t    set_shellsize((int)Columns, (int)Rows, TRUE);\n\telse\n\t{\n\t    // Postpone the resizing; check the size and cmdline position for\n\t    // messages.\n\t    check_shellsize();\n\t    if (cmdline_row > Rows - p_ch && Rows > p_ch)\n\t\tcmdline_row = Rows - p_ch;\n\t}\n\tif (p_window >= Rows || !option_was_set((char_u *)\"window\"))\n\t    p_window = Rows - 1;\n    }\n\n    if (curbuf->b_p_ts <= 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tcurbuf->b_p_ts = 8;\n    }\n    if (p_tm < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_tm = 0;\n    }\n    if ((curwin->w_p_scr <= 0\n\t\t|| (curwin->w_p_scr > curwin->w_height\n\t\t    && curwin->w_height > 0))\n\t    && full_screen)\n    {\n\tif (pp == &(curwin->w_p_scr))\n\t{\n\t    if (curwin->w_p_scr != 0)\n\t\terrmsg = e_invalid_scroll_size;\n\t    win_comp_scroll(curwin);\n\t}\n\t// If 'scroll' became invalid because of a side effect silently adjust\n\t// it.\n\telse if (curwin->w_p_scr <= 0)\n\t    curwin->w_p_scr = 1;\n\telse // curwin->w_p_scr > curwin->w_height\n\t    curwin->w_p_scr = curwin->w_height;\n    }\n    if (p_hi < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_hi = 0;\n    }\n    else if (p_hi > 10000)\n    {\n\terrmsg = e_invalid_argument;\n\tp_hi = 10000;\n    }\n    if (p_re < 0 || p_re > 2)\n    {\n\terrmsg = e_invalid_argument;\n\tp_re = 0;\n    }\n    if (p_report < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_report = 1;\n    }\n    if ((p_sj < -100 || p_sj >= Rows) && full_screen)\n    {\n\tif (Rows != old_Rows)\t// Rows changed, just adjust p_sj\n\t    p_sj = Rows / 2;\n\telse\n\t{\n\t    errmsg = e_invalid_scroll_size;\n\t    p_sj = 1;\n\t}\n    }\n    if (p_so < 0 && full_screen)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_so = 0;\n    }\n    if (p_siso < 0 && full_screen)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_siso = 0;\n    }\n#ifdef FEAT_CMDWIN\n    if (p_cwh < 1)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_cwh = 1;\n    }\n#endif\n    if (p_ut < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_ut = 2000;\n    }\n    if (p_ss < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_ss = 0;\n    }\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags, old_value, old_global_value,\n\t\t\t\t\t\t\t\tvalue, errmsg);\n#endif\n\n    comp_col();\t\t\t    // in case 'columns' or 'ls' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return errmsg;\n}",
        "func": "static char *\nset_num_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t*varp,\t\t\t// pointer to the option variable\n    long\tvalue,\t\t\t// new value\n    char\t*errbuf,\t\t// buffer for error messages\n    size_t\terrbuflen,\t\t// length of \"errbuf\"\n    int\t\topt_flags)\t\t// OPT_LOCAL, OPT_GLOBAL,\n\t\t\t\t\t// OPT_MODELINE, etc.\n{\n    char\t*errmsg = NULL;\n    long\told_value = *(long *)varp;\n#if defined(FEAT_EVAL)\n    long\told_global_value = 0;\t// only used when setting a local and\n\t\t\t\t\t// global option\n#endif\n    long\told_Rows = Rows;\t// remember old Rows\n    long\told_Columns = Columns;\t// remember old Columns\n    long\t*pp = (long *)varp;\n\n    // Disallow changing some options from secure mode.\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (options[opt_idx].flags & P_SECURE))\n\treturn e_not_allowed_here;\n\n#if defined(FEAT_EVAL)\n    // Save the global value before changing anything. This is needed as for\n    // a global-only option setting the \"local value\" in fact sets the global\n    // value (since there is only one value).\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\told_global_value = *(long *)get_varp_scope(&(options[opt_idx]),\n\t\t\t\t\t\t\t\t   OPT_GLOBAL);\n#endif\n\n    *pp = value;\n#ifdef FEAT_EVAL\n    // Remember where the option was set.\n    set_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    if (curbuf->b_p_sw < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n#ifdef FEAT_VARTABS\n\t// Use the first 'vartabstop' value, or 'tabstop' if vts isn't in use.\n\tcurbuf->b_p_sw = tabstop_count(curbuf->b_p_vts_array) > 0\n\t               ? tabstop_first(curbuf->b_p_vts_array)\n\t\t       : curbuf->b_p_ts;\n#else\n\tcurbuf->b_p_sw = curbuf->b_p_ts;\n#endif\n    }\n\n    /*\n     * Number options that need some action when changed\n     */\n    if (pp == &p_wh || pp == &p_hh)\n    {\n\t// 'winheight' and 'helpheight'\n\tif (p_wh < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wh = 1;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight_cannot_be_smaller_than_winminheight;\n\t    p_wh = p_wmh;\n\t}\n\tif (p_hh < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_hh = 0;\n\t}\n\n\t// Change window height NOW\n\tif (!ONE_WINDOW)\n\t{\n\t    if (pp == &p_wh && curwin->w_height < p_wh)\n\t\twin_setheight((int)p_wh);\n\t    if (pp == &p_hh && curbuf->b_help && curwin->w_height < p_hh)\n\t\twin_setheight((int)p_hh);\n\t}\n    }\n    else if (pp == &p_wmh)\n    {\n\t// 'winminheight'\n\tif (p_wmh < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wmh = 0;\n\t}\n\tif (p_wmh > p_wh)\n\t{\n\t    errmsg = e_winheight_cannot_be_smaller_than_winminheight;\n\t    p_wmh = p_wh;\n\t}\n\twin_setminheight();\n    }\n    else if (pp == &p_wiw)\n    {\n\t// 'winwidth'\n\tif (p_wiw < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wiw = 1;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth_cannot_be_smaller_than_winminwidth;\n\t    p_wiw = p_wmw;\n\t}\n\n\t// Change window width NOW\n\tif (!ONE_WINDOW && curwin->w_width < p_wiw)\n\t    win_setwidth((int)p_wiw);\n    }\n    else if (pp == &p_wmw)\n    {\n\t// 'winminwidth'\n\tif (p_wmw < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_wmw = 0;\n\t}\n\tif (p_wmw > p_wiw)\n\t{\n\t    errmsg = e_winwidth_cannot_be_smaller_than_winminwidth;\n\t    p_wmw = p_wiw;\n\t}\n\twin_setminwidth();\n    }\n\n    // (re)set last window status line\n    else if (pp == &p_ls)\n    {\n\tlast_status(FALSE);\n    }\n\n    // (re)set tab page line\n    else if (pp == &p_stal)\n    {\n\tshell_new_rows();\t// recompute window positions and heights\n    }\n\n#ifdef FEAT_GUI\n    else if (pp == &p_linespace)\n    {\n\t// Recompute gui.char_height and resize the Vim window to keep the\n\t// same number of lines.\n\tif (gui.in_use && gui_mch_adjust_charheight() == OK)\n\t    gui_set_shellsize(FALSE, FALSE, RESIZE_VERT);\n    }\n#endif\n\n#ifdef FEAT_FOLDING\n    // 'foldlevel'\n    else if (pp == &curwin->w_p_fdl)\n    {\n\tif (curwin->w_p_fdl < 0)\n\t    curwin->w_p_fdl = 0;\n\tnewFoldLevel();\n    }\n\n    // 'foldminlines'\n    else if (pp == &curwin->w_p_fml)\n    {\n\tfoldUpdateAll(curwin);\n    }\n\n    // 'foldnestmax'\n    else if (pp == &curwin->w_p_fdn)\n    {\n\tif (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n    }\n\n    // 'foldcolumn'\n    else if (pp == &curwin->w_p_fdc)\n    {\n\tif (curwin->w_p_fdc < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_fdc = 0;\n\t}\n\telse if (curwin->w_p_fdc > 12)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_fdc = 12;\n\t}\n    }\n#endif // FEAT_FOLDING\n\n#if defined(FEAT_FOLDING) || defined(FEAT_CINDENT)\n    // 'shiftwidth' or 'tabstop'\n    else if (pp == &curbuf->b_p_sw || pp == &curbuf->b_p_ts)\n    {\n# ifdef FEAT_FOLDING\n\tif (foldmethodIsIndent(curwin))\n\t    foldUpdateAll(curwin);\n# endif\n# ifdef FEAT_CINDENT\n\t// When 'shiftwidth' changes, or it's zero and 'tabstop' changes:\n\t// parse 'cinoptions'.\n\tif (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0)\n\t    parse_cino(curbuf);\n# endif\n    }\n#endif\n\n    // 'maxcombine'\n    else if (pp == &p_mco)\n    {\n\tif (p_mco > MAX_MCO)\n\t    p_mco = MAX_MCO;\n\telse if (p_mco < 0)\n\t    p_mco = 0;\n\tscreenclear();\t    // will re-allocate the screen\n    }\n\n    else if (pp == &curbuf->b_p_iminsert)\n    {\n\tif (curbuf->b_p_iminsert < 0 || curbuf->b_p_iminsert > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t}\n\tp_iminsert = curbuf->b_p_iminsert;\n\tif (termcap_active)\t// don't do this in the alternate screen\n\t    showmode();\n#if defined(FEAT_KEYMAP)\n\t// Show/unshow value of 'keymap' in status lines.\n\tstatus_redraw_curbuf();\n#endif\n    }\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    // 'imstyle'\n    else if (pp == &p_imst)\n    {\n\tif (p_imst != IM_ON_THE_SPOT && p_imst != IM_OVER_THE_SPOT)\n\t    errmsg = e_invalid_argument;\n    }\n#endif\n\n    else if (pp == &p_window)\n    {\n\tif (p_window < 1)\n\t    p_window = 1;\n\telse if (p_window >= Rows)\n\t    p_window = Rows - 1;\n    }\n\n    else if (pp == &curbuf->b_p_imsearch)\n    {\n\tif (curbuf->b_p_imsearch < -1 || curbuf->b_p_imsearch > B_IMODE_LAST)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curbuf->b_p_imsearch = B_IMODE_NONE;\n\t}\n\tp_imsearch = curbuf->b_p_imsearch;\n    }\n\n    // if 'titlelen' has changed, redraw the title\n    else if (pp == &p_titlelen)\n    {\n\tif (p_titlelen < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_titlelen = 85;\n\t}\n\tif (starting != NO_SCREEN && old_value != p_titlelen)\n\t    need_maketitle = TRUE;\n    }\n\n    // if p_ch changed value, change the command line height\n    else if (pp == &p_ch)\n    {\n\tif (p_ch < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_ch = 1;\n\t}\n\tif (p_ch > Rows - min_rows() + 1)\n\t    p_ch = Rows - min_rows() + 1;\n\n\t// Only compute the new window layout when startup has been\n\t// completed. Otherwise the frame sizes may be wrong.\n\tif (p_ch != old_value && full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t   )\n\t    command_height();\n    }\n\n    // when 'updatecount' changes from zero to non-zero, open swap files\n    else if (pp == &p_uc)\n    {\n\tif (p_uc < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    p_uc = 100;\n\t}\n\tif (p_uc && !old_value)\n\t    ml_open_files();\n    }\n#ifdef FEAT_CONCEAL\n    else if (pp == &curwin->w_p_cole)\n    {\n\tif (curwin->w_p_cole < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_cole = 0;\n\t}\n\telse if (curwin->w_p_cole > 3)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_cole = 3;\n\t}\n    }\n#endif\n#ifdef MZSCHEME_GUI_THREADS\n    else if (pp == &p_mzq)\n\tmzvim_reset_timer();\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)\n    // 'pyxversion'\n    else if (pp == &p_pyx)\n    {\n\tif (p_pyx != 0 && p_pyx != 2 && p_pyx != 3)\n\t    errmsg = e_invalid_argument;\n    }\n#endif\n\n    // sync undo before 'undolevels' changes\n    else if (pp == &p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tp_ul = old_value;\n\tu_sync(TRUE);\n\tp_ul = value;\n    }\n    else if (pp == &curbuf->b_p_ul)\n    {\n\t// use the old value, otherwise u_sync() may not work properly\n\tcurbuf->b_p_ul = old_value;\n\tu_sync(TRUE);\n\tcurbuf->b_p_ul = value;\n    }\n\n#ifdef FEAT_LINEBREAK\n    // 'numberwidth' must be positive\n    else if (pp == &curwin->w_p_nuw)\n    {\n\tif (curwin->w_p_nuw < 1)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curwin->w_p_nuw = 1;\n\t}\n\tif (curwin->w_p_nuw > 20)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    curwin->w_p_nuw = 20;\n\t}\n\tcurwin->w_nrwidth_line_count = 0; // trigger a redraw\n    }\n#endif\n\n    else if (pp == &curbuf->b_p_tw)\n    {\n\tif (curbuf->b_p_tw < 0)\n\t{\n\t    errmsg = e_argument_must_be_positive;\n\t    curbuf->b_p_tw = 0;\n\t}\n#ifdef FEAT_SYN_HL\n\t{\n\t    win_T\t*wp;\n\t    tabpage_T\t*tp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\tcheck_colorcolumn(wp);\n\t}\n#endif\n    }\n\n    /*\n     * Check the bounds for numeric options here\n     */\n    if (Rows < min_rows() && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf(errbuf, errbuflen,\n\t\t\t       _(e_need_at_least_nr_lines), min_rows());\n\t    errmsg = errbuf;\n\t}\n\tRows = min_rows();\n    }\n    if (Columns < MIN_COLUMNS && full_screen)\n    {\n\tif (errbuf != NULL)\n\t{\n\t    vim_snprintf(errbuf, errbuflen,\n\t\t\t    _(e_need_at_least_nr_columns), MIN_COLUMNS);\n\t    errmsg = errbuf;\n\t}\n\tColumns = MIN_COLUMNS;\n    }\n    limit_screen_size();\n\n    /*\n     * If the screen (shell) height has been changed, assume it is the\n     * physical screenheight.\n     */\n    if (old_Rows != Rows || old_Columns != Columns)\n    {\n\t// Changing the screen size is not allowed while updating the screen.\n\tif (updating_screen)\n\t    *pp = old_value;\n\telse if (full_screen\n#ifdef FEAT_GUI\n\t\t&& !gui.starting\n#endif\n\t    )\n\t    set_shellsize((int)Columns, (int)Rows, TRUE);\n\telse\n\t{\n\t    // Postpone the resizing; check the size and cmdline position for\n\t    // messages.\n\t    check_shellsize();\n\t    if (cmdline_row > Rows - p_ch && Rows > p_ch)\n\t\tcmdline_row = Rows - p_ch;\n\t}\n\tif (p_window >= Rows || !option_was_set((char_u *)\"window\"))\n\t    p_window = Rows - 1;\n    }\n\n    if (curbuf->b_p_ts <= 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tcurbuf->b_p_ts = 8;\n    }\n    else if (curbuf->b_p_ts > TABSTOP_MAX)\n    {\n\terrmsg = e_invalid_argument;\n\tcurbuf->b_p_ts = 8;\n    }\n    if (p_tm < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_tm = 0;\n    }\n    if ((curwin->w_p_scr <= 0\n\t\t|| (curwin->w_p_scr > curwin->w_height\n\t\t    && curwin->w_height > 0))\n\t    && full_screen)\n    {\n\tif (pp == &(curwin->w_p_scr))\n\t{\n\t    if (curwin->w_p_scr != 0)\n\t\terrmsg = e_invalid_scroll_size;\n\t    win_comp_scroll(curwin);\n\t}\n\t// If 'scroll' became invalid because of a side effect silently adjust\n\t// it.\n\telse if (curwin->w_p_scr <= 0)\n\t    curwin->w_p_scr = 1;\n\telse // curwin->w_p_scr > curwin->w_height\n\t    curwin->w_p_scr = curwin->w_height;\n    }\n    if (p_hi < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_hi = 0;\n    }\n    else if (p_hi > 10000)\n    {\n\terrmsg = e_invalid_argument;\n\tp_hi = 10000;\n    }\n    if (p_re < 0 || p_re > 2)\n    {\n\terrmsg = e_invalid_argument;\n\tp_re = 0;\n    }\n    if (p_report < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_report = 1;\n    }\n    if ((p_sj < -100 || p_sj >= Rows) && full_screen)\n    {\n\tif (Rows != old_Rows)\t// Rows changed, just adjust p_sj\n\t    p_sj = Rows / 2;\n\telse\n\t{\n\t    errmsg = e_invalid_scroll_size;\n\t    p_sj = 1;\n\t}\n    }\n    if (p_so < 0 && full_screen)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_so = 0;\n    }\n    if (p_siso < 0 && full_screen)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_siso = 0;\n    }\n#ifdef FEAT_CMDWIN\n    if (p_cwh < 1)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_cwh = 1;\n    }\n#endif\n    if (p_ut < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_ut = 2000;\n    }\n    if (p_ss < 0)\n    {\n\terrmsg = e_argument_must_be_positive;\n\tp_ss = 0;\n    }\n\n    // May set global value for local option.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n\t*(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;\n\n    options[opt_idx].flags |= P_WAS_SET;\n\n#if defined(FEAT_EVAL)\n    apply_optionset_autocmd(opt_idx, opt_flags, old_value, old_global_value,\n\t\t\t\t\t\t\t\tvalue, errmsg);\n#endif\n\n    comp_col();\t\t\t    // in case 'columns' or 'ls' changed\n    if (curwin->w_curswant != MAXCOL\n\t\t     && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n\tcheck_redraw(options[opt_idx].flags);\n\n    return errmsg;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -449,6 +449,11 @@\n \terrmsg = e_argument_must_be_positive;\n \tcurbuf->b_p_ts = 8;\n     }\n+    else if (curbuf->b_p_ts > TABSTOP_MAX)\n+    {\n+\terrmsg = e_invalid_argument;\n+\tcurbuf->b_p_ts = 8;\n+    }\n     if (p_tm < 0)\n     {\n \terrmsg = e_argument_must_be_positive;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    else if (curbuf->b_p_ts > TABSTOP_MAX)",
                "    {",
                "\terrmsg = e_invalid_argument;",
                "\tcurbuf->b_p_ts = 8;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0570",
        "func_name": "mruby/gen_values",
        "description": "Heap-based Buffer Overflow in Homebrew mruby prior to 3.2.",
        "git_url": "https://github.com/mruby/mruby/commit/38b164ace7d6ae1c367883a3d67d7f559783faad",
        "commit_title": "codegen.c: fix a bug in `gen_values()`.",
        "commit_text": " - Fix limit handling that fails 15 arguments method calls. - Fix too early argument packing in arrays.",
        "func_before": "static int\ngen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n\n    if (is_splat || n > limit || cursp() >= slimit) { /* flush stack */\n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  /* variable length */\n  }\n  return n;\n}",
        "func": "static int\ngen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n\n    if (is_splat || cursp() >= slimit) { /* flush stack */\n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  /* variable length */\n  }\n  else if (n > limit) {\n    pop_n(n);\n    genop_2(s, OP_ARRAY, cursp(), n);\n    return -1;\n  }\n  return n;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n   while (t) {\n     int is_splat = nint(t->car->car) == NODE_SPLAT;\n \n-    if (is_splat || n > limit || cursp() >= slimit) { /* flush stack */\n+    if (is_splat || cursp() >= slimit) { /* flush stack */\n       pop_n(n);\n       if (first) {\n         if (n == 0) {\n@@ -59,5 +59,10 @@\n     }\n     return -1;                  /* variable length */\n   }\n+  else if (n > limit) {\n+    pop_n(n);\n+    genop_2(s, OP_ARRAY, cursp(), n);\n+    return -1;\n+  }\n   return n;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (is_splat || n > limit || cursp() >= slimit) { /* flush stack */"
            ],
            "added_lines": [
                "    if (is_splat || cursp() >= slimit) { /* flush stack */",
                "  else if (n > limit) {",
                "    pop_n(n);",
                "    genop_2(s, OP_ARRAY, cursp(), n);",
                "    return -1;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0631",
        "func_name": "mruby/mrb_f_send",
        "description": "Heap-based Buffer Overflow in Homebrew mruby prior to 3.2.",
        "git_url": "https://github.com/mruby/mruby/commit/47068ae07a5fa3aa9a1879cdfe98a9ce0f339299",
        "commit_title": "vm.c: packed arguments length may be zero for `send` method.",
        "commit_text": "",
        "func_before": "mrb_value\nmrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n\n  regs = mrb->c->ci->stack+1;\n\n  if (n == 0) {\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            /* call method_mising */\n    goto funcall;\n  }\n\n  ci->mid = name;\n  ci->u.target_class = c;\n  /* remove first symbol from arguments */\n  if (n == 15) {     /* variable length arguments */\n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { /* n > 0 */\n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        /* copy kdict or block */\n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    /* copy block */\n    }\n    ci->n--;\n  }\n\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}",
        "func": "mrb_value\nmrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n\n  regs = mrb->c->ci->stack+1;\n\n  if (n == 0) {\n  argnum_error:\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            /* call method_mising */\n    goto funcall;\n  }\n\n  ci->mid = name;\n  ci->u.target_class = c;\n  /* remove first symbol from arguments */\n  if (n == 15) {     /* variable length arguments */\n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { /* n > 0 */\n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        /* copy kdict or block */\n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    /* copy block */\n    }\n    ci->n--;\n  }\n\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,9 +19,11 @@\n   regs = mrb->c->ci->stack+1;\n \n   if (n == 0) {\n+  argnum_error:\n     mrb_argnum_error(mrb, 0, 1, -1);\n   }\n   else if (n == 15) {\n+    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;\n     name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n   }\n   else {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  argnum_error:",
                "    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2819",
        "func_name": "vim/compile_lock_unlock",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0211.",
        "git_url": "https://github.com/vim/vim/commit/d1d8f6bacb489036d0fd479c9dd3c0102c988889",
        "commit_title": "patch 9.0.0211: invalid memory access when compiling :lockvar",
        "commit_text": " Problem:    Invalid memory access when compiling :lockvar. Solution:   Don't read past the end of the line.",
        "func_before": "static int\ncompile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\n\t    // For \"d.member\" put the local variable on the stack, it will be\n\t    // passed to ex_lockvar() indirectly.\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n\n    // Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}",
        "func": "static int\ncompile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (*p == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), cmd);\n\treturn FAIL;\n    }\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\n\t    // For \"d.member\" put the local variable on the stack, it will be\n\t    // passed to ex_lockvar() indirectly.\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n\n    // Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,9 +13,16 @@\n     size_t\tlen;\n     char_u\t*buf;\n     isntype_T\tisn = ISN_EXEC;\n+    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n \n     if (cctx->ctx_skip == SKIP_YES)\n \treturn OK;\n+\n+    if (*p == NUL)\n+    {\n+\tsemsg(_(e_argument_required_for_str), cmd);\n+\treturn FAIL;\n+    }\n \n     // Cannot use :lockvar and :unlockvar on local variables.\n     if (p[1] != ':')\n@@ -48,8 +55,6 @@\n \tret = FAIL;\n     else\n     {\n-\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n-\n \tif (deep < 0)\n \t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n \telse",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";",
                ""
            ],
            "added_lines": [
                "    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";",
                "",
                "    if (*p == NUL)",
                "    {",
                "\tsemsg(_(e_argument_required_for_str), cmd);",
                "\treturn FAIL;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2849",
        "func_name": "vim/latin_ptr2len",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0220.",
        "git_url": "https://github.com/vim/vim/commit/f6d39c31d2177549a986d170e192d8351bd571e2",
        "commit_title": "patch 9.0.0220: invalid memory access with for loop over NULL string",
        "commit_text": " Problem:    Invalid memory access with for loop over NULL string. Solution:   Make sure mb_ptr2len() consistently returns zero for NUL.",
        "func_before": "int\nlatin_ptr2len(char_u *p)\n{\n return MB_BYTE2LEN(*p);\n}",
        "func": "int\nlatin_ptr2len(char_u *p)\n{\n    return *p == NUL ? 0 : 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n int\n latin_ptr2len(char_u *p)\n {\n- return MB_BYTE2LEN(*p);\n+    return *p == NUL ? 0 : 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                " return MB_BYTE2LEN(*p);"
            ],
            "added_lines": [
                "    return *p == NUL ? 0 : 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2849",
        "func_name": "vim/dbcs_ptr2len",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0220.",
        "git_url": "https://github.com/vim/vim/commit/f6d39c31d2177549a986d170e192d8351bd571e2",
        "commit_title": "patch 9.0.0220: invalid memory access with for loop over NULL string",
        "commit_text": " Problem:    Invalid memory access with for loop over NULL string. Solution:   Make sure mb_ptr2len() consistently returns zero for NUL.",
        "func_before": "static int\ndbcs_ptr2len(\n    char_u\t*p)\n{\n    int\t\tlen;\n\n    // Check if second byte is not missing.\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}",
        "func": "static int\ndbcs_ptr2len(char_u *p)\n{\n    int\t\tlen;\n\n    if (*p == NUL)\n\treturn 0;\n\n    // if the second byte is missing the length is 1\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,12 @@\n static int\n-dbcs_ptr2len(\n-    char_u\t*p)\n+dbcs_ptr2len(char_u *p)\n {\n     int\t\tlen;\n \n-    // Check if second byte is not missing.\n+    if (*p == NUL)\n+\treturn 0;\n+\n+    // if the second byte is missing the length is 1\n     len = MB_BYTE2LEN(*p);\n     if (len == 2 && p[1] == NUL)\n \tlen = 1;",
        "diff_line_info": {
            "deleted_lines": [
                "dbcs_ptr2len(",
                "    char_u\t*p)",
                "    // Check if second byte is not missing."
            ],
            "added_lines": [
                "dbcs_ptr2len(char_u *p)",
                "    if (*p == NUL)",
                "\treturn 0;",
                "",
                "    // if the second byte is missing the length is 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25309",
        "func_name": "fribidi/fribidi_cap_rtl_to_unicode",
        "description": "A heap-based buffer overflow flaw was found in the Fribidi package and affects the fribidi_cap_rtl_to_unicode() function of the fribidi-char-sets-cap-rtl.c file. This flaw allows an attacker to pass a specially crafted file to the Fribidi application with the '--caprtl' option, leading to a crash and causing a denial of service.",
        "git_url": "https://github.com/fribidi/fribidi/commit/f22593b82b5d1668d1997dbccd10a9c31ffea3b3",
        "commit_title": "Protected against garbage in the CapRTL encoder",
        "commit_text": "",
        "func_before": "FriBidiStrIndex\nfribidi_cap_rtl_to_unicode (\n  /* input */\n  const char *s,\n  FriBidiStrIndex len,\n  /* output */\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n\n  return j;\n}",
        "func": "FriBidiStrIndex\nfribidi_cap_rtl_to_unicode (\n  /* input */\n  const char *s,\n  FriBidiStrIndex len,\n  /* output */\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n      {\n        if ((int)s[i] < 0)\n          us[j++] = '?';\n        else\n          us[j++] = caprtl_to_unicode[(int) s[i]];\n      }\n    }\n\n  return j;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,7 +65,12 @@\n \t    }\n \t}\n       else\n-\tus[j++] = caprtl_to_unicode[(int) s[i]];\n+      {\n+        if ((int)s[i] < 0)\n+          us[j++] = '?';\n+        else\n+          us[j++] = caprtl_to_unicode[(int) s[i]];\n+      }\n     }\n \n   return j;",
        "diff_line_info": {
            "deleted_lines": [
                "\tus[j++] = caprtl_to_unicode[(int) s[i]];"
            ],
            "added_lines": [
                "      {",
                "        if ((int)s[i] < 0)",
                "          us[j++] = '?';",
                "        else",
                "          us[j++] = caprtl_to_unicode[(int) s[i]];",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3234",
        "func_name": "vim/op_replace",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0483.",
        "git_url": "https://github.com/vim/vim/commit/c249913edc35c0e666d783bfc21595cf9f7d9e0d",
        "commit_title": "patch 9.0.0483: illegal memory access when replacing in virtualedit mode",
        "commit_text": " Problem:    Illegal memory access when replacing in virtualedit mode. Solution:   Check for replacing NUL after Tab.",
        "func_before": "int\nop_replace(oparg_T *oap, int c)\n{\n    int\t\t\tn, numc;\n    int\t\t\tnum_chars;\n    char_u\t\t*newp, *oldp;\n    size_t\t\toldlen;\n    struct block_def\tbd;\n    char_u\t\t*after_p = NULL;\n    int\t\t\thad_ctrl_v_cr = FALSE;\n\n    if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)\n\treturn OK;\t    // nothing to do\n\n    if (c == REPLACE_CR_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = CAR;\n    }\n    else if (c == REPLACE_NL_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = NL;\n    }\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn FAIL;\n\n    /*\n     * block mode replace\n     */\n    if (oap->block_mode)\n    {\n\tbd.is_MAX = (curwin->w_curswant == MAXCOL);\n\tfor ( ; curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = 0;  // make sure cursor position is valid\n\t    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n\t    if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))\n\t\tcontinue;\t    // nothing to replace\n\n\t    // n == number of extra chars required\n\t    // If we split a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    // If the range starts in virtual space, count the initial\n\t    // coladd offset as part of \"startspaces\"\n\t    if (virtual_op && bd.is_short && *bd.textstart == NUL)\n\t    {\n\t\tpos_T vpos;\n\n\t\tvpos.lnum = curwin->w_cursor.lnum;\n\t\tgetvpos(&vpos, oap->start_vcol);\n\t\tbd.startspaces += vpos.coladd;\n\t\tn = bd.startspaces;\n\t    }\n\t    else\n\t\t// allow for pre spaces\n\t\tn = (bd.startspaces ? bd.start_char_vcols - 1 : 0);\n\n\t    // allow for post spp\n\t    n += (bd.endspaces\n\t\t    && !bd.is_oneChar\n\t\t    && bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;\n\t    // Figure out how many characters to replace.\n\t    numc = oap->end_vcol - oap->start_vcol + 1;\n\t    if (bd.is_short && (!virtual_op || bd.is_MAX))\n\t\tnumc -= (oap->end_vcol - bd.end_vcol) + 1;\n\n\t    // A double-wide character can be replaced only up to half the\n\t    // times.\n\t    if ((*mb_char2cells)(c) > 1)\n\t    {\n\t\tif ((numc & 1) && !bd.is_short)\n\t\t{\n\t\t    ++bd.endspaces;\n\t\t    ++n;\n\t\t}\n\t\tnumc = numc / 2;\n\t    }\n\n\t    // Compute bytes needed, move character count to num_chars.\n\t    num_chars = numc;\n\t    numc *= (*mb_char2len)(c);\n\t    // oldlen includes textlen, so don't double count\n\t    n += numc - bd.textlen;\n\n\t    oldp = ml_get_curline();\n\t    oldlen = STRLEN(oldp);\n\t    newp = alloc(oldlen + 1 + n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    vim_memset(newp, NUL, (size_t)(oldlen + 1 + n));\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    oldp += bd.textcol + bd.textlen;\n\t    // insert pre-spaces\n\t    vim_memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);\n\t    // insert replacement chars CHECK FOR ALLOCATED SPACE\n\t    // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR\n\t    // literally.\n\t    if (had_ctrl_v_cr || (c != '\\r' && c != '\\n'))\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = (int)STRLEN(newp);\n\t\t    while (--num_chars >= 0)\n\t\t\tn += (*mb_char2bytes)(c, newp + n);\n\t\t}\n\t\telse\n\t\t    vim_memset(newp + STRLEN(newp), c, (size_t)numc);\n\t\tif (!bd.is_short)\n\t\t{\n\t\t    // insert post-spaces\n\t\t    vim_memset(newp + STRLEN(newp), ' ', (size_t)bd.endspaces);\n\t\t    // copy the part after the changed part\n\t\t    STRMOVE(newp + STRLEN(newp), oldp);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Replacing with \\r or \\n means splitting the line.\n\t\tafter_p = alloc(oldlen + 1 + n - STRLEN(newp));\n\t\tif (after_p != NULL)\n\t\t    STRMOVE(after_p, oldp);\n\t    }\n\t    // replace the line\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    if (after_p != NULL)\n\t    {\n\t\tml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);\n\t\tappended_lines_mark(curwin->w_cursor.lnum, 1L);\n\t\toap->end.lnum++;\n\t\tvim_free(after_p);\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * MCHAR and MLINE motion replace.\n\t */\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    curwin->w_cursor.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\twhile (LTOREQ_POS(curwin->w_cursor, oap->end))\n\t{\n\t    n = gchar_cursor();\n\t    if (n != NUL)\n\t    {\n\t\tint new_byte_len = (*mb_char2len)(c);\n\t\tint old_byte_len = mb_ptr2len(ml_get_cursor());\n\n\t\tif (new_byte_len > 1 || old_byte_len > 1)\n\t\t{\n\t\t    // This is slow, but it handles replacing a single-byte\n\t\t    // with a multi-byte and the other way around.\n\t\t    if (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\toap->end.col += new_byte_len - old_byte_len;\n\t\t    replace_character(c);\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (n == TAB)\n\t\t    {\n\t\t\tint end_vcol = 0;\n\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t{\n\t\t\t    // oap->end has to be recalculated when\n\t\t\t    // the tab breaks\n\t\t\t    end_vcol = getviscol2(oap->end.col,\n\t\t\t\t\t\t\t     oap->end.coladd);\n\t\t\t}\n\t\t\tcoladvance_force(getviscol());\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t    getvpos(&oap->end, end_vcol);\n\t\t    }\n\t\t    PBYTE(curwin->w_cursor, c);\n\t\t}\n\t    }\n\t    else if (virtual_op && curwin->w_cursor.lnum == oap->end.lnum)\n\t    {\n\t\tint virtcols = oap->end.coladd;\n\n\t\tif (curwin->w_cursor.lnum == oap->start.lnum\n\t\t\t&& oap->start.col == oap->end.col && oap->start.coladd)\n\t\t    virtcols -= oap->start.coladd;\n\n\t\t// oap->end has been trimmed so it's effectively inclusive;\n\t\t// as a result an extra +1 must be counted so we don't\n\t\t// trample the NUL byte.\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd) + 1);\n\t\tcurwin->w_cursor.col -= (virtcols + 1);\n\t\tfor (; virtcols >= 0; virtcols--)\n\t\t{\n\t\t    if ((*mb_char2len)(c) > 1)\n\t\t       replace_character(c);\n\t\t    else\n\t\t\tPBYTE(curwin->w_cursor, c);\n\t\t   if (inc(&curwin->w_cursor) == -1)\n\t\t       break;\n\t\t}\n\t    }\n\n\t    // Advance to next character, stop at the end of the file.\n\t    if (inc_cursor() == -1)\n\t\tbreak;\n\t}\n    }\n\n    curwin->w_cursor = oap->start;\n    check_cursor();\n    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1, 0L);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    return OK;\n}",
        "func": "int\nop_replace(oparg_T *oap, int c)\n{\n    int\t\t\tn, numc;\n    int\t\t\tnum_chars;\n    char_u\t\t*newp, *oldp;\n    size_t\t\toldlen;\n    struct block_def\tbd;\n    char_u\t\t*after_p = NULL;\n    int\t\t\thad_ctrl_v_cr = FALSE;\n\n    if ((curbuf->b_ml.ml_flags & ML_EMPTY ) || oap->empty)\n\treturn OK;\t    // nothing to do\n\n    if (c == REPLACE_CR_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = CAR;\n    }\n    else if (c == REPLACE_NL_NCHAR)\n    {\n\thad_ctrl_v_cr = TRUE;\n\tc = NL;\n    }\n\n    if (has_mbyte)\n\tmb_adjust_opend(oap);\n\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn FAIL;\n\n    /*\n     * block mode replace\n     */\n    if (oap->block_mode)\n    {\n\tbd.is_MAX = (curwin->w_curswant == MAXCOL);\n\tfor ( ; curwin->w_cursor.lnum <= oap->end.lnum; ++curwin->w_cursor.lnum)\n\t{\n\t    curwin->w_cursor.col = 0;  // make sure cursor position is valid\n\t    block_prep(oap, &bd, curwin->w_cursor.lnum, TRUE);\n\t    if (bd.textlen == 0 && (!virtual_op || bd.is_MAX))\n\t\tcontinue;\t    // nothing to replace\n\n\t    // n == number of extra chars required\n\t    // If we split a TAB, it may be replaced by several characters.\n\t    // Thus the number of characters may increase!\n\t    // If the range starts in virtual space, count the initial\n\t    // coladd offset as part of \"startspaces\"\n\t    if (virtual_op && bd.is_short && *bd.textstart == NUL)\n\t    {\n\t\tpos_T vpos;\n\n\t\tvpos.lnum = curwin->w_cursor.lnum;\n\t\tgetvpos(&vpos, oap->start_vcol);\n\t\tbd.startspaces += vpos.coladd;\n\t\tn = bd.startspaces;\n\t    }\n\t    else\n\t\t// allow for pre spaces\n\t\tn = (bd.startspaces ? bd.start_char_vcols - 1 : 0);\n\n\t    // allow for post spp\n\t    n += (bd.endspaces\n\t\t    && !bd.is_oneChar\n\t\t    && bd.end_char_vcols > 0) ? bd.end_char_vcols - 1 : 0;\n\t    // Figure out how many characters to replace.\n\t    numc = oap->end_vcol - oap->start_vcol + 1;\n\t    if (bd.is_short && (!virtual_op || bd.is_MAX))\n\t\tnumc -= (oap->end_vcol - bd.end_vcol) + 1;\n\n\t    // A double-wide character can be replaced only up to half the\n\t    // times.\n\t    if ((*mb_char2cells)(c) > 1)\n\t    {\n\t\tif ((numc & 1) && !bd.is_short)\n\t\t{\n\t\t    ++bd.endspaces;\n\t\t    ++n;\n\t\t}\n\t\tnumc = numc / 2;\n\t    }\n\n\t    // Compute bytes needed, move character count to num_chars.\n\t    num_chars = numc;\n\t    numc *= (*mb_char2len)(c);\n\t    // oldlen includes textlen, so don't double count\n\t    n += numc - bd.textlen;\n\n\t    oldp = ml_get_curline();\n\t    oldlen = STRLEN(oldp);\n\t    newp = alloc(oldlen + 1 + n);\n\t    if (newp == NULL)\n\t\tcontinue;\n\t    vim_memset(newp, NUL, (size_t)(oldlen + 1 + n));\n\t    // copy up to deleted part\n\t    mch_memmove(newp, oldp, (size_t)bd.textcol);\n\t    oldp += bd.textcol + bd.textlen;\n\t    // insert pre-spaces\n\t    vim_memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);\n\t    // insert replacement chars CHECK FOR ALLOCATED SPACE\n\t    // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR\n\t    // literally.\n\t    if (had_ctrl_v_cr || (c != '\\r' && c != '\\n'))\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = (int)STRLEN(newp);\n\t\t    while (--num_chars >= 0)\n\t\t\tn += (*mb_char2bytes)(c, newp + n);\n\t\t}\n\t\telse\n\t\t    vim_memset(newp + STRLEN(newp), c, (size_t)numc);\n\t\tif (!bd.is_short)\n\t\t{\n\t\t    // insert post-spaces\n\t\t    vim_memset(newp + STRLEN(newp), ' ', (size_t)bd.endspaces);\n\t\t    // copy the part after the changed part\n\t\t    STRMOVE(newp + STRLEN(newp), oldp);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Replacing with \\r or \\n means splitting the line.\n\t\tafter_p = alloc(oldlen + 1 + n - STRLEN(newp));\n\t\tif (after_p != NULL)\n\t\t    STRMOVE(after_p, oldp);\n\t    }\n\t    // replace the line\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    if (after_p != NULL)\n\t    {\n\t\tml_append(curwin->w_cursor.lnum++, after_p, 0, FALSE);\n\t\tappended_lines_mark(curwin->w_cursor.lnum, 1L);\n\t\toap->end.lnum++;\n\t\tvim_free(after_p);\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * MCHAR and MLINE motion replace.\n\t */\n\tif (oap->motion_type == MLINE)\n\t{\n\t    oap->start.col = 0;\n\t    curwin->w_cursor.col = 0;\n\t    oap->end.col = (colnr_T)STRLEN(ml_get(oap->end.lnum));\n\t    if (oap->end.col)\n\t\t--oap->end.col;\n\t}\n\telse if (!oap->inclusive)\n\t    dec(&(oap->end));\n\n\twhile (LTOREQ_POS(curwin->w_cursor, oap->end))\n\t{\n\t    int done = FALSE;\n\n\t    n = gchar_cursor();\n\t    if (n != NUL)\n\t    {\n\t\tint new_byte_len = (*mb_char2len)(c);\n\t\tint old_byte_len = mb_ptr2len(ml_get_cursor());\n\n\t\tif (new_byte_len > 1 || old_byte_len > 1)\n\t\t{\n\t\t    // This is slow, but it handles replacing a single-byte\n\t\t    // with a multi-byte and the other way around.\n\t\t    if (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\toap->end.col += new_byte_len - old_byte_len;\n\t\t    replace_character(c);\n\t\t    done = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (n == TAB)\n\t\t    {\n\t\t\tint end_vcol = 0;\n\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t{\n\t\t\t    // oap->end has to be recalculated when\n\t\t\t    // the tab breaks\n\t\t\t    end_vcol = getviscol2(oap->end.col,\n\t\t\t\t\t\t\t     oap->end.coladd);\n\t\t\t}\n\t\t\tcoladvance_force(getviscol());\n\t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n\t\t\t    getvpos(&oap->end, end_vcol);\n\t\t    }\n\t\t    // with \"coladd\" set may move to just after a TAB\n\t\t    if (gchar_cursor() != NUL)\n\t\t    {\n\t\t\tPBYTE(curwin->w_cursor, c);\n\t\t\tdone = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!done && virtual_op && curwin->w_cursor.lnum == oap->end.lnum)\n\t    {\n\t\tint virtcols = oap->end.coladd;\n\n\t\tif (curwin->w_cursor.lnum == oap->start.lnum\n\t\t\t&& oap->start.col == oap->end.col && oap->start.coladd)\n\t\t    virtcols -= oap->start.coladd;\n\n\t\t// oap->end has been trimmed so it's effectively inclusive;\n\t\t// as a result an extra +1 must be counted so we don't\n\t\t// trample the NUL byte.\n\t\tcoladvance_force(getviscol2(oap->end.col, oap->end.coladd) + 1);\n\t\tcurwin->w_cursor.col -= (virtcols + 1);\n\t\tfor (; virtcols >= 0; virtcols--)\n\t\t{\n\t\t    if ((*mb_char2len)(c) > 1)\n\t\t       replace_character(c);\n\t\t    else\n\t\t\tPBYTE(curwin->w_cursor, c);\n\t\t   if (inc(&curwin->w_cursor) == -1)\n\t\t       break;\n\t\t}\n\t    }\n\n\t    // Advance to next character, stop at the end of the file.\n\t    if (inc_cursor() == -1)\n\t\tbreak;\n\t}\n    }\n\n    curwin->w_cursor = oap->start;\n    check_cursor();\n    changed_lines(oap->start.lnum, oap->start.col, oap->end.lnum + 1, 0L);\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -156,6 +156,8 @@\n \n \twhile (LTOREQ_POS(curwin->w_cursor, oap->end))\n \t{\n+\t    int done = FALSE;\n+\n \t    n = gchar_cursor();\n \t    if (n != NUL)\n \t    {\n@@ -169,6 +171,7 @@\n \t\t    if (curwin->w_cursor.lnum == oap->end.lnum)\n \t\t\toap->end.col += new_byte_len - old_byte_len;\n \t\t    replace_character(c);\n+\t\t    done = TRUE;\n \t\t}\n \t\telse\n \t\t{\n@@ -187,10 +190,15 @@\n \t\t\tif (curwin->w_cursor.lnum == oap->end.lnum)\n \t\t\t    getvpos(&oap->end, end_vcol);\n \t\t    }\n-\t\t    PBYTE(curwin->w_cursor, c);\n-\t\t}\n-\t    }\n-\t    else if (virtual_op && curwin->w_cursor.lnum == oap->end.lnum)\n+\t\t    // with \"coladd\" set may move to just after a TAB\n+\t\t    if (gchar_cursor() != NUL)\n+\t\t    {\n+\t\t\tPBYTE(curwin->w_cursor, c);\n+\t\t\tdone = TRUE;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    if (!done && virtual_op && curwin->w_cursor.lnum == oap->end.lnum)\n \t    {\n \t\tint virtcols = oap->end.coladd;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    PBYTE(curwin->w_cursor, c);",
                "\t\t}",
                "\t    }",
                "\t    else if (virtual_op && curwin->w_cursor.lnum == oap->end.lnum)"
            ],
            "added_lines": [
                "\t    int done = FALSE;",
                "",
                "\t\t    done = TRUE;",
                "\t\t    // with \"coladd\" set may move to just after a TAB",
                "\t\t    if (gchar_cursor() != NUL)",
                "\t\t    {",
                "\t\t\tPBYTE(curwin->w_cursor, c);",
                "\t\t\tdone = TRUE;",
                "\t\t    }",
                "\t\t}",
                "\t    }",
                "\t    if (!done && virtual_op && curwin->w_cursor.lnum == oap->end.lnum)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-4751",
        "func_name": "vim/ex_buffer_all",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1331.",
        "git_url": "https://github.com/vim/vim/commit/e1121b139480f53d1b06f84f3e4574048108fa0b",
        "commit_title": "patch 9.0.1331: illegal memory access when using :ball in Visual mode",
        "commit_text": " Problem:    Illegal memory access when using :ball in Visual mode. Solution:   Stop Visual mode when using :ball. (Pavel Mayorov, closes #11923)",
        "func_before": "void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t\t|| ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t    ? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t     - tabline_height()\n\t\t\t    : wp->w_width != Columns)\n\t\t\t|| (had_tab > 0 && wp != firstwin))\n\t\t    && !ONE_WINDOW\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n\t\t    && !win_unlisted(wp))\n\t    {\n\t\tif (win_close(wp, FALSE) == FAIL)\n\t\t    break;\n\t\t// Just in case an autocommand does something strange with\n\t\t// windows: start all over...\n\t\twpnext = firstwin;\n\t\ttpnext = first_tabpage;\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}",
        "func": "void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    // Stop Visual mode, the cursor and \"VIsual\" may very well be invalid after\n    // switching to another buffer.\n    reset_VIsual_and_resel();\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t\t|| ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t    ? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t     - tabline_height()\n\t\t\t    : wp->w_width != Columns)\n\t\t\t|| (had_tab > 0 && wp != firstwin))\n\t\t    && !ONE_WINDOW\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n\t\t    && !win_unlisted(wp))\n\t    {\n\t\tif (win_close(wp, FALSE) == FAIL)\n\t\t    break;\n\t\t// Just in case an autocommand does something strange with\n\t\t// windows: start all over...\n\t\twpnext = firstwin;\n\t\ttpnext = first_tabpage;\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,10 @@\n \tall = FALSE;\n     else\n \tall = TRUE;\n+\n+    // Stop Visual mode, the cursor and \"VIsual\" may very well be invalid after\n+    // switching to another buffer.\n+    reset_VIsual_and_resel();\n \n     setpcmark();\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    // Stop Visual mode, the cursor and \"VIsual\" may very well be invalid after",
                "    // switching to another buffer.",
                "    reset_VIsual_and_resel();"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3770",
        "func_name": "vim/tabstop_set",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/b7081e135a16091c93f6f5f7525a5c58fb7ca9f9",
        "commit_title": "patch 8.2.3402: invalid memory access when using :retab with large value",
        "commit_text": " Problem:    Invalid memory access when using :retab with large value. Solution:   Check the number is positive.",
        "func_before": "int\ntabstop_set(char_u *var, int **array)\n{\n    int valcount = 1;\n    int t;\n    char_u *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn TRUE;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_positive));\n\t\telse\n\t\t    emsg(_(e_invarg));\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\temsg(_(e_invarg));\n\treturn FALSE;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FALSE;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\t(*array)[t++] = atoi((char *)cp);\n\twhile (*cp  != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return TRUE;\n}",
        "func": "int\ntabstop_set(char_u *var, int **array)\n{\n    int\t    valcount = 1;\n    int\t    t;\n    char_u  *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn OK;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_positive));\n\t\telse\n\t\t    semsg(_(e_invarg2), cp);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\tsemsg(_(e_invarg2), var);\n\treturn FAIL;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FAIL;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\tint n = atoi((char *)cp);\n\n\tif (n < 0 || n > 9999)\n\t{\n\t    semsg(_(e_invarg2), cp);\n\t    return FAIL;\n\t}\n\t(*array)[t++] = n;\n\twhile (*cp != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,14 +1,14 @@\n int\n tabstop_set(char_u *var, int **array)\n {\n-    int valcount = 1;\n-    int t;\n-    char_u *cp;\n+    int\t    valcount = 1;\n+    int\t    t;\n+    char_u  *cp;\n \n     if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n     {\n \t*array = NULL;\n-\treturn TRUE;\n+\treturn OK;\n     }\n \n     for (cp = var; *cp != NUL; ++cp)\n@@ -22,8 +22,8 @@\n \t\tif (cp != end)\n \t\t    emsg(_(e_positive));\n \t\telse\n-\t\t    emsg(_(e_invarg));\n-\t\treturn FALSE;\n+\t\t    semsg(_(e_invarg2), cp);\n+\t\treturn FAIL;\n \t    }\n \t}\n \n@@ -34,24 +34,31 @@\n \t    ++valcount;\n \t    continue;\n \t}\n-\temsg(_(e_invarg));\n-\treturn FALSE;\n+\tsemsg(_(e_invarg2), var);\n+\treturn FAIL;\n     }\n \n     *array = ALLOC_MULT(int, valcount + 1);\n     if (*array == NULL)\n-\treturn FALSE;\n+\treturn FAIL;\n     (*array)[0] = valcount;\n \n     t = 1;\n     for (cp = var; *cp != NUL;)\n     {\n-\t(*array)[t++] = atoi((char *)cp);\n-\twhile (*cp  != NUL && *cp != ',')\n+\tint n = atoi((char *)cp);\n+\n+\tif (n < 0 || n > 9999)\n+\t{\n+\t    semsg(_(e_invarg2), cp);\n+\t    return FAIL;\n+\t}\n+\t(*array)[t++] = n;\n+\twhile (*cp != NUL && *cp != ',')\n \t    ++cp;\n \tif (*cp != NUL)\n \t    ++cp;\n     }\n \n-    return TRUE;\n+    return OK;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    int valcount = 1;",
                "    int t;",
                "    char_u *cp;",
                "\treturn TRUE;",
                "\t\t    emsg(_(e_invarg));",
                "\t\treturn FALSE;",
                "\temsg(_(e_invarg));",
                "\treturn FALSE;",
                "\treturn FALSE;",
                "\t(*array)[t++] = atoi((char *)cp);",
                "\twhile (*cp  != NUL && *cp != ',')",
                "    return TRUE;"
            ],
            "added_lines": [
                "    int\t    valcount = 1;",
                "    int\t    t;",
                "    char_u  *cp;",
                "\treturn OK;",
                "\t\t    semsg(_(e_invarg2), cp);",
                "\t\treturn FAIL;",
                "\tsemsg(_(e_invarg2), var);",
                "\treturn FAIL;",
                "\treturn FAIL;",
                "\tint n = atoi((char *)cp);",
                "",
                "\tif (n < 0 || n > 9999)",
                "\t{",
                "\t    semsg(_(e_invarg2), cp);",
                "\t    return FAIL;",
                "\t}",
                "\t(*array)[t++] = n;",
                "\twhile (*cp != NUL && *cp != ',')",
                "    return OK;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3770",
        "func_name": "vim/ex_retab",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/b7081e135a16091c93f6f5f7525a5c58fb7ca9f9",
        "commit_title": "patch 8.2.3402: invalid memory access when using :retab with large value",
        "commit_text": " Problem:    Invalid memory access when using :retab with large value. Solution:   Check the number is positive.",
        "func_before": "void\nex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (!tabstop_set(eap->arg, &new_vts_array))\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    new_ts = getdigits(&(eap->arg));\n    if (new_ts < 0)\n    {\n\temsg(_(e_positive));\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interr));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}",
        "func": "void\nex_retab(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tgot_tab = FALSE;\n    long\tnum_spaces = 0;\n    long\tnum_tabs;\n    long\tlen;\n    long\tcol;\n    long\tvcol;\n    long\tstart_col = 0;\t\t// For start of white-space string\n    long\tstart_vcol = 0;\t\t// For start of white-space string\n    long\told_len;\n    char_u\t*ptr;\n    char_u\t*new_line = (char_u *)1; // init to non-NULL\n    int\t\tdid_undo;\t\t// called u_save for current line\n#ifdef FEAT_VARTABS\n    int\t\t*new_vts_array = NULL;\n    char_u\t*new_ts_str;\t\t// string value of tab argument\n#else\n    int\t\ttemp;\n    int\t\tnew_ts;\n#endif\n    int\t\tsave_list;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line = 0;\t\t// last changed line\n\n    save_list = curwin->w_p_list;\n    curwin->w_p_list = 0;\t    // don't want list mode here\n\n#ifdef FEAT_VARTABS\n    new_ts_str = eap->arg;\n    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n\treturn;\n    while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n\t++(eap->arg);\n\n    // This ensures that either new_vts_array and new_ts_str are freshly\n    // allocated, or new_vts_array points to an existing array and new_ts_str\n    // is null.\n    if (new_vts_array == NULL)\n    {\n\tnew_vts_array = curbuf->b_p_vts_array;\n\tnew_ts_str = NULL;\n    }\n    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    new_ts = getdigits(&(eap->arg));\n    if (new_ts < 0)\n    {\n\temsg(_(e_positive));\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);\n\tcol = 0;\n\tvcol = 0;\n\tdid_undo = FALSE;\n\tfor (;;)\n\t{\n\t    if (VIM_ISWHITE(ptr[col]))\n\t    {\n\t\tif (!got_tab && num_spaces == 0)\n\t\t{\n\t\t    // First consecutive white-space\n\t\t    start_vcol = vcol;\n\t\t    start_col = col;\n\t\t}\n\t\tif (ptr[col] == ' ')\n\t\t    num_spaces++;\n\t\telse\n\t\t    got_tab = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tif (got_tab || (eap->forceit && num_spaces > 1))\n\t\t{\n\t\t    // Retabulate this string of white-space\n\n\t\t    // len is virtual length of white string\n\t\t    len = num_spaces = vcol - start_vcol;\n\t\t    num_tabs = 0;\n\t\t    if (!curbuf->b_p_et)\n\t\t    {\n#ifdef FEAT_VARTABS\n\t\t\tint t, s;\n\n\t\t\ttabstop_fromto(start_vcol, vcol,\n\t\t\t\t\tcurbuf->b_p_ts, new_vts_array, &t, &s);\n\t\t\tnum_tabs = t;\n\t\t\tnum_spaces = s;\n#else\n\t\t\ttemp = new_ts - (start_vcol % new_ts);\n\t\t\tif (num_spaces >= temp)\n\t\t\t{\n\t\t\t    num_spaces -= temp;\n\t\t\t    num_tabs++;\n\t\t\t}\n\t\t\tnum_tabs += num_spaces / new_ts;\n\t\t\tnum_spaces -= (num_spaces / new_ts) * new_ts;\n#endif\n\t\t    }\n\t\t    if (curbuf->b_p_et || got_tab ||\n\t\t\t\t\t(num_spaces + num_tabs < len))\n\t\t    {\n\t\t\tif (did_undo == FALSE)\n\t\t\t{\n\t\t\t    did_undo = TRUE;\n\t\t\t    if (u_save((linenr_T)(lnum - 1),\n\t\t\t\t\t\t(linenr_T)(lnum + 1)) == FAIL)\n\t\t\t    {\n\t\t\t\tnew_line = NULL;\t// flag out-of-memory\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// len is actual number of white characters used\n\t\t\tlen = num_spaces + num_tabs;\n\t\t\told_len = (long)STRLEN(ptr);\n\t\t\tnew_line = alloc(old_len - col + start_col + len + 1);\n\t\t\tif (new_line == NULL)\n\t\t\t    break;\n\t\t\tif (start_col > 0)\n\t\t\t    mch_memmove(new_line, ptr, (size_t)start_col);\n\t\t\tmch_memmove(new_line + start_col + len,\n\t\t\t\t      ptr + col, (size_t)(old_len - col + 1));\n\t\t\tptr = new_line + start_col;\n\t\t\tfor (col = 0; col < len; col++)\n\t\t\t    ptr[col] = (col < num_tabs) ? '\\t' : ' ';\n\t\t\tif (ml_replace(lnum, new_line, FALSE) == OK)\n\t\t\t    // \"new_line\" may have been copied\n\t\t\t    new_line = curbuf->b_ml.ml_line_ptr;\n\t\t\tif (first_line == 0)\n\t\t\t    first_line = lnum;\n\t\t\tlast_line = lnum;\n\t\t\tptr = new_line;\n\t\t\tcol = start_col + len;\n\t\t    }\n\t\t}\n\t\tgot_tab = FALSE;\n\t\tnum_spaces = 0;\n\t    }\n\t    if (ptr[col] == NUL)\n\t\tbreak;\n\t    vcol += chartabsize(ptr + col, (colnr_T)vcol);\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    else\n\t\t++col;\n\t}\n\tif (new_line == NULL)\t\t    // out of memory\n\t    break;\n\tline_breakcheck();\n    }\n    if (got_int)\n\temsg(_(e_interr));\n\n#ifdef FEAT_VARTABS\n    // If a single value was given then it can be considered equal to\n    // either the value of 'tabstop' or the value of 'vartabstop'.\n    if (tabstop_count(curbuf->b_p_vts_array) == 0\n\t&& tabstop_count(new_vts_array) == 1\n\t&& curbuf->b_p_ts == tabstop_first(new_vts_array))\n\t; // not changed\n    else if (tabstop_count(curbuf->b_p_vts_array) > 0\n        && tabstop_eq(curbuf->b_p_vts_array, new_vts_array))\n\t; // not changed\n    else\n\tredraw_curbuf_later(NOT_VALID);\n#else\n    if (curbuf->b_p_ts != new_ts)\n\tredraw_curbuf_later(NOT_VALID);\n#endif\n    if (first_line != 0)\n\tchanged_lines(first_line, 0, last_line + 1, 0L);\n\n    curwin->w_p_list = save_list;\t// restore 'list'\n\n#ifdef FEAT_VARTABS\n    if (new_ts_str != NULL)\t\t// set the new tabstop\n    {\n\t// If 'vartabstop' is in use or if the value given to retab has more\n\t// than one tabstop then update 'vartabstop'.\n\tint *old_vts_ary = curbuf->b_p_vts_array;\n\n\tif (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1)\n\t{\n\t    set_string_option_direct((char_u *)\"vts\", -1, new_ts_str,\n\t\t\t\t\t\t\tOPT_FREE|OPT_LOCAL, 0);\n\t    curbuf->b_p_vts_array = new_vts_array;\n\t    vim_free(old_vts_ary);\n\t}\n\telse\n\t{\n\t    // 'vartabstop' wasn't in use and a single value was given to\n\t    // retab then update 'tabstop'.\n\t    curbuf->b_p_ts = tabstop_first(new_vts_array);\n\t    vim_free(new_vts_array);\n\t}\n\tvim_free(new_ts_str);\n    }\n#else\n    curbuf->b_p_ts = new_ts;\n#endif\n    coladvance(curwin->w_curswant);\n\n    u_clearline();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n \n #ifdef FEAT_VARTABS\n     new_ts_str = eap->arg;\n-    if (!tabstop_set(eap->arg, &new_vts_array))\n+    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)\n \treturn;\n     while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',')\n \t++(eap->arg);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!tabstop_set(eap->arg, &new_vts_array))"
            ],
            "added_lines": [
                "    if (tabstop_set(eap->arg, &new_vts_array) == FAIL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3770",
        "func_name": "vim/paste_option_changed",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/b7081e135a16091c93f6f5f7525a5c58fb7ca9f9",
        "commit_title": "patch 8.2.3402: invalid memory access when using :retab with large value",
        "commit_text": " Problem:    Invalid memory access when using :retab with large value. Solution:   Check the number is positive.",
        "func_before": "static void\npaste_option_changed(void)\n{\n    static int\told_p_paste = FALSE;\n    static int\tsave_sm = 0;\n    static int\tsave_sta = 0;\n#ifdef FEAT_CMDL_INFO\n    static int\tsave_ru = 0;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    static int\tsave_ri = 0;\n    static int\tsave_hkmap = 0;\n#endif\n    buf_T\t*buf;\n\n    if (p_paste)\n    {\n\t/*\n\t * Paste switched from off to on.\n\t * Save the current values, so they can be restored later.\n\t */\n\tif (!old_p_paste)\n\t{\n\t    // save options for each buffer\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tbuf->b_p_tw_nopaste = buf->b_p_tw;\n\t\tbuf->b_p_wm_nopaste = buf->b_p_wm;\n\t\tbuf->b_p_sts_nopaste = buf->b_p_sts;\n\t\tbuf->b_p_ai_nopaste = buf->b_p_ai;\n\t\tbuf->b_p_et_nopaste = buf->b_p_et;\n#ifdef FEAT_VARTABS\n\t\tif (buf->b_p_vsts_nopaste)\n\t\t    vim_free(buf->b_p_vsts_nopaste);\n\t\tbuf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option\n\t\t\t\t     ? vim_strsave(buf->b_p_vsts) : NULL;\n#endif\n\t    }\n\n\t    // save global options\n\t    save_sm = p_sm;\n\t    save_sta = p_sta;\n#ifdef FEAT_CMDL_INFO\n\t    save_ru = p_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    save_ri = p_ri;\n\t    save_hkmap = p_hkmap;\n#endif\n\t    // save global values for local buffer options\n\t    p_ai_nopaste = p_ai;\n\t    p_et_nopaste = p_et;\n\t    p_sts_nopaste = p_sts;\n\t    p_tw_nopaste = p_tw;\n\t    p_wm_nopaste = p_wm;\n#ifdef FEAT_VARTABS\n\t    if (p_vsts_nopaste)\n\t\tvim_free(p_vsts_nopaste);\n\t    p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL;\n#endif\n\t}\n\n\t/*\n\t * Always set the option values, also when 'paste' is set when it is\n\t * already on.\n\t */\n\t// set options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = 0;\t    // textwidth is 0\n\t    buf->b_p_wm = 0;\t    // wrapmargin is 0\n\t    buf->b_p_sts = 0;\t    // softtabstop is 0\n\t    buf->b_p_ai = 0;\t    // no auto-indent\n\t    buf->b_p_et = 0;\t    // no expandtab\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    buf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// set global options\n\tp_sm = 0;\t\t    // no showmatch\n\tp_sta = 0;\t\t    // no smarttab\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru)\n\t    status_redraw_all();    // redraw to remove the ruler\n\tp_ru = 0;\t\t    // no ruler\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = 0;\t\t    // no reverse insert\n\tp_hkmap = 0;\t\t    // no Hebrew keyboard\n#endif\n\t// set global values for local buffer options\n\tp_tw = 0;\n\tp_wm = 0;\n\tp_sts = 0;\n\tp_ai = 0;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = empty_option;\n#endif\n    }\n\n    /*\n     * Paste switched from on to off: Restore saved values.\n     */\n    else if (old_p_paste)\n    {\n\t// restore options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = buf->b_p_tw_nopaste;\n\t    buf->b_p_wm = buf->b_p_wm_nopaste;\n\t    buf->b_p_sts = buf->b_p_sts_nopaste;\n\t    buf->b_p_ai = buf->b_p_ai_nopaste;\n\t    buf->b_p_et = buf->b_p_et_nopaste;\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n\t\t\t ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n\t\ttabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// restore global options\n\tp_sm = save_sm;\n\tp_sta = save_sta;\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru != save_ru)\n\t    status_redraw_all();    // redraw to draw the ruler\n\tp_ru = save_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = save_ri;\n\tp_hkmap = save_hkmap;\n#endif\n\t// set global values for local buffer options\n\tp_ai = p_ai_nopaste;\n\tp_et = p_et_nopaste;\n\tp_sts = p_sts_nopaste;\n\tp_tw = p_tw_nopaste;\n\tp_wm = p_wm_nopaste;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;\n#endif\n    }\n\n    old_p_paste = p_paste;\n}",
        "func": "static void\npaste_option_changed(void)\n{\n    static int\told_p_paste = FALSE;\n    static int\tsave_sm = 0;\n    static int\tsave_sta = 0;\n#ifdef FEAT_CMDL_INFO\n    static int\tsave_ru = 0;\n#endif\n#ifdef FEAT_RIGHTLEFT\n    static int\tsave_ri = 0;\n    static int\tsave_hkmap = 0;\n#endif\n    buf_T\t*buf;\n\n    if (p_paste)\n    {\n\t/*\n\t * Paste switched from off to on.\n\t * Save the current values, so they can be restored later.\n\t */\n\tif (!old_p_paste)\n\t{\n\t    // save options for each buffer\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tbuf->b_p_tw_nopaste = buf->b_p_tw;\n\t\tbuf->b_p_wm_nopaste = buf->b_p_wm;\n\t\tbuf->b_p_sts_nopaste = buf->b_p_sts;\n\t\tbuf->b_p_ai_nopaste = buf->b_p_ai;\n\t\tbuf->b_p_et_nopaste = buf->b_p_et;\n#ifdef FEAT_VARTABS\n\t\tif (buf->b_p_vsts_nopaste)\n\t\t    vim_free(buf->b_p_vsts_nopaste);\n\t\tbuf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option\n\t\t\t\t     ? vim_strsave(buf->b_p_vsts) : NULL;\n#endif\n\t    }\n\n\t    // save global options\n\t    save_sm = p_sm;\n\t    save_sta = p_sta;\n#ifdef FEAT_CMDL_INFO\n\t    save_ru = p_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    save_ri = p_ri;\n\t    save_hkmap = p_hkmap;\n#endif\n\t    // save global values for local buffer options\n\t    p_ai_nopaste = p_ai;\n\t    p_et_nopaste = p_et;\n\t    p_sts_nopaste = p_sts;\n\t    p_tw_nopaste = p_tw;\n\t    p_wm_nopaste = p_wm;\n#ifdef FEAT_VARTABS\n\t    if (p_vsts_nopaste)\n\t\tvim_free(p_vsts_nopaste);\n\t    p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL;\n#endif\n\t}\n\n\t/*\n\t * Always set the option values, also when 'paste' is set when it is\n\t * already on.\n\t */\n\t// set options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = 0;\t    // textwidth is 0\n\t    buf->b_p_wm = 0;\t    // wrapmargin is 0\n\t    buf->b_p_sts = 0;\t    // softtabstop is 0\n\t    buf->b_p_ai = 0;\t    // no auto-indent\n\t    buf->b_p_et = 0;\t    // no expandtab\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    buf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// set global options\n\tp_sm = 0;\t\t    // no showmatch\n\tp_sta = 0;\t\t    // no smarttab\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru)\n\t    status_redraw_all();    // redraw to remove the ruler\n\tp_ru = 0;\t\t    // no ruler\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = 0;\t\t    // no reverse insert\n\tp_hkmap = 0;\t\t    // no Hebrew keyboard\n#endif\n\t// set global values for local buffer options\n\tp_tw = 0;\n\tp_wm = 0;\n\tp_sts = 0;\n\tp_ai = 0;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = empty_option;\n#endif\n    }\n\n    /*\n     * Paste switched from on to off: Restore saved values.\n     */\n    else if (old_p_paste)\n    {\n\t// restore options for each buffer\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    buf->b_p_tw = buf->b_p_tw_nopaste;\n\t    buf->b_p_wm = buf->b_p_wm_nopaste;\n\t    buf->b_p_sts = buf->b_p_sts_nopaste;\n\t    buf->b_p_ai = buf->b_p_ai_nopaste;\n\t    buf->b_p_et = buf->b_p_et_nopaste;\n#ifdef FEAT_VARTABS\n\t    if (buf->b_p_vsts)\n\t\tfree_string_option(buf->b_p_vsts);\n\t    buf->b_p_vsts = buf->b_p_vsts_nopaste\n\t\t\t ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option;\n\t    if (buf->b_p_vsts_array)\n\t\tvim_free(buf->b_p_vsts_array);\n\t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n\t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n#endif\n\t}\n\n\t// restore global options\n\tp_sm = save_sm;\n\tp_sta = save_sta;\n#ifdef FEAT_CMDL_INFO\n\tif (p_ru != save_ru)\n\t    status_redraw_all();    // redraw to draw the ruler\n\tp_ru = save_ru;\n#endif\n#ifdef FEAT_RIGHTLEFT\n\tp_ri = save_ri;\n\tp_hkmap = save_hkmap;\n#endif\n\t// set global values for local buffer options\n\tp_ai = p_ai_nopaste;\n\tp_et = p_et_nopaste;\n\tp_sts = p_sts_nopaste;\n\tp_tw = p_tw_nopaste;\n\tp_wm = p_wm_nopaste;\n#ifdef FEAT_VARTABS\n\tif (p_vsts)\n\t    free_string_option(p_vsts);\n\tp_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option;\n#endif\n    }\n\n    old_p_paste = p_paste;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -127,7 +127,7 @@\n \t    if (buf->b_p_vsts_array)\n \t\tvim_free(buf->b_p_vsts_array);\n \t    if (buf->b_p_vsts && buf->b_p_vsts != empty_option)\n-\t\ttabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n+\t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);\n \t    else\n \t\tbuf->b_p_vsts_array = 0;\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\t\ttabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);"
            ],
            "added_lines": [
                "\t\t(void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3770",
        "func_name": "vim/buf_copy_options",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/b7081e135a16091c93f6f5f7525a5c58fb7ca9f9",
        "commit_title": "patch 8.2.3402: invalid memory access when using :retab with large value",
        "commit_text": " Problem:    Invalid memory access when using :retab with large value. Solution:   Check the number is positive.",
        "func_before": "void\nbuf_copy_options(buf_T *buf, int flags)\n{\n    int\t\tshould_copy = TRUE;\n    char_u\t*save_p_isk = NULL;\t    // init for GCC\n    int\t\tdont_do_help;\n    int\t\tdid_isk = FALSE;\n\n    /*\n     * Skip this when the option defaults have not been set yet.  Happens when\n     * main() allocates the first buffer.\n     */\n    if (p_cpo != NULL)\n    {\n\t/*\n\t * Always copy when entering and 'cpo' contains 'S'.\n\t * Don't copy when already initialized.\n\t * Don't copy when 'cpo' contains 's' and not entering.\n\t * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n\t * yes\t  yes\t       X\t X\tTRUE\n\t * yes\t  no\t      yes\t X\tFALSE\n\t * no\t   X\t      yes\t X\tFALSE\n\t *  X\t  no\t      no\tyes\tFALSE\n\t *  X\t  no\t      no\tno\tTRUE\n\t * no\t  yes\t      no\t X\tTRUE\n\t */\n\tif ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n\t\t&& (buf->b_p_initialized\n\t\t    || (!(flags & BCO_ENTER)\n\t\t\t&& vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n\t    should_copy = FALSE;\n\n\tif (should_copy || (flags & BCO_ALWAYS))\n\t{\n#ifdef FEAT_EVAL\n\t    CLEAR_FIELD(buf->b_p_script_ctx);\n\t    init_buf_opt_idx();\n#endif\n\t    // Don't copy the options specific to a help buffer when\n\t    // BCO_NOHELP is given or the options were initialized already\n\t    // (jumping back to a help file with CTRL-T or CTRL-O)\n\t    dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n\t\t\t\t\t\t       || buf->b_p_initialized;\n\t    if (dont_do_help)\t\t// don't free b_p_isk\n\t    {\n\t\tsave_p_isk = buf->b_p_isk;\n\t\tbuf->b_p_isk = NULL;\n\t    }\n\t    /*\n\t     * Always free the allocated strings.  If not already initialized,\n\t     * reset 'readonly' and copy 'fileformat'.\n\t     */\n\t    if (!buf->b_p_initialized)\n\t    {\n\t\tfree_buf_options(buf, TRUE);\n\t\tbuf->b_p_ro = FALSE;\t\t// don't copy readonly\n\t\tbuf->b_p_tx = p_tx;\n\t\tbuf->b_p_fenc = vim_strsave(p_fenc);\n\t\tswitch (*p_ffs)\n\t\t{\n\t\t    case 'm':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;\n\t\t    case 'd':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;\n\t\t    case 'u':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;\n\t\t    default:\n\t\t\tbuf->b_p_ff = vim_strsave(p_ff);\n\t\t}\n\t\tif (buf->b_p_ff != NULL)\n\t\t    buf->b_start_ffc = *buf->b_p_ff;\n\t\tbuf->b_p_bh = empty_option;\n\t\tbuf->b_p_bt = empty_option;\n\t    }\n\t    else\n\t\tfree_buf_options(buf, FALSE);\n\n\t    buf->b_p_ai = p_ai;\n\t    COPY_OPT_SCTX(buf, BV_AI);\n\t    buf->b_p_ai_nopaste = p_ai_nopaste;\n\t    buf->b_p_sw = p_sw;\n\t    COPY_OPT_SCTX(buf, BV_SW);\n\t    buf->b_p_tw = p_tw;\n\t    COPY_OPT_SCTX(buf, BV_TW);\n\t    buf->b_p_tw_nopaste = p_tw_nopaste;\n\t    buf->b_p_tw_nobin = p_tw_nobin;\n\t    buf->b_p_wm = p_wm;\n\t    COPY_OPT_SCTX(buf, BV_WM);\n\t    buf->b_p_wm_nopaste = p_wm_nopaste;\n\t    buf->b_p_wm_nobin = p_wm_nobin;\n\t    buf->b_p_bin = p_bin;\n\t    COPY_OPT_SCTX(buf, BV_BIN);\n\t    buf->b_p_bomb = p_bomb;\n\t    COPY_OPT_SCTX(buf, BV_BOMB);\n\t    buf->b_p_fixeol = p_fixeol;\n\t    COPY_OPT_SCTX(buf, BV_FIXEOL);\n\t    buf->b_p_et = p_et;\n\t    COPY_OPT_SCTX(buf, BV_ET);\n\t    buf->b_p_et_nobin = p_et_nobin;\n\t    buf->b_p_et_nopaste = p_et_nopaste;\n\t    buf->b_p_ml = p_ml;\n\t    COPY_OPT_SCTX(buf, BV_ML);\n\t    buf->b_p_ml_nobin = p_ml_nobin;\n\t    buf->b_p_inf = p_inf;\n\t    COPY_OPT_SCTX(buf, BV_INF);\n\t    if (cmdmod.cmod_flags & CMOD_NOSWAPFILE)\n\t\tbuf->b_p_swf = FALSE;\n\t    else\n\t    {\n\t\tbuf->b_p_swf = p_swf;\n\t\tCOPY_OPT_SCTX(buf, BV_INF);\n\t    }\n\t    buf->b_p_cpt = vim_strsave(p_cpt);\n\t    COPY_OPT_SCTX(buf, BV_CPT);\n#ifdef BACKSLASH_IN_FILENAME\n\t    buf->b_p_csl = vim_strsave(p_csl);\n\t    COPY_OPT_SCTX(buf, BV_CSL);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_cfu = vim_strsave(p_cfu);\n\t    COPY_OPT_SCTX(buf, BV_CFU);\n\t    buf->b_p_ofu = vim_strsave(p_ofu);\n\t    COPY_OPT_SCTX(buf, BV_OFU);\n#endif\n#ifdef FEAT_EVAL\n\t    buf->b_p_tfu = vim_strsave(p_tfu);\n\t    COPY_OPT_SCTX(buf, BV_TFU);\n#endif\n\t    buf->b_p_sts = p_sts;\n\t    COPY_OPT_SCTX(buf, BV_STS);\n\t    buf->b_p_sts_nopaste = p_sts_nopaste;\n#ifdef FEAT_VARTABS\n\t    buf->b_p_vsts = vim_strsave(p_vsts);\n\t    COPY_OPT_SCTX(buf, BV_VSTS);\n\t    if (p_vsts && p_vsts != empty_option)\n\t\ttabstop_set(p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n\t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n\t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n#endif\n\t    buf->b_p_sn = p_sn;\n\t    COPY_OPT_SCTX(buf, BV_SN);\n\t    buf->b_p_com = vim_strsave(p_com);\n\t    COPY_OPT_SCTX(buf, BV_COM);\n#ifdef FEAT_FOLDING\n\t    buf->b_p_cms = vim_strsave(p_cms);\n\t    COPY_OPT_SCTX(buf, BV_CMS);\n#endif\n\t    buf->b_p_fo = vim_strsave(p_fo);\n\t    COPY_OPT_SCTX(buf, BV_FO);\n\t    buf->b_p_flp = vim_strsave(p_flp);\n\t    COPY_OPT_SCTX(buf, BV_FLP);\n\t    // NOTE: Valgrind may report a bogus memory leak for 'nrformats'\n\t    // when it is set to 8 bytes in defaults.vim.\n\t    buf->b_p_nf = vim_strsave(p_nf);\n\t    COPY_OPT_SCTX(buf, BV_NF);\n\t    buf->b_p_mps = vim_strsave(p_mps);\n\t    COPY_OPT_SCTX(buf, BV_MPS);\n#ifdef FEAT_SMARTINDENT\n\t    buf->b_p_si = p_si;\n\t    COPY_OPT_SCTX(buf, BV_SI);\n#endif\n\t    buf->b_p_ci = p_ci;\n\t    COPY_OPT_SCTX(buf, BV_CI);\n#ifdef FEAT_CINDENT\n\t    buf->b_p_cin = p_cin;\n\t    COPY_OPT_SCTX(buf, BV_CIN);\n\t    buf->b_p_cink = vim_strsave(p_cink);\n\t    COPY_OPT_SCTX(buf, BV_CINK);\n\t    buf->b_p_cino = vim_strsave(p_cino);\n\t    COPY_OPT_SCTX(buf, BV_CINO);\n#endif\n\t    // Don't copy 'filetype', it must be detected\n\t    buf->b_p_ft = empty_option;\n\t    buf->b_p_pi = p_pi;\n\t    COPY_OPT_SCTX(buf, BV_PI);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    buf->b_p_cinw = vim_strsave(p_cinw);\n\t    COPY_OPT_SCTX(buf, BV_CINW);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lisp = p_lisp;\n\t    COPY_OPT_SCTX(buf, BV_LISP);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // Don't copy 'syntax', it must be set\n\t    buf->b_p_syn = empty_option;\n\t    buf->b_p_smc = p_smc;\n\t    COPY_OPT_SCTX(buf, BV_SMC);\n\t    buf->b_s.b_syn_isk = empty_option;\n#endif\n#ifdef FEAT_SPELL\n\t    buf->b_s.b_p_spc = vim_strsave(p_spc);\n\t    COPY_OPT_SCTX(buf, BV_SPC);\n\t    (void)compile_cap_prog(&buf->b_s);\n\t    buf->b_s.b_p_spf = vim_strsave(p_spf);\n\t    COPY_OPT_SCTX(buf, BV_SPF);\n\t    buf->b_s.b_p_spl = vim_strsave(p_spl);\n\t    COPY_OPT_SCTX(buf, BV_SPL);\n\t    buf->b_s.b_p_spo = vim_strsave(p_spo);\n\t    COPY_OPT_SCTX(buf, BV_SPO);\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\t    buf->b_p_inde = vim_strsave(p_inde);\n\t    COPY_OPT_SCTX(buf, BV_INDE);\n\t    buf->b_p_indk = vim_strsave(p_indk);\n\t    COPY_OPT_SCTX(buf, BV_INDK);\n#endif\n\t    buf->b_p_fp = empty_option;\n#if defined(FEAT_EVAL)\n\t    buf->b_p_fex = vim_strsave(p_fex);\n\t    COPY_OPT_SCTX(buf, BV_FEX);\n#endif\n#ifdef FEAT_CRYPT\n\t    buf->b_p_key = vim_strsave(p_key);\n\t    COPY_OPT_SCTX(buf, BV_KEY);\n#endif\n#ifdef FEAT_SEARCHPATH\n\t    buf->b_p_sua = vim_strsave(p_sua);\n\t    COPY_OPT_SCTX(buf, BV_SUA);\n#endif\n#ifdef FEAT_KEYMAP\n\t    buf->b_p_keymap = vim_strsave(p_keymap);\n\t    COPY_OPT_SCTX(buf, BV_KMAP);\n\t    buf->b_kmap_state |= KEYMAP_INIT;\n#endif\n#ifdef FEAT_TERMINAL\n\t    buf->b_p_twsl = p_twsl;\n\t    COPY_OPT_SCTX(buf, BV_TWSL);\n#endif\n\t    // This isn't really an option, but copying the langmap and IME\n\t    // state from the current buffer is better than resetting it.\n\t    buf->b_p_iminsert = p_iminsert;\n\t    COPY_OPT_SCTX(buf, BV_IMI);\n\t    buf->b_p_imsearch = p_imsearch;\n\t    COPY_OPT_SCTX(buf, BV_IMS);\n\n\t    // options that are normally global but also have a local value\n\t    // are not copied, start using the global value\n\t    buf->b_p_ar = -1;\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    buf->b_p_bkc = empty_option;\n\t    buf->b_bkc_flags = 0;\n#ifdef FEAT_QUICKFIX\n\t    buf->b_p_gp = empty_option;\n\t    buf->b_p_mp = empty_option;\n\t    buf->b_p_efm = empty_option;\n#endif\n\t    buf->b_p_ep = empty_option;\n\t    buf->b_p_kp = empty_option;\n\t    buf->b_p_path = empty_option;\n\t    buf->b_p_tags = empty_option;\n\t    buf->b_p_tc = empty_option;\n\t    buf->b_tc_flags = 0;\n#ifdef FEAT_FIND_ID\n\t    buf->b_p_def = empty_option;\n\t    buf->b_p_inc = empty_option;\n# ifdef FEAT_EVAL\n\t    buf->b_p_inex = vim_strsave(p_inex);\n\t    COPY_OPT_SCTX(buf, BV_INEX);\n# endif\n#endif\n\t    buf->b_p_dict = empty_option;\n\t    buf->b_p_tsr = empty_option;\n#ifdef FEAT_TEXTOBJ\n\t    buf->b_p_qe = vim_strsave(p_qe);\n\t    COPY_OPT_SCTX(buf, BV_QE);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    buf->b_p_bexpr = empty_option;\n#endif\n#if defined(FEAT_CRYPT)\n\t    buf->b_p_cm = empty_option;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t    buf->b_p_udf = p_udf;\n\t    COPY_OPT_SCTX(buf, BV_UDF);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lw = empty_option;\n#endif\n\t    buf->b_p_menc = empty_option;\n\n\t    /*\n\t     * Don't copy the options set by ex_help(), use the saved values,\n\t     * when going from a help buffer to a non-help buffer.\n\t     * Don't touch these at all when BCO_NOHELP is used and going from\n\t     * or to a help buffer.\n\t     */\n\t    if (dont_do_help)\n\t    {\n\t\tbuf->b_p_isk = save_p_isk;\n#ifdef FEAT_VARTABS\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t    }\n\t    else\n\t    {\n\t\tbuf->b_p_isk = vim_strsave(p_isk);\n\t\tCOPY_OPT_SCTX(buf, BV_ISK);\n\t\tdid_isk = TRUE;\n\t\tbuf->b_p_ts = p_ts;\n#ifdef FEAT_VARTABS\n\t\tbuf->b_p_vts = vim_strsave(p_vts);\n\t\tCOPY_OPT_SCTX(buf, BV_VTS);\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t\tbuf->b_help = FALSE;\n\t\tif (buf->b_p_bt[0] == 'h')\n\t\t    clear_string_option(&buf->b_p_bt);\n\t\tbuf->b_p_ma = p_ma;\n\t\tCOPY_OPT_SCTX(buf, BV_MA);\n\t    }\n\t}\n\n\t/*\n\t * When the options should be copied (ignoring BCO_ALWAYS), set the\n\t * flag that indicates that the options have been initialized.\n\t */\n\tif (should_copy)\n\t    buf->b_p_initialized = TRUE;\n    }\n\n    check_buf_options(buf);\t    // make sure we don't have NULLs\n    if (did_isk)\n\t(void)buf_init_chartab(buf, FALSE);\n}",
        "func": "void\nbuf_copy_options(buf_T *buf, int flags)\n{\n    int\t\tshould_copy = TRUE;\n    char_u\t*save_p_isk = NULL;\t    // init for GCC\n    int\t\tdont_do_help;\n    int\t\tdid_isk = FALSE;\n\n    /*\n     * Skip this when the option defaults have not been set yet.  Happens when\n     * main() allocates the first buffer.\n     */\n    if (p_cpo != NULL)\n    {\n\t/*\n\t * Always copy when entering and 'cpo' contains 'S'.\n\t * Don't copy when already initialized.\n\t * Don't copy when 'cpo' contains 's' and not entering.\n\t * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n\t * yes\t  yes\t       X\t X\tTRUE\n\t * yes\t  no\t      yes\t X\tFALSE\n\t * no\t   X\t      yes\t X\tFALSE\n\t *  X\t  no\t      no\tyes\tFALSE\n\t *  X\t  no\t      no\tno\tTRUE\n\t * no\t  yes\t      no\t X\tTRUE\n\t */\n\tif ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n\t\t&& (buf->b_p_initialized\n\t\t    || (!(flags & BCO_ENTER)\n\t\t\t&& vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n\t    should_copy = FALSE;\n\n\tif (should_copy || (flags & BCO_ALWAYS))\n\t{\n#ifdef FEAT_EVAL\n\t    CLEAR_FIELD(buf->b_p_script_ctx);\n\t    init_buf_opt_idx();\n#endif\n\t    // Don't copy the options specific to a help buffer when\n\t    // BCO_NOHELP is given or the options were initialized already\n\t    // (jumping back to a help file with CTRL-T or CTRL-O)\n\t    dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n\t\t\t\t\t\t       || buf->b_p_initialized;\n\t    if (dont_do_help)\t\t// don't free b_p_isk\n\t    {\n\t\tsave_p_isk = buf->b_p_isk;\n\t\tbuf->b_p_isk = NULL;\n\t    }\n\t    /*\n\t     * Always free the allocated strings.  If not already initialized,\n\t     * reset 'readonly' and copy 'fileformat'.\n\t     */\n\t    if (!buf->b_p_initialized)\n\t    {\n\t\tfree_buf_options(buf, TRUE);\n\t\tbuf->b_p_ro = FALSE;\t\t// don't copy readonly\n\t\tbuf->b_p_tx = p_tx;\n\t\tbuf->b_p_fenc = vim_strsave(p_fenc);\n\t\tswitch (*p_ffs)\n\t\t{\n\t\t    case 'm':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;\n\t\t    case 'd':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;\n\t\t    case 'u':\n\t\t\tbuf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;\n\t\t    default:\n\t\t\tbuf->b_p_ff = vim_strsave(p_ff);\n\t\t}\n\t\tif (buf->b_p_ff != NULL)\n\t\t    buf->b_start_ffc = *buf->b_p_ff;\n\t\tbuf->b_p_bh = empty_option;\n\t\tbuf->b_p_bt = empty_option;\n\t    }\n\t    else\n\t\tfree_buf_options(buf, FALSE);\n\n\t    buf->b_p_ai = p_ai;\n\t    COPY_OPT_SCTX(buf, BV_AI);\n\t    buf->b_p_ai_nopaste = p_ai_nopaste;\n\t    buf->b_p_sw = p_sw;\n\t    COPY_OPT_SCTX(buf, BV_SW);\n\t    buf->b_p_tw = p_tw;\n\t    COPY_OPT_SCTX(buf, BV_TW);\n\t    buf->b_p_tw_nopaste = p_tw_nopaste;\n\t    buf->b_p_tw_nobin = p_tw_nobin;\n\t    buf->b_p_wm = p_wm;\n\t    COPY_OPT_SCTX(buf, BV_WM);\n\t    buf->b_p_wm_nopaste = p_wm_nopaste;\n\t    buf->b_p_wm_nobin = p_wm_nobin;\n\t    buf->b_p_bin = p_bin;\n\t    COPY_OPT_SCTX(buf, BV_BIN);\n\t    buf->b_p_bomb = p_bomb;\n\t    COPY_OPT_SCTX(buf, BV_BOMB);\n\t    buf->b_p_fixeol = p_fixeol;\n\t    COPY_OPT_SCTX(buf, BV_FIXEOL);\n\t    buf->b_p_et = p_et;\n\t    COPY_OPT_SCTX(buf, BV_ET);\n\t    buf->b_p_et_nobin = p_et_nobin;\n\t    buf->b_p_et_nopaste = p_et_nopaste;\n\t    buf->b_p_ml = p_ml;\n\t    COPY_OPT_SCTX(buf, BV_ML);\n\t    buf->b_p_ml_nobin = p_ml_nobin;\n\t    buf->b_p_inf = p_inf;\n\t    COPY_OPT_SCTX(buf, BV_INF);\n\t    if (cmdmod.cmod_flags & CMOD_NOSWAPFILE)\n\t\tbuf->b_p_swf = FALSE;\n\t    else\n\t    {\n\t\tbuf->b_p_swf = p_swf;\n\t\tCOPY_OPT_SCTX(buf, BV_INF);\n\t    }\n\t    buf->b_p_cpt = vim_strsave(p_cpt);\n\t    COPY_OPT_SCTX(buf, BV_CPT);\n#ifdef BACKSLASH_IN_FILENAME\n\t    buf->b_p_csl = vim_strsave(p_csl);\n\t    COPY_OPT_SCTX(buf, BV_CSL);\n#endif\n#ifdef FEAT_COMPL_FUNC\n\t    buf->b_p_cfu = vim_strsave(p_cfu);\n\t    COPY_OPT_SCTX(buf, BV_CFU);\n\t    buf->b_p_ofu = vim_strsave(p_ofu);\n\t    COPY_OPT_SCTX(buf, BV_OFU);\n#endif\n#ifdef FEAT_EVAL\n\t    buf->b_p_tfu = vim_strsave(p_tfu);\n\t    COPY_OPT_SCTX(buf, BV_TFU);\n#endif\n\t    buf->b_p_sts = p_sts;\n\t    COPY_OPT_SCTX(buf, BV_STS);\n\t    buf->b_p_sts_nopaste = p_sts_nopaste;\n#ifdef FEAT_VARTABS\n\t    buf->b_p_vsts = vim_strsave(p_vsts);\n\t    COPY_OPT_SCTX(buf, BV_VSTS);\n\t    if (p_vsts && p_vsts != empty_option)\n\t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);\n\t    else\n\t\tbuf->b_p_vsts_array = 0;\n\t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n\t\t\t\t ? vim_strsave(p_vsts_nopaste) : NULL;\n#endif\n\t    buf->b_p_sn = p_sn;\n\t    COPY_OPT_SCTX(buf, BV_SN);\n\t    buf->b_p_com = vim_strsave(p_com);\n\t    COPY_OPT_SCTX(buf, BV_COM);\n#ifdef FEAT_FOLDING\n\t    buf->b_p_cms = vim_strsave(p_cms);\n\t    COPY_OPT_SCTX(buf, BV_CMS);\n#endif\n\t    buf->b_p_fo = vim_strsave(p_fo);\n\t    COPY_OPT_SCTX(buf, BV_FO);\n\t    buf->b_p_flp = vim_strsave(p_flp);\n\t    COPY_OPT_SCTX(buf, BV_FLP);\n\t    // NOTE: Valgrind may report a bogus memory leak for 'nrformats'\n\t    // when it is set to 8 bytes in defaults.vim.\n\t    buf->b_p_nf = vim_strsave(p_nf);\n\t    COPY_OPT_SCTX(buf, BV_NF);\n\t    buf->b_p_mps = vim_strsave(p_mps);\n\t    COPY_OPT_SCTX(buf, BV_MPS);\n#ifdef FEAT_SMARTINDENT\n\t    buf->b_p_si = p_si;\n\t    COPY_OPT_SCTX(buf, BV_SI);\n#endif\n\t    buf->b_p_ci = p_ci;\n\t    COPY_OPT_SCTX(buf, BV_CI);\n#ifdef FEAT_CINDENT\n\t    buf->b_p_cin = p_cin;\n\t    COPY_OPT_SCTX(buf, BV_CIN);\n\t    buf->b_p_cink = vim_strsave(p_cink);\n\t    COPY_OPT_SCTX(buf, BV_CINK);\n\t    buf->b_p_cino = vim_strsave(p_cino);\n\t    COPY_OPT_SCTX(buf, BV_CINO);\n#endif\n\t    // Don't copy 'filetype', it must be detected\n\t    buf->b_p_ft = empty_option;\n\t    buf->b_p_pi = p_pi;\n\t    COPY_OPT_SCTX(buf, BV_PI);\n#if defined(FEAT_SMARTINDENT) || defined(FEAT_CINDENT)\n\t    buf->b_p_cinw = vim_strsave(p_cinw);\n\t    COPY_OPT_SCTX(buf, BV_CINW);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lisp = p_lisp;\n\t    COPY_OPT_SCTX(buf, BV_LISP);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // Don't copy 'syntax', it must be set\n\t    buf->b_p_syn = empty_option;\n\t    buf->b_p_smc = p_smc;\n\t    COPY_OPT_SCTX(buf, BV_SMC);\n\t    buf->b_s.b_syn_isk = empty_option;\n#endif\n#ifdef FEAT_SPELL\n\t    buf->b_s.b_p_spc = vim_strsave(p_spc);\n\t    COPY_OPT_SCTX(buf, BV_SPC);\n\t    (void)compile_cap_prog(&buf->b_s);\n\t    buf->b_s.b_p_spf = vim_strsave(p_spf);\n\t    COPY_OPT_SCTX(buf, BV_SPF);\n\t    buf->b_s.b_p_spl = vim_strsave(p_spl);\n\t    COPY_OPT_SCTX(buf, BV_SPL);\n\t    buf->b_s.b_p_spo = vim_strsave(p_spo);\n\t    COPY_OPT_SCTX(buf, BV_SPO);\n#endif\n#if defined(FEAT_CINDENT) && defined(FEAT_EVAL)\n\t    buf->b_p_inde = vim_strsave(p_inde);\n\t    COPY_OPT_SCTX(buf, BV_INDE);\n\t    buf->b_p_indk = vim_strsave(p_indk);\n\t    COPY_OPT_SCTX(buf, BV_INDK);\n#endif\n\t    buf->b_p_fp = empty_option;\n#if defined(FEAT_EVAL)\n\t    buf->b_p_fex = vim_strsave(p_fex);\n\t    COPY_OPT_SCTX(buf, BV_FEX);\n#endif\n#ifdef FEAT_CRYPT\n\t    buf->b_p_key = vim_strsave(p_key);\n\t    COPY_OPT_SCTX(buf, BV_KEY);\n#endif\n#ifdef FEAT_SEARCHPATH\n\t    buf->b_p_sua = vim_strsave(p_sua);\n\t    COPY_OPT_SCTX(buf, BV_SUA);\n#endif\n#ifdef FEAT_KEYMAP\n\t    buf->b_p_keymap = vim_strsave(p_keymap);\n\t    COPY_OPT_SCTX(buf, BV_KMAP);\n\t    buf->b_kmap_state |= KEYMAP_INIT;\n#endif\n#ifdef FEAT_TERMINAL\n\t    buf->b_p_twsl = p_twsl;\n\t    COPY_OPT_SCTX(buf, BV_TWSL);\n#endif\n\t    // This isn't really an option, but copying the langmap and IME\n\t    // state from the current buffer is better than resetting it.\n\t    buf->b_p_iminsert = p_iminsert;\n\t    COPY_OPT_SCTX(buf, BV_IMI);\n\t    buf->b_p_imsearch = p_imsearch;\n\t    COPY_OPT_SCTX(buf, BV_IMS);\n\n\t    // options that are normally global but also have a local value\n\t    // are not copied, start using the global value\n\t    buf->b_p_ar = -1;\n\t    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n\t    buf->b_p_bkc = empty_option;\n\t    buf->b_bkc_flags = 0;\n#ifdef FEAT_QUICKFIX\n\t    buf->b_p_gp = empty_option;\n\t    buf->b_p_mp = empty_option;\n\t    buf->b_p_efm = empty_option;\n#endif\n\t    buf->b_p_ep = empty_option;\n\t    buf->b_p_kp = empty_option;\n\t    buf->b_p_path = empty_option;\n\t    buf->b_p_tags = empty_option;\n\t    buf->b_p_tc = empty_option;\n\t    buf->b_tc_flags = 0;\n#ifdef FEAT_FIND_ID\n\t    buf->b_p_def = empty_option;\n\t    buf->b_p_inc = empty_option;\n# ifdef FEAT_EVAL\n\t    buf->b_p_inex = vim_strsave(p_inex);\n\t    COPY_OPT_SCTX(buf, BV_INEX);\n# endif\n#endif\n\t    buf->b_p_dict = empty_option;\n\t    buf->b_p_tsr = empty_option;\n#ifdef FEAT_TEXTOBJ\n\t    buf->b_p_qe = vim_strsave(p_qe);\n\t    COPY_OPT_SCTX(buf, BV_QE);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n\t    buf->b_p_bexpr = empty_option;\n#endif\n#if defined(FEAT_CRYPT)\n\t    buf->b_p_cm = empty_option;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t    buf->b_p_udf = p_udf;\n\t    COPY_OPT_SCTX(buf, BV_UDF);\n#endif\n#ifdef FEAT_LISP\n\t    buf->b_p_lw = empty_option;\n#endif\n\t    buf->b_p_menc = empty_option;\n\n\t    /*\n\t     * Don't copy the options set by ex_help(), use the saved values,\n\t     * when going from a help buffer to a non-help buffer.\n\t     * Don't touch these at all when BCO_NOHELP is used and going from\n\t     * or to a help buffer.\n\t     */\n\t    if (dont_do_help)\n\t    {\n\t\tbuf->b_p_isk = save_p_isk;\n#ifdef FEAT_VARTABS\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t    }\n\t    else\n\t    {\n\t\tbuf->b_p_isk = vim_strsave(p_isk);\n\t\tCOPY_OPT_SCTX(buf, BV_ISK);\n\t\tdid_isk = TRUE;\n\t\tbuf->b_p_ts = p_ts;\n#ifdef FEAT_VARTABS\n\t\tbuf->b_p_vts = vim_strsave(p_vts);\n\t\tCOPY_OPT_SCTX(buf, BV_VTS);\n\t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n\t\telse\n\t\t    buf->b_p_vts_array = NULL;\n#endif\n\t\tbuf->b_help = FALSE;\n\t\tif (buf->b_p_bt[0] == 'h')\n\t\t    clear_string_option(&buf->b_p_bt);\n\t\tbuf->b_p_ma = p_ma;\n\t\tCOPY_OPT_SCTX(buf, BV_MA);\n\t    }\n\t}\n\n\t/*\n\t * When the options should be copied (ignoring BCO_ALWAYS), set the\n\t * flag that indicates that the options have been initialized.\n\t */\n\tif (should_copy)\n\t    buf->b_p_initialized = TRUE;\n    }\n\n    check_buf_options(buf);\t    // make sure we don't have NULLs\n    if (did_isk)\n\t(void)buf_init_chartab(buf, FALSE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -133,7 +133,7 @@\n \t    buf->b_p_vsts = vim_strsave(p_vsts);\n \t    COPY_OPT_SCTX(buf, BV_VSTS);\n \t    if (p_vsts && p_vsts != empty_option)\n-\t\ttabstop_set(p_vsts, &buf->b_p_vsts_array);\n+\t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);\n \t    else\n \t\tbuf->b_p_vsts_array = 0;\n \t    buf->b_p_vsts_nopaste = p_vsts_nopaste\n@@ -293,7 +293,7 @@\n \t\tbuf->b_p_isk = save_p_isk;\n #ifdef FEAT_VARTABS\n \t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n-\t\t    tabstop_set(p_vts, &buf->b_p_vts_array);\n+\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n \t\telse\n \t\t    buf->b_p_vts_array = NULL;\n #endif\n@@ -308,7 +308,7 @@\n \t\tbuf->b_p_vts = vim_strsave(p_vts);\n \t\tCOPY_OPT_SCTX(buf, BV_VTS);\n \t\tif (p_vts && p_vts != empty_option && !buf->b_p_vts_array)\n-\t\t    tabstop_set(p_vts, &buf->b_p_vts_array);\n+\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);\n \t\telse\n \t\t    buf->b_p_vts_array = NULL;\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\t\ttabstop_set(p_vsts, &buf->b_p_vsts_array);",
                "\t\t    tabstop_set(p_vts, &buf->b_p_vts_array);",
                "\t\t    tabstop_set(p_vts, &buf->b_p_vts_array);"
            ],
            "added_lines": [
                "\t\t(void)tabstop_set(p_vsts, &buf->b_p_vsts_array);",
                "\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);",
                "\t\t    (void)tabstop_set(p_vts, &buf->b_p_vts_array);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3770",
        "func_name": "vim/didset_options2",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/b7081e135a16091c93f6f5f7525a5c58fb7ca9f9",
        "commit_title": "patch 8.2.3402: invalid memory access when using :retab with large value",
        "commit_text": " Problem:    Invalid memory access when using :retab with large value. Solution:   Check the number is positive.",
        "func_before": "static void\ndidset_options2(void)\n{\n    // Initialize the highlight_attr[] table.\n    (void)highlight_changed();\n\n    // Parse default for 'wildmode'\n    check_opt_wim();\n\n    // Parse default for 'listchars'.\n    (void)set_chars_option(curwin, &curwin->w_p_lcs);\n\n    // Parse default for 'fillchars'.\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    // Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}",
        "func": "static void\ndidset_options2(void)\n{\n    // Initialize the highlight_attr[] table.\n    (void)highlight_changed();\n\n    // Parse default for 'wildmode'\n    check_opt_wim();\n\n    // Parse default for 'listchars'.\n    (void)set_chars_option(curwin, &curwin->w_p_lcs);\n\n    // Parse default for 'fillchars'.\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    // Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,8 +19,8 @@\n #endif\n #ifdef FEAT_VARTABS\n     vim_free(curbuf->b_p_vsts_array);\n-    tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n+    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n     vim_free(curbuf->b_p_vts_array);\n-    tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n+    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n #endif\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);",
                "    tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);"
            ],
            "added_lines": [
                "    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);",
                "    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3778",
        "func_name": "vim/find_match_text",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/65b605665997fad54ef39a93199e305af2fe4d7f",
        "commit_title": "patch 8.2.3409: reading beyond end of line with invalid utf-8 character",
        "commit_text": " Problem:    Reading beyond end of line with invalid utf-8 character. Solution:   Check for NUL when advancing.",
        "func_before": "static long\nfind_match_text(colnr_T startcol, int regstart, char_u *match_text)\n{\n    colnr_T col = startcol;\n    int\t    c1, c2;\n    int\t    len1, len2;\n    int\t    match;\n\n    for (;;)\n    {\n\tmatch = TRUE;\n\tlen2 = MB_CHAR2LEN(regstart); // skip regstart\n\tfor (len1 = 0; match_text[len1] != NUL; len1 += MB_CHAR2LEN(c1))\n\t{\n\t    c1 = PTR2CHAR(match_text + len1);\n\t    c2 = PTR2CHAR(rex.line + col + len2);\n\t    if (c1 != c2 && (!rex.reg_ic || MB_CASEFOLD(c1) != MB_CASEFOLD(c2)))\n\t    {\n\t\tmatch = FALSE;\n\t\tbreak;\n\t    }\n\t    len2 += MB_CHAR2LEN(c2);\n\t}\n\tif (match\n\t\t// check that no composing char follows\n\t\t&& !(enc_utf8\n\t\t\t  && utf_iscomposing(PTR2CHAR(rex.line + col + len2))))\n\t{\n\t    cleanup_subexpr();\n\t    if (REG_MULTI)\n\t    {\n\t\trex.reg_startpos[0].lnum = rex.lnum;\n\t\trex.reg_startpos[0].col = col;\n\t\trex.reg_endpos[0].lnum = rex.lnum;\n\t\trex.reg_endpos[0].col = col + len2;\n\t    }\n\t    else\n\t    {\n\t\trex.reg_startp[0] = rex.line + col;\n\t\trex.reg_endp[0] = rex.line + col + len2;\n\t    }\n\t    return 1L;\n\t}\n\n\t// Try finding regstart after the current match.\n\tcol += MB_CHAR2LEN(regstart); // skip regstart\n\tif (skip_to_start(regstart, &col) == FAIL)\n\t    break;\n    }\n    return 0L;\n}",
        "func": "static long\nfind_match_text(colnr_T startcol, int regstart, char_u *match_text)\n{\n    colnr_T col = startcol;\n    int\t    c1, c2;\n    int\t    len1, len2;\n    int\t    match;\n\n    for (;;)\n    {\n\tmatch = TRUE;\n\tlen2 = MB_CHAR2LEN(regstart); // skip regstart\n\tfor (len1 = 0; match_text[len1] != NUL; len1 += MB_CHAR2LEN(c1))\n\t{\n\t    c1 = PTR2CHAR(match_text + len1);\n\t    c2 = PTR2CHAR(rex.line + col + len2);\n\t    if (c1 != c2 && (!rex.reg_ic || MB_CASEFOLD(c1) != MB_CASEFOLD(c2)))\n\t    {\n\t\tmatch = FALSE;\n\t\tbreak;\n\t    }\n\t    len2 += enc_utf8 ? utf_ptr2len(rex.line + col + len2)\n\t\t\t\t\t\t\t     : MB_CHAR2LEN(c2);\n\t}\n\tif (match\n\t\t// check that no composing char follows\n\t\t&& !(enc_utf8\n\t\t\t  && utf_iscomposing(PTR2CHAR(rex.line + col + len2))))\n\t{\n\t    cleanup_subexpr();\n\t    if (REG_MULTI)\n\t    {\n\t\trex.reg_startpos[0].lnum = rex.lnum;\n\t\trex.reg_startpos[0].col = col;\n\t\trex.reg_endpos[0].lnum = rex.lnum;\n\t\trex.reg_endpos[0].col = col + len2;\n\t    }\n\t    else\n\t    {\n\t\trex.reg_startp[0] = rex.line + col;\n\t\trex.reg_endp[0] = rex.line + col + len2;\n\t    }\n\t    return 1L;\n\t}\n\n\t// Try finding regstart after the current match.\n\tcol += MB_CHAR2LEN(regstart); // skip regstart\n\tif (skip_to_start(regstart, &col) == FAIL)\n\t    break;\n    }\n    return 0L;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,8 @@\n \t\tmatch = FALSE;\n \t\tbreak;\n \t    }\n-\t    len2 += MB_CHAR2LEN(c2);\n+\t    len2 += enc_utf8 ? utf_ptr2len(rex.line + col + len2)\n+\t\t\t\t\t\t\t     : MB_CHAR2LEN(c2);\n \t}\n \tif (match\n \t\t// check that no composing char follows",
        "diff_line_info": {
            "deleted_lines": [
                "\t    len2 += MB_CHAR2LEN(c2);"
            ],
            "added_lines": [
                "\t    len2 += enc_utf8 ? utf_ptr2len(rex.line + col + len2)",
                "\t\t\t\t\t\t\t     : MB_CHAR2LEN(c2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32626",
        "func_name": "redis/ldbRedis",
        "description": "Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",
        "git_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "commit_title": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}",
        "commit_text": " When LUA call our C code, by default, the LUA stack has room for 20 elements. In most cases, this is more than enough but sometimes it's not and the caller must verify the LUA stack size before he pushes elements.  On 3 places in the code, there was no verification of the LUA stack size. On specific inputs this missing verification could have lead to invalid memory write: 1. On 'luaReplyToRedisReply', one might return a nested reply that will    explode the LUA stack. 2. On 'redisProtocolToLuaType', the Redis reply might be deep enough  to explode the LUA stack (notice that currently there is no such  command in Redis that returns such a nested reply, but modules might  do it) 3. On 'ldbRedis', one might give a command with enough arguments to  explode the LUA stack (all the arguments will be pushed to the LUA  stack)  This commit is solving all those 3 issues by calling 'lua_checkstack' and verify that there is enough room in the LUA stack to push elements. In case 'lua_checkstack' returns an error (there is not enough room in the LUA stack and it's not possible to increase the stack), we will do the following: 1. On 'luaReplyToRedisReply', we will return an error to the user. 2. On 'redisProtocolToLuaType' we will exit with panic (we assume this    scenario is rare because it can only happen with a module). 3. On 'ldbRedis', we return an error.",
        "func_before": "void ldbRedis(lua_State *lua, sds *argv, int argc) {\n    int j, saved_rc = server.lua_replicate_commands;\n\n    lua_getglobal(lua,\"redis\");\n    lua_pushstring(lua,\"call\");\n    lua_gettable(lua,-2);       /* Stack: redis, redis.call */\n    for (j = 1; j < argc; j++)\n        lua_pushlstring(lua,argv[j],sdslen(argv[j]));\n    ldb.step = 1;               /* Force redis.call() to log. */\n    server.lua_replicate_commands = 1;\n    lua_pcall(lua,argc-1,1,0);  /* Stack: redis, result */\n    ldb.step = 0;               /* Disable logging. */\n    server.lua_replicate_commands = saved_rc;\n    lua_pop(lua,2);             /* Discard the result and clean the stack. */\n}",
        "func": "void ldbRedis(lua_State *lua, sds *argv, int argc) {\n    int j, saved_rc = server.lua_replicate_commands;\n\n    if (!lua_checkstack(lua, argc + 1)) {\n        /* Increase the Lua stack if needed to make sure there is enough room\n         * to push 'argc + 1' elements to the stack. On failure, return error.\n    * Notice that we need, in worst case, 'argc + 1' elements because we push all the arguments\n    * given by the user (without the first argument) and we also push the 'redis' global table and\n    * 'redis.call' function so:\n    * (1 (redis table)) + (1 (redis.call function)) + (argc - 1 (all arguments without the first)) = argc + 1*/\n        ldbLogRedisReply(\"max lua stack reached\");\n        return;\n    }\n\n    lua_getglobal(lua,\"redis\");\n    lua_pushstring(lua,\"call\");\n    lua_gettable(lua,-2);       /* Stack: redis, redis.call */\n    for (j = 1; j < argc; j++)\n        lua_pushlstring(lua,argv[j],sdslen(argv[j]));\n    ldb.step = 1;               /* Force redis.call() to log. */\n    server.lua_replicate_commands = 1;\n    lua_pcall(lua,argc-1,1,0);  /* Stack: redis, result */\n    ldb.step = 0;               /* Disable logging. */\n    server.lua_replicate_commands = saved_rc;\n    lua_pop(lua,2);             /* Discard the result and clean the stack. */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,16 @@\n void ldbRedis(lua_State *lua, sds *argv, int argc) {\n     int j, saved_rc = server.lua_replicate_commands;\n+\n+    if (!lua_checkstack(lua, argc + 1)) {\n+        /* Increase the Lua stack if needed to make sure there is enough room\n+         * to push 'argc + 1' elements to the stack. On failure, return error.\n+    * Notice that we need, in worst case, 'argc + 1' elements because we push all the arguments\n+    * given by the user (without the first argument) and we also push the 'redis' global table and\n+    * 'redis.call' function so:\n+    * (1 (redis table)) + (1 (redis.call function)) + (argc - 1 (all arguments without the first)) = argc + 1*/\n+        ldbLogRedisReply(\"max lua stack reached\");\n+        return;\n+    }\n \n     lua_getglobal(lua,\"redis\");\n     lua_pushstring(lua,\"call\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (!lua_checkstack(lua, argc + 1)) {",
                "        /* Increase the Lua stack if needed to make sure there is enough room",
                "         * to push 'argc + 1' elements to the stack. On failure, return error.",
                "    * Notice that we need, in worst case, 'argc + 1' elements because we push all the arguments",
                "    * given by the user (without the first argument) and we also push the 'redis' global table and",
                "    * 'redis.call' function so:",
                "    * (1 (redis table)) + (1 (redis.call function)) + (argc - 1 (all arguments without the first)) = argc + 1*/",
                "        ldbLogRedisReply(\"max lua stack reached\");",
                "        return;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32626",
        "func_name": "redis/luaReplyToRedisReply",
        "description": "Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",
        "git_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "commit_title": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}",
        "commit_text": " When LUA call our C code, by default, the LUA stack has room for 20 elements. In most cases, this is more than enough but sometimes it's not and the caller must verify the LUA stack size before he pushes elements.  On 3 places in the code, there was no verification of the LUA stack size. On specific inputs this missing verification could have lead to invalid memory write: 1. On 'luaReplyToRedisReply', one might return a nested reply that will    explode the LUA stack. 2. On 'redisProtocolToLuaType', the Redis reply might be deep enough  to explode the LUA stack (notice that currently there is no such  command in Redis that returns such a nested reply, but modules might  do it) 3. On 'ldbRedis', one might give a command with enough arguments to  explode the LUA stack (all the arguments will be pushed to the LUA  stack)  This commit is solving all those 3 issues by calling 'lua_checkstack' and verify that there is enough room in the LUA stack to push elements. In case 'lua_checkstack' returns an error (there is not enough room in the LUA stack and it's not possible to increase the stack), we will do the following: 1. On 'luaReplyToRedisReply', we will return an error to the user. 2. On 'redisProtocolToLuaType' we will exit with panic (we assume this    scenario is rare because it can only happen with a module). 3. On 'ldbRedis', we return an error.",
        "func_before": "void luaReplyToRedisReply(client *c, lua_State *lua) {\n    int t = lua_type(lua,-1);\n\n    switch(t) {\n    case LUA_TSTRING:\n        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));\n        break;\n    case LUA_TBOOLEAN:\n        if (server.lua_client->resp == 2)\n            addReply(c,lua_toboolean(lua,-1) ? shared.cone :\n                                               shared.null[c->resp]);\n        else\n            addReplyBool(c,lua_toboolean(lua,-1));\n        break;\n    case LUA_TNUMBER:\n        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));\n        break;\n    case LUA_TTABLE:\n        /* We need to check if it is an array, an error, or a status reply.\n         * Error are returned as a single element table with 'err' field.\n         * Status replies are returned as single element table with 'ok'\n         * field. */\n\n        /* Handle error reply. */\n        lua_pushstring(lua,\"err\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds err = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(err,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"-%s\\r\\n\",err));\n            sdsfree(err);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle status reply. */\n        lua_pushstring(lua,\"ok\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds ok = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(ok,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"+%s\\r\\n\",ok));\n            sdsfree(ok);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle double reply. */\n        lua_pushstring(lua,\"double\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TNUMBER) {\n            addReplyDouble(c,lua_tonumber(lua,-1));\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle map reply. */\n        lua_pushstring(lua,\"map\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int maplen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, value */\n                lua_pushvalue(lua,-2);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                luaReplyToRedisReply(c, lua); /* Return value. */\n                /* Stack now: table, key. */\n                maplen++;\n            }\n            setDeferredMapLen(c,replylen,maplen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle set reply. */\n        lua_pushstring(lua,\"set\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int setlen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, true */\n                lua_pop(lua,1);               /* Discard the boolean value. */\n                lua_pushvalue(lua,-1);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                /* Stack now: table, key. */\n                setlen++;\n            }\n            setDeferredSetLen(c,replylen,setlen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle the array reply. */\n        void *replylen = addReplyDeferredLen(c);\n        int j = 1, mbulklen = 0;\n        while(1) {\n            lua_pushnumber(lua,j++);\n            lua_gettable(lua,-2);\n            t = lua_type(lua,-1);\n            if (t == LUA_TNIL) {\n                lua_pop(lua,1);\n                break;\n            }\n            luaReplyToRedisReply(c, lua);\n            mbulklen++;\n        }\n        setDeferredArrayLen(c,replylen,mbulklen);\n        break;\n    default:\n        addReplyNull(c);\n    }\n    lua_pop(lua,1);\n}",
        "func": "void luaReplyToRedisReply(client *c, lua_State *lua) {\n\n    if (!lua_checkstack(lua, 4)) {\n        /* Increase the Lua stack if needed to make sure there is enough room\n         * to push 4 elements to the stack. On failure, return error.\n    * Notice that we need, in the worst case, 4 elements because returning a map might\n         * require push 4 elements to the Lua stack.*/\n        addReplyErrorFormat(c, \"reached lua stack limit\");\n        lua_pop(lua,1); // pop the element from the stack\n        return;\n    }\n\n    int t = lua_type(lua,-1);\n\n    switch(t) {\n    case LUA_TSTRING:\n        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));\n        break;\n    case LUA_TBOOLEAN:\n        if (server.lua_client->resp == 2)\n            addReply(c,lua_toboolean(lua,-1) ? shared.cone :\n                                               shared.null[c->resp]);\n        else\n            addReplyBool(c,lua_toboolean(lua,-1));\n        break;\n    case LUA_TNUMBER:\n        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));\n        break;\n    case LUA_TTABLE:\n        /* We need to check if it is an array, an error, or a status reply.\n         * Error are returned as a single element table with 'err' field.\n         * Status replies are returned as single element table with 'ok'\n         * field. */\n\n        /* Handle error reply. */\n        // we took care of the stack size on function start\n        lua_pushstring(lua,\"err\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds err = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(err,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"-%s\\r\\n\",err));\n            sdsfree(err);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle status reply. */\n        lua_pushstring(lua,\"ok\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TSTRING) {\n            sds ok = sdsnew(lua_tostring(lua,-1));\n            sdsmapchars(ok,\"\\r\\n\",\"  \",2);\n            addReplySds(c,sdscatprintf(sdsempty(),\"+%s\\r\\n\",ok));\n            sdsfree(ok);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle double reply. */\n        lua_pushstring(lua,\"double\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TNUMBER) {\n            addReplyDouble(c,lua_tonumber(lua,-1));\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle map reply. */\n        lua_pushstring(lua,\"map\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int maplen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            /* we took care of the stack size on function start */\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, value */\n                lua_pushvalue(lua,-2);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                luaReplyToRedisReply(c, lua); /* Return value. */\n                /* Stack now: table, key. */\n                maplen++;\n            }\n            setDeferredMapLen(c,replylen,maplen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle set reply. */\n        lua_pushstring(lua,\"set\");\n        lua_gettable(lua,-2);\n        t = lua_type(lua,-1);\n        if (t == LUA_TTABLE) {\n            int setlen = 0;\n            void *replylen = addReplyDeferredLen(c);\n            /* we took care of the stack size on function start */\n            lua_pushnil(lua); /* Use nil to start iteration. */\n            while (lua_next(lua,-2)) {\n                /* Stack now: table, key, true */\n                lua_pop(lua,1);               /* Discard the boolean value. */\n                lua_pushvalue(lua,-1);        /* Dup key before consuming. */\n                luaReplyToRedisReply(c, lua); /* Return key. */\n                /* Stack now: table, key. */\n                setlen++;\n            }\n            setDeferredSetLen(c,replylen,setlen);\n            lua_pop(lua,2);\n            return;\n        }\n        lua_pop(lua,1); /* Discard field name pushed before. */\n\n        /* Handle the array reply. */\n        void *replylen = addReplyDeferredLen(c);\n        int j = 1, mbulklen = 0;\n        while(1) {\n            /* we took care of the stack size on function start */\n            lua_pushnumber(lua,j++);\n            lua_gettable(lua,-2);\n            t = lua_type(lua,-1);\n            if (t == LUA_TNIL) {\n                lua_pop(lua,1);\n                break;\n            }\n            luaReplyToRedisReply(c, lua);\n            mbulklen++;\n        }\n        setDeferredArrayLen(c,replylen,mbulklen);\n        break;\n    default:\n        addReplyNull(c);\n    }\n    lua_pop(lua,1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,15 @@\n void luaReplyToRedisReply(client *c, lua_State *lua) {\n+\n+    if (!lua_checkstack(lua, 4)) {\n+        /* Increase the Lua stack if needed to make sure there is enough room\n+         * to push 4 elements to the stack. On failure, return error.\n+    * Notice that we need, in the worst case, 4 elements because returning a map might\n+         * require push 4 elements to the Lua stack.*/\n+        addReplyErrorFormat(c, \"reached lua stack limit\");\n+        lua_pop(lua,1); // pop the element from the stack\n+        return;\n+    }\n+\n     int t = lua_type(lua,-1);\n \n     switch(t) {\n@@ -22,6 +33,7 @@\n          * field. */\n \n         /* Handle error reply. */\n+        // we took care of the stack size on function start\n         lua_pushstring(lua,\"err\");\n         lua_gettable(lua,-2);\n         t = lua_type(lua,-1);\n@@ -67,6 +79,7 @@\n         if (t == LUA_TTABLE) {\n             int maplen = 0;\n             void *replylen = addReplyDeferredLen(c);\n+            /* we took care of the stack size on function start */\n             lua_pushnil(lua); /* Use nil to start iteration. */\n             while (lua_next(lua,-2)) {\n                 /* Stack now: table, key, value */\n@@ -89,6 +102,7 @@\n         if (t == LUA_TTABLE) {\n             int setlen = 0;\n             void *replylen = addReplyDeferredLen(c);\n+            /* we took care of the stack size on function start */\n             lua_pushnil(lua); /* Use nil to start iteration. */\n             while (lua_next(lua,-2)) {\n                 /* Stack now: table, key, true */\n@@ -108,6 +122,7 @@\n         void *replylen = addReplyDeferredLen(c);\n         int j = 1, mbulklen = 0;\n         while(1) {\n+            /* we took care of the stack size on function start */\n             lua_pushnumber(lua,j++);\n             lua_gettable(lua,-2);\n             t = lua_type(lua,-1);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (!lua_checkstack(lua, 4)) {",
                "        /* Increase the Lua stack if needed to make sure there is enough room",
                "         * to push 4 elements to the stack. On failure, return error.",
                "    * Notice that we need, in the worst case, 4 elements because returning a map might",
                "         * require push 4 elements to the Lua stack.*/",
                "        addReplyErrorFormat(c, \"reached lua stack limit\");",
                "        lua_pop(lua,1); // pop the element from the stack",
                "        return;",
                "    }",
                "",
                "        // we took care of the stack size on function start",
                "            /* we took care of the stack size on function start */",
                "            /* we took care of the stack size on function start */",
                "            /* we took care of the stack size on function start */"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32626",
        "func_name": "redis/redisProtocolToLuaType",
        "description": "Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",
        "git_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "commit_title": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}",
        "commit_text": " When LUA call our C code, by default, the LUA stack has room for 20 elements. In most cases, this is more than enough but sometimes it's not and the caller must verify the LUA stack size before he pushes elements.  On 3 places in the code, there was no verification of the LUA stack size. On specific inputs this missing verification could have lead to invalid memory write: 1. On 'luaReplyToRedisReply', one might return a nested reply that will    explode the LUA stack. 2. On 'redisProtocolToLuaType', the Redis reply might be deep enough  to explode the LUA stack (notice that currently there is no such  command in Redis that returns such a nested reply, but modules might  do it) 3. On 'ldbRedis', one might give a command with enough arguments to  explode the LUA stack (all the arguments will be pushed to the LUA  stack)  This commit is solving all those 3 issues by calling 'lua_checkstack' and verify that there is enough room in the LUA stack to push elements. In case 'lua_checkstack' returns an error (there is not enough room in the LUA stack and it's not possible to increase the stack), we will do the following: 1. On 'luaReplyToRedisReply', we will return an error to the user. 2. On 'redisProtocolToLuaType' we will exit with panic (we assume this    scenario is rare because it can only happen with a module). 3. On 'ldbRedis', we return an error.",
        "func_before": "char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n    char *p = reply;\n\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}",
        "func": "char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n\n    if (!lua_checkstack(lua, 5)) {\n        /*\n         * Increase the Lua stack if needed, to make sure there is enough room\n         * to push 5 elements to the stack. On failure, exit with panic.\n    * Notice that we need, in the worst case, 5 elements because redisProtocolToLuaType_Aggregate\n    * might push 5 elements to the Lua stack.*/\n        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n    }\n\n    char *p = reply;\n\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,14 @@\n char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n+\n+    if (!lua_checkstack(lua, 5)) {\n+        /*\n+         * Increase the Lua stack if needed, to make sure there is enough room\n+         * to push 5 elements to the stack. On failure, exit with panic.\n+    * Notice that we need, in the worst case, 5 elements because redisProtocolToLuaType_Aggregate\n+    * might push 5 elements to the Lua stack.*/\n+        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n+    }\n+\n     char *p = reply;\n \n     switch(*p) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (!lua_checkstack(lua, 5)) {",
                "        /*",
                "         * Increase the Lua stack if needed, to make sure there is enough room",
                "         * to push 5 elements to the stack. On failure, exit with panic.",
                "    * Notice that we need, in the worst case, 5 elements because redisProtocolToLuaType_Aggregate",
                "    * might push 5 elements to the Lua stack.*/",
                "        serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32626",
        "func_name": "redis/redisProtocolToLuaType_Aggregate",
        "description": "Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",
        "git_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "commit_title": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}",
        "commit_text": " When LUA call our C code, by default, the LUA stack has room for 20 elements. In most cases, this is more than enough but sometimes it's not and the caller must verify the LUA stack size before he pushes elements.  On 3 places in the code, there was no verification of the LUA stack size. On specific inputs this missing verification could have lead to invalid memory write: 1. On 'luaReplyToRedisReply', one might return a nested reply that will    explode the LUA stack. 2. On 'redisProtocolToLuaType', the Redis reply might be deep enough  to explode the LUA stack (notice that currently there is no such  command in Redis that returns such a nested reply, but modules might  do it) 3. On 'ldbRedis', one might give a command with enough arguments to  explode the LUA stack (all the arguments will be pushed to the LUA  stack)  This commit is solving all those 3 issues by calling 'lua_checkstack' and verify that there is enough room in the LUA stack to push elements. In case 'lua_checkstack' returns an error (there is not enough room in the LUA stack and it's not possible to increase the stack), we will do the following: 1. On 'luaReplyToRedisReply', we will return an error to the user. 2. On 'redisProtocolToLuaType' we will exit with panic (we assume this    scenario is rare because it can only happen with a module). 3. On 'ldbRedis', we return an error.",
        "func_before": "char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        /* Here we handle only Set and Map replies in RESP3 mode, since arrays\n         * follow the above RESP2 code path. Note that those are represented\n         * as a table with the \"map\" or \"set\" field populated with the actual\n         * table representing the set or the map type. */\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}",
        "func": "char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        /* Here we handle only Set and Map replies in RESP3 mode, since arrays\n         * follow the above RESP2 code path. Note that those are represented\n         * as a table with the \"map\" or \"set\" field populated with the actual\n         * table representing the set or the map type. */\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                if (!lua_checkstack(lua, 1)) {\n                    /* Notice that here we need to check the stack again because the recursive\n                     * call to redisProtocolToLuaType might have use the room allocated in the stack */\n                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n                }\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,11 @@\n             if (atype == '%') {\n                 p = redisProtocolToLuaType(lua,p);\n             } else {\n+                if (!lua_checkstack(lua, 1)) {\n+                    /* Notice that here we need to check the stack again because the recursive\n+                     * call to redisProtocolToLuaType might have use the room allocated in the stack */\n+                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n+                }\n                 lua_pushboolean(lua,1);\n             }\n             lua_settable(lua,-3);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                if (!lua_checkstack(lua, 1)) {",
                "                    /* Notice that here we need to check the stack again because the recursive",
                "                     * call to redisProtocolToLuaType might have use the room allocated in the stack */",
                "                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-23537",
        "func_name": "pjsip/pjproject/pj_stun_msg_decode",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. Buffer overread is possible when parsing a specially crafted STUN message with unknown attribute. The vulnerability affects applications that uses STUN including PJNATH and PJSUA-LIB. The patch is available as a commit in the master branch (2.13.1).",
        "git_url": "https://github.com/pjsip/pjproject/commit/d8440f4d711a654b511f50f79c0445b26f9dd1e1",
        "commit_title": "Merge pull request from GHSA-9pfh-r8x4-w26w",
        "commit_text": " * Fix buffer overread in STUN message decoder  * Updates based on comments",
        "func_before": "PJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n                                       const pj_uint8_t *pdu,\n                                       pj_size_t pdu_len,\n                                       unsigned options,\n                                       pj_stun_msg **p_msg,\n                                       pj_size_t *p_parsed_len,\n                                       pj_stun_msg **p_response)\n{\n    \n    pj_stun_msg *msg;\n    const pj_uint8_t *start_pdu = pdu;\n    pj_bool_t has_msg_int = PJ_FALSE;\n    pj_bool_t has_fingerprint = PJ_FALSE;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(options);\n\n    PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);\n\n    if (p_parsed_len)\n        *p_parsed_len = 0;\n    if (p_response)\n        *p_response = NULL;\n\n    /* Check if this is a STUN message, if necessary */\n    if (options & PJ_STUN_CHECK_PACKET) {\n        status = pj_stun_msg_check(pdu, pdu_len, options);\n        if (status != PJ_SUCCESS)\n            return status;\n    }\n\n    /* Create the message, copy the header, and convert to host byte order */\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));\n    msg->hdr.type = pj_ntohs(msg->hdr.type);\n    msg->hdr.length = pj_ntohs(msg->hdr.length);\n    msg->hdr.magic = pj_ntohl(msg->hdr.magic);\n\n    pdu += sizeof(pj_stun_msg_hdr);\n    /* pdu_len -= sizeof(pj_stun_msg_hdr); */\n    pdu_len = msg->hdr.length;\n\n    /* No need to create response if this is not a request */\n    if (!PJ_STUN_IS_REQUEST(msg->hdr.type))\n        p_response = NULL;\n\n    /* Parse attributes */\n    while (pdu_len >= 4) {\n        unsigned attr_type, attr_val_len;\n        const struct attr_desc *adesc;\n\n        /* Get attribute type and length. If length is not aligned\n         * to 4 bytes boundary, add padding.\n         */\n        attr_type = GETVAL16H(pdu, 0);\n        attr_val_len = GETVAL16H(pdu, 2);\n        attr_val_len = (attr_val_len + 3) & (~3);\n\n        /* Check length */\n        if (pdu_len < attr_val_len) {\n            pj_str_t err_msg;\n            char err_msg_buf[80];\n\n            err_msg.ptr = err_msg_buf;\n            err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),\n                                            \"Attribute %s has invalid length\",\n                                            pj_stun_get_attr_name(attr_type));\n\n            PJ_LOG(4,(THIS_FILE, \"Error decoding message: %.*s\",\n                      (int)err_msg.slen, err_msg.ptr));\n\n            if (p_response) {\n                pj_stun_msg_create_response(pool, msg, \n                                            PJ_STUN_SC_BAD_REQUEST, \n                                            &err_msg, p_response);\n            }\n            return PJNATH_ESTUNINATTRLEN;\n        }\n\n        /* Get the attribute descriptor */\n        adesc = find_attr_desc(attr_type);\n\n        if (adesc == NULL) {\n            /* Unrecognized attribute */\n            pj_stun_binary_attr *attr = NULL;\n\n            PJ_LOG(5,(THIS_FILE, \"Unrecognized attribute type 0x%x\", \n                      attr_type));\n\n            /* Is this a fatal condition? */\n            if (attr_type <= 0x7FFF) {\n                /* This is a mandatory attribute, we must return error\n                 * if we don't understand the attribute.\n                 */\n                if (p_response) {\n                    unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;\n\n                    status = pj_stun_msg_create_response(pool, msg,\n                                                         err_code, NULL, \n                                                         p_response);\n                    if (status==PJ_SUCCESS) {\n                        pj_uint16_t d = (pj_uint16_t)attr_type;\n                        pj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);\n                    }\n                }\n\n                return PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Create binary attribute to represent this */\n            status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, \n                                                GETVAL16H(pdu, 2), &attr);\n            if (status != PJ_SUCCESS) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing unknown STUN attribute type %d\",\n                          attr_type));\n\n                return status;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = &attr->hdr;\n\n        } else {\n            void *attr;\n            char err_msg1[PJ_ERR_MSG_SIZE],\n                 err_msg2[PJ_ERR_MSG_SIZE];\n\n            /* Parse the attribute */\n            status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);\n\n            if (status != PJ_SUCCESS) {\n                pj_strerror(status, err_msg1, sizeof(err_msg1));\n\n                if (p_response) {\n                    pj_str_t e;\n\n                    e.ptr = err_msg2;\n                    e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),\n                                             \"%s in %s\",\n                                             err_msg1,\n                                             pj_stun_get_attr_name(attr_type));\n                    if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))\n                        e.slen = sizeof(err_msg2) - 1;\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_BAD_REQUEST,\n                                                &e, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing STUN attribute %s: %s\",\n                          pj_stun_get_attr_name(attr_type), \n                          err_msg1));\n\n                return status;\n            }\n\n            if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && \n                !has_fingerprint) \n            {\n                if (has_msg_int) {\n                    /* Already has MESSAGE-INTEGRITY */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_msg_int = PJ_TRUE;\n\n            } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {\n                if (has_fingerprint) {\n                    /* Already has FINGERPRINT */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_fingerprint = PJ_TRUE;\n            } else {\n                if (has_fingerprint) {\n                    /* Another attribute is found which is not FINGERPRINT\n                     * after FINGERPRINT. Note that non-FINGERPRINT is\n                     * allowed to appear after M-I\n                     */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNFINGERPOS;\n                }\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;\n        }\n\n        /* Next attribute */\n        if (attr_val_len + 4 >= pdu_len) {\n            pdu += pdu_len;\n            pdu_len = 0;\n        } else {\n            pdu += (attr_val_len + 4);\n            pdu_len -= (attr_val_len + 4);\n        }\n    }\n\n    if (pdu_len > 0) {\n        /* Stray trailing bytes */\n        PJ_LOG(4,(THIS_FILE, \n                  \"Error decoding STUN message: unparsed trailing %d bytes\",\n                  pdu_len));\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    *p_msg = msg;\n\n    if (p_parsed_len)\n        *p_parsed_len = (pdu - start_pdu);\n\n    return PJ_SUCCESS;\n}",
        "func": "PJ_DEF(pj_status_t) pj_stun_msg_decode(pj_pool_t *pool,\n                                       const pj_uint8_t *pdu,\n                                       pj_size_t pdu_len,\n                                       unsigned options,\n                                       pj_stun_msg **p_msg,\n                                       pj_size_t *p_parsed_len,\n                                       pj_stun_msg **p_response)\n{\n    \n    pj_stun_msg *msg;\n    const pj_uint8_t *start_pdu = pdu;\n    pj_bool_t has_msg_int = PJ_FALSE;\n    pj_bool_t has_fingerprint = PJ_FALSE;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(options);\n\n    PJ_ASSERT_RETURN(pool && pdu && pdu_len && p_msg, PJ_EINVAL);\n    PJ_ASSERT_RETURN(sizeof(pj_stun_msg_hdr) == 20, PJ_EBUG);\n\n    if (p_parsed_len)\n        *p_parsed_len = 0;\n    if (p_response)\n        *p_response = NULL;\n\n    /* Check if this is a STUN message, if necessary */\n    if (options & PJ_STUN_CHECK_PACKET) {\n        status = pj_stun_msg_check(pdu, pdu_len, options);\n        if (status != PJ_SUCCESS)\n            return status;\n    } else {\n        /* For safety, verify packet length at least */\n        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;\n        if (msg_len > pdu_len ||\n            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))\n        {\n            return PJNATH_EINSTUNMSGLEN;\n        }\n    }\n\n    /* Create the message, copy the header, and convert to host byte order */\n    msg = PJ_POOL_ZALLOC_T(pool, pj_stun_msg);\n    pj_memcpy(&msg->hdr, pdu, sizeof(pj_stun_msg_hdr));\n    msg->hdr.type = pj_ntohs(msg->hdr.type);\n    msg->hdr.length = pj_ntohs(msg->hdr.length);\n    msg->hdr.magic = pj_ntohl(msg->hdr.magic);\n\n    pdu += sizeof(pj_stun_msg_hdr);\n    /* pdu_len -= sizeof(pj_stun_msg_hdr); */\n    pdu_len = msg->hdr.length;\n\n    /* No need to create response if this is not a request */\n    if (!PJ_STUN_IS_REQUEST(msg->hdr.type))\n        p_response = NULL;\n\n    /* Parse attributes */\n    while (pdu_len >= ATTR_HDR_LEN) {\n        unsigned attr_type, attr_val_len;\n        const struct attr_desc *adesc;\n\n        /* Get attribute type and length. If length is not aligned\n         * to 4 bytes boundary, add padding.\n         */\n        attr_type = GETVAL16H(pdu, 0);\n        attr_val_len = GETVAL16H(pdu, 2);\n        attr_val_len = (attr_val_len + 3) & (~3);\n\n        /* Check length */\n        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {\n            pj_str_t err_msg;\n            char err_msg_buf[80];\n\n            err_msg.ptr = err_msg_buf;\n            err_msg.slen = pj_ansi_snprintf(err_msg_buf, sizeof(err_msg_buf),\n                                            \"Attribute %s has invalid length\",\n                                            pj_stun_get_attr_name(attr_type));\n\n            PJ_LOG(4,(THIS_FILE, \"Error decoding message: %.*s\",\n                      (int)err_msg.slen, err_msg.ptr));\n\n            if (p_response) {\n                pj_stun_msg_create_response(pool, msg, \n                                            PJ_STUN_SC_BAD_REQUEST, \n                                            &err_msg, p_response);\n            }\n            return PJNATH_ESTUNINATTRLEN;\n        }\n\n        /* Get the attribute descriptor */\n        adesc = find_attr_desc(attr_type);\n\n        if (adesc == NULL) {\n            /* Unrecognized attribute */\n            pj_stun_binary_attr *attr = NULL;\n\n            PJ_LOG(5,(THIS_FILE, \"Unrecognized attribute type 0x%x\", \n                      attr_type));\n\n            /* Is this a fatal condition? */\n            if (attr_type <= 0x7FFF) {\n                /* This is a mandatory attribute, we must return error\n                 * if we don't understand the attribute.\n                 */\n                if (p_response) {\n                    unsigned err_code = PJ_STUN_SC_UNKNOWN_ATTRIBUTE;\n\n                    status = pj_stun_msg_create_response(pool, msg,\n                                                         err_code, NULL, \n                                                         p_response);\n                    if (status==PJ_SUCCESS) {\n                        pj_uint16_t d = (pj_uint16_t)attr_type;\n                        pj_stun_msg_add_unknown_attr(pool, *p_response, 1, &d);\n                    }\n                }\n\n                return PJ_STATUS_FROM_STUN_CODE(PJ_STUN_SC_UNKNOWN_ATTRIBUTE);\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Create binary attribute to represent this */\n            status = pj_stun_binary_attr_create(pool, attr_type, pdu+4, \n                                                GETVAL16H(pdu, 2), &attr);\n            if (status != PJ_SUCCESS) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing unknown STUN attribute type %d\",\n                          attr_type));\n\n                return status;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = &attr->hdr;\n\n        } else {\n            void *attr;\n            char err_msg1[PJ_ERR_MSG_SIZE],\n                 err_msg2[PJ_ERR_MSG_SIZE];\n\n            /* Parse the attribute */\n            status = (adesc->decode_attr)(pool, pdu, &msg->hdr, &attr);\n\n            if (status != PJ_SUCCESS) {\n                pj_strerror(status, err_msg1, sizeof(err_msg1));\n\n                if (p_response) {\n                    pj_str_t e;\n\n                    e.ptr = err_msg2;\n                    e.slen= pj_ansi_snprintf(err_msg2, sizeof(err_msg2),\n                                             \"%s in %s\",\n                                             err_msg1,\n                                             pj_stun_get_attr_name(attr_type));\n                    if (e.slen < 1 || e.slen >= (int)sizeof(err_msg2))\n                        e.slen = sizeof(err_msg2) - 1;\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_BAD_REQUEST,\n                                                &e, p_response);\n                }\n\n                PJ_LOG(4,(THIS_FILE, \n                          \"Error parsing STUN attribute %s: %s\",\n                          pj_stun_get_attr_name(attr_type), \n                          err_msg1));\n\n                return status;\n            }\n\n            if (attr_type == PJ_STUN_ATTR_MESSAGE_INTEGRITY && \n                !has_fingerprint) \n            {\n                if (has_msg_int) {\n                    /* Already has MESSAGE-INTEGRITY */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_msg_int = PJ_TRUE;\n\n            } else if (attr_type == PJ_STUN_ATTR_FINGERPRINT) {\n                if (has_fingerprint) {\n                    /* Already has FINGERPRINT */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNDUPATTR;\n                }\n                has_fingerprint = PJ_TRUE;\n            } else {\n                if (has_fingerprint) {\n                    /* Another attribute is found which is not FINGERPRINT\n                     * after FINGERPRINT. Note that non-FINGERPRINT is\n                     * allowed to appear after M-I\n                     */\n                    if (p_response) {\n                        pj_stun_msg_create_response(pool, msg,\n                                                    PJ_STUN_SC_BAD_REQUEST,\n                                                    NULL, p_response);\n                    }\n                    return PJNATH_ESTUNFINGERPOS;\n                }\n            }\n\n            /* Make sure we have rooms for the new attribute */\n            if (msg->attr_count >= PJ_STUN_MAX_ATTR) {\n                if (p_response) {\n                    pj_stun_msg_create_response(pool, msg,\n                                                PJ_STUN_SC_SERVER_ERROR,\n                                                NULL, p_response);\n                }\n                return PJNATH_ESTUNTOOMANYATTR;\n            }\n\n            /* Add the attribute */\n            msg->attr[msg->attr_count++] = (pj_stun_attr_hdr*)attr;\n        }\n\n        /* Next attribute */\n        if (attr_val_len + 4 >= pdu_len) {\n            pdu += pdu_len;\n            pdu_len = 0;\n        } else {\n            pdu += (attr_val_len + 4);\n            pdu_len -= (attr_val_len + 4);\n        }\n    }\n\n    if (pdu_len > 0) {\n        /* Stray trailing bytes */\n        PJ_LOG(4,(THIS_FILE, \n                  \"Error decoding STUN message: unparsed trailing %d bytes\",\n                  pdu_len));\n        return PJNATH_EINSTUNMSGLEN;\n    }\n\n    *p_msg = msg;\n\n    if (p_parsed_len)\n        *p_parsed_len = (pdu - start_pdu);\n\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,14 @@\n         status = pj_stun_msg_check(pdu, pdu_len, options);\n         if (status != PJ_SUCCESS)\n             return status;\n+    } else {\n+        /* For safety, verify packet length at least */\n+        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;\n+        if (msg_len > pdu_len ||\n+            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))\n+        {\n+            return PJNATH_EINSTUNMSGLEN;\n+        }\n     }\n \n     /* Create the message, copy the header, and convert to host byte order */\n@@ -46,7 +54,7 @@\n         p_response = NULL;\n \n     /* Parse attributes */\n-    while (pdu_len >= 4) {\n+    while (pdu_len >= ATTR_HDR_LEN) {\n         unsigned attr_type, attr_val_len;\n         const struct attr_desc *adesc;\n \n@@ -58,7 +66,7 @@\n         attr_val_len = (attr_val_len + 3) & (~3);\n \n         /* Check length */\n-        if (pdu_len < attr_val_len) {\n+        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {\n             pj_str_t err_msg;\n             char err_msg_buf[80];\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    while (pdu_len >= 4) {",
                "        if (pdu_len < attr_val_len) {"
            ],
            "added_lines": [
                "    } else {",
                "        /* For safety, verify packet length at least */",
                "        pj_uint32_t msg_len = GETVAL16H(pdu, 2) + 20;",
                "        if (msg_len > pdu_len ||",
                "            ((options & PJ_STUN_IS_DATAGRAM) && msg_len != pdu_len))",
                "        {",
                "            return PJNATH_EINSTUNMSGLEN;",
                "        }",
                "    while (pdu_len >= ATTR_HDR_LEN) {",
                "        if (pdu_len < attr_val_len + ATTR_HDR_LEN) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-23547",
        "func_name": "pjsip/pjproject/decode_uint_attr",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. This issue is similar to GHSA-9pfh-r8x4-w26w. Possible buffer overread when parsing a certain STUN message. The vulnerability affects applications that uses STUN including PJNATH and PJSUA-LIB. The patch is available as commit in the master branch.",
        "git_url": "https://github.com/pjsip/pjproject/commit/bc4812d31a67d5e2f973fbfaf950d6118226cf36",
        "commit_title": "Merge pull request from GHSA-cxwq-5g9x-x7fr",
        "commit_text": " * Fixed heap buffer overflow when parsing STUN errcode attribute  * Also fixed uint parsing",
        "func_before": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->value = GETVAL32H(buf, 4);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}",
        "func": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    attr->value = GETVAL32H(buf, 4);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,11 +11,11 @@\n     attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n     GETATTRHDR(buf, &attr->hdr);\n \n-    attr->value = GETVAL32H(buf, 4);\n-\n     /* Check that the attribute length is valid */\n     if (attr->hdr.length != 4)\n         return PJNATH_ESTUNINATTRLEN;\n+\n+    attr->value = GETVAL32H(buf, 4);\n \n     /* Done */\n     *p_attr = attr;",
        "diff_line_info": {
            "deleted_lines": [
                "    attr->value = GETVAL32H(buf, 4);",
                ""
            ],
            "added_lines": [
                "",
                "    attr->value = GETVAL32H(buf, 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-23547",
        "func_name": "pjsip/pjproject/decode_errcode_attr",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. This issue is similar to GHSA-9pfh-r8x4-w26w. Possible buffer overread when parsing a certain STUN message. The vulnerability affects applications that uses STUN including PJNATH and PJSUA-LIB. The patch is available as commit in the master branch.",
        "git_url": "https://github.com/pjsip/pjproject/commit/bc4812d31a67d5e2f973fbfaf950d6118226cf36",
        "commit_title": "Merge pull request from GHSA-cxwq-5g9x-x7fr",
        "commit_text": " * Fixed heap buffer overflow when parsing STUN errcode attribute  * Also fixed uint parsing",
        "func_before": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    /* Make sure the length is never negative */\n    if (value.slen < 0)\n        value.slen = 0;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}",
        "func": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    /* Check that the attribute length is valid */\n    if (attr->hdr.length < 4)\n        return PJNATH_ESTUNINATTRLEN;\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,14 +12,15 @@\n     attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n     GETATTRHDR(buf, &attr->hdr);\n \n+    /* Check that the attribute length is valid */\n+    if (attr->hdr.length < 4)\n+        return PJNATH_ESTUNINATTRLEN;\n+\n     attr->err_code = buf[6] * 100 + buf[7];\n \n     /* Get pointer to the string in the message */\n     value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n     value.slen = attr->hdr.length - 4;\n-    /* Make sure the length is never negative */\n-    if (value.slen < 0)\n-        value.slen = 0;\n \n     /* Copy the string to the attribute */\n     pj_strdup(pool, &attr->reason, &value);",
        "diff_line_info": {
            "deleted_lines": [
                "    /* Make sure the length is never negative */",
                "    if (value.slen < 0)",
                "        value.slen = 0;"
            ],
            "added_lines": [
                "    /* Check that the attribute length is valid */",
                "    if (attr->hdr.length < 4)",
                "        return PJNATH_ESTUNINATTRLEN;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0051",
        "func_name": "vim/msg_puts_printf",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1144.",
        "git_url": "https://github.com/vim/vim/commit/c32949b0779106ed5710ae3bffc5053e49083ab4",
        "commit_title": "patch 9.0.1144: reading beyond text",
        "commit_text": " Problem:    Reading beyond text. Solution:   Add strlen_maxlen() and use it.",
        "func_before": "static void\nmsg_puts_printf(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    char_u\t*buf = NULL;\n    char_u\t*p = s;\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_COOK);\t// handle CR and NL correctly\n#endif\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\tif (!(silent_mode && p_verbose == 0))\n\t{\n\t    // NL --> CR NL translation (for Unix, not for \"--version\")\n\t    if (*s == NL)\n\t    {\n\t\tint n = (int)(s - p);\n\n\t\tbuf = alloc(n + 3);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    memcpy(buf, p, n);\n\t\t    if (!info_message)\n\t\t\tbuf[n++] = CAR;\n\t\t    buf[n++] = NL;\n\t\t    buf[n++] = NUL;\n\t\t    if (info_message)   // informative message, not an error\n\t\t\tmch_msg((char *)buf);\n\t\t    else\n\t\t\tmch_errmsg((char *)buf);\n\t\t    vim_free(buf);\n\t\t}\n\t\tp = s + 1;\n\t    }\n\t}\n\n\t// primitive way to compute the current column\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = Columns - 1;\n\t    else\n\t\t--msg_col;\n\t}\n\telse\n#endif\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = 0;\n\t    else\n\t\t++msg_col;\n\t}\n\t++s;\n    }\n\n    if (*p != NUL && !(silent_mode && p_verbose == 0))\n    {\n\tchar_u *tofree = NULL;\n\n\tif (maxlen > 0 && STRLEN(p) > (size_t)maxlen)\n\t{\n\t    tofree = vim_strnsave(p, (size_t)maxlen);\n\t    p = tofree;\n\t}\n\tif (p != NULL)\n\t{\n\t    if (info_message)\n\t\tmch_msg((char *)p);\n\t    else\n\t\tmch_errmsg((char *)p);\n\t    vim_free(tofree);\n\t}\n    }\n\n    msg_didout = TRUE;\t    // assume that line is not empty\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_RAW);\n#endif\n}",
        "func": "static void\nmsg_puts_printf(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    char_u\t*buf = NULL;\n    char_u\t*p = s;\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_COOK);\t// handle CR and NL correctly\n#endif\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\tif (!(silent_mode && p_verbose == 0))\n\t{\n\t    // NL --> CR NL translation (for Unix, not for \"--version\")\n\t    if (*s == NL)\n\t    {\n\t\tint n = (int)(s - p);\n\n\t\tbuf = alloc(n + 3);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    memcpy(buf, p, n);\n\t\t    if (!info_message)\n\t\t\tbuf[n++] = CAR;\n\t\t    buf[n++] = NL;\n\t\t    buf[n++] = NUL;\n\t\t    if (info_message)   // informative message, not an error\n\t\t\tmch_msg((char *)buf);\n\t\t    else\n\t\t\tmch_errmsg((char *)buf);\n\t\t    vim_free(buf);\n\t\t}\n\t\tp = s + 1;\n\t    }\n\t}\n\n\t// primitive way to compute the current column\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = Columns - 1;\n\t    else\n\t\t--msg_col;\n\t}\n\telse\n#endif\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = 0;\n\t    else\n\t\t++msg_col;\n\t}\n\t++s;\n    }\n\n    if (*p != NUL && !(silent_mode && p_verbose == 0))\n    {\n\tchar_u *tofree = NULL;\n\n\tif (maxlen > 0 && vim_strlen_maxlen((char *)p, (size_t)maxlen)\n\t\t\t\t\t\t\t     >= (size_t)maxlen)\n\t{\n\t    tofree = vim_strnsave(p, (size_t)maxlen);\n\t    p = tofree;\n\t}\n\tif (p != NULL)\n\t{\n\t    if (info_message)\n\t\tmch_msg((char *)p);\n\t    else\n\t\tmch_errmsg((char *)p);\n\t    vim_free(tofree);\n\t}\n    }\n\n    msg_didout = TRUE;\t    // assume that line is not empty\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_RAW);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,7 +60,8 @@\n     {\n \tchar_u *tofree = NULL;\n \n-\tif (maxlen > 0 && STRLEN(p) > (size_t)maxlen)\n+\tif (maxlen > 0 && vim_strlen_maxlen((char *)p, (size_t)maxlen)\n+\t\t\t\t\t\t\t     >= (size_t)maxlen)\n \t{\n \t    tofree = vim_strnsave(p, (size_t)maxlen);\n \t    p = tofree;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (maxlen > 0 && STRLEN(p) > (size_t)maxlen)"
            ],
            "added_lines": [
                "\tif (maxlen > 0 && vim_strlen_maxlen((char *)p, (size_t)maxlen)",
                "\t\t\t\t\t\t\t     >= (size_t)maxlen)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0051",
        "func_name": "vim/vim_strchr",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1144.",
        "git_url": "https://github.com/vim/vim/commit/c32949b0779106ed5710ae3bffc5053e49083ab4",
        "commit_title": "patch 9.0.1144: reading beyond text",
        "commit_text": " Problem:    Reading beyond text. Solution:   Add strlen_maxlen() and use it.",
        "func_before": "char_u  *\nvim_strchr(char_u *string, int c)\n{\n    char_u\t*p;\n    int\t\tb;\n\n    p = string;\n    if (enc_utf8 && c >= 0x80)\n    {\n\twhile (*p != NUL)\n\t{\n\t    int l = utfc_ptr2len(p);\n\n\t    // Avoid matching an illegal byte here.\n\t    if (utf_ptr2char(p) == c && l > 1)\n\t\treturn p;\n\t    p += l;\n\t}\n\treturn NULL;\n    }\n    if (enc_dbcs != 0 && c > 255)\n    {\n\tint\tn2 = c & 0xff;\n\n\tc = ((unsigned)c >> 8) & 0xff;\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c && p[1] == n2)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    if (has_mbyte)\n    {\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    while ((b = *p) != NUL)\n    {\n\tif (b == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}",
        "func": "char_u *\nvim_strchr(char_u *string, int c)\n{\n    char_u\t*p;\n    int\t\tb;\n\n    p = string;\n    if (enc_utf8 && c >= 0x80)\n    {\n\twhile (*p != NUL)\n\t{\n\t    int l = utfc_ptr2len(p);\n\n\t    // Avoid matching an illegal byte here.\n\t    if (utf_ptr2char(p) == c && l > 1)\n\t\treturn p;\n\t    p += l;\n\t}\n\treturn NULL;\n    }\n    if (enc_dbcs != 0 && c > 255)\n    {\n\tint\tn2 = c & 0xff;\n\n\tc = ((unsigned)c >> 8) & 0xff;\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c && p[1] == n2)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    if (has_mbyte)\n    {\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    while ((b = *p) != NUL)\n    {\n\tif (b == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-char_u  *\n+char_u *\n vim_strchr(char_u *string, int c)\n {\n     char_u\t*p;",
        "diff_line_info": {
            "deleted_lines": [
                "char_u  *"
            ],
            "added_lines": [
                "char_u *"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0288",
        "func_name": "vim/nv_scroll",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1189.",
        "git_url": "https://github.com/vim/vim/commit/232bdaaca98c34a99ffadf27bf6ee08be6cc8f6a",
        "commit_title": "patch 9.0.1189: invalid memory access with folding and using \"L\"",
        "commit_text": " Problem:    Invalid memory access with folding and using \"L\". Solution:   Prevent the cursor from moving to line zero.",
        "func_before": "static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    --curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}",
        "func": "static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    if (curwin->w_cursor.lnum > curwin->w_topline)\n\t\t\t--curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,8 @@\n \t\t{\n \t\t    (void)hasFolding(curwin->w_cursor.lnum,\n \t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n-\t\t    --curwin->w_cursor.lnum;\n+\t\t    if (curwin->w_cursor.lnum > curwin->w_topline)\n+\t\t\t--curwin->w_cursor.lnum;\n \t\t}\n \t    }\n \t    else",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    --curwin->w_cursor.lnum;"
            ],
            "added_lines": [
                "\t\t    if (curwin->w_cursor.lnum > curwin->w_topline)",
                "\t\t\t--curwin->w_cursor.lnum;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0433",
        "func_name": "vim/same_leader",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1225.",
        "git_url": "https://github.com/vim/vim/commit/11977f917506d950b7e0cae558bd9189260b253b",
        "commit_title": "patch 9.0.1225: reading past the end of a line when formatting text",
        "commit_text": " Problem:    Reading past the end of a line when formatting text. Solution:   Check for not going over the end of the line.",
        "func_before": "static int\nsame_leader(\n    linenr_T lnum,\n    int\t    leader1_len,\n    char_u  *leader1_flags,\n    int\t    leader2_len,\n    char_u  *leader2_flags)\n{\n    int\t    idx1 = 0, idx2 = 0;\n    char_u  *p;\n    char_u  *line1;\n    char_u  *line2;\n\n    if (leader1_len == 0)\n\treturn (leader2_len == 0);\n\n    // If first leader has 'f' flag, the lines can be joined only if the\n    // second line does not have a leader.\n    // If first leader has 'e' flag, the lines can never be joined.\n    // If first leader has 's' flag, the lines can only be joined if there is\n    // some text after it and the second line has the 'm' flag.\n    if (leader1_flags != NULL)\n    {\n\tfor (p = leader1_flags; *p && *p != ':'; ++p)\n\t{\n\t    if (*p == COM_FIRST)\n\t\treturn (leader2_len == 0);\n\t    if (*p == COM_END)\n\t\treturn FALSE;\n\t    if (*p == COM_START)\n\t    {\n\t\tif (*(ml_get(lnum) + leader1_len) == NUL)\n\t\t    return FALSE;\n\t\tif (leader2_flags == NULL || leader2_len == 0)\n\t\t    return FALSE;\n\t\tfor (p = leader2_flags; *p && *p != ':'; ++p)\n\t\t    if (*p == COM_MIDDLE)\n\t\t\treturn TRUE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // Get current line and next line, compare the leaders.\n    // The first line has to be saved, only one line can be locked at a time.\n    line1 = vim_strsave(ml_get(lnum));\n    if (line1 != NULL)\n    {\n\tfor (idx1 = 0; VIM_ISWHITE(line1[idx1]); ++idx1)\n\t    ;\n\tline2 = ml_get(lnum + 1);\n\tfor (idx2 = 0; idx2 < leader2_len; ++idx2)\n\t{\n\t    if (!VIM_ISWHITE(line2[idx2]))\n\t    {\n\t\tif (line1[idx1++] != line2[idx2])\n\t\t    break;\n\t    }\n\t    else\n\t\twhile (VIM_ISWHITE(line1[idx1]))\n\t\t    ++idx1;\n\t}\n\tvim_free(line1);\n    }\n    return (idx2 == leader2_len && idx1 == leader1_len);\n}",
        "func": "static int\nsame_leader(\n    linenr_T lnum,\n    int\t    leader1_len,\n    char_u  *leader1_flags,\n    int\t    leader2_len,\n    char_u  *leader2_flags)\n{\n    int\t    idx1 = 0, idx2 = 0;\n    char_u  *p;\n    char_u  *line1;\n    char_u  *line2;\n\n    if (leader1_len == 0)\n\treturn (leader2_len == 0);\n\n    char_u  *lnum_line = NULL;\n    int\t    line_len = 0;\n\n    // If first leader has 'f' flag, the lines can be joined only if the\n    // second line does not have a leader.\n    // If first leader has 'e' flag, the lines can never be joined.\n    // If first leader has 's' flag, the lines can only be joined if there is\n    // some text after it and the second line has the 'm' flag.\n    if (leader1_flags != NULL)\n    {\n\tfor (p = leader1_flags; *p && *p != ':'; ++p)\n\t{\n\t    if (*p == COM_FIRST)\n\t\treturn (leader2_len == 0);\n\t    if (*p == COM_END)\n\t\treturn FALSE;\n\t    if (*p == COM_START)\n\t    {\n\t\tif (lnum_line == NULL)\n\t\t{\n\t\t    lnum_line = ml_get(lnum);\n\t\t    line_len = (int)STRLEN(lnum_line);\n\t\t}\n\t\tif (line_len <= leader1_len)\n\t\t    return FALSE;\n\t\tif (leader2_flags == NULL || leader2_len == 0)\n\t\t    return FALSE;\n\t\tfor (p = leader2_flags; *p && *p != ':'; ++p)\n\t\t    if (*p == COM_MIDDLE)\n\t\t\treturn TRUE;\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n\n    // Get current line and next line, compare the leaders.\n    // The first line has to be saved, only one line can be locked at a time.\n    line1 = vim_strsave(ml_get(lnum));\n    if (line1 != NULL)\n    {\n\tfor (idx1 = 0; VIM_ISWHITE(line1[idx1]); ++idx1)\n\t    ;\n\tline2 = ml_get(lnum + 1);\n\tfor (idx2 = 0; idx2 < leader2_len; ++idx2)\n\t{\n\t    if (!VIM_ISWHITE(line2[idx2]))\n\t    {\n\t\tif (line1[idx1++] != line2[idx2])\n\t\t    break;\n\t    }\n\t    else\n\t\twhile (VIM_ISWHITE(line1[idx1]))\n\t\t    ++idx1;\n\t}\n\tvim_free(line1);\n    }\n    return (idx2 == leader2_len && idx1 == leader1_len);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,9 @@\n     if (leader1_len == 0)\n \treturn (leader2_len == 0);\n \n+    char_u  *lnum_line = NULL;\n+    int\t    line_len = 0;\n+\n     // If first leader has 'f' flag, the lines can be joined only if the\n     // second line does not have a leader.\n     // If first leader has 'e' flag, the lines can never be joined.\n@@ -29,7 +32,12 @@\n \t\treturn FALSE;\n \t    if (*p == COM_START)\n \t    {\n-\t\tif (*(ml_get(lnum) + leader1_len) == NUL)\n+\t\tif (lnum_line == NULL)\n+\t\t{\n+\t\t    lnum_line = ml_get(lnum);\n+\t\t    line_len = (int)STRLEN(lnum_line);\n+\t\t}\n+\t\tif (line_len <= leader1_len)\n \t\t    return FALSE;\n \t\tif (leader2_flags == NULL || leader2_len == 0)\n \t\t    return FALSE;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (*(ml_get(lnum) + leader1_len) == NUL)"
            ],
            "added_lines": [
                "    char_u  *lnum_line = NULL;",
                "    int\t    line_len = 0;",
                "",
                "\t\tif (lnum_line == NULL)",
                "\t\t{",
                "\t\t    lnum_line = ml_get(lnum);",
                "\t\t    line_len = (int)STRLEN(lnum_line);",
                "\t\t}",
                "\t\tif (line_len <= leader1_len)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0760",
        "func_name": "gpac/video_sample_entry_box_size",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe",
        "commit_title": "sgpd box entry: disallow null grouping_type (#2389)",
        "commit_text": "",
        "func_before": "GF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\t/*make sure we write the config box first, we don't care about the rest*/\n\n\t/*mp4v*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\t/*avc / SVC + MVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\t\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}",
        "func": "GF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\n\t/*make sure we write the config box first, we don't care about the rest*/\n\n\t/*mp4v*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\t/*avc / SVC + MVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n \n \t/*VVC*/\n \tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n-\t\n+\n \t/*AV1*/\n \tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0760",
        "func_name": "gpac/dac3_box_write",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe",
        "commit_title": "sgpd box entry: disallow null grouping_type (#2389)",
        "commit_text": "",
        "func_before": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\t\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}",
        "func": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \te = gf_isom_box_write_header(s, bs);\n \tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n \tif (e) return e;\n-\t\n+\n \te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n \tif (e) return e;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0760",
        "func_name": "gpac/sgpd_parse_entry",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe",
        "commit_title": "sgpd box entry: disallow null grouping_type (#2389)",
        "commit_text": "",
        "func_before": "static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\tGF_DefaultSampleGroupDescriptionEntry *def_ptr;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tif (bytes_in_box<3) return NULL;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tBool use_mkey = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tbytes_in_box -= 3;\n\t\tif (use_mkey) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tu32 i, count = gf_bs_read_u16(bs);\n\t\t\tbytes_in_box -= 2;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 ivsize = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_skip_bytes(bs, 16);\n\t\t\t\tbytes_in_box -= 17;\n\t\t\t\tif (!ivsize) {\n\t\t\t\t\t//const IV\n\t\t\t\t\tivsize = gf_bs_read_u8(bs);\n\t\t\t\t\tgf_bs_skip_bytes(bs, ivsize);\n\t\t\t\t\tbytes_in_box -= 1 + ivsize;\n\t\t\t\t}\n\t\t\t\tif (bytes_in_box<0) {\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\tptr->key_info[0] = 1;\n\t\t\tgf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);\n\t\t\t*total_bytes = 3 + ptr->key_info_size - 1;\n\n\t\t\tif (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {\n\t\t\t\tgf_free(ptr->key_info);\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbin128 kid;\n\t\t\tu8 const_iv_size = 0;\n\t\t\tu8 iv_size = gf_bs_read_u8(bs);\n\t\t\tgf_bs_read_data(bs, kid, 16);\n\t\t\tbytes_in_box -= 17;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*total_bytes = 20;\n\t\t\tif ((ptr->IsProtected == 1) && !iv_size) {\n\t\t\t\tconst_iv_size = gf_bs_read_u8(bs);\n\t\t\t\tif ((const_iv_size != 8) && (const_iv_size != 16)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 20;\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info_size += 1 + const_iv_size;\n\t\t\t}\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr->key_info[0] = 0;\n\t\t\tptr->key_info[1] = 0;\n\t\t\tptr->key_info[2] = 0;\n\t\t\tptr->key_info[3] = iv_size;\n\t\t\tmemcpy(ptr->key_info+4, kid, 16);\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info[20] = const_iv_size;\n\t\t\t\tgf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);\n\t\t\t\t*total_bytes += 1 + const_iv_size;\n\t\t\t}\n\t\t}\n\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + (large_size ? 2 : 1);\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);\n\t\tptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);\n\t\t*total_bytes = 2;\n\t\tptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);\n\t\tif (!ptr->subp_track_ref_idx) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->num_subpic_ref_idx; i++) {\n\t\t\tptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\tif (ptr->subpic_id_info_flag) {\n\t\t\tptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);\n\t\t\tptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);\n\t\t\tptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);\n\t\t\tptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ptr->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 6);\n\t\t\t} else {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 4);\n\t\t\t\tgf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\t*total_bytes += 3;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->groupID_info_4cc = gf_bs_read_u32(bs);\n\t\tptr->nb_entries = 1 + gf_bs_read_u16(bs);\n\t\t*total_bytes = 6;\n\t\tptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);\n\t\tif (!ptr->groupIDs) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tptr->groupIDs[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\treturn ptr;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!def_ptr) return NULL;\n\tif (entry_size) {\n\t\tdef_ptr->length = entry_size;\n\t\tdef_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);\n\t\tif (!def_ptr->data) {\n\t\t\tgf_free(def_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn def_ptr;\n}",
        "func": "static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\tGF_DefaultSampleGroupDescriptionEntry *def_ptr;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tif (bytes_in_box<3) return NULL;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tBool use_mkey = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tbytes_in_box -= 3;\n\t\tif (use_mkey) {\n\t\t\tu64 pos = gf_bs_get_position(bs);\n\t\t\tu32 i, count = gf_bs_read_u16(bs);\n\t\t\tbytes_in_box -= 2;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 ivsize = gf_bs_read_u8(bs);\n\t\t\t\tgf_bs_skip_bytes(bs, 16);\n\t\t\t\tbytes_in_box -= 17;\n\t\t\t\tif (!ivsize) {\n\t\t\t\t\t//const IV\n\t\t\t\t\tivsize = gf_bs_read_u8(bs);\n\t\t\t\t\tgf_bs_skip_bytes(bs, ivsize);\n\t\t\t\t\tbytes_in_box -= 1 + ivsize;\n\t\t\t\t}\n\t\t\t\tif (bytes_in_box<0) {\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos);\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\tptr->key_info[0] = 1;\n\t\t\tgf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1);\n\t\t\t*total_bytes = 3 + ptr->key_info_size - 1;\n\n\t\t\tif (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) {\n\t\t\t\tgf_free(ptr->key_info);\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbin128 kid;\n\t\t\tu8 const_iv_size = 0;\n\t\t\tu8 iv_size = gf_bs_read_u8(bs);\n\t\t\tgf_bs_read_data(bs, kid, 16);\n\t\t\tbytes_in_box -= 17;\n\t\t\tif (bytes_in_box<0) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t*total_bytes = 20;\n\t\t\tif ((ptr->IsProtected == 1) && !iv_size) {\n\t\t\t\tconst_iv_size = gf_bs_read_u8(bs);\n\t\t\t\tif ((const_iv_size != 8) && (const_iv_size != 16)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\t\tgf_free(ptr);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tptr->key_info_size = 20;\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info_size += 1 + const_iv_size;\n\t\t\t}\n\t\t\tptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size);\n\t\t\tif (!ptr->key_info) {\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr->key_info[0] = 0;\n\t\t\tptr->key_info[1] = 0;\n\t\t\tptr->key_info[2] = 0;\n\t\t\tptr->key_info[3] = iv_size;\n\t\t\tmemcpy(ptr->key_info+4, kid, 16);\n\t\t\tif (!iv_size && ptr->IsProtected) {\n\t\t\t\tptr->key_info[20] = const_iv_size;\n\t\t\t\tgf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size);\n\t\t\t\t*total_bytes += 1 + const_iv_size;\n\t\t\t}\n\t\t}\n\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + (large_size ? 2 : 1);\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_SPOR:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureOrderEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureOrderEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->subpic_id_info_flag = gf_bs_read_int(bs, 1);\n\t\tptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15);\n\t\t*total_bytes = 2;\n\t\tptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx);\n\t\tif (!ptr->subp_track_ref_idx) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->num_subpic_ref_idx; i++) {\n\t\t\tptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\tif (ptr->subpic_id_info_flag) {\n\t\t\tptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4);\n\t\t\tptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12);\n\t\t\tptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1);\n\t\t\tptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1);\n\t\t\tif (ptr->spinfo.pps_sps_subpic_id_flag) {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 6);\n\t\t\t} else {\n\t\t\t\tptr->spinfo.xps_id = gf_bs_read_int(bs, 4);\n\t\t\t\tgf_bs_read_int(bs, 2);\n\t\t\t}\n\t\t\t*total_bytes += 3;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SULM:\n\t{\n\t\tu32 i;\n\t\tGF_SubpictureLayoutMapEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->groupID_info_4cc = gf_bs_read_u32(bs);\n\t\tptr->nb_entries = 1 + gf_bs_read_u16(bs);\n\t\t*total_bytes = 6;\n\t\tptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries);\n\t\tif (!ptr->groupIDs) {\n\t\t\tgf_free(ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tptr->groupIDs[i] = gf_bs_read_u16(bs);\n\t\t\t*total_bytes += 2;\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase 0:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\") );\n\t\treturn NULL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!def_ptr) return NULL;\n\tif (entry_size) {\n\t\tdef_ptr->length = entry_size;\n\t\tdef_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length);\n\t\tif (!def_ptr->data) {\n\t\t\tgf_free(def_ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tgf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn def_ptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -272,6 +272,9 @@\n \t\t}\n \t\treturn ptr;\n \t}\n+\tcase 0:\n+\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\") );\n+\t\treturn NULL;\n \tdefault:\n \t\tbreak;\n \t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcase 0:",
                "\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] sgpd entry null grouping_type is invalid\\n\") );",
                "\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0760",
        "func_name": "gpac/gf_isom_get_sample_for_media_time",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe",
        "commit_title": "sgpd box entry: disallow null grouping_type (#2389)",
        "commit_text": "",
        "func_before": "GF_EXPORT\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}",
        "func": "GF_EXPORT\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -164,6 +164,6 @@\n \t}\n \tif (static_sample && ! (*sample)->alloc_size )\n \t\t (*sample)->alloc_size =  (*sample)->dataLength;\n-\t\t \n+\n \treturn GF_OK;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t "
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0760",
        "func_name": "gpac/gf_isom_get_track_switch_parameter",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe",
        "commit_title": "sgpd box entry: disallow null grouping_type (#2389)",
        "commit_text": "",
        "func_before": "GF_EXPORT\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}",
        "func": "GF_EXPORT\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \tif (!map) return NULL;\n \ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n \tif (!tsel) return NULL;\n-\t\n+\n \t*switchGroupID = tsel->switchGroup;\n \t*criteriaListSize = tsel->attributeListCount;\n \treturn (const u32 *) tsel->attributeList;",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0760",
        "func_name": "gpac/gf_isom_get_sample_cenc_info_internal",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe",
        "commit_title": "sgpd box entry: disallow null grouping_type (#2389)",
        "commit_text": "",
        "func_before": "GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#else\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#endif\n{\n\tGF_SampleGroupBox *sample_group;\n\tu32 j, group_desc_index;\n\tGF_SampleGroupDescriptionBox *sgdesc;\n\tu32 i, count;\n\tu32 descIndex, chunkNum;\n\tu64 offset;\n\tu32 first_sample_in_entry, last_sample_in_entry;\n\tGF_CENCSampleEncryptionGroupEntry *entry;\n\n\tif (IsEncrypted) *IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\t\n\tif (!trak) return GF_BAD_PARAM;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf)\n\t\treturn GF_NOT_SUPPORTED;\n#else\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tif (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {\n\t\tstbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);\n\t} else {\n\t\t//this is dump mode of fragments, we haven't merged tables yet - use current stsd idx indicated in trak\n\t\tdescIndex = trak->current_traf_stsd_idx;\n\t\tif (!descIndex) descIndex = 1;\n\t}\n\n\tgf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\n\tsample_group = NULL;\n\tgroup_desc_index = 0;\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!group_desc_index && traf && traf->sampleGroups) {\n\t\tcount = gf_list_count(traf->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgroup_desc_index = 0;\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup info associated*/\n\tif (!group_desc_index) goto exit;\n\n\tsgdesc = NULL;\n\n\tif (group_desc_index<=0x10000) {\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (traf) {\n\t\tgroup_desc_index -= 0x10000;\n\t\tfor (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup description found for this group (invalid file)*/\n\tif (!sgdesc) return GF_ISOM_INVALID_FILE;\n\n\tentry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (IsEncrypted) *IsEncrypted = entry->IsProtected;\n\tif (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;\n\tif (skip_byte_block) *skip_byte_block = entry->skip_byte_block;\n\n\tif (key_info) *key_info = entry->key_info;\n\tif (key_info_size) *key_info_size = entry->key_info_size;\n\nexit:\n\t//in PIFF we may have default values if no TENC is present: 8 bytes for IV size\n\tif (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {\n\t\tif (!senc) {\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = 8;\n\t\t} else {\n\t\t\tif (!senc->piff_type) {\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t\tsenc->IV_size = 8;\n\t\t\t}\n\t\t\tassert(senc->IV_size);\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = senc->IV_size;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
        "func": "GF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#else\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#endif\n{\n\tGF_SampleGroupBox *sample_group;\n\tu32 j, group_desc_index;\n\tGF_SampleGroupDescriptionBox *sgdesc;\n\tu32 i, count;\n\tu32 descIndex, chunkNum;\n\tu64 offset;\n\tu32 first_sample_in_entry, last_sample_in_entry;\n\tGF_CENCSampleEncryptionGroupEntry *entry;\n\n\tif (IsEncrypted) *IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\n\tif (!trak) return GF_BAD_PARAM;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf)\n\t\treturn GF_NOT_SUPPORTED;\n#else\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tif (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {\n\t\tstbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);\n\t} else {\n\t\t//this is dump mode of fragments, we haven't merged tables yet - use current stsd idx indicated in trak\n\t\tdescIndex = trak->current_traf_stsd_idx;\n\t\tif (!descIndex) descIndex = 1;\n\t}\n\n\tgf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\n\tsample_group = NULL;\n\tgroup_desc_index = 0;\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!group_desc_index && traf && traf->sampleGroups) {\n\t\tcount = gf_list_count(traf->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgroup_desc_index = 0;\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup info associated*/\n\tif (!group_desc_index) goto exit;\n\n\tsgdesc = NULL;\n\n\tif (group_desc_index<=0x10000) {\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (traf) {\n\t\tgroup_desc_index -= 0x10000;\n\t\tfor (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup description found for this group (invalid file)*/\n\tif (!sgdesc) return GF_ISOM_INVALID_FILE;\n\n\tentry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (IsEncrypted) *IsEncrypted = entry->IsProtected;\n\tif (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;\n\tif (skip_byte_block) *skip_byte_block = entry->skip_byte_block;\n\n\tif (key_info) *key_info = entry->key_info;\n\tif (key_info_size) *key_info_size = entry->key_info_size;\n\nexit:\n\t//in PIFF we may have default values if no TENC is present: 8 bytes for IV size\n\tif (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {\n\t\tif (!senc) {\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = 8;\n\t\t} else {\n\t\t\tif (!senc->piff_type) {\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t\tsenc->IV_size = 8;\n\t\t\t}\n\t\t\tassert(senc->IV_size);\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = senc->IV_size;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \tif (skip_byte_block) *skip_byte_block = 0;\n \tif (key_info) *key_info = NULL;\n \tif (key_info_size) *key_info_size = 0;\n-\t\n+\n \tif (!trak) return GF_BAD_PARAM;\n \n #ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0760",
        "func_name": "gpac/gf_isom_box_write",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe",
        "commit_title": "sgpd box entry: disallow null grouping_type (#2389)",
        "commit_text": "",
        "func_before": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\t\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;\n}",
        "func": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \tif (!a) return GF_BAD_PARAM;\n \t//box has been disabled, do not write\n \tif (!a->size) return GF_OK;\n-\t\n+\n \tif (a->registry->disabled) {\n \t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n \t\treturn GF_OK;",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0760",
        "func_name": "gpac/gf_isom_box_parse_ex",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe",
        "commit_title": "sgpd box entry: disallow null grouping_type (#2389)",
        "commit_text": "",
        "func_before": "GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\t\t\t\tif (!compb) return GF_OUT_OF_MEM;\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_free(compb);\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\n#define ERR_EXIT(_e) { \\\n\t\tif (uncomp_bs) {\\\n\t\t\tgf_free(uncomp_data);\\\n\t\t\tgf_bs_del(uncomp_bs); \\\n\t\t}\\\n\t\treturn _e;\\\n\t}\n\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\t\tif (is_root_box && (e==GF_SKIP_BOX))\n\t\t\te = GF_ISOM_INVALID_FILE;\n\n\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}",
        "func": "GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\t\t\t\tif (!compb) return GF_OUT_OF_MEM;\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_free(compb);\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\n#define ERR_EXIT(_e) { \\\n\t\tif (uncomp_bs) {\\\n\t\t\tgf_free(uncomp_data);\\\n\t\t\tgf_bs_del(uncomp_bs); \\\n\t\t}\\\n\t\treturn _e;\\\n\t}\n\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\t\tif (is_root_box && (e==GF_SKIP_BOX))\n\t\t\te = GF_ISOM_INVALID_FILE;\n\n\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \tGF_Box *newBox;\n \tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n \tBool is_special = GF_TRUE;\n-\t\n+\n \tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n \t*outBox = NULL;\n \tif (gf_bs_available(bs) < 8) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0760",
        "func_name": "gpac/gf_isom_check_position",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/ea7395f39f601a7750d48d606e9d10ea0b7beefe",
        "commit_title": "sgpd box entry: disallow null grouping_type (#2389)",
        "commit_text": "",
        "func_before": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\n\t//happens when partially cloning boxes \n\tif (cur_pos < 0) return;\n\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;\n}",
        "func": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\n\t//happens when partially cloning boxes\n\tif (cur_pos < 0) return;\n\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n \ts32 cur_pos = gf_list_find(s->child_boxes, child);\n \n-\t//happens when partially cloning boxes \n+\t//happens when partially cloning boxes\n \tif (cur_pos < 0) return;\n \n \tif (cur_pos != (s32) *pos) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t//happens when partially cloning boxes "
            ],
            "added_lines": [
                "\t//happens when partially cloning boxes"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0819",
        "func_name": "gpac/gf_m2ts_process_tdt_tot",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to v2.3.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/d067ab3ccdeaa340e8c045a0fd5bcfc22b809e8f",
        "commit_title": "mpeg2ts: add section size check (#2395)",
        "commit_text": "",
        "func_before": "static void gf_m2ts_process_tdt_tot(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *tdt_tot_es, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tunsigned char *data;\n\tu32 data_size, nb_sections;\n\tu32 date, yp, mp, k;\n\tGF_M2TS_Section *section;\n\tGF_M2TS_TDT_TOT *time_table;\n\tconst char *table_name;\n\n\t/*wait for the last section */\n\tif ( !(status & GF_M2TS_TABLE_END) )\n\t\treturn;\n\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_TDT:\n\t\ttable_name = \"TDT\";\n\t\tbreak;\n\tcase GF_M2TS_TABLE_ID_TOT:\n\t\ttable_name = \"TOT\";\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Unimplemented table_id %u for PID %u\\n\", table_id, GF_M2TS_PID_TDT_TOT_ST));\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] %s on multiple sections not supported\\n\", table_name));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\t/*TOT only contains 40 bits of UTC_time; TDT add descriptors and a CRC*/\n\tif ((table_id==GF_M2TS_TABLE_ID_TDT) && (data_size != 5)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Corrupted TDT size\\n\", table_name));\n\t}\n\tGF_SAFEALLOC(time_table, GF_M2TS_TDT_TOT);\n\tif (!time_table) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to alloc DVB time table\\n\"));\n\t\treturn;\n\t}\n\n\t/*UTC_time - see annex C of DVB-SI ETSI EN 300468*/\n/* decodes an Modified Julian Date (MJD) into a Co-ordinated Universal Time (UTC)\nSee annex C of DVB-SI ETSI EN 300468 */\n\tdate = data[0]*256 + data[1];\n\typ = (u32)((date - 15078.2)/365.25);\n\tmp = (u32)((date - 14956.1 - (u32)(yp * 365.25))/30.6001);\n\ttime_table->day = (u32)(date - 14956 - (u32)(yp * 365.25) - (u32)(mp * 30.6001));\n\tif (mp == 14 || mp == 15) k = 1;\n\telse k = 0;\n\ttime_table->year = yp + k + 1900;\n\ttime_table->month = mp - 1 - k*12;\n\n\ttime_table->hour   = 10*((data[2]&0xf0)>>4) + (data[2]&0x0f);\n\ttime_table->minute = 10*((data[3]&0xf0)>>4) + (data[3]&0x0f);\n\ttime_table->second = 10*((data[4]&0xf0)>>4) + (data[4]&0x0f);\n\tassert(time_table->hour<24 && time_table->minute<60 && time_table->second<60);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream UTC time is %u/%02u/%02u %02u:%02u:%02u\\n\", time_table->year, time_table->month, time_table->day, time_table->hour, time_table->minute, time_table->second));\n\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_TDT:\n\t\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\t\tts->TDT_time = time_table;\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TDT, time_table);\n\t\tbreak;\n\tcase GF_M2TS_TABLE_ID_TOT:\n#if 0\n\t{\n\t\tu32 pos, loop_len;\n\t\tloop_len = ((data[5]&0x0f) << 8) | (data[6] & 0xff);\n\t\tdata += 7;\n\t\tpos = 0;\n\t\twhile (pos < loop_len) {\n\t\t\tu8 tag = data[pos];\n\t\t\tpos += 2;\n\t\t\tif (tag == GF_M2TS_DVB_LOCAL_TIME_OFFSET_DESCRIPTOR) {\n\t\t\t\tchar tmp_time[10];\n\t\t\t\tu16 offset_hours, offset_minutes;\n\t\t\t\tnow->country_code[0] = data[pos];\n\t\t\t\tnow->country_code[1] = data[pos+1];\n\t\t\t\tnow->country_code[2] = data[pos+2];\n\t\t\t\tnow->country_region_id = data[pos+3]>>2;\n\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+4]);\n\t\t\t\toffset_hours = atoi(tmp_time);\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+5]);\n\t\t\t\toffset_minutes = atoi(tmp_time);\n\t\t\t\tnow->local_time_offset_seconds = (offset_hours * 60 + offset_minutes) * 60;\n\t\t\t\tif (data[pos+3] & 1) now->local_time_offset_seconds *= -1;\n\n\t\t\t\tdvb_decode_mjd_to_unix_time(data+pos+6, &now->unix_next_toc);\n\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+11]);\n\t\t\t\toffset_hours = atoi(tmp_time);\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+12]);\n\t\t\t\toffset_minutes = atoi(tmp_time);\n\t\t\t\tnow->next_time_offset_seconds = (offset_hours * 60 + offset_minutes) * 60;\n\t\t\t\tif (data[pos+3] & 1) now->next_time_offset_seconds *= -1;\n\t\t\t\tpos+= 13;\n\t\t\t}\n\t\t}\n\t\t/*TODO: check lengths are ok*/\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TOT, time_table);\n\t}\n#endif\n\t/*check CRC32*/\n\tif (ts->tdt_tot->length<4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted %s table (less than 4 bytes but CRC32 should be present\\n\", table_name));\n\t\tgoto error_exit;\n\t}\n\tif (!gf_m2ts_crc32_check(ts->tdt_tot->section, ts->tdt_tot->length-4)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted %s table (CRC32 failed)\\n\", table_name));\n\t\tgoto error_exit;\n\t}\n\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\tts->TDT_time = time_table;\n\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TOT, time_table);\n\tbreak;\n\tdefault:\n\t\tassert(0);\n\t\tgoto error_exit;\n\t}\n\n\treturn; /*success*/\n\nerror_exit:\n\tgf_free(time_table);\n\treturn;\n}",
        "func": "static void gf_m2ts_process_tdt_tot(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *tdt_tot_es, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tunsigned char *data;\n\tu32 data_size, nb_sections;\n\tu32 date, yp, mp, k;\n\tGF_M2TS_Section *section;\n\tGF_M2TS_TDT_TOT *time_table;\n\tconst char *table_name;\n\n\t/*wait for the last section */\n\tif ( !(status & GF_M2TS_TABLE_END) )\n\t\treturn;\n\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_TDT:\n\t\ttable_name = \"TDT\";\n\t\tbreak;\n\tcase GF_M2TS_TABLE_ID_TOT:\n\t\ttable_name = \"TOT\";\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Unimplemented table_id %u for PID %u\\n\", table_id, GF_M2TS_PID_TDT_TOT_ST));\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] %s on multiple sections not supported\\n\", table_name));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\t/*TOT only contains 40 bits of UTC_time; TDT add descriptors and a CRC*/\n\tif ((table_id==GF_M2TS_TABLE_ID_TDT) && (data_size != 5)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Corrupted TDT size\\n\", table_name));\n\t}\n\tGF_SAFEALLOC(time_table, GF_M2TS_TDT_TOT);\n\tif (!time_table) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to alloc DVB time table\\n\"));\n\t\treturn;\n\t}\n\n\tif (data_size < 5) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Section data size too small to read date (len: %u)\\n\", data_size));\n\t\treturn;\n\t}\n\n\t/*UTC_time - see annex C of DVB-SI ETSI EN 300468*/\n/* decodes an Modified Julian Date (MJD) into a Co-ordinated Universal Time (UTC)\nSee annex C of DVB-SI ETSI EN 300468 */\n\tdate = data[0]*256 + data[1];\n\typ = (u32)((date - 15078.2)/365.25);\n\tmp = (u32)((date - 14956.1 - (u32)(yp * 365.25))/30.6001);\n\ttime_table->day = (u32)(date - 14956 - (u32)(yp * 365.25) - (u32)(mp * 30.6001));\n\tif (mp == 14 || mp == 15) k = 1;\n\telse k = 0;\n\ttime_table->year = yp + k + 1900;\n\ttime_table->month = mp - 1 - k*12;\n\n\ttime_table->hour   = 10*((data[2]&0xf0)>>4) + (data[2]&0x0f);\n\ttime_table->minute = 10*((data[3]&0xf0)>>4) + (data[3]&0x0f);\n\ttime_table->second = 10*((data[4]&0xf0)>>4) + (data[4]&0x0f);\n\tassert(time_table->hour<24 && time_table->minute<60 && time_table->second<60);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream UTC time is %u/%02u/%02u %02u:%02u:%02u\\n\", time_table->year, time_table->month, time_table->day, time_table->hour, time_table->minute, time_table->second));\n\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_TDT:\n\t\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\t\tts->TDT_time = time_table;\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TDT, time_table);\n\t\tbreak;\n\tcase GF_M2TS_TABLE_ID_TOT:\n#if 0\n\t{\n\t\tu32 pos, loop_len;\n\t\tloop_len = ((data[5]&0x0f) << 8) | (data[6] & 0xff);\n\t\tdata += 7;\n\t\tpos = 0;\n\t\twhile (pos < loop_len) {\n\t\t\tu8 tag = data[pos];\n\t\t\tpos += 2;\n\t\t\tif (tag == GF_M2TS_DVB_LOCAL_TIME_OFFSET_DESCRIPTOR) {\n\t\t\t\tchar tmp_time[10];\n\t\t\t\tu16 offset_hours, offset_minutes;\n\t\t\t\tnow->country_code[0] = data[pos];\n\t\t\t\tnow->country_code[1] = data[pos+1];\n\t\t\t\tnow->country_code[2] = data[pos+2];\n\t\t\t\tnow->country_region_id = data[pos+3]>>2;\n\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+4]);\n\t\t\t\toffset_hours = atoi(tmp_time);\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+5]);\n\t\t\t\toffset_minutes = atoi(tmp_time);\n\t\t\t\tnow->local_time_offset_seconds = (offset_hours * 60 + offset_minutes) * 60;\n\t\t\t\tif (data[pos+3] & 1) now->local_time_offset_seconds *= -1;\n\n\t\t\t\tdvb_decode_mjd_to_unix_time(data+pos+6, &now->unix_next_toc);\n\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+11]);\n\t\t\t\toffset_hours = atoi(tmp_time);\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+12]);\n\t\t\t\toffset_minutes = atoi(tmp_time);\n\t\t\t\tnow->next_time_offset_seconds = (offset_hours * 60 + offset_minutes) * 60;\n\t\t\t\tif (data[pos+3] & 1) now->next_time_offset_seconds *= -1;\n\t\t\t\tpos+= 13;\n\t\t\t}\n\t\t}\n\t\t/*TODO: check lengths are ok*/\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TOT, time_table);\n\t}\n#endif\n\t/*check CRC32*/\n\tif (ts->tdt_tot->length<4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted %s table (less than 4 bytes but CRC32 should be present\\n\", table_name));\n\t\tgoto error_exit;\n\t}\n\tif (!gf_m2ts_crc32_check(ts->tdt_tot->section, ts->tdt_tot->length-4)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted %s table (CRC32 failed)\\n\", table_name));\n\t\tgoto error_exit;\n\t}\n\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\tts->TDT_time = time_table;\n\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TOT, time_table);\n\tbreak;\n\tdefault:\n\t\tassert(0);\n\t\tgoto error_exit;\n\t}\n\n\treturn; /*success*/\n\nerror_exit:\n\tgf_free(time_table);\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,6 +39,11 @@\n \tGF_SAFEALLOC(time_table, GF_M2TS_TDT_TOT);\n \tif (!time_table) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to alloc DVB time table\\n\"));\n+\t\treturn;\n+\t}\n+\n+\tif (data_size < 5) {\n+\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Section data size too small to read date (len: %u)\\n\", data_size));\n \t\treturn;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\treturn;",
                "\t}",
                "",
                "\tif (data_size < 5) {",
                "\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Section data size too small to read date (len: %u)\\n\", data_size));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0866",
        "func_name": "gpac/adts_dmx_process",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.3.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/b964fe4226f1424cf676d5822ef898b6b01f5937",
        "commit_title": "rfadts: add size guard on dmx (#2400)",
        "commit_text": "",
        "func_before": "GF_Err adts_dmx_process(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tadts_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->adts_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->adts_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {\n\t\t\tctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;\n\t\t\tctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);\n\t\tctx->adts_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->adts_buffer_size;\n\tstart = ctx->adts_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tu32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\t\t\tctx->id3_buffer_size = 0;\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tsync = memchr(start, 0xFF, remain);\n\t\tsync_pos = (u32) (sync ? sync - start : remain);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (remain - sync_pos < 7) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//not sync !\n\t\tif ((sync[1] & 0xF0) != 0xF0) {\n\t\t\tif (ctx->is_sync) {\n\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ADTSDmx] invalid ADTS sync bytes, resyncing\\n\"));\n\t\t\t\tctx->is_sync=GF_FALSE;\n\t\t\t}\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif (!ctx->bs) {\n\t\t\tctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);\n\t\t}\n\n\t\t//ok parse header\n\t\tgf_bs_read_int(ctx->bs, 4);\n\n\t\tctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);\n\t\t//if (ctx->mpeg4)\n\t\t//we deprecate old MPEG-2 signaling for AAC in ISOBMFF, as it is not well supported anyway and we don't write adif_header as\n\t\t//supposed to be for these types\n\t\tctx->hdr.is_mp2 = 0;\n\n\t\tgf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);\n\n\t\tctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);\n\t\tgf_bs_read_int(ctx->bs, 1);\n\t\tctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);\n\n\t\tgf_bs_read_int(ctx->bs, 4);\n\t\tctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);\n\t\tgf_bs_read_int(ctx->bs, 11);\n\t\tnb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.hdr_size = 7;\n\n\t\tif (!ctx->hdr.no_crc) {\n\t\t\tu32 skip;\n\t\t\tif (!nb_blocks_per_frame) {\n\t\t\t\tskip = 2;\n\t\t\t} else {\n\t\t\t\tskip = 2 + 2*nb_blocks_per_frame; //and we have 2 bytes per raw_data_block\n\t\t\t}\n\t\t\tctx->hdr.hdr_size += skip;\n\t\t\tgf_bs_skip_bytes(ctx->bs, skip);\n\t\t}\n\n\t\tif (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ADTSDmx] Invalid ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t} else if (!nb_blocks_per_frame) {\n\t\t\tif (ctx->aacchcfg<0)\n\t\t\t\tctx->hdr.nb_ch = -ctx->aacchcfg;\n\t\t\telse if (!ctx->hdr.nb_ch)\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg;\n\n\t\t\tif (!ctx->hdr.nb_ch) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\\n\"));\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg = 2;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_blocks_per_frame==2) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tgf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);\n\t\t\tif (!ctx->hdr.no_crc)\n\t\t\t\tgf_bs_skip_bytes(ctx->bs, 2);  //per block CRC\n\n\t\t\tctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;\n\t\t\tctx->hdr.nb_ch = ctx->acfg.nb_chan;\n\t\t}\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (ctx->hdr.nb_ch==7)\n\t\t\tctx->hdr.nb_ch = 8;\n\n\n\t\t//ready to send packet, check what we have in frame_size is a sync word\n\t\t//if not enough bytes, store and wait\n\t\tif (ctx->hdr.frame_size + sync_pos + 1 < remain) {\n\t\t\tu32 next_frame = ctx->hdr.frame_size;\n\t\t\t//make sure we are sync!\n\t\t\tif ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {\n\t\t\t\tif (ctx->is_sync) {\n\t\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ADTSDmx] invalid next ADTS frame sync, resyncing\\n\"));\n\t\t\t\t\tctx->is_sync = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tctx->nb_frames = 0;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\tctx->cts = cts;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ctx->hdr.frame_size < ctx->hdr.hdr_size) {\n\t\t\tGF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ADTSDmx] Corrupted ADTS frame header, resyncing\\n\"));\n\t\t\tctx->is_sync = GF_FALSE;\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\n\t\tadts_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->adts_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tctx->is_sync = GF_TRUE;\n\n\t\tctx->nb_frames++;\n\t\tsize = ctx->hdr.frame_size - ctx->hdr.hdr_size;\n\t\toffset = ctx->hdr.hdr_size;\n\t\t//per raw-block CRC\n\t\tif ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)\n\t\t\tsize -= 2;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = ctx->hdr.frame_size;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, sync + offset, size);\n\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tadts_dmx_update_cts(ctx);\n\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] truncated ADTS frame %d bytes but only %d left!\\n\", bytes_to_drop, remain));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->adts_buffer_size = 0;\n\t\treturn adts_dmx_process(filter);\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->adts_buffer, start, remain);\n\t\t}\n\t\tctx->adts_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}",
        "func": "GF_Err adts_dmx_process(GF_Filter *filter)\n{\n\tGF_ADTSDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tadts_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->adts_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->adts_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->adts_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->adts_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->adts_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->adts_buffer_size + pck_size > ctx->adts_buffer_alloc) {\n\t\t\tctx->adts_buffer_alloc = ctx->adts_buffer_size + pck_size;\n\t\t\tctx->adts_buffer = gf_realloc(ctx->adts_buffer, ctx->adts_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->adts_buffer + ctx->adts_buffer_size, data, pck_size);\n\t\tctx->adts_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->adts_buffer_size;\n\tstart = ctx->adts_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tu32 sync_pos, size, offset, bytes_to_drop=0, nb_blocks_per_frame;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\t\t\t\tctx->id3_buffer_size = 0;\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tsync = memchr(start, 0xFF, remain);\n\t\tsync_pos = (u32) (sync ? sync - start : remain);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (remain - sync_pos < 7) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//not sync !\n\t\tif ((sync[1] & 0xF0) != 0xF0) {\n\t\t\tif (ctx->is_sync) {\n\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ADTSDmx] invalid ADTS sync bytes, resyncing\\n\"));\n\t\t\t\tctx->is_sync=GF_FALSE;\n\t\t\t}\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif (!ctx->bs) {\n\t\t\tctx->bs = gf_bs_new(sync + 1, remain - sync_pos - 1, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, sync + 1, remain - sync_pos - 1);\n\t\t}\n\n\t\t//ok parse header\n\t\tgf_bs_read_int(ctx->bs, 4);\n\n\t\tctx->hdr.is_mp2 = (Bool)gf_bs_read_int(ctx->bs, 1);\n\t\t//if (ctx->mpeg4)\n\t\t//we deprecate old MPEG-2 signaling for AAC in ISOBMFF, as it is not well supported anyway and we don't write adif_header as\n\t\t//supposed to be for these types\n\t\tctx->hdr.is_mp2 = 0;\n\n\t\tgf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.no_crc = (Bool)gf_bs_read_int(ctx->bs, 1);\n\n\t\tctx->hdr.profile = 1 + gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.sr_idx = gf_bs_read_int(ctx->bs, 4);\n\t\tgf_bs_read_int(ctx->bs, 1);\n\t\tctx->hdr.nb_ch = gf_bs_read_int(ctx->bs, 3);\n\n\t\tgf_bs_read_int(ctx->bs, 4);\n\t\tctx->hdr.frame_size = gf_bs_read_int(ctx->bs, 13);\n\t\tgf_bs_read_int(ctx->bs, 11);\n\t\tnb_blocks_per_frame = gf_bs_read_int(ctx->bs, 2);\n\t\tctx->hdr.hdr_size = 7;\n\n\t\tif (!ctx->hdr.no_crc) {\n\t\t\tu32 skip;\n\t\t\tif (!nb_blocks_per_frame) {\n\t\t\t\tskip = 2;\n\t\t\t} else {\n\t\t\t\tskip = 2 + 2*nb_blocks_per_frame; //and we have 2 bytes per raw_data_block\n\t\t\t}\n\t\t\tctx->hdr.hdr_size += skip;\n\t\t\tgf_bs_skip_bytes(ctx->bs, skip);\n\t\t}\n\n\t\tif (!ctx->hdr.frame_size || !GF_M4ASampleRates[ctx->hdr.sr_idx]) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ADTSDmx] Invalid ADTS frame header, resyncing\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\t\tif ((nb_blocks_per_frame>2) || (nb_blocks_per_frame && ctx->hdr.nb_ch)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ADTSDmx] Unsupported multi-block ADTS frame header - patch welcome\\n\"));\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t} else if (!nb_blocks_per_frame) {\n\t\t\tif (ctx->aacchcfg<0)\n\t\t\t\tctx->hdr.nb_ch = -ctx->aacchcfg;\n\t\t\telse if (!ctx->hdr.nb_ch)\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg;\n\n\t\t\tif (!ctx->hdr.nb_ch) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] Missing channel configuration in ADTS frame header, defaulting to stereo - use `--aacchcfg` to force config\\n\"));\n\t\t\t\tctx->hdr.nb_ch = ctx->aacchcfg = 2;\n\t\t\t}\n\t\t}\n\n\t\tif (nb_blocks_per_frame==2) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(ctx->bs);\n\t\t\tgf_m4a_parse_program_config_element(ctx->bs, &ctx->acfg);\n\t\t\tif (!ctx->hdr.no_crc)\n\t\t\t\tgf_bs_skip_bytes(ctx->bs, 2);  //per block CRC\n\n\t\t\tctx->hdr.hdr_size += (u32) gf_bs_get_position(ctx->bs) - pos;\n\t\t\tctx->hdr.nb_ch = ctx->acfg.nb_chan;\n\t\t}\n\t\t//value 1->6 match channel number, value 7 is 7.1\n\t\tif (ctx->hdr.nb_ch==7)\n\t\t\tctx->hdr.nb_ch = 8;\n\n\n\t\t//ready to send packet, check what we have in frame_size is a sync word\n\t\t//if not enough bytes, store and wait\n\t\tif (ctx->hdr.frame_size + sync_pos + 1 < remain) {\n\t\t\tu32 next_frame = ctx->hdr.frame_size;\n\t\t\t//make sure we are sync!\n\t\t\tif ((sync[next_frame] !=0xFF) || ((sync[next_frame+1] & 0xF0) !=0xF0) ) {\n\t\t\t\tif (ctx->is_sync) {\n\t\t\t\t\tGF_LOG(ctx->nb_frames ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ADTSDmx] invalid next ADTS frame sync, resyncing\\n\"));\n\t\t\t\t\tctx->is_sync = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tctx->nb_frames = 0;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\tctx->cts = cts;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ctx->hdr.frame_size < ctx->hdr.hdr_size) {\n\t\t\tGF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[ADTSDmx] Corrupted ADTS frame header, resyncing\\n\"));\n\t\t\tctx->is_sync = GF_FALSE;\n\t\t\tctx->nb_frames = 0;\n\t\t\tgoto drop_byte;\n\t\t}\n\n\t\tadts_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->adts_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tctx->is_sync = GF_TRUE;\n\n\t\tctx->nb_frames++;\n\t\tsize = ctx->hdr.frame_size - ctx->hdr.hdr_size;\n\t\toffset = ctx->hdr.hdr_size;\n\t\t//per raw-block CRC\n\t\tif ((nb_blocks_per_frame==2) && !ctx->hdr.no_crc)\n\t\t\tsize -= 2;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n\t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = ctx->hdr.frame_size;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\n\t\t\tif (sync_pos + offset + size > remain) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] truncated frame\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\t\tmemcpy(output, sync + offset, size);\n\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.hdr_size);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tadts_dmx_update_cts(ctx);\n\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] truncated ADTS frame %d bytes but only %d left!\\n\", bytes_to_drop, remain));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->adts_buffer_size = 0;\n\t\treturn adts_dmx_process(filter);\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->adts_buffer, start, remain);\n\t\t}\n\t\tctx->adts_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -272,6 +272,12 @@\n \t\t}\n \n \t\tif (!ctx->in_seek) {\n+\n+\t\t\tif (sync_pos + offset + size > remain) {\n+\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] truncated frame\\n\"));\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n \t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n \t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n \t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\tif (sync_pos + offset + size > remain) {",
                "\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] truncated frame\\n\"));",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0866",
        "func_name": "gpac/adts_dmx_check_dur",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.3.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/b964fe4226f1424cf676d5822ef898b6b01f5937",
        "commit_title": "rfadts: add size guard on dmx (#2400)",
        "commit_text": "",
        "func_before": "static void adts_dmx_check_dur(GF_Filter *filter, GF_ADTSDmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tADTSHeader hdr;\n\tu64 duration, cur_dur, rate;\n\ts32 sr_idx = -1;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (adts_dmx_sync_frame_bs(bs, &hdr)) {\n\t\tif ((sr_idx>=0) && (sr_idx != hdr.sr_idx)) {\n\t\t\tduration *= GF_M4ASampleRates[hdr.sr_idx];\n\t\t\tduration /= GF_M4ASampleRates[sr_idx];\n\n\t\t\tcur_dur *= GF_M4ASampleRates[hdr.sr_idx];\n\t\t\tcur_dur /= GF_M4ASampleRates[sr_idx];\n\t\t}\n\t\tsr_idx = hdr.sr_idx;\n\t\tduration += ctx->frame_size;\n\t\tcur_dur += ctx->frame_size;\n\t\tif (cur_dur > ctx->index * GF_M4ASampleRates[sr_idx]) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(ADTSIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = gf_bs_get_position(bs) - hdr.hdr_size;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= GF_M4ASampleRates[sr_idx];\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, hdr.frame_size);\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\n\tif (sr_idx>=0) {\n\t\tif (!ctx->duration.num || (ctx->duration.num  * GF_M4ASampleRates[sr_idx] != duration * ctx->duration.den)) {\n\t\t\tctx->duration.num = (s32) duration;\n\t\t\tctx->duration.den = GF_M4ASampleRates[sr_idx];\n\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\t\trate *= 8 * ctx->duration.den;\n\t\t\t\trate /= ctx->duration.num;\n\t\t\t\tctx->bitrate = (u32) rate;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}",
        "func": "static void adts_dmx_check_dur(GF_Filter *filter, GF_ADTSDmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tADTSHeader hdr;\n\tu64 duration, cur_dur, rate;\n\ts32 sr_idx = -1;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (adts_dmx_sync_frame_bs(bs, &hdr)) {\n\t\tif ((sr_idx>=0) && (sr_idx != hdr.sr_idx)) {\n\t\t\tduration *= GF_M4ASampleRates[hdr.sr_idx];\n\t\t\tduration /= GF_M4ASampleRates[sr_idx];\n\n\t\t\tcur_dur *= GF_M4ASampleRates[hdr.sr_idx];\n\t\t\tcur_dur /= GF_M4ASampleRates[sr_idx];\n\t\t}\n\t\tsr_idx = hdr.sr_idx;\n\t\tduration += ctx->frame_size;\n\t\tcur_dur += ctx->frame_size;\n\t\tif (cur_dur > ctx->index * GF_M4ASampleRates[sr_idx]) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(ADTSIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = gf_bs_get_position(bs) - hdr.hdr_size;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= GF_M4ASampleRates[sr_idx];\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, hdr.frame_size);\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\n\tif (sr_idx>=0) {\n\t\tif (!ctx->duration.num || (ctx->duration.num  * GF_M4ASampleRates[sr_idx] != duration * ctx->duration.den)) {\n\t\t\tctx->duration.num = (s32) duration;\n\t\t\tctx->duration.den = GF_M4ASampleRates[sr_idx];\n\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\t\tif (duration && !gf_sys_is_test_mode() ) {\n\t\t\t\trate *= 8 * ctx->duration.den;\n\t\t\t\trate /= ctx->duration.num;\n\t\t\t\tctx->bitrate = (u32) rate;\n\t\t\t}\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -75,7 +75,7 @@\n \t\t\t}\n \t\t}\n \t}\n-\t\n+\n \tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n \tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0714",
        "func_name": "vim/change_indent",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.4436.",
        "git_url": "https://github.com/vim/vim/commit/4e889f98e95ac05d7c8bd3ee933ab4d47820fdfa",
        "commit_title": "patch 8.2.4436: crash with weird 'vartabstop' value",
        "commit_text": " Problem:    Crash with weird 'vartabstop' value. Solution:   Check for running into the end of the line.",
        "func_before": "void\nchange_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}",
        "func": "void\nchange_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    if (ptr[new_cursor_col] == NUL)\n\t\tbreak;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -100,6 +100,8 @@\n \t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n \t    else\n \t\t++new_cursor_col;\n+\t    if (ptr[new_cursor_col] == NUL)\n+\t\tbreak;\n \t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n \t}\n \tvcol = last_vcol;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    if (ptr[new_cursor_col] == NUL)",
                "\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0943",
        "func_name": "vim/spell_suggest",
        "description": "Heap-based Buffer Overflow occurs in vim in GitHub repository vim/vim prior to 8.2.4563.",
        "git_url": "https://github.com/vim/vim/commit/5c68617d395f9d7b824f68475b24ce3e38d653a3",
        "commit_title": "patch 8.2.4563: \"z=\" in Visual mode may go beyond the end of the line",
        "commit_text": " Problem:    \"z=\" in Visual mode may go beyond the end of the line. Solution:   Adjust \"badlen\".",
        "func_before": "void\nspell_suggest(int count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\tend_visual_mode();\n    }\n    // Find the start of the badly spelled word.\n    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    || curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor = prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p, curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len == 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\tif (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t// When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now the rabbit from the high hat: Avoid showing the\n\t    // untranslated message rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of the bad word, add\n\t    // the not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t    if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score, stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p, line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t    ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum, c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\nskip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}",
        "func": "void\nspell_suggest(int count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\tend_visual_mode();\n\t// make sure we don't include the NUL at the end of the line\n\tline = ml_get_curline();\n\tif (badlen > STRLEN(line) - curwin->w_cursor.col)\n\t    badlen = STRLEN(line) - curwin->w_cursor.col;\n    }\n    // Find the start of the badly spelled word.\n    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    || curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor = prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p, curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len == 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\tif (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t// When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now the rabbit from the high hat: Avoid showing the\n\t    // untranslated message rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of the bad word, add\n\t    // the not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t    if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score, stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p, line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t    ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum, c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\nskip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,6 +45,10 @@\n \t    curwin->w_cursor.col = VIsual.col;\n \t++badlen;\n \tend_visual_mode();\n+\t// make sure we don't include the NUL at the end of the line\n+\tline = ml_get_curline();\n+\tif (badlen > STRLEN(line) - curwin->w_cursor.col)\n+\t    badlen = STRLEN(line) - curwin->w_cursor.col;\n     }\n     // Find the start of the badly spelled word.\n     else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t// make sure we don't include the NUL at the end of the line",
                "\tline = ml_get_curline();",
                "\tif (badlen > STRLEN(line) - curwin->w_cursor.col)",
                "\t    badlen = STRLEN(line) - curwin->w_cursor.col;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1160",
        "func_name": "vim/get_one_sourceline",
        "description": "heap buffer overflow in get_one_sourceline in GitHub repository vim/vim prior to 8.2.4647.",
        "git_url": "https://github.com/vim/vim/commit/2bdad6126778f907c0b98002bfebf0e611a3f5db",
        "commit_title": "patch 8.2.4647: \"source\" can read past end of copied line",
        "commit_text": " Problem:    \"source\" can read past end of copied line. Solution:   Add a terminating NUL.",
        "func_before": "static char_u *\nget_one_sourceline(source_cookie_T *sp)\n{\n    garray_T\t\tga;\n    int\t\t\tlen;\n    int\t\t\tc;\n    char_u\t\t*buf;\n#ifdef USE_CRNL\n    int\t\t\thas_cr;\t\t// CR-LF found\n#endif\n    int\t\t\thave_read = FALSE;\n\n    // use a growarray to store the sourced line\n    ga_init2(&ga, 1, 250);\n\n    // Loop until there is a finished line (or end-of-file).\n    ++sp->sourcing_lnum;\n    for (;;)\n    {\n\t// make room to read at least 120 (more) characters\n\tif (ga_grow(&ga, 120) == FAIL)\n\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    buf = (char_u *)ga.ga_data;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t}\n\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}\n#endif\n\n\thave_read = TRUE;\n\tga.ga_len = len;\n\n\t// If the line was longer than the buffer, read more.\n\tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n\t    continue;\n\n\tif (len >= 1 && buf[len - 1] == '\\n')\t// remove trailing NL\n\t{\n#ifdef USE_CRNL\n\t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n\t    if (sp->fileformat == EOL_UNKNOWN)\n\t    {\n\t\tif (has_cr)\n\t\t    sp->fileformat = EOL_DOS;\n\t\telse\n\t\t    sp->fileformat = EOL_UNIX;\n\t    }\n\n\t    if (sp->fileformat == EOL_DOS)\n\t    {\n\t\tif (has_cr)\t    // replace trailing CR\n\t\t{\n\t\t    buf[len - 2] = '\\n';\n\t\t    --len;\n\t\t    --ga.ga_len;\n\t\t}\n\t\telse\t    // lines like \":map xx yy^M\" will have failed\n\t\t{\n\t\t    if (!sp->error)\n\t\t    {\n\t\t\tmsg_source(HL_ATTR(HLF_W));\n\t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n\t\t    }\n\t\t    sp->error = TRUE;\n\t\t    sp->fileformat = EOL_UNIX;\n\t\t}\n\t    }\n#endif\n\t    // The '\\n' is escaped if there is an odd number of ^V's just\n\t    // before it, first set \"c\" just before the 'V's and then check\n\t    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo\n\t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n\t\t;\n\t    if ((len & 1) != (c & 1))\t// escaped NL, read more\n\t    {\n\t\t++sp->sourcing_lnum;\n\t\tcontinue;\n\t    }\n\n\t    buf[len - 1] = NUL;\t\t// remove the NL\n\t}\n\n\t// Check for ^C here now and then, so recursive :so can be broken.\n\tline_breakcheck();\n\tbreak;\n    }\n\n    if (have_read)\n\treturn (char_u *)ga.ga_data;\n\n    vim_free(ga.ga_data);\n    return NULL;\n}",
        "func": "static char_u *\nget_one_sourceline(source_cookie_T *sp)\n{\n    garray_T\t\tga;\n    int\t\t\tlen;\n    int\t\t\tc;\n    char_u\t\t*buf;\n#ifdef USE_CRNL\n    int\t\t\thas_cr;\t\t// CR-LF found\n#endif\n    int\t\t\thave_read = FALSE;\n\n    // use a growarray to store the sourced line\n    ga_init2(&ga, 1, 250);\n\n    // Loop until there is a finished line (or end-of-file).\n    ++sp->sourcing_lnum;\n    for (;;)\n    {\n\t// make room to read at least 120 (more) characters\n\tif (ga_grow(&ga, 120) == FAIL)\n\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t}\n\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}\n#endif\n\n\thave_read = TRUE;\n\tga.ga_len = len;\n\n\t// If the line was longer than the buffer, read more.\n\tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n\t    continue;\n\n\tif (len >= 1 && buf[len - 1] == '\\n')\t// remove trailing NL\n\t{\n#ifdef USE_CRNL\n\t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n\t    if (sp->fileformat == EOL_UNKNOWN)\n\t    {\n\t\tif (has_cr)\n\t\t    sp->fileformat = EOL_DOS;\n\t\telse\n\t\t    sp->fileformat = EOL_UNIX;\n\t    }\n\n\t    if (sp->fileformat == EOL_DOS)\n\t    {\n\t\tif (has_cr)\t    // replace trailing CR\n\t\t{\n\t\t    buf[len - 2] = '\\n';\n\t\t    --len;\n\t\t    --ga.ga_len;\n\t\t}\n\t\telse\t    // lines like \":map xx yy^M\" will have failed\n\t\t{\n\t\t    if (!sp->error)\n\t\t    {\n\t\t\tmsg_source(HL_ATTR(HLF_W));\n\t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n\t\t    }\n\t\t    sp->error = TRUE;\n\t\t    sp->fileformat = EOL_UNIX;\n\t\t}\n\t    }\n#endif\n\t    // The '\\n' is escaped if there is an odd number of ^V's just\n\t    // before it, first set \"c\" just before the 'V's and then check\n\t    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo\n\t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n\t\t;\n\t    if ((len & 1) != (c & 1))\t// escaped NL, read more\n\t    {\n\t\t++sp->sourcing_lnum;\n\t\tcontinue;\n\t    }\n\n\t    buf[len - 1] = NUL;\t\t// remove the NL\n\t}\n\n\t// Check for ^C here now and then, so recursive :so can be broken.\n\tline_breakcheck();\n\tbreak;\n    }\n\n    if (have_read)\n\treturn (char_u *)ga.ga_data;\n\n    vim_free(ga.ga_data);\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,10 @@\n \t\tbreak;\t\t    // all the lines are processed\n \t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n \t    sp->buf_lnum++;\n+\t    if (ga_grow(&ga, 1) == FAIL)\n+\t\tbreak;\n \t    buf = (char_u *)ga.ga_data;\n+\t    buf[ga.ga_len++] = NUL;\n \t}\n \telse\n \t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    if (ga_grow(&ga, 1) == FAIL)",
                "\t\tbreak;",
                "\t    buf[ga.ga_len++] = NUL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1244",
        "func_name": "radareorg/radare2/create_cache_bins",
        "description": "heap-buffer-overflow in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is capable of inducing denial of service.",
        "git_url": "https://github.com/radareorg/radare2/commit/2b77b277d67ce061ee6ef839e7139ebc2103c1e3",
        "commit_title": "Fix oobread in dyldcache ##crash",
        "commit_text": " * Reported by @hdthky via huntr.dev * Reproducers: poc1 * BountyID: 8ae2c61a-2220-47a5-bfe8-fe6d41ab1f82",
        "func_before": "static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\tr_list_free (bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\tr_list_free (bins);\n\t\t\tr_list_free (target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tR_FREE (lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tR_FREE (lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (path_to_idx);\n\t\t\tR_FREE (depArray);\n\t\t\tR_FREE (extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = r_read_le32 (magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64:\n\t\t\t{\n\t\t\t\tchar file[256];\n\t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup (file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (depArray);\n\t\tR_FREE (extras);\n\t\tR_FREE (img);\n\t}\n\tif (r_list_empty (bins)) {\n\t\tr_list_free (bins);\n\t\tbins = NULL;\n\t}\n\tR_FREE (deps);\n\tR_FREE (target_libs);\n\tr_list_free (target_lib_names);\n\treturn bins;\n}",
        "func": "static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\t\tif (!target_lib_names) {\n\t\t\tr_list_free (bins);\n\t\t\treturn NULL;\n\t\t}\n\t\tdeps = R_NEWS0 (int, cache->hdr->imagesCount);\n\t\tif (!deps) {\n\t\t\tr_list_free (bins);\n\t\t\tr_list_free (target_lib_names);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\textras = read_cache_imgextra (cache->buf, hdr, cache->accel);\n\t\t\t\tif (!extras) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpath_to_idx = create_path_to_index (cache->buf, img, hdr);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\t\tbool printing = !deps[j];\n\t\t\t\tchar *lib_name = get_lib_name (cache->buf, &img[j]);\n\t\t\t\tif (!lib_name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (strstr (lib_name, \"libobjc.A.dylib\")) {\n\t\t\t\t\tdeps[j]++;\n\t\t\t\t}\n\t\t\t\tif (!r_list_find (target_lib_names, lib_name, string_contains)) {\n\t\t\t\t\tR_FREE (lib_name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (printing) {\n\t\t\t\t\teprintf (\"FILTER: %s\\n\", lib_name);\n\t\t\t\t}\n\t\t\t\tR_FREE (lib_name);\n\t\t\t\tdeps[j]++;\n\n\t\t\t\tif (extras && depArray) {\n\t\t\t\t\tut32 k;\n\t\t\t\t\tfor (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {\n\t\t\t\t\t\tut16 dep_index = depArray[k] & 0x7fff;\n\t\t\t\t\t\tdeps[dep_index]++;\n\n\t\t\t\t\t\tchar *dep_name = get_lib_name (cache->buf, &img[dep_index]);\n\t\t\t\t\t\tif (!dep_name) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (printing) {\n\t\t\t\t\t\t\teprintf (\"-> %s\\n\", dep_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (dep_name);\n\t\t\t\t\t}\n\t\t\t\t} else if (path_to_idx) {\n\t\t\t\t\tcarve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tht_pu_free (path_to_idx);\n\t\t\tR_FREE (depArray);\n\t\t\tR_FREE (extras);\n\t\t}\n\n\t\tfor (j = 0; j < hdr->imagesCount; j++) {\n\t\t\tif (deps && !deps[j]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n\t\t\tif (pa == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut8 magicbytes[4];\n\t\t\tr_buf_read_at (cache->buf, pa, magicbytes, 4);\n\t\t\tint magic = r_read_le32 (magicbytes);\n\t\t\tswitch (magic) {\n\t\t\tcase MH_MAGIC_64:\n\t\t\t{\n\t\t\t\tchar file[256];\n\t\t\t\tRDyldBinImage *bin = R_NEW0 (RDyldBinImage);\n\t\t\t\tif (!bin) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tbin->header_at = pa;\n\t\t\t\tbin->hdr_offset = hdr_offset;\n\t\t\t\tbin->symbols_off = resolve_symbols_off (cache, pa);\n\t\t\t\tbin->va = img[j].address;\n\t\t\t\tif (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {\n\t\t\t\t\tfile[255] = 0;\n\t\t\t\t\tchar *last_slash = strrchr (file, '/');\n\t\t\t\t\tif (last_slash && *last_slash) {\n\t\t\t\t\t\tif (last_slash > file) {\n\t\t\t\t\t\t\tchar *scan = last_slash - 1;\n\t\t\t\t\t\t\twhile (scan > file && *scan != '/') {\n\t\t\t\t\t\t\t\tscan--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (*scan == '/') {\n\t\t\t\t\t\t\t\tbin->file = strdup (scan + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbin->file = strdup (last_slash + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->file = strdup (file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_append (bins, bin);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\teprintf (\"Unknown sub-bin\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnext:\n\t\tR_FREE (depArray);\n\t\tR_FREE (extras);\n\t\tR_FREE (img);\n\t}\n\tif (r_list_empty (bins)) {\n\t\tr_list_free (bins);\n\t\tbins = NULL;\n\t}\n\tR_FREE (deps);\n\tR_FREE (target_libs);\n\tr_list_free (target_lib_names);\n\treturn bins;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -103,7 +103,8 @@\n \t\t\tif (deps && !deps[j]) {\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n+\t\t\t// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n+\t\t\tut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);\n \t\t\tif (pa == UT64_MAX) {\n \t\t\t\tcontinue;\n \t\t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);"
            ],
            "added_lines": [
                "\t\t\t// ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);",
                "\t\t\tut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1253",
        "func_name": "strukturag/libde265/video_usability_information::read",
        "description": "Heap-based Buffer Overflow in GitHub repository strukturag/libde265 prior to and including 1.0.8. The fix is established in commit 8e89fe0e175d2870c39486fdd09250b230ec10b8 but does not yet belong to an official release.",
        "git_url": "https://github.com/strukturag/libde265/commit/8e89fe0e175d2870c39486fdd09250b230ec10b8",
        "commit_title": "error on out-of-range cpb_cnt_minus1 (oss-fuzz issue 27590)",
        "commit_text": "",
        "func_before": "de265_error video_usability_information::read(error_queue* errqueue, bitreader* br,\n                                              const seq_parameter_set* sps)\n{\n  int vlc;\n\n\n  // --- sample aspect ratio (SAR) ---\n\n  aspect_ratio_info_present_flag = get_bits(br, 1);\n  if (aspect_ratio_info_present_flag) {\n    int aspect_ratio_idc = get_bits(br, 8);\n    if (aspect_ratio_idc <= NUM_SAR_PRESETS) {\n      sar_width = sar_presets[aspect_ratio_idc][0];\n      sar_height = sar_presets[aspect_ratio_idc][1];\n    }\n    else if (aspect_ratio_idc == EXTENDED_SAR) {\n      sar_width = get_bits(br, 16);\n      sar_height = get_bits(br, 16);\n    }\n    else {\n      sar_width = 0;\n      sar_height = 0;\n    }\n  }\n  else {\n    sar_width = 0;\n    sar_height = 0;\n  }\n\n\n  // --- overscan ---\n\n  overscan_info_present_flag = get_bits(br, 1);\n  if (overscan_info_present_flag) {\n    overscan_appropriate_flag = get_bits(br, 1);\n  }\n\n\n  // --- video signal type ---\n\n  { // defaults\n    video_format = VideoFormat_Unspecified;\n    video_full_range_flag = false;\n    colour_primaries = 2;\n    transfer_characteristics = 2;\n    matrix_coeffs = 2;\n  }\n\n  video_signal_type_present_flag = get_bits(br, 1);\n  if (video_signal_type_present_flag) {\n    int video_format_idc = get_bits(br, 3);\n    if (video_format_idc > 5) {\n      video_format_idc = VideoFormat_Unspecified;\n    }\n    video_format = (VideoFormat)video_format_idc;\n\n    video_full_range_flag = get_bits(br, 1);\n\n    colour_description_present_flag = get_bits(br, 1);\n    if (colour_description_present_flag) {\n      colour_primaries = get_bits(br, 8);\n      if (colour_primaries == 0 ||\n        colour_primaries == 3 ||\n        colour_primaries >= 11) {\n        colour_primaries = 2;\n      }\n\n      transfer_characteristics = get_bits(br, 8);\n      if (transfer_characteristics == 0 ||\n        transfer_characteristics == 3 ||\n        transfer_characteristics >= 18) {\n        transfer_characteristics = 2;\n      }\n\n      matrix_coeffs = get_bits(br, 8);\n      \n      if (matrix_coeffs >= 11) {\n        matrix_coeffs = 2;\n      }\n    }\n  }\n\n\n  // --- chroma / interlaced ---\n\n  chroma_loc_info_present_flag = get_bits(br, 1);\n  if (chroma_loc_info_present_flag) {\n    READ_VLC(chroma_sample_loc_type_top_field, uvlc);\n    READ_VLC(chroma_sample_loc_type_bottom_field, uvlc);\n  }\n  else {\n    chroma_sample_loc_type_top_field = 0;\n    chroma_sample_loc_type_bottom_field = 0;\n  }\n\n  neutral_chroma_indication_flag = get_bits(br, 1);\n  field_seq_flag = get_bits(br, 1);\n  frame_field_info_present_flag = get_bits(br, 1);\n\n\n  // --- default display window ---\n\n  default_display_window_flag = get_bits(br, 1);\n  if (default_display_window_flag) {\n    READ_VLC(def_disp_win_left_offset, uvlc);\n    READ_VLC(def_disp_win_right_offset, uvlc);\n    READ_VLC(def_disp_win_top_offset, uvlc);\n    READ_VLC(def_disp_win_bottom_offset, uvlc);\n  }\n  else {\n    def_disp_win_left_offset = 0;\n    def_disp_win_right_offset = 0;\n    def_disp_win_top_offset = 0;\n    def_disp_win_bottom_offset = 0;\n  }\n\n\n  // --- timing ---\n\n  vui_timing_info_present_flag = get_bits(br, 1);\n  if (vui_timing_info_present_flag) {\n    vui_num_units_in_tick = get_bits(br, 32);\n    vui_time_scale = get_bits(br, 32);\n\n    vui_poc_proportional_to_timing_flag = get_bits(br, 1);\n    if (vui_poc_proportional_to_timing_flag) {\n      READ_VLC_OFFSET(vui_num_ticks_poc_diff_one, uvlc, 1);\n    }\n\n    // --- hrd parameters ---\n\n    vui_hrd_parameters_present_flag = get_bits(br, 1);\n    if (vui_hrd_parameters_present_flag) {\n      de265_error err;\n      err = hrd_parameters(errqueue, br, sps);\n    }\n  }\n\n  // --- bitstream restriction ---\n\n  bitstream_restriction_flag = get_bits(br,1);\n  if (bitstream_restriction_flag) {\n    tiles_fixed_structure_flag = get_bits(br,1);\n    motion_vectors_over_pic_boundaries_flag = get_bits(br,1);\n    restricted_ref_pic_lists_flag = get_bits(br,1);\n\n    READ_VLC(min_spatial_segmentation_idc, uvlc);\n    if (min_spatial_segmentation_idc > 4095) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      min_spatial_segmentation_idc = 0;\n    }\n\n    READ_VLC(max_bytes_per_pic_denom, uvlc);\n    if (max_bytes_per_pic_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bytes_per_pic_denom = 2;\n    }\n\n    READ_VLC(max_bits_per_min_cu_denom, uvlc);\n    if (max_bits_per_min_cu_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bits_per_min_cu_denom = 1;\n    }\n\n    READ_VLC(log2_max_mv_length_horizontal, uvlc);\n    if (log2_max_mv_length_horizontal > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_horizontal = 15;\n    }\n\n    READ_VLC(log2_max_mv_length_vertical, uvlc);\n    if (log2_max_mv_length_vertical > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_vertical = 15;\n    }\n  }\n  else {\n    tiles_fixed_structure_flag = false;\n    motion_vectors_over_pic_boundaries_flag = true;\n    restricted_ref_pic_lists_flag = false; // NOTE: default not specified in standard 2014/10\n\n    min_spatial_segmentation_idc = 0;\n    max_bytes_per_pic_denom   = 2;\n    max_bits_per_min_cu_denom = 1;\n    log2_max_mv_length_horizontal = 15;\n    log2_max_mv_length_vertical   = 15;\n  }\n\n  //vui_read = true;\n\n  return DE265_OK;\n}",
        "func": "de265_error video_usability_information::read(error_queue* errqueue, bitreader* br,\n                                              const seq_parameter_set* sps)\n{\n  int vlc;\n\n\n  // --- sample aspect ratio (SAR) ---\n\n  aspect_ratio_info_present_flag = get_bits(br, 1);\n  if (aspect_ratio_info_present_flag) {\n    int aspect_ratio_idc = get_bits(br, 8);\n    if (aspect_ratio_idc <= NUM_SAR_PRESETS) {\n      sar_width = sar_presets[aspect_ratio_idc][0];\n      sar_height = sar_presets[aspect_ratio_idc][1];\n    }\n    else if (aspect_ratio_idc == EXTENDED_SAR) {\n      sar_width = get_bits(br, 16);\n      sar_height = get_bits(br, 16);\n    }\n    else {\n      sar_width = 0;\n      sar_height = 0;\n    }\n  }\n  else {\n    sar_width = 0;\n    sar_height = 0;\n  }\n\n\n  // --- overscan ---\n\n  overscan_info_present_flag = get_bits(br, 1);\n  if (overscan_info_present_flag) {\n    overscan_appropriate_flag = get_bits(br, 1);\n  }\n\n\n  // --- video signal type ---\n\n  { // defaults\n    video_format = VideoFormat_Unspecified;\n    video_full_range_flag = false;\n    colour_primaries = 2;\n    transfer_characteristics = 2;\n    matrix_coeffs = 2;\n  }\n\n  video_signal_type_present_flag = get_bits(br, 1);\n  if (video_signal_type_present_flag) {\n    int video_format_idc = get_bits(br, 3);\n    if (video_format_idc > 5) {\n      video_format_idc = VideoFormat_Unspecified;\n    }\n    video_format = (VideoFormat)video_format_idc;\n\n    video_full_range_flag = get_bits(br, 1);\n\n    colour_description_present_flag = get_bits(br, 1);\n    if (colour_description_present_flag) {\n      colour_primaries = get_bits(br, 8);\n      if (colour_primaries == 0 ||\n        colour_primaries == 3 ||\n        colour_primaries >= 11) {\n        colour_primaries = 2;\n      }\n\n      transfer_characteristics = get_bits(br, 8);\n      if (transfer_characteristics == 0 ||\n        transfer_characteristics == 3 ||\n        transfer_characteristics >= 18) {\n        transfer_characteristics = 2;\n      }\n\n      matrix_coeffs = get_bits(br, 8);\n      \n      if (matrix_coeffs >= 11) {\n        matrix_coeffs = 2;\n      }\n    }\n  }\n\n\n  // --- chroma / interlaced ---\n\n  chroma_loc_info_present_flag = get_bits(br, 1);\n  if (chroma_loc_info_present_flag) {\n    READ_VLC(chroma_sample_loc_type_top_field, uvlc);\n    READ_VLC(chroma_sample_loc_type_bottom_field, uvlc);\n  }\n  else {\n    chroma_sample_loc_type_top_field = 0;\n    chroma_sample_loc_type_bottom_field = 0;\n  }\n\n  neutral_chroma_indication_flag = get_bits(br, 1);\n  field_seq_flag = get_bits(br, 1);\n  frame_field_info_present_flag = get_bits(br, 1);\n\n\n  // --- default display window ---\n\n  default_display_window_flag = get_bits(br, 1);\n  if (default_display_window_flag) {\n    READ_VLC(def_disp_win_left_offset, uvlc);\n    READ_VLC(def_disp_win_right_offset, uvlc);\n    READ_VLC(def_disp_win_top_offset, uvlc);\n    READ_VLC(def_disp_win_bottom_offset, uvlc);\n  }\n  else {\n    def_disp_win_left_offset = 0;\n    def_disp_win_right_offset = 0;\n    def_disp_win_top_offset = 0;\n    def_disp_win_bottom_offset = 0;\n  }\n\n\n  // --- timing ---\n\n  vui_timing_info_present_flag = get_bits(br, 1);\n  if (vui_timing_info_present_flag) {\n    vui_num_units_in_tick = get_bits(br, 32);\n    vui_time_scale = get_bits(br, 32);\n\n    vui_poc_proportional_to_timing_flag = get_bits(br, 1);\n    if (vui_poc_proportional_to_timing_flag) {\n      READ_VLC_OFFSET(vui_num_ticks_poc_diff_one, uvlc, 1);\n    }\n\n    // --- hrd parameters ---\n\n    vui_hrd_parameters_present_flag = get_bits(br, 1);\n    if (vui_hrd_parameters_present_flag) {\n      de265_error err;\n      err = hrd_parameters(errqueue, br, sps);\n      if (err) {\n\treturn err;\n      }\n    }\n  }\n\n  // --- bitstream restriction ---\n\n  bitstream_restriction_flag = get_bits(br,1);\n  if (bitstream_restriction_flag) {\n    tiles_fixed_structure_flag = get_bits(br,1);\n    motion_vectors_over_pic_boundaries_flag = get_bits(br,1);\n    restricted_ref_pic_lists_flag = get_bits(br,1);\n\n    READ_VLC(min_spatial_segmentation_idc, uvlc);\n    if (min_spatial_segmentation_idc > 4095) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      min_spatial_segmentation_idc = 0;\n    }\n\n    READ_VLC(max_bytes_per_pic_denom, uvlc);\n    if (max_bytes_per_pic_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bytes_per_pic_denom = 2;\n    }\n\n    READ_VLC(max_bits_per_min_cu_denom, uvlc);\n    if (max_bits_per_min_cu_denom > 16) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      max_bits_per_min_cu_denom = 1;\n    }\n\n    READ_VLC(log2_max_mv_length_horizontal, uvlc);\n    if (log2_max_mv_length_horizontal > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_horizontal = 15;\n    }\n\n    READ_VLC(log2_max_mv_length_vertical, uvlc);\n    if (log2_max_mv_length_vertical > 15) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      log2_max_mv_length_vertical = 15;\n    }\n  }\n  else {\n    tiles_fixed_structure_flag = false;\n    motion_vectors_over_pic_boundaries_flag = true;\n    restricted_ref_pic_lists_flag = false; // NOTE: default not specified in standard 2014/10\n\n    min_spatial_segmentation_idc = 0;\n    max_bytes_per_pic_denom   = 2;\n    max_bits_per_min_cu_denom = 1;\n    log2_max_mv_length_horizontal = 15;\n    log2_max_mv_length_vertical   = 15;\n  }\n\n  //vui_read = true;\n\n  return DE265_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -133,6 +133,9 @@\n     if (vui_hrd_parameters_present_flag) {\n       de265_error err;\n       err = hrd_parameters(errqueue, br, sps);\n+      if (err) {\n+\treturn err;\n+      }\n     }\n   }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if (err) {",
                "\treturn err;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1253",
        "func_name": "strukturag/libde265/video_usability_information::hrd_parameters",
        "description": "Heap-based Buffer Overflow in GitHub repository strukturag/libde265 prior to and including 1.0.8. The fix is established in commit 8e89fe0e175d2870c39486fdd09250b230ec10b8 but does not yet belong to an official release.",
        "git_url": "https://github.com/strukturag/libde265/commit/8e89fe0e175d2870c39486fdd09250b230ec10b8",
        "commit_title": "error on out-of-range cpb_cnt_minus1 (oss-fuzz issue 27590)",
        "commit_text": "",
        "func_before": "de265_error video_usability_information::hrd_parameters(error_queue* errqueue, bitreader* br, const seq_parameter_set* sps)\n{\n  int vlc;\n\n  nal_hrd_parameters_present_flag = get_bits(br, 1);\n  vcl_hrd_parameters_present_flag = get_bits(br, 1);\n\n  if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag)\n  {\n    sub_pic_hrd_params_present_flag = get_bits(br, 1);\n    if (sub_pic_hrd_params_present_flag)\n    {\n      tick_divisor_minus2 = get_bits(br, 8);\n      du_cpb_removal_delay_increment_length_minus1 = get_bits(br, 5);\n      sub_pic_cpb_params_in_pic_timing_sei_flag = get_bits(br, 1);\n      dpb_output_delay_du_length_minus1 = get_bits(br, 5);\n    }\n    bit_rate_scale = get_bits(br, 4);\n    cpb_size_scale = get_bits(br, 4);\n\n\n    if (sub_pic_hrd_params_present_flag)\n    {\n      cpb_size_du_scale = get_bits(br, 4);\n    }\n    initial_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    au_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    dpb_output_delay_length_minus1 = get_bits(br, 5);\n  }\n  int  i, j, nalOrVcl;\n\n  for (i = 0; i < sps->sps_max_sub_layers; i++)\n  {\n    fixed_pic_rate_general_flag[i] = get_bits(br, 1);\n    if (!fixed_pic_rate_general_flag[i])\n    {\n      fixed_pic_rate_within_cvs_flag[i] = get_bits(br, 1);\n    }\n    else\n    {\n      fixed_pic_rate_within_cvs_flag[i] = true;\n    }\n\n    low_delay_hrd_flag[i] = 0;// Infered to be 0 when not present\n    cpb_cnt_minus1[i] = 0;    // Infered to be 0 when not present\n\n    if (fixed_pic_rate_within_cvs_flag[i])\n    {\n      READ_VLC_OFFSET(elemental_duration_in_tc_minus1[i], uvlc, 0);\n    }\n    else\n    {\n      low_delay_hrd_flag[i] = get_bits(br, 1);\n    }\n    if (!low_delay_hrd_flag[i])\n    {\n      READ_VLC_OFFSET(cpb_cnt_minus1[i], uvlc, 0);\n    }\n\n    for (nalOrVcl = 0; nalOrVcl < 2; nalOrVcl++)\n    {\n      if (((nalOrVcl == 0) && nal_hrd_parameters_present_flag) ||\n        ((nalOrVcl == 1) && vcl_hrd_parameters_present_flag))\n      {\n        for (j = 0; j <= cpb_cnt_minus1[i]; j++)\n        {\n          READ_VLC_OFFSET(bit_rate_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          READ_VLC_OFFSET(cpb_size_value_minus1[i][j][nalOrVcl], uvlc, 0);\n\n          if (sub_pic_hrd_params_present_flag)\n          {\n            READ_VLC_OFFSET(cpb_size_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n            READ_VLC_OFFSET(bit_rate_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          }\n          cbr_flag[i][j][nalOrVcl] = get_bits(br, 1);\n        }\n      }\n    }\n  }\n  return DE265_OK;\n}",
        "func": "de265_error video_usability_information::hrd_parameters(error_queue* errqueue, bitreader* br, const seq_parameter_set* sps)\n{\n  int vlc;\n\n  nal_hrd_parameters_present_flag = get_bits(br, 1);\n  vcl_hrd_parameters_present_flag = get_bits(br, 1);\n\n  if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag)\n  {\n    sub_pic_hrd_params_present_flag = get_bits(br, 1);\n    if (sub_pic_hrd_params_present_flag)\n    {\n      tick_divisor_minus2 = get_bits(br, 8);\n      du_cpb_removal_delay_increment_length_minus1 = get_bits(br, 5);\n      sub_pic_cpb_params_in_pic_timing_sei_flag = get_bits(br, 1);\n      dpb_output_delay_du_length_minus1 = get_bits(br, 5);\n    }\n    bit_rate_scale = get_bits(br, 4);\n    cpb_size_scale = get_bits(br, 4);\n\n\n    if (sub_pic_hrd_params_present_flag)\n    {\n      cpb_size_du_scale = get_bits(br, 4);\n    }\n    initial_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    au_cpb_removal_delay_length_minus1 = get_bits(br, 5);\n    dpb_output_delay_length_minus1 = get_bits(br, 5);\n  }\n  int  i, j, nalOrVcl;\n\n  for (i = 0; i < sps->sps_max_sub_layers; i++)\n  {\n    fixed_pic_rate_general_flag[i] = get_bits(br, 1);\n    if (!fixed_pic_rate_general_flag[i])\n    {\n      fixed_pic_rate_within_cvs_flag[i] = get_bits(br, 1);\n    }\n    else\n    {\n      fixed_pic_rate_within_cvs_flag[i] = true;\n    }\n\n    low_delay_hrd_flag[i] = 0;// Infered to be 0 when not present\n    cpb_cnt_minus1[i] = 0;    // Infered to be 0 when not present\n\n    if (fixed_pic_rate_within_cvs_flag[i])\n    {\n      READ_VLC_OFFSET(elemental_duration_in_tc_minus1[i], uvlc, 0);\n    }\n    else\n    {\n      low_delay_hrd_flag[i] = get_bits(br, 1);\n    }\n    if (!low_delay_hrd_flag[i])\n    {\n      READ_VLC_OFFSET(cpb_cnt_minus1[i], uvlc, 0);\n      if (cpb_cnt_minus1[i] > 31) {\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n    }\n\n    for (nalOrVcl = 0; nalOrVcl < 2; nalOrVcl++)\n    {\n      if (((nalOrVcl == 0) && nal_hrd_parameters_present_flag) ||\n        ((nalOrVcl == 1) && vcl_hrd_parameters_present_flag))\n      {\n        for (j = 0; j <= cpb_cnt_minus1[i]; j++)\n        {\n          READ_VLC_OFFSET(bit_rate_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          READ_VLC_OFFSET(cpb_size_value_minus1[i][j][nalOrVcl], uvlc, 0);\n\n          if (sub_pic_hrd_params_present_flag)\n          {\n            READ_VLC_OFFSET(cpb_size_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n            READ_VLC_OFFSET(bit_rate_du_value_minus1[i][j][nalOrVcl], uvlc, 0);\n          }\n          cbr_flag[i][j][nalOrVcl] = get_bits(br, 1);\n        }\n      }\n    }\n  }\n  return DE265_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,6 +55,9 @@\n     if (!low_delay_hrd_flag[i])\n     {\n       READ_VLC_OFFSET(cpb_cnt_minus1[i], uvlc, 0);\n+      if (cpb_cnt_minus1[i] > 31) {\n+\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n+      }\n     }\n \n     for (nalOrVcl = 0; nalOrVcl < 2; nalOrVcl++)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if (cpb_cnt_minus1[i] > 31) {",
                "\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1253",
        "func_name": "strukturag/libde265/seq_parameter_set::read",
        "description": "Heap-based Buffer Overflow in GitHub repository strukturag/libde265 prior to and including 1.0.8. The fix is established in commit 8e89fe0e175d2870c39486fdd09250b230ec10b8 but does not yet belong to an official release.",
        "git_url": "https://github.com/strukturag/libde265/commit/8e89fe0e175d2870c39486fdd09250b230ec10b8",
        "commit_title": "error on out-of-range cpb_cnt_minus1 (oss-fuzz issue 27590)",
        "commit_text": "",
        "func_before": "de265_error seq_parameter_set::read(error_queue* errqueue, bitreader* br)\n{\n  int vlc;\n\n  video_parameter_set_id = get_bits(br,4);\n  sps_max_sub_layers     = get_bits(br,3) +1;\n  if (sps_max_sub_layers>7) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  sps_temporal_id_nesting_flag = get_bits(br,1);\n\n  profile_tier_level_.read(br, sps_max_sub_layers);\n\n  READ_VLC(seq_parameter_set_id, uvlc);\n  if (seq_parameter_set_id >= DE265_MAX_SPS_SETS) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- decode chroma type ---\n\n  READ_VLC(chroma_format_idc, uvlc);\n\n  if (chroma_format_idc == 3) {\n    separate_colour_plane_flag = get_bits(br,1);\n  }\n  else {\n    separate_colour_plane_flag = 0;\n  }\n\n  if (chroma_format_idc<0 ||\n      chroma_format_idc>3) {\n    errqueue->add_warning(DE265_WARNING_INVALID_CHROMA_FORMAT, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- picture size ---\n\n  READ_VLC(pic_width_in_luma_samples,  uvlc);\n  READ_VLC(pic_height_in_luma_samples, uvlc);\n\n  if (pic_width_in_luma_samples  == 0 ||\n      pic_height_in_luma_samples == 0) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (pic_width_in_luma_samples > MAX_PICTURE_WIDTH ||\n      pic_height_in_luma_samples> MAX_PICTURE_HEIGHT) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  conformance_window_flag = get_bits(br,1);\n\n  if (conformance_window_flag) {\n    READ_VLC(conf_win_left_offset,  uvlc);\n    READ_VLC(conf_win_right_offset, uvlc);\n    READ_VLC(conf_win_top_offset,   uvlc);\n    READ_VLC(conf_win_bottom_offset,uvlc);\n  }\n  else {\n    conf_win_left_offset  = 0;\n    conf_win_right_offset = 0;\n    conf_win_top_offset   = 0;\n    conf_win_bottom_offset= 0;\n  }\n\n  READ_VLC_OFFSET(bit_depth_luma,  uvlc, 8);\n  READ_VLC_OFFSET(bit_depth_chroma,uvlc, 8);\n  if (bit_depth_luma > 16 ||\n      bit_depth_chroma > 16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  READ_VLC_OFFSET(log2_max_pic_order_cnt_lsb, uvlc, 4);\n  if (log2_max_pic_order_cnt_lsb<4 ||\n      log2_max_pic_order_cnt_lsb>16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n  MaxPicOrderCntLsb = 1<<(log2_max_pic_order_cnt_lsb);\n\n\n  // --- sub_layer_ordering_info ---\n\n  sps_sub_layer_ordering_info_present_flag = get_bits(br,1);\n\n  int firstLayer = (sps_sub_layer_ordering_info_present_flag ?\n                    0 : sps_max_sub_layers-1 );\n\n  for (int i=firstLayer ; i <= sps_max_sub_layers-1; i++ ) {\n\n    // sps_max_dec_pic_buffering[i]\n\n    vlc=get_uvlc(br);\n    if (vlc == UVLC_ERROR ||\n        vlc+1 > MAX_NUM_REF_PICS) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    sps_max_dec_pic_buffering[i] = vlc+1;\n\n    // sps_max_num_reorder_pics[i]\n\n    READ_VLC(sps_max_num_reorder_pics[i], uvlc);\n\n\n    // sps_max_latency_increase[i]\n\n    READ_VLC(sps_max_latency_increase_plus1[i], uvlc);\n\n    SpsMaxLatencyPictures[i] = (sps_max_num_reorder_pics[i] +\n                                sps_max_latency_increase_plus1[i]-1);\n  }\n\n  // copy info to all layers if only specified once\n\n  if (sps_sub_layer_ordering_info_present_flag) {\n    int ref = sps_max_sub_layers-1;\n    assert(ref<7);\n\n    for (int i=0 ; i < sps_max_sub_layers-1; i++ ) {\n      sps_max_dec_pic_buffering[i] = sps_max_dec_pic_buffering[ref];\n      sps_max_num_reorder_pics[i]  = sps_max_num_reorder_pics[ref];\n      sps_max_latency_increase_plus1[i]  = sps_max_latency_increase_plus1[ref];\n    }\n  }\n\n\n  READ_VLC_OFFSET(log2_min_luma_coding_block_size, uvlc, 3);\n  READ_VLC       (log2_diff_max_min_luma_coding_block_size, uvlc);\n  READ_VLC_OFFSET(log2_min_transform_block_size, uvlc, 2);\n  READ_VLC(log2_diff_max_min_transform_block_size, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_inter, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_intra, uvlc);\n\n  if (log2_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size + log2_diff_max_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n\n  scaling_list_enable_flag = get_bits(br,1);\n\n  if (scaling_list_enable_flag) {\n\n    sps_scaling_list_data_present_flag = get_bits(br,1);\n    if (sps_scaling_list_data_present_flag) {\n\n      de265_error err;\n      if ((err=read_scaling_list(br,this, &scaling_list, false)) != DE265_OK) {\n        return err;\n      }\n    }\n    else {\n      set_default_scaling_lists(&scaling_list);\n    }\n  }\n\n  amp_enabled_flag = get_bits(br,1);\n  sample_adaptive_offset_enabled_flag = get_bits(br,1);\n  pcm_enabled_flag = get_bits(br,1);\n  if (pcm_enabled_flag) {\n    pcm_sample_bit_depth_luma = get_bits(br,4)+1;\n    pcm_sample_bit_depth_chroma = get_bits(br,4)+1;\n    READ_VLC_OFFSET(log2_min_pcm_luma_coding_block_size, uvlc, 3);\n    READ_VLC(log2_diff_max_min_pcm_luma_coding_block_size, uvlc);\n    pcm_loop_filter_disable_flag = get_bits(br,1);\n\n    if (pcm_sample_bit_depth_luma > bit_depth_luma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    if (pcm_sample_bit_depth_chroma > bit_depth_chroma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n  }\n  else {\n    pcm_sample_bit_depth_luma = 0;\n    pcm_sample_bit_depth_chroma = 0;\n    log2_min_pcm_luma_coding_block_size = 0;\n    log2_diff_max_min_pcm_luma_coding_block_size = 0;\n    pcm_loop_filter_disable_flag = 0;\n  }\n\n  int num_short_term_ref_pic_sets;\n  READ_VLC(num_short_term_ref_pic_sets, uvlc);\n  if (num_short_term_ref_pic_sets < 0 ||\n      num_short_term_ref_pic_sets > 64) {\n    errqueue->add_warning(DE265_WARNING_NUMBER_OF_SHORT_TERM_REF_PIC_SETS_OUT_OF_RANGE, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  // --- allocate reference pic set ---\n\n  // we do not allocate the ref-pic-set for the slice header here, but in the slice header itself\n\n  ref_pic_sets.resize(num_short_term_ref_pic_sets);\n\n  for (int i = 0; i < num_short_term_ref_pic_sets; i++) {\n\n    bool success = read_short_term_ref_pic_set(errqueue,this,br,\n                                               &ref_pic_sets[i], i,\n                                               ref_pic_sets,\n                                               false);\n\n    if (!success) {\n      return DE265_WARNING_SPS_HEADER_INVALID;\n    }\n\n    // dump_short_term_ref_pic_set(&(*ref_pic_sets)[i], fh);\n  }\n\n  long_term_ref_pics_present_flag = get_bits(br,1);\n\n  if (long_term_ref_pics_present_flag) {\n\n    READ_VLC(num_long_term_ref_pics_sps, uvlc);\n    if (num_long_term_ref_pics_sps > MAX_NUM_LT_REF_PICS_SPS) {\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    for (int i = 0; i < num_long_term_ref_pics_sps; i++ ) {\n      lt_ref_pic_poc_lsb_sps[i] = get_bits(br, log2_max_pic_order_cnt_lsb);\n      used_by_curr_pic_lt_sps_flag[i] = get_bits(br,1);\n    }\n  }\n  else {\n    num_long_term_ref_pics_sps = 0; // NOTE: missing definition in standard !\n  }\n\n  sps_temporal_mvp_enabled_flag = get_bits(br,1);\n  strong_intra_smoothing_enable_flag = get_bits(br,1);\n\n  vui_parameters_present_flag = get_bits(br,1);\n  if (vui_parameters_present_flag) {\n    vui.read(errqueue, br, this);\n  }\n\n\n  sps_extension_present_flag = get_bits(br,1);\n  if (sps_extension_present_flag) {\n    sps_range_extension_flag = get_bits(br,1);\n    sps_multilayer_extension_flag = get_bits(br,1);\n    sps_extension_6bits = get_bits(br,6);\n  }\n  else {\n    sps_range_extension_flag = 0;\n  }\n\n  if (sps_range_extension_flag) {\n    de265_error err = range_extension.read(errqueue, br);\n    if (err != DE265_OK) { return err; }\n  }\n\n  /*\n  sps_extension_flag = get_bits(br,1);\n  if (sps_extension_flag) {\n    assert(false);\n  }\n  */\n\n\n  de265_error err = compute_derived_values();\n  if (err != DE265_OK) { return err; }\n\n  sps_read = true;\n\n  return DE265_OK;\n}",
        "func": "de265_error seq_parameter_set::read(error_queue* errqueue, bitreader* br)\n{\n  int vlc;\n\n  video_parameter_set_id = get_bits(br,4);\n  sps_max_sub_layers     = get_bits(br,3) +1;\n  if (sps_max_sub_layers>7) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  sps_temporal_id_nesting_flag = get_bits(br,1);\n\n  profile_tier_level_.read(br, sps_max_sub_layers);\n\n  READ_VLC(seq_parameter_set_id, uvlc);\n  if (seq_parameter_set_id >= DE265_MAX_SPS_SETS) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- decode chroma type ---\n\n  READ_VLC(chroma_format_idc, uvlc);\n\n  if (chroma_format_idc == 3) {\n    separate_colour_plane_flag = get_bits(br,1);\n  }\n  else {\n    separate_colour_plane_flag = 0;\n  }\n\n  if (chroma_format_idc<0 ||\n      chroma_format_idc>3) {\n    errqueue->add_warning(DE265_WARNING_INVALID_CHROMA_FORMAT, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n  // --- picture size ---\n\n  READ_VLC(pic_width_in_luma_samples,  uvlc);\n  READ_VLC(pic_height_in_luma_samples, uvlc);\n\n  if (pic_width_in_luma_samples  == 0 ||\n      pic_height_in_luma_samples == 0) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  if (pic_width_in_luma_samples > MAX_PICTURE_WIDTH ||\n      pic_height_in_luma_samples> MAX_PICTURE_HEIGHT) {\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  conformance_window_flag = get_bits(br,1);\n\n  if (conformance_window_flag) {\n    READ_VLC(conf_win_left_offset,  uvlc);\n    READ_VLC(conf_win_right_offset, uvlc);\n    READ_VLC(conf_win_top_offset,   uvlc);\n    READ_VLC(conf_win_bottom_offset,uvlc);\n  }\n  else {\n    conf_win_left_offset  = 0;\n    conf_win_right_offset = 0;\n    conf_win_top_offset   = 0;\n    conf_win_bottom_offset= 0;\n  }\n\n  READ_VLC_OFFSET(bit_depth_luma,  uvlc, 8);\n  READ_VLC_OFFSET(bit_depth_chroma,uvlc, 8);\n  if (bit_depth_luma > 16 ||\n      bit_depth_chroma > 16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  READ_VLC_OFFSET(log2_max_pic_order_cnt_lsb, uvlc, 4);\n  if (log2_max_pic_order_cnt_lsb<4 ||\n      log2_max_pic_order_cnt_lsb>16) {\n    errqueue->add_warning(DE265_WARNING_SPS_HEADER_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n  MaxPicOrderCntLsb = 1<<(log2_max_pic_order_cnt_lsb);\n\n\n  // --- sub_layer_ordering_info ---\n\n  sps_sub_layer_ordering_info_present_flag = get_bits(br,1);\n\n  int firstLayer = (sps_sub_layer_ordering_info_present_flag ?\n                    0 : sps_max_sub_layers-1 );\n\n  for (int i=firstLayer ; i <= sps_max_sub_layers-1; i++ ) {\n\n    // sps_max_dec_pic_buffering[i]\n\n    vlc=get_uvlc(br);\n    if (vlc == UVLC_ERROR ||\n        vlc+1 > MAX_NUM_REF_PICS) {\n      errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    sps_max_dec_pic_buffering[i] = vlc+1;\n\n    // sps_max_num_reorder_pics[i]\n\n    READ_VLC(sps_max_num_reorder_pics[i], uvlc);\n\n\n    // sps_max_latency_increase[i]\n\n    READ_VLC(sps_max_latency_increase_plus1[i], uvlc);\n\n    SpsMaxLatencyPictures[i] = (sps_max_num_reorder_pics[i] +\n                                sps_max_latency_increase_plus1[i]-1);\n  }\n\n  // copy info to all layers if only specified once\n\n  if (sps_sub_layer_ordering_info_present_flag) {\n    int ref = sps_max_sub_layers-1;\n    assert(ref<7);\n\n    for (int i=0 ; i < sps_max_sub_layers-1; i++ ) {\n      sps_max_dec_pic_buffering[i] = sps_max_dec_pic_buffering[ref];\n      sps_max_num_reorder_pics[i]  = sps_max_num_reorder_pics[ref];\n      sps_max_latency_increase_plus1[i]  = sps_max_latency_increase_plus1[ref];\n    }\n  }\n\n\n  READ_VLC_OFFSET(log2_min_luma_coding_block_size, uvlc, 3);\n  READ_VLC       (log2_diff_max_min_luma_coding_block_size, uvlc);\n  READ_VLC_OFFSET(log2_min_transform_block_size, uvlc, 2);\n  READ_VLC(log2_diff_max_min_transform_block_size, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_inter, uvlc);\n  READ_VLC(max_transform_hierarchy_depth_intra, uvlc);\n\n  if (log2_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_luma_coding_block_size + log2_diff_max_min_luma_coding_block_size > 6) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n  if (log2_min_transform_block_size + log2_diff_max_min_transform_block_size > 5) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n\n  scaling_list_enable_flag = get_bits(br,1);\n\n  if (scaling_list_enable_flag) {\n\n    sps_scaling_list_data_present_flag = get_bits(br,1);\n    if (sps_scaling_list_data_present_flag) {\n\n      de265_error err;\n      if ((err=read_scaling_list(br,this, &scaling_list, false)) != DE265_OK) {\n        return err;\n      }\n    }\n    else {\n      set_default_scaling_lists(&scaling_list);\n    }\n  }\n\n  amp_enabled_flag = get_bits(br,1);\n  sample_adaptive_offset_enabled_flag = get_bits(br,1);\n  pcm_enabled_flag = get_bits(br,1);\n  if (pcm_enabled_flag) {\n    pcm_sample_bit_depth_luma = get_bits(br,4)+1;\n    pcm_sample_bit_depth_chroma = get_bits(br,4)+1;\n    READ_VLC_OFFSET(log2_min_pcm_luma_coding_block_size, uvlc, 3);\n    READ_VLC(log2_diff_max_min_pcm_luma_coding_block_size, uvlc);\n    pcm_loop_filter_disable_flag = get_bits(br,1);\n\n    if (pcm_sample_bit_depth_luma > bit_depth_luma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    if (pcm_sample_bit_depth_chroma > bit_depth_chroma) {\n      errqueue->add_warning(DE265_WARNING_PCM_BITDEPTH_TOO_LARGE, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n  }\n  else {\n    pcm_sample_bit_depth_luma = 0;\n    pcm_sample_bit_depth_chroma = 0;\n    log2_min_pcm_luma_coding_block_size = 0;\n    log2_diff_max_min_pcm_luma_coding_block_size = 0;\n    pcm_loop_filter_disable_flag = 0;\n  }\n\n  int num_short_term_ref_pic_sets;\n  READ_VLC(num_short_term_ref_pic_sets, uvlc);\n  if (num_short_term_ref_pic_sets < 0 ||\n      num_short_term_ref_pic_sets > 64) {\n    errqueue->add_warning(DE265_WARNING_NUMBER_OF_SHORT_TERM_REF_PIC_SETS_OUT_OF_RANGE, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  // --- allocate reference pic set ---\n\n  // we do not allocate the ref-pic-set for the slice header here, but in the slice header itself\n\n  ref_pic_sets.resize(num_short_term_ref_pic_sets);\n\n  for (int i = 0; i < num_short_term_ref_pic_sets; i++) {\n\n    bool success = read_short_term_ref_pic_set(errqueue,this,br,\n                                               &ref_pic_sets[i], i,\n                                               ref_pic_sets,\n                                               false);\n\n    if (!success) {\n      return DE265_WARNING_SPS_HEADER_INVALID;\n    }\n\n    // dump_short_term_ref_pic_set(&(*ref_pic_sets)[i], fh);\n  }\n\n  long_term_ref_pics_present_flag = get_bits(br,1);\n\n  if (long_term_ref_pics_present_flag) {\n\n    READ_VLC(num_long_term_ref_pics_sps, uvlc);\n    if (num_long_term_ref_pics_sps > MAX_NUM_LT_REF_PICS_SPS) {\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    for (int i = 0; i < num_long_term_ref_pics_sps; i++ ) {\n      lt_ref_pic_poc_lsb_sps[i] = get_bits(br, log2_max_pic_order_cnt_lsb);\n      used_by_curr_pic_lt_sps_flag[i] = get_bits(br,1);\n    }\n  }\n  else {\n    num_long_term_ref_pics_sps = 0; // NOTE: missing definition in standard !\n  }\n\n  sps_temporal_mvp_enabled_flag = get_bits(br,1);\n  strong_intra_smoothing_enable_flag = get_bits(br,1);\n\n  vui_parameters_present_flag = get_bits(br,1);\n  if (vui_parameters_present_flag) {\n    de265_error err = vui.read(errqueue, br, this);\n    if (err) {\n      return err;\n    }\n  }\n\n\n  sps_extension_present_flag = get_bits(br,1);\n  if (sps_extension_present_flag) {\n    sps_range_extension_flag = get_bits(br,1);\n    sps_multilayer_extension_flag = get_bits(br,1);\n    sps_extension_6bits = get_bits(br,6);\n  }\n  else {\n    sps_range_extension_flag = 0;\n  }\n\n  if (sps_range_extension_flag) {\n    de265_error err = range_extension.read(errqueue, br);\n    if (err != DE265_OK) { return err; }\n  }\n\n  /*\n  sps_extension_flag = get_bits(br,1);\n  if (sps_extension_flag) {\n    assert(false);\n  }\n  */\n\n\n  de265_error err = compute_derived_values();\n  if (err != DE265_OK) { return err; }\n\n  sps_read = true;\n\n  return DE265_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -238,7 +238,10 @@\n \n   vui_parameters_present_flag = get_bits(br,1);\n   if (vui_parameters_present_flag) {\n-    vui.read(errqueue, br, this);\n+    de265_error err = vui.read(errqueue, br, this);\n+    if (err) {\n+      return err;\n+    }\n   }\n \n ",
        "diff_line_info": {
            "deleted_lines": [
                "    vui.read(errqueue, br, this);"
            ],
            "added_lines": [
                "    de265_error err = vui.read(errqueue, br, this);",
                "    if (err) {",
                "      return err;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1381",
        "func_name": "vim/parse_command_modifiers",
        "description": "global heap buffer overflow in skip_range in GitHub repository vim/vim prior to 8.2.4763. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution",
        "git_url": "https://github.com/vim/vim/commit/f50808ed135ab973296bca515ae4029b321afe47",
        "commit_title": "patch 8.2.4763: using invalid pointer with \"V:\" in Ex mode",
        "commit_text": " Problem:    Using invalid pointer with \"V:\" in Ex mode. Solution:   Correctly handle the command being changed to \"+\".",
        "func_before": "int\nparse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *cmd_start = NULL;\n    char_u  *p;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty line works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    eap->cmd = (char_u *)\"+\";\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd);\n\t\t\t    if (cmod->cmod_verbose == 0)\n\t\t\t\tcmod->cmod_verbose = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 1;\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t    eap->cmd -= 5;\n\t    mch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t}\n\telse\n\t    // no modifiers, move the pointer back\n\t    eap->cmd -= 5;\n    }\n\n    return OK;\n}",
        "func": "int\nparse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    did_plus_cmd = FALSE;\n    char_u  *p;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty line works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    eap->cmd = (char_u *)\"+\";\n\t    did_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd);\n\t\t\t    if (cmod->cmod_verbose == 0)\n\t\t\t\tcmod->cmod_verbose = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 1;\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (did_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command may have been changed to \"+\":\n\t\t//  \"'<,'>mod\" -> \"mod'<,'>+\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: empty command may have been changed to \"+\".\n\t    if (did_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,9 @@\n \tcmdmod_T    *cmod,\n \tint\t    skip_only)\n {\n+    char_u  *orig_cmd = eap->cmd;\n     char_u  *cmd_start = NULL;\n+    int\t    did_plus_cmd = FALSE;\n     char_u  *p;\n     int\t    starts_with_colon = FALSE;\n     int\t    vim9script = in_vim9script();\n@@ -41,6 +43,7 @@\n \t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n \t{\n \t    eap->cmd = (char_u *)\"+\";\n+\t    did_plus_cmd = TRUE;\n \t    if (!skip_only)\n \t\tex_pressedreturn = TRUE;\n \t}\n@@ -327,13 +330,29 @@\n \t    // Since the modifiers have been parsed put the colon on top of the\n \t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n \t    // Put eap->cmd after the colon.\n-\t    mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n-\t    eap->cmd -= 5;\n-\t    mch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n+\t    if (did_plus_cmd)\n+\t    {\n+\t\tsize_t len = STRLEN(cmd_start);\n+\n+\t\t// Special case: empty command may have been changed to \"+\":\n+\t\t//  \"'<,'>mod\" -> \"mod'<,'>+\n+\t\tmch_memmove(orig_cmd, cmd_start, len);\n+\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");\n+\t    }\n+\t    else\n+\t    {\n+\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n+\t\teap->cmd -= 5;\n+\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n+\t    }\n \t}\n \telse\n-\t    // no modifiers, move the pointer back\n-\t    eap->cmd -= 5;\n+\t    // No modifiers, move the pointer back.\n+\t    // Special case: empty command may have been changed to \"+\".\n+\t    if (did_plus_cmd)\n+\t\teap->cmd = (char_u *)\"'<,'>+\";\n+\t    else\n+\t\teap->cmd = orig_cmd;\n     }\n \n     return OK;",
        "diff_line_info": {
            "deleted_lines": [
                "\t    mch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);",
                "\t    eap->cmd -= 5;",
                "\t    mch_memmove(eap->cmd - 1, \":'<,'>\", 6);",
                "\t    // no modifiers, move the pointer back",
                "\t    eap->cmd -= 5;"
            ],
            "added_lines": [
                "    char_u  *orig_cmd = eap->cmd;",
                "    int\t    did_plus_cmd = FALSE;",
                "\t    did_plus_cmd = TRUE;",
                "\t    if (did_plus_cmd)",
                "\t    {",
                "\t\tsize_t len = STRLEN(cmd_start);",
                "",
                "\t\t// Special case: empty command may have been changed to \"+\":",
                "\t\t//  \"'<,'>mod\" -> \"mod'<,'>+",
                "\t\tmch_memmove(orig_cmd, cmd_start, len);",
                "\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");",
                "\t    }",
                "\t    else",
                "\t    {",
                "\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);",
                "\t\teap->cmd -= 5;",
                "\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);",
                "\t    }",
                "\t    // No modifiers, move the pointer back.",
                "\t    // Special case: empty command may have been changed to \"+\".",
                "\t    if (did_plus_cmd)",
                "\t\teap->cmd = (char_u *)\"'<,'>+\";",
                "\t    else",
                "\t\teap->cmd = orig_cmd;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1621",
        "func_name": "vim/store_word",
        "description": "Heap buffer overflow in vim_strncpy find_word in GitHub repository vim/vim prior to 8.2.4919. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution",
        "git_url": "https://github.com/vim/vim/commit/7c824682d2028432ee082703ef0ab399867a089b",
        "commit_title": "patch 8.2.4919: can add invalid bytes with :spellgood",
        "commit_text": " Problem:    Can add invalid bytes with :spellgood. Solution:   Check for a valid word string.",
        "func_before": "static int\nstore_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    int\t\tflags,\t\t// extra flags, WF_BANNED\n    int\t\tregion,\t\t// supported region(s)\n    char_u\t*pfxlist,\t// list of prefix IDs or NULL\n    int\t\tneed_affix)\t// only store word with affix ID\n{\n    int\t\tlen = (int)STRLEN(word);\n    int\t\tct = captype(word, word + len);\n    char_u\tfoldword[MAXWLEN];\n    int\t\tres = OK;\n    char_u\t*p;\n\n    (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);\n    for (p = pfxlist; res == OK; ++p)\n    {\n\tif (!need_affix || (p != NULL && *p != NUL))\n\t    res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\tif (p == NULL || *p == NUL)\n\t    break;\n    }\n    ++spin->si_foldwcount;\n\n    if (res == OK && (ct == WF_KEEPCAP || (flags & WF_KEEPCAP)))\n    {\n\tfor (p = pfxlist; res == OK; ++p)\n\t{\n\t    if (!need_affix || (p != NULL && *p != NUL))\n\t\tres = tree_add_word(spin, word, spin->si_keeproot, flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\t    if (p == NULL || *p == NUL)\n\t\tbreak;\n\t}\n\t++spin->si_keepwcount;\n    }\n    return res;\n}",
        "func": "static int\nstore_word(\n    spellinfo_T\t*spin,\n    char_u\t*word,\n    int\t\tflags,\t\t// extra flags, WF_BANNED\n    int\t\tregion,\t\t// supported region(s)\n    char_u\t*pfxlist,\t// list of prefix IDs or NULL\n    int\t\tneed_affix)\t// only store word with affix ID\n{\n    int\t\tlen = (int)STRLEN(word);\n    int\t\tct = captype(word, word + len);\n    char_u\tfoldword[MAXWLEN];\n    int\t\tres = OK;\n    char_u\t*p;\n\n    // Avoid adding illegal bytes to the word tree.\n    if (enc_utf8 && !utf_valid_string(word, NULL))\n\treturn FAIL;\n\n    (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);\n    for (p = pfxlist; res == OK; ++p)\n    {\n\tif (!need_affix || (p != NULL && *p != NUL))\n\t    res = tree_add_word(spin, foldword, spin->si_foldroot, ct | flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\tif (p == NULL || *p == NUL)\n\t    break;\n    }\n    ++spin->si_foldwcount;\n\n    if (res == OK && (ct == WF_KEEPCAP || (flags & WF_KEEPCAP)))\n    {\n\tfor (p = pfxlist; res == OK; ++p)\n\t{\n\t    if (!need_affix || (p != NULL && *p != NUL))\n\t\tres = tree_add_word(spin, word, spin->si_keeproot, flags,\n\t\t\t\t\t\t  region, p == NULL ? 0 : *p);\n\t    if (p == NULL || *p == NUL)\n\t\tbreak;\n\t}\n\t++spin->si_keepwcount;\n    }\n    return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,10 @@\n     char_u\tfoldword[MAXWLEN];\n     int\t\tres = OK;\n     char_u\t*p;\n+\n+    // Avoid adding illegal bytes to the word tree.\n+    if (enc_utf8 && !utf_valid_string(word, NULL))\n+\treturn FAIL;\n \n     (void)spell_casefold(curwin, word, len, foldword, MAXWLEN);\n     for (p = pfxlist; res == OK; ++p)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    // Avoid adding illegal bytes to the word tree.",
                "    if (enc_utf8 && !utf_valid_string(word, NULL))",
                "\treturn FAIL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1621",
        "func_name": "vim/spell_add_word",
        "description": "Heap buffer overflow in vim_strncpy find_word in GitHub repository vim/vim prior to 8.2.4919. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution",
        "git_url": "https://github.com/vim/vim/commit/7c824682d2028432ee082703ef0ab399867a089b",
        "commit_title": "patch 8.2.4919: can add invalid bytes with :spellgood",
        "commit_text": " Problem:    Can add invalid bytes with :spellgood. Solution:   Check for a valid word string.",
        "func_before": "void\nspell_add_word(\n    char_u\t*word,\n    int\t\tlen,\n    int\t\twhat,\t    // SPELL_ADD_ values\n    int\t\tidx,\t    // \"zG\" and \"zW\": zero, otherwise index in\n\t\t\t    // 'spellfile'\n    int\t\tundo)\t    // TRUE for \"zug\", \"zuG\", \"zuw\" and \"zuW\"\n{\n    FILE\t*fd = NULL;\n    buf_T\t*buf = NULL;\n    int\t\tnew_spf = FALSE;\n    char_u\t*fname;\n    char_u\t*fnamebuf = NULL;\n    char_u\tline[MAXWLEN * 2];\n    long\tfpos, fpos_next = 0;\n    int\t\ti;\n    char_u\t*spf;\n\n    if (idx == 0)\t    // use internal wordlist\n    {\n\tif (int_wordlist == NULL)\n\t{\n\t    int_wordlist = vim_tempname('s', FALSE);\n\t    if (int_wordlist == NULL)\n\t\treturn;\n\t}\n\tfname = int_wordlist;\n    }\n    else\n    {\n\t// If 'spellfile' isn't set figure out a good default value.\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    init_spellfile();\n\t    new_spf = TRUE;\n\t}\n\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    semsg(_(e_option_str_is_not_set), \"spellfile\");\n\t    return;\n\t}\n\tfnamebuf = alloc(MAXPATHL);\n\tif (fnamebuf == NULL)\n\t    return;\n\n\tfor (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i)\n\t{\n\t    copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");\n\t    if (i == idx)\n\t\tbreak;\n\t    if (*spf == NUL)\n\t    {\n\t\tsemsg(_(e_spellfile_does_not_have_nr_entries), idx);\n\t\tvim_free(fnamebuf);\n\t\treturn;\n\t    }\n\t}\n\n\t// Check that the user isn't editing the .add file somewhere.\n\tbuf = buflist_findname_exp(fnamebuf);\n\tif (buf != NULL && buf->b_ml.ml_mfp == NULL)\n\t    buf = NULL;\n\tif (buf != NULL && bufIsChanged(buf))\n\t{\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    vim_free(fnamebuf);\n\t    return;\n\t}\n\n\tfname = fnamebuf;\n    }\n\n    if (what == SPELL_ADD_BAD || undo)\n    {\n\t// When the word appears as good word we need to remove that one,\n\t// since its flags sort before the one with WF_BANNED.\n\tfd = mch_fopen((char *)fname, \"r\");\n\tif (fd != NULL)\n\t{\n\t    while (!vim_fgets(line, MAXWLEN * 2, fd))\n\t    {\n\t\tfpos = fpos_next;\n\t\tfpos_next = ftell(fd);\n\t\tif (fpos_next < 0)\n\t\t    break;  // should never happen\n\t\tif (STRNCMP(word, line, len) == 0\n\t\t\t&& (line[len] == '/' || line[len] < ' '))\n\t\t{\n\t\t    // Found duplicate word.  Remove it by writing a '#' at\n\t\t    // the start of the line.  Mixing reading and writing\n\t\t    // doesn't work for all systems, close the file first.\n\t\t    fclose(fd);\n\t\t    fd = mch_fopen((char *)fname, \"r+\");\n\t\t    if (fd == NULL)\n\t\t\tbreak;\n\t\t    if (fseek(fd, fpos, SEEK_SET) == 0)\n\t\t    {\n\t\t\tfputc('#', fd);\n\t\t\tif (undo)\n\t\t\t{\n\t\t\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t\t\t    smsg(_(\"Word '%.*s' removed from %s\"),\n\t\t\t\t\t\t\t len, word, NameBuff);\n\t\t\t}\n\t\t    }\n\t\t    if (fseek(fd, fpos_next, SEEK_SET) != 0)\n\t\t    {\n\t\t\tPERROR(_(\"Seek error in spellfile\"));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t}\n    }\n\n    if (!undo)\n    {\n\tfd = mch_fopen((char *)fname, \"a\");\n\tif (fd == NULL && new_spf)\n\t{\n\t    char_u *p;\n\n\t    // We just initialized the 'spellfile' option and can't open the\n\t    // file.  We may need to create the \"spell\" directory first.  We\n\t    // already checked the runtime directory is writable in\n\t    // init_spellfile().\n\t    if (!dir_of_file_exists(fname) && (p = gettail_sep(fname)) != fname)\n\t    {\n\t\tint c = *p;\n\n\t\t// The directory doesn't exist.  Try creating it and opening\n\t\t// the file again.\n\t\t*p = NUL;\n\t\tvim_mkdir(fname, 0755);\n\t\t*p = c;\n\t\tfd = mch_fopen((char *)fname, \"a\");\n\t    }\n\t}\n\n\tif (fd == NULL)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse\n\t{\n\t    if (what == SPELL_ADD_BAD)\n\t\tfprintf(fd, \"%.*s/!\\n\", len, word);\n\t    else if (what == SPELL_ADD_RARE)\n\t\tfprintf(fd, \"%.*s/?\\n\", len, word);\n\t    else\n\t\tfprintf(fd, \"%.*s\\n\", len, word);\n\t    fclose(fd);\n\n\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t    smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);\n\t}\n    }\n\n    if (fd != NULL)\n    {\n\t// Update the .add.spl file.\n\tmkspell(1, &fname, FALSE, TRUE, TRUE);\n\n\t// If the .add file is edited somewhere, reload it.\n\tif (buf != NULL)\n\t    buf_reload(buf, buf->b_orig_mode, FALSE);\n\n\tredraw_all_later(SOME_VALID);\n    }\n    vim_free(fnamebuf);\n}",
        "func": "void\nspell_add_word(\n    char_u\t*word,\n    int\t\tlen,\n    int\t\twhat,\t    // SPELL_ADD_ values\n    int\t\tidx,\t    // \"zG\" and \"zW\": zero, otherwise index in\n\t\t\t    // 'spellfile'\n    int\t\tundo)\t    // TRUE for \"zug\", \"zuG\", \"zuw\" and \"zuW\"\n{\n    FILE\t*fd = NULL;\n    buf_T\t*buf = NULL;\n    int\t\tnew_spf = FALSE;\n    char_u\t*fname;\n    char_u\t*fnamebuf = NULL;\n    char_u\tline[MAXWLEN * 2];\n    long\tfpos, fpos_next = 0;\n    int\t\ti;\n    char_u\t*spf;\n\n    if (enc_utf8 && !utf_valid_string(word, NULL))\n    {\n\temsg(_(e_illegal_character_in_word));\n\treturn;\n    }\n\n    if (idx == 0)\t    // use internal wordlist\n    {\n\tif (int_wordlist == NULL)\n\t{\n\t    int_wordlist = vim_tempname('s', FALSE);\n\t    if (int_wordlist == NULL)\n\t\treturn;\n\t}\n\tfname = int_wordlist;\n    }\n    else\n    {\n\t// If 'spellfile' isn't set figure out a good default value.\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    init_spellfile();\n\t    new_spf = TRUE;\n\t}\n\n\tif (*curwin->w_s->b_p_spf == NUL)\n\t{\n\t    semsg(_(e_option_str_is_not_set), \"spellfile\");\n\t    return;\n\t}\n\tfnamebuf = alloc(MAXPATHL);\n\tif (fnamebuf == NULL)\n\t    return;\n\n\tfor (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i)\n\t{\n\t    copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");\n\t    if (i == idx)\n\t\tbreak;\n\t    if (*spf == NUL)\n\t    {\n\t\tsemsg(_(e_spellfile_does_not_have_nr_entries), idx);\n\t\tvim_free(fnamebuf);\n\t\treturn;\n\t    }\n\t}\n\n\t// Check that the user isn't editing the .add file somewhere.\n\tbuf = buflist_findname_exp(fnamebuf);\n\tif (buf != NULL && buf->b_ml.ml_mfp == NULL)\n\t    buf = NULL;\n\tif (buf != NULL && bufIsChanged(buf))\n\t{\n\t    emsg(_(e_file_is_loaded_in_another_buffer));\n\t    vim_free(fnamebuf);\n\t    return;\n\t}\n\n\tfname = fnamebuf;\n    }\n\n    if (what == SPELL_ADD_BAD || undo)\n    {\n\t// When the word appears as good word we need to remove that one,\n\t// since its flags sort before the one with WF_BANNED.\n\tfd = mch_fopen((char *)fname, \"r\");\n\tif (fd != NULL)\n\t{\n\t    while (!vim_fgets(line, MAXWLEN * 2, fd))\n\t    {\n\t\tfpos = fpos_next;\n\t\tfpos_next = ftell(fd);\n\t\tif (fpos_next < 0)\n\t\t    break;  // should never happen\n\t\tif (STRNCMP(word, line, len) == 0\n\t\t\t&& (line[len] == '/' || line[len] < ' '))\n\t\t{\n\t\t    // Found duplicate word.  Remove it by writing a '#' at\n\t\t    // the start of the line.  Mixing reading and writing\n\t\t    // doesn't work for all systems, close the file first.\n\t\t    fclose(fd);\n\t\t    fd = mch_fopen((char *)fname, \"r+\");\n\t\t    if (fd == NULL)\n\t\t\tbreak;\n\t\t    if (fseek(fd, fpos, SEEK_SET) == 0)\n\t\t    {\n\t\t\tfputc('#', fd);\n\t\t\tif (undo)\n\t\t\t{\n\t\t\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t\t\t    smsg(_(\"Word '%.*s' removed from %s\"),\n\t\t\t\t\t\t\t len, word, NameBuff);\n\t\t\t}\n\t\t    }\n\t\t    if (fseek(fd, fpos_next, SEEK_SET) != 0)\n\t\t    {\n\t\t\tPERROR(_(\"Seek error in spellfile\"));\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t}\n    }\n\n    if (!undo)\n    {\n\tfd = mch_fopen((char *)fname, \"a\");\n\tif (fd == NULL && new_spf)\n\t{\n\t    char_u *p;\n\n\t    // We just initialized the 'spellfile' option and can't open the\n\t    // file.  We may need to create the \"spell\" directory first.  We\n\t    // already checked the runtime directory is writable in\n\t    // init_spellfile().\n\t    if (!dir_of_file_exists(fname) && (p = gettail_sep(fname)) != fname)\n\t    {\n\t\tint c = *p;\n\n\t\t// The directory doesn't exist.  Try creating it and opening\n\t\t// the file again.\n\t\t*p = NUL;\n\t\tvim_mkdir(fname, 0755);\n\t\t*p = c;\n\t\tfd = mch_fopen((char *)fname, \"a\");\n\t    }\n\t}\n\n\tif (fd == NULL)\n\t    semsg(_(e_cant_open_file_str), fname);\n\telse\n\t{\n\t    if (what == SPELL_ADD_BAD)\n\t\tfprintf(fd, \"%.*s/!\\n\", len, word);\n\t    else if (what == SPELL_ADD_RARE)\n\t\tfprintf(fd, \"%.*s/?\\n\", len, word);\n\t    else\n\t\tfprintf(fd, \"%.*s\\n\", len, word);\n\t    fclose(fd);\n\n\t    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);\n\t    smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);\n\t}\n    }\n\n    if (fd != NULL)\n    {\n\t// Update the .add.spl file.\n\tmkspell(1, &fname, FALSE, TRUE, TRUE);\n\n\t// If the .add file is edited somewhere, reload it.\n\tif (buf != NULL)\n\t    buf_reload(buf, buf->b_orig_mode, FALSE);\n\n\tredraw_all_later(SOME_VALID);\n    }\n    vim_free(fnamebuf);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,12 @@\n     long\tfpos, fpos_next = 0;\n     int\t\ti;\n     char_u\t*spf;\n+\n+    if (enc_utf8 && !utf_valid_string(word, NULL))\n+    {\n+\temsg(_(e_illegal_character_in_word));\n+\treturn;\n+    }\n \n     if (idx == 0)\t    // use internal wordlist\n     {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (enc_utf8 && !utf_valid_string(word, NULL))",
                "    {",
                "\temsg(_(e_illegal_character_in_word));",
                "\treturn;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1733",
        "func_name": "vim/skip_string",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.4968.",
        "git_url": "https://github.com/vim/vim/commit/60ae0e71490c97f2871a6344aca61cacf220f813",
        "commit_title": "patch 8.2.4968: reading past end of the line when C-indenting",
        "commit_text": " Problem:    Reading past end of the line when C-indenting. Solution:   Check for NUL.",
        "func_before": "static char_u *\nskip_string(char_u *p)\n{\n    int\t    i;\n\n    // We loop, because strings may be concatenated: \"date\"\"time\".\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    // 'c' or '\\n' or '\\000'\n\t{\n\t    if (p[1] == NUL)\t\t    // ' at end of line\n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    // '\\n' or '\\000'\n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   // '\\000'\n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    // check for trailing '\n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    // start of string\n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    // end of string\n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; // continue for another string\n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    // Raw string: R\"[delim](...)[delim]\"\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; // continue for another string\n\t    }\n\t}\n\tbreak;\t\t\t\t    // no string found\n    }\n    if (!*p)\n\t--p;\t\t\t\t    // backup from NUL\n    return p;\n}",
        "func": "static char_u *\nskip_string(char_u *p)\n{\n    int\t    i;\n\n    // We loop, because strings may be concatenated: \"date\"\"time\".\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    // 'c' or '\\n' or '\\000'\n\t{\n\t    if (p[1] == NUL)\t\t    // ' at end of line\n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    // '\\n' or '\\000'\n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   // '\\000'\n\t\t    ++i;\n\t    }\n\t    if (p[i - 1] != NUL && p[i] == '\\'')    // check for trailing '\n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    // start of string\n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    // end of string\n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; // continue for another string\n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    // Raw string: R\"[delim](...)[delim]\"\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; // continue for another string\n\t    }\n\t}\n\tbreak;\t\t\t\t    // no string found\n    }\n    if (!*p)\n\t--p;\t\t\t\t    // backup from NUL\n    return p;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t\twhile (vim_isdigit(p[i - 1]))   // '\\000'\n \t\t    ++i;\n \t    }\n-\t    if (p[i] == '\\'')\t\t    // check for trailing '\n+\t    if (p[i - 1] != NUL && p[i] == '\\'')    // check for trailing '\n \t    {\n \t\tp += i;\n \t\tcontinue;",
        "diff_line_info": {
            "deleted_lines": [
                "\t    if (p[i] == '\\'')\t\t    // check for trailing '"
            ],
            "added_lines": [
                "\t    if (p[i - 1] != NUL && p[i] == '\\'')    // check for trailing '"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1886",
        "func_name": "vim/do_put",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/2a585c85013be22f59f184d49612074fd9b115d7",
        "commit_title": "patch 8.2.5016: access before start of text with a put command",
        "commit_text": " Problem:    Access before start of text with a put command. Solution:   Check the length is more than zero.",
        "func_before": "void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, padd with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    // Skip mark_adjust when adding lines after the last one, there\n\t    // can't be marks there. But still needed in diff mode.\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t\tcurbuf->b_op_end.col = col - 1\n\t\t\t\t- mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}",
        "func": "void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, padd with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    // Skip mark_adjust when adding lines after the last one, there\n\t    // can't be marks there. But still needed in diff mode.\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -696,9 +696,12 @@\n \t    len = STRLEN(y_array[y_size - 1]);\n \t    col = (colnr_T)len - lendiff;\n \t    if (col > 1)\n-\t\tcurbuf->b_op_end.col = col - 1\n-\t\t\t\t- mb_head_off(y_array[y_size - 1],\n+\t    {\n+\t\tcurbuf->b_op_end.col = col - 1;\n+\t\tif (len > 0)\n+\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n \t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n+\t    }\n \t    else\n \t\tcurbuf->b_op_end.col = 0;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tcurbuf->b_op_end.col = col - 1",
                "\t\t\t\t- mb_head_off(y_array[y_size - 1],"
            ],
            "added_lines": [
                "\t    {",
                "\t\tcurbuf->b_op_end.col = col - 1;",
                "\t\tif (len > 0)",
                "\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],",
                "\t    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1942",
        "func_name": "vim/buflist_getfile",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/71223e2db87c2bf3b09aecb46266b56cda26191d",
        "commit_title": "patch 8.2.5043: can open a cmdline window from a substitute expression",
        "commit_text": " Problem:    Can open a cmdline window from a substitute expression. Solution:   Disallow opening a command line window when text or buffer is             locked.",
        "func_before": "int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn FAIL;\n    }\n    if (curbuf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}",
        "func": "int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_or_buf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,12 +24,7 @@\n     if (buf == curbuf)\n \treturn OK;\n \n-    if (text_locked())\n-    {\n-\ttext_locked_msg();\n-\treturn FAIL;\n-    }\n-    if (curbuf_locked())\n+    if (text_or_buf_locked())\n \treturn FAIL;\n \n     // altfpos may be changed by getfile(), get it now",
        "diff_line_info": {
            "deleted_lines": [
                "    if (text_locked())",
                "    {",
                "\ttext_locked_msg();",
                "\treturn FAIL;",
                "    }",
                "    if (curbuf_locked())"
            ],
            "added_lines": [
                "    if (text_or_buf_locked())"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1942",
        "func_name": "vim/win_goto",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/71223e2db87c2bf3b09aecb46266b56cda26191d",
        "commit_title": "patch 8.2.5043: can open a cmdline window from a substitute expression",
        "commit_text": " Problem:    Can open a cmdline window from a substitute expression. Solution:   Disallow opening a command line window when text or buffer is             locked.",
        "func_before": "void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_locked())\n    {\n\tbeep_flush();\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n\treturn;\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}",
        "func": "void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,14 +14,11 @@\n \treturn;\n     }\n #endif\n-    if (text_locked())\n+    if (text_or_buf_locked())\n     {\n \tbeep_flush();\n-\ttext_locked_msg();\n \treturn;\n     }\n-    if (curbuf_locked())\n-\treturn;\n \n     if (wp->w_buffer != curbuf)\n \treset_VIsual_and_resel();",
        "diff_line_info": {
            "deleted_lines": [
                "    if (text_locked())",
                "\ttext_locked_msg();",
                "    if (curbuf_locked())",
                "\treturn;"
            ],
            "added_lines": [
                "    if (text_or_buf_locked())"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1942",
        "func_name": "vim/open_cmdwin",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/71223e2db87c2bf3b09aecb46266b56cda26191d",
        "commit_title": "patch 8.2.5043: can open a cmdline window from a substitute expression",
        "commit_text": " Problem:    Can open a cmdline window from a substitute expression. Solution:   Disallow opening a command line window when text or buffer is             locked.",
        "func_before": "static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = MODE_NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    i = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = i;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == K_XF2)\t// :qa typed\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"qa\");\n\t    cmdwin_result = CAR;\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    if (ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    if (cmdwin_result == K_IGNORE)\n\t    {\n\t\tset_cmdspos_cursor();\n\t\tredrawcmd();\n\t    }\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    setmouse();\n\n    return cmdwin_result;\n}",
        "func": "static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this when text or buffer is locked.\n    if (text_or_buf_locked())\n\treturn K_IGNORE;\n\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = MODE_NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    i = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = i;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == K_XF2)\t// :qa typed\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"qa\");\n\t    cmdwin_result = CAR;\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    if (ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    if (cmdwin_result == K_IGNORE)\n\t    {\n\t\tset_cmdspos_cursor();\n\t\tredrawcmd();\n\t    }\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    setmouse();\n\n    return cmdwin_result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,10 @@\n     int\t\t\tsave_KeyTyped;\n #endif\n \n+    // Can't do this when text or buffer is locked.\n+    if (text_or_buf_locked())\n+\treturn K_IGNORE;\n+\n     // Can't do this recursively.  Can't do it when typing a password.\n     if (cmdwin_type != 0\n # if defined(FEAT_CRYPT) || defined(FEAT_EVAL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // Can't do this when text or buffer is locked.",
                "    if (text_or_buf_locked())",
                "\treturn K_IGNORE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-4781",
        "func_name": "vim/win_exchange",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1873.",
        "git_url": "https://github.com/vim/vim/commit/f6d28fe2c95c678cc3202cc5dc825a3fcc709e93",
        "commit_title": "patch 9.0.1873: [security] heap-buffer-overflow in vim_regsub_both",
        "commit_text": " Problem:  heap-buffer-overflow in vim_regsub_both Solution: Disallow exchanging windows when textlock is active ",
        "func_before": "static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(UPD_NOT_VALID);\n}",
        "func": "static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(UPD_NOT_VALID);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,11 @@\n     if (ERROR_IF_ANY_POPUP_WINDOW)\n \treturn;\n     if (ONE_WINDOW)\t    // just one window\n+    {\n+\tbeep_flush();\n+\treturn;\n+    }\n+    if (text_or_buf_locked())\n     {\n \tbeep_flush();\n \treturn;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    {",
                "\tbeep_flush();",
                "\treturn;",
                "    }",
                "    if (text_or_buf_locked())"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-5344",
        "func_name": "vim/trunc_string",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1969.",
        "git_url": "https://github.com/vim/vim/commit/3bd7fa12e146c6051490d048a4acbfba974eeb04",
        "commit_title": "patch 9.0.1969: [security] buffer-overflow in trunc_string()",
        "commit_text": " Problem:  buffer-overflow in trunc_string() Solution: Add NULL at end of buffer  Currently trunc_string() assumes that when the string is too long, buf[e-1] will always be writeable. But that assumption may not always be true. The condition currently looks like this      else if (e + 3 < buflen)     [...]     else     { \t// can't fit in the \"...\", just truncate it \tbuf[e - 1] = NUL;     }  but this means, we may run into the last else clause with e still being larger than buflen. So a buffer overflow occurs.  So instead of using `buf[e - 1]`, let's just always truncate at `buf[buflen - 1]` which should always be writable. ",
        "func_before": "void\ntrunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[e - 1] = NUL;\n    }\n}",
        "func": "void\ntrunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[buflen - 1] = NUL;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -112,6 +112,6 @@\n     else\n     {\n \t// can't fit in the \"...\", just truncate it\n-\tbuf[e - 1] = NUL;\n+\tbuf[buflen - 1] = NUL;\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tbuf[e - 1] = NUL;"
            ],
            "added_lines": [
                "\tbuf[buflen - 1] = NUL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1170",
        "func_name": "vim/do_put",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1376.",
        "git_url": "https://github.com/vim/vim/commit/1c73b65229c25e3c1fd8824ba958f7cc4d604f9c",
        "commit_title": "patch 9.0.1376: accessing invalid memory with put in Visual block mode",
        "commit_text": " Problem:    Accessing invalid memory with put in Visual block mode. Solution:   Adjust the cursor column if needed.",
        "func_before": "void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int\t\t    spaces = 0;\n\t    char\t    shortline;\n\t    chartabsize_T   cts;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    init_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum, 0,\n\t\t\t\t\t\t\t\t  oldp, oldp);\n\n\t    while (cts.cts_vcol < col && *cts.cts_ptr != NUL)\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(&cts);\n\t\tcts.cts_vcol += incr;\n\t    }\n\t    vcol = cts.cts_vcol;\n\t    ptr = cts.cts_ptr;\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    clear_chartabsize_arg(&cts);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, pad with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tinit_chartabsize_arg(&cts, curwin, 0, 0,\n\t\t\t\t\t\t      y_array[i], y_array[i]);\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t{\n\t\t    spaces -= lbr_chartabsize(&cts);\n\t\t    ++cts.cts_ptr;\n\t\t    cts.cts_vcol = 0;\n\t\t}\n\t\tclear_chartabsize_arg(&cts);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tif (curbuf->b_op_end.col < 0)\n\t    curbuf->b_op_end.col = 0;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Note: this may free \"newp\"\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    inserted_bytes(lnum, col, totlen);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    mark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}",
        "func": "void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int\t\t    spaces = 0;\n\t    char\t    shortline;\n\t    chartabsize_T   cts;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    init_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum, 0,\n\t\t\t\t\t\t\t\t  oldp, oldp);\n\n\t    while (cts.cts_vcol < col && *cts.cts_ptr != NUL)\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(&cts);\n\t\tcts.cts_vcol += incr;\n\t    }\n\t    vcol = cts.cts_vcol;\n\t    ptr = cts.cts_ptr;\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    clear_chartabsize_arg(&cts);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, pad with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tinit_chartabsize_arg(&cts, curwin, 0, 0,\n\t\t\t\t\t\t      y_array[i], y_array[i]);\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t{\n\t\t    spaces -= lbr_chartabsize(&cts);\n\t\t    ++cts.cts_ptr;\n\t\t    cts.cts_vcol = 0;\n\t\t}\n\t\tclear_chartabsize_arg(&cts);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces > 0)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tif (curbuf->b_op_end.col < 0)\n\t    curbuf->b_op_end.col = 0;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Note: this may free \"newp\"\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    inserted_bytes(lnum, col, totlen);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    mark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\n    // Make sure the cursor is not after the NUL.\n    int len = (int)STRLEN(ml_get_curline());\n    if (curwin->w_cursor.col > len)\n    {\n\tif (cur_ve_flags == VE_ALL)\n\t    curwin->w_cursor.coladd = curwin->w_cursor.col - len;\n\tcurwin->w_cursor.col = len;\n    }\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -404,7 +404,7 @@\n \t\tptr += yanklen;\n \n \t\t// insert block's trailing spaces only if there's text behind\n-\t\tif ((j < count - 1 || !shortline) && spaces)\n+\t\tif ((j < count - 1 || !shortline) && spaces > 0)\n \t\t{\n \t\t    vim_memset(ptr, ' ', (size_t)spaces);\n \t\t    ptr += spaces;\n@@ -760,6 +760,15 @@\n     msgmore(nr_lines);\n     curwin->w_set_curswant = TRUE;\n \n+    // Make sure the cursor is not after the NUL.\n+    int len = (int)STRLEN(ml_get_curline());\n+    if (curwin->w_cursor.col > len)\n+    {\n+\tif (cur_ve_flags == VE_ALL)\n+\t    curwin->w_cursor.coladd = curwin->w_cursor.col - len;\n+\tcurwin->w_cursor.col = len;\n+    }\n+\n end:\n     if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif ((j < count - 1 || !shortline) && spaces)"
            ],
            "added_lines": [
                "\t\tif ((j < count - 1 || !shortline) && spaces > 0)",
                "    // Make sure the cursor is not after the NUL.",
                "    int len = (int)STRLEN(ml_get_curline());",
                "    if (curwin->w_cursor.col > len)",
                "    {",
                "\tif (cur_ve_flags == VE_ALL)",
                "\t    curwin->w_cursor.coladd = curwin->w_cursor.col - len;",
                "\tcurwin->w_cursor.col = len;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-27585",
        "func_name": "pjsip/pjproject/get_name",
        "description": "PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.13 and prior affects applications that use PJSIP DNS resolver. It doesn't affect PJSIP users who do not utilise PJSIP DNS resolver. This vulnerability is related to CVE-2022-24793. The difference is that this issue is in parsing the query record `parse_query()`, while the issue in CVE-2022-24793 is in `parse_rr()`. A patch is available as commit `d1c5e4d` in the `master` branch. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver implementation instead.",
        "git_url": "https://github.com/pjsip/pjproject/commit/d1c5e4da5bae7f220bc30719888bb389c905c0c5",
        "commit_title": "Merge pull request from GHSA-q9cp-8wcq-7pfr",
        "commit_text": " * Prevent heap buffer overflow when parsing DNS packet  * Fixed incorrect check in get_name*()",
        "func_before": "static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Retrieve the name from that offset. */\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n\n    return PJ_SUCCESS;\n}",
        "func": "static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Retrieve the name from that offset. */\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,9 @@\n         /* Too many name recursion */\n         return PJLIB_UTIL_EDNSINNAMEPTR;\n     }\n+\n+    if (start >= max)\n+        return PJLIB_UTIL_EDNSINNAMEPTR;\n \n     p = start;\n     while (*p) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (start >= max)",
                "        return PJLIB_UTIL_EDNSINNAMEPTR;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-27585",
        "func_name": "pjsip/pjproject/parse_rr",
        "description": "PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.13 and prior affects applications that use PJSIP DNS resolver. It doesn't affect PJSIP users who do not utilise PJSIP DNS resolver. This vulnerability is related to CVE-2022-24793. The difference is that this issue is in parsing the query record `parse_query()`, while the issue in CVE-2022-24793 is in `parse_rr()`. A patch is available as commit `d1c5e4d` in the `master` branch. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver implementation instead.",
        "git_url": "https://github.com/pjsip/pjproject/commit/d1c5e4da5bae7f220bc30719888bb389c905c0c5",
        "commit_title": "Merge pull request from GHSA-q9cp-8wcq-7pfr",
        "commit_text": " * Prevent heap buffer overflow when parsing DNS packet  * Fixed incorrect check in get_name*()",
        "func_before": "static pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool,\n                            const pj_uint8_t *pkt,\n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    rr->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &rr->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p+10 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&rr->type, p, 2);\n    rr->type = pj_ntohs(rr->type);\n    p += 2;\n    \n    /* Get the class */\n    pj_memcpy(&rr->dnsclass, p, 2);\n    rr->dnsclass = pj_ntohs(rr->dnsclass);\n    p += 2;\n\n    /* Class MUST be IN */\n    if (rr->dnsclass != 1) {\n        /* Class is not IN, return error only if type is known (see #1889) */\n        if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  ||\n            rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    ||\n            rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV)\n        {\n            return PJLIB_UTIL_EDNSINCLASS;\n        }\n    }\n\n    /* Get TTL */\n    pj_memcpy(&rr->ttl, p, 4);\n    rr->ttl = pj_ntohl(rr->ttl);\n    p += 4;\n\n    /* Get rdlength */\n    pj_memcpy(&rr->rdlength, p, 2);\n    rr->rdlength = pj_ntohs(rr->rdlength);\n    p += 2;\n\n    /* Check that length is valid */\n    if (p + rr->rdlength > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Parse some well known records */\n    if (rr->type == PJ_DNS_TYPE_A) {\n        pj_memcpy(&rr->rdata.a.ip_addr, p, 4);\n        p += 4;\n\n    } else if (rr->type == PJ_DNS_TYPE_AAAA) {\n        pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16);\n        p += 16;\n\n    } else if (rr->type == PJ_DNS_TYPE_CNAME ||\n               rr->type == PJ_DNS_TYPE_NS ||\n               rr->type == PJ_DNS_TYPE_PTR) \n    {\n\n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.cname.name.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.cname.name);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        p += name_part_len;\n\n    } else if (rr->type == PJ_DNS_TYPE_SRV) {\n\n        /* Priority */\n        pj_memcpy(&rr->rdata.srv.prio, p, 2);\n        rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio);\n        p += 2;\n\n        /* Weight */\n        pj_memcpy(&rr->rdata.srv.weight, p, 2);\n        rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight);\n        p += 2;\n\n        /* Port */\n        pj_memcpy(&rr->rdata.srv.port, p, 2);\n        rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port);\n        p += 2;\n        \n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.srv.target.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.srv.target);\n        if (status != PJ_SUCCESS)\n            return status;\n        p += name_part_len;\n\n    } else {\n        /* Copy the raw data */\n        rr->data = pj_pool_alloc(pool, rr->rdlength);\n        pj_memcpy(rr->data, p, rr->rdlength);\n\n        p += rr->rdlength;\n    }\n\n    *parsed_len = (int)(p - start);\n    return PJ_SUCCESS;\n}",
        "func": "static pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool,\n                            const pj_uint8_t *pkt,\n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    rr->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &rr->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p+10 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&rr->type, p, 2);\n    rr->type = pj_ntohs(rr->type);\n    p += 2;\n    \n    /* Get the class */\n    pj_memcpy(&rr->dnsclass, p, 2);\n    rr->dnsclass = pj_ntohs(rr->dnsclass);\n    p += 2;\n\n    /* Class MUST be IN */\n    if (rr->dnsclass != 1) {\n        /* Class is not IN, return error only if type is known (see #1889) */\n        if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  ||\n            rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    ||\n            rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV)\n        {\n            return PJLIB_UTIL_EDNSINCLASS;\n        }\n    }\n\n    /* Get TTL */\n    pj_memcpy(&rr->ttl, p, 4);\n    rr->ttl = pj_ntohl(rr->ttl);\n    p += 4;\n\n    /* Get rdlength */\n    pj_memcpy(&rr->rdlength, p, 2);\n    rr->rdlength = pj_ntohs(rr->rdlength);\n    p += 2;\n\n    /* Check that length is valid */\n    if (p + rr->rdlength > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Parse some well known records */\n    if (rr->type == PJ_DNS_TYPE_A) {\n        if (p + 4 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n        pj_memcpy(&rr->rdata.a.ip_addr, p, 4);\n        p += 4;\n\n    } else if (rr->type == PJ_DNS_TYPE_AAAA) {\n        if (p + 16 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n        pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16);\n        p += 16;\n\n    } else if (rr->type == PJ_DNS_TYPE_CNAME ||\n               rr->type == PJ_DNS_TYPE_NS ||\n               rr->type == PJ_DNS_TYPE_PTR) \n    {\n\n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.cname.name.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.cname.name);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        p += name_part_len;\n\n    } else if (rr->type == PJ_DNS_TYPE_SRV) {\n        if (p + 6 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n\n        /* Priority */\n        pj_memcpy(&rr->rdata.srv.prio, p, 2);\n        rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio);\n        p += 2;\n\n        /* Weight */\n        pj_memcpy(&rr->rdata.srv.weight, p, 2);\n        rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight);\n        p += 2;\n\n        /* Port */\n        pj_memcpy(&rr->rdata.srv.port, p, 2);\n        rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port);\n        p += 2;\n        \n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.srv.target.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.srv.target);\n        if (status != PJ_SUCCESS)\n            return status;\n        p += name_part_len;\n\n    } else {\n        /* Copy the raw data */\n        rr->data = pj_pool_alloc(pool, rr->rdlength);\n        pj_memcpy(rr->data, p, rr->rdlength);\n\n        p += rr->rdlength;\n    }\n\n    *parsed_len = (int)(p - start);\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -64,10 +64,14 @@\n \n     /* Parse some well known records */\n     if (rr->type == PJ_DNS_TYPE_A) {\n+        if (p + 4 > max)\n+            return PJLIB_UTIL_EDNSINSIZE;\n         pj_memcpy(&rr->rdata.a.ip_addr, p, 4);\n         p += 4;\n \n     } else if (rr->type == PJ_DNS_TYPE_AAAA) {\n+        if (p + 16 > max)\n+            return PJLIB_UTIL_EDNSINSIZE;\n         pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16);\n         p += 16;\n \n@@ -93,6 +97,8 @@\n         p += name_part_len;\n \n     } else if (rr->type == PJ_DNS_TYPE_SRV) {\n+        if (p + 6 > max)\n+            return PJLIB_UTIL_EDNSINSIZE;\n \n         /* Priority */\n         pj_memcpy(&rr->rdata.srv.prio, p, 2);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (p + 4 > max)",
                "            return PJLIB_UTIL_EDNSINSIZE;",
                "        if (p + 16 > max)",
                "            return PJLIB_UTIL_EDNSINSIZE;",
                "        if (p + 6 > max)",
                "            return PJLIB_UTIL_EDNSINSIZE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-27585",
        "func_name": "pjsip/pjproject/get_name_len",
        "description": "PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.13 and prior affects applications that use PJSIP DNS resolver. It doesn't affect PJSIP users who do not utilise PJSIP DNS resolver. This vulnerability is related to CVE-2022-24793. The difference is that this issue is in parsing the query record `parse_query()`, while the issue in CVE-2022-24793 is in `parse_rr()`. A patch is available as commit `d1c5e4d` in the `master` branch. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver implementation instead.",
        "git_url": "https://github.com/pjsip/pjproject/commit/d1c5e4da5bae7f220bc30719888bb389c905c0c5",
        "commit_title": "Merge pull request from GHSA-q9cp-8wcq-7pfr",
        "commit_text": " * Prevent heap buffer overflow when parsing DNS packet  * Fixed incorrect check in get_name*()",
        "func_before": "static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n                                const pj_uint8_t *start, const pj_uint8_t *max, \n                                int *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            int ptr_len = 0;\n            int dummy;\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Get the name length from that offset. */\n            status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n                                  &dummy, &ptr_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            *parsed_len += 2;\n            *name_len += ptr_len;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            p += (label_len + 1);\n            *parsed_len += (label_len + 1);\n\n            if (*p != 0)\n                ++label_len;\n            \n            *name_len += label_len;\n        }\n    }\n    ++p;\n    (*parsed_len)++;\n\n    return PJ_SUCCESS;\n}",
        "func": "static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n                                const pj_uint8_t *start, const pj_uint8_t *max, \n                                int *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            int ptr_len = 0;\n            int dummy;\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Get the name length from that offset. */\n            status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n                                  &dummy, &ptr_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            *parsed_len += 2;\n            *name_len += ptr_len;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            p += (label_len + 1);\n            *parsed_len += (label_len + 1);\n\n            if (*p != 0)\n                ++label_len;\n            \n            *name_len += label_len;\n        }\n    }\n    ++p;\n    (*parsed_len)++;\n\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,9 @@\n         /* Too many name recursion */\n         return PJLIB_UTIL_EDNSINNAMEPTR;\n     }\n+\n+    if (start >= max)\n+        return PJLIB_UTIL_EDNSINNAMEPTR;\n \n     *name_len = *parsed_len = 0;\n     p = start;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (start >= max)",
                "        return PJLIB_UTIL_EDNSINNAMEPTR;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1448",
        "func_name": "gpac/gf_m2ts_process_sdt",
        "description": "A vulnerability, which was classified as problematic, was found in GPAC 2.3-DEV-rev35-gbbca86917-master. This affects the function gf_m2ts_process_sdt of the file media_tools/mpegts.c. The manipulation leads to heap-based buffer overflow. Attacking locally is a requirement. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The identifier VDB-223293 was assigned to this vulnerability.",
        "git_url": "https://github.com/gpac/gpac/commit/8db20cb634a546c536c31caac94e1f74b778b463",
        "commit_title": "m2ts: check descs_size read from input to prevent overflow (#2388)",
        "commit_text": "",
        "func_before": "static void gf_m2ts_process_sdt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 pos, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SDT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tif (table_id != GF_M2TS_TABLE_ID_SDT_ACTUAL) {\n\t\treturn;\n\t}\n\n\tgf_m2ts_reset_sdt(ts);\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] SDT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\t//orig_net_id = (data[0] << 8) | data[1];\n\tpos = 3;\n\twhile (pos < data_size) {\n\t\tGF_M2TS_SDT *sdt;\n\t\tu32 descs_size, d_pos, ulen;\n\n\t\tGF_SAFEALLOC(sdt, GF_M2TS_SDT);\n\t\tif (!sdt) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to create SDT\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tgf_list_add(ts->SDTs, sdt);\n\n\t\tsdt->service_id = (data[pos]<<8) + data[pos+1];\n\t\tsdt->EIT_schedule = (data[pos+2] & 0x2) ? 1 : 0;\n\t\tsdt->EIT_present_following = (data[pos+2] & 0x1);\n\t\tsdt->running_status = (data[pos+3]>>5) & 0x7;\n\t\tsdt->free_CA_mode = (data[pos+3]>>4) & 0x1;\n\t\tdescs_size = ((data[pos+3]&0xf)<<8) | data[pos+4];\n\t\tpos += 5;\n\n\t\td_pos = 0;\n\t\twhile (d_pos < descs_size) {\n\t\t\tu8 d_tag = data[pos+d_pos];\n\t\t\tu8 d_len = data[pos+d_pos+1];\n\n\t\t\tswitch (d_tag) {\n\t\t\tcase GF_M2TS_DVB_SERVICE_DESCRIPTOR:\n\t\t\t\tif (sdt->provider) gf_free(sdt->provider);\n\t\t\t\tsdt->provider = NULL;\n\t\t\t\tif (sdt->service) gf_free(sdt->service);\n\t\t\t\tsdt->service = NULL;\n\n\t\t\t\td_pos+=2;\n\t\t\t\tsdt->service_type = data[pos+d_pos];\n\t\t\t\tulen = data[pos+d_pos+1];\n\t\t\t\td_pos += 2;\n\t\t\t\tsdt->provider = (char*)gf_malloc(sizeof(char)*(ulen+1));\n\t\t\t\tmemcpy(sdt->provider, data+pos+d_pos, sizeof(char)*ulen);\n\t\t\t\tsdt->provider[ulen] = 0;\n\t\t\t\td_pos += ulen;\n\n\t\t\t\tulen = data[pos+d_pos];\n\t\t\t\td_pos += 1;\n\t\t\t\tsdt->service = (char*)gf_malloc(sizeof(char)*(ulen+1));\n\t\t\t\tmemcpy(sdt->service, data+pos+d_pos, sizeof(char)*ulen);\n\t\t\t\tsdt->service[ulen] = 0;\n\t\t\t\td_pos += ulen;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) not supported\\n\", d_tag));\n\t\t\t\td_pos += d_len;\n\t\t\t\tif (d_len == 0) d_pos = descs_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpos += descs_size;\n\t}\n\tevt_type = GF_M2TS_EVT_SDT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}",
        "func": "static void gf_m2ts_process_sdt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 pos, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SDT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tif (table_id != GF_M2TS_TABLE_ID_SDT_ACTUAL) {\n\t\treturn;\n\t}\n\n\tgf_m2ts_reset_sdt(ts);\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] SDT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\t//orig_net_id = (data[0] << 8) | data[1];\n\tpos = 3;\n\twhile (pos < data_size) {\n\t\tGF_M2TS_SDT *sdt;\n\t\tu32 descs_size, d_pos, ulen;\n\n\t\tGF_SAFEALLOC(sdt, GF_M2TS_SDT);\n\t\tif (!sdt) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to create SDT\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tgf_list_add(ts->SDTs, sdt);\n\n\t\tsdt->service_id = (data[pos]<<8) + data[pos+1];\n\t\tsdt->EIT_schedule = (data[pos+2] & 0x2) ? 1 : 0;\n\t\tsdt->EIT_present_following = (data[pos+2] & 0x1);\n\t\tsdt->running_status = (data[pos+3]>>5) & 0x7;\n\t\tsdt->free_CA_mode = (data[pos+3]>>4) & 0x1;\n\t\tdescs_size = ((data[pos+3]&0xf)<<8) | data[pos+4];\n\t\tpos += 5;\n\n\t\tif (pos+descs_size > data_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid descriptors size read from data (%u)\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\td_pos = 0;\n\t\twhile (d_pos < descs_size) {\n\t\t\tu8 d_tag = data[pos+d_pos];\n\t\t\tu8 d_len = data[pos+d_pos+1];\n\n\t\t\tswitch (d_tag) {\n\t\t\tcase GF_M2TS_DVB_SERVICE_DESCRIPTOR:\n\t\t\t\tif (sdt->provider) gf_free(sdt->provider);\n\t\t\t\tsdt->provider = NULL;\n\t\t\t\tif (sdt->service) gf_free(sdt->service);\n\t\t\t\tsdt->service = NULL;\n\n\t\t\t\td_pos+=2;\n\t\t\t\tsdt->service_type = data[pos+d_pos];\n\t\t\t\tulen = data[pos+d_pos+1];\n\t\t\t\td_pos += 2;\n\t\t\t\tsdt->provider = (char*)gf_malloc(sizeof(char)*(ulen+1));\n\t\t\t\tmemcpy(sdt->provider, data+pos+d_pos, sizeof(char)*ulen);\n\t\t\t\tsdt->provider[ulen] = 0;\n\t\t\t\td_pos += ulen;\n\n\t\t\t\tulen = data[pos+d_pos];\n\t\t\t\td_pos += 1;\n\t\t\t\tsdt->service = (char*)gf_malloc(sizeof(char)*(ulen+1));\n\t\t\t\tmemcpy(sdt->service, data+pos+d_pos, sizeof(char)*ulen);\n\t\t\t\tsdt->service[ulen] = 0;\n\t\t\t\td_pos += ulen;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) not supported\\n\", d_tag));\n\t\t\t\td_pos += d_len;\n\t\t\t\tif (d_len == 0) d_pos = descs_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpos += descs_size;\n\t}\n\tevt_type = GF_M2TS_EVT_SDT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,6 +51,11 @@\n \t\tdescs_size = ((data[pos+3]&0xf)<<8) | data[pos+4];\n \t\tpos += 5;\n \n+\t\tif (pos+descs_size > data_size) {\n+\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid descriptors size read from data (%u)\\n\"));\n+\t\t\treturn;\n+\t\t}\n+\n \t\td_pos = 0;\n \t\twhile (d_pos < descs_size) {\n \t\t\tu8 d_tag = data[pos+d_pos];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (pos+descs_size > data_size) {",
                "\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid descriptors size read from data (%u)\\n\"));",
                "\t\t\treturn;",
                "\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1448",
        "func_name": "gpac/gf_m2ts_flush_pes",
        "description": "A vulnerability, which was classified as problematic, was found in GPAC 2.3-DEV-rev35-gbbca86917-master. This affects the function gf_m2ts_process_sdt of the file media_tools/mpegts.c. The manipulation leads to heap-based buffer overflow. Attacking locally is a requirement. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. The identifier VDB-223293 was assigned to this vulnerability.",
        "git_url": "https://github.com/gpac/gpac/commit/8db20cb634a546c536c31caac94e1f74b778b463",
        "commit_title": "m2ts: check descs_size read from input to prevent overflow (#2388)",
        "commit_text": "",
        "func_before": "void gf_m2ts_flush_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, u32 force_flush_type)\n{\n\tGF_M2TS_PESHeader pesh;\n\tif (!ts) return;\n\n\t/*we need at least a full, valid start code and PES header !!*/\n\tif ((pes->pck_data_len >= 4) && !pes->pck_data[0] && !pes->pck_data[1] && (pes->pck_data[2] == 0x1)) {\n\t\tu32 len;\n\t\tBool has_pes_header = GF_TRUE;\n\t\tBool has_data = GF_TRUE;\n\t\tu32 stream_id = pes->pck_data[3];\n\t\tBool same_pts = GF_FALSE;\n\n\t\tswitch (stream_id) {\n\t\tcase GF_M2_STREAMID_PADDING:\n\t\t\thas_data = GF_FALSE;\n\t\tcase GF_M2_STREAMID_PROGRAM_STREAM_MAP:\n\t\tcase GF_M2_STREAMID_PRIVATE_2:\n\t\tcase GF_M2_STREAMID_ECM:\n\t\tcase GF_M2_STREAMID_EMM:\n\t\tcase GF_M2_STREAMID_PROGRAM_STREAM_DIRECTORY:\n\t\tcase GF_M2_STREAMID_DSMCC:\n\t\tcase GF_M2_STREAMID_H222_TYPE_E:\n\t\t\thas_pes_header = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (has_pes_header) {\n\n\t\t\t/*OK read header*/\n\t\t\tgf_m2ts_pes_header(pes, pes->pck_data + 3, pes->pck_data_len - 3, &pesh);\n\n\t\t\t/*send PES timing*/\n\t\t\tif (ts->notify_pes_timing) {\n\t\t\t\tGF_M2TS_PES_PCK pck;\n\t\t\t\tmemset(&pck, 0, sizeof(GF_M2TS_PES_PCK));\n\t\t\t\tpck.PTS = pesh.PTS;\n\t\t\t\tpck.DTS = pesh.DTS;\n\t\t\t\tpck.stream = pes;\n\t\t\t\tif (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP;\n\t\t\t\tpes->pes_end_packet_number = ts->pck_number;\n\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PES_TIMING, &pck);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Got PES header DTS %d PTS %d\\n\", pes->pid, pesh.DTS, pesh.PTS));\n\n\t\t\tif (pesh.PTS) {\n\t\t\t\tif (pesh.PTS == pes->PTS) {\n\t\t\t\t\tsame_pts = GF_TRUE;\n\t\t\t\t\tif ((pes->stream_type==GF_M2TS_AUDIO_TRUEHD) || (pes->stream_type==GF_M2TS_AUDIO_EC3)) {\n\t\t\t\t\t\tsame_pts = GF_FALSE;\n\t\t\t\t\t} else if (!pes->is_resume) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - same PTS \"LLU\" for two consecutive PES packets \\n\", pes->pid, pes->PTS));\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef GPAC_DISABLE_LOG\n\t\t\t\t/*FIXME - this test should only be done for non bi-directionally coded media\n\t\t\t\telse if (pesh.PTS < pes->PTS) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - PTS \"LLU\" less than previous packet PTS \"LLU\"\\n\", pes->pid, pesh.PTS, pes->PTS) );\n\t\t\t\t}\n\t\t\t\t*/\n#endif\n\n\t\t\t\tpes->PTS = pesh.PTS;\n#ifndef GPAC_DISABLE_LOG\n\t\t\t\t{\n\t\t\t\t\tif (!pes->is_resume && pes->DTS && (pesh.DTS == pes->DTS)) {\n\t\t\t\t\t\tif ((pes->stream_type==GF_M2TS_AUDIO_TRUEHD) || (pes->stream_type==GF_M2TS_AUDIO_EC3)) {\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - same DTS \"LLU\" for two consecutive PES packets \\n\", pes->pid, pes->DTS));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pesh.DTS < pes->DTS) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - DTS \"LLU\" less than previous DTS \"LLU\"\\n\", pes->pid, pesh.DTS, pes->DTS));\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tpes->DTS = pesh.DTS;\n\t\t\t}\n\t\t\t/*no PTSs were coded, same time*/\n\t\t\telse if (!pesh.hdr_data_len) {\n\t\t\t\tsame_pts = GF_TRUE;\n\t\t\t}\n\n\t\t\tpes->is_resume = GF_FALSE;\n\n\t\t\t/*3-byte start-code + 6 bytes header + hdr extensions*/\n\t\t\tlen = 9 + pesh.hdr_data_len;\n\n\t\t} else {\n\t\t\tif (!has_data) goto exit;\n\t\t\t\n\t\t\t/*3-byte start-code + 1 byte streamid*/\n\t\t\tlen = 4;\n\t\t\tmemset(&pesh, 0, sizeof(pesh));\n\t\t}\n\n\t\tif ((u8) pes->pck_data[3]==0xfa) {\n\t\t\tGF_M2TS_SL_PCK sl_pck;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] SL Packet in PES for %d - ES ID %d\\n\", pes->pid, pes->mpeg4_es_id));\n\n\t\t\tif (pes->pck_data_len > len) {\n\t\t\t\tsl_pck.data = (char *)pes->pck_data + len;\n\t\t\t\tsl_pck.data_len = pes->pck_data_len - len;\n\t\t\t\tsl_pck.stream = (GF_M2TS_ES *)pes;\n\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SL_PCK, &sl_pck);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Bad SL Packet size: (%d indicated < %d header)\\n\", pes->pid, pes->pck_data_len, len));\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (pes->reframe) {\n\t\t\tu32 remain = 0;\n\t\t\tu32 offset = len;\n\n\t\t\tif (pesh.pck_len && (pesh.pck_len-3-pesh.hdr_data_len != pes->pck_data_len-len)) {\n\t\t\t\tif (!force_flush_type) {\n\t\t\t\t\tpes->is_resume = GF_TRUE;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (force_flush_type==1) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PES payload size %d but received %d bytes\\n\", pes->pid, (u32) ( pesh.pck_len-3-pesh.hdr_data_len), pes->pck_data_len-len));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//copy over the remaining of previous PES payload before start of this PES payload\n\t\t\tif (pes->prev_data_len) {\n\t\t\t\tif (pes->prev_data_len < len) {\n\t\t\t\t\toffset = len - pes->prev_data_len;\n\t\t\t\t\tmemcpy(pes->pck_data + offset, pes->prev_data, pes->prev_data_len);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PES reassembly buffer overflow (%d bytes not processed from previous PES) - discarding prev data\\n\", pes->pid, pes->prev_data_len ));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pes->temi_pending && pes->temi_tc_desc_len) {\n\t\t\t\tgf_m2ts_store_temi(ts, pes);\n\t\t\t}\n\n\t\t\tif (pes->temi_pending) {\n\t\t\t\tpes->temi_pending = 0;\n\t\t\t\tpes->temi_tc.pes_pts = pes->PTS;\n\t\t\t\tpes->temi_tc.pid = pes->pid;\n\t\t\t\tif (ts->on_event)\n\t\t\t\t\tts->on_event(ts, GF_M2TS_EVT_TEMI_TIMECODE, &pes->temi_tc);\n\t\t\t}\n\n\t\t\tif (! ts->seek_mode)\n\t\t\t\tremain = pes->reframe(ts, pes, same_pts, pes->pck_data+offset, pes->pck_data_len-offset, &pesh);\n\n\t\t\t//CLEANUP alloc stuff\n\t\t\tif (pes->prev_data) gf_free(pes->prev_data);\n\t\t\tpes->prev_data = NULL;\n\t\t\tpes->prev_data_len = 0;\n\t\t\tif (remain) {\n\t\t\t\tpes->prev_data = gf_malloc(sizeof(char)*remain);\n\t\t\t\tassert(pes->pck_data_len >= remain);\n\t\t\t\tmemcpy(pes->prev_data, pes->pck_data + pes->pck_data_len - remain, remain);\n\t\t\t\tpes->prev_data_len = remain;\n\t\t\t}\n\t\t}\n\t} else if (pes->pck_data_len) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Bad PES Header, discarding packet (maybe stream is encrypted ?)\\n\", pes->pid));\n\t}\n\nexit:\n\tpes->pck_data_len = 0;\n\tpes->pes_len = 0;\n\tpes->rap = 0;\n}",
        "func": "void gf_m2ts_flush_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, u32 force_flush_type)\n{\n\tGF_M2TS_PESHeader pesh;\n\tif (!ts) return;\n\n\t/*we need at least a full, valid start code and PES header !!*/\n\tif ((pes->pck_data_len >= 4) && !pes->pck_data[0] && !pes->pck_data[1] && (pes->pck_data[2] == 0x1)) {\n\t\tu32 len;\n\t\tBool has_pes_header = GF_TRUE;\n\t\tBool has_data = GF_TRUE;\n\t\tu32 stream_id = pes->pck_data[3];\n\t\tBool same_pts = GF_FALSE;\n\n\t\tswitch (stream_id) {\n\t\tcase GF_M2_STREAMID_PADDING:\n\t\t\thas_data = GF_FALSE;\n\t\tcase GF_M2_STREAMID_PROGRAM_STREAM_MAP:\n\t\tcase GF_M2_STREAMID_PRIVATE_2:\n\t\tcase GF_M2_STREAMID_ECM:\n\t\tcase GF_M2_STREAMID_EMM:\n\t\tcase GF_M2_STREAMID_PROGRAM_STREAM_DIRECTORY:\n\t\tcase GF_M2_STREAMID_DSMCC:\n\t\tcase GF_M2_STREAMID_H222_TYPE_E:\n\t\t\thas_pes_header = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (has_pes_header) {\n\n\t\t\t/*OK read header*/\n\t\t\tgf_m2ts_pes_header(pes, pes->pck_data + 3, pes->pck_data_len - 3, &pesh);\n\n\t\t\t/*send PES timing*/\n\t\t\tif (ts->notify_pes_timing) {\n\t\t\t\tGF_M2TS_PES_PCK pck;\n\t\t\t\tmemset(&pck, 0, sizeof(GF_M2TS_PES_PCK));\n\t\t\t\tpck.PTS = pesh.PTS;\n\t\t\t\tpck.DTS = pesh.DTS;\n\t\t\t\tpck.stream = pes;\n\t\t\t\tif (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP;\n\t\t\t\tpes->pes_end_packet_number = ts->pck_number;\n\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PES_TIMING, &pck);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Got PES header DTS %d PTS %d\\n\", pes->pid, pesh.DTS, pesh.PTS));\n\n\t\t\tif (pesh.PTS) {\n\t\t\t\tif (pesh.PTS == pes->PTS) {\n\t\t\t\t\tsame_pts = GF_TRUE;\n\t\t\t\t\tif ((pes->stream_type==GF_M2TS_AUDIO_TRUEHD) || (pes->stream_type==GF_M2TS_AUDIO_EC3)) {\n\t\t\t\t\t\tsame_pts = GF_FALSE;\n\t\t\t\t\t} else if (!pes->is_resume) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - same PTS \"LLU\" for two consecutive PES packets \\n\", pes->pid, pes->PTS));\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef GPAC_DISABLE_LOG\n\t\t\t\t/*FIXME - this test should only be done for non bi-directionally coded media\n\t\t\t\telse if (pesh.PTS < pes->PTS) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - PTS \"LLU\" less than previous packet PTS \"LLU\"\\n\", pes->pid, pesh.PTS, pes->PTS) );\n\t\t\t\t}\n\t\t\t\t*/\n#endif\n\n\t\t\t\tpes->PTS = pesh.PTS;\n#ifndef GPAC_DISABLE_LOG\n\t\t\t\t{\n\t\t\t\t\tif (!pes->is_resume && pes->DTS && (pesh.DTS == pes->DTS)) {\n\t\t\t\t\t\tif ((pes->stream_type==GF_M2TS_AUDIO_TRUEHD) || (pes->stream_type==GF_M2TS_AUDIO_EC3)) {\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - same DTS \"LLU\" for two consecutive PES packets \\n\", pes->pid, pes->DTS));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pesh.DTS < pes->DTS) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - DTS \"LLU\" less than previous DTS \"LLU\"\\n\", pes->pid, pesh.DTS, pes->DTS));\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tpes->DTS = pesh.DTS;\n\t\t\t}\n\t\t\t/*no PTSs were coded, same time*/\n\t\t\telse if (!pesh.hdr_data_len) {\n\t\t\t\tsame_pts = GF_TRUE;\n\t\t\t}\n\n\t\t\tpes->is_resume = GF_FALSE;\n\n\t\t\t/*3-byte start-code + 6 bytes header + hdr extensions*/\n\t\t\tlen = 9 + pesh.hdr_data_len;\n\n\t\t} else {\n\t\t\tif (!has_data) goto exit;\n\n\t\t\t/*3-byte start-code + 1 byte streamid*/\n\t\t\tlen = 4;\n\t\t\tmemset(&pesh, 0, sizeof(pesh));\n\t\t}\n\n\t\tif ((u8) pes->pck_data[3]==0xfa) {\n\t\t\tGF_M2TS_SL_PCK sl_pck;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] SL Packet in PES for %d - ES ID %d\\n\", pes->pid, pes->mpeg4_es_id));\n\n\t\t\tif (pes->pck_data_len > len) {\n\t\t\t\tsl_pck.data = (char *)pes->pck_data + len;\n\t\t\t\tsl_pck.data_len = pes->pck_data_len - len;\n\t\t\t\tsl_pck.stream = (GF_M2TS_ES *)pes;\n\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SL_PCK, &sl_pck);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Bad SL Packet size: (%d indicated < %d header)\\n\", pes->pid, pes->pck_data_len, len));\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (pes->reframe) {\n\t\t\tu32 remain = 0;\n\t\t\tu32 offset = len;\n\n\t\t\tif (pesh.pck_len && (pesh.pck_len-3-pesh.hdr_data_len != pes->pck_data_len-len)) {\n\t\t\t\tif (!force_flush_type) {\n\t\t\t\t\tpes->is_resume = GF_TRUE;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (force_flush_type==1) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PES payload size %d but received %d bytes\\n\", pes->pid, (u32) ( pesh.pck_len-3-pesh.hdr_data_len), pes->pck_data_len-len));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//copy over the remaining of previous PES payload before start of this PES payload\n\t\t\tif (pes->prev_data_len) {\n\t\t\t\tif (pes->prev_data_len < len) {\n\t\t\t\t\toffset = len - pes->prev_data_len;\n\t\t\t\t\tmemcpy(pes->pck_data + offset, pes->prev_data, pes->prev_data_len);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PES reassembly buffer overflow (%d bytes not processed from previous PES) - discarding prev data\\n\", pes->pid, pes->prev_data_len ));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pes->temi_pending && pes->temi_tc_desc_len) {\n\t\t\t\tgf_m2ts_store_temi(ts, pes);\n\t\t\t}\n\n\t\t\tif (pes->temi_pending) {\n\t\t\t\tpes->temi_pending = 0;\n\t\t\t\tpes->temi_tc.pes_pts = pes->PTS;\n\t\t\t\tpes->temi_tc.pid = pes->pid;\n\t\t\t\tif (ts->on_event)\n\t\t\t\t\tts->on_event(ts, GF_M2TS_EVT_TEMI_TIMECODE, &pes->temi_tc);\n\t\t\t}\n\n\t\t\tif (! ts->seek_mode)\n\t\t\t\tremain = pes->reframe(ts, pes, same_pts, pes->pck_data+offset, pes->pck_data_len-offset, &pesh);\n\n\t\t\t//CLEANUP alloc stuff\n\t\t\tif (pes->prev_data) gf_free(pes->prev_data);\n\t\t\tpes->prev_data = NULL;\n\t\t\tpes->prev_data_len = 0;\n\t\t\tif (remain) {\n\t\t\t\tpes->prev_data = gf_malloc(sizeof(char)*remain);\n\t\t\t\tassert(pes->pck_data_len >= remain);\n\t\t\t\tmemcpy(pes->prev_data, pes->pck_data + pes->pck_data_len - remain, remain);\n\t\t\t\tpes->prev_data_len = remain;\n\t\t\t}\n\t\t}\n\t} else if (pes->pck_data_len) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Bad PES Header, discarding packet (maybe stream is encrypted ?)\\n\", pes->pid));\n\t}\n\nexit:\n\tpes->pck_data_len = 0;\n\tpes->pes_len = 0;\n\tpes->rap = 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -88,7 +88,7 @@\n \n \t\t} else {\n \t\t\tif (!has_data) goto exit;\n-\t\t\t\n+\n \t\t\t/*3-byte start-code + 1 byte streamid*/\n \t\t\tlen = 4;\n \t\t\tmemset(&pesh, 0, sizeof(pesh));",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1655",
        "func_name": "gpac/pcmreframe_process",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.4.0.",
        "git_url": "https://github.com/gpac/gpac/commit/e7f96c2d3774e4ea25f952bcdf55af1dd6e919f4",
        "commit_title": "fixed #2425",
        "commit_text": "",
        "func_before": "GF_Err pcmreframe_process(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu64 byte_offset;\n\tu8 *data;\n\tu32 pck_size;\n\n\tif (ctx->done) return GF_EOS;\n\n\tif (!ctx->is_playing && ctx->opid) return GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid) && !ctx->reverse_play) {\n\t\t\tif (ctx->out_pck) {\n\t\t\t\tgf_filter_pck_truncate(ctx->out_pck, ctx->nb_bytes_in_frame);\n\t\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->nb_bytes_in_frame/ctx->Bps/ctx->ch);\n\t\t\t\tpcmreframe_flush_packet(ctx);\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tif (ctx->probe_wave==1) {\n\t\tBool wav_ok = GF_TRUE;\n\t\tGF_BitStream *bs;\n\t\tif (ctx->probe_data) {\n\t\t\tctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);\n\t\t\tmemcpy(ctx->probe_data + ctx->probe_data_size, data, pck_size);\n\t\t\tctx->probe_data_size += pck_size;\n\t\t\tbs = gf_bs_new(ctx->probe_data, ctx->probe_data_size, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tbs = gf_bs_new(data, pck_size, GF_BITSTREAM_READ);\n\t\t}\n\t\tu32 type = gf_bs_read_u32(bs);\n\t\tif (type!=GF_4CC('R', 'I', 'F', 'F')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tgf_bs_read_u32(bs);\n\t\tu32 wtype = gf_bs_read_u32(bs);\n\t\tif (wtype!=GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\twhile (gf_bs_available(bs)) {\n\t\t\ttype = gf_bs_read_u32(bs);\n\t\t\tu32 csize = gf_bs_read_u32_le(bs); //subchunk size\n\t\t\tif (type==GF_4CC('d', 'a', 't', 'a')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type!=GF_4CC('f', 'm', 't', ' ')) {\n\t\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//parse fmt\n\t\t\tu16 atype = gf_bs_read_u16_le(bs);\n\t\t\tctx->ch = gf_bs_read_u16_le(bs);\n\t\t\tctx->sr = gf_bs_read_u32_le(bs);\n\t\t\tgf_bs_read_u32_le(bs); //byte rate\n\t\t\tgf_bs_read_u16_le(bs); // block align\n\t\t\tu32 bps = gf_bs_read_u16_le(bs);\n\t\t\tif (atype==3) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_FLT;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else if (atype==1) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S32;\n\t\t\t\t} else if (bps==24) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S24;\n\t\t\t\t} else if (bps==16) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S16;\n\t\t\t\t} else if (bps==8) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_U8;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tif (!ctx->probe_data) {\n\t\t\t\tctx->probe_data = gf_malloc(pck_size);\n\t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n\t\t\t\tctx->probe_data_size = pck_size;\n\t\t\t}\n\t\t\tif (ctx->probe_data_size<=10000) {\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chink afetr %d bytes, aborting\\n\", ctx->probe_data_size));\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\n\t\tctx->wav_hdr_size = (u32) gf_bs_get_position(bs);\n\n\t\tgf_bs_del(bs);\n\t\tif (!wav_ok) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Invalid or unsupported WAVE header, aborting\\n\", ctx->probe_data_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tctx->probe_wave = 2;\n\t\tpcmreframe_configure_pid(filter, ctx->ipid, GF_FALSE);\n\t\tif (ctx->probe_data) {\n\t\t\tpck_size = ctx->probe_data_size;\n\t\t\tdata = ctx->probe_data;\n\t\t}\n\t\tpck_size -= ctx->wav_hdr_size;\n\t\tdata+=ctx->wav_hdr_size;\n\t\tbyte_offset = 0;\n\t}\n\tbyte_offset+= ctx->wav_hdr_size;\n\n\twhile (pck_size) {\n\t\tif (!ctx->out_pck) {\n\t\t\tctx->out_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->frame_size, &ctx->out_data);\n\t\t\tif (!ctx->out_pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_cts(ctx->out_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_sap(ctx->out_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->framelen);\n\t\t\tgf_filter_pck_set_byte_offset(ctx->out_pck, byte_offset);\n\t\t}\n\n\t\tif (pck_size + ctx->nb_bytes_in_frame < ctx->frame_size) {\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, pck_size);\n\t\t\tctx->nb_bytes_in_frame += pck_size;\n\t\t\tpck_size = 0;\n\t\t} else {\n\t\t\tu32 remain = ctx->frame_size - ctx->nb_bytes_in_frame;\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, remain);\n\t\t\tctx->nb_bytes_in_frame = ctx->frame_size;\n\t\t\tpcmreframe_flush_packet(ctx);\n\n\t\t\tpck_size -= remain;\n\t\t\tdata += remain;\n\t\t\tbyte_offset += remain;\n\t\t\tctx->out_pck = NULL;\n\t\t\tctx->nb_bytes_in_frame = 0;\n\n\t\t\t//reverse playback, the remaining data is for the next frame, we want the previous one.\n\t\t\t//Trash packet and seek to previous frame\n\t\t\tif (ctx->reverse_play) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\tif (!ctx->cts) {\n\t\t\t\t\tif (ctx->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_STOP, ctx->ipid);\n\t\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\t\treturn GF_EOS;\n\t\t\t\t}\n\t\t\t\tctx->cts -= ctx->framelen;\n\t\t\t\tctx->filepos -= ctx->frame_size;\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t//post a seek, this will trash remaining packets in buffers\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tctx->cts += ctx->framelen;\n\t\t}\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (ctx->probe_data) {\n\t\tgf_free(ctx->probe_data);\n\t\tctx->probe_data = NULL;\n\t\tctx->probe_data_size = 0;\n\t}\n\treturn GF_OK;\n}",
        "func": "GF_Err pcmreframe_process(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu64 byte_offset;\n\tu8 *data;\n\tu32 pck_size;\n\n\tif (ctx->done) return GF_EOS;\n\n\tif (!ctx->is_playing && ctx->opid) return GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid) && !ctx->reverse_play) {\n\t\t\tif (ctx->out_pck) {\n\t\t\t\tgf_filter_pck_truncate(ctx->out_pck, ctx->nb_bytes_in_frame);\n\t\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->nb_bytes_in_frame/ctx->Bps/ctx->ch);\n\t\t\t\tpcmreframe_flush_packet(ctx);\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tif (ctx->probe_wave==1) {\n\t\tBool wav_ok = GF_TRUE;\n\t\tBool hdr_found = GF_FALSE;\n\t\tGF_BitStream *bs;\n\t\tif (ctx->probe_data) {\n\t\t\tctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);\n\t\t\tmemcpy(ctx->probe_data + ctx->probe_data_size, data, pck_size);\n\t\t\tctx->probe_data_size += pck_size;\n\t\t\tbs = gf_bs_new(ctx->probe_data, ctx->probe_data_size, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tbs = gf_bs_new(data, pck_size, GF_BITSTREAM_READ);\n\t\t}\n\t\tu32 type = gf_bs_read_u32(bs);\n\t\tif (type!=GF_4CC('R', 'I', 'F', 'F')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tgf_bs_read_u32(bs);\n\t\tu32 wtype = gf_bs_read_u32(bs);\n\t\tif (wtype!=GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\twhile (gf_bs_available(bs)) {\n\t\t\ttype = gf_bs_read_u32(bs);\n\t\t\tu32 csize = gf_bs_read_u32_le(bs); //subchunk size\n\t\t\tif (type==GF_4CC('d', 'a', 't', 'a')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type!=GF_4CC('f', 'm', 't', ' ')) {\n\t\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//parse fmt\n\t\t\thdr_found = GF_TRUE;\n\t\t\tu16 atype = gf_bs_read_u16_le(bs);\n\t\t\tctx->ch = gf_bs_read_u16_le(bs);\n\t\t\tctx->sr = gf_bs_read_u32_le(bs);\n\t\t\tgf_bs_read_u32_le(bs); //byte rate\n\t\t\tgf_bs_read_u16_le(bs); // block align\n\t\t\tu32 bps = gf_bs_read_u16_le(bs);\n\t\t\tif (atype==3) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_FLT;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else if (atype==1) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S32;\n\t\t\t\t} else if (bps==24) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S24;\n\t\t\t\t} else if (bps==16) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S16;\n\t\t\t\t} else if (bps==8) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_U8;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tif (!ctx->probe_data) {\n\t\t\t\tctx->probe_data = gf_malloc(pck_size);\n\t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n\t\t\t\tctx->probe_data_size = pck_size;\n\t\t\t}\n\t\t\tif (!hdr_found) {\n\t\t\t\tif (ctx->probe_data_size<=10000) {\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\\n\", ctx->probe_data_size));\n\t\t\t}\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\n\t\tctx->wav_hdr_size = (u32) gf_bs_get_position(bs);\n\n\t\tgf_bs_del(bs);\n\t\tif (!wav_ok) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Invalid or unsupported WAVE header, aborting\\n\", ctx->probe_data_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tctx->probe_wave = 2;\n\t\tpcmreframe_configure_pid(filter, ctx->ipid, GF_FALSE);\n\t\tif (ctx->probe_data) {\n\t\t\tpck_size = ctx->probe_data_size;\n\t\t\tdata = ctx->probe_data;\n\t\t}\n\t\tpck_size -= ctx->wav_hdr_size;\n\t\tdata+=ctx->wav_hdr_size;\n\t\tbyte_offset = 0;\n\t}\n\tbyte_offset+= ctx->wav_hdr_size;\n\n\twhile (pck_size) {\n\t\tif (!ctx->out_pck) {\n\t\t\tctx->out_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->frame_size, &ctx->out_data);\n\t\t\tif (!ctx->out_pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_cts(ctx->out_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_sap(ctx->out_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->framelen);\n\t\t\tgf_filter_pck_set_byte_offset(ctx->out_pck, byte_offset);\n\t\t}\n\n\t\tif (pck_size + ctx->nb_bytes_in_frame < ctx->frame_size) {\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, pck_size);\n\t\t\tctx->nb_bytes_in_frame += pck_size;\n\t\t\tpck_size = 0;\n\t\t} else {\n\t\t\tu32 remain = ctx->frame_size - ctx->nb_bytes_in_frame;\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, remain);\n\t\t\tctx->nb_bytes_in_frame = ctx->frame_size;\n\t\t\tpcmreframe_flush_packet(ctx);\n\n\t\t\tpck_size -= remain;\n\t\t\tdata += remain;\n\t\t\tbyte_offset += remain;\n\t\t\tctx->out_pck = NULL;\n\t\t\tctx->nb_bytes_in_frame = 0;\n\n\t\t\t//reverse playback, the remaining data is for the next frame, we want the previous one.\n\t\t\t//Trash packet and seek to previous frame\n\t\t\tif (ctx->reverse_play) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\tif (!ctx->cts) {\n\t\t\t\t\tif (ctx->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_STOP, ctx->ipid);\n\t\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\t\treturn GF_EOS;\n\t\t\t\t}\n\t\t\t\tctx->cts -= ctx->framelen;\n\t\t\t\tctx->filepos -= ctx->frame_size;\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t//post a seek, this will trash remaining packets in buffers\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tctx->cts += ctx->framelen;\n\t\t}\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (ctx->probe_data) {\n\t\tgf_free(ctx->probe_data);\n\t\tctx->probe_data = NULL;\n\t\tctx->probe_data_size = 0;\n\t}\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,7 @@\n \n \tif (ctx->probe_wave==1) {\n \t\tBool wav_ok = GF_TRUE;\n+\t\tBool hdr_found = GF_FALSE;\n \t\tGF_BitStream *bs;\n \t\tif (ctx->probe_data) {\n \t\t\tctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);\n@@ -60,6 +61,7 @@\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\t//parse fmt\n+\t\t\thdr_found = GF_TRUE;\n \t\t\tu16 atype = gf_bs_read_u16_le(bs);\n \t\t\tctx->ch = gf_bs_read_u16_le(bs);\n \t\t\tctx->sr = gf_bs_read_u32_le(bs);\n@@ -92,11 +94,13 @@\n \t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n \t\t\t\tctx->probe_data_size = pck_size;\n \t\t\t}\n-\t\t\tif (ctx->probe_data_size<=10000) {\n-\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n-\t\t\t\treturn GF_OK;\n+\t\t\tif (!hdr_found) {\n+\t\t\t\tif (ctx->probe_data_size<=10000) {\n+\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n+\t\t\t\t\treturn GF_OK;\n+\t\t\t\t}\n+\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\\n\", ctx->probe_data_size));\n \t\t\t}\n-\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chink afetr %d bytes, aborting\\n\", ctx->probe_data_size));\n \t\t\twav_ok = GF_FALSE;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (ctx->probe_data_size<=10000) {",
                "\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);",
                "\t\t\t\treturn GF_OK;",
                "\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chink afetr %d bytes, aborting\\n\", ctx->probe_data_size));"
            ],
            "added_lines": [
                "\t\tBool hdr_found = GF_FALSE;",
                "\t\t\thdr_found = GF_TRUE;",
                "\t\t\tif (!hdr_found) {",
                "\t\t\t\tif (ctx->probe_data_size<=10000) {",
                "\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);",
                "\t\t\t\t\treturn GF_OK;",
                "\t\t\t\t}",
                "\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\\n\", ctx->probe_data_size));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1655",
        "func_name": "gpac/gf_bs_skip_bytes",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.4.0.",
        "git_url": "https://github.com/gpac/gpac/commit/e7f96c2d3774e4ea25f952bcdf55af1dd6e919f4",
        "commit_title": "fixed #2425",
        "commit_text": "",
        "func_before": "GF_EXPORT\nvoid gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\n\tgf_bs_align(bs);\n\n\t/*special case for file skipping...*/\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\t//weird msys2 bug resulting in broken seek on some files ?!?  -the bug is not happening when doing absolute seek\n//\t\tgf_fseek(bs->stream, nbBytes, SEEK_CUR);\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\n\t/*special case for reading*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t}\n\t\treturn;\n\t}\n\t/*for writing we must do it this way, otherwise pb in dynamic buffers*/\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}",
        "func": "GF_EXPORT\nvoid gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\n\tgf_bs_align(bs);\n\n\t/*special case for file skipping...*/\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\t//weird msys2 bug resulting in broken seek on some files ?!?  -the bug is not happening when doing absolute seek\n//\t\tgf_fseek(bs->stream, nbBytes, SEEK_CUR);\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\n\t/*special case for reading*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\t/*for writing we must do it this way, otherwise pb in dynamic buffers*/\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,10 @@\n \t\t\t}\n \t\t} else {\n \t\t\tbs->position += nbBytes;\n+\t\t\tif (bs->position>bs->size) {\n+\t\t\t\tbs->position = bs->size;\n+\t\t\t\tbs->overflow_state = 1;\n+\t\t\t}\n \t\t}\n \t\treturn;\n \t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif (bs->position>bs->size) {",
                "\t\t\t\tbs->position = bs->size;",
                "\t\t\t\tbs->overflow_state = 1;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-43634",
        "func_name": "Netatalk/netatalk/dsi_writeinit",
        "description": "This vulnerability allows remote attackers to execute arbitrary code on affected installations of Netatalk. Authentication is not required to exploit this vulnerability. The specific flaw exists within the dsi_writeinit function. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of root. Was ZDI-CAN-17646.",
        "git_url": "https://github.com/Netatalk/netatalk/commit/72216b33128365037466f357da572a28e0496ca4",
        "commit_title": "fix CVE-2022-43634",
        "commit_text": "",
        "func_before": "size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen _U_)\n{\n    size_t bytes = 0;\n    dsi->datasize = ntohl(dsi->header.dsi_len) - dsi->header.dsi_data.dsi_doff;\n\n    if (dsi->eof > dsi->start) {\n        /* We have data in the buffer */\n        bytes = MIN(dsi->eof - dsi->start, dsi->datasize);\n        memmove(buf, dsi->start, bytes);\n        dsi->start += bytes;\n        dsi->datasize -= bytes;\n        if (dsi->start >= dsi->eof)\n            dsi->start = dsi->eof = dsi->buffer;\n    }\n\n    LOG(log_maxdebug, logtype_dsi, \"dsi_writeinit: remaining DSI datasize: %jd\", (intmax_t)dsi->datasize);\n\n    return bytes;\n}",
        "func": "size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen)\n{\n    size_t bytes = 0;\n    dsi->datasize = ntohl(dsi->header.dsi_len) - dsi->header.dsi_data.dsi_doff;\n\n    if (dsi->eof > dsi->start) {\n        /* We have data in the buffer */\n        bytes = MIN(dsi->eof - dsi->start, dsi->datasize);\n        memmove(buf, dsi->start, MIN(buflen, bytes));\n        dsi->start += bytes;\n        dsi->datasize -= bytes;\n        if (dsi->start >= dsi->eof)\n            dsi->start = dsi->eof = dsi->buffer;\n    }\n\n    LOG(log_maxdebug, logtype_dsi, \"dsi_writeinit: remaining DSI datasize: %jd\", (intmax_t)dsi->datasize);\n\n    return bytes;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen _U_)\n+size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen)\n {\n     size_t bytes = 0;\n     dsi->datasize = ntohl(dsi->header.dsi_len) - dsi->header.dsi_data.dsi_doff;\n@@ -6,7 +6,7 @@\n     if (dsi->eof > dsi->start) {\n         /* We have data in the buffer */\n         bytes = MIN(dsi->eof - dsi->start, dsi->datasize);\n-        memmove(buf, dsi->start, bytes);\n+        memmove(buf, dsi->start, MIN(buflen, bytes));\n         dsi->start += bytes;\n         dsi->datasize -= bytes;\n         if (dsi->start >= dsi->eof)",
        "diff_line_info": {
            "deleted_lines": [
                "size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen _U_)",
                "        memmove(buf, dsi->start, bytes);"
            ],
            "added_lines": [
                "size_t dsi_writeinit(DSI *dsi, void *buf, const size_t buflen)",
                "        memmove(buf, dsi->start, MIN(buflen, bytes));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3291",
        "func_name": "gpac/id3dmx_flush",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.2.",
        "git_url": "https://github.com/gpac/gpac/commit/6a748ccc3f76ff10e3ae43014967ea4b0c088aaf",
        "commit_title": "fixed #2493",
        "commit_text": "",
        "func_before": "void id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid *audio_pid, GF_FilterPid **video_pid_p)\n{\n\tGF_BitStream *bs = gf_bs_new(id3_buf, id3_buf_size, GF_BITSTREAM_READ);\n\tchar *sep_desc;\n\tchar *_buf=NULL;\n\tu32 buf_alloc=0;\n\tgf_bs_skip_bytes(bs, 3);\n\t/*u8 major = */gf_bs_read_u8(bs);\n\t/*u8 minor = */gf_bs_read_u8(bs);\n\t/*u8 unsync = */gf_bs_read_int(bs, 1);\n\tu8 ext_hdr = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 6);\n\tu32 size = gf_id3_read_size(bs);\n\n\n\tif (ext_hdr) {\n\n\t}\n\n\twhile (size && (gf_bs_available(bs)>=10) ) {\n\t\tchar *buf;\n\t\tchar szTag[1024];\n\t\tchar *sep;\n\t\ts32 tag_idx;\n\t\tu32 pic_size;\n\t\t//u32 pic_type;\n\t\tu32 ftag = gf_bs_read_u32(bs);\n\t\tu32 fsize = gf_id3_read_size(bs);\n\t\t/*u16 fflags = */gf_bs_read_u16(bs);\n\n\t\tsize -= 10;\n\t\tif (!fsize)\n\t\t\tbreak;\n\n\t\tif (size<fsize) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] Broken ID3 frame tag %s, size %d but remaining bytes %d\\n\", gf_4cc_to_str(ftag), fsize, size));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf_alloc<=fsize) {\n\t\t\t_buf = gf_realloc(_buf, fsize+3);\n\t\t\tbuf_alloc = fsize+3;\n\t\t}\n\t\t//read into _buf+1 so that buf+1 is always %2 mem aligned as it can be loaded as unsigned short\n\t\tgf_bs_read_data(bs, _buf+1, fsize);\n\t\t_buf[fsize+1]=0;\n\t\t_buf[fsize+2]=0;\n\t\tbuf = _buf+1;\n\n\t\ttag_idx = gf_itags_find_by_id3tag(ftag);\n\n\t\tif (ftag==GF_ID3V2_FRAME_TXXX) {\n\t\t\tsep = memchr(buf, 0, fsize);\n\t\t\tif (sep) {\n\t\t\t\tif (!stricmp(buf+1, \"comment\")) {\n\t\t\t\t\tid3dmx_set_string(audio_pid, \"comment\", sep+1, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(szTag, \"tag_\");\n\t\t\t\t\tstrncat(szTag, buf+1, 1019);\n\t\t\t\t\tid3dmx_set_string(audio_pid, szTag, sep+1, GF_TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ftag == GF_ID3V2_FRAME_APIC) {\n\t\t\t//first char is text encoding\n\t\t\t//then mime\n\t\t\tsep = memchr(buf+1, 0, fsize-1);\n\t\t\t/*pic_type = sep[1];*/\n\t\t\tsep_desc = memchr(sep+2, 0, fsize-1);\n\n\t\t\tif (sep_desc) {\n\t\t\t\tGF_Err e;\n\t\t\t\tpic_size = (u32) ( (sep_desc + 1) - buf);\n\t\t\t\tpic_size = fsize - pic_size;\n\n\t\t\t\tif (video_pid_p) {\n\t\t\t\t\te = gf_filter_pid_raw_new(filter, NULL, NULL, buf+1, NULL, sep_desc+1, pic_size, GF_FALSE, video_pid_p);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] error setting up video pid for cover art: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t\t}\n\t\t\t\t\tif (*video_pid_p) {\n\t\t\t\t\t\tu8 *out_buffer;\n\t\t\t\t\t\tGF_FilterPacket *dst_pck;\n\t\t\t\t\t\tgf_filter_pid_set_name(*video_pid_p, \"CoverArt\");\n\t\t\t\t\t\tgf_filter_pid_set_property(*video_pid_p, GF_PROP_PID_COVER_ART, &PROP_BOOL(GF_TRUE));\n\t\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(*video_pid_p, pic_size, &out_buffer);\n\t\t\t\t\t\tif (dst_pck) {\n\t\t\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t\tmemcpy(out_buffer, sep_desc+1, pic_size);\n\t\t\t\t\t\t\tgf_filter_pck_send(dst_pck);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgf_filter_pid_set_eos(*video_pid_p);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pid_set_property(audio_pid, GF_PROP_PID_COVER_ART, &PROP_DATA(sep_desc+1, pic_size) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tag_idx>=0) {\n\t\t\tconst char *tag_name = gf_itags_get_name((u32) tag_idx);\n\t\t\tid3dmx_set_string(audio_pid, (char *) tag_name, buf+1, GF_FALSE);\n\t\t} else {\n\t\t\tsprintf(szTag, \"tag_%s\", gf_4cc_to_str(ftag));\n\t\t\tif ((ftag>>24) == 'T') {\n\t\t\t\tid3dmx_set_string(audio_pid, szTag, buf+1, GF_TRUE);\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property_dyn(audio_pid, szTag, &PROP_DATA(buf, fsize) );\n\t\t\t}\n\t\t}\n\t\tsize -= fsize;\n\t}\n\tgf_bs_del(bs);\n\tif (_buf) gf_free(_buf);\n}",
        "func": "void id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid *audio_pid, GF_FilterPid **video_pid_p)\n{\n\tGF_BitStream *bs = gf_bs_new(id3_buf, id3_buf_size, GF_BITSTREAM_READ);\n\tchar *sep_desc;\n\tchar *_buf=NULL;\n\tu32 buf_alloc=0;\n\tgf_bs_skip_bytes(bs, 3);\n\t/*u8 major = */gf_bs_read_u8(bs);\n\t/*u8 minor = */gf_bs_read_u8(bs);\n\t/*u8 unsync = */gf_bs_read_int(bs, 1);\n\tu8 ext_hdr = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 6);\n\tu32 size = gf_id3_read_size(bs);\n\n\n\tif (ext_hdr) {\n\n\t}\n\n\twhile (size && (gf_bs_available(bs)>=10) ) {\n\t\tchar *buf;\n\t\tchar szTag[1024];\n\t\tchar *sep;\n\t\ts32 tag_idx;\n\t\tu32 pic_size;\n\t\t//u32 pic_type;\n\t\tu32 ftag = gf_bs_read_u32(bs);\n\t\tu32 fsize = gf_id3_read_size(bs);\n\t\t/*u16 fflags = */gf_bs_read_u16(bs);\n\n\t\tsize -= 10;\n\t\tif (!fsize)\n\t\t\tbreak;\n\n\t\tif (size<fsize) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] Broken ID3 frame tag %s, size %d but remaining bytes %d\\n\", gf_4cc_to_str(ftag), fsize, size));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf_alloc <= fsize+2) {\n\t\t\t_buf = gf_realloc(_buf, fsize+3);\n\t\t\tbuf_alloc = fsize+3;\n\t\t}\n\t\t//read into _buf+1 so that buf+1 is always %2 mem aligned as it can be loaded as unsigned short\n\t\tgf_bs_read_data(bs, _buf+1, fsize);\n\t\t_buf[fsize+1]=0;\n\t\t_buf[fsize+2]=0;\n\t\tbuf = _buf+1;\n\n\t\ttag_idx = gf_itags_find_by_id3tag(ftag);\n\n\t\tif (ftag==GF_ID3V2_FRAME_TXXX) {\n\t\t\tsep = memchr(buf, 0, fsize);\n\t\t\tif (sep) {\n\t\t\t\tif (!stricmp(buf+1, \"comment\")) {\n\t\t\t\t\tid3dmx_set_string(audio_pid, \"comment\", sep+1, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(szTag, \"tag_\");\n\t\t\t\t\tstrncat(szTag, buf+1, 1019);\n\t\t\t\t\tid3dmx_set_string(audio_pid, szTag, sep+1, GF_TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ftag == GF_ID3V2_FRAME_APIC) {\n\t\t\t//first char is text encoding\n\t\t\t//then mime\n\t\t\tsep = memchr(buf+1, 0, fsize-1);\n\t\t\t/*pic_type = sep[1];*/\n\t\t\tsep_desc = memchr(sep+2, 0, fsize-1);\n\n\t\t\tif (sep_desc) {\n\t\t\t\tGF_Err e;\n\t\t\t\tpic_size = (u32) ( (sep_desc + 1) - buf);\n\t\t\t\tpic_size = fsize - pic_size;\n\n\t\t\t\tif (video_pid_p) {\n\t\t\t\t\te = gf_filter_pid_raw_new(filter, NULL, NULL, buf+1, NULL, sep_desc+1, pic_size, GF_FALSE, video_pid_p);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] error setting up video pid for cover art: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t\t}\n\t\t\t\t\tif (*video_pid_p) {\n\t\t\t\t\t\tu8 *out_buffer;\n\t\t\t\t\t\tGF_FilterPacket *dst_pck;\n\t\t\t\t\t\tgf_filter_pid_set_name(*video_pid_p, \"CoverArt\");\n\t\t\t\t\t\tgf_filter_pid_set_property(*video_pid_p, GF_PROP_PID_COVER_ART, &PROP_BOOL(GF_TRUE));\n\t\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(*video_pid_p, pic_size, &out_buffer);\n\t\t\t\t\t\tif (dst_pck) {\n\t\t\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t\tmemcpy(out_buffer, sep_desc+1, pic_size);\n\t\t\t\t\t\t\tgf_filter_pck_send(dst_pck);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgf_filter_pid_set_eos(*video_pid_p);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pid_set_property(audio_pid, GF_PROP_PID_COVER_ART, &PROP_DATA(sep_desc+1, pic_size) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tag_idx>=0) {\n\t\t\tconst char *tag_name = gf_itags_get_name((u32) tag_idx);\n\t\t\tid3dmx_set_string(audio_pid, (char *) tag_name, buf+1, GF_FALSE);\n\t\t} else {\n\t\t\tsprintf(szTag, \"tag_%s\", gf_4cc_to_str(ftag));\n\t\t\tif ((ftag>>24) == 'T') {\n\t\t\t\tid3dmx_set_string(audio_pid, szTag, buf+1, GF_TRUE);\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property_dyn(audio_pid, szTag, &PROP_DATA(buf, fsize) );\n\t\t\t}\n\t\t}\n\t\tsize -= fsize;\n\t}\n\tgf_bs_del(bs);\n\tif (_buf) gf_free(_buf);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,7 @@\n \t\t\tbreak;\n \t\t}\n \n-\t\tif (buf_alloc<=fsize) {\n+\t\tif (buf_alloc <= fsize+2) {\n \t\t\t_buf = gf_realloc(_buf, fsize+3);\n \t\t\tbuf_alloc = fsize+3;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (buf_alloc<=fsize) {"
            ],
            "added_lines": [
                "\t\tif (buf_alloc <= fsize+2) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14815",
        "func_name": "torvalds/linux/mwifiex_update_vs_ie",
        "description": "A vulnerability was found in Linux Kernel, where a Heap Overflow was found in mwifiex_set_wmm_params() function of Marvell Wifi Driver.",
        "git_url": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a",
        "commit_title": "mwifiex: Fix three heap overflow at parsing element in cfg80211_ap_settings",
        "commit_text": " mwifiex_update_vs_ie(),mwifiex_set_uap_rates() and mwifiex_set_wmm_params() call memcpy() without checking the destination size.Since the source is given from user-space, this may trigger a heap buffer overflow.  Fix them by putting the length check before performing memcpy().  This fix addresses CVE-2019-14814,CVE-2019-14815,CVE-2019-14816. ",
        "func_before": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}",
        "func": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,9 @@\n \t\t}\n \n \t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n+\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n+\t\t\tIEEE_MAX_IE_SIZE)\n+\t\t\treturn -EINVAL;\n \t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n \t\t       vs_ie, vs_ie->len + 2);\n \t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >",
                "\t\t\tIEEE_MAX_IE_SIZE)",
                "\t\t\treturn -EINVAL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14815",
        "func_name": "torvalds/linux/mwifiex_set_wmm_params",
        "description": "A vulnerability was found in Linux Kernel, where a Heap Overflow was found in mwifiex_set_wmm_params() function of Marvell Wifi Driver.",
        "git_url": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a",
        "commit_title": "mwifiex: Fix three heap overflow at parsing element in cfg80211_ap_settings",
        "commit_text": " mwifiex_update_vs_ie(),mwifiex_set_uap_rates() and mwifiex_set_wmm_params() call memcpy() without checking the destination size.Since the source is given from user-space, this may trigger a heap buffer overflow.  Fix them by putting the length check before performing memcpy().  This fix addresses CVE-2019-14814,CVE-2019-14815,CVE-2019-14816. ",
        "func_before": "void\nmwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}",
        "func": "void\nmwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,8 @@\n \t\t\t\t\t    params->beacon.tail_len);\n \tif (vendor_ie) {\n \t\twmm_ie = vendor_ie;\n+\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n+\t\t\treturn;\n \t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n \t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n \t\tpriv->wmm_enabled = 1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))",
                "\t\t\treturn;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14815",
        "func_name": "torvalds/linux/mwifiex_set_uap_rates",
        "description": "A vulnerability was found in Linux Kernel, where a Heap Overflow was found in mwifiex_set_wmm_params() function of Marvell Wifi Driver.",
        "git_url": "https://github.com/torvalds/linux/commit/7caac62ed598a196d6ddf8d9c121e12e082cac3a",
        "commit_title": "mwifiex: Fix three heap overflow at parsing element in cfg80211_ap_settings",
        "commit_text": " mwifiex_update_vs_ie(),mwifiex_set_uap_rates() and mwifiex_set_wmm_params() call memcpy() without checking the destination size.Since the source is given from user-space, this may trigger a heap buffer overflow.  Fix them by putting the length check before performing memcpy().  This fix addresses CVE-2019-14814,CVE-2019-14815,CVE-2019-14816. ",
        "func_before": "void\nmwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\n\treturn;\n}",
        "func": "void\nmwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\t}\n\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,8 @@\n \n \trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n \tif (rate_ie) {\n+\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)\n+\t\t\treturn;\n \t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n \t\trate_len = rate_ie->len;\n \t}\n@@ -17,8 +19,11 @@\n \trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n \t\t\t\t\t   params->beacon.tail,\n \t\t\t\t\t   params->beacon.tail_len);\n-\tif (rate_ie)\n+\tif (rate_ie) {\n+\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)\n+\t\t\treturn;\n \t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n+\t}\n \n \treturn;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (rate_ie)"
            ],
            "added_lines": [
                "\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)",
                "\t\t\treturn;",
                "\tif (rate_ie) {",
                "\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)",
                "\t\t\treturn;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3875",
        "func_name": "vim/get_address",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/35a319b77f897744eec1155b736e9372c9c5575f",
        "commit_title": "patch 8.2.3489: ml_get error after search with range",
        "commit_text": " Problem:    ml_get error after search with range. Solution:   Limit the line number to the buffer line count.",
        "func_before": "static linenr_T\nget_address(\n    exarg_T\t*eap UNUSED,\n    char_u\t**ptr,\n    cmd_addr_T\taddr_type,\n    int\t\tskip,\t\t// only skip the address, don't use it\n    int\t\tsilent,\t\t// no errors or side effects\n    int\t\tto_other_file,  // flag: may jump to other file\n    int\t\taddress_count UNUSED) // 1 for first address, >1 after comma\n{\n    int\t\tc;\n    int\t\ti;\n    long\tn;\n    char_u\t*cmd;\n    pos_T\tpos;\n    pos_T\t*fp;\n    linenr_T\tlnum;\n    buf_T\t*buf;\n\n    cmd = skipwhite(*ptr);\n    lnum = MAXLNUM;\n    do\n    {\n\tswitch (*cmd)\n\t{\n\t    case '.':\t\t\t    // '.' - Cursor position\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '$':\t\t\t    // '$' - last line\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = LAST_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = ARGCOUNT;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\tbuf = lastbuf;\n\t\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t\t{\n\t\t\t    if (buf->b_prev == NULL)\n\t\t\t\tbreak;\n\t\t\t    buf = buf->b_prev;\n\t\t\t}\n\t\t\tlnum = buf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = LAST_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_valid_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '\\'':\t\t\t    // ''' - mark\n\t\tif (*++cmd == NUL)\n\t\t{\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\n\t\t    ++cmd;\n\t\telse\n\t\t{\n\t\t    // Only accept a mark in another file when it is\n\t\t    // used by itself: \":'M\".\n\t\t    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n\t\t    ++cmd;\n\t\t    if (fp == (pos_T *)-1)\n\t\t\t// Jumped to another file.\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t    else\n\t\t    {\n\t\t\tif (check_mark(fp) == FAIL)\n\t\t\t{\n\t\t\t    cmd = NULL;\n\t\t\t    goto error;\n\t\t\t}\n\t\t\tlnum = fp->lnum;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '/':\n\t    case '?':\t\t\t// '/' or '?' - search\n\t\tc = *cmd++;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\t// skip \"/pat/\"\n\t\t{\n\t\t    cmd = skip_regexp(cmd, c, magic_isset());\n\t\t    if (*cmd == c)\n\t\t\t++cmd;\n\t\t}\n\t\telse\n\t\t{\n\t\t    int flags;\n\n\t\t    pos = curwin->w_cursor; // save curwin->w_cursor\n\n\t\t    // When '/' or '?' follows another address, start from\n\t\t    // there.\n\t\t    if (lnum != MAXLNUM)\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\n\t\t    // Start a forward search at the end of the line (unless\n\t\t    // before the first line).\n\t\t    // Start a backward search at the start of the line.\n\t\t    // This makes sure we never match in the current\n\t\t    // line, and can match anywhere in the\n\t\t    // next/previous line.\n\t\t    if (c == '/' && curwin->w_cursor.lnum > 0)\n\t\t\tcurwin->w_cursor.col = MAXCOL;\n\t\t    else\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    searchcmdlen = 0;\n\t\t    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n\t\t    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL))\n\t\t    {\n\t\t\tcurwin->w_cursor = pos;\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum = curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor = pos;\n\t\t    // adjust command string pointer\n\t\t    cmd += searchcmdlen;\n\t\t}\n\t\tbreak;\n\n\t    case '\\\\':\t\t    // \"\\?\", \"\\/\" or \"\\&\", repeat search\n\t\t++cmd;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (*cmd == '&')\n\t\t    i = RE_SUBST;\n\t\telse if (*cmd == '?' || *cmd == '/')\n\t\t    i = RE_SEARCH;\n\t\telse\n\t\t{\n\t\t    emsg(_(e_backslash_should_be_followed_by));\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t    /*\n\t\t     * When search follows another address, start from\n\t\t     * there.\n\t\t     */\n\t\t    if (lnum != MAXLNUM)\n\t\t\tpos.lnum = lnum;\n\t\t    else\n\t\t\tpos.lnum = curwin->w_cursor.lnum;\n\n\t\t    /*\n\t\t     * Start the search just like for the above\n\t\t     * do_search().\n\t\t     */\n\t\t    if (*cmd != '?')\n\t\t\tpos.col = MAXCOL;\n\t\t    else\n\t\t\tpos.col = 0;\n\t\t    pos.coladd = 0;\n\t\t    if (searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t*cmd == '?' ? BACKWARD : FORWARD,\n\t\t\t\t(char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL)\n\t\t\tlnum = pos.lnum;\n\t\t    else\n\t\t    {\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t}\n\t\t++cmd;\n\t\tbreak;\n\n\t    default:\n\t\tif (VIM_ISDIGIT(*cmd))\t// absolute line number\n\t\t    lnum = getdigits(&cmd);\n\t}\n\n\tfor (;;)\n\t{\n\t    cmd = skipwhite(cmd);\n\t    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))\n\t\tbreak;\n\n\t    if (lnum == MAXLNUM)\n\t    {\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\t// \"+1\" is same as \".+1\"\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t\tlnum = 1;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\tlnum = 0;\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    if (VIM_ISDIGIT(*cmd))\n\t\ti = '+';\t\t// \"number\" is same as \"+number\"\n\t    else\n\t\ti = *cmd++;\n\t    if (!VIM_ISDIGIT(*cmd))\t// '+' is '+1', but '+0' is not '+1'\n\t\tn = 1;\n\t    else\n\t\tn = getdigits(&cmd);\n\n\t    if (addr_type == ADDR_TABS_RELATIVE)\n\t    {\n\t\temsg(_(e_invalid_range));\n\t\tcmd = NULL;\n\t\tgoto error;\n\t    }\n\t    else if (addr_type == ADDR_LOADED_BUFFERS\n\t\t    || addr_type == ADDR_BUFFERS)\n\t\tlnum = compute_buffer_local_count(\n\t\t\t\t    addr_type, lnum, (i == '-') ? -1 * n : n);\n\t    else\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Relative line addressing, need to adjust for folded lines\n\t\t// now, but only do it after the first address.\n\t\tif (addr_type == ADDR_LINES && (i == '-' || i == '+')\n\t\t\t&& address_count >= 2)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t\tif (i == '-')\n\t\t    lnum -= n;\n\t\telse\n\t\t    lnum += n;\n\t    }\n\t}\n    } while (*cmd == '/' || *cmd == '?');\n\nerror:\n    *ptr = cmd;\n    return lnum;\n}",
        "func": "static linenr_T\nget_address(\n    exarg_T\t*eap UNUSED,\n    char_u\t**ptr,\n    cmd_addr_T\taddr_type,\n    int\t\tskip,\t\t// only skip the address, don't use it\n    int\t\tsilent,\t\t// no errors or side effects\n    int\t\tto_other_file,  // flag: may jump to other file\n    int\t\taddress_count UNUSED) // 1 for first address, >1 after comma\n{\n    int\t\tc;\n    int\t\ti;\n    long\tn;\n    char_u\t*cmd;\n    pos_T\tpos;\n    pos_T\t*fp;\n    linenr_T\tlnum;\n    buf_T\t*buf;\n\n    cmd = skipwhite(*ptr);\n    lnum = MAXLNUM;\n    do\n    {\n\tswitch (*cmd)\n\t{\n\t    case '.':\t\t\t    // '.' - Cursor position\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '$':\t\t\t    // '$' - last line\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = LAST_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = ARGCOUNT;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\tbuf = lastbuf;\n\t\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t\t{\n\t\t\t    if (buf->b_prev == NULL)\n\t\t\t\tbreak;\n\t\t\t    buf = buf->b_prev;\n\t\t\t}\n\t\t\tlnum = buf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = LAST_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_valid_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '\\'':\t\t\t    // ''' - mark\n\t\tif (*++cmd == NUL)\n\t\t{\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\n\t\t    ++cmd;\n\t\telse\n\t\t{\n\t\t    // Only accept a mark in another file when it is\n\t\t    // used by itself: \":'M\".\n\t\t    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n\t\t    ++cmd;\n\t\t    if (fp == (pos_T *)-1)\n\t\t\t// Jumped to another file.\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t    else\n\t\t    {\n\t\t\tif (check_mark(fp) == FAIL)\n\t\t\t{\n\t\t\t    cmd = NULL;\n\t\t\t    goto error;\n\t\t\t}\n\t\t\tlnum = fp->lnum;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '/':\n\t    case '?':\t\t\t// '/' or '?' - search\n\t\tc = *cmd++;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\t// skip \"/pat/\"\n\t\t{\n\t\t    cmd = skip_regexp(cmd, c, magic_isset());\n\t\t    if (*cmd == c)\n\t\t\t++cmd;\n\t\t}\n\t\telse\n\t\t{\n\t\t    int flags;\n\n\t\t    pos = curwin->w_cursor; // save curwin->w_cursor\n\n\t\t    // When '/' or '?' follows another address, start from\n\t\t    // there.\n\t\t    if (lnum > 0 && lnum != MAXLNUM)\n\t\t\tcurwin->w_cursor.lnum =\n\t\t\t\tlnum > curbuf->b_ml.ml_line_count\n\t\t\t\t\t   ? curbuf->b_ml.ml_line_count : lnum;\n\n\t\t    // Start a forward search at the end of the line (unless\n\t\t    // before the first line).\n\t\t    // Start a backward search at the start of the line.\n\t\t    // This makes sure we never match in the current\n\t\t    // line, and can match anywhere in the\n\t\t    // next/previous line.\n\t\t    if (c == '/' && curwin->w_cursor.lnum > 0)\n\t\t\tcurwin->w_cursor.col = MAXCOL;\n\t\t    else\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    searchcmdlen = 0;\n\t\t    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n\t\t    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL))\n\t\t    {\n\t\t\tcurwin->w_cursor = pos;\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum = curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor = pos;\n\t\t    // adjust command string pointer\n\t\t    cmd += searchcmdlen;\n\t\t}\n\t\tbreak;\n\n\t    case '\\\\':\t\t    // \"\\?\", \"\\/\" or \"\\&\", repeat search\n\t\t++cmd;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (*cmd == '&')\n\t\t    i = RE_SUBST;\n\t\telse if (*cmd == '?' || *cmd == '/')\n\t\t    i = RE_SEARCH;\n\t\telse\n\t\t{\n\t\t    emsg(_(e_backslash_should_be_followed_by));\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t    /*\n\t\t     * When search follows another address, start from\n\t\t     * there.\n\t\t     */\n\t\t    if (lnum != MAXLNUM)\n\t\t\tpos.lnum = lnum;\n\t\t    else\n\t\t\tpos.lnum = curwin->w_cursor.lnum;\n\n\t\t    /*\n\t\t     * Start the search just like for the above\n\t\t     * do_search().\n\t\t     */\n\t\t    if (*cmd != '?')\n\t\t\tpos.col = MAXCOL;\n\t\t    else\n\t\t\tpos.col = 0;\n\t\t    pos.coladd = 0;\n\t\t    if (searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t*cmd == '?' ? BACKWARD : FORWARD,\n\t\t\t\t(char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL)\n\t\t\tlnum = pos.lnum;\n\t\t    else\n\t\t    {\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t}\n\t\t++cmd;\n\t\tbreak;\n\n\t    default:\n\t\tif (VIM_ISDIGIT(*cmd))\t// absolute line number\n\t\t    lnum = getdigits(&cmd);\n\t}\n\n\tfor (;;)\n\t{\n\t    cmd = skipwhite(cmd);\n\t    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))\n\t\tbreak;\n\n\t    if (lnum == MAXLNUM)\n\t    {\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\t// \"+1\" is same as \".+1\"\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t\tlnum = 1;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\tlnum = 0;\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    if (VIM_ISDIGIT(*cmd))\n\t\ti = '+';\t\t// \"number\" is same as \"+number\"\n\t    else\n\t\ti = *cmd++;\n\t    if (!VIM_ISDIGIT(*cmd))\t// '+' is '+1', but '+0' is not '+1'\n\t\tn = 1;\n\t    else\n\t\tn = getdigits(&cmd);\n\n\t    if (addr_type == ADDR_TABS_RELATIVE)\n\t    {\n\t\temsg(_(e_invalid_range));\n\t\tcmd = NULL;\n\t\tgoto error;\n\t    }\n\t    else if (addr_type == ADDR_LOADED_BUFFERS\n\t\t    || addr_type == ADDR_BUFFERS)\n\t\tlnum = compute_buffer_local_count(\n\t\t\t\t    addr_type, lnum, (i == '-') ? -1 * n : n);\n\t    else\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Relative line addressing, need to adjust for folded lines\n\t\t// now, but only do it after the first address.\n\t\tif (addr_type == ADDR_LINES && (i == '-' || i == '+')\n\t\t\t&& address_count >= 2)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t\tif (i == '-')\n\t\t    lnum -= n;\n\t\telse\n\t\t    lnum += n;\n\t    }\n\t}\n    } while (*cmd == '/' || *cmd == '?');\n\nerror:\n    *ptr = cmd;\n    return lnum;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -176,8 +176,10 @@\n \n \t\t    // When '/' or '?' follows another address, start from\n \t\t    // there.\n-\t\t    if (lnum != MAXLNUM)\n-\t\t\tcurwin->w_cursor.lnum = lnum;\n+\t\t    if (lnum > 0 && lnum != MAXLNUM)\n+\t\t\tcurwin->w_cursor.lnum =\n+\t\t\t\tlnum > curbuf->b_ml.ml_line_count\n+\t\t\t\t\t   ? curbuf->b_ml.ml_line_count : lnum;\n \n \t\t    // Start a forward search at the end of the line (unless\n \t\t    // before the first line).",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    if (lnum != MAXLNUM)",
                "\t\t\tcurwin->w_cursor.lnum = lnum;"
            ],
            "added_lines": [
                "\t\t    if (lnum > 0 && lnum != MAXLNUM)",
                "\t\t\tcurwin->w_cursor.lnum =",
                "\t\t\t\tlnum > curbuf->b_ml.ml_line_count",
                "\t\t\t\t\t   ? curbuf->b_ml.ml_line_count : lnum;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3872",
        "func_name": "vim/win_redr_status",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/826bfe4bbd7594188e3d74d2539d9707b1c6a14b",
        "commit_title": "patch 8.2.3487: illegal memory access if buffer name is very long",
        "commit_text": " Problem:    Illegal memory access if buffer name is very long. Solution:   Make sure not to go over the end of the buffer.",
        "func_before": "static void\nwin_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif (bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t|| wp->w_p_pvw\n#endif\n\t\t|| bufIsChanged(wp->w_buffer)\n\t\t|| wp->w_buffer->b_p_ro)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    STRCPY(p + len, _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    STRCPY(p + len, _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    STRCPY(p + len, \"[+]\");\n\t    len += 3;\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    STRCPY(p + len, _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}",
        "func": "static void\nwin_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif (bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t|| wp->w_p_pvw\n#endif\n\t\t|| bufIsChanged(wp->w_buffer)\n\t\t|| wp->w_buffer->b_p_ro)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,13 +55,13 @@\n \t    *(p + len++) = ' ';\n \tif (bt_help(wp->w_buffer))\n \t{\n-\t    STRCPY(p + len, _(\"[Help]\"));\n+\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n \t    len += (int)STRLEN(p + len);\n \t}\n #ifdef FEAT_QUICKFIX\n \tif (wp->w_p_pvw)\n \t{\n-\t    STRCPY(p + len, _(\"[Preview]\"));\n+\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n \t    len += (int)STRLEN(p + len);\n \t}\n #endif\n@@ -71,12 +71,12 @@\n #endif\n \t\t)\n \t{\n-\t    STRCPY(p + len, \"[+]\");\n-\t    len += 3;\n+\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n+\t    len += (int)STRLEN(p + len);\n \t}\n \tif (wp->w_buffer->b_p_ro)\n \t{\n-\t    STRCPY(p + len, _(\"[RO]\"));\n+\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n \t    len += (int)STRLEN(p + len);\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t    STRCPY(p + len, _(\"[Help]\"));",
                "\t    STRCPY(p + len, _(\"[Preview]\"));",
                "\t    STRCPY(p + len, \"[+]\");",
                "\t    len += 3;",
                "\t    STRCPY(p + len, _(\"[RO]\"));"
            ],
            "added_lines": [
                "\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));",
                "\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));",
                "\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");",
                "\t    len += (int)STRLEN(p + len);",
                "\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3903",
        "func_name": "vim/update_topline",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/777e7c21b7627be80961848ac560cb0a9978ff43",
        "commit_title": "patch 8.2.3564: invalid memory access when scrolling without valid screen",
        "commit_text": " Problem:    Invalid memory access when scrolling without a valid screen. Solution:   Do not set VALID_BOTLINE in w_valid.",
        "func_before": "void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(NOT_VALID);\n\t}\n\telse\n\t    redraw_later(VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}",
        "func": "void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(NOT_VALID);\n\t}\n\telse\n\t    redraw_later(VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,6 @@\n \tcheck_cursor_lnum();\n \tcurwin->w_topline = curwin->w_cursor.lnum;\n \tcurwin->w_botline = curwin->w_topline;\n-\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n \tcurwin->w_scbind_pos = 1;\n \treturn;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-3927",
        "func_name": "vim/ex_put",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/0b5b06cb4777d1401fdf83e7d48d287662236e7e",
        "commit_title": "patch 8.2.3581: reading character past end of line",
        "commit_text": " Problem:    Reading character past end of line. Solution:   Correct the cursor column.",
        "func_before": "static void\nex_put(exarg_T *eap)\n{\n    // \":0put\" works like \":1put!\".\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}",
        "func": "static void\nex_put(exarg_T *eap)\n{\n    // \":0put\" works like \":1put!\".\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n \teap->forceit = TRUE;\n     }\n     curwin->w_cursor.lnum = eap->line2;\n+    check_cursor_col();\n     do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n \t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    check_cursor_col();"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3968",
        "func_name": "vim/n_start_visual_mode",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/a062006b9de0b2947ab5fb376c6e67ef92a8cd69",
        "commit_title": "patch 8.2.3610: crash when ModeChanged triggered too early",
        "commit_text": " Problem:    Crash when ModeChanged triggered too early. Solution:   Trigger ModeChanged after setting VIsual.",
        "func_before": "static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}",
        "func": "static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,6 @@\n     VIsual_mode = c;\n     VIsual_active = TRUE;\n     VIsual_reselect = TRUE;\n-    trigger_modechanged();\n \n     // Corner case: the 0 position in a tab may change when going into\n     // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n@@ -24,6 +23,7 @@\n     foldAdjustVisual();\n #endif\n \n+    trigger_modechanged();\n     setmouse();\n #ifdef FEAT_CONCEAL\n     // Check if redraw is needed after changing the state.",
        "diff_line_info": {
            "deleted_lines": [
                "    trigger_modechanged();"
            ],
            "added_lines": [
                "    trigger_modechanged();"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3973",
        "func_name": "vim/find_file_in_path_option",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/615ddd5342b50a6878a907062aa471740bd9a847",
        "commit_title": "patch 8.2.3611: crash when using CTRL-W f without finding a file name",
        "commit_text": " Problem:    Crash when using CTRL-W f without finding a file name. Solution:   Bail out when the file name length is zero.",
        "func_before": "char_u *\nfind_file_in_path_option(\n    char_u\t*ptr,\t\t// file name\n    int\t\tlen,\t\t// length of file name\n    int\t\toptions,\n    int\t\tfirst,\t\t// use count'th matching file name\n    char_u\t*path_option,\t// p_path or p_cdpath\n    int\t\tfind_what,\t// FINDFILE_FILE, _DIR or _BOTH\n    char_u\t*rel_fname,\t// file name we are looking relative to.\n    char_u\t*suffixes)\t// list of suffixes, 'suffixesadd' option\n{\n    static char_u\t*dir;\n    static int\t\tdid_findfile_init = FALSE;\n    char_u\t\tsave_char;\n    char_u\t\t*file_name = NULL;\n    char_u\t\t*buf = NULL;\n    int\t\t\trel_to_curdir;\n# ifdef AMIGA\n    struct Process\t*proc = (struct Process *)FindTask(0L);\n    APTR\t\tsave_winptr = proc->pr_WindowPtr;\n\n    // Avoid a requester here for a volume that doesn't exist.\n    proc->pr_WindowPtr = (APTR)-1L;\n# endif\n\n    if (first == TRUE)\n    {\n\t// copy file name into NameBuff, expanding environment variables\n\tsave_char = ptr[len];\n\tptr[len] = NUL;\n\texpand_env_esc(ptr, NameBuff, MAXPATHL, FALSE, TRUE, NULL);\n\tptr[len] = save_char;\n\n\tvim_free(ff_file_to_find);\n\tff_file_to_find = vim_strsave(NameBuff);\n\tif (ff_file_to_find == NULL)\t// out of memory\n\t{\n\t    file_name = NULL;\n\t    goto theend;\n\t}\n\tif (options & FNAME_UNESC)\n\t{\n\t    // Change all \"\\ \" to \" \".\n\t    for (ptr = ff_file_to_find; *ptr != NUL; ++ptr)\n\t\tif (ptr[0] == '\\\\' && ptr[1] == ' ')\n\t\t    mch_memmove(ptr, ptr + 1, STRLEN(ptr));\n\t}\n    }\n\n    rel_to_curdir = (ff_file_to_find[0] == '.'\n\t\t    && (ff_file_to_find[1] == NUL\n\t\t\t|| vim_ispathsep(ff_file_to_find[1])\n\t\t\t|| (ff_file_to_find[1] == '.'\n\t\t\t    && (ff_file_to_find[2] == NUL\n\t\t\t\t|| vim_ispathsep(ff_file_to_find[2])))));\n    if (vim_isAbsName(ff_file_to_find)\n\t    // \"..\", \"../path\", \".\" and \"./path\": don't use the path_option\n\t    || rel_to_curdir\n# if defined(MSWIN)\n\t    // handle \"\\tmp\" as absolute path\n\t    || vim_ispathsep(ff_file_to_find[0])\n\t    // handle \"c:name\" as absolute path\n\t    || (ff_file_to_find[0] != NUL && ff_file_to_find[1] == ':')\n# endif\n# ifdef AMIGA\n\t    // handle \":tmp\" as absolute path\n\t    || ff_file_to_find[0] == ':'\n# endif\n       )\n    {\n\t/*\n\t * Absolute path, no need to use \"path_option\".\n\t * If this is not a first call, return NULL.  We already returned a\n\t * filename on the first call.\n\t */\n\tif (first == TRUE)\n\t{\n\t    int\t\tl;\n\t    int\t\trun;\n\n\t    if (path_with_url(ff_file_to_find))\n\t    {\n\t\tfile_name = vim_strsave(ff_file_to_find);\n\t\tgoto theend;\n\t    }\n\n\t    // When FNAME_REL flag given first use the directory of the file.\n\t    // Otherwise or when this fails use the current directory.\n\t    for (run = 1; run <= 2; ++run)\n\t    {\n\t\tl = (int)STRLEN(ff_file_to_find);\n\t\tif (run == 1\n\t\t\t&& rel_to_curdir\n\t\t\t&& (options & FNAME_REL)\n\t\t\t&& rel_fname != NULL\n\t\t\t&& STRLEN(rel_fname) + l < MAXPATHL)\n\t\t{\n\t\t    STRCPY(NameBuff, rel_fname);\n\t\t    STRCPY(gettail(NameBuff), ff_file_to_find);\n\t\t    l = (int)STRLEN(NameBuff);\n\t\t}\n\t\telse\n\t\t{\n\t\t    STRCPY(NameBuff, ff_file_to_find);\n\t\t    run = 2;\n\t\t}\n\n\t\t// When the file doesn't exist, try adding parts of\n\t\t// 'suffixesadd'.\n\t\tbuf = suffixes;\n\t\tfor (;;)\n\t\t{\n\t\t    if (mch_getperm(NameBuff) >= 0\n\t\t\t     && (find_what == FINDFILE_BOTH\n\t\t\t\t || ((find_what == FINDFILE_DIR)\n\t\t\t\t\t\t    == mch_isdir(NameBuff))))\n\t\t    {\n\t\t\tfile_name = vim_strsave(NameBuff);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (*buf == NUL)\n\t\t\tbreak;\n\t\t    copy_option_part(&buf, NameBuff + l, MAXPATHL - l, \",\");\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * Loop over all paths in the 'path' or 'cdpath' option.\n\t * When \"first\" is set, first setup to the start of the option.\n\t * Otherwise continue to find the next match.\n\t */\n\tif (first == TRUE)\n\t{\n\t    // vim_findfile_free_visited can handle a possible NULL pointer\n\t    vim_findfile_free_visited(fdip_search_ctx);\n\t    dir = path_option;\n\t    did_findfile_init = FALSE;\n\t}\n\n\tfor (;;)\n\t{\n\t    if (did_findfile_init)\n\t    {\n\t\tfile_name = vim_findfile(fdip_search_ctx);\n\t\tif (file_name != NULL)\n\t\t    break;\n\n\t\tdid_findfile_init = FALSE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u  *r_ptr;\n\n\t\tif (dir == NULL || *dir == NUL)\n\t\t{\n\t\t    // We searched all paths of the option, now we can\n\t\t    // free the search context.\n\t\t    vim_findfile_cleanup(fdip_search_ctx);\n\t\t    fdip_search_ctx = NULL;\n\t\t    break;\n\t\t}\n\n\t\tif ((buf = alloc(MAXPATHL)) == NULL)\n\t\t    break;\n\n\t\t// copy next path\n\t\tbuf[0] = 0;\n\t\tcopy_option_part(&dir, buf, MAXPATHL, \" ,\");\n\n# ifdef FEAT_PATH_EXTRA\n\t\t// get the stopdir string\n\t\tr_ptr = vim_findfile_stopdir(buf);\n# else\n\t\tr_ptr = NULL;\n# endif\n\t\tfdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,\n\t\t\t\t\t    r_ptr, 100, FALSE, find_what,\n\t\t\t\t\t   fdip_search_ctx, FALSE, rel_fname);\n\t\tif (fdip_search_ctx != NULL)\n\t\t    did_findfile_init = TRUE;\n\t\tvim_free(buf);\n\t    }\n\t}\n    }\n    if (file_name == NULL && (options & FNAME_MESS))\n    {\n\tif (first == TRUE)\n\t{\n\t    if (find_what == FINDFILE_DIR)\n\t\tsemsg(_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"),\n\t\t\tff_file_to_find);\n\t    else\n\t\tsemsg(_(\"E345: Can't find file \\\"%s\\\" in path\"),\n\t\t\tff_file_to_find);\n\t}\n\telse\n\t{\n\t    if (find_what == FINDFILE_DIR)\n\t\tsemsg(_(\"E346: No more directory \\\"%s\\\" found in cdpath\"),\n\t\t\tff_file_to_find);\n\t    else\n\t\tsemsg(_(\"E347: No more file \\\"%s\\\" found in path\"),\n\t\t\tff_file_to_find);\n\t}\n    }\n\ntheend:\n# ifdef AMIGA\n    proc->pr_WindowPtr = save_winptr;\n# endif\n    return file_name;\n}",
        "func": "char_u *\nfind_file_in_path_option(\n    char_u\t*ptr,\t\t// file name\n    int\t\tlen,\t\t// length of file name\n    int\t\toptions,\n    int\t\tfirst,\t\t// use count'th matching file name\n    char_u\t*path_option,\t// p_path or p_cdpath\n    int\t\tfind_what,\t// FINDFILE_FILE, _DIR or _BOTH\n    char_u\t*rel_fname,\t// file name we are looking relative to.\n    char_u\t*suffixes)\t// list of suffixes, 'suffixesadd' option\n{\n    static char_u\t*dir;\n    static int\t\tdid_findfile_init = FALSE;\n    char_u\t\tsave_char;\n    char_u\t\t*file_name = NULL;\n    char_u\t\t*buf = NULL;\n    int\t\t\trel_to_curdir;\n# ifdef AMIGA\n    struct Process\t*proc = (struct Process *)FindTask(0L);\n    APTR\t\tsave_winptr = proc->pr_WindowPtr;\n\n    // Avoid a requester here for a volume that doesn't exist.\n    proc->pr_WindowPtr = (APTR)-1L;\n# endif\n\n    if (len == 0)\n\treturn NULL;\n\n    if (first == TRUE)\n    {\n\t// copy file name into NameBuff, expanding environment variables\n\tsave_char = ptr[len];\n\tptr[len] = NUL;\n\texpand_env_esc(ptr, NameBuff, MAXPATHL, FALSE, TRUE, NULL);\n\tptr[len] = save_char;\n\n\tvim_free(ff_file_to_find);\n\tff_file_to_find = vim_strsave(NameBuff);\n\tif (ff_file_to_find == NULL)\t// out of memory\n\t{\n\t    file_name = NULL;\n\t    goto theend;\n\t}\n\tif (options & FNAME_UNESC)\n\t{\n\t    // Change all \"\\ \" to \" \".\n\t    for (ptr = ff_file_to_find; *ptr != NUL; ++ptr)\n\t\tif (ptr[0] == '\\\\' && ptr[1] == ' ')\n\t\t    mch_memmove(ptr, ptr + 1, STRLEN(ptr));\n\t}\n    }\n\n    rel_to_curdir = (ff_file_to_find[0] == '.'\n\t\t    && (ff_file_to_find[1] == NUL\n\t\t\t|| vim_ispathsep(ff_file_to_find[1])\n\t\t\t|| (ff_file_to_find[1] == '.'\n\t\t\t    && (ff_file_to_find[2] == NUL\n\t\t\t\t|| vim_ispathsep(ff_file_to_find[2])))));\n    if (vim_isAbsName(ff_file_to_find)\n\t    // \"..\", \"../path\", \".\" and \"./path\": don't use the path_option\n\t    || rel_to_curdir\n# if defined(MSWIN)\n\t    // handle \"\\tmp\" as absolute path\n\t    || vim_ispathsep(ff_file_to_find[0])\n\t    // handle \"c:name\" as absolute path\n\t    || (ff_file_to_find[0] != NUL && ff_file_to_find[1] == ':')\n# endif\n# ifdef AMIGA\n\t    // handle \":tmp\" as absolute path\n\t    || ff_file_to_find[0] == ':'\n# endif\n       )\n    {\n\t/*\n\t * Absolute path, no need to use \"path_option\".\n\t * If this is not a first call, return NULL.  We already returned a\n\t * filename on the first call.\n\t */\n\tif (first == TRUE)\n\t{\n\t    int\t\tl;\n\t    int\t\trun;\n\n\t    if (path_with_url(ff_file_to_find))\n\t    {\n\t\tfile_name = vim_strsave(ff_file_to_find);\n\t\tgoto theend;\n\t    }\n\n\t    // When FNAME_REL flag given first use the directory of the file.\n\t    // Otherwise or when this fails use the current directory.\n\t    for (run = 1; run <= 2; ++run)\n\t    {\n\t\tl = (int)STRLEN(ff_file_to_find);\n\t\tif (run == 1\n\t\t\t&& rel_to_curdir\n\t\t\t&& (options & FNAME_REL)\n\t\t\t&& rel_fname != NULL\n\t\t\t&& STRLEN(rel_fname) + l < MAXPATHL)\n\t\t{\n\t\t    STRCPY(NameBuff, rel_fname);\n\t\t    STRCPY(gettail(NameBuff), ff_file_to_find);\n\t\t    l = (int)STRLEN(NameBuff);\n\t\t}\n\t\telse\n\t\t{\n\t\t    STRCPY(NameBuff, ff_file_to_find);\n\t\t    run = 2;\n\t\t}\n\n\t\t// When the file doesn't exist, try adding parts of\n\t\t// 'suffixesadd'.\n\t\tbuf = suffixes;\n\t\tfor (;;)\n\t\t{\n\t\t    if (mch_getperm(NameBuff) >= 0\n\t\t\t     && (find_what == FINDFILE_BOTH\n\t\t\t\t || ((find_what == FINDFILE_DIR)\n\t\t\t\t\t\t    == mch_isdir(NameBuff))))\n\t\t    {\n\t\t\tfile_name = vim_strsave(NameBuff);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (*buf == NUL)\n\t\t\tbreak;\n\t\t    copy_option_part(&buf, NameBuff + l, MAXPATHL - l, \",\");\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * Loop over all paths in the 'path' or 'cdpath' option.\n\t * When \"first\" is set, first setup to the start of the option.\n\t * Otherwise continue to find the next match.\n\t */\n\tif (first == TRUE)\n\t{\n\t    // vim_findfile_free_visited can handle a possible NULL pointer\n\t    vim_findfile_free_visited(fdip_search_ctx);\n\t    dir = path_option;\n\t    did_findfile_init = FALSE;\n\t}\n\n\tfor (;;)\n\t{\n\t    if (did_findfile_init)\n\t    {\n\t\tfile_name = vim_findfile(fdip_search_ctx);\n\t\tif (file_name != NULL)\n\t\t    break;\n\n\t\tdid_findfile_init = FALSE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u  *r_ptr;\n\n\t\tif (dir == NULL || *dir == NUL)\n\t\t{\n\t\t    // We searched all paths of the option, now we can\n\t\t    // free the search context.\n\t\t    vim_findfile_cleanup(fdip_search_ctx);\n\t\t    fdip_search_ctx = NULL;\n\t\t    break;\n\t\t}\n\n\t\tif ((buf = alloc(MAXPATHL)) == NULL)\n\t\t    break;\n\n\t\t// copy next path\n\t\tbuf[0] = 0;\n\t\tcopy_option_part(&dir, buf, MAXPATHL, \" ,\");\n\n# ifdef FEAT_PATH_EXTRA\n\t\t// get the stopdir string\n\t\tr_ptr = vim_findfile_stopdir(buf);\n# else\n\t\tr_ptr = NULL;\n# endif\n\t\tfdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,\n\t\t\t\t\t    r_ptr, 100, FALSE, find_what,\n\t\t\t\t\t   fdip_search_ctx, FALSE, rel_fname);\n\t\tif (fdip_search_ctx != NULL)\n\t\t    did_findfile_init = TRUE;\n\t\tvim_free(buf);\n\t    }\n\t}\n    }\n    if (file_name == NULL && (options & FNAME_MESS))\n    {\n\tif (first == TRUE)\n\t{\n\t    if (find_what == FINDFILE_DIR)\n\t\tsemsg(_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"),\n\t\t\tff_file_to_find);\n\t    else\n\t\tsemsg(_(\"E345: Can't find file \\\"%s\\\" in path\"),\n\t\t\tff_file_to_find);\n\t}\n\telse\n\t{\n\t    if (find_what == FINDFILE_DIR)\n\t\tsemsg(_(\"E346: No more directory \\\"%s\\\" found in cdpath\"),\n\t\t\tff_file_to_find);\n\t    else\n\t\tsemsg(_(\"E347: No more file \\\"%s\\\" found in path\"),\n\t\t\tff_file_to_find);\n\t}\n    }\n\ntheend:\n# ifdef AMIGA\n    proc->pr_WindowPtr = save_winptr;\n# endif\n    return file_name;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,9 @@\n     proc->pr_WindowPtr = (APTR)-1L;\n # endif\n \n+    if (len == 0)\n+\treturn NULL;\n+\n     if (first == TRUE)\n     {\n \t// copy file name into NameBuff, expanding environment variables",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (len == 0)",
                "\treturn NULL;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3973",
        "func_name": "vim/find_file_name_in_path",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/615ddd5342b50a6878a907062aa471740bd9a847",
        "commit_title": "patch 8.2.3611: crash when using CTRL-W f without finding a file name",
        "commit_text": " Problem:    Crash when using CTRL-W f without finding a file name. Solution:   Bail out when the file name length is zero.",
        "func_before": "char_u *\nfind_file_name_in_path(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\toptions,\n    long\tcount,\n    char_u\t*rel_fname)\t// file we are searching relative to\n{\n    char_u\t*file_name;\n    int\t\tc;\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    char_u\t*tofree = NULL;\n\n    if ((options & FNAME_INCL) && *curbuf->b_p_inex != NUL)\n    {\n\ttofree = eval_includeexpr(ptr, len);\n\tif (tofree != NULL)\n\t{\n\t    ptr = tofree;\n\t    len = (int)STRLEN(ptr);\n\t}\n    }\n# endif\n\n    if (options & FNAME_EXP)\n    {\n\tfile_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,\n\t\t\t\t\t\t\t     TRUE, rel_fname);\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n\t/*\n\t * If the file could not be found in a normal way, try applying\n\t * 'includeexpr' (unless done already).\n\t */\n\tif (file_name == NULL\n\t\t&& !(options & FNAME_INCL) && *curbuf->b_p_inex != NUL)\n\t{\n\t    tofree = eval_includeexpr(ptr, len);\n\t    if (tofree != NULL)\n\t    {\n\t\tptr = tofree;\n\t\tlen = (int)STRLEN(ptr);\n\t\tfile_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,\n\t\t\t\t\t\t\t     TRUE, rel_fname);\n\t    }\n\t}\n# endif\n\tif (file_name == NULL && (options & FNAME_MESS))\n\t{\n\t    c = ptr[len];\n\t    ptr[len] = NUL;\n\t    semsg(_(\"E447: Can't find file \\\"%s\\\" in path\"), ptr);\n\t    ptr[len] = c;\n\t}\n\n\t// Repeat finding the file \"count\" times.  This matters when it\n\t// appears several times in the path.\n\twhile (file_name != NULL && --count > 0)\n\t{\n\t    vim_free(file_name);\n\t    file_name = find_file_in_path(ptr, len, options, FALSE, rel_fname);\n\t}\n    }\n    else\n\tfile_name = vim_strnsave(ptr, len);\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    vim_free(tofree);\n# endif\n\n    return file_name;\n}",
        "func": "char_u *\nfind_file_name_in_path(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\toptions,\n    long\tcount,\n    char_u\t*rel_fname)\t// file we are searching relative to\n{\n    char_u\t*file_name;\n    int\t\tc;\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    char_u\t*tofree = NULL;\n# endif\n\n    if (len == 0)\n\treturn NULL;\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    if ((options & FNAME_INCL) && *curbuf->b_p_inex != NUL)\n    {\n\ttofree = eval_includeexpr(ptr, len);\n\tif (tofree != NULL)\n\t{\n\t    ptr = tofree;\n\t    len = (int)STRLEN(ptr);\n\t}\n    }\n# endif\n\n    if (options & FNAME_EXP)\n    {\n\tfile_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,\n\t\t\t\t\t\t\t     TRUE, rel_fname);\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n\t/*\n\t * If the file could not be found in a normal way, try applying\n\t * 'includeexpr' (unless done already).\n\t */\n\tif (file_name == NULL\n\t\t&& !(options & FNAME_INCL) && *curbuf->b_p_inex != NUL)\n\t{\n\t    tofree = eval_includeexpr(ptr, len);\n\t    if (tofree != NULL)\n\t    {\n\t\tptr = tofree;\n\t\tlen = (int)STRLEN(ptr);\n\t\tfile_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,\n\t\t\t\t\t\t\t     TRUE, rel_fname);\n\t    }\n\t}\n# endif\n\tif (file_name == NULL && (options & FNAME_MESS))\n\t{\n\t    c = ptr[len];\n\t    ptr[len] = NUL;\n\t    semsg(_(\"E447: Can't find file \\\"%s\\\" in path\"), ptr);\n\t    ptr[len] = c;\n\t}\n\n\t// Repeat finding the file \"count\" times.  This matters when it\n\t// appears several times in the path.\n\twhile (file_name != NULL && --count > 0)\n\t{\n\t    vim_free(file_name);\n\t    file_name = find_file_in_path(ptr, len, options, FALSE, rel_fname);\n\t}\n    }\n    else\n\tfile_name = vim_strnsave(ptr, len);\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    vim_free(tofree);\n# endif\n\n    return file_name;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,12 @@\n     int\t\tc;\n # if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n     char_u\t*tofree = NULL;\n+# endif\n \n+    if (len == 0)\n+\treturn NULL;\n+\n+# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n     if ((options & FNAME_INCL) && *curbuf->b_p_inex != NUL)\n     {\n \ttofree = eval_includeexpr(ptr, len);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "# endif",
                "    if (len == 0)",
                "\treturn NULL;",
                "",
                "# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3973",
        "func_name": "vim/get_visual_text",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/615ddd5342b50a6878a907062aa471740bd9a847",
        "commit_title": "patch 8.2.3611: crash when using CTRL-W f without finding a file name",
        "commit_text": " Problem:    Crash when using CTRL-W f without finding a file name. Solution:   Bail out when the file name length is zero.",
        "func_before": "int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (has_mbyte)\n\t    // Correct the length to include the whole last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
        "func": "int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (has_mbyte && *lenp > 0)\n\t    // Correct the length to include all bytes of the last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,8 +29,10 @@\n \t    *pp = ml_get_pos(&VIsual);\n \t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n \t}\n-\tif (has_mbyte)\n-\t    // Correct the length to include the whole last character.\n+\tif (**pp == NUL)\n+\t    *lenp = 0;\n+\tif (has_mbyte && *lenp > 0)\n+\t    // Correct the length to include all bytes of the last character.\n \t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n     }\n     reset_VIsual_and_resel();",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (has_mbyte)",
                "\t    // Correct the length to include the whole last character."
            ],
            "added_lines": [
                "\tif (**pp == NUL)",
                "\t    *lenp = 0;",
                "\tif (has_mbyte && *lenp > 0)",
                "\t    // Correct the length to include all bytes of the last character."
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4019",
        "func_name": "vim/find_help_tags",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/bd228fd097b41a798f90944b5d1245eddd484142",
        "commit_title": "patch 8.2.3669: buffer overflow with long help argument",
        "commit_text": " Problem:    Buffer overflow with long help argument. Solution:   Use snprintf().",
        "func_before": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    STRCPY(d, \"/\\\\\\\\\");\n\t    STRCPY(d + 3, arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "func": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    vim_snprintf((char *)d, IOSIZE, \"/\\\\\\\\%s\", arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -105,8 +105,7 @@\n \t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n \t\t\t\t\t\t\t   && arg[2] != NUL)))\n \t{\n-\t    STRCPY(d, \"/\\\\\\\\\");\n-\t    STRCPY(d + 3, arg + 1);\n+\t    vim_snprintf((char *)d, IOSIZE, \"/\\\\\\\\%s\", arg + 1);\n \t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n \t    if (d[3] == '_' && d[4] == '$')\n \t\tSTRCPY(d + 4, \"\\\\$\");",
        "diff_line_info": {
            "deleted_lines": [
                "\t    STRCPY(d, \"/\\\\\\\\\");",
                "\t    STRCPY(d + 3, arg + 1);"
            ],
            "added_lines": [
                "\t    vim_snprintf((char *)d, IOSIZE, \"/\\\\\\\\%s\", arg + 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3984",
        "func_name": "vim/find_start_brace",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/2de9b7c7c8791da8853a9a7ca9c467867465b655",
        "commit_title": "patch 8.2.3625: illegal memory access when C-indenting",
        "commit_text": " Problem:    Illegal memory access when C-indenting. Solution:   Also set the cursor column.",
        "func_before": "static pos_T *\nfind_start_brace(void)\t    // XXX\n{\n    pos_T\tcursor_save;\n    pos_T\t*trypos;\n    pos_T\t*pos;\n    static pos_T\tpos_copy;\n\n    cursor_save = curwin->w_cursor;\n    while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)\n    {\n\tpos_copy = *trypos;\t// copy pos_T, next findmatch will change it\n\ttrypos = &pos_copy;\n\tcurwin->w_cursor = *trypos;\n\tpos = NULL;\n\t// ignore the { if it's in a // or / *  * / comment\n\tif ((colnr_T)cin_skip2pos(trypos) == trypos->col\n\t\t       && (pos = ind_find_start_CORS(NULL)) == NULL) // XXX\n\t    break;\n\tif (pos != NULL)\n\t    curwin->w_cursor.lnum = pos->lnum;\n    }\n    curwin->w_cursor = cursor_save;\n    return trypos;\n}",
        "func": "static pos_T *\nfind_start_brace(void)\t    // XXX\n{\n    pos_T\t    cursor_save;\n    pos_T\t    *trypos;\n    pos_T\t    *pos;\n    static pos_T    pos_copy;\n\n    cursor_save = curwin->w_cursor;\n    while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)\n    {\n\tpos_copy = *trypos;\t// copy pos_T, next findmatch will change it\n\ttrypos = &pos_copy;\n\tcurwin->w_cursor = *trypos;\n\tpos = NULL;\n\t// ignore the { if it's in a // or / *  * / comment\n\tif ((colnr_T)cin_skip2pos(trypos) == trypos->col\n\t\t       && (pos = ind_find_start_CORS(NULL)) == NULL) // XXX\n\t    break;\n\tif (pos != NULL)\n\t    curwin->w_cursor = *pos;\n    }\n    curwin->w_cursor = cursor_save;\n    return trypos;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n static pos_T *\n find_start_brace(void)\t    // XXX\n {\n-    pos_T\tcursor_save;\n-    pos_T\t*trypos;\n-    pos_T\t*pos;\n-    static pos_T\tpos_copy;\n+    pos_T\t    cursor_save;\n+    pos_T\t    *trypos;\n+    pos_T\t    *pos;\n+    static pos_T    pos_copy;\n \n     cursor_save = curwin->w_cursor;\n     while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)\n@@ -18,7 +18,7 @@\n \t\t       && (pos = ind_find_start_CORS(NULL)) == NULL) // XXX\n \t    break;\n \tif (pos != NULL)\n-\t    curwin->w_cursor.lnum = pos->lnum;\n+\t    curwin->w_cursor = *pos;\n     }\n     curwin->w_cursor = cursor_save;\n     return trypos;",
        "diff_line_info": {
            "deleted_lines": [
                "    pos_T\tcursor_save;",
                "    pos_T\t*trypos;",
                "    pos_T\t*pos;",
                "    static pos_T\tpos_copy;",
                "\t    curwin->w_cursor.lnum = pos->lnum;"
            ],
            "added_lines": [
                "    pos_T\t    cursor_save;",
                "    pos_T\t    *trypos;",
                "    pos_T\t    *pos;",
                "    static pos_T    pos_copy;",
                "\t    curwin->w_cursor = *pos;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4136",
        "func_name": "vim/eval_lambda",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/605ec91e5a7330d61be313637e495fa02a6dc264",
        "commit_title": "patch 8.2.3847: illegal memory access when using a lambda with an error",
        "commit_text": " Problem:    Illegal memory access when using a lambda with an error. Solution:   Avoid skipping over the NUL after a string.",
        "func_before": "static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ')')\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n\t++*arg;\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_nowhitespace));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}",
        "func": "static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ')')\n\t{\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_nowhitespace));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,12 +23,15 @@\n \t++*arg;\n \tret = eval1(arg, rettv, evalarg);\n \t*arg = skipwhite_and_linebreak(*arg, evalarg);\n-\tif (**arg != ')')\n+\tif (**arg == ')')\n+\t{\n+\t    ++*arg;\n+\t}\n+\telse\n \t{\n \t    emsg(_(e_missing_closing_paren));\n \t    ret = FAIL;\n \t}\n-\t++*arg;\n     }\n     if (ret != OK)\n \treturn FAIL;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (**arg != ')')",
                "\t++*arg;"
            ],
            "added_lines": [
                "\tif (**arg == ')')",
                "\t{",
                "\t    ++*arg;",
                "\t}",
                "\telse"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0080",
        "func_name": "mruby/mrb_proc_copy",
        "description": "mruby is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/mruby/mruby/commit/28ccc664e5dcd3f9d55173e9afde77c4705a9ab6",
        "commit_title": "proc.c: should not reference `irep` when copying failed.",
        "commit_text": " It may cause broken reference count numbers.",
        "func_before": "void\nmrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
        "func": "void\nmrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,12 +5,12 @@\n     /* already initialized proc */\n     return;\n   }\n+  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {\n+    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);\n+  }\n   a->flags = b->flags;\n   a->body = b->body;\n   a->upper = b->upper;\n-  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n-    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n-  }\n   a->e.env = b->e.env;\n   /* a->e.target_class = a->e.target_class; */\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {",
                "    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);",
                "  }"
            ],
            "added_lines": [
                "  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {",
                "    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0158",
        "func_name": "vim/compile_get_env",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/5f25c3855071bd7e26255c68bf458b1b5cf92f39",
        "commit_title": "patch 8.2.4049: Vim9: reading before the start of the line with \"$\"",
        "commit_text": " Problem:    Vim9: reading before the start of the line with \"$\" by itself. Solution:   Do not subtract one when reporting the error.",
        "func_before": "static int\ncompile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start - 1);\n\treturn FAIL;\n    }\n\n    // include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}",
        "func": "static int\ncompile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start);\n\treturn FAIL;\n    }\n\n    // include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n     len = get_env_len(arg);\n     if (len == 0)\n     {\n-\tsemsg(_(e_syntax_error_at_str), start - 1);\n+\tsemsg(_(e_syntax_error_at_str), start);\n \treturn FAIL;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tsemsg(_(e_syntax_error_at_str), start - 1);"
            ],
            "added_lines": [
                "\tsemsg(_(e_syntax_error_at_str), start);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0213",
        "func_name": "vim/win_redr_status",
        "description": "vim is vulnerable to Heap-based Buffer Overflow",
        "git_url": "https://github.com/vim/vim/commit/de05bb25733c3319e18dca44e9b59c6ee389eb26",
        "commit_title": "patch 8.2.4074: going over the end of NameBuff",
        "commit_text": " Problem:    Going over the end of NameBuff. Solution:   Check length when appending a space.",
        "func_before": "static void\nwin_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif (bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t|| wp->w_p_pvw\n#endif\n\t\t|| bufIsChanged(wp->w_buffer)\n\t\t|| wp->w_buffer->b_p_ro)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}",
        "func": "static void\nwin_redr_status(win_T *wp, int ignore_pum UNUSED)\n{\n    int\t\trow;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tfillchar;\n    int\t\tattr;\n    int\t\tthis_ru_col;\n    static int  busy = FALSE;\n\n    // It's possible to get here recursively when 'statusline' (indirectly)\n    // invokes \":redrawstatus\".  Simply ignore the call then.\n    if (busy)\n\treturn;\n    busy = TRUE;\n\n    row = statusline_row(wp);\n\n    wp->w_redr_status = FALSE;\n    if (wp->w_status_height == 0)\n    {\n\t// no status line, can only be last window\n\tredraw_cmdline = TRUE;\n    }\n    else if (!redrawing()\n\t    // don't update status line when popup menu is visible and may be\n\t    // drawn over it, unless it will be redrawn later\n\t    || (!ignore_pum && pum_visible()))\n    {\n\t// Don't redraw right now, do it later.\n\twp->w_redr_status = TRUE;\n    }\n#ifdef FEAT_STL_OPT\n    else if (*p_stl != NUL || *wp->w_p_stl != NUL)\n    {\n\t// redraw custom status line\n\tredraw_custom_statusline(wp);\n    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif ((bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n#endif\n\t\t    || bufIsChanged(wp->w_buffer)\n\t\t    || wp->w_buffer->b_p_ro)\n\t\t&& len < MAXPATHL - 1)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#endif\n\tif (bufIsChanged(wp->w_buffer)\n#ifdef FEAT_TERMINAL\n\t\t&& !bt_terminal(wp->w_buffer)\n#endif\n\t\t)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", \"[+]\");\n\t    len += (int)STRLEN(p + len);\n\t}\n\tif (wp->w_buffer->b_p_ro)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[RO]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n\n\tthis_ru_col = ru_col - (Columns - wp->w_width);\n\tif (this_ru_col < (wp->w_width + 1) / 2)\n\t    this_ru_col = (wp->w_width + 1) / 2;\n\tif (this_ru_col <= 1)\n\t{\n\t    p = (char_u *)\"<\";\t\t// No room for file name!\n\t    len = 1;\n\t}\n\telse if (has_mbyte)\n\t{\n\t    int\tclen = 0, i;\n\n\t    // Count total number of display cells.\n\t    clen = mb_string2cells(p, -1);\n\n\t    // Find first character that will fit.\n\t    // Going from start to end is much faster for DBCS.\n\t    for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;\n\t\t    i += (*mb_ptr2len)(p + i))\n\t\tclen -= (*mb_ptr2cells)(p + i);\n\t    len = clen;\n\t    if (i > 0)\n\t    {\n\t\tp = p + i - 1;\n\t\t*p = '<';\n\t\t++len;\n\t    }\n\n\t}\n\telse if (len > this_ru_col - 1)\n\t{\n\t    p += len - (this_ru_col - 1);\n\t    *p = '<';\n\t    len = this_ru_col - 1;\n\t}\n\n\tscreen_puts(p, row, wp->w_wincol, attr);\n\tscreen_fill(row, row + 1, len + wp->w_wincol,\n\t\t\tthis_ru_col + wp->w_wincol, fillchar, fillchar, attr);\n\n\tif (get_keymap_str(wp, (char_u *)\"<%s>\", NameBuff, MAXPATHL)\n\t\t&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))\n\t    screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)\n\t\t\t\t\t\t   - 1 + wp->w_wincol), attr);\n\n#ifdef FEAT_CMDL_INFO\n\twin_redr_ruler(wp, TRUE, ignore_pum);\n#endif\n    }\n\n    /*\n     * May need to draw the character below the vertical separator.\n     */\n    if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())\n    {\n\tif (stl_connected(wp))\n\t    fillchar = fillchar_status(&attr, wp);\n\telse\n\t    fillchar = fillchar_vsep(&attr);\n\tscreen_putchar(fillchar, row, W_ENDCOL(wp), attr);\n    }\n    busy = FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,12 +46,13 @@\n \tp = NameBuff;\n \tlen = (int)STRLEN(p);\n \n-\tif (bt_help(wp->w_buffer)\n+\tif ((bt_help(wp->w_buffer)\n #ifdef FEAT_QUICKFIX\n-\t\t|| wp->w_p_pvw\n+\t\t    || wp->w_p_pvw\n #endif\n-\t\t|| bufIsChanged(wp->w_buffer)\n-\t\t|| wp->w_buffer->b_p_ro)\n+\t\t    || bufIsChanged(wp->w_buffer)\n+\t\t    || wp->w_buffer->b_p_ro)\n+\t\t&& len < MAXPATHL - 1)\n \t    *(p + len++) = ' ';\n \tif (bt_help(wp->w_buffer))\n \t{",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (bt_help(wp->w_buffer)",
                "\t\t|| wp->w_p_pvw",
                "\t\t|| bufIsChanged(wp->w_buffer)",
                "\t\t|| wp->w_buffer->b_p_ro)"
            ],
            "added_lines": [
                "\tif ((bt_help(wp->w_buffer)",
                "\t\t    || wp->w_p_pvw",
                "\t\t    || bufIsChanged(wp->w_buffer)",
                "\t\t    || wp->w_buffer->b_p_ro)",
                "\t\t&& len < MAXPATHL - 1)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0359",
        "func_name": "vim/init_ccline",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/85b6747abc15a7a81086db31289cf1b8b17e6cb1",
        "commit_title": "patch 8.2.4214: illegal memory access with large 'tabstop' in Ex mode",
        "commit_text": " Problem:    Illegal memory access with large 'tabstop' in Ex mode. Solution:   Allocate enough memory.",
        "func_before": "static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}",
        "func": "static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n     ccline.cmdindent = (firstc > 0 ? indent : 0);\n \n     // alloc initial ccline.cmdbuff\n-    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n+    alloc_cmdbuff(indent + 50);\n     if (ccline.cmdbuff == NULL)\n \treturn FAIL;\n     ccline.cmdlen = ccline.cmdpos = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    alloc_cmdbuff(exmode_active ? 250 : indent + 1);"
            ],
            "added_lines": [
                "    alloc_cmdbuff(indent + 50);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0361",
        "func_name": "vim/ex_copy",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/dc5490e2cbc8c16022a23b449b48c1bd0083f366",
        "commit_title": "patch 8.2.4215: illegal memory access when copying lines in Visual mode",
        "commit_text": " Problem:    Illegal memory access when copying lines in Visual mode. Solution:   Adjust the Visual position after copying lines.",
        "func_before": "void\nex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n\n    msgmore((long)count);\n}",
        "func": "void\nex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    msgmore((long)count);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,6 +49,8 @@\n     }\n \n     appended_lines_mark(n, count);\n+    if (VIsual_active)\n+\tcheck_pos(curbuf, &VIsual);\n \n     msgmore((long)count);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (VIsual_active)",
                "\tcheck_pos(curbuf, &VIsual);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4141",
        "func_name": "vim/do_window",
        "description": "Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.",
        "git_url": "https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5",
        "commit_title": "patch 9.0.0947: invalid memory access in substitute with function",
        "commit_text": " Problem:    Invalid memory access in substitute with function that goes to             another file. Solution:   Check for text locked in CTRL-W gf.",
        "func_before": "void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\nnewwindow:\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same width and/or height\n    case '=':\n\t\t{\n\t\t    int mod = cmdmod.cmod_split & (WSP_VERT | WSP_HOR);\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_equal(NULL, FALSE,\n\t\t\t   mod == WSP_VERT ? 'v' : mod == WSP_HOR ? 'h' : 'b');\n\t\t}\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t\t(void)add_to_showcmd(xchar);\n\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}",
        "func": "void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\nnewwindow:\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same width and/or height\n    case '=':\n\t\t{\n\t\t    int mod = cmdmod.cmod_split & (WSP_VERT | WSP_HOR);\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_equal(NULL, FALSE,\n\t\t\t   mod == WSP_VERT ? 'v' : mod == WSP_HOR ? 'h' : 'b');\n\t\t}\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\t\tif (check_text_or_curbuf_locked(NULL))\n\t\t    break;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\n\t\t// Make a copy, if the line was changed it will be freed.\n\t\tptr = vim_strnsave(ptr, len);\n\t\tif (ptr == NULL)\n\t\t    break;\n\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tvim_free(ptr);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t\t(void)add_to_showcmd(xchar);\n\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -395,6 +395,8 @@\n     case Ctrl_F:\n wingotofile:\n \t\tCHECK_CMDWIN;\n+\t\tif (check_text_or_curbuf_locked(NULL))\n+\t\t    break;\n \n \t\tptr = grab_file_name(Prenum1, &lnum);\n \t\tif (ptr != NULL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (check_text_or_curbuf_locked(NULL))",
                "\t\t    break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4141",
        "func_name": "vim/check_text_locked",
        "description": "Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.",
        "git_url": "https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5",
        "commit_title": "patch 9.0.0947: invalid memory access in substitute with function",
        "commit_text": " Problem:    Invalid memory access in substitute with function that goes to             another file. Solution:   Check for text locked in CTRL-W gf.",
        "func_before": "static int\ncheck_text_locked(oparg_T *oap)\n{\n    if (text_locked())\n    {\n\tclearopbeep(oap);\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return FALSE;\n}",
        "func": "static int\ncheck_text_locked(oparg_T *oap)\n{\n    if (text_locked())\n    {\n\tif (oap != NULL)\n\t    clearopbeep(oap);\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,8 @@\n {\n     if (text_locked())\n     {\n-\tclearopbeep(oap);\n+\tif (oap != NULL)\n+\t    clearopbeep(oap);\n \ttext_locked_msg();\n \treturn TRUE;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "\tclearopbeep(oap);"
            ],
            "added_lines": [
                "\tif (oap != NULL)",
                "\t    clearopbeep(oap);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4141",
        "func_name": "vim/normal_cmd",
        "description": "Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.",
        "git_url": "https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5",
        "commit_title": "patch 9.0.0947: invalid memory access in substitute with function",
        "commit_text": " Problem:    Invalid memory access in substitute with function that goes to             another file. Solution:   Check for text locked in CTRL-W gf.",
        "func_before": "void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n    need_flushbuf = add_to_showcmd(c);\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW)\n\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    may_trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}",
        "func": "void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n    int\t\tneed_flushbuf = FALSE;\t// need to call out_flush()\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n    int\t\tset_prevcount = FALSE;\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    // If there is an operator pending, then the command we take this time\n    // will terminate it. Finish_op tells us to finish the operation before\n    // returning this time (unless the operation was cancelled).\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    may_trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = MODE_NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT);\n\n    // If a mapping was started in Visual or Select mode, remember the length\n    // of the mapping.  This is used below to not return to Insert mode for as\n    // long as the mapping is being executed.\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    // In Select mode, typed text replaces the selection.\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\tint len;\n\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tlen = ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\n\t// When recording and gotchars() was called the character will be\n\t// recorded again, remove the previous recording.\n\tif (KeyTyped)\n\t    ungetchars(len);\n\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n    // If the window was made so small that nothing shows, make it at least one\n    // line and one column when typing a command.\n    if (KeyTyped && !KeyStuffed)\n\twin_ensure_size();\n\n    need_flushbuf = add_to_showcmd(c);\n\n    // Get the command count\n    c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w,\n\t\t\t\t\t\t\t&need_flushbuf);\n\n    // Find the command character in the table of commands.\n    // For CTRL-W we already got nchar when looking for a count.\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(UPD_INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    // Get additional characters if we need them.\n    if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags))\n\tidx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf);\n\n    // Flush the showcmd characters onto the screen so we can see them while\n    // the command is being executed.  Only do this when the shown command was\n    // actually displayed, otherwise this will slow down a lot when executing\n    // mappings.\n    if (need_flushbuf)\n\tout_flush();\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = MODE_NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    // Execute the command!\n    // Call the command function found in the commands table.\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    // If we didn't start or finish an operator, reset oap->regname, unless we\n    // need it later.\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    // If an operation is pending, handle it.  But not for K_IGNORE or\n    // K_MOUSEMOVE.\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    // Wait for a moment when a message is displayed that will be overwritten\n    // by the mode message.\n    if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos))\n\tnormal_cmd_wait_for_msg();\n\n    // Finish up after executing a Normal mode command.\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    may_trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    // May restart edit(), if we got here with CTRL-O in Insert mode (but not\n    // if still inside a mapping that started in Visual mode).\n    // May switch from Visual to Select mode after CTRL-O command.\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    may_trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t    VIsual_select_reg = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -150,8 +150,7 @@\n \tgoto normal_end;\n     }\n \n-    if ((nv_cmds[idx].cmd_flags & NV_NCW)\n-\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))\n+    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n \t// this command is not allowed now\n \tgoto normal_end;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if ((nv_cmds[idx].cmd_flags & NV_NCW)",
                "\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))"
            ],
            "added_lines": [
                "    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4141",
        "func_name": "vim/nv_gotofile",
        "description": "Heap based buffer overflow in vim/vim 9.0.0946 and below by allowing an attacker to CTRL-W gf in the expression used in the RHS of the substitute command.",
        "git_url": "https://github.com/vim/vim/commit/cc762a48d42b579fb7bdec2c614636b830342dd5",
        "commit_title": "patch 9.0.0947: invalid memory access in substitute with function",
        "commit_text": " Problem:    Invalid memory access in substitute with function that goes to             another file. Solution:   Check for text locked in CTRL-W gf.",
        "func_before": "static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (check_text_locked(cap->oap))\n\treturn;\n    if (curbuf_locked())\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}",
        "func": "static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (check_text_or_curbuf_locked(cap->oap))\n\treturn;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,13 +4,9 @@\n     char_u\t*ptr;\n     linenr_T\tlnum = -1;\n \n-    if (check_text_locked(cap->oap))\n+    if (check_text_or_curbuf_locked(cap->oap))\n \treturn;\n-    if (curbuf_locked())\n-    {\n-\tclearop(cap->oap);\n-\treturn;\n-    }\n+\n #ifdef FEAT_PROP_POPUP\n     if (ERROR_IF_TERM_POPUP_WINDOW)\n \treturn;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (check_text_locked(cap->oap))",
                "    if (curbuf_locked())",
                "    {",
                "\tclearop(cap->oap);",
                "\treturn;",
                "    }"
            ],
            "added_lines": [
                "    if (check_text_or_curbuf_locked(cap->oap))",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3520",
        "func_name": "vim/do_put",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0765.",
        "git_url": "https://github.com/vim/vim/commit/36343ae0fb7247e060abfd35fb8e4337b33abb4b",
        "commit_title": "patch 9.0.0765: with a Visual block a put command column may go negative",
        "commit_text": " Problem:    With a Visual block a put command column may go negative. Solution:   Check that the column does not become negative.",
        "func_before": "void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int\t\t    spaces = 0;\n\t    char\t    shortline;\n\t    chartabsize_T   cts;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    init_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum, 0,\n\t\t\t\t\t\t\t\t  oldp, oldp);\n\n\t    while (cts.cts_vcol < col && *cts.cts_ptr != NUL)\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(&cts);\n\t\tcts.cts_vcol += incr;\n\t    }\n\t    vcol = cts.cts_vcol;\n\t    ptr = cts.cts_ptr;\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    clear_chartabsize_arg(&cts);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, padd with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tinit_chartabsize_arg(&cts, curwin, 0, 0,\n\t\t\t\t\t\t      y_array[i], y_array[i]);\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t{\n\t\t    spaces -= lbr_chartabsize(&cts);\n\t\t    ++cts.cts_ptr;\n\t\t    cts.cts_vcol = 0;\n\t\t}\n\t\tclear_chartabsize_arg(&cts);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Note: this may free \"newp\"\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    inserted_bytes(lnum, col, totlen);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    // Skip mark_adjust when adding lines after the last one, there\n\t    // can't be marks there. But still needed in diff mode.\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}",
        "func": "void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int\t\t    spaces = 0;\n\t    char\t    shortline;\n\t    chartabsize_T   cts;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    init_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum, 0,\n\t\t\t\t\t\t\t\t  oldp, oldp);\n\n\t    while (cts.cts_vcol < col && *cts.cts_ptr != NUL)\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(&cts);\n\t\tcts.cts_vcol += incr;\n\t    }\n\t    vcol = cts.cts_vcol;\n\t    ptr = cts.cts_ptr;\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    clear_chartabsize_arg(&cts);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, padd with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tinit_chartabsize_arg(&cts, curwin, 0, 0,\n\t\t\t\t\t\t      y_array[i], y_array[i]);\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t{\n\t\t    spaces -= lbr_chartabsize(&cts);\n\t\t    ++cts.cts_ptr;\n\t\t    cts.cts_vcol = 0;\n\t\t}\n\t\tclear_chartabsize_arg(&cts);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tif (curbuf->b_op_end.col < 0)\n\t    curbuf->b_op_end.col = 0;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Note: this may free \"newp\"\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    inserted_bytes(lnum, col, totlen);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    // Skip mark_adjust when adding lines after the last one, there\n\t    // can't be marks there. But still needed in diff mode.\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -436,6 +436,8 @@\n \t// adjust '] mark\n \tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n \tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n+\tif (curbuf->b_op_end.col < 0)\n+\t    curbuf->b_op_end.col = 0;\n \tcurbuf->b_op_end.coladd = 0;\n \tif (flags & PUT_CURSEND)\n \t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (curbuf->b_op_end.col < 0)",
                "\t    curbuf->b_op_end.col = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3491",
        "func_name": "vim/compile_redir",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0742.",
        "git_url": "https://github.com/vim/vim/commit/3558afe9e9e904cabb8475392d859f2d2fc21041",
        "commit_title": "patch 9.0.0742: reading past end of the line when compiling a function",
        "commit_text": " Problem:    Reading past end of the line when compiling a function with             errors. Solution:   Do not return an invalid pointer.  Fix skipping redirection.",
        "func_before": "char_u *\ncompile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *arg = eap->arg;\n    lhs_T   *lhs = &cctx->ctx_redir_lhs;\n\n    if (lhs->lhs_name != NULL)\n    {\n\tif (STRNCMP(arg, \"END\", 3) == 0)\n\t{\n\t    if (lhs->lhs_append)\n\t    {\n\t\t// First load the current variable value.\n\t\tif (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    // Gets the redirected text and put it on the stack, then store it\n\t    // in the variable.\n\t    generate_instr_type(cctx, ISN_REDIREND, &t_string);\n\n\t    if (lhs->lhs_append)\n\t\tgenerate_CONCAT(cctx, 2);\n\n\t    if (lhs->lhs_has_index)\n\t    {\n\t\t// Use the info in \"lhs\" to store the value at the index in the\n\t\t// list or dict.\n\t\tif (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n\t\t\t\t\t\t      &t_string, cctx) == FAIL)\n\t\t    return NULL;\n\t    }\n\t    else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)\n\t\treturn NULL;\n\n\t    VIM_CLEAR(lhs->lhs_name);\n\t    VIM_CLEAR(lhs->lhs_whole);\n\t    return arg + 3;\n\t}\n\temsg(_(e_cannot_nest_redir));\n\treturn NULL;\n    }\n\n    if (arg[0] == '=' && arg[1] == '>')\n    {\n\tint\t    append = FALSE;\n\n\t// redirect to a variable is compiled\n\targ += 2;\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    append = TRUE;\n\t}\n\targ = skipwhite(arg);\n\n\tif (compile_assign_lhs(arg, lhs, CMD_redir,\n\t\t\t\t\t FALSE, FALSE, FALSE, 1, cctx) == FAIL)\n\t    return NULL;\n\tif (need_type(&t_string, lhs->lhs_member_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t    return NULL;\n\tgenerate_instr(cctx, ISN_REDIRSTART);\n\tlhs->lhs_append = append;\n\tif (lhs->lhs_has_index)\n\t{\n\t    lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n\t    if (lhs->lhs_whole == NULL)\n\t\treturn NULL;\n\t}\n\n\treturn arg + lhs->lhs_varlen_total;\n    }\n\n    // other redirects are handled like at script level\n    return compile_exec(line, eap, cctx);\n}",
        "func": "char_u *\ncompile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *arg = eap->arg;\n    lhs_T   *lhs = &cctx->ctx_redir_lhs;\n\n    if (lhs->lhs_name != NULL)\n    {\n\tif (STRNCMP(arg, \"END\", 3) == 0)\n\t{\n\t    if (cctx->ctx_skip != SKIP_YES)\n\t    {\n\t\tif (lhs->lhs_append)\n\t\t{\n\t\t    // First load the current variable value.\n\t\t    if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t\treturn NULL;\n\t\t}\n\n\t\t// Gets the redirected text and put it on the stack, then store\n\t\t// it in the variable.\n\t\tgenerate_instr_type(cctx, ISN_REDIREND, &t_string);\n\n\t\tif (lhs->lhs_append)\n\t\t    generate_CONCAT(cctx, 2);\n\n\t\tif (lhs->lhs_has_index)\n\t\t{\n\t\t    // Use the info in \"lhs\" to store the value at the index in\n\t\t    // the list or dict.\n\t\t    if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n\t\t\t\t\t\t      &t_string, cctx) == FAIL)\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)\n\t\t    return NULL;\n\n\t\tVIM_CLEAR(lhs->lhs_name);\n\t\tVIM_CLEAR(lhs->lhs_whole);\n\t    }\n\t    return arg + 3;\n\t}\n\temsg(_(e_cannot_nest_redir));\n\treturn NULL;\n    }\n\n    if (arg[0] == '=' && arg[1] == '>')\n    {\n\tint\t    append = FALSE;\n\n\t// redirect to a variable is compiled\n\targ += 2;\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    append = TRUE;\n\t}\n\targ = skipwhite(arg);\n\n\tif (compile_assign_lhs(arg, lhs, CMD_redir,\n\t\t\t\t\t FALSE, FALSE, FALSE, 1, cctx) == FAIL)\n\t    return NULL;\n\tif (need_type(&t_string, lhs->lhs_member_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t    return NULL;\n\tif (cctx->ctx_skip == SKIP_YES)\n\t{\n\t    VIM_CLEAR(lhs->lhs_name);\n\t}\n\telse\n\t{\n\t    generate_instr(cctx, ISN_REDIRSTART);\n\t    lhs->lhs_append = append;\n\t    if (lhs->lhs_has_index)\n\t    {\n\t\tlhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n\t\tif (lhs->lhs_whole == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n\n\treturn arg + lhs->lhs_varlen_total;\n    }\n\n    // other redirects are handled like at script level\n    return compile_exec(line, eap, cctx);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,34 +8,37 @@\n     {\n \tif (STRNCMP(arg, \"END\", 3) == 0)\n \t{\n-\t    if (lhs->lhs_append)\n+\t    if (cctx->ctx_skip != SKIP_YES)\n \t    {\n-\t\t// First load the current variable value.\n-\t\tif (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n+\t\tif (lhs->lhs_append)\n+\t\t{\n+\t\t    // First load the current variable value.\n+\t\t    if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n \t\t\t\t\t\t\t\t cctx) == FAIL)\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\t// Gets the redirected text and put it on the stack, then store\n+\t\t// it in the variable.\n+\t\tgenerate_instr_type(cctx, ISN_REDIREND, &t_string);\n+\n+\t\tif (lhs->lhs_append)\n+\t\t    generate_CONCAT(cctx, 2);\n+\n+\t\tif (lhs->lhs_has_index)\n+\t\t{\n+\t\t    // Use the info in \"lhs\" to store the value at the index in\n+\t\t    // the list or dict.\n+\t\t    if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n+\t\t\t\t\t\t      &t_string, cctx) == FAIL)\n+\t\t\treturn NULL;\n+\t\t}\n+\t\telse if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)\n \t\t    return NULL;\n+\n+\t\tVIM_CLEAR(lhs->lhs_name);\n+\t\tVIM_CLEAR(lhs->lhs_whole);\n \t    }\n-\n-\t    // Gets the redirected text and put it on the stack, then store it\n-\t    // in the variable.\n-\t    generate_instr_type(cctx, ISN_REDIREND, &t_string);\n-\n-\t    if (lhs->lhs_append)\n-\t\tgenerate_CONCAT(cctx, 2);\n-\n-\t    if (lhs->lhs_has_index)\n-\t    {\n-\t\t// Use the info in \"lhs\" to store the value at the index in the\n-\t\t// list or dict.\n-\t\tif (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n-\t\t\t\t\t\t      &t_string, cctx) == FAIL)\n-\t\t    return NULL;\n-\t    }\n-\t    else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)\n-\t\treturn NULL;\n-\n-\t    VIM_CLEAR(lhs->lhs_name);\n-\t    VIM_CLEAR(lhs->lhs_whole);\n \t    return arg + 3;\n \t}\n \temsg(_(e_cannot_nest_redir));\n@@ -61,13 +64,20 @@\n \tif (need_type(&t_string, lhs->lhs_member_type,\n \t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n \t    return NULL;\n-\tgenerate_instr(cctx, ISN_REDIRSTART);\n-\tlhs->lhs_append = append;\n-\tif (lhs->lhs_has_index)\n+\tif (cctx->ctx_skip == SKIP_YES)\n \t{\n-\t    lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n-\t    if (lhs->lhs_whole == NULL)\n-\t\treturn NULL;\n+\t    VIM_CLEAR(lhs->lhs_name);\n+\t}\n+\telse\n+\t{\n+\t    generate_instr(cctx, ISN_REDIRSTART);\n+\t    lhs->lhs_append = append;\n+\t    if (lhs->lhs_has_index)\n+\t    {\n+\t\tlhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n+\t\tif (lhs->lhs_whole == NULL)\n+\t\t    return NULL;\n+\t    }\n \t}\n \n \treturn arg + lhs->lhs_varlen_total;",
        "diff_line_info": {
            "deleted_lines": [
                "\t    if (lhs->lhs_append)",
                "\t\t// First load the current variable value.",
                "\t\tif (compile_load_lhs_with_index(lhs, lhs->lhs_whole,",
                "",
                "\t    // Gets the redirected text and put it on the stack, then store it",
                "\t    // in the variable.",
                "\t    generate_instr_type(cctx, ISN_REDIREND, &t_string);",
                "",
                "\t    if (lhs->lhs_append)",
                "\t\tgenerate_CONCAT(cctx, 2);",
                "",
                "\t    if (lhs->lhs_has_index)",
                "\t    {",
                "\t\t// Use the info in \"lhs\" to store the value at the index in the",
                "\t\t// list or dict.",
                "\t\tif (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,",
                "\t\t\t\t\t\t      &t_string, cctx) == FAIL)",
                "\t\t    return NULL;",
                "\t    }",
                "\t    else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)",
                "\t\treturn NULL;",
                "",
                "\t    VIM_CLEAR(lhs->lhs_name);",
                "\t    VIM_CLEAR(lhs->lhs_whole);",
                "\tgenerate_instr(cctx, ISN_REDIRSTART);",
                "\tlhs->lhs_append = append;",
                "\tif (lhs->lhs_has_index)",
                "\t    lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);",
                "\t    if (lhs->lhs_whole == NULL)",
                "\t\treturn NULL;"
            ],
            "added_lines": [
                "\t    if (cctx->ctx_skip != SKIP_YES)",
                "\t\tif (lhs->lhs_append)",
                "\t\t{",
                "\t\t    // First load the current variable value.",
                "\t\t    if (compile_load_lhs_with_index(lhs, lhs->lhs_whole,",
                "\t\t\treturn NULL;",
                "\t\t}",
                "",
                "\t\t// Gets the redirected text and put it on the stack, then store",
                "\t\t// it in the variable.",
                "\t\tgenerate_instr_type(cctx, ISN_REDIREND, &t_string);",
                "",
                "\t\tif (lhs->lhs_append)",
                "\t\t    generate_CONCAT(cctx, 2);",
                "",
                "\t\tif (lhs->lhs_has_index)",
                "\t\t{",
                "\t\t    // Use the info in \"lhs\" to store the value at the index in",
                "\t\t    // the list or dict.",
                "\t\t    if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,",
                "\t\t\t\t\t\t      &t_string, cctx) == FAIL)",
                "\t\t\treturn NULL;",
                "\t\t}",
                "\t\telse if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)",
                "",
                "\t\tVIM_CLEAR(lhs->lhs_name);",
                "\t\tVIM_CLEAR(lhs->lhs_whole);",
                "\tif (cctx->ctx_skip == SKIP_YES)",
                "\t    VIM_CLEAR(lhs->lhs_name);",
                "\t}",
                "\telse",
                "\t{",
                "\t    generate_instr(cctx, ISN_REDIRSTART);",
                "\t    lhs->lhs_append = append;",
                "\t    if (lhs->lhs_has_index)",
                "\t    {",
                "\t\tlhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);",
                "\t\tif (lhs->lhs_whole == NULL)",
                "\t\t    return NULL;",
                "\t    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3491",
        "func_name": "vim/get_var_dest",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0742.",
        "git_url": "https://github.com/vim/vim/commit/3558afe9e9e904cabb8475392d859f2d2fc21041",
        "commit_title": "patch 9.0.0742: reading past end of the line when compiling a function",
        "commit_text": " Problem:    Reading past end of the line when compiling a function with             errors. Solution:   Do not return an invalid pointer.  Fix skipping redirection.",
        "func_before": "int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tcmdidx_T\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}",
        "func": "int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tcmdidx_T\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (!valid_dest_reg(name[1]))\n\t    return FAIL;\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,12 +71,8 @@\n     }\n     else if (*name == '@')\n     {\n-\tif (name[1] != '@'\n-\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n-\t{\n-\t    emsg_invreg(name[1]);\n+\tif (!valid_dest_reg(name[1]))\n \t    return FAIL;\n-\t}\n \t*dest = dest_reg;\n \t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (name[1] != '@'",
                "\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))",
                "\t{",
                "\t    emsg_invreg(name[1]);",
                "\t}"
            ],
            "added_lines": [
                "\tif (!valid_dest_reg(name[1]))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3491",
        "func_name": "vim/compile_lhs",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0742.",
        "git_url": "https://github.com/vim/vim/commit/3558afe9e9e904cabb8475392d859f2d2fc21041",
        "commit_title": "patch 9.0.0742: reading past end of the line when compiling a function",
        "commit_text": " Problem:    Reading past end of the line when compiling a function with             errors. Solution:   Do not return an invalid pointer.  Fix skipping redirection.",
        "func_before": "int\ncompile_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t    cctx, NULL)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t    cctx, NULL)) == OK;\n\t\timported_T  *import =\n\t\t\t      find_imported(var_start, lhs->lhs_varlen, FALSE);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (script_namespace && current_script_is_vim9())\n\t\t    {\n\t\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t   cctx, NULL);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl || (lhs->lhs_has_index && !has_cmd\n\t\t\t\t\t\t&& cctx->ctx_skip != SKIP_YES))\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tint assign = cmdidx == CMD_final ? ASSIGN_FINAL\n\t\t\t     : cmdidx == CMD_const ? ASSIGN_CONST : ASSIGN_VAR;\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\tassign, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl && cctx->ctx_skip != SKIP_YES)\n\t{\n\t    if (has_cmd)\n\t\temsg(_(e_cannot_use_index_when_declaring_variable));\n\t    else\n\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}",
        "func": "int\ncompile_lhs(\n\tchar_u\t    *var_start,\n\tlhs_T\t    *lhs,\n\tcmdidx_T    cmdidx,\n\tint\t    heredoc,\n\tint\t    has_cmd,\t    // \"var\" before \"var_start\"\n\tint\t    oplen,\n\tcctx_T\t    *cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n    {\n\tif (!valid_dest_reg(var_start[1]))\n\t    return FAIL;\n\tvar_end = var_start + 2;\n    }\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t    cctx, NULL)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t    cctx, NULL)) == OK;\n\t\timported_T  *import =\n\t\t\t      find_imported(var_start, lhs->lhs_varlen, FALSE);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (script_namespace && current_script_is_vim9())\n\t\t    {\n\t\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t   cctx, NULL);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx,\n\t\t\t\t\t\t\t  NULL, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl || (lhs->lhs_has_index && !has_cmd\n\t\t\t\t\t\t&& cctx->ctx_skip != SKIP_YES))\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tint assign = cmdidx == CMD_final ? ASSIGN_FINAL\n\t\t\t     : cmdidx == CMD_const ? ASSIGN_CONST : ASSIGN_VAR;\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\tassign, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl && cctx->ctx_skip != SKIP_YES)\n\t{\n\t    if (has_cmd)\n\t\temsg(_(e_cannot_use_index_when_declaring_variable));\n\t    else\n\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,11 @@\n     // \"var_end\" is the end of the variable/option/etc. name.\n     lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n     if (*var_start == '@')\n+    {\n+\tif (!valid_dest_reg(var_start[1]))\n+\t    return FAIL;\n \tvar_end = var_start + 2;\n+    }\n     else\n     {\n \t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    {",
                "\tif (!valid_dest_reg(var_start[1]))",
                "\t    return FAIL;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27814",
        "func_name": "uclouvain/openjpeg/opj_tcd_code_block_enc_allocate_data",
        "description": "A heap-buffer overflow was found in the way openjpeg2 handled certain PNG format files. An attacker could use this flaw to cause an application crash or in some cases execute arbitrary code with the permission of the user running such an application.",
        "git_url": "https://github.com/uclouvain/openjpeg/commit/eaa098b59b346cb88e4d10d505061f669d7134fc",
        "commit_title": "Encoder: grow buffer size in opj_tcd_code_block_enc_allocate_data() to avoid write heap buffer overflow in opj_mqc_flush (fixes #1283)",
        "commit_text": "",
        "func_before": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    /* +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */\n    /* and actually +2 required for https://github.com/uclouvain/openjpeg/issues/982 */\n    /* TODO: is there a theoretical upper-bound for the compressed code */\n    /* block size ? */\n    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            /* We refer to data - 1 since below we incremented it */\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        /* We reserve the initial byte as a fake byte to a non-FF value */\n        /* and increment the data pointer, so that opj_mqc_init_enc() */\n        /* can do bp = data - 1, and opj_mqc_byteout() can safely dereference */\n        /* it. */\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; /*why +1 ?*/\n    }\n    return OPJ_TRUE;\n}",
        "func": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    /* +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */\n    /* and actually +2 required for https://github.com/uclouvain/openjpeg/issues/982 */\n    /* and +7 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 3) */\n    /* and +26 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 7) */\n    /* TODO: is there a theoretical upper-bound for the compressed code */\n    /* block size ? */\n    l_data_size = 26 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            /* We refer to data - 1 since below we incremented it */\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        /* We reserve the initial byte as a fake byte to a non-FF value */\n        /* and increment the data pointer, so that opj_mqc_init_enc() */\n        /* can do bp = data - 1, and opj_mqc_byteout() can safely dereference */\n        /* it. */\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; /*why +1 ?*/\n    }\n    return OPJ_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,9 +5,11 @@\n \n     /* +1 is needed for https://github.com/uclouvain/openjpeg/issues/835 */\n     /* and actually +2 required for https://github.com/uclouvain/openjpeg/issues/982 */\n+    /* and +7 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 3) */\n+    /* and +26 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 7) */\n     /* TODO: is there a theoretical upper-bound for the compressed code */\n     /* block size ? */\n-    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n+    l_data_size = 26 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                    (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n \n     if (l_data_size > p_code_block->data_size) {",
        "diff_line_info": {
            "deleted_lines": [
                "    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *"
            ],
            "added_lines": [
                "    /* and +7 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 3) */",
                "    /* and +26 for https://github.com/uclouvain/openjpeg/issues/1283 (-M 7) */",
                "    l_data_size = 26 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29457",
        "func_name": "Exiv2/exiv2/Jp2Image::doWriteMetadata",
        "description": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when _writing_ the metadata, which is a less frequently used Exiv2 operation than _reading_ the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/3106ae52c106cb559b96a4abb201ba0105902b9a",
        "commit_title": "Fix out of buffer access in #1529",
        "commit_text": "",
        "func_before": "void Jp2Image::doWriteMetadata(BasicIo& outIo)\n    {\n        if (!io_->isopen()) throw Error(kerInputDataReadFailed);\n        if (!outIo.isopen()) throw Error(kerImageWriteFailed);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Writing JPEG-2000 file \" << io_->path() << std::endl;\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: tmp file created \" << outIo.path() << std::endl;\n#endif\n\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerInputDataReadFailed);\n            throw Error(kerNoImageInInputData);\n        }\n\n        // Write JPEG2000 Signature.\n        if (outIo.write(Jp2Signature, 12) != 12) throw Error(kerImageWriteFailed);\n\n        Jp2BoxHeader box = {0,0};\n\n        byte    boxDataSize[4];\n        byte    boxUUIDtype[4];\n        DataBuf bheaderBuf(8);     // Box header : 4 bytes (data size) + 4 bytes (box type).\n\n        // FIXME: Andreas, why the loop do not stop when EOF is taken from _io. The loop go out by an exception\n        // generated by a zero size data read.\n\n        while(io_->tell() < (long) io_->size())\n        {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Position: \" << io_->tell() << \" / \" << io_->size() << std::endl;\n#endif\n\n            // Read chunk header.\n\n            std::memset(bheaderBuf.pData_, 0x00, bheaderBuf.size_);\n            long bufRead = io_->read(bheaderBuf.pData_, bheaderBuf.size_);\n            if (io_->error()) throw Error(kerFailedToReadImageData);\n            if (bufRead != bheaderBuf.size_) throw Error(kerInputDataReadFailed);\n\n            // Decode box header.\n\n            box.length = getLong(bheaderBuf.pData_,     bigEndian);\n            box.type   = getLong(bheaderBuf.pData_ + 4, bigEndian);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length << std::endl;\n#endif\n\n            if (box.length == 0)\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Null Box size has been found. \"\n                             \"This is the last box of file.\" << std::endl;\n#endif\n                box.length = (uint32_t) (io_->size() - io_->tell() + 8);\n            }\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            // Read whole box : Box header + Box data (not fixed size - can be null).\n\n            DataBuf boxBuf(box.length);                             // Box header (8 bytes) + box data.\n            memcpy(boxBuf.pData_, bheaderBuf.pData_, 8);               // Copy header.\n            bufRead = io_->read(boxBuf.pData_ + 8, box.length - 8); // Extract box data.\n            if (io_->error())\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Error reading source file\" << std::endl;\n#endif\n\n                throw Error(kerFailedToReadImageData);\n            }\n\n            if (bufRead != (long)(box.length - 8))\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Cannot read source file data\" << std::endl;\n#endif\n                throw Error(kerInputDataReadFailed);\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n                    DataBuf newBuf;\n                    encodeJp2Header(boxBuf,newBuf);\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write JP2Header box (length: \" << box.length << \")\" << std::endl;\n#endif\n                    if (outIo.write(newBuf.pData_, newBuf.size_) != newBuf.size_) throw Error(kerImageWriteFailed);\n\n                    // Write all updated metadata here, just after JP2Header.\n\n                    if (exifData_.count() > 0)\n                    {\n                        // Update Exif data to a new UUID box\n\n                        Blob blob;\n                        ExifParser::encode(blob, littleEndian, exifData_);\n                        if (blob.size())\n                        {\n                            DataBuf rawExif(static_cast<long>(blob.size()));\n                            memcpy(rawExif.pData_, &blob[0], blob.size());\n\n                            DataBuf boxData(8 + 16 + rawExif.size_);\n                            ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                            ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                            memcpy(boxData.pData_,          boxDataSize,    4);\n                            memcpy(boxData.pData_ + 4,      boxUUIDtype,    4);\n                            memcpy(boxData.pData_ + 8,      kJp2UuidExif,   16);\n                            memcpy(boxData.pData_ + 8 + 16, rawExif.pData_, rawExif.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Exif metadata (length: \"\n                                      << boxData.size_ << std::endl;\n#endif\n                            if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                        }\n                    }\n\n                    if (iptcData_.count() > 0)\n                    {\n                        // Update Iptc data to a new UUID box\n\n                        DataBuf rawIptc = IptcParser::encode(iptcData_);\n                        if (rawIptc.size_ > 0)\n                        {\n                            DataBuf boxData(8 + 16 + rawIptc.size_);\n                            ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                            ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                            memcpy(boxData.pData_,          boxDataSize,    4);\n                            memcpy(boxData.pData_ + 4,      boxUUIDtype,    4);\n                            memcpy(boxData.pData_ + 8,      kJp2UuidIptc,   16);\n                            memcpy(boxData.pData_ + 8 + 16, rawIptc.pData_, rawIptc.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Iptc metadata (length: \"\n                                      << boxData.size_ << std::endl;\n#endif\n                            if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                        }\n                    }\n\n                    if (writeXmpFromPacket() == false)\n                    {\n                        if (XmpParser::encode(xmpPacket_, xmpData_) > 1)\n                        {\n#ifndef SUPPRESS_WARNINGS\n                            EXV_ERROR << \"Failed to encode XMP metadata.\" << std::endl;\n#endif\n                        }\n                    }\n                    if (xmpPacket_.size() > 0)\n                    {\n                        // Update Xmp data to a new UUID box\n\n                        DataBuf xmp(reinterpret_cast<const byte*>(xmpPacket_.data()), static_cast<long>(xmpPacket_.size()));\n                        DataBuf boxData(8 + 16 + xmp.size_);\n                        ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                        ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                        memcpy(boxData.pData_,          boxDataSize,  4);\n                        memcpy(boxData.pData_ + 4,      boxUUIDtype,  4);\n                        memcpy(boxData.pData_ + 8,      kJp2UuidXmp,  16);\n                        memcpy(boxData.pData_ + 8 + 16, xmp.pData_,   xmp.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with XMP metadata (length: \"\n                                  << boxData.size_ << \")\" << std::endl;\n#endif\n                        if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                    }\n\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n                    if(memcmp(boxBuf.pData_ + 8, kJp2UuidExif, 16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Exif Uuid box\" << std::endl;\n#endif\n                    }\n                    else if(memcmp(boxBuf.pData_ + 8, kJp2UuidIptc, 16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Iptc Uuid box\" << std::endl;\n#endif\n                    }\n                    else if(memcmp(boxBuf.pData_ + 8, kJp2UuidXmp,  16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Xmp Uuid box\" << std::endl;\n#endif\n                    }\n                    else\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: write Uuid box (length: \" << box.length << \")\" << std::endl;\n#endif\n                        if (outIo.write(boxBuf.pData_, boxBuf.size_) != boxBuf.size_) throw Error(kerImageWriteFailed);\n                    }\n                    break;\n                }\n\n                default:\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::doWriteMetadata: write box (length: \" << box.length << \")\" << std::endl;\n#endif\n                    if (outIo.write(boxBuf.pData_, boxBuf.size_) != boxBuf.size_) throw Error(kerImageWriteFailed);\n\n                    break;\n                }\n            }\n        }\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: EOF\" << std::endl;\n#endif\n\n    }",
        "func": "void Jp2Image::doWriteMetadata(BasicIo& outIo)\n    {\n        if (!io_->isopen()) throw Error(kerInputDataReadFailed);\n        if (!outIo.isopen()) throw Error(kerImageWriteFailed);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Writing JPEG-2000 file \" << io_->path() << std::endl;\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: tmp file created \" << outIo.path() << std::endl;\n#endif\n\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerInputDataReadFailed);\n            throw Error(kerNoImageInInputData);\n        }\n\n        // Write JPEG2000 Signature.\n        if (outIo.write(Jp2Signature, 12) != 12) throw Error(kerImageWriteFailed);\n\n        Jp2BoxHeader box = {0,0};\n\n        byte    boxDataSize[4];\n        byte    boxUUIDtype[4];\n        DataBuf bheaderBuf(8);     // Box header : 4 bytes (data size) + 4 bytes (box type).\n\n        // FIXME: Andreas, why the loop do not stop when EOF is taken from _io. The loop go out by an exception\n        // generated by a zero size data read.\n\n        while(io_->tell() < (long) io_->size())\n        {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Position: \" << io_->tell() << \" / \" << io_->size() << std::endl;\n#endif\n\n            // Read chunk header.\n\n            std::memset(bheaderBuf.pData_, 0x00, bheaderBuf.size_);\n            long bufRead = io_->read(bheaderBuf.pData_, bheaderBuf.size_);\n            if (io_->error()) throw Error(kerFailedToReadImageData);\n            if (bufRead != bheaderBuf.size_) throw Error(kerInputDataReadFailed);\n\n            // Decode box header.\n\n            box.length = getLong(bheaderBuf.pData_,     bigEndian);\n            box.type   = getLong(bheaderBuf.pData_ + 4, bigEndian);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length << std::endl;\n#endif\n\n            if (box.length == 0)\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Null Box size has been found. \"\n                             \"This is the last box of file.\" << std::endl;\n#endif\n                box.length = (uint32_t) (io_->size() - io_->tell() + 8);\n            }\n            if (box.length < 8)\n            {\n                // box is broken -> there is nothing we can do here\n                throw Error(kerCorruptedMetadata);\n            }\n\n            // Read whole box : Box header + Box data (not fixed size - can be null).\n\n            DataBuf boxBuf(box.length);                             // Box header (8 bytes) + box data.\n            memcpy(boxBuf.pData_, bheaderBuf.pData_, 8);               // Copy header.\n            bufRead = io_->read(boxBuf.pData_ + 8, box.length - 8); // Extract box data.\n            if (io_->error())\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Error reading source file\" << std::endl;\n#endif\n\n                throw Error(kerFailedToReadImageData);\n            }\n\n            if (bufRead != (long)(box.length - 8))\n            {\n#ifdef EXIV2_DEBUG_MESSAGES\n                std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Cannot read source file data\" << std::endl;\n#endif\n                throw Error(kerInputDataReadFailed);\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n                    DataBuf newBuf;\n                    encodeJp2Header(boxBuf,newBuf);\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write JP2Header box (length: \" << box.length << \")\" << std::endl;\n#endif\n                    if (outIo.write(newBuf.pData_, newBuf.size_) != newBuf.size_) throw Error(kerImageWriteFailed);\n\n                    // Write all updated metadata here, just after JP2Header.\n\n                    if (exifData_.count() > 0)\n                    {\n                        // Update Exif data to a new UUID box\n\n                        Blob blob;\n                        ExifParser::encode(blob, littleEndian, exifData_);\n                        if (blob.size())\n                        {\n                            DataBuf rawExif(static_cast<long>(blob.size()));\n                            memcpy(rawExif.pData_, &blob[0], blob.size());\n\n                            DataBuf boxData(8 + 16 + rawExif.size_);\n                            ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                            ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                            memcpy(boxData.pData_,          boxDataSize,    4);\n                            memcpy(boxData.pData_ + 4,      boxUUIDtype,    4);\n                            memcpy(boxData.pData_ + 8,      kJp2UuidExif,   16);\n                            memcpy(boxData.pData_ + 8 + 16, rawExif.pData_, rawExif.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Exif metadata (length: \"\n                                      << boxData.size_ << std::endl;\n#endif\n                            if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                        }\n                    }\n\n                    if (iptcData_.count() > 0)\n                    {\n                        // Update Iptc data to a new UUID box\n\n                        DataBuf rawIptc = IptcParser::encode(iptcData_);\n                        if (rawIptc.size_ > 0)\n                        {\n                            DataBuf boxData(8 + 16 + rawIptc.size_);\n                            ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                            ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                            memcpy(boxData.pData_,          boxDataSize,    4);\n                            memcpy(boxData.pData_ + 4,      boxUUIDtype,    4);\n                            memcpy(boxData.pData_ + 8,      kJp2UuidIptc,   16);\n                            memcpy(boxData.pData_ + 8 + 16, rawIptc.pData_, rawIptc.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with Iptc metadata (length: \"\n                                      << boxData.size_ << std::endl;\n#endif\n                            if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                        }\n                    }\n\n                    if (writeXmpFromPacket() == false)\n                    {\n                        if (XmpParser::encode(xmpPacket_, xmpData_) > 1)\n                        {\n#ifndef SUPPRESS_WARNINGS\n                            EXV_ERROR << \"Failed to encode XMP metadata.\" << std::endl;\n#endif\n                        }\n                    }\n                    if (xmpPacket_.size() > 0)\n                    {\n                        // Update Xmp data to a new UUID box\n\n                        DataBuf xmp(reinterpret_cast<const byte*>(xmpPacket_.data()), static_cast<long>(xmpPacket_.size()));\n                        DataBuf boxData(8 + 16 + xmp.size_);\n                        ul2Data(boxDataSize, boxData.size_, Exiv2::bigEndian);\n                        ul2Data(boxUUIDtype, kJp2BoxTypeUuid, Exiv2::bigEndian);\n                        memcpy(boxData.pData_,          boxDataSize,  4);\n                        memcpy(boxData.pData_ + 4,      boxUUIDtype,  4);\n                        memcpy(boxData.pData_ + 8,      kJp2UuidXmp,  16);\n                        memcpy(boxData.pData_ + 8 + 16, xmp.pData_,   xmp.size_);\n\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: Write box with XMP metadata (length: \"\n                                  << boxData.size_ << \")\" << std::endl;\n#endif\n                        if (outIo.write(boxData.pData_, boxData.size_) != boxData.size_) throw Error(kerImageWriteFailed);\n                    }\n\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n                    if(memcmp(boxBuf.pData_ + 8, kJp2UuidExif, 16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Exif Uuid box\" << std::endl;\n#endif\n                    }\n                    else if(memcmp(boxBuf.pData_ + 8, kJp2UuidIptc, 16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Iptc Uuid box\" << std::endl;\n#endif\n                    }\n                    else if(memcmp(boxBuf.pData_ + 8, kJp2UuidXmp,  16) == 0)\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: strip Xmp Uuid box\" << std::endl;\n#endif\n                    }\n                    else\n                    {\n#ifdef EXIV2_DEBUG_MESSAGES\n                        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: write Uuid box (length: \" << box.length << \")\" << std::endl;\n#endif\n                        if (outIo.write(boxBuf.pData_, boxBuf.size_) != boxBuf.size_) throw Error(kerImageWriteFailed);\n                    }\n                    break;\n                }\n\n                default:\n                {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << \"Exiv2::Jp2Image::doWriteMetadata: write box (length: \" << box.length << \")\" << std::endl;\n#endif\n                    if (outIo.write(boxBuf.pData_, boxBuf.size_) != boxBuf.size_) throw Error(kerImageWriteFailed);\n\n                    break;\n                }\n            }\n        }\n\n#ifdef EXIV2_DEBUG_MESSAGES\n        std::cout << \"Exiv2::Jp2Image::doWriteMetadata: EOF\" << std::endl;\n#endif\n\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,9 +58,10 @@\n #endif\n                 box.length = (uint32_t) (io_->size() - io_->tell() + 8);\n             }\n-            if (box.length == 1)\n-            {\n-                // FIXME. Special case. the real box size is given in another place.\n+            if (box.length < 8)\n+            {\n+                // box is broken -> there is nothing we can do here\n+                throw Error(kerCorruptedMetadata);\n             }\n \n             // Read whole box : Box header + Box data (not fixed size - can be null).",
        "diff_line_info": {
            "deleted_lines": [
                "            if (box.length == 1)",
                "            {",
                "                // FIXME. Special case. the real box size is given in another place."
            ],
            "added_lines": [
                "            if (box.length < 8)",
                "            {",
                "                // box is broken -> there is nothing we can do here",
                "                throw Error(kerCorruptedMetadata);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-4682",
        "func_name": "gpac/AVI_read_frame",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.3-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/b1042c3eefca87c4bc32afb404ed6518d693e5be",
        "commit_title": "fixed #2574",
        "commit_text": "",
        "func_before": "int AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\n\tAVI->video_pos++;\n\n\treturn n;\n}",
        "func": "int AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\tAVI->video_pos++;\n\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\n\treturn n;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,7 @@\n \t}\n \n \tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n+\tAVI->video_pos++;\n \n \tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n \t{\n@@ -29,7 +30,5 @@\n \t\treturn -1;\n \t}\n \n-\tAVI->video_pos++;\n-\n \treturn n;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tAVI->video_pos++;",
                ""
            ],
            "added_lines": [
                "\tAVI->video_pos++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-4682",
        "func_name": "gpac/AVI_read_audio",
        "description": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.3-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/b1042c3eefca87c4bc32afb404ed6518d693e5be",
        "commit_title": "fixed #2574",
        "commit_text": "",
        "func_before": "int AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tnr = 0; /* total number of bytes read */\n\n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t}\n\n\treturn nr;\n}",
        "func": "int AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tnr = 0; /* total number of bytes read */\n\n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t}\n\n\treturn nr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,7 @@\n \t\t\ttodo = left;\n \t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n \t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n+\t\tAVI->track[AVI->aptr].audio_posb += todo;\n \t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n \t\t{\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n@@ -46,7 +47,6 @@\n \t\t}\n \t\tbytes -= todo;\n \t\tnr    += todo;\n-\t\tAVI->track[AVI->aptr].audio_posb += todo;\n \t}\n \n \treturn nr;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tAVI->track[AVI->aptr].audio_posb += todo;"
            ],
            "added_lines": [
                "\t\tAVI->track[AVI->aptr].audio_posb += todo;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2522",
        "func_name": "vim/ins_compl_infercase_gettext",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0061.",
        "git_url": "https://github.com/vim/vim/commit/b9e717367c395490149495cf375911b5d9de889e",
        "commit_title": "patch 9.0.0060: accessing uninitialized memory when completing long line",
        "commit_text": " Problem:    Accessing uninitialized memory when completing long line. Solution:   Terminate string with NUL.",
        "func_before": "static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tchar_len,\n\tint\tcompl_char_len,\n\tint\tmin_len,\n\tchar_u  **tofree)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n    garray_T\tgap;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, char_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < char_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    p = IObuff;\n    i = 0;\n    ga_init2(&gap, 1, 500);\n    while (i < char_len)\n    {\n\tif (gap.ga_data != NULL)\n\t{\n\t    if (ga_grow(&gap, 10) == FAIL)\n\t    {\n\t\tga_clear(&gap);\n\t\treturn (char_u *)\"[failed]\";\n\t    }\n\t    p = (char_u *)gap.ga_data + gap.ga_len;\n\t    if (has_mbyte)\n\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n\t    else\n\t    {\n\t\t*p = wca[i++];\n\t\t++gap.ga_len;\n\t    }\n\t}\n\telse if ((p - IObuff) + 6 >= IOSIZE)\n\t{\n\t    // Multi-byte characters can occupy up to five bytes more than\n\t    // ASCII characters, and we also need one byte for NUL, so when\n\t    // getting to six bytes from the edge of IObuff switch to using a\n\t    // growarray.  Add the character in the next round.\n\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n\t\treturn (char_u *)\"[failed]\";\n\t    STRCPY(gap.ga_data, IObuff);\n\t    gap.ga_len = (int)STRLEN(IObuff);\n\t}\n\telse if (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    }\n    vim_free(wca);\n\n    if (gap.ga_data != NULL)\n    {\n\t*tofree = gap.ga_data;\n\treturn gap.ga_data;\n    }\n\n    *p = NUL;\n    return IObuff;\n}",
        "func": "static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tchar_len,\n\tint\tcompl_char_len,\n\tint\tmin_len,\n\tchar_u  **tofree)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n    garray_T\tgap;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, char_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < char_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    p = IObuff;\n    i = 0;\n    ga_init2(&gap, 1, 500);\n    while (i < char_len)\n    {\n\tif (gap.ga_data != NULL)\n\t{\n\t    if (ga_grow(&gap, 10) == FAIL)\n\t    {\n\t\tga_clear(&gap);\n\t\treturn (char_u *)\"[failed]\";\n\t    }\n\t    p = (char_u *)gap.ga_data + gap.ga_len;\n\t    if (has_mbyte)\n\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n\t    else\n\t    {\n\t\t*p = wca[i++];\n\t\t++gap.ga_len;\n\t    }\n\t}\n\telse if ((p - IObuff) + 6 >= IOSIZE)\n\t{\n\t    // Multi-byte characters can occupy up to five bytes more than\n\t    // ASCII characters, and we also need one byte for NUL, so when\n\t    // getting to six bytes from the edge of IObuff switch to using a\n\t    // growarray.  Add the character in the next round.\n\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n\t\treturn (char_u *)\"[failed]\";\n\t    *p = NUL;\n\t    STRCPY(gap.ga_data, IObuff);\n\t    gap.ga_len = (int)STRLEN(IObuff);\n\t}\n\telse if (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    }\n    vim_free(wca);\n\n    if (gap.ga_data != NULL)\n    {\n\t*tofree = gap.ga_data;\n\treturn gap.ga_data;\n    }\n\n    *p = NUL;\n    return IObuff;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -114,6 +114,7 @@\n \t    // growarray.  Add the character in the next round.\n \t    if (ga_grow(&gap, IOSIZE) == FAIL)\n \t\treturn (char_u *)\"[failed]\";\n+\t    *p = NUL;\n \t    STRCPY(gap.ga_data, IObuff);\n \t    gap.ga_len = (int)STRLEN(IObuff);\n \t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    *p = NUL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2522",
        "func_name": "vim/check_lnums",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0061.",
        "git_url": "https://github.com/vim/vim/commit/5fa9f23a63651a8abdb074b4fc2ec9b1adc6b089",
        "commit_title": "patch 9.0.0061: ml_get error with nested autocommand",
        "commit_text": " Problem:    ml_get error with nested autocommand. Solution:   Also check line numbers for a nested autocommand. (closes #10761)",
        "func_before": "void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}",
        "func": "void\ncheck_lnums(int do_curwin)\n{\n    check_lnums_both(do_curwin, FALSE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,23 +1,5 @@\n void\n check_lnums(int do_curwin)\n {\n-    win_T\t*wp;\n-    tabpage_T\t*tp;\n-\n-    FOR_ALL_TAB_WINDOWS(tp, wp)\n-\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n-\t{\n-\t    // save the original cursor position and topline\n-\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n-\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n-\n-\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n-\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n-\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n-\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n-\n-\t    // save the corrected cursor position and topline\n-\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n-\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n-\t}\n+    check_lnums_both(do_curwin, FALSE);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    win_T\t*wp;",
                "    tabpage_T\t*tp;",
                "",
                "    FOR_ALL_TAB_WINDOWS(tp, wp)",
                "\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)",
                "\t{",
                "\t    // save the original cursor position and topline",
                "\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;",
                "\t    wp->w_save_cursor.w_topline_save = wp->w_topline;",
                "",
                "\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)",
                "\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;",
                "\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)",
                "\t\twp->w_topline = curbuf->b_ml.ml_line_count;",
                "",
                "\t    // save the corrected cursor position and topline",
                "\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;",
                "\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;",
                "\t}"
            ],
            "added_lines": [
                "    check_lnums_both(do_curwin, FALSE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2522",
        "func_name": "vim/apply_autocmds_group",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0061.",
        "git_url": "https://github.com/vim/vim/commit/5fa9f23a63651a8abdb074b4fc2ec9b1adc6b089",
        "commit_title": "patch 9.0.0061: ml_get error with nested autocommand",
        "commit_text": " Problem:    ml_get error with nested autocommand. Solution:   Also check line numbers for a nested autocommand. (closes #10761)",
        "func_before": "static int\napply_autocmds_group(\n    event_T\tevent,\n    char_u\t*fname,\t     // NULL or empty means use actual file name\n    char_u\t*fname_io,   // fname to use for <afile> on cmdline, NULL means\n\t\t\t     // use fname\n    int\t\tforce,\t     // when TRUE, ignore autocmd_busy\n    int\t\tgroup,\t     // group ID, or AUGROUP_ALL\n    buf_T\t*buf,\t     // buffer for <abuf>\n    exarg_T\t*eap UNUSED) // command arguments\n{\n    char_u\t*sfname = NULL;\t// short file name\n    char_u\t*tail;\n    int\t\tsave_changed;\n    buf_T\t*old_curbuf;\n    int\t\tretval = FALSE;\n    char_u\t*save_autocmd_fname;\n    int\t\tsave_autocmd_fname_full;\n    int\t\tsave_autocmd_bufnr;\n    char_u\t*save_autocmd_match;\n    int\t\tsave_autocmd_busy;\n    int\t\tsave_autocmd_nested;\n    static int\tnesting = 0;\n    AutoPatCmd_T patcmd;\n    AutoPat\t*ap;\n    sctx_T\tsave_current_sctx;\n#ifdef FEAT_EVAL\n    funccal_entry_T funccal_entry;\n    char_u\t*save_cmdarg;\n    long\tsave_cmdbang;\n#endif\n    static int\tfilechangeshell_busy = FALSE;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n    int\t\tdid_save_redobuff = FALSE;\n    save_redo_T\tsave_redo;\n    int\t\tsave_KeyTyped = KeyTyped;\n    int\t\tsave_did_emsg;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * Quickly return if there are no autocommands for this event or\n     * autocommands are blocked.\n     */\n    if (event == NUM_EVENTS || first_autopat[(int)event] == NULL\n\t    || autocmd_blocked > 0)\n\tgoto BYPASS_AU;\n\n    /*\n     * When autocommands are busy, new autocommands are only executed when\n     * explicitly enabled with the \"nested\" flag.\n     */\n    if (autocmd_busy && !(force || autocmd_nested))\n\tgoto BYPASS_AU;\n\n#ifdef FEAT_EVAL\n    /*\n     * Quickly return when immediately aborting on error, or when an interrupt\n     * occurred or an exception was thrown but not caught.\n     */\n    if (aborting())\n\tgoto BYPASS_AU;\n#endif\n\n    /*\n     * FileChangedShell never nests, because it can create an endless loop.\n     */\n    if (filechangeshell_busy && (event == EVENT_FILECHANGEDSHELL\n\t\t\t\t      || event == EVENT_FILECHANGEDSHELLPOST))\n\tgoto BYPASS_AU;\n\n    /*\n     * Ignore events in 'eventignore'.\n     */\n    if (event_ignored(event))\n\tgoto BYPASS_AU;\n\n    /*\n     * Allow nesting of autocommands, but restrict the depth, because it's\n     * possible to create an endless loop.\n     */\n    if (nesting == 10)\n    {\n\temsg(_(e_autocommand_nesting_too_deep));\n\tgoto BYPASS_AU;\n    }\n\n    /*\n     * Check if these autocommands are disabled.  Used when doing \":all\" or\n     * \":ball\".\n     */\n    if (       (autocmd_no_enter\n\t\t&& (event == EVENT_WINENTER || event == EVENT_BUFENTER))\n\t    || (autocmd_no_leave\n\t\t&& (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))\n\tgoto BYPASS_AU;\n\n    /*\n     * Save the autocmd_* variables and info about the current buffer.\n     */\n    save_autocmd_fname = autocmd_fname;\n    save_autocmd_fname_full = autocmd_fname_full;\n    save_autocmd_bufnr = autocmd_bufnr;\n    save_autocmd_match = autocmd_match;\n    save_autocmd_busy = autocmd_busy;\n    save_autocmd_nested = autocmd_nested;\n    save_changed = curbuf->b_changed;\n    old_curbuf = curbuf;\n\n    /*\n     * Set the file name to be used for <afile>.\n     * Make a copy to avoid that changing a buffer name or directory makes it\n     * invalid.\n     */\n    if (fname_io == NULL)\n    {\n\tif (event == EVENT_COLORSCHEME || event == EVENT_COLORSCHEMEPRE\n\t\t\t\t\t\t   || event == EVENT_OPTIONSET\n\t\t\t\t\t\t   || event == EVENT_MODECHANGED)\n\t    autocmd_fname = NULL;\n\telse if (fname != NULL && !ends_excmd(*fname))\n\t    autocmd_fname = fname;\n\telse if (buf != NULL)\n\t    autocmd_fname = buf->b_ffname;\n\telse\n\t    autocmd_fname = NULL;\n    }\n    else\n\tautocmd_fname = fname_io;\n    if (autocmd_fname != NULL)\n\tautocmd_fname = vim_strsave(autocmd_fname);\n    autocmd_fname_full = FALSE; // call FullName_save() later\n\n    /*\n     * Set the buffer number to be used for <abuf>.\n     */\n    if (buf == NULL)\n\tautocmd_bufnr = 0;\n    else\n\tautocmd_bufnr = buf->b_fnum;\n\n    /*\n     * When the file name is NULL or empty, use the file name of buffer \"buf\".\n     * Always use the full path of the file name to match with, in case\n     * \"allow_dirs\" is set.\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tif (buf == NULL)\n\t    fname = NULL;\n\telse\n\t{\n#ifdef FEAT_SYN_HL\n\t    if (event == EVENT_SYNTAX)\n\t\tfname = buf->b_p_syn;\n\t    else\n#endif\n\t\tif (event == EVENT_FILETYPE)\n\t\t    fname = buf->b_p_ft;\n\t\telse\n\t\t{\n\t\t    if (buf->b_sfname != NULL)\n\t\t\tsfname = vim_strsave(buf->b_sfname);\n\t\t    fname = buf->b_ffname;\n\t\t}\n\t}\n\tif (fname == NULL)\n\t    fname = (char_u *)\"\";\n\tfname = vim_strsave(fname);\t// make a copy, so we can change it\n    }\n    else\n    {\n\tsfname = vim_strsave(fname);\n\t// Don't try expanding FileType, Syntax, FuncUndefined, WindowID,\n\t// ColorScheme, QuickFixCmd*, DirChanged and similar.\n\tif (event == EVENT_FILETYPE\n\t\t|| event == EVENT_SYNTAX\n\t\t|| event == EVENT_CMDLINECHANGED\n\t\t|| event == EVENT_CMDLINEENTER\n\t\t|| event == EVENT_CMDLINELEAVE\n\t\t|| event == EVENT_CMDWINENTER\n\t\t|| event == EVENT_CMDWINLEAVE\n\t\t|| event == EVENT_CMDUNDEFINED\n\t\t|| event == EVENT_FUNCUNDEFINED\n\t\t|| event == EVENT_REMOTEREPLY\n\t\t|| event == EVENT_SPELLFILEMISSING\n\t\t|| event == EVENT_QUICKFIXCMDPRE\n\t\t|| event == EVENT_COLORSCHEME\n\t\t|| event == EVENT_COLORSCHEMEPRE\n\t\t|| event == EVENT_OPTIONSET\n\t\t|| event == EVENT_QUICKFIXCMDPOST\n\t\t|| event == EVENT_DIRCHANGED\n\t\t|| event == EVENT_DIRCHANGEDPRE\n\t\t|| event == EVENT_MODECHANGED\n\t\t|| event == EVENT_USER\n\t\t|| event == EVENT_WINCLOSED\n\t\t|| event == EVENT_WINSCROLLED)\n\t{\n\t    fname = vim_strsave(fname);\n\t    autocmd_fname_full = TRUE; // don't expand it later\n\t}\n\telse\n\t    fname = FullName_save(fname, FALSE);\n    }\n    if (fname == NULL)\t    // out of memory\n    {\n\tvim_free(sfname);\n\tretval = FALSE;\n\tgoto BYPASS_AU;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n#ifdef VMS\n    // remove version for correct match\n    if (sfname != NULL)\n\tvms_remove_version(sfname);\n    vms_remove_version(fname);\n#endif\n\n    /*\n     * Set the name to be used for <amatch>.\n     */\n    autocmd_match = fname;\n\n\n    // Don't redraw while doing autocommands.\n    ++RedrawingDisabled;\n\n    // name and lnum are filled in later\n    estack_push(ETYPE_AUCMD, NULL, 0);\n    ESTACK_CHECK_SETUP\n\n    save_current_sctx = current_sctx;\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time); // doesn't count for the caller itself\n# endif\n\n    // Don't use local function variables, if called from a function.\n    save_funccal(&funccal_entry);\n#endif\n\n    /*\n     * When starting to execute autocommands, save the search patterns.\n     */\n    if (!autocmd_busy)\n    {\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redobuff = TRUE;\n\t}\n\tdid_filetype = keep_filetype;\n    }\n\n    /*\n     * Note that we are applying autocmds.  Some commands need to know.\n     */\n    autocmd_busy = TRUE;\n    filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);\n    ++nesting;\t\t// see matching decrement below\n\n    // Remember that FileType was triggered.  Used for did_filetype().\n    if (event == EVENT_FILETYPE)\n\tdid_filetype = TRUE;\n\n    tail = gettail(fname);\n\n    // Find first autocommand that matches\n    CLEAR_FIELD(patcmd);\n    patcmd.curpat = first_autopat[(int)event];\n    patcmd.group = group;\n    patcmd.fname = fname;\n    patcmd.sfname = sfname;\n    patcmd.tail = tail;\n    patcmd.event = event;\n    patcmd.arg_bufnr = autocmd_bufnr;\n    auto_next_pat(&patcmd, FALSE);\n\n    // found one, start executing the autocommands\n    if (patcmd.curpat != NULL)\n    {\n\t// add to active_apc_list\n\tpatcmd.next = active_apc_list;\n\tactive_apc_list = &patcmd;\n\n#ifdef FEAT_EVAL\n\t// set v:cmdarg (only when there is a matching pattern)\n\tsave_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);\n\tif (eap != NULL)\n\t{\n\t    save_cmdarg = set_cmdarg(eap, NULL);\n\t    set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);\n\t}\n\telse\n\t    save_cmdarg = NULL;\t// avoid gcc warning\n#endif\n\tretval = TRUE;\n\t// mark the last pattern, to avoid an endless loop when more patterns\n\t// are added when executing autocommands\n\tfor (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)\n\t    ap->last = FALSE;\n\tap->last = TRUE;\n\n\tif (nesting == 1)\n\t    // make sure cursor and topline are valid\n\t    check_lnums(TRUE);\n\n\tsave_did_emsg = did_emsg;\n\n\tdo_cmdline(NULL, getnextac, (void *)&patcmd,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n\tdid_emsg += save_did_emsg;\n\n\tif (nesting == 1)\n\t    // restore cursor and topline, unless they were changed\n\t    reset_lnums();\n\n#ifdef FEAT_EVAL\n\tif (eap != NULL)\n\t{\n\t    (void)set_cmdarg(NULL, save_cmdarg);\n\t    set_vim_var_nr(VV_CMDBANG, save_cmdbang);\n\t}\n#endif\n\t// delete from active_apc_list\n\tif (active_apc_list == &patcmd)\t    // just in case\n\t    active_apc_list = patcmd.next;\n    }\n\n    --RedrawingDisabled;\n    autocmd_busy = save_autocmd_busy;\n    filechangeshell_busy = FALSE;\n    autocmd_nested = save_autocmd_nested;\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n    vim_free(autocmd_fname);\n    autocmd_fname = save_autocmd_fname;\n    autocmd_fname_full = save_autocmd_fname_full;\n    autocmd_bufnr = save_autocmd_bufnr;\n    autocmd_match = save_autocmd_match;\n    current_sctx = save_current_sctx;\n#ifdef FEAT_EVAL\n    restore_funccal();\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n    KeyTyped = save_KeyTyped;\n    vim_free(fname);\n    vim_free(sfname);\n    --nesting;\t\t// see matching increment above\n\n    /*\n     * When stopping to execute autocommands, restore the search patterns and\n     * the redo buffer.  Free any buffers in the au_pending_free_buf list and\n     * free any windows in the au_pending_free_win list.\n     */\n    if (!autocmd_busy)\n    {\n\trestore_search_patterns();\n\tif (did_save_redobuff)\n\t    restoreRedobuff(&save_redo);\n\tdid_filetype = FALSE;\n\twhile (au_pending_free_buf != NULL)\n\t{\n\t    buf_T *b = au_pending_free_buf->b_next;\n\n\t    vim_free(au_pending_free_buf);\n\t    au_pending_free_buf = b;\n\t}\n\twhile (au_pending_free_win != NULL)\n\t{\n\t    win_T *w = au_pending_free_win->w_next;\n\n\t    vim_free(au_pending_free_win);\n\t    au_pending_free_win = w;\n\t}\n    }\n\n    /*\n     * Some events don't set or reset the Changed flag.\n     * Check if still in the same buffer!\n     */\n    if (curbuf == old_curbuf\n\t    && (event == EVENT_BUFREADPOST\n\t\t|| event == EVENT_BUFWRITEPOST\n\t\t|| event == EVENT_FILEAPPENDPOST\n\t\t|| event == EVENT_VIMLEAVE\n\t\t|| event == EVENT_VIMLEAVEPRE))\n    {\n\tif (curbuf->b_changed != save_changed)\n\t    need_maketitle = TRUE;\n\tcurbuf->b_changed = save_changed;\n    }\n\n    au_cleanup();\t// may really delete removed patterns/commands now\n\nBYPASS_AU:\n    // When wiping out a buffer make sure all its buffer-local autocommands\n    // are deleted.\n    if (event == EVENT_BUFWIPEOUT && buf != NULL)\n\taubuflocal_remove(buf);\n\n    if (retval == OK && event == EVENT_FILETYPE)\n\tau_did_filetype = TRUE;\n\n    return retval;\n}",
        "func": "static int\napply_autocmds_group(\n    event_T\tevent,\n    char_u\t*fname,\t     // NULL or empty means use actual file name\n    char_u\t*fname_io,   // fname to use for <afile> on cmdline, NULL means\n\t\t\t     // use fname\n    int\t\tforce,\t     // when TRUE, ignore autocmd_busy\n    int\t\tgroup,\t     // group ID, or AUGROUP_ALL\n    buf_T\t*buf,\t     // buffer for <abuf>\n    exarg_T\t*eap UNUSED) // command arguments\n{\n    char_u\t*sfname = NULL;\t// short file name\n    char_u\t*tail;\n    int\t\tsave_changed;\n    buf_T\t*old_curbuf;\n    int\t\tretval = FALSE;\n    char_u\t*save_autocmd_fname;\n    int\t\tsave_autocmd_fname_full;\n    int\t\tsave_autocmd_bufnr;\n    char_u\t*save_autocmd_match;\n    int\t\tsave_autocmd_busy;\n    int\t\tsave_autocmd_nested;\n    static int\tnesting = 0;\n    AutoPatCmd_T patcmd;\n    AutoPat\t*ap;\n    sctx_T\tsave_current_sctx;\n#ifdef FEAT_EVAL\n    funccal_entry_T funccal_entry;\n    char_u\t*save_cmdarg;\n    long\tsave_cmdbang;\n#endif\n    static int\tfilechangeshell_busy = FALSE;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n    int\t\tdid_save_redobuff = FALSE;\n    save_redo_T\tsave_redo;\n    int\t\tsave_KeyTyped = KeyTyped;\n    int\t\tsave_did_emsg;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * Quickly return if there are no autocommands for this event or\n     * autocommands are blocked.\n     */\n    if (event == NUM_EVENTS || first_autopat[(int)event] == NULL\n\t    || autocmd_blocked > 0)\n\tgoto BYPASS_AU;\n\n    /*\n     * When autocommands are busy, new autocommands are only executed when\n     * explicitly enabled with the \"nested\" flag.\n     */\n    if (autocmd_busy && !(force || autocmd_nested))\n\tgoto BYPASS_AU;\n\n#ifdef FEAT_EVAL\n    /*\n     * Quickly return when immediately aborting on error, or when an interrupt\n     * occurred or an exception was thrown but not caught.\n     */\n    if (aborting())\n\tgoto BYPASS_AU;\n#endif\n\n    /*\n     * FileChangedShell never nests, because it can create an endless loop.\n     */\n    if (filechangeshell_busy && (event == EVENT_FILECHANGEDSHELL\n\t\t\t\t      || event == EVENT_FILECHANGEDSHELLPOST))\n\tgoto BYPASS_AU;\n\n    /*\n     * Ignore events in 'eventignore'.\n     */\n    if (event_ignored(event))\n\tgoto BYPASS_AU;\n\n    /*\n     * Allow nesting of autocommands, but restrict the depth, because it's\n     * possible to create an endless loop.\n     */\n    if (nesting == 10)\n    {\n\temsg(_(e_autocommand_nesting_too_deep));\n\tgoto BYPASS_AU;\n    }\n\n    /*\n     * Check if these autocommands are disabled.  Used when doing \":all\" or\n     * \":ball\".\n     */\n    if (       (autocmd_no_enter\n\t\t&& (event == EVENT_WINENTER || event == EVENT_BUFENTER))\n\t    || (autocmd_no_leave\n\t\t&& (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))\n\tgoto BYPASS_AU;\n\n    /*\n     * Save the autocmd_* variables and info about the current buffer.\n     */\n    save_autocmd_fname = autocmd_fname;\n    save_autocmd_fname_full = autocmd_fname_full;\n    save_autocmd_bufnr = autocmd_bufnr;\n    save_autocmd_match = autocmd_match;\n    save_autocmd_busy = autocmd_busy;\n    save_autocmd_nested = autocmd_nested;\n    save_changed = curbuf->b_changed;\n    old_curbuf = curbuf;\n\n    /*\n     * Set the file name to be used for <afile>.\n     * Make a copy to avoid that changing a buffer name or directory makes it\n     * invalid.\n     */\n    if (fname_io == NULL)\n    {\n\tif (event == EVENT_COLORSCHEME || event == EVENT_COLORSCHEMEPRE\n\t\t\t\t\t\t   || event == EVENT_OPTIONSET\n\t\t\t\t\t\t   || event == EVENT_MODECHANGED)\n\t    autocmd_fname = NULL;\n\telse if (fname != NULL && !ends_excmd(*fname))\n\t    autocmd_fname = fname;\n\telse if (buf != NULL)\n\t    autocmd_fname = buf->b_ffname;\n\telse\n\t    autocmd_fname = NULL;\n    }\n    else\n\tautocmd_fname = fname_io;\n    if (autocmd_fname != NULL)\n\tautocmd_fname = vim_strsave(autocmd_fname);\n    autocmd_fname_full = FALSE; // call FullName_save() later\n\n    /*\n     * Set the buffer number to be used for <abuf>.\n     */\n    if (buf == NULL)\n\tautocmd_bufnr = 0;\n    else\n\tautocmd_bufnr = buf->b_fnum;\n\n    /*\n     * When the file name is NULL or empty, use the file name of buffer \"buf\".\n     * Always use the full path of the file name to match with, in case\n     * \"allow_dirs\" is set.\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tif (buf == NULL)\n\t    fname = NULL;\n\telse\n\t{\n#ifdef FEAT_SYN_HL\n\t    if (event == EVENT_SYNTAX)\n\t\tfname = buf->b_p_syn;\n\t    else\n#endif\n\t\tif (event == EVENT_FILETYPE)\n\t\t    fname = buf->b_p_ft;\n\t\telse\n\t\t{\n\t\t    if (buf->b_sfname != NULL)\n\t\t\tsfname = vim_strsave(buf->b_sfname);\n\t\t    fname = buf->b_ffname;\n\t\t}\n\t}\n\tif (fname == NULL)\n\t    fname = (char_u *)\"\";\n\tfname = vim_strsave(fname);\t// make a copy, so we can change it\n    }\n    else\n    {\n\tsfname = vim_strsave(fname);\n\t// Don't try expanding FileType, Syntax, FuncUndefined, WindowID,\n\t// ColorScheme, QuickFixCmd*, DirChanged and similar.\n\tif (event == EVENT_FILETYPE\n\t\t|| event == EVENT_SYNTAX\n\t\t|| event == EVENT_CMDLINECHANGED\n\t\t|| event == EVENT_CMDLINEENTER\n\t\t|| event == EVENT_CMDLINELEAVE\n\t\t|| event == EVENT_CMDWINENTER\n\t\t|| event == EVENT_CMDWINLEAVE\n\t\t|| event == EVENT_CMDUNDEFINED\n\t\t|| event == EVENT_FUNCUNDEFINED\n\t\t|| event == EVENT_REMOTEREPLY\n\t\t|| event == EVENT_SPELLFILEMISSING\n\t\t|| event == EVENT_QUICKFIXCMDPRE\n\t\t|| event == EVENT_COLORSCHEME\n\t\t|| event == EVENT_COLORSCHEMEPRE\n\t\t|| event == EVENT_OPTIONSET\n\t\t|| event == EVENT_QUICKFIXCMDPOST\n\t\t|| event == EVENT_DIRCHANGED\n\t\t|| event == EVENT_DIRCHANGEDPRE\n\t\t|| event == EVENT_MODECHANGED\n\t\t|| event == EVENT_USER\n\t\t|| event == EVENT_WINCLOSED\n\t\t|| event == EVENT_WINSCROLLED)\n\t{\n\t    fname = vim_strsave(fname);\n\t    autocmd_fname_full = TRUE; // don't expand it later\n\t}\n\telse\n\t    fname = FullName_save(fname, FALSE);\n    }\n    if (fname == NULL)\t    // out of memory\n    {\n\tvim_free(sfname);\n\tretval = FALSE;\n\tgoto BYPASS_AU;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n#ifdef VMS\n    // remove version for correct match\n    if (sfname != NULL)\n\tvms_remove_version(sfname);\n    vms_remove_version(fname);\n#endif\n\n    /*\n     * Set the name to be used for <amatch>.\n     */\n    autocmd_match = fname;\n\n\n    // Don't redraw while doing autocommands.\n    ++RedrawingDisabled;\n\n    // name and lnum are filled in later\n    estack_push(ETYPE_AUCMD, NULL, 0);\n    ESTACK_CHECK_SETUP\n\n    save_current_sctx = current_sctx;\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time); // doesn't count for the caller itself\n# endif\n\n    // Don't use local function variables, if called from a function.\n    save_funccal(&funccal_entry);\n#endif\n\n    /*\n     * When starting to execute autocommands, save the search patterns.\n     */\n    if (!autocmd_busy)\n    {\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redobuff = TRUE;\n\t}\n\tdid_filetype = keep_filetype;\n    }\n\n    /*\n     * Note that we are applying autocmds.  Some commands need to know.\n     */\n    autocmd_busy = TRUE;\n    filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);\n    ++nesting;\t\t// see matching decrement below\n\n    // Remember that FileType was triggered.  Used for did_filetype().\n    if (event == EVENT_FILETYPE)\n\tdid_filetype = TRUE;\n\n    tail = gettail(fname);\n\n    // Find first autocommand that matches\n    CLEAR_FIELD(patcmd);\n    patcmd.curpat = first_autopat[(int)event];\n    patcmd.group = group;\n    patcmd.fname = fname;\n    patcmd.sfname = sfname;\n    patcmd.tail = tail;\n    patcmd.event = event;\n    patcmd.arg_bufnr = autocmd_bufnr;\n    auto_next_pat(&patcmd, FALSE);\n\n    // found one, start executing the autocommands\n    if (patcmd.curpat != NULL)\n    {\n\t// add to active_apc_list\n\tpatcmd.next = active_apc_list;\n\tactive_apc_list = &patcmd;\n\n#ifdef FEAT_EVAL\n\t// set v:cmdarg (only when there is a matching pattern)\n\tsave_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);\n\tif (eap != NULL)\n\t{\n\t    save_cmdarg = set_cmdarg(eap, NULL);\n\t    set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);\n\t}\n\telse\n\t    save_cmdarg = NULL;\t// avoid gcc warning\n#endif\n\tretval = TRUE;\n\t// mark the last pattern, to avoid an endless loop when more patterns\n\t// are added when executing autocommands\n\tfor (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)\n\t    ap->last = FALSE;\n\tap->last = TRUE;\n\n\t// Make sure cursor and topline are valid.  The first time the current\n\t// values are saved, restored by reset_lnums().  When nested only the\n\t// values are corrected when needed.\n\tif (nesting == 1)\n\t    check_lnums(TRUE);\n\telse\n\t    check_lnums_nested(TRUE);\n\n\tsave_did_emsg = did_emsg;\n\n\tdo_cmdline(NULL, getnextac, (void *)&patcmd,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n\tdid_emsg += save_did_emsg;\n\n\tif (nesting == 1)\n\t    // restore cursor and topline, unless they were changed\n\t    reset_lnums();\n\n#ifdef FEAT_EVAL\n\tif (eap != NULL)\n\t{\n\t    (void)set_cmdarg(NULL, save_cmdarg);\n\t    set_vim_var_nr(VV_CMDBANG, save_cmdbang);\n\t}\n#endif\n\t// delete from active_apc_list\n\tif (active_apc_list == &patcmd)\t    // just in case\n\t    active_apc_list = patcmd.next;\n    }\n\n    --RedrawingDisabled;\n    autocmd_busy = save_autocmd_busy;\n    filechangeshell_busy = FALSE;\n    autocmd_nested = save_autocmd_nested;\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n    vim_free(autocmd_fname);\n    autocmd_fname = save_autocmd_fname;\n    autocmd_fname_full = save_autocmd_fname_full;\n    autocmd_bufnr = save_autocmd_bufnr;\n    autocmd_match = save_autocmd_match;\n    current_sctx = save_current_sctx;\n#ifdef FEAT_EVAL\n    restore_funccal();\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n    KeyTyped = save_KeyTyped;\n    vim_free(fname);\n    vim_free(sfname);\n    --nesting;\t\t// see matching increment above\n\n    /*\n     * When stopping to execute autocommands, restore the search patterns and\n     * the redo buffer.  Free any buffers in the au_pending_free_buf list and\n     * free any windows in the au_pending_free_win list.\n     */\n    if (!autocmd_busy)\n    {\n\trestore_search_patterns();\n\tif (did_save_redobuff)\n\t    restoreRedobuff(&save_redo);\n\tdid_filetype = FALSE;\n\twhile (au_pending_free_buf != NULL)\n\t{\n\t    buf_T *b = au_pending_free_buf->b_next;\n\n\t    vim_free(au_pending_free_buf);\n\t    au_pending_free_buf = b;\n\t}\n\twhile (au_pending_free_win != NULL)\n\t{\n\t    win_T *w = au_pending_free_win->w_next;\n\n\t    vim_free(au_pending_free_win);\n\t    au_pending_free_win = w;\n\t}\n    }\n\n    /*\n     * Some events don't set or reset the Changed flag.\n     * Check if still in the same buffer!\n     */\n    if (curbuf == old_curbuf\n\t    && (event == EVENT_BUFREADPOST\n\t\t|| event == EVENT_BUFWRITEPOST\n\t\t|| event == EVENT_FILEAPPENDPOST\n\t\t|| event == EVENT_VIMLEAVE\n\t\t|| event == EVENT_VIMLEAVEPRE))\n    {\n\tif (curbuf->b_changed != save_changed)\n\t    need_maketitle = TRUE;\n\tcurbuf->b_changed = save_changed;\n    }\n\n    au_cleanup();\t// may really delete removed patterns/commands now\n\nBYPASS_AU:\n    // When wiping out a buffer make sure all its buffer-local autocommands\n    // are deleted.\n    if (event == EVENT_BUFWIPEOUT && buf != NULL)\n\taubuflocal_remove(buf);\n\n    if (retval == OK && event == EVENT_FILETYPE)\n\tau_did_filetype = TRUE;\n\n    return retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -315,9 +315,13 @@\n \t    ap->last = FALSE;\n \tap->last = TRUE;\n \n+\t// Make sure cursor and topline are valid.  The first time the current\n+\t// values are saved, restored by reset_lnums().  When nested only the\n+\t// values are corrected when needed.\n \tif (nesting == 1)\n-\t    // make sure cursor and topline are valid\n \t    check_lnums(TRUE);\n+\telse\n+\t    check_lnums_nested(TRUE);\n \n \tsave_did_emsg = did_emsg;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t    // make sure cursor and topline are valid"
            ],
            "added_lines": [
                "\t// Make sure cursor and topline are valid.  The first time the current",
                "\t// values are saved, restored by reset_lnums().  When nested only the",
                "\t// values are corrected when needed.",
                "\telse",
                "\t    check_lnums_nested(TRUE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2571",
        "func_name": "vim/ins_comp_get_next_word_or_line",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0101.",
        "git_url": "https://github.com/vim/vim/commit/a6f9e300161f4cb54713da22f65b261595e8e614",
        "commit_title": "patch 9.0.0102: reading past end of line with insert mode completion",
        "commit_text": " Problem:    Reading past end of line with insert mode completion. Solution:   Check text length.",
        "func_before": "static char_u *\nins_comp_get_next_word_or_line(\n\tbuf_T\t*ins_buf,\t\t// buffer being scanned\n\tpos_T\t*cur_match_pos,\t\t// current match position\n\tint\t*match_len,\n\tint\t*cont_s_ipos)\t\t// next ^X<> will set initial_pos\n{\n    char_u\t*ptr;\n    int\t\tlen;\n\n    *match_len = 0;\n    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum, FALSE) +\n\tcur_match_pos->col;\n    if (ctrl_x_mode_line_or_eval())\n    {\n\tif (compl_status_adding())\n\t{\n\t    if (cur_match_pos->lnum >= ins_buf->b_ml.ml_line_count)\n\t\treturn NULL;\n\t    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t    if (!p_paste)\n\t\tptr = skipwhite(ptr);\n\t}\n\tlen = (int)STRLEN(ptr);\n    }\n    else\n    {\n\tchar_u\t*tmp_ptr = ptr;\n\n\tif (compl_status_adding())\n\t{\n\t    tmp_ptr += compl_length;\n\t    // Skip if already inside a word.\n\t    if (vim_iswordp(tmp_ptr))\n\t\treturn NULL;\n\t    // Find start of next word.\n\t    tmp_ptr = find_word_start(tmp_ptr);\n\t}\n\t// Find end of this word.\n\ttmp_ptr = find_word_end(tmp_ptr);\n\tlen = (int)(tmp_ptr - ptr);\n\n\tif (compl_status_adding() && len == compl_length)\n\t{\n\t    if (cur_match_pos->lnum < ins_buf->b_ml.ml_line_count)\n\t    {\n\t\t// Try next line, if any. the new word will be\n\t\t// \"join\" as if the normal command \"J\" was used.\n\t\t// IOSIZE is always greater than\n\t\t// compl_length, so the next STRNCPY always\n\t\t// works -- Acevedo\n\t\tSTRNCPY(IObuff, ptr, len);\n\t\tptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t\ttmp_ptr = ptr = skipwhite(ptr);\n\t\t// Find start of next word.\n\t\ttmp_ptr = find_word_start(tmp_ptr);\n\t\t// Find end of next word.\n\t\ttmp_ptr = find_word_end(tmp_ptr);\n\t\tif (tmp_ptr > ptr)\n\t\t{\n\t\t    if (*ptr != ')' && IObuff[len - 1] != TAB)\n\t\t    {\n\t\t\tif (IObuff[len - 1] != ' ')\n\t\t\t    IObuff[len++] = ' ';\n\t\t\t// IObuf =~ \"\\k.* \", thus len >= 2\n\t\t\tif (p_js\n\t\t\t\t&& (IObuff[len - 2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP)\n\t\t\t\t\t== NULL\n\t\t\t\t\t&& (IObuff[len - 2] == '?'\n\t\t\t\t\t    || IObuff[len - 2] == '!'))))\n\t\t\t    IObuff[len++] = ' ';\n\t\t    }\n\t\t    // copy as much as possible of the new word\n\t\t    if (tmp_ptr - ptr >= IOSIZE - len)\n\t\t\ttmp_ptr = ptr + IOSIZE - len - 1;\n\t\t    STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);\n\t\t    len += (int)(tmp_ptr - ptr);\n\t\t    *cont_s_ipos = TRUE;\n\t\t}\n\t\tIObuff[len] = NUL;\n\t\tptr = IObuff;\n\t    }\n\t    if (len == compl_length)\n\t\treturn NULL;\n\t}\n    }\n\n    *match_len = len;\n    return ptr;\n}",
        "func": "static char_u *\nins_comp_get_next_word_or_line(\n\tbuf_T\t*ins_buf,\t\t// buffer being scanned\n\tpos_T\t*cur_match_pos,\t\t// current match position\n\tint\t*match_len,\n\tint\t*cont_s_ipos)\t\t// next ^X<> will set initial_pos\n{\n    char_u\t*ptr;\n    int\t\tlen;\n\n    *match_len = 0;\n    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum, FALSE) +\n\tcur_match_pos->col;\n    if (ctrl_x_mode_line_or_eval())\n    {\n\tif (compl_status_adding())\n\t{\n\t    if (cur_match_pos->lnum >= ins_buf->b_ml.ml_line_count)\n\t\treturn NULL;\n\t    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t    if (!p_paste)\n\t\tptr = skipwhite(ptr);\n\t}\n\tlen = (int)STRLEN(ptr);\n    }\n    else\n    {\n\tchar_u\t*tmp_ptr = ptr;\n\n\tif (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))\n\t{\n\t    tmp_ptr += compl_length;\n\t    // Skip if already inside a word.\n\t    if (vim_iswordp(tmp_ptr))\n\t\treturn NULL;\n\t    // Find start of next word.\n\t    tmp_ptr = find_word_start(tmp_ptr);\n\t}\n\t// Find end of this word.\n\ttmp_ptr = find_word_end(tmp_ptr);\n\tlen = (int)(tmp_ptr - ptr);\n\n\tif (compl_status_adding() && len == compl_length)\n\t{\n\t    if (cur_match_pos->lnum < ins_buf->b_ml.ml_line_count)\n\t    {\n\t\t// Try next line, if any. the new word will be\n\t\t// \"join\" as if the normal command \"J\" was used.\n\t\t// IOSIZE is always greater than\n\t\t// compl_length, so the next STRNCPY always\n\t\t// works -- Acevedo\n\t\tSTRNCPY(IObuff, ptr, len);\n\t\tptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t\ttmp_ptr = ptr = skipwhite(ptr);\n\t\t// Find start of next word.\n\t\ttmp_ptr = find_word_start(tmp_ptr);\n\t\t// Find end of next word.\n\t\ttmp_ptr = find_word_end(tmp_ptr);\n\t\tif (tmp_ptr > ptr)\n\t\t{\n\t\t    if (*ptr != ')' && IObuff[len - 1] != TAB)\n\t\t    {\n\t\t\tif (IObuff[len - 1] != ' ')\n\t\t\t    IObuff[len++] = ' ';\n\t\t\t// IObuf =~ \"\\k.* \", thus len >= 2\n\t\t\tif (p_js\n\t\t\t\t&& (IObuff[len - 2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP)\n\t\t\t\t\t== NULL\n\t\t\t\t\t&& (IObuff[len - 2] == '?'\n\t\t\t\t\t    || IObuff[len - 2] == '!'))))\n\t\t\t    IObuff[len++] = ' ';\n\t\t    }\n\t\t    // copy as much as possible of the new word\n\t\t    if (tmp_ptr - ptr >= IOSIZE - len)\n\t\t\ttmp_ptr = ptr + IOSIZE - len - 1;\n\t\t    STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);\n\t\t    len += (int)(tmp_ptr - ptr);\n\t\t    *cont_s_ipos = TRUE;\n\t\t}\n\t\tIObuff[len] = NUL;\n\t\tptr = IObuff;\n\t    }\n\t    if (len == compl_length)\n\t\treturn NULL;\n\t}\n    }\n\n    *match_len = len;\n    return ptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n     {\n \tchar_u\t*tmp_ptr = ptr;\n \n-\tif (compl_status_adding())\n+\tif (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))\n \t{\n \t    tmp_ptr += compl_length;\n \t    // Skip if already inside a word.",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (compl_status_adding())"
            ],
            "added_lines": [
                "\tif (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2580",
        "func_name": "vim/eval_string",
        "description": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0102.",
        "git_url": "https://github.com/vim/vim/commit/1e56bda9048a9625bce6e660938c834c5c15b07d",
        "commit_title": "patch 9.0.0104: going beyond allocated memory when evaluating string constant",
        "commit_text": " Problem:    Going beyond allocated memory when evaluating string constant. Solution:   Properly skip over <Key> form.",
        "func_before": "int\neval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t\textra += 5;\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}",
        "func": "int\neval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t    {\n\t\tint\t\tmodifiers = 0;\n\t\tint\t\tflags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\textra += 5;\n\n\t\t// Skip to the '>' to avoid using '{' inside for string\n\t\t// interpolation.\n\t\tif (p[1] != '*')\n\t\t    flags |= FSK_SIMPLIFY;\n\t\tif (find_special_key(&p, &modifiers, flags, NULL) != 0)\n\t\t    --p;  // leave \"p\" on the \">\"\n\t    }\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,19 @@\n \t    // to 9 characters (6 for the char and 3 for a modifier):\n \t    // reserve space for 5 extra.\n \t    if (*p == '<')\n+\t    {\n+\t\tint\t\tmodifiers = 0;\n+\t\tint\t\tflags = FSK_KEYCODE | FSK_IN_STRING;\n+\n \t\textra += 5;\n+\n+\t\t// Skip to the '>' to avoid using '{' inside for string\n+\t\t// interpolation.\n+\t\tif (p[1] != '*')\n+\t\t    flags |= FSK_SIMPLIFY;\n+\t\tif (find_special_key(&p, &modifiers, flags, NULL) != 0)\n+\t\t    --p;  // leave \"p\" on the \">\"\n+\t    }\n \t}\n \telse if (interpolate && (*p == '{' || *p == '}'))\n \t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    {",
                "\t\tint\t\tmodifiers = 0;",
                "\t\tint\t\tflags = FSK_KEYCODE | FSK_IN_STRING;",
                "",
                "",
                "\t\t// Skip to the '>' to avoid using '{' inside for string",
                "\t\t// interpolation.",
                "\t\tif (p[1] != '*')",
                "\t\t    flags |= FSK_SIMPLIFY;",
                "\t\tif (find_special_key(&p, &modifiers, flags, NULL) != 0)",
                "\t\t    --p;  // leave \"p\" on the \">\"",
                "\t    }"
            ]
        }
    }
]