[
    {
        "cve_id": "CVE-2017-6508",
        "func_name": "wget/url_parse",
        "description": "CRLF injection vulnerability in the url_parse function in url.c in Wget through 1.19.1 allows remote attackers to inject arbitrary HTTP headers via CRLF sequences in the host subcomponent of a URL.",
        "git_url": "http://git.savannah.gnu.org/cgit/wget.git/commit/?id=4d729e322fae359a1aefaafec1144764a54e8ad4",
        "commit_title": "* src/url.c (url_parse): Reject control characters in host part of URL",
        "commit_text": " ",
        "func_before": "struct url *\nurl_parse (const char *url, int *error, struct iri *iri, bool percent_encode)\n{\n  struct url *u;\n  const char *p;\n  bool path_modified, host_modified;\n\n  enum url_scheme scheme;\n  const char *seps;\n\n  const char *uname_b,     *uname_e;\n  const char *host_b,      *host_e;\n  const char *path_b,      *path_e;\n  const char *params_b,    *params_e;\n  const char *query_b,     *query_e;\n  const char *fragment_b,  *fragment_e;\n\n  int port;\n  char *user = NULL, *passwd = NULL;\n\n  const char *url_encoded = NULL;\n\n  int error_code;\n\n  scheme = url_scheme (url);\n  if (scheme == SCHEME_INVALID)\n    {\n      if (url_has_scheme (url))\n        error_code = PE_UNSUPPORTED_SCHEME;\n      else\n        error_code = PE_MISSING_SCHEME;\n      goto error;\n    }\n\n  url_encoded = url;\n\n  if (iri && iri->utf8_encode)\n    {\n      char *new_url = NULL;\n\n      iri->utf8_encode = remote_to_utf8 (iri, iri->orig_url ? iri->orig_url : url, &new_url);\n      if (!iri->utf8_encode)\n        new_url = NULL;\n      else\n        {\n          xfree (iri->orig_url);\n          iri->orig_url = xstrdup (url);\n          url_encoded = reencode_escapes (new_url);\n          if (url_encoded != new_url)\n            xfree (new_url);\n          percent_encode = false;\n        }\n    }\n\n  if (percent_encode)\n    url_encoded = reencode_escapes (url);\n\n  p = url_encoded;\n  p += strlen (supported_schemes[scheme].leading_string);\n  uname_b = p;\n  p = url_skip_credentials (p);\n  uname_e = p;\n\n  /* scheme://user:pass@host[:port]... */\n  /*                    ^              */\n\n  /* We attempt to break down the URL into the components path,\n     params, query, and fragment.  They are ordered like this:\n\n       scheme://host[:port][/path][;params][?query][#fragment]  */\n\n  path_b     = path_e     = NULL;\n  params_b   = params_e   = NULL;\n  query_b    = query_e    = NULL;\n  fragment_b = fragment_e = NULL;\n\n  /* Initialize separators for optional parts of URL, depending on the\n     scheme.  For example, FTP has params, and HTTP and HTTPS have\n     query string and fragment. */\n  seps = init_seps (scheme);\n\n  host_b = p;\n\n  if (*p == '[')\n    {\n      /* Handle IPv6 address inside square brackets.  Ideally we'd\n         just look for the terminating ']', but rfc2732 mandates\n         rejecting invalid IPv6 addresses.  */\n\n      /* The address begins after '['. */\n      host_b = p + 1;\n      host_e = strchr (host_b, ']');\n\n      if (!host_e)\n        {\n          error_code = PE_UNTERMINATED_IPV6_ADDRESS;\n          goto error;\n        }\n\n#ifdef ENABLE_IPV6\n      /* Check if the IPv6 address is valid. */\n      if (!is_valid_ipv6_address(host_b, host_e))\n        {\n          error_code = PE_INVALID_IPV6_ADDRESS;\n          goto error;\n        }\n\n      /* Continue parsing after the closing ']'. */\n      p = host_e + 1;\n#else\n      error_code = PE_IPV6_NOT_SUPPORTED;\n      goto error;\n#endif\n\n      /* The closing bracket must be followed by a separator or by the\n         null char.  */\n      /* http://[::1]... */\n      /*             ^   */\n      if (!strchr (seps, *p))\n        {\n          /* Trailing garbage after []-delimited IPv6 address. */\n          error_code = PE_INVALID_HOST_NAME;\n          goto error;\n        }\n    }\n  else\n    {\n      p = strpbrk_or_eos (p, seps);\n      host_e = p;\n    }\n  ++seps;                       /* advance to '/' */\n\n  if (host_b == host_e)\n    {\n      error_code = PE_INVALID_HOST_NAME;\n      goto error;\n    }\n\n  port = scheme_default_port (scheme);\n  if (*p == ':')\n    {\n      const char *port_b, *port_e, *pp;\n\n      /* scheme://host:port/tralala */\n      /*              ^             */\n      ++p;\n      port_b = p;\n      p = strpbrk_or_eos (p, seps);\n      port_e = p;\n\n      /* Allow empty port, as per rfc2396. */\n      if (port_b != port_e)\n        for (port = 0, pp = port_b; pp < port_e; pp++)\n          {\n            if (!c_isdigit (*pp))\n              {\n                /* http://host:12randomgarbage/blah */\n                /*               ^                  */\n                error_code = PE_BAD_PORT_NUMBER;\n                goto error;\n              }\n            port = 10 * port + (*pp - '0');\n            /* Check for too large port numbers here, before we have\n               a chance to overflow on bogus port values.  */\n            if (port > 0xffff)\n              {\n                error_code = PE_BAD_PORT_NUMBER;\n                goto error;\n              }\n          }\n    }\n  /* Advance to the first separator *after* '/' (either ';' or '?',\n     depending on the scheme).  */\n  ++seps;\n\n  /* Get the optional parts of URL, each part being delimited by\n     current location and the position of the next separator.  */\n#define GET_URL_PART(sepchar, var) do {                         \\\n  if (*p == sepchar)                                            \\\n    var##_b = ++p, var##_e = p = strpbrk_or_eos (p, seps);      \\\n  ++seps;                                                       \\\n} while (0)\n\n  GET_URL_PART ('/', path);\n  if (supported_schemes[scheme].flags & scm_has_params)\n    GET_URL_PART (';', params);\n  if (supported_schemes[scheme].flags & scm_has_query)\n    GET_URL_PART ('?', query);\n  if (supported_schemes[scheme].flags & scm_has_fragment)\n    GET_URL_PART ('#', fragment);\n\n#undef GET_URL_PART\n  assert (*p == 0);\n\n  if (uname_b != uname_e)\n    {\n      /* http://user:pass@host */\n      /*        ^         ^    */\n      /*     uname_b   uname_e */\n      if (!parse_credentials (uname_b, uname_e - 1, &user, &passwd))\n        {\n          error_code = PE_INVALID_USER_NAME;\n          goto error;\n        }\n    }\n\n  u = xnew0 (struct url);\n  u->scheme = scheme;\n  u->host   = strdupdelim (host_b, host_e);\n  u->port   = port;\n  u->user   = user;\n  u->passwd = passwd;\n\n  u->path = strdupdelim (path_b, path_e);\n  path_modified = path_simplify (scheme, u->path);\n  split_path (u->path, &u->dir, &u->file);\n\n  host_modified = lowercase_str (u->host);\n\n  /* Decode %HH sequences in host name.  This is important not so much\n     to support %HH sequences in host names (which other browser\n     don't), but to support binary characters (which will have been\n     converted to %HH by reencode_escapes).  */\n  if (strchr (u->host, '%'))\n    {\n      url_unescape (u->host);\n      host_modified = true;\n\n      /* Apply IDNA regardless of iri->utf8_encode status */\n      if (opt.enable_iri && iri)\n        {\n          char *new = idn_encode (iri, u->host);\n          if (new)\n            {\n              xfree (u->host);\n              u->host = new;\n              u->idn_allocated = true;\n              host_modified = true;\n            }\n        }\n    }\n\n  if (params_b)\n    u->params = strdupdelim (params_b, params_e);\n  if (query_b)\n    u->query = strdupdelim (query_b, query_e);\n  if (fragment_b)\n    u->fragment = strdupdelim (fragment_b, fragment_e);\n\n  if (opt.enable_iri || path_modified || u->fragment || host_modified || path_b == path_e)\n    {\n      /* If we suspect that a transformation has rendered what\n         url_string might return different from URL_ENCODED, rebuild\n         u->url using url_string.  */\n      u->url = url_string (u, URL_AUTH_SHOW);\n\n      if (url_encoded != url)\n        xfree (url_encoded);\n    }\n  else\n    {\n      if (url_encoded == url)\n        u->url = xstrdup (url);\n      else\n        u->url = (char *) url_encoded;\n    }\n\n  return u;\n\n error:\n  /* Cleanup in case of error: */\n  if (url_encoded && url_encoded != url)\n    xfree (url_encoded);\n\n  /* Transmit the error code to the caller, if the caller wants to\n     know.  */\n  if (error)\n    *error = error_code;\n  return NULL;\n}",
        "func": "struct url *\nurl_parse (const char *url, int *error, struct iri *iri, bool percent_encode)\n{\n  struct url *u;\n  const char *p;\n  bool path_modified, host_modified;\n\n  enum url_scheme scheme;\n  const char *seps;\n\n  const char *uname_b,     *uname_e;\n  const char *host_b,      *host_e;\n  const char *path_b,      *path_e;\n  const char *params_b,    *params_e;\n  const char *query_b,     *query_e;\n  const char *fragment_b,  *fragment_e;\n\n  int port;\n  char *user = NULL, *passwd = NULL;\n\n  const char *url_encoded = NULL;\n\n  int error_code;\n\n  scheme = url_scheme (url);\n  if (scheme == SCHEME_INVALID)\n    {\n      if (url_has_scheme (url))\n        error_code = PE_UNSUPPORTED_SCHEME;\n      else\n        error_code = PE_MISSING_SCHEME;\n      goto error;\n    }\n\n  url_encoded = url;\n\n  if (iri && iri->utf8_encode)\n    {\n      char *new_url = NULL;\n\n      iri->utf8_encode = remote_to_utf8 (iri, iri->orig_url ? iri->orig_url : url, &new_url);\n      if (!iri->utf8_encode)\n        new_url = NULL;\n      else\n        {\n          xfree (iri->orig_url);\n          iri->orig_url = xstrdup (url);\n          url_encoded = reencode_escapes (new_url);\n          if (url_encoded != new_url)\n            xfree (new_url);\n          percent_encode = false;\n        }\n    }\n\n  if (percent_encode)\n    url_encoded = reencode_escapes (url);\n\n  p = url_encoded;\n  p += strlen (supported_schemes[scheme].leading_string);\n  uname_b = p;\n  p = url_skip_credentials (p);\n  uname_e = p;\n\n  /* scheme://user:pass@host[:port]... */\n  /*                    ^              */\n\n  /* We attempt to break down the URL into the components path,\n     params, query, and fragment.  They are ordered like this:\n\n       scheme://host[:port][/path][;params][?query][#fragment]  */\n\n  path_b     = path_e     = NULL;\n  params_b   = params_e   = NULL;\n  query_b    = query_e    = NULL;\n  fragment_b = fragment_e = NULL;\n\n  /* Initialize separators for optional parts of URL, depending on the\n     scheme.  For example, FTP has params, and HTTP and HTTPS have\n     query string and fragment. */\n  seps = init_seps (scheme);\n\n  host_b = p;\n\n  if (*p == '[')\n    {\n      /* Handle IPv6 address inside square brackets.  Ideally we'd\n         just look for the terminating ']', but rfc2732 mandates\n         rejecting invalid IPv6 addresses.  */\n\n      /* The address begins after '['. */\n      host_b = p + 1;\n      host_e = strchr (host_b, ']');\n\n      if (!host_e)\n        {\n          error_code = PE_UNTERMINATED_IPV6_ADDRESS;\n          goto error;\n        }\n\n#ifdef ENABLE_IPV6\n      /* Check if the IPv6 address is valid. */\n      if (!is_valid_ipv6_address(host_b, host_e))\n        {\n          error_code = PE_INVALID_IPV6_ADDRESS;\n          goto error;\n        }\n\n      /* Continue parsing after the closing ']'. */\n      p = host_e + 1;\n#else\n      error_code = PE_IPV6_NOT_SUPPORTED;\n      goto error;\n#endif\n\n      /* The closing bracket must be followed by a separator or by the\n         null char.  */\n      /* http://[::1]... */\n      /*             ^   */\n      if (!strchr (seps, *p))\n        {\n          /* Trailing garbage after []-delimited IPv6 address. */\n          error_code = PE_INVALID_HOST_NAME;\n          goto error;\n        }\n    }\n  else\n    {\n      p = strpbrk_or_eos (p, seps);\n      host_e = p;\n    }\n  ++seps;                       /* advance to '/' */\n\n  if (host_b == host_e)\n    {\n      error_code = PE_INVALID_HOST_NAME;\n      goto error;\n    }\n\n  port = scheme_default_port (scheme);\n  if (*p == ':')\n    {\n      const char *port_b, *port_e, *pp;\n\n      /* scheme://host:port/tralala */\n      /*              ^             */\n      ++p;\n      port_b = p;\n      p = strpbrk_or_eos (p, seps);\n      port_e = p;\n\n      /* Allow empty port, as per rfc2396. */\n      if (port_b != port_e)\n        for (port = 0, pp = port_b; pp < port_e; pp++)\n          {\n            if (!c_isdigit (*pp))\n              {\n                /* http://host:12randomgarbage/blah */\n                /*               ^                  */\n                error_code = PE_BAD_PORT_NUMBER;\n                goto error;\n              }\n            port = 10 * port + (*pp - '0');\n            /* Check for too large port numbers here, before we have\n               a chance to overflow on bogus port values.  */\n            if (port > 0xffff)\n              {\n                error_code = PE_BAD_PORT_NUMBER;\n                goto error;\n              }\n          }\n    }\n  /* Advance to the first separator *after* '/' (either ';' or '?',\n     depending on the scheme).  */\n  ++seps;\n\n  /* Get the optional parts of URL, each part being delimited by\n     current location and the position of the next separator.  */\n#define GET_URL_PART(sepchar, var) do {                         \\\n  if (*p == sepchar)                                            \\\n    var##_b = ++p, var##_e = p = strpbrk_or_eos (p, seps);      \\\n  ++seps;                                                       \\\n} while (0)\n\n  GET_URL_PART ('/', path);\n  if (supported_schemes[scheme].flags & scm_has_params)\n    GET_URL_PART (';', params);\n  if (supported_schemes[scheme].flags & scm_has_query)\n    GET_URL_PART ('?', query);\n  if (supported_schemes[scheme].flags & scm_has_fragment)\n    GET_URL_PART ('#', fragment);\n\n#undef GET_URL_PART\n  assert (*p == 0);\n\n  if (uname_b != uname_e)\n    {\n      /* http://user:pass@host */\n      /*        ^         ^    */\n      /*     uname_b   uname_e */\n      if (!parse_credentials (uname_b, uname_e - 1, &user, &passwd))\n        {\n          error_code = PE_INVALID_USER_NAME;\n          goto error;\n        }\n    }\n\n  u = xnew0 (struct url);\n  u->scheme = scheme;\n  u->host   = strdupdelim (host_b, host_e);\n  u->port   = port;\n  u->user   = user;\n  u->passwd = passwd;\n\n  u->path = strdupdelim (path_b, path_e);\n  path_modified = path_simplify (scheme, u->path);\n  split_path (u->path, &u->dir, &u->file);\n\n  host_modified = lowercase_str (u->host);\n\n  /* Decode %HH sequences in host name.  This is important not so much\n     to support %HH sequences in host names (which other browser\n     don't), but to support binary characters (which will have been\n     converted to %HH by reencode_escapes).  */\n  if (strchr (u->host, '%'))\n    {\n      url_unescape (u->host);\n      host_modified = true;\n\n      /* check for invalid control characters in host name */\n      for (p = u->host; *p; p++)\n        {\n          if (c_iscntrl(*p))\n            {\n              url_free(u);\n              error_code = PE_INVALID_HOST_NAME;\n              goto error;\n            }\n        }\n\n      /* Apply IDNA regardless of iri->utf8_encode status */\n      if (opt.enable_iri && iri)\n        {\n          char *new = idn_encode (iri, u->host);\n          if (new)\n            {\n              xfree (u->host);\n              u->host = new;\n              u->idn_allocated = true;\n              host_modified = true;\n            }\n        }\n    }\n\n  if (params_b)\n    u->params = strdupdelim (params_b, params_e);\n  if (query_b)\n    u->query = strdupdelim (query_b, query_e);\n  if (fragment_b)\n    u->fragment = strdupdelim (fragment_b, fragment_e);\n\n  if (opt.enable_iri || path_modified || u->fragment || host_modified || path_b == path_e)\n    {\n      /* If we suspect that a transformation has rendered what\n         url_string might return different from URL_ENCODED, rebuild\n         u->url using url_string.  */\n      u->url = url_string (u, URL_AUTH_SHOW);\n\n      if (url_encoded != url)\n        xfree (url_encoded);\n    }\n  else\n    {\n      if (url_encoded == url)\n        u->url = xstrdup (url);\n      else\n        u->url = (char *) url_encoded;\n    }\n\n  return u;\n\n error:\n  /* Cleanup in case of error: */\n  if (url_encoded && url_encoded != url)\n    xfree (url_encoded);\n\n  /* Transmit the error code to the caller, if the caller wants to\n     know.  */\n  if (error)\n    *error = error_code;\n  return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -226,6 +226,17 @@\n       url_unescape (u->host);\n       host_modified = true;\n \n+      /* check for invalid control characters in host name */\n+      for (p = u->host; *p; p++)\n+        {\n+          if (c_iscntrl(*p))\n+            {\n+              url_free(u);\n+              error_code = PE_INVALID_HOST_NAME;\n+              goto error;\n+            }\n+        }\n+\n       /* Apply IDNA regardless of iri->utf8_encode status */\n       if (opt.enable_iri && iri)\n         {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      /* check for invalid control characters in host name */",
                "      for (p = u->host; *p; p++)",
                "        {",
                "          if (c_iscntrl(*p))",
                "            {",
                "              url_free(u);",
                "              error_code = PE_INVALID_HOST_NAME;",
                "              goto error;",
                "            }",
                "        }",
                ""
            ]
        }
    }
]