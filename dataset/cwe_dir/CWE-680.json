[
    {
        "cve_id": "CVE-2021-32687",
        "func_name": "redis/rdbLoadObject",
        "description": "Redis is an open source, in-memory database that persists on disk. An integer overflow bug affecting all versions of Redis can be exploited to corrupt the heap and potentially be used to leak arbitrary contents of the heap or trigger remote code execution. The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the set-max-intset-entries configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.",
        "git_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
        "commit_title": "Fix Integer overflow issue with intsets (CVE-2021-32687)",
        "commit_text": " The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets",
        "func_before": "robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {\n    robj *o = NULL, *ele, *dec;\n    uint64_t len;\n    unsigned int i;\n\n    if (rdbtype == RDB_TYPE_STRING) {\n        /* Read string value */\n        if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;\n        o = tryObjectEncoding(o);\n    } else if (rdbtype == RDB_TYPE_LIST) {\n        /* Read list value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        /* Load every single element of the list */\n        while(len--) {\n            if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            dec = getDecodedObject(ele);\n            size_t len = sdslen(dec->ptr);\n            quicklistPushTail(o->ptr, dec->ptr, len);\n            decrRefCount(dec);\n            decrRefCount(ele);\n        }\n    } else if (rdbtype == RDB_TYPE_SET) {\n        /* Read Set value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        /* Use a regular set when there are too many entries. */\n        if (len > server.set_max_intset_entries) {\n            o = createSetObject();\n            /* It's faster to expand the dict to the right size asap in order\n             * to avoid rehashing */\n            if (len > DICT_HT_INITIAL_SIZE)\n                dictExpand(o->ptr,len);\n        } else {\n            o = createIntsetObject();\n        }\n\n        /* Load every single element of the set */\n        for (i = 0; i < len; i++) {\n            long long llval;\n            sds sdsele;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (o->encoding == OBJ_ENCODING_INTSET) {\n                /* Fetch integer value from element. */\n                if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {\n                    o->ptr = intsetAdd(o->ptr,llval,NULL);\n                } else {\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                    dictExpand(o->ptr,len);\n                }\n            }\n\n            /* This will also be called when the set was just converted\n             * to a regular hash table encoded set. */\n            if (o->encoding == OBJ_ENCODING_HT) {\n                dictAdd((dict*)o->ptr,sdsele,NULL);\n            } else {\n                sdsfree(sdsele);\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {\n        /* Read list/set value. */\n        uint64_t zsetlen;\n        size_t maxelelen = 0;\n        zset *zs;\n\n        if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createZsetObject();\n        zs = o->ptr;\n\n        if (zsetlen > DICT_HT_INITIAL_SIZE)\n            dictExpand(zs->dict,zsetlen);\n\n        /* Load every single element of the sorted set. */\n        while(zsetlen--) {\n            sds sdsele;\n            double score;\n            zskiplistNode *znode;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (rdbtype == RDB_TYPE_ZSET_2) {\n                if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            } else {\n                if (rdbLoadDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            }\n\n            /* Don't care about integer-encoded strings. */\n            if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);\n\n            znode = zslInsert(zs->zsl,score,sdsele);\n            dictAdd(zs->dict,sdsele,&znode->score);\n        }\n\n        /* Convert *after* loading, since sorted sets are not stored ordered. */\n        if (zsetLength(o) <= server.zset_max_ziplist_entries &&\n            maxelelen <= server.zset_max_ziplist_value)\n                zsetConvert(o,OBJ_ENCODING_ZIPLIST);\n    } else if (rdbtype == RDB_TYPE_HASH) {\n        uint64_t len;\n        int ret;\n        sds field, value;\n\n        len = rdbLoadLen(rdb, NULL);\n        if (len == RDB_LENERR) return NULL;\n\n        o = createHashObject();\n\n        /* Too many entries? Use a hash table. */\n        if (len > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n\n        /* Load every field and value into the ziplist */\n        while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {\n            len--;\n            /* Load raw strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to ziplist */\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)field,\n                    sdslen(field), ZIPLIST_TAIL);\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)value,\n                    sdslen(value), ZIPLIST_TAIL);\n\n            /* Convert to hash table if size threshold is exceeded */\n            if (sdslen(field) > server.hash_max_ziplist_value ||\n                sdslen(value) > server.hash_max_ziplist_value)\n            {\n                sdsfree(field);\n                sdsfree(value);\n                hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            }\n            sdsfree(field);\n            sdsfree(value);\n        }\n\n        if (o->encoding == OBJ_ENCODING_HT && len > DICT_HT_INITIAL_SIZE)\n            dictExpand(o->ptr,len);\n\n        /* Load remaining fields and values into the hash table */\n        while (o->encoding == OBJ_ENCODING_HT && len > 0) {\n            len--;\n            /* Load encoded strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to hash table */\n            ret = dictAdd((dict*)o->ptr, field, value);\n            if (ret == DICT_ERR) {\n                rdbExitReportCorruptRDB(\"Duplicate keys detected\");\n            }\n        }\n\n        /* All pairs should be read by now */\n        serverAssert(len == 0);\n    } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        while (len--) {\n            unsigned char *zl =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (zl == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            quicklistAppendZiplist(o->ptr, zl);\n        }\n    } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||\n               rdbtype == RDB_TYPE_LIST_ZIPLIST ||\n               rdbtype == RDB_TYPE_SET_INTSET   ||\n               rdbtype == RDB_TYPE_ZSET_ZIPLIST ||\n               rdbtype == RDB_TYPE_HASH_ZIPLIST)\n    {\n        unsigned char *encoded =\n            rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n        if (encoded == NULL) return NULL;\n        o = createObject(OBJ_STRING,encoded); /* Obj type fixed below. */\n\n        /* Fix the object encoding, and make sure to convert the encoded\n         * data type into the base type if accordingly to the current\n         * configuration there are too many elements in the encoded data\n         * type. Note that we only check the length and not max element\n         * size as this is an O(N) scan. Eventually everything will get\n         * converted. */\n        switch(rdbtype) {\n            case RDB_TYPE_HASH_ZIPMAP:\n                /* Convert to ziplist encoded hash. This must be deprecated\n                 * when loading dumps created by Redis 2.4 gets deprecated. */\n                {\n                    unsigned char *zl = ziplistNew();\n                    unsigned char *zi = zipmapRewind(o->ptr);\n                    unsigned char *fstr, *vstr;\n                    unsigned int flen, vlen;\n                    unsigned int maxlen = 0;\n\n                    while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {\n                        if (flen > maxlen) maxlen = flen;\n                        if (vlen > maxlen) maxlen = vlen;\n                        zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);\n                        zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);\n                    }\n\n                    zfree(o->ptr);\n                    o->ptr = zl;\n                    o->type = OBJ_HASH;\n                    o->encoding = OBJ_ENCODING_ZIPLIST;\n\n                    if (hashTypeLength(o) > server.hash_max_ziplist_entries ||\n                        maxlen > server.hash_max_ziplist_value)\n                    {\n                        hashTypeConvert(o, OBJ_ENCODING_HT);\n                    }\n                }\n                break;\n            case RDB_TYPE_LIST_ZIPLIST:\n                o->type = OBJ_LIST;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                listTypeConvert(o,OBJ_ENCODING_QUICKLIST);\n                break;\n            case RDB_TYPE_SET_INTSET:\n                o->type = OBJ_SET;\n                o->encoding = OBJ_ENCODING_INTSET;\n                if (intsetLen(o->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                break;\n            case RDB_TYPE_ZSET_ZIPLIST:\n                o->type = OBJ_ZSET;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (zsetLength(o) > server.zset_max_ziplist_entries)\n                    zsetConvert(o,OBJ_ENCODING_SKIPLIST);\n                break;\n            case RDB_TYPE_HASH_ZIPLIST:\n                o->type = OBJ_HASH;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n                    hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            default:\n                /* totally unreachable */\n                rdbExitReportCorruptRDB(\"Unknown RDB encoding type %d\",rdbtype);\n                break;\n        }\n    } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {\n        o = createStreamObject();\n        stream *s = o->ptr;\n        uint64_t listpacks = rdbLoadLen(rdb,NULL);\n        if (listpacks == RDB_LENERR) {\n            rdbReportReadError(\"Stream listpacks len loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        while(listpacks--) {\n            /* Get the master ID, the one we'll use as key of the radix tree\n             * node: the entries inside the listpack itself are delta-encoded\n             * relatively to this ID. */\n            sds nodekey = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (nodekey == NULL) {\n                rdbReportReadError(\"Stream master ID loading failed: invalid encoding or I/O error.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            if (sdslen(nodekey) != sizeof(streamID)) {\n                rdbExitReportCorruptRDB(\"Stream node key entry is not the \"\n                                        \"size of a stream ID\");\n            }\n\n            /* Load the listpack. */\n            unsigned char *lp =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (lp == NULL) {\n                rdbReportReadError(\"Stream listpacks loading failed.\");\n                sdsfree(nodekey);\n                decrRefCount(o);\n                return NULL;\n            }\n            unsigned char *first = lpFirst(lp);\n            if (first == NULL) {\n                /* Serialized listpacks should never be empty, since on\n                 * deletion we should remove the radix tree key if the\n                 * resulting listpack is empty. */\n                rdbExitReportCorruptRDB(\"Empty listpack inside stream\");\n            }\n\n            /* Insert the key in the radix tree. */\n            int retval = raxInsert(s->rax,\n                (unsigned char*)nodekey,sizeof(streamID),lp,NULL);\n            sdsfree(nodekey);\n            if (!retval)\n                rdbExitReportCorruptRDB(\"Listpack re-added with existing key\");\n        }\n        /* Load total number of items inside the stream. */\n        s->length = rdbLoadLen(rdb,NULL);\n\n        /* Load the last entry ID. */\n        s->last_id.ms = rdbLoadLen(rdb,NULL);\n        s->last_id.seq = rdbLoadLen(rdb,NULL);\n\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Stream object metadata loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        /* Consumer groups loading */\n        uint64_t cgroups_count = rdbLoadLen(rdb,NULL);\n        if (cgroups_count == RDB_LENERR) {\n            rdbReportReadError(\"Stream cgroup count loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n        while(cgroups_count--) {\n            /* Get the consumer group name and ID. We can then create the\n             * consumer group ASAP and populate its structure as\n             * we read more data. */\n            streamID cg_id;\n            sds cgname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (cgname == NULL) {\n                rdbReportReadError(\n                    \"Error reading the consumer group name from Stream\");\n                decrRefCount(o);\n                return NULL;\n            }\n\n            cg_id.ms = rdbLoadLen(rdb,NULL);\n            cg_id.seq = rdbLoadLen(rdb,NULL);\n            if (rioGetReadError(rdb)) {\n                rdbReportReadError(\"Stream cgroup ID loading failed.\");\n                sdsfree(cgname);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);\n            if (cgroup == NULL)\n                rdbExitReportCorruptRDB(\"Duplicated consumer group name %s\",\n                                         cgname);\n            sdsfree(cgname);\n\n            /* Load the global PEL for this consumer group, however we'll\n             * not yet populate the NACK structures with the message\n             * owner, since consumers for this group and their messages will\n             * be read as a next step. So for now leave them not resolved\n             * and later populate it. */\n            uint64_t pel_size = rdbLoadLen(rdb,NULL);\n            if (pel_size == RDB_LENERR) {\n                rdbReportReadError(\"Stream PEL size loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(pel_size--) {\n                unsigned char rawid[sizeof(streamID)];\n                if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                    rdbReportReadError(\"Stream PEL ID loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamNACK *nack = streamCreateNACK(NULL);\n                nack->delivery_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                nack->delivery_count = rdbLoadLen(rdb,NULL);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream PEL NACK loading failed.\");\n                    decrRefCount(o);\n                    streamFreeNACK(nack);\n                    return NULL;\n                }\n                if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))\n                    rdbExitReportCorruptRDB(\"Duplicated gobal PEL entry \"\n                                            \"loading stream consumer group\");\n            }\n\n            /* Now that we loaded our global PEL, we need to load the\n             * consumers and their local PELs. */\n            uint64_t consumers_num = rdbLoadLen(rdb,NULL);\n            if (consumers_num == RDB_LENERR) {\n                rdbReportReadError(\"Stream consumers num loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(consumers_num--) {\n                sds cname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n                if (cname == NULL) {\n                    rdbReportReadError(\n                        \"Error reading the consumer name from Stream group.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamConsumer *consumer =\n                    streamLookupConsumer(cgroup,cname,SLC_NONE);\n                sdsfree(cname);\n                consumer->seen_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream short read reading seen time.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n\n                /* Load the PEL about entries owned by this specific\n                 * consumer. */\n                pel_size = rdbLoadLen(rdb,NULL);\n                if (pel_size == RDB_LENERR) {\n                    rdbReportReadError(\n                        \"Stream consumer PEL num loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                while(pel_size--) {\n                    unsigned char rawid[sizeof(streamID)];\n                    if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                        rdbReportReadError(\n                            \"Stream short read reading PEL streamID.\");\n                        decrRefCount(o);\n                        return NULL;\n                    }\n                    streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));\n                    if (nack == raxNotFound)\n                        rdbExitReportCorruptRDB(\"Consumer entry not found in \"\n                                                \"group global PEL\");\n\n                    /* Set the NACK consumer, that was left to NULL when\n                     * loading the global PEL. Then set the same shared\n                     * NACK structure also in the consumer-specific PEL. */\n                    nack->consumer = consumer;\n                    if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))\n                        rdbExitReportCorruptRDB(\"Duplicated consumer PEL entry \"\n                                                \" loading a stream consumer \"\n                                                \"group\");\n                }\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {\n        uint64_t moduleid = rdbLoadLen(rdb,NULL);\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Short read module id\");\n            return NULL;\n        }\n        moduleType *mt = moduleTypeLookupModuleByID(moduleid);\n        char name[10];\n\n        if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2) {\n            moduleTypeNameByID(name,moduleid);\n            return rdbLoadCheckModuleValue(rdb,name);\n        }\n\n        if (mt == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data I can't load: no matching module '%s'\", name);\n            exit(1);\n        }\n        RedisModuleIO io;\n        robj keyobj;\n        initStaticStringObject(keyobj,key);\n        moduleInitIOContext(io,mt,rdb,&keyobj);\n        io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;\n        /* Call the rdb_load method of the module providing the 10 bit\n         * encoding version in the lower 10 bits of the module ID. */\n        void *ptr = mt->rdb_load(&io,moduleid&1023);\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n\n        /* Module v2 serialization has an EOF mark at the end. */\n        if (io.ver == 2) {\n            uint64_t eof = rdbLoadLen(rdb,NULL);\n            if (eof == RDB_LENERR) {\n                o = createModuleObject(mt,ptr); /* creating just in order to easily destroy */\n                decrRefCount(o);\n                return NULL;\n            }\n            if (eof != RDB_MODULE_OPCODE_EOF) {\n                serverLog(LL_WARNING,\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                exit(1);\n            }\n        }\n\n        if (ptr == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n            exit(1);\n        }\n        o = createModuleObject(mt,ptr);\n    } else {\n        rdbReportReadError(\"Unknown RDB encoding type %d\",rdbtype);\n        return NULL;\n    }\n    return o;\n}",
        "func": "robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {\n    robj *o = NULL, *ele, *dec;\n    uint64_t len;\n    unsigned int i;\n\n    if (rdbtype == RDB_TYPE_STRING) {\n        /* Read string value */\n        if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;\n        o = tryObjectEncoding(o);\n    } else if (rdbtype == RDB_TYPE_LIST) {\n        /* Read list value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        /* Load every single element of the list */\n        while(len--) {\n            if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            dec = getDecodedObject(ele);\n            size_t len = sdslen(dec->ptr);\n            quicklistPushTail(o->ptr, dec->ptr, len);\n            decrRefCount(dec);\n            decrRefCount(ele);\n        }\n    } else if (rdbtype == RDB_TYPE_SET) {\n        /* Read Set value */\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n\n        /* Use a regular set when there are too many entries. */\n        size_t max_entries = server.set_max_intset_entries;\n        if (max_entries >= 1<<30) max_entries = 1<<30;\n        if (len > max_entries) {\n            o = createSetObject();\n            /* It's faster to expand the dict to the right size asap in order\n             * to avoid rehashing */\n            if (len > DICT_HT_INITIAL_SIZE)\n                dictExpand(o->ptr,len);\n        } else {\n            o = createIntsetObject();\n        }\n\n        /* Load every single element of the set */\n        for (i = 0; i < len; i++) {\n            long long llval;\n            sds sdsele;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (o->encoding == OBJ_ENCODING_INTSET) {\n                /* Fetch integer value from element. */\n                if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {\n                    o->ptr = intsetAdd(o->ptr,llval,NULL);\n                } else {\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                    dictExpand(o->ptr,len);\n                }\n            }\n\n            /* This will also be called when the set was just converted\n             * to a regular hash table encoded set. */\n            if (o->encoding == OBJ_ENCODING_HT) {\n                dictAdd((dict*)o->ptr,sdsele,NULL);\n            } else {\n                sdsfree(sdsele);\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {\n        /* Read list/set value. */\n        uint64_t zsetlen;\n        size_t maxelelen = 0;\n        zset *zs;\n\n        if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createZsetObject();\n        zs = o->ptr;\n\n        if (zsetlen > DICT_HT_INITIAL_SIZE)\n            dictExpand(zs->dict,zsetlen);\n\n        /* Load every single element of the sorted set. */\n        while(zsetlen--) {\n            sds sdsele;\n            double score;\n            zskiplistNode *znode;\n\n            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n\n            if (rdbtype == RDB_TYPE_ZSET_2) {\n                if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            } else {\n                if (rdbLoadDoubleValue(rdb,&score) == -1) {\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                    return NULL;\n                }\n            }\n\n            /* Don't care about integer-encoded strings. */\n            if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);\n\n            znode = zslInsert(zs->zsl,score,sdsele);\n            dictAdd(zs->dict,sdsele,&znode->score);\n        }\n\n        /* Convert *after* loading, since sorted sets are not stored ordered. */\n        if (zsetLength(o) <= server.zset_max_ziplist_entries &&\n            maxelelen <= server.zset_max_ziplist_value)\n                zsetConvert(o,OBJ_ENCODING_ZIPLIST);\n    } else if (rdbtype == RDB_TYPE_HASH) {\n        uint64_t len;\n        int ret;\n        sds field, value;\n\n        len = rdbLoadLen(rdb, NULL);\n        if (len == RDB_LENERR) return NULL;\n\n        o = createHashObject();\n\n        /* Too many entries? Use a hash table. */\n        if (len > server.hash_max_ziplist_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n\n        /* Load every field and value into the ziplist */\n        while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {\n            len--;\n            /* Load raw strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to ziplist */\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)field,\n                    sdslen(field), ZIPLIST_TAIL);\n            o->ptr = ziplistPush(o->ptr, (unsigned char*)value,\n                    sdslen(value), ZIPLIST_TAIL);\n\n            /* Convert to hash table if size threshold is exceeded */\n            if (sdslen(field) > server.hash_max_ziplist_value ||\n                sdslen(value) > server.hash_max_ziplist_value)\n            {\n                sdsfree(field);\n                sdsfree(value);\n                hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            }\n            sdsfree(field);\n            sdsfree(value);\n        }\n\n        if (o->encoding == OBJ_ENCODING_HT && len > DICT_HT_INITIAL_SIZE)\n            dictExpand(o->ptr,len);\n\n        /* Load remaining fields and values into the hash table */\n        while (o->encoding == OBJ_ENCODING_HT && len > 0) {\n            len--;\n            /* Load encoded strings */\n            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL)) == NULL) {\n                sdsfree(field);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            /* Add pair to hash table */\n            ret = dictAdd((dict*)o->ptr, field, value);\n            if (ret == DICT_ERR) {\n                rdbExitReportCorruptRDB(\"Duplicate keys detected\");\n            }\n        }\n\n        /* All pairs should be read by now */\n        serverAssert(len == 0);\n    } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {\n        if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n\n        while (len--) {\n            unsigned char *zl =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (zl == NULL) {\n                decrRefCount(o);\n                return NULL;\n            }\n            quicklistAppendZiplist(o->ptr, zl);\n        }\n    } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||\n               rdbtype == RDB_TYPE_LIST_ZIPLIST ||\n               rdbtype == RDB_TYPE_SET_INTSET   ||\n               rdbtype == RDB_TYPE_ZSET_ZIPLIST ||\n               rdbtype == RDB_TYPE_HASH_ZIPLIST)\n    {\n        unsigned char *encoded =\n            rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n        if (encoded == NULL) return NULL;\n        o = createObject(OBJ_STRING,encoded); /* Obj type fixed below. */\n\n        /* Fix the object encoding, and make sure to convert the encoded\n         * data type into the base type if accordingly to the current\n         * configuration there are too many elements in the encoded data\n         * type. Note that we only check the length and not max element\n         * size as this is an O(N) scan. Eventually everything will get\n         * converted. */\n        switch(rdbtype) {\n            case RDB_TYPE_HASH_ZIPMAP:\n                /* Convert to ziplist encoded hash. This must be deprecated\n                 * when loading dumps created by Redis 2.4 gets deprecated. */\n                {\n                    unsigned char *zl = ziplistNew();\n                    unsigned char *zi = zipmapRewind(o->ptr);\n                    unsigned char *fstr, *vstr;\n                    unsigned int flen, vlen;\n                    unsigned int maxlen = 0;\n\n                    while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {\n                        if (flen > maxlen) maxlen = flen;\n                        if (vlen > maxlen) maxlen = vlen;\n                        zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);\n                        zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);\n                    }\n\n                    zfree(o->ptr);\n                    o->ptr = zl;\n                    o->type = OBJ_HASH;\n                    o->encoding = OBJ_ENCODING_ZIPLIST;\n\n                    if (hashTypeLength(o) > server.hash_max_ziplist_entries ||\n                        maxlen > server.hash_max_ziplist_value)\n                    {\n                        hashTypeConvert(o, OBJ_ENCODING_HT);\n                    }\n                }\n                break;\n            case RDB_TYPE_LIST_ZIPLIST:\n                o->type = OBJ_LIST;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                listTypeConvert(o,OBJ_ENCODING_QUICKLIST);\n                break;\n            case RDB_TYPE_SET_INTSET:\n                o->type = OBJ_SET;\n                o->encoding = OBJ_ENCODING_INTSET;\n                if (intsetLen(o->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(o,OBJ_ENCODING_HT);\n                break;\n            case RDB_TYPE_ZSET_ZIPLIST:\n                o->type = OBJ_ZSET;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (zsetLength(o) > server.zset_max_ziplist_entries)\n                    zsetConvert(o,OBJ_ENCODING_SKIPLIST);\n                break;\n            case RDB_TYPE_HASH_ZIPLIST:\n                o->type = OBJ_HASH;\n                o->encoding = OBJ_ENCODING_ZIPLIST;\n                if (hashTypeLength(o) > server.hash_max_ziplist_entries)\n                    hashTypeConvert(o, OBJ_ENCODING_HT);\n                break;\n            default:\n                /* totally unreachable */\n                rdbExitReportCorruptRDB(\"Unknown RDB encoding type %d\",rdbtype);\n                break;\n        }\n    } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {\n        o = createStreamObject();\n        stream *s = o->ptr;\n        uint64_t listpacks = rdbLoadLen(rdb,NULL);\n        if (listpacks == RDB_LENERR) {\n            rdbReportReadError(\"Stream listpacks len loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        while(listpacks--) {\n            /* Get the master ID, the one we'll use as key of the radix tree\n             * node: the entries inside the listpack itself are delta-encoded\n             * relatively to this ID. */\n            sds nodekey = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (nodekey == NULL) {\n                rdbReportReadError(\"Stream master ID loading failed: invalid encoding or I/O error.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            if (sdslen(nodekey) != sizeof(streamID)) {\n                rdbExitReportCorruptRDB(\"Stream node key entry is not the \"\n                                        \"size of a stream ID\");\n            }\n\n            /* Load the listpack. */\n            unsigned char *lp =\n                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);\n            if (lp == NULL) {\n                rdbReportReadError(\"Stream listpacks loading failed.\");\n                sdsfree(nodekey);\n                decrRefCount(o);\n                return NULL;\n            }\n            unsigned char *first = lpFirst(lp);\n            if (first == NULL) {\n                /* Serialized listpacks should never be empty, since on\n                 * deletion we should remove the radix tree key if the\n                 * resulting listpack is empty. */\n                rdbExitReportCorruptRDB(\"Empty listpack inside stream\");\n            }\n\n            /* Insert the key in the radix tree. */\n            int retval = raxInsert(s->rax,\n                (unsigned char*)nodekey,sizeof(streamID),lp,NULL);\n            sdsfree(nodekey);\n            if (!retval)\n                rdbExitReportCorruptRDB(\"Listpack re-added with existing key\");\n        }\n        /* Load total number of items inside the stream. */\n        s->length = rdbLoadLen(rdb,NULL);\n\n        /* Load the last entry ID. */\n        s->last_id.ms = rdbLoadLen(rdb,NULL);\n        s->last_id.seq = rdbLoadLen(rdb,NULL);\n\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Stream object metadata loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n\n        /* Consumer groups loading */\n        uint64_t cgroups_count = rdbLoadLen(rdb,NULL);\n        if (cgroups_count == RDB_LENERR) {\n            rdbReportReadError(\"Stream cgroup count loading failed.\");\n            decrRefCount(o);\n            return NULL;\n        }\n        while(cgroups_count--) {\n            /* Get the consumer group name and ID. We can then create the\n             * consumer group ASAP and populate its structure as\n             * we read more data. */\n            streamID cg_id;\n            sds cgname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n            if (cgname == NULL) {\n                rdbReportReadError(\n                    \"Error reading the consumer group name from Stream\");\n                decrRefCount(o);\n                return NULL;\n            }\n\n            cg_id.ms = rdbLoadLen(rdb,NULL);\n            cg_id.seq = rdbLoadLen(rdb,NULL);\n            if (rioGetReadError(rdb)) {\n                rdbReportReadError(\"Stream cgroup ID loading failed.\");\n                sdsfree(cgname);\n                decrRefCount(o);\n                return NULL;\n            }\n\n            streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);\n            if (cgroup == NULL)\n                rdbExitReportCorruptRDB(\"Duplicated consumer group name %s\",\n                                         cgname);\n            sdsfree(cgname);\n\n            /* Load the global PEL for this consumer group, however we'll\n             * not yet populate the NACK structures with the message\n             * owner, since consumers for this group and their messages will\n             * be read as a next step. So for now leave them not resolved\n             * and later populate it. */\n            uint64_t pel_size = rdbLoadLen(rdb,NULL);\n            if (pel_size == RDB_LENERR) {\n                rdbReportReadError(\"Stream PEL size loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(pel_size--) {\n                unsigned char rawid[sizeof(streamID)];\n                if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                    rdbReportReadError(\"Stream PEL ID loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamNACK *nack = streamCreateNACK(NULL);\n                nack->delivery_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                nack->delivery_count = rdbLoadLen(rdb,NULL);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream PEL NACK loading failed.\");\n                    decrRefCount(o);\n                    streamFreeNACK(nack);\n                    return NULL;\n                }\n                if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))\n                    rdbExitReportCorruptRDB(\"Duplicated gobal PEL entry \"\n                                            \"loading stream consumer group\");\n            }\n\n            /* Now that we loaded our global PEL, we need to load the\n             * consumers and their local PELs. */\n            uint64_t consumers_num = rdbLoadLen(rdb,NULL);\n            if (consumers_num == RDB_LENERR) {\n                rdbReportReadError(\"Stream consumers num loading failed.\");\n                decrRefCount(o);\n                return NULL;\n            }\n            while(consumers_num--) {\n                sds cname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);\n                if (cname == NULL) {\n                    rdbReportReadError(\n                        \"Error reading the consumer name from Stream group.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                streamConsumer *consumer =\n                    streamLookupConsumer(cgroup,cname,SLC_NONE);\n                sdsfree(cname);\n                consumer->seen_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);\n                if (rioGetReadError(rdb)) {\n                    rdbReportReadError(\"Stream short read reading seen time.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n\n                /* Load the PEL about entries owned by this specific\n                 * consumer. */\n                pel_size = rdbLoadLen(rdb,NULL);\n                if (pel_size == RDB_LENERR) {\n                    rdbReportReadError(\n                        \"Stream consumer PEL num loading failed.\");\n                    decrRefCount(o);\n                    return NULL;\n                }\n                while(pel_size--) {\n                    unsigned char rawid[sizeof(streamID)];\n                    if (rioRead(rdb,rawid,sizeof(rawid)) == 0) {\n                        rdbReportReadError(\n                            \"Stream short read reading PEL streamID.\");\n                        decrRefCount(o);\n                        return NULL;\n                    }\n                    streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));\n                    if (nack == raxNotFound)\n                        rdbExitReportCorruptRDB(\"Consumer entry not found in \"\n                                                \"group global PEL\");\n\n                    /* Set the NACK consumer, that was left to NULL when\n                     * loading the global PEL. Then set the same shared\n                     * NACK structure also in the consumer-specific PEL. */\n                    nack->consumer = consumer;\n                    if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))\n                        rdbExitReportCorruptRDB(\"Duplicated consumer PEL entry \"\n                                                \" loading a stream consumer \"\n                                                \"group\");\n                }\n            }\n        }\n    } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {\n        uint64_t moduleid = rdbLoadLen(rdb,NULL);\n        if (rioGetReadError(rdb)) {\n            rdbReportReadError(\"Short read module id\");\n            return NULL;\n        }\n        moduleType *mt = moduleTypeLookupModuleByID(moduleid);\n        char name[10];\n\n        if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2) {\n            moduleTypeNameByID(name,moduleid);\n            return rdbLoadCheckModuleValue(rdb,name);\n        }\n\n        if (mt == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data I can't load: no matching module '%s'\", name);\n            exit(1);\n        }\n        RedisModuleIO io;\n        robj keyobj;\n        initStaticStringObject(keyobj,key);\n        moduleInitIOContext(io,mt,rdb,&keyobj);\n        io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;\n        /* Call the rdb_load method of the module providing the 10 bit\n         * encoding version in the lower 10 bits of the module ID. */\n        void *ptr = mt->rdb_load(&io,moduleid&1023);\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n\n        /* Module v2 serialization has an EOF mark at the end. */\n        if (io.ver == 2) {\n            uint64_t eof = rdbLoadLen(rdb,NULL);\n            if (eof == RDB_LENERR) {\n                o = createModuleObject(mt,ptr); /* creating just in order to easily destroy */\n                decrRefCount(o);\n                return NULL;\n            }\n            if (eof != RDB_MODULE_OPCODE_EOF) {\n                serverLog(LL_WARNING,\"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                exit(1);\n            }\n        }\n\n        if (ptr == NULL) {\n            moduleTypeNameByID(name,moduleid);\n            serverLog(LL_WARNING,\"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n            exit(1);\n        }\n        o = createModuleObject(mt,ptr);\n    } else {\n        rdbReportReadError(\"Unknown RDB encoding type %d\",rdbtype);\n        return NULL;\n    }\n    return o;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,9 @@\n         if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;\n \n         /* Use a regular set when there are too many entries. */\n-        if (len > server.set_max_intset_entries) {\n+        size_t max_entries = server.set_max_intset_entries;\n+        if (max_entries >= 1<<30) max_entries = 1<<30;\n+        if (len > max_entries) {\n             o = createSetObject();\n             /* It's faster to expand the dict to the right size asap in order\n              * to avoid rehashing */",
        "diff_line_info": {
            "deleted_lines": [
                "        if (len > server.set_max_intset_entries) {"
            ],
            "added_lines": [
                "        size_t max_entries = server.set_max_intset_entries;",
                "        if (max_entries >= 1<<30) max_entries = 1<<30;",
                "        if (len > max_entries) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32687",
        "func_name": "redis/setTypeAdd",
        "description": "Redis is an open source, in-memory database that persists on disk. An integer overflow bug affecting all versions of Redis can be exploited to corrupt the heap and potentially be used to leak arbitrary contents of the heap or trigger remote code execution. The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the set-max-intset-entries configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.",
        "git_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
        "commit_title": "Fix Integer overflow issue with intsets (CVE-2021-32687)",
        "commit_text": " The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets",
        "func_before": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}",
        "func": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                size_t max_entries = server.set_max_intset_entries;\n                /* limit to 1G entries due to intset internals. */\n                if (max_entries >= 1<<30) max_entries = 1<<30;\n                if (intsetLen(subject->ptr) > max_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,10 @@\n             if (success) {\n                 /* Convert to regular set when the intset contains\n                  * too many entries. */\n-                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n+                size_t max_entries = server.set_max_intset_entries;\n+                /* limit to 1G entries due to intset internals. */\n+                if (max_entries >= 1<<30) max_entries = 1<<30;\n+                if (intsetLen(subject->ptr) > max_entries)\n                     setTypeConvert(subject,OBJ_ENCODING_HT);\n                 return 1;\n             }",
        "diff_line_info": {
            "deleted_lines": [
                "                if (intsetLen(subject->ptr) > server.set_max_intset_entries)"
            ],
            "added_lines": [
                "                size_t max_entries = server.set_max_intset_entries;",
                "                /* limit to 1G entries due to intset internals. */",
                "                if (max_entries >= 1<<30) max_entries = 1<<30;",
                "                if (intsetLen(subject->ptr) > max_entries)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32687",
        "func_name": "redis/intsetResize",
        "description": "Redis is an open source, in-memory database that persists on disk. An integer overflow bug affecting all versions of Redis can be exploited to corrupt the heap and potentially be used to leak arbitrary contents of the heap or trigger remote code execution. The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the set-max-intset-entries configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.",
        "git_url": "https://github.com/redis/redis/commit/a30d367a71b7017581cf1ca104242a3c644dec0f",
        "commit_title": "Fix Integer overflow issue with intsets (CVE-2021-32687)",
        "commit_text": " The vulnerability involves changing the default set-max-intset-entries configuration parameter to a very large value and constructing specially crafted commands to manipulate sets",
        "func_before": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}",
        "func": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);\n    assert(size <= SIZE_MAX - sizeof(intset));\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static intset *intsetResize(intset *is, uint32_t len) {\n-    uint32_t size = len*intrev32ifbe(is->encoding);\n+    uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);\n+    assert(size <= SIZE_MAX - sizeof(intset));\n     is = zrealloc(is,sizeof(intset)+size);\n     return is;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    uint32_t size = len*intrev32ifbe(is->encoding);"
            ],
            "added_lines": [
                "    uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);",
                "    assert(size <= SIZE_MAX - sizeof(intset));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32762",
        "func_name": "redis/createArrayObject",
        "description": "Redis is an open source, in-memory database that persists on disk. The redis-cli command line tool and redis-sentinel service may be vulnerable to integer overflow when parsing specially crafted large multi-bulk network replies. This is a result of a vulnerability in the underlying hiredis library which does not perform an overflow check before calling the calloc() heap allocation function. This issue only impacts systems with heap allocators that do not perform their own overflow checks. Most modern systems do and are therefore not likely to be affected. Furthermore, by default redis-sentinel uses the jemalloc allocator which is also not vulnerable. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14.",
        "git_url": "https://github.com/redis/redis/commit/0215324a66af949be39b34be2d55143232c1cb71",
        "commit_title": "Fix redis-cli / redis-sential overflow on some platforms (CVE-2021-32762) (#9587)",
        "commit_text": " The redis-cli command line tool and redis-sentinel service may be vulnerable\r to integer overflow when parsing specially crafted large multi-bulk network\r replies. This is a result of a vulnerability in the underlying hiredis\r library which does not perform an overflow check before calling the calloc()\r heap allocation function.\r \r This issue only impacts systems with heap allocators that do not perform their\r own overflow checks. Most modern systems do and are therefore not likely to\r be affected. Furthermore, by default redis-sentinel uses the jemalloc allocator\r which is also not vulnerable.\r \r Co-authored-by: Yossi Gottlieb <yossigo@gmail.com>",
        "func_before": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}",
        "func": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n         return NULL;\n \n     if (elements > 0) {\n+        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */\n         r->element = hi_calloc(elements,sizeof(redisReply*));\n         if (r->element == NULL) {\n             freeReplyObject(r);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  /* Don't overflow */"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41099",
        "func_name": "redis/sdsMakeRoomFor",
        "description": "Redis is an open source, in-memory database that persists on disk. An integer overflow bug in the underlying string library can be used to corrupt the heap and potentially result with denial of service or remote code execution. The vulnerability involves changing the default proto-max-bulk-len configuration parameter to a very large value and constructing specially crafted network payloads or commands. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the proto-max-bulk-len configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.",
        "git_url": "https://github.com/redis/redis/commit/c6ad876774f3cc11e32681ea02a2eead00f2c521",
        "commit_title": "Fix integer overflow in _sdsMakeRoomFor (CVE-2021-41099)",
        "commit_text": "",
        "func_before": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    newlen = (len+addlen);\n    assert(newlen > len);   /* Catch size_t overflow */\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}",
        "func": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen, reqlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    reqlen = newlen = (len+addlen);\n    assert(newlen > len);   /* Catch size_t overflow */\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n sds sdsMakeRoomFor(sds s, size_t addlen) {\n     void *sh, *newsh;\n     size_t avail = sdsavail(s);\n-    size_t len, newlen;\n+    size_t len, newlen, reqlen;\n     char type, oldtype = s[-1] & SDS_TYPE_MASK;\n     int hdrlen;\n \n@@ -10,7 +10,7 @@\n \n     len = sdslen(s);\n     sh = (char*)s-sdsHdrSize(oldtype);\n-    newlen = (len+addlen);\n+    reqlen = newlen = (len+addlen);\n     assert(newlen > len);   /* Catch size_t overflow */\n     if (newlen < SDS_MAX_PREALLOC)\n         newlen *= 2;\n@@ -25,7 +25,7 @@\n     if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n \n     hdrlen = sdsHdrSize(type);\n-    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */\n+    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */\n     if (oldtype==type) {\n         newsh = s_realloc(sh, hdrlen+newlen+1);\n         if (newsh == NULL) return NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "    size_t len, newlen;",
                "    newlen = (len+addlen);",
                "    assert(hdrlen + newlen + 1 > len);  /* Catch size_t overflow */"
            ],
            "added_lines": [
                "    size_t len, newlen, reqlen;",
                "    reqlen = newlen = (len+addlen);",
                "    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */"
            ]
        }
    }
]