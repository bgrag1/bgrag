[
    {
        "cve_id": "CVE-2021-42073",
        "func_name": "debauchee/barrier/Client::connect",
        "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
        "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
        "commit_title": "Implement client identity verification",
        "commit_text": " This commit fixes two security vulnerabilities: CVE-2021-42072 and CVE-2021-42073.  The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
        "func_before": "void\nClient::connect()\n{\n    if (m_stream != NULL) {\n        return;\n    }\n    if (m_suspended) {\n        m_connectOnResume = true;\n        return;\n    }\n\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (m_useSecureNetwork) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n    }\n\n    try {\n        // resolve the server hostname.  do this every time we connect\n        // in case we couldn't resolve the address earlier or the address\n        // has changed (which can happen frequently if this is a laptop\n        // being shuttled between various networks).  patch by Brent\n        // Priddy.\n        m_serverAddress.resolve();\n\n        // m_serverAddress will be null if the hostname address is not reolved\n        if (m_serverAddress.getAddress() != NULL) {\n          // to help users troubleshoot, show server host name (issue: 60)\n          LOG((CLOG_NOTE \"connecting to '%s': %s:%i\",\n          m_serverAddress.getHostname().c_str(),\n          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),\n          m_serverAddress.getPort()));\n        }\n\n        // create the socket\n        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),\n                                                      security_level);\n        m_socket = dynamic_cast<TCPSocket*>(socket);\n\n        // filter socket messages, including a packetizing filter\n        m_stream = socket;\n        m_stream = new PacketStreamFilter(m_events, m_stream, true);\n\n        // connect\n        LOG((CLOG_DEBUG1 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        socket->connect(m_serverAddress);\n    }\n    catch (XBase& e) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((CLOG_DEBUG1 \"connection failed\"));\n        sendConnectionFailedEvent(e.what());\n        return;\n    }\n}",
        "func": "void\nClient::connect()\n{\n    if (m_stream != NULL) {\n        return;\n    }\n    if (m_suspended) {\n        m_connectOnResume = true;\n        return;\n    }\n\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (m_useSecureNetwork) {\n        // client always authenticates server\n        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n    }\n\n    try {\n        // resolve the server hostname.  do this every time we connect\n        // in case we couldn't resolve the address earlier or the address\n        // has changed (which can happen frequently if this is a laptop\n        // being shuttled between various networks).  patch by Brent\n        // Priddy.\n        m_serverAddress.resolve();\n\n        // m_serverAddress will be null if the hostname address is not reolved\n        if (m_serverAddress.getAddress() != NULL) {\n          // to help users troubleshoot, show server host name (issue: 60)\n          LOG((CLOG_NOTE \"connecting to '%s': %s:%i\",\n          m_serverAddress.getHostname().c_str(),\n          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),\n          m_serverAddress.getPort()));\n        }\n\n        // create the socket\n        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),\n                                                      security_level);\n        m_socket = dynamic_cast<TCPSocket*>(socket);\n\n        // filter socket messages, including a packetizing filter\n        m_stream = socket;\n        m_stream = new PacketStreamFilter(m_events, m_stream, true);\n\n        // connect\n        LOG((CLOG_DEBUG1 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        socket->connect(m_serverAddress);\n    }\n    catch (XBase& e) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((CLOG_DEBUG1 \"connection failed\"));\n        sendConnectionFailedEvent(e.what());\n        return;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,8 @@\n \n     auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n     if (m_useSecureNetwork) {\n-        security_level = ConnectionSecurityLevel::ENCRYPTED;\n+        // client always authenticates server\n+        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n     }\n \n     try {",
        "diff_line_info": {
            "deleted_lines": [
                "        security_level = ConnectionSecurityLevel::ENCRYPTED;"
            ],
            "added_lines": [
                "        // client always authenticates server",
                "        security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42073",
        "func_name": "debauchee/barrier/MainWindow::serverArgs",
        "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
        "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
        "commit_title": "Implement client identity verification",
        "commit_text": " This commit fixes two security vulnerabilities: CVE-2021-42072 and CVE-2021-42073.  The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
        "func_before": "bool MainWindow::serverArgs(QStringList& args, QString& app)\n{\n    app = appPath(appConfig().barriersName());\n\n    if (!QFile::exists(app))\n    {\n        QMessageBox::warning(this, tr(\"Barrier server not found\"),\n                             tr(\"The executable for the barrier server does not exist.\"));\n        return false;\n    }\n\n#if defined(Q_OS_WIN)\n    // wrap in quotes so a malicious user can't start \\Program.exe as admin.\n    app = QString(\"\\\"%1\\\"\").arg(app);\n#endif\n\n    if (appConfig().logToFile())\n    {\n        appConfig().persistLogDir();\n\n        args << \"--log\" << appConfig().logFilenameCmd();\n    }\n\n    QString configFilename = this->configFilename();\n#if defined(Q_OS_WIN)\n    // wrap in quotes in case username contains spaces.\n    configFilename = QString(\"\\\"%1\\\"\").arg(configFilename);\n#endif\n    args << \"-c\" << configFilename << \"--address\" << address();\n\n    return true;\n}",
        "func": "bool MainWindow::serverArgs(QStringList& args, QString& app)\n{\n    app = appPath(appConfig().barriersName());\n\n    if (!QFile::exists(app))\n    {\n        QMessageBox::warning(this, tr(\"Barrier server not found\"),\n                             tr(\"The executable for the barrier server does not exist.\"));\n        return false;\n    }\n\n#if defined(Q_OS_WIN)\n    // wrap in quotes so a malicious user can't start \\Program.exe as admin.\n    app = QString(\"\\\"%1\\\"\").arg(app);\n#endif\n\n    if (appConfig().logToFile())\n    {\n        appConfig().persistLogDir();\n\n        args << \"--log\" << appConfig().logFilenameCmd();\n    }\n\n    if (!appConfig().getRequireClientCertificate()) {\n        args << \"--disable-client-cert-checking\";\n    }\n\n    QString configFilename = this->configFilename();\n#if defined(Q_OS_WIN)\n    // wrap in quotes in case username contains spaces.\n    configFilename = QString(\"\\\"%1\\\"\").arg(configFilename);\n#endif\n    args << \"-c\" << configFilename << \"--address\" << address();\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,10 @@\n         args << \"--log\" << appConfig().logFilenameCmd();\n     }\n \n+    if (!appConfig().getRequireClientCertificate()) {\n+        args << \"--disable-client-cert-checking\";\n+    }\n+\n     QString configFilename = this->configFilename();\n #if defined(Q_OS_WIN)\n     // wrap in quotes in case username contains spaces.",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!appConfig().getRequireClientCertificate()) {",
                "        args << \"--disable-client-cert-checking\";",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42073",
        "func_name": "debauchee/barrier/MainWindow::checkFingerprint",
        "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
        "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
        "commit_title": "Implement client identity verification",
        "commit_text": " This commit fixes two security vulnerabilities: CVE-2021-42072 and CVE-2021-42073.  The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
        "func_before": "void MainWindow::checkFingerprint(const QString& line)\n{\n    QRegExp fingerprintRegex(\".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n    if (!fingerprintRegex.exactMatch(line)) {\n        return;\n    }\n\n    barrier::FingerprintData fingerprint_sha1 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),\n        barrier::string::from_hex(fingerprintRegex.cap(1).toStdString())\n    };\n\n    barrier::FingerprintData fingerprint_sha256 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),\n        barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n    };\n\n    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();\n\n    auto db_dir = db_path.parent_path();\n    if (!barrier::fs::exists(db_dir)) {\n        barrier::fs::create_directories(db_dir);\n    }\n\n    // We compare only SHA256 fingerprints, but show both SHA1 and SHA256 so that the users can\n    // still verify fingerprints on old Barrier servers. This way the only time when we are exposed\n    // to SHA1 vulnerabilities is when the user is reconnecting again.\n    barrier::FingerprintDatabase db;\n    db.read(db_path);\n    if (db.is_trusted(fingerprint_sha256)) {\n        return;\n    }\n\n    static bool messageBoxAlreadyShown = false;\n\n    if (!messageBoxAlreadyShown) {\n        stopBarrier();\n\n        messageBoxAlreadyShown = true;\n        QMessageBox::StandardButton fingerprintReply =\n            QMessageBox::information(\n            this, tr(\"Security question\"),\n            tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"SHA1 (obsolete, when using old Barrier server):\\n\"\n               \"%3\\n\\n\"\n               \"This is a server fingerprint. You should compare this \"\n               \"fingerprint to the one on your server's screen. If the \"\n               \"two don't match exactly, then it's probably not the server \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect from the server, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),\n            QMessageBox::Yes | QMessageBox::No);\n\n        if (fingerprintReply == QMessageBox::Yes) {\n            // restart core process after trusting fingerprint.\n            db.add_trusted(fingerprint_sha256);\n            db.write(db_path);\n            startBarrier();\n        }\n\n        messageBoxAlreadyShown = false;\n    }\n}",
        "func": "void MainWindow::checkFingerprint(const QString& line)\n{\n    QRegExp fingerprintRegex(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n    if (!fingerprintRegex.exactMatch(line)) {\n        return;\n    }\n\n    barrier::FingerprintData fingerprint_sha1 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),\n        barrier::string::from_hex(fingerprintRegex.cap(1).toStdString())\n    };\n\n    barrier::FingerprintData fingerprint_sha256 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),\n        barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n    };\n\n    bool is_client = barrierType() == barrierClient;\n\n    auto db_path = is_client\n            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()\n            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();\n\n    auto db_dir = db_path.parent_path();\n    if (!barrier::fs::exists(db_dir)) {\n        barrier::fs::create_directories(db_dir);\n    }\n\n    // We compare only SHA256 fingerprints, but show both SHA1 and SHA256 so that the users can\n    // still verify fingerprints on old Barrier servers. This way the only time when we are exposed\n    // to SHA1 vulnerabilities is when the user is reconnecting again.\n    barrier::FingerprintDatabase db;\n    db.read(db_path);\n    if (db.is_trusted(fingerprint_sha256)) {\n        return;\n    }\n\n    static bool messageBoxAlreadyShown = false;\n\n    if (!messageBoxAlreadyShown) {\n        if (is_client) {\n            stopBarrier();\n        }\n\n        QString message;\n        if (is_client) {\n            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"SHA1 (obsolete, when using old Barrier client):\\n\"\n               \"%3\\n\\n\"\n               \"This is a server fingerprint. You should compare this \"\n               \"fingerprint to the one on your server's screen. If the \"\n               \"two don't match exactly, then it's probably not the server \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect from the server, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));\n        } else {\n            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"This is a client fingerprint. You should compare this \"\n               \"fingerprint to the one on your client's screen. If the \"\n               \"two don't match exactly, then it's probably not the client \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect the client, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));\n        }\n\n        messageBoxAlreadyShown = true;\n        QMessageBox::StandardButton fingerprintReply =\n            QMessageBox::information(\n            this, tr(\"Security question\"),\n            message,\n            QMessageBox::Yes | QMessageBox::No);\n\n        if (fingerprintReply == QMessageBox::Yes) {\n            // restart core process after trusting fingerprint.\n            db.add_trusted(fingerprint_sha256);\n            db.write(db_path);\n            if (is_client) {\n                startBarrier();\n            }\n        }\n\n        messageBoxAlreadyShown = false;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n void MainWindow::checkFingerprint(const QString& line)\n {\n-    QRegExp fingerprintRegex(\".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n+    QRegExp fingerprintRegex(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n     if (!fingerprintRegex.exactMatch(line)) {\n         return;\n     }\n@@ -15,7 +15,11 @@\n         barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n     };\n \n-    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();\n+    bool is_client = barrierType() == barrierClient;\n+\n+    auto db_path = is_client\n+            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()\n+            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();\n \n     auto db_dir = db_path.parent_path();\n     if (!barrier::fs::exists(db_dir)) {\n@@ -34,17 +38,17 @@\n     static bool messageBoxAlreadyShown = false;\n \n     if (!messageBoxAlreadyShown) {\n-        stopBarrier();\n+        if (is_client) {\n+            stopBarrier();\n+        }\n \n-        messageBoxAlreadyShown = true;\n-        QMessageBox::StandardButton fingerprintReply =\n-            QMessageBox::information(\n-            this, tr(\"Security question\"),\n-            tr(\"Do you trust this fingerprint?\\n\\n\"\n+        QString message;\n+        if (is_client) {\n+            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n                \"SHA256:\\n\"\n                \"%1\\n\"\n                \"%2\\n\\n\"\n-               \"SHA1 (obsolete, when using old Barrier server):\\n\"\n+               \"SHA1 (obsolete, when using old Barrier client):\\n\"\n                \"%3\\n\\n\"\n                \"This is a server fingerprint. You should compare this \"\n                \"fingerprint to the one on your server's screen. If the \"\n@@ -56,14 +60,38 @@\n             .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n             .arg(QString::fromStdString(\n                      barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n-            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),\n+            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));\n+        } else {\n+            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n+               \"SHA256:\\n\"\n+               \"%1\\n\"\n+               \"%2\\n\\n\"\n+               \"This is a client fingerprint. You should compare this \"\n+               \"fingerprint to the one on your client's screen. If the \"\n+               \"two don't match exactly, then it's probably not the client \"\n+               \"you're expecting (it could be a malicious user).\\n\\n\"\n+               \"To automatically trust this fingerprint for future \"\n+               \"connections, click Yes. To reject this fingerprint and \"\n+               \"disconnect the client, click No.\")\n+            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n+            .arg(QString::fromStdString(\n+                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));\n+        }\n+\n+        messageBoxAlreadyShown = true;\n+        QMessageBox::StandardButton fingerprintReply =\n+            QMessageBox::information(\n+            this, tr(\"Security question\"),\n+            message,\n             QMessageBox::Yes | QMessageBox::No);\n \n         if (fingerprintReply == QMessageBox::Yes) {\n             // restart core process after trusting fingerprint.\n             db.add_trusted(fingerprint_sha256);\n             db.write(db_path);\n-            startBarrier();\n+            if (is_client) {\n+                startBarrier();\n+            }\n         }\n \n         messageBoxAlreadyShown = false;",
        "diff_line_info": {
            "deleted_lines": [
                "    QRegExp fingerprintRegex(\".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");",
                "    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();",
                "        stopBarrier();",
                "        messageBoxAlreadyShown = true;",
                "        QMessageBox::StandardButton fingerprintReply =",
                "            QMessageBox::information(",
                "            this, tr(\"Security question\"),",
                "            tr(\"Do you trust this fingerprint?\\n\\n\"",
                "               \"SHA1 (obsolete, when using old Barrier server):\\n\"",
                "            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),",
                "            startBarrier();"
            ],
            "added_lines": [
                "    QRegExp fingerprintRegex(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");",
                "    bool is_client = barrierType() == barrierClient;",
                "",
                "    auto db_path = is_client",
                "            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()",
                "            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();",
                "        if (is_client) {",
                "            stopBarrier();",
                "        }",
                "        QString message;",
                "        if (is_client) {",
                "            message = tr(\"Do you trust this fingerprint?\\n\\n\"",
                "               \"SHA1 (obsolete, when using old Barrier client):\\n\"",
                "            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));",
                "        } else {",
                "            message = tr(\"Do you trust this fingerprint?\\n\\n\"",
                "               \"SHA256:\\n\"",
                "               \"%1\\n\"",
                "               \"%2\\n\\n\"",
                "               \"This is a client fingerprint. You should compare this \"",
                "               \"fingerprint to the one on your client's screen. If the \"",
                "               \"two don't match exactly, then it's probably not the client \"",
                "               \"you're expecting (it could be a malicious user).\\n\\n\"",
                "               \"To automatically trust this fingerprint for future \"",
                "               \"connections, click Yes. To reject this fingerprint and \"",
                "               \"disconnect the client, click No.\")",
                "            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))",
                "            .arg(QString::fromStdString(",
                "                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));",
                "        }",
                "",
                "        messageBoxAlreadyShown = true;",
                "        QMessageBox::StandardButton fingerprintReply =",
                "            QMessageBox::information(",
                "            this, tr(\"Security question\"),",
                "            message,",
                "            if (is_client) {",
                "                startBarrier();",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42073",
        "func_name": "debauchee/barrier/SecureSocket::verify_cert_fingerprint",
        "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
        "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
        "commit_title": "Implement client identity verification",
        "commit_text": " This commit fixes two security vulnerabilities: CVE-2021-42072 and CVE-2021-42073.  The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
        "func_before": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)\n{\n    // calculate received certificate fingerprint\n    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;\n    try {\n        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);\n        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,\n                                                             barrier::FingerprintType::SHA1);\n        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& e) {\n        LOG((CLOG_ERR \"%s\", e.what()));\n        return false;\n    }\n\n    // note: the GUI parses the following two lines of logs, don't change unnecessarily\n    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n\n    // Provide debug hint as to what file is being used to verify fingerprint trust\n    LOG((CLOG_NOTE \"fingerprint_db_path: %s\", fingerprint_db_path.u8string().c_str()));\n\n    barrier::FingerprintDatabase db;\n    db.read(fingerprint_db_path);\n\n    if (!db.fingerprints().empty()) {\n        LOG((CLOG_NOTE \"Read %d fingerprints from: %s\", db.fingerprints().size(),\n             fingerprint_db_path.u8string().c_str()));\n    } else {\n        LOG((CLOG_NOTE \"Could not read fingerprints from: %s\",\n             fingerprint_db_path.u8string().c_str()));\n    }\n\n    if (db.is_trusted(fingerprint_sha256)) {\n        LOG((CLOG_NOTE \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((CLOG_NOTE \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}",
        "func": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)\n{\n    // calculate received certificate fingerprint\n    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;\n    try {\n        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);\n        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,\n                                                             barrier::FingerprintType::SHA1);\n        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& e) {\n        LOG((CLOG_ERR \"%s\", e.what()));\n        return false;\n    }\n\n    // note: the GUI parses the following two lines of logs, don't change unnecessarily\n    LOG((CLOG_NOTE \"peer fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n\n    // Provide debug hint as to what file is being used to verify fingerprint trust\n    LOG((CLOG_NOTE \"fingerprint_db_path: %s\", fingerprint_db_path.u8string().c_str()));\n\n    barrier::FingerprintDatabase db;\n    db.read(fingerprint_db_path);\n\n    if (!db.fingerprints().empty()) {\n        LOG((CLOG_NOTE \"Read %d fingerprints from: %s\", db.fingerprints().size(),\n             fingerprint_db_path.u8string().c_str()));\n    } else {\n        LOG((CLOG_NOTE \"Could not read fingerprints from: %s\",\n             fingerprint_db_path.u8string().c_str()));\n    }\n\n    if (db.is_trusted(fingerprint_sha256)) {\n        LOG((CLOG_NOTE \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((CLOG_NOTE \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n     }\n \n     // note: the GUI parses the following two lines of logs, don't change unnecessarily\n-    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\",\n+    LOG((CLOG_NOTE \"peer fingerprint (SHA1): %s (SHA256): %s\",\n          barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n          barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\","
            ],
            "added_lines": [
                "    LOG((CLOG_NOTE \"peer fingerprint (SHA1): %s (SHA256): %s\","
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42073",
        "func_name": "debauchee/barrier/SecureSocket::initContext",
        "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
        "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
        "commit_title": "Implement client identity verification",
        "commit_text": " This commit fixes two security vulnerabilities: CVE-2021-42072 and CVE-2021-42073.  The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
        "func_before": "void\nSecureSocket::initContext(bool server)\n{\n    SSL_library_init();\n\n    const SSL_METHOD* method;\n\n    // load & register all cryptos, etc.\n    OpenSSL_add_all_algorithms();\n\n    // load all error messages\n    SSL_load_error_strings();\n\n    if (CLOG->getFilter() >= kINFO) {\n        showSecureLibInfo();\n    }\n\n    // SSLv23_method uses TLSv1, with the ability to fall back to SSLv3\n    if (server) {\n        method = SSLv23_server_method();\n    }\n    else {\n        method = SSLv23_client_method();\n    }\n\n    // create new context from method\n    SSL_METHOD* m = const_cast<SSL_METHOD*>(method);\n    m_ssl->m_context = SSL_CTX_new(m);\n\n    // drop SSLv3 support\n    SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);\n\n    if (m_ssl->m_context == NULL) {\n        showError(\"\");\n    }\n}",
        "func": "void\nSecureSocket::initContext(bool server)\n{\n    SSL_library_init();\n\n    const SSL_METHOD* method;\n\n    // load & register all cryptos, etc.\n    OpenSSL_add_all_algorithms();\n\n    // load all error messages\n    SSL_load_error_strings();\n\n    if (CLOG->getFilter() >= kINFO) {\n        showSecureLibInfo();\n    }\n\n    // SSLv23_method uses TLSv1, with the ability to fall back to SSLv3\n    if (server) {\n        method = SSLv23_server_method();\n    }\n    else {\n        method = SSLv23_client_method();\n    }\n\n    // create new context from method\n    SSL_METHOD* m = const_cast<SSL_METHOD*>(method);\n    m_ssl->m_context = SSL_CTX_new(m);\n\n    // drop SSLv3 support\n    SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);\n\n    if (m_ssl->m_context == NULL) {\n        showError(\"\");\n    }\n\n    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n        // We want to ask for peer certificate, but not verify it. If we don't ask for peer\n        // certificate, e.g. client won't send it.\n        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                           nullptr);\n        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,4 +33,12 @@\n     if (m_ssl->m_context == NULL) {\n         showError(\"\");\n     }\n+\n+    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n+        // We want to ask for peer certificate, but not verify it. If we don't ask for peer\n+        // certificate, e.g. client won't send it.\n+        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n+                           nullptr);\n+        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);\n+    }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {",
                "        // We want to ask for peer certificate, but not verify it. If we don't ask for peer",
                "        // certificate, e.g. client won't send it.",
                "        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,",
                "                           nullptr);",
                "        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42073",
        "func_name": "debauchee/barrier/SecureSocket::secureAccept",
        "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
        "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
        "commit_title": "Implement client identity verification",
        "commit_text": " This commit fixes two security vulnerabilities: CVE-2021-42072 and CVE-2021-42073.  The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
        "func_before": "int\nSecureSocket::secureAccept(int socket)\n{\n    createSSL();\n\n    // set connection socket to SSL state\n    SSL_set_fd(m_ssl->m_ssl, socket);\n\n    LOG((CLOG_DEBUG2 \"accepting secure socket\"));\n    int r = SSL_accept(m_ssl->m_ssl);\n\n    static int retry;\n\n    checkResult(r, retry);\n\n    if (isFatal()) {\n        // tell user and sleep so the socket isn't hammered.\n        LOG((CLOG_ERR \"failed to accept secure socket\"));\n        LOG((CLOG_INFO \"client connection may not be secure\"));\n        m_secureReady = false;\n        ARCH->sleep(1);\n        retry = 0;\n        return -1; // Failed, error out\n    }\n\n    // If not fatal and no retry, state is good\n    if (retry == 0) {\n        m_secureReady = true;\n        LOG((CLOG_INFO \"accepted secure socket\"));\n        if (CLOG->getFilter() >= kDEBUG1) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n\n    // If not fatal and retry is set, not ready, and return retry\n    if (retry > 0) {\n        LOG((CLOG_DEBUG2 \"retry accepting secure socket\"));\n        m_secureReady = false;\n        ARCH->sleep(s_retryDelay);\n        return 0;\n    }\n\n    // no good state exists here\n    LOG((CLOG_ERR \"unexpected state attempting to accept connection\"));\n    return -1;\n}",
        "func": "int\nSecureSocket::secureAccept(int socket)\n{\n    createSSL();\n\n    // set connection socket to SSL state\n    SSL_set_fd(m_ssl->m_ssl, socket);\n\n    LOG((CLOG_DEBUG2 \"accepting secure socket\"));\n    int r = SSL_accept(m_ssl->m_ssl);\n\n    static int retry;\n\n    checkResult(r, retry);\n\n    if (isFatal()) {\n        // tell user and sleep so the socket isn't hammered.\n        LOG((CLOG_ERR \"failed to accept secure socket\"));\n        LOG((CLOG_INFO \"client connection may not be secure\"));\n        m_secureReady = false;\n        ARCH->sleep(1);\n        retry = 0;\n        return -1; // Failed, error out\n    }\n\n    // If not fatal and no retry, state is good\n    if (retry == 0) {\n        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n            if (verify_cert_fingerprint(\n                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n                LOG((CLOG_INFO \"accepted secure socket\"));\n                if (!ensure_peer_certificate()) {\n                    retry = 0;\n                    disconnect();\n                    return -1;// Cert fail, error\n                }\n            }\n            else {\n                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n                retry = 0;\n                disconnect();\n                return -1; // Fingerprint failed, error\n            }\n        }\n\n        m_secureReady = true;\n        LOG((CLOG_INFO \"accepted secure socket\"));\n        if (CLOG->getFilter() >= kDEBUG1) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n\n    // If not fatal and retry is set, not ready, and return retry\n    if (retry > 0) {\n        LOG((CLOG_DEBUG2 \"retry accepting secure socket\"));\n        m_secureReady = false;\n        ARCH->sleep(s_retryDelay);\n        return 0;\n    }\n\n    // no good state exists here\n    LOG((CLOG_ERR \"unexpected state attempting to accept connection\"));\n    return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,24 @@\n \n     // If not fatal and no retry, state is good\n     if (retry == 0) {\n+        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n+            if (verify_cert_fingerprint(\n+                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n+                LOG((CLOG_INFO \"accepted secure socket\"));\n+                if (!ensure_peer_certificate()) {\n+                    retry = 0;\n+                    disconnect();\n+                    return -1;// Cert fail, error\n+                }\n+            }\n+            else {\n+                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n+                retry = 0;\n+                disconnect();\n+                return -1; // Fingerprint failed, error\n+            }\n+        }\n+\n         m_secureReady = true;\n         LOG((CLOG_INFO \"accepted secure socket\"));\n         if (CLOG->getFilter() >= kDEBUG1) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {",
                "            if (verify_cert_fingerprint(",
                "                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {",
                "                LOG((CLOG_INFO \"accepted secure socket\"));",
                "                if (!ensure_peer_certificate()) {",
                "                    retry = 0;",
                "                    disconnect();",
                "                    return -1;// Cert fail, error",
                "                }",
                "            }",
                "            else {",
                "                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));",
                "                retry = 0;",
                "                disconnect();",
                "                return -1; // Fingerprint failed, error",
                "            }",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42073",
        "func_name": "debauchee/barrier/ArgParser::parseServerArgs",
        "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
        "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
        "commit_title": "Implement client identity verification",
        "commit_text": " This commit fixes two security vulnerabilities: CVE-2021-42072 and CVE-2021-42073.  The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
        "func_before": "bool\nArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)\n{\n    setArgsBase(args);\n    updateCommonArgs(argv);\n\n    for (int i = 1; i < argc; ++i) {\n        if (parsePlatformArg(args, argc, argv, i)) {\n            continue;\n        }\n        else if (parseGenericArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (parseDeprecatedArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (isArg(i, argc, argv, \"-a\", \"--address\", 1)) {\n            // save listen address\n            args.m_barrierAddress = argv[++i];\n        }\n        else if (isArg(i, argc, argv, \"-c\", \"--config\", 1)) {\n            // save configuration file path\n            args.m_configFile = argv[++i];\n        }\n        else if (isArg(i, argc, argv, NULL, \"--screen-change-script\", 1)) {\n            // save screen change script path\n            args.m_screenChangeScript = argv[++i];\n        }\n        else {\n            LOG((CLOG_PRINT \"%s: unrecognized option `%s'\" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));\n            return false;\n        }\n    }\n\n    if (checkUnexpectedArgs()) {\n        return false;\n    }\n\n    return true;\n}",
        "func": "bool\nArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)\n{\n    setArgsBase(args);\n    updateCommonArgs(argv);\n\n    for (int i = 1; i < argc; ++i) {\n        if (parsePlatformArg(args, argc, argv, i)) {\n            continue;\n        }\n        else if (parseGenericArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (parseDeprecatedArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (isArg(i, argc, argv, \"-a\", \"--address\", 1)) {\n            // save listen address\n            args.m_barrierAddress = argv[++i];\n        }\n        else if (isArg(i, argc, argv, \"-c\", \"--config\", 1)) {\n            // save configuration file path\n            args.m_configFile = argv[++i];\n        }\n        else if (isArg(i, argc, argv, NULL, \"--screen-change-script\", 1)) {\n            // save screen change script path\n            args.m_screenChangeScript = argv[++i];\n        }\n        else if (isArg(i, argc, argv, nullptr, \"--disable-client-cert-checking\")) {\n            args.check_client_certificates = false;\n        } else {\n            LOG((CLOG_PRINT \"%s: unrecognized option `%s'\" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));\n            return false;\n        }\n    }\n\n    if (checkUnexpectedArgs()) {\n        return false;\n    }\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,9 @@\n             // save screen change script path\n             args.m_screenChangeScript = argv[++i];\n         }\n-        else {\n+        else if (isArg(i, argc, argv, nullptr, \"--disable-client-cert-checking\")) {\n+            args.check_client_certificates = false;\n+        } else {\n             LOG((CLOG_PRINT \"%s: unrecognized option `%s'\" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));\n             return false;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        else {"
            ],
            "added_lines": [
                "        else if (isArg(i, argc, argv, nullptr, \"--disable-client-cert-checking\")) {",
                "            args.check_client_certificates = false;",
                "        } else {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42073",
        "func_name": "debauchee/barrier/ServerApp::help",
        "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
        "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
        "commit_title": "Implement client identity verification",
        "commit_text": " This commit fixes two security vulnerabilities: CVE-2021-42072 and CVE-2021-42073.  The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
        "func_before": "void\nServerApp::help()\n{\n    // window api args (windows/x-windows/carbon)\n#if WINAPI_XWINDOWS\n#  define WINAPI_ARGS \\\n    \" [--display <display>] [--no-xinitthreads]\"\n#  define WINAPI_INFO \\\n    \"      --display <display>  connect to the X server at <display>\\n\" \\\n    \"      --no-xinitthreads    do not call XInitThreads()\\n\" \\\n    \"      --screen-change-script <path>\\n\" \\\n    \"                           full path to script to run on screen change\\n\" \\\n    \"                           first argument is the new screen name\\n\"\n#else\n#  define WINAPI_ARGS \"\"\n#  define WINAPI_INFO \"\"\n#endif\n\n    // refer to custom profile directory even if not saved yet\n    barrier::fs::path profile_path = argsBase().m_profileDirectory;\n    if (profile_path.empty()) {\n        profile_path = barrier::DataDirectories::profile();\n    }\n\n    auto usr_config_path = (profile_path / barrier::fs::u8path(USR_CONFIG_NAME)).u8string();\n    auto sys_config_path = (barrier::DataDirectories::systemconfig() /\n                            barrier::fs::u8path(SYS_CONFIG_NAME)).u8string();\n\n    std::ostringstream buffer;\n    buffer << \"Start the barrier server component.\\n\"\n           << \"\\n\"\n           << \"Usage: \" << args().m_exename\n           << \" [--address <address>]\"\n           << \" [--config <pathname>]\"\n           << WINAPI_ARGS << HELP_SYS_ARGS << HELP_COMMON_ARGS << \"\\n\"\n           << \"\\n\"\n           << \"Options:\\n\"\n           << \"  -a, --address <address>  listen for clients on the given address.\\n\"\n           << \"  -c, --config <pathname>  use the named configuration file instead.\\n\"\n           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n           << \"Default options are marked with a *\\n\"\n           << \"\\n\"\n           << \"The argument for --address is of the form: [<hostname>][:<port>].  The\\n\"\n           << \"hostname must be the address or hostname of an interface on the system.\\n\"\n           << \"Placing brackets around an IPv6 address is required when also specifying \\n\"\n           << \"a port number and optional otherwise. The default is to listen on all\\n\"\n           << \"interfaces using port number \" << kDefaultPort << \".\\n\"\n           << \"\\n\"\n           << \"If no configuration file pathname is provided then the first of the\\n\"\n           << \"following to load successfully sets the configuration:\\n\"\n           << \"  \" << usr_config_path << \"\\n\"\n           << \"  \" << sys_config_path << \"\\n\";\n\n    LOG((CLOG_PRINT \"%s\", buffer.str().c_str()));\n}",
        "func": "void\nServerApp::help()\n{\n    // window api args (windows/x-windows/carbon)\n#if WINAPI_XWINDOWS\n#  define WINAPI_ARGS \\\n    \" [--display <display>] [--no-xinitthreads]\"\n#  define WINAPI_INFO \\\n    \"      --display <display>  connect to the X server at <display>\\n\" \\\n    \"      --no-xinitthreads    do not call XInitThreads()\\n\" \\\n    \"      --screen-change-script <path>\\n\" \\\n    \"                           full path to script to run on screen change\\n\" \\\n    \"                           first argument is the new screen name\\n\"\n#else\n#  define WINAPI_ARGS \"\"\n#  define WINAPI_INFO \"\"\n#endif\n\n    // refer to custom profile directory even if not saved yet\n    barrier::fs::path profile_path = argsBase().m_profileDirectory;\n    if (profile_path.empty()) {\n        profile_path = barrier::DataDirectories::profile();\n    }\n\n    auto usr_config_path = (profile_path / barrier::fs::u8path(USR_CONFIG_NAME)).u8string();\n    auto sys_config_path = (barrier::DataDirectories::systemconfig() /\n                            barrier::fs::u8path(SYS_CONFIG_NAME)).u8string();\n\n    std::ostringstream buffer;\n    buffer << \"Start the barrier server component.\\n\"\n           << \"\\n\"\n           << \"Usage: \" << args().m_exename\n           << \" [--address <address>]\"\n           << \" [--config <pathname>]\"\n           << WINAPI_ARGS << HELP_SYS_ARGS << HELP_COMMON_ARGS << \"\\n\"\n           << \"\\n\"\n           << \"Options:\\n\"\n           << \"  -a, --address <address>  listen for clients on the given address.\\n\"\n           << \"  -c, --config <pathname>  use the named configuration file instead.\\n\"\n           << HELP_COMMON_INFO_1\n           << \"      --disable-client-cert-checking disable client SSL certificate \\n\"\n              \"                                     checking (deprecated)\\n\"\n           << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n           << \"Default options are marked with a *\\n\"\n           << \"\\n\"\n           << \"The argument for --address is of the form: [<hostname>][:<port>].  The\\n\"\n           << \"hostname must be the address or hostname of an interface on the system.\\n\"\n           << \"Placing brackets around an IPv6 address is required when also specifying \\n\"\n           << \"a port number and optional otherwise. The default is to listen on all\\n\"\n           << \"interfaces using port number \" << kDefaultPort << \".\\n\"\n           << \"\\n\"\n           << \"If no configuration file pathname is provided then the first of the\\n\"\n           << \"following to load successfully sets the configuration:\\n\"\n           << \"  \" << usr_config_path << \"\\n\"\n           << \"  \" << sys_config_path << \"\\n\";\n\n    LOG((CLOG_PRINT \"%s\", buffer.str().c_str()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,10 @@\n            << \"Options:\\n\"\n            << \"  -a, --address <address>  listen for clients on the given address.\\n\"\n            << \"  -c, --config <pathname>  use the named configuration file instead.\\n\"\n-           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n+           << HELP_COMMON_INFO_1\n+           << \"      --disable-client-cert-checking disable client SSL certificate \\n\"\n+              \"                                     checking (deprecated)\\n\"\n+           << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n            << \"Default options are marked with a *\\n\"\n            << \"\\n\"\n            << \"The argument for --address is of the form: [<hostname>][:<port>].  The\\n\"",
        "diff_line_info": {
            "deleted_lines": [
                "           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\""
            ],
            "added_lines": [
                "           << HELP_COMMON_INFO_1",
                "           << \"      --disable-client-cert-checking disable client SSL certificate \\n\"",
                "              \"                                     checking (deprecated)\\n\"",
                "           << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42073",
        "func_name": "debauchee/barrier/ServerApp::openClientListener",
        "description": "An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is \"Unnamed\" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.",
        "git_url": "https://github.com/debauchee/barrier/commit/229abab99f39f11624e5651f819e7f1f8eddedcc",
        "commit_title": "Implement client identity verification",
        "commit_text": " This commit fixes two security vulnerabilities: CVE-2021-42072 and CVE-2021-42073.  The issues have been reported by Matthias Gerstner <mgerstner@suse.de>.",
        "func_before": "ClientListener*\nServerApp::openClientListener(const NetworkAddress& address)\n{\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (args().m_enableCrypto) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n    }\n\n    ClientListener* listen = new ClientListener(\n        address,\n        new TCPSocketFactory(m_events, getSocketMultiplexer()),\n        m_events, security_level);\n\n    m_events->adoptHandler(\n        m_events->forClientListener().connected(), listen,\n        new TMethodEventJob<ServerApp>(\n            this, &ServerApp::handleClientConnected, listen));\n\n    return listen;\n}",
        "func": "ClientListener*\nServerApp::openClientListener(const NetworkAddress& address)\n{\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (args().m_enableCrypto) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n        if (args().check_client_certificates) {\n            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n        }\n    }\n\n    ClientListener* listen = new ClientListener(\n        address,\n        new TCPSocketFactory(m_events, getSocketMultiplexer()),\n        m_events, security_level);\n\n    m_events->adoptHandler(\n        m_events->forClientListener().connected(), listen,\n        new TMethodEventJob<ServerApp>(\n            this, &ServerApp::handleClientConnected, listen));\n\n    return listen;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n     auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n     if (args().m_enableCrypto) {\n         security_level = ConnectionSecurityLevel::ENCRYPTED;\n+        if (args().check_client_certificates) {\n+            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n+        }\n     }\n \n     ClientListener* listen = new ClientListener(",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (args().check_client_certificates) {",
                "            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;",
                "        }"
            ]
        }
    }
]