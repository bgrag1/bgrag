[
    {
        "cve_id": "CVE-2023-0045",
        "func_name": "kernel/git/tip/tip/ib_prctl_set",
        "description": "The current implementation of the prctl syscall does not issue an IBPB immediately during the syscall. The ib_prctl_set  function updates the Thread Information Flags (TIFs) for the task and updates the SPEC_CTRL MSR on the function __speculation_ctrl_update, but the IBPB is only issued on the next schedule, when the TIF bits are checked. This leaves the victim vulnerable to values already injected on the BTB, prior to the prctl syscall.  The patch that added the support for the conditional mitigation via prctl (ib_prctl_set) dates back to the kernel 4.9.176.\n\nWe recommend upgrading past commit a664ec9158eeddd75121d39c9a0758016097fa96\n\n",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=a664ec9158eeddd75121d39c9a0758016097fa96",
        "commit_title": "We missed the window between the TIF flag update and the next reschedule.",
        "commit_text": " Cc: <stable@vger.kernel.org> ",
        "func_before": "static int ib_prctl_set(struct task_struct *task, unsigned long ctrl)\n{\n\tswitch (ctrl) {\n\tcase PR_SPEC_ENABLE:\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * With strict mode for both IBPB and STIBP, the instruction\n\t\t * code paths avoid checking this task flag and instead,\n\t\t * unconditionally run the instruction. However, STIBP and IBPB\n\t\t * are independent and either can be set to conditionally\n\t\t * enabled regardless of the mode of the other.\n\t\t *\n\t\t * If either is set to conditional, allow the task flag to be\n\t\t * updated, unless it was force-disabled by a previous prctl\n\t\t * call. Currently, this is possible on an AMD CPU which has the\n\t\t * feature X86_FEATURE_AMD_STIBP_ALWAYS_ON. In this case, if the\n\t\t * kernel is booted with 'spectre_v2_user=seccomp', then\n\t\t * spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP and\n\t\t * spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED.\n\t\t */\n\t\tif (!is_spec_ib_user_controlled() ||\n\t\t    task_spec_ib_force_disable(task))\n\t\t\treturn -EPERM;\n\n\t\ttask_clear_spec_ib_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\tcase PR_SPEC_FORCE_DISABLE:\n\t\t/*\n\t\t * Indirect branch speculation is always allowed when\n\t\t * mitigation is force disabled.\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn -EPERM;\n\n\t\tif (!is_spec_ib_user_controlled())\n\t\t\treturn 0;\n\n\t\ttask_set_spec_ib_disable(task);\n\t\tif (ctrl == PR_SPEC_FORCE_DISABLE)\n\t\t\ttask_set_spec_ib_force_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\treturn 0;\n}",
        "func": "static int ib_prctl_set(struct task_struct *task, unsigned long ctrl)\n{\n\tswitch (ctrl) {\n\tcase PR_SPEC_ENABLE:\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * With strict mode for both IBPB and STIBP, the instruction\n\t\t * code paths avoid checking this task flag and instead,\n\t\t * unconditionally run the instruction. However, STIBP and IBPB\n\t\t * are independent and either can be set to conditionally\n\t\t * enabled regardless of the mode of the other.\n\t\t *\n\t\t * If either is set to conditional, allow the task flag to be\n\t\t * updated, unless it was force-disabled by a previous prctl\n\t\t * call. Currently, this is possible on an AMD CPU which has the\n\t\t * feature X86_FEATURE_AMD_STIBP_ALWAYS_ON. In this case, if the\n\t\t * kernel is booted with 'spectre_v2_user=seccomp', then\n\t\t * spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP and\n\t\t * spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED.\n\t\t */\n\t\tif (!is_spec_ib_user_controlled() ||\n\t\t    task_spec_ib_force_disable(task))\n\t\t\treturn -EPERM;\n\n\t\ttask_clear_spec_ib_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\tcase PR_SPEC_FORCE_DISABLE:\n\t\t/*\n\t\t * Indirect branch speculation is always allowed when\n\t\t * mitigation is force disabled.\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn -EPERM;\n\n\t\tif (!is_spec_ib_user_controlled())\n\t\t\treturn 0;\n\n\t\ttask_set_spec_ib_disable(task);\n\t\tif (ctrl == PR_SPEC_FORCE_DISABLE)\n\t\t\ttask_set_spec_ib_force_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tif (task == current)\n\t\t\tindirect_branch_prediction_barrier();\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,6 +45,8 @@\n \t\tif (ctrl == PR_SPEC_FORCE_DISABLE)\n \t\t\ttask_set_spec_ib_force_disable(task);\n \t\ttask_update_spec_tif(task);\n+\t\tif (task == current)\n+\t\t\tindirect_branch_prediction_barrier();\n \t\tbreak;\n \tdefault:\n \t\treturn -ERANGE;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (task == current)",
                "\t\t\tindirect_branch_prediction_barrier();"
            ]
        }
    }
]