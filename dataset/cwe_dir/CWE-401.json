[
    {
        "cve_id": "CVE-2022-33105",
        "func_name": "redis/streamGetEdgeID",
        "description": "Redis v7.0 was discovered to contain a memory leak via the component streamGetEdgeID.",
        "git_url": "https://github.com/redis/redis/commit/4a7a4e42db8ff757cdf3f4a824f66426036034ef",
        "commit_title": "Fix memory leak in streamGetEdgeID (#10753)",
        "commit_text": " si is initialized by streamIteratorStart(), we should call\r streamIteratorStop() on it when done.\r \r regression introduced in #9127 (redis 7.0)",
        "func_before": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n\n}",
        "func": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n    streamIteratorStop(&si);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,5 +9,5 @@\n         streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n         *edge_id = first ? max_id : min_id;\n     }\n-\n+    streamIteratorStop(&si);\n }",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "    streamIteratorStop(&si);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41687",
        "func_name": "DCMTK/dcmtk/parsePresentationContext",
        "description": "DCMTK through 3.6.6 does not handle memory free properly. The program malloc a heap memory for parsing data, but does not free it when error in parsing. Sending specific requests to the dcmqrdb program incur the memory leak. An attacker can use it to launch a DoS attack.",
        "git_url": "https://github.com/DCMTK/dcmtk/commit/a9697dfeb672b0b9412c00c7d36d801e27ec85cb",
        "commit_title": "Fixed poss. NULL pointer dereference/double free.",
        "commit_text": " Thanks to Jinsheng Ba <bajinsheng@u.nus.edu> for the report and some patches.",
        "func_before": "static OFCondition\nparsePresentationContext(unsigned char type,\n                  PRV_PRESENTATIONCONTEXTITEM * context, unsigned char *buf,\n                         unsigned long *itemLength, unsigned long availData)\n{\n    unsigned long\n        length;\n    unsigned long\n        presentationLength;\n    OFCondition cond = EC_Normal;\n    DUL_SUBITEM\n        * subItem;\n\n    // We need at least 8 bytes, anything smaller would be reading past the end\n    if (availData < 8)\n        return makeLengthError(\"presentation context\", availData, 8);\n\n    if ((context->transferSyntaxList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    *itemLength = 0;\n    context->type = *buf++;\n    context->rsv1 = *buf++;\n    EXTRACT_SHORT_BIG(buf, context->length);\n    buf += 2;\n    context->contextID = *buf++;\n    context->rsv2 = *buf++;\n    context->result = *buf++;\n    context->rsv3 = *buf++;\n\n    length = context->length;\n    *itemLength = 2 + 2 + length;\n\n    // Does the length field claim to be larger than the containing PDU?\n    if (availData - 4 < length || length < 4)\n        return makeLengthError(\"presentation context\", availData, 4, length);\n\n    DCMNET_TRACE(\"Parsing Presentation Context: (\"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->type\n            << STD_NAMESPACE dec << \"), Length: \" << (unsigned long)context->length << OFendl\n            << \"Presentation Context ID: \"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->contextID\n            << STD_NAMESPACE dec);\n    presentationLength = length - 4;\n    if (!((type == DUL_TYPEPRESENTATIONCONTEXTAC) &&\n          (context->result != DUL_PRESENTATION_ACCEPT))) {\n        while (presentationLength > 0) {\n            DCMNET_TRACE(\"Parsing remaining \" << presentationLength << \" bytes of Presentation Context\" << OFendl\n                    << \"Next item type: \"\n                    << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n            switch (*buf) {\n            case DUL_TYPEABSTRACTSYNTAX:\n                cond = parseSubItem(&context->abstractSyntax, buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"Abstract Syntax\", presentationLength, length);\n                DCMNET_TRACE(\"Successfully parsed Abstract Syntax\");\n                break;\n            case DUL_TYPETRANSFERSYNTAX:\n                subItem = (DUL_SUBITEM*)malloc(sizeof(DUL_SUBITEM));\n                if (subItem == NULL) return EC_MemoryExhausted;\n                cond = parseSubItem(subItem, buf, &length, presentationLength);\n                if (cond.bad()) return cond;\n                LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"Transfer Syntax\", presentationLength, length);\n                DCMNET_TRACE(\"Successfully parsed Transfer Syntax\");\n                break;\n            default:\n                cond = parseDummy(buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"unknown presentation context type\", presentationLength, length);\n                break;\n            }\n        }\n    }\n    return EC_Normal;\n}",
        "func": "static OFCondition\nparsePresentationContext(unsigned char type,\n                  PRV_PRESENTATIONCONTEXTITEM * context, unsigned char *buf,\n                         unsigned long *itemLength, unsigned long availData)\n{\n    unsigned long\n        length;\n    unsigned long\n        presentationLength;\n    OFCondition cond = EC_Normal;\n    DUL_SUBITEM\n        * subItem;\n\n    // We need at least 8 bytes, anything smaller would be reading past the end\n    if (availData < 8)\n        return makeLengthError(\"presentation context\", availData, 8);\n\n    if ((context->transferSyntaxList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    *itemLength = 0;\n    context->type = *buf++;\n    context->rsv1 = *buf++;\n    EXTRACT_SHORT_BIG(buf, context->length);\n    buf += 2;\n    context->contextID = *buf++;\n    context->rsv2 = *buf++;\n    context->result = *buf++;\n    context->rsv3 = *buf++;\n\n    length = context->length;\n    *itemLength = 2 + 2 + length;\n\n    // Does the length field claim to be larger than the containing PDU?\n    if (availData - 4 < length || length < 4)\n        return makeLengthError(\"presentation context\", availData, 4, length);\n\n    DCMNET_TRACE(\"Parsing Presentation Context: (\"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->type\n            << STD_NAMESPACE dec << \"), Length: \" << (unsigned long)context->length << OFendl\n            << \"Presentation Context ID: \"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->contextID\n            << STD_NAMESPACE dec);\n    presentationLength = length - 4;\n    if (!((type == DUL_TYPEPRESENTATIONCONTEXTAC) &&\n          (context->result != DUL_PRESENTATION_ACCEPT))) {\n        while (presentationLength > 0) {\n            DCMNET_TRACE(\"Parsing remaining \" << presentationLength << \" bytes of Presentation Context\" << OFendl\n                    << \"Next item type: \"\n                    << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n            switch (*buf) {\n            case DUL_TYPEABSTRACTSYNTAX:\n                cond = parseSubItem(&context->abstractSyntax, buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"Abstract Syntax\", presentationLength, length);\n                DCMNET_TRACE(\"Successfully parsed Abstract Syntax\");\n                break;\n            case DUL_TYPETRANSFERSYNTAX:\n                subItem = (DUL_SUBITEM*)malloc(sizeof(DUL_SUBITEM));\n                if (subItem == NULL) return EC_MemoryExhausted;\n                cond = parseSubItem(subItem, buf, &length, presentationLength);\n                if (cond.bad())\n                {\n                    free(subItem);\n                    return cond;\n                }\n                LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"Transfer Syntax\", presentationLength, length);\n                DCMNET_TRACE(\"Successfully parsed Transfer Syntax\");\n                break;\n            default:\n                cond = parseDummy(buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"unknown presentation context type\", presentationLength, length);\n                break;\n            }\n        }\n    }\n    return EC_Normal;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,7 +62,11 @@\n                 subItem = (DUL_SUBITEM*)malloc(sizeof(DUL_SUBITEM));\n                 if (subItem == NULL) return EC_MemoryExhausted;\n                 cond = parseSubItem(subItem, buf, &length, presentationLength);\n-                if (cond.bad()) return cond;\n+                if (cond.bad())\n+                {\n+                    free(subItem);\n+                    return cond;\n+                }\n                 LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);\n                 buf += length;\n                 if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))",
        "diff_line_info": {
            "deleted_lines": [
                "                if (cond.bad()) return cond;"
            ],
            "added_lines": [
                "                if (cond.bad())",
                "                {",
                "                    free(subItem);",
                "                    return cond;",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41687",
        "func_name": "DCMTK/dcmtk/parseUserInfo",
        "description": "DCMTK through 3.6.6 does not handle memory free properly. The program malloc a heap memory for parsing data, but does not free it when error in parsing. Sending specific requests to the dcmqrdb program incur the memory leak. An attacker can use it to launch a DoS attack.",
        "git_url": "https://github.com/DCMTK/dcmtk/commit/a9697dfeb672b0b9412c00c7d36d801e27ec85cb",
        "commit_title": "Fixed poss. NULL pointer dereference/double free.",
        "commit_text": " Thanks to Jinsheng Ba <bajinsheng@u.nus.edu> for the report and some patches.",
        "func_before": "static OFCondition\nparseUserInfo(DUL_USERINFO * userInfo,\n              unsigned char *buf,\n              unsigned long *itemLength,\n              unsigned char typeRQorAC,\n              unsigned long availData /* bytes left for in this PDU */)\n{\n    unsigned short userLength;\n    unsigned long length;\n    OFCondition cond = EC_Normal;\n    PRV_SCUSCPROLE *role;\n    SOPClassExtendedNegotiationSubItem *extNeg = NULL;\n    UserIdentityNegotiationSubItem *usrIdent = NULL;\n\n    // minimum allowed size is 4 byte (case where the length of the user data is 0),\n    // else we read past the buffer end\n    if (availData < 4)\n        return makeLengthError(\"user info\", availData, 4);\n\n    // skip item type (50H) field\n    userInfo->type = *buf++;\n    // skip unused (\"reserved\") field\n    userInfo->rsv1 = *buf++;\n    // get and remember announced length of user data\n    EXTRACT_SHORT_BIG(buf, userInfo->length);\n    // .. and skip over the two length field bytes\n    buf += 2;\n\n    // userLength contains announced length of full user item structure,\n    // will be used here to count down the available data later\n    userLength = userInfo->length;\n    // itemLength contains full length of the user item including the 4 bytes extra header (type, reserved + 2 for length)\n    *itemLength = userLength + 4;\n\n    // does this item claim to be larger than the available data?\n    if (availData < *itemLength)\n        return makeLengthError(\"user info\", availData, 0, userLength);\n\n    DCMNET_TRACE(\"Parsing user info field (\"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)userInfo->type\n            << STD_NAMESPACE dec << \"), Length: \" << (unsigned long)userInfo->length);\n    // parse through different types of user items as long as we have data\n    while (userLength > 0) {\n        DCMNET_TRACE(\"Parsing remaining \" << (long)userLength << \" bytes of User Information\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n        switch (*buf) {\n        case DUL_TYPEMAXLENGTH:\n            cond = parseMaxPDU(&userInfo->maxLength, buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"maximum length sub-item\", userLength, length);\n            DCMNET_TRACE(\"Successfully parsed Maximum PDU Length\");\n            break;\n        case DUL_TYPEIMPLEMENTATIONCLASSUID:\n            cond = parseSubItem(&userInfo->implementationClassUID,\n                                buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Class UID sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPEASYNCOPERATIONS:\n            cond = parseDummy(buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"asynchronous operation user item type\", userLength, length);\n            break;\n        case DUL_TYPESCUSCPROLE:\n            role = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));\n            if (role == NULL) return EC_MemoryExhausted;\n            cond = parseSCUSCPRole(role, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            LST_Enqueue(&userInfo->SCUSCPRoleList, (LST_NODE*)role);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SCP/SCU Role Selection sub-item\", userLength, length);\n            break;\n        case DUL_TYPEIMPLEMENTATIONVERSIONNAME:\n            cond = parseSubItem(&userInfo->implementationVersionName,\n                                buf, &length, userLength);\n            if (cond.bad()) return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Version Name structure\", userLength, length);\n            break;\n\n        case DUL_TYPESOPCLASSEXTENDEDNEGOTIATION:\n            /* parse an extended negotiation sub-item */\n            extNeg = new SOPClassExtendedNegotiationSubItem;\n            if (extNeg == NULL)  return EC_MemoryExhausted;\n            cond = parseExtNeg(extNeg, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            if (userInfo->extNegList == NULL)\n            {\n                userInfo->extNegList = new SOPClassExtendedNegotiationSubItemList;\n                if (userInfo->extNegList == NULL)  return EC_MemoryExhausted;\n            }\n            userInfo->extNegList->push_back(extNeg);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SOP Class Extended Negotiation sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_REQ:\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_ACK:\n          if (typeRQorAC == DUL_TYPEASSOCIATERQ)\n            usrIdent = new UserIdentityNegotiationSubItemRQ();\n          else // assume DUL_TYPEASSOCIATEAC\n            usrIdent = new UserIdentityNegotiationSubItemAC();\n          if (usrIdent == NULL) return EC_MemoryExhausted;\n          cond = usrIdent->parseFromBuffer(buf, length /*return value*/, userLength);\n          if (cond.bad())\n          {\n            delete usrIdent;\n            return cond;\n          }\n          userInfo->usrIdent = usrIdent;\n          buf += length;\n          if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n            return makeLengthError(\"User Identity sub-item\", userLength, length);\n          break;\n        default:\n            // we hit an unknown user item that is not defined in the standard\n            // or still unknown to DCMTK\n            cond = parseDummy(buf, &length /* returns bytes \"handled\" by parseDummy */, userLength /* data available in bytes for user item */);\n            if (cond.bad())\n              return cond;\n            // skip the bytes read\n            buf += length;\n            // subtract bytes of parsed data from available data bytes\n            if (OFstatic_cast(unsigned short, length) != length\n                || !OFStandard::safeSubtract(userLength, OFstatic_cast(unsigned short, length), userLength))\n              return makeUnderflowError(\"unknown user item\", userLength, length);\n            break;\n        }\n    }\n\n    return EC_Normal;\n}",
        "func": "static OFCondition\nparseUserInfo(DUL_USERINFO * userInfo,\n              unsigned char *buf,\n              unsigned long *itemLength,\n              unsigned char typeRQorAC,\n              unsigned long availData /* bytes left for in this PDU */)\n{\n    unsigned short userLength;\n    unsigned long length;\n    OFCondition cond = EC_Normal;\n    PRV_SCUSCPROLE *role;\n    SOPClassExtendedNegotiationSubItem *extNeg = NULL;\n    UserIdentityNegotiationSubItem *usrIdent = NULL;\n\n    // minimum allowed size is 4 byte (case where the length of the user data is 0),\n    // else we read past the buffer end\n    if (availData < 4)\n        return makeLengthError(\"user info\", availData, 4);\n\n    // skip item type (50H) field\n    userInfo->type = *buf++;\n    // skip unused (\"reserved\") field\n    userInfo->rsv1 = *buf++;\n    // get and remember announced length of user data\n    EXTRACT_SHORT_BIG(buf, userInfo->length);\n    // .. and skip over the two length field bytes\n    buf += 2;\n\n    // userLength contains announced length of full user item structure,\n    // will be used here to count down the available data later\n    userLength = userInfo->length;\n    // itemLength contains full length of the user item including the 4 bytes extra header (type, reserved + 2 for length)\n    *itemLength = userLength + 4;\n\n    // does this item claim to be larger than the available data?\n    if (availData < *itemLength)\n        return makeLengthError(\"user info\", availData, 0, userLength);\n\n    DCMNET_TRACE(\"Parsing user info field (\"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)userInfo->type\n            << STD_NAMESPACE dec << \"), Length: \" << (unsigned long)userInfo->length);\n    // parse through different types of user items as long as we have data\n    while (userLength > 0) {\n        DCMNET_TRACE(\"Parsing remaining \" << (long)userLength << \" bytes of User Information\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n        switch (*buf) {\n        case DUL_TYPEMAXLENGTH:\n            cond = parseMaxPDU(&userInfo->maxLength, buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"maximum length sub-item\", userLength, length);\n            DCMNET_TRACE(\"Successfully parsed Maximum PDU Length\");\n            break;\n        case DUL_TYPEIMPLEMENTATIONCLASSUID:\n            cond = parseSubItem(&userInfo->implementationClassUID,\n                                buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Class UID sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPEASYNCOPERATIONS:\n            cond = parseDummy(buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"asynchronous operation user item type\", userLength, length);\n            break;\n        case DUL_TYPESCUSCPROLE:\n            role = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));\n            if (role == NULL) return EC_MemoryExhausted;\n            cond = parseSCUSCPRole(role, buf, &length, userLength);\n            if (cond.bad())\n            {\n                free(role);\n                return cond;\n            }\n            LST_Enqueue(&userInfo->SCUSCPRoleList, (LST_NODE*)role);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SCP/SCU Role Selection sub-item\", userLength, length);\n            break;\n        case DUL_TYPEIMPLEMENTATIONVERSIONNAME:\n            cond = parseSubItem(&userInfo->implementationVersionName,\n                                buf, &length, userLength);\n            if (cond.bad()) return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Version Name structure\", userLength, length);\n            break;\n\n        case DUL_TYPESOPCLASSEXTENDEDNEGOTIATION:\n            /* parse an extended negotiation sub-item */\n            extNeg = new SOPClassExtendedNegotiationSubItem;\n            if (extNeg == NULL)  return EC_MemoryExhausted;\n            cond = parseExtNeg(extNeg, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            if (userInfo->extNegList == NULL)\n            {\n                userInfo->extNegList = new SOPClassExtendedNegotiationSubItemList;\n                if (userInfo->extNegList == NULL)  return EC_MemoryExhausted;\n            }\n            userInfo->extNegList->push_back(extNeg);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SOP Class Extended Negotiation sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_REQ:\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_ACK:\n          if (typeRQorAC == DUL_TYPEASSOCIATERQ)\n            usrIdent = new UserIdentityNegotiationSubItemRQ();\n          else // assume DUL_TYPEASSOCIATEAC\n            usrIdent = new UserIdentityNegotiationSubItemAC();\n          if (usrIdent == NULL) return EC_MemoryExhausted;\n          cond = usrIdent->parseFromBuffer(buf, length /*return value*/, userLength);\n          if (cond.bad())\n          {\n            delete usrIdent;\n            return cond;\n          }\n          userInfo->usrIdent = usrIdent;\n          buf += length;\n          if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n            return makeLengthError(\"User Identity sub-item\", userLength, length);\n          break;\n        default:\n            // we hit an unknown user item that is not defined in the standard\n            // or still unknown to DCMTK\n            cond = parseDummy(buf, &length /* returns bytes \"handled\" by parseDummy */, userLength /* data available in bytes for user item */);\n            if (cond.bad())\n              return cond;\n            // skip the bytes read\n            buf += length;\n            // subtract bytes of parsed data from available data bytes\n            if (OFstatic_cast(unsigned short, length) != length\n                || !OFStandard::safeSubtract(userLength, OFstatic_cast(unsigned short, length), userLength))\n              return makeUnderflowError(\"unknown user item\", userLength, length);\n            break;\n        }\n    }\n\n    return EC_Normal;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,7 +76,11 @@\n             role = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));\n             if (role == NULL) return EC_MemoryExhausted;\n             cond = parseSCUSCPRole(role, buf, &length, userLength);\n-            if (cond.bad()) return cond;\n+            if (cond.bad())\n+            {\n+                free(role);\n+                return cond;\n+            }\n             LST_Enqueue(&userInfo->SCUSCPRoleList, (LST_NODE*)role);\n             buf += length;\n             if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))",
        "diff_line_info": {
            "deleted_lines": [
                "            if (cond.bad()) return cond;"
            ],
            "added_lines": [
                "            if (cond.bad())",
                "            {",
                "                free(role);",
                "                return cond;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41687",
        "func_name": "DCMTK/dcmtk/parseAssociate",
        "description": "DCMTK through 3.6.6 does not handle memory free properly. The program malloc a heap memory for parsing data, but does not free it when error in parsing. Sending specific requests to the dcmqrdb program incur the memory leak. An attacker can use it to launch a DoS attack.",
        "git_url": "https://github.com/DCMTK/dcmtk/commit/a9697dfeb672b0b9412c00c7d36d801e27ec85cb",
        "commit_title": "Fixed poss. NULL pointer dereference/double free.",
        "commit_text": " Thanks to Jinsheng Ba <bajinsheng@u.nus.edu> for the report and some patches.",
        "func_before": "OFCondition\nparseAssociate(unsigned char *buf, unsigned long pduLength,\n               PRV_ASSOCIATEPDU * assoc)\n{\n    OFCondition cond = EC_Normal;\n    unsigned char\n        type;\n    unsigned long\n        itemLength;\n    PRV_PRESENTATIONCONTEXTITEM\n        * context;\n\n    (void) memset(assoc, 0, sizeof(*assoc));\n    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    // Check if the PDU actually is long enough for the fields we read\n    if (pduLength < 2 + 2 + 16 + 16 + 32)\n        return makeLengthError(\"associate PDU\", pduLength, 2 + 2 + 16 + 16 + 32);\n\n    assoc->type = *buf++;\n    assoc->rsv1 = *buf++;\n    EXTRACT_LONG_BIG(buf, assoc->length);\n    buf += 4;\n\n    EXTRACT_SHORT_BIG(buf, assoc->protocol);\n    buf += 2;\n    pduLength -= 2;\n    if ((assoc->protocol & DUL_PROTOCOL) == 0)\n    {\n        char buffer[256];\n        sprintf(buffer, \"DUL Unsupported peer protocol %04x; expected %04x in %s\", assoc->protocol, DUL_PROTOCOL, \"parseAssociate\");\n        return makeDcmnetCondition(DULC_UNSUPPORTEDPEERPROTOCOL, OF_error, buffer);\n    }\n    assoc->rsv2[0] = *buf++;\n    pduLength--;\n    assoc->rsv2[1] = *buf++;\n    pduLength--;\n    (void) strncpy(assoc->calledAPTitle, (char *) buf, 16);\n    assoc->calledAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->calledAPTitle);\n\n    buf += 16;\n    pduLength -= 16;\n    (void) strncpy(assoc->callingAPTitle, (char *) buf, 16);\n    assoc->callingAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->callingAPTitle);\n    buf += 16;\n    pduLength -= 16;\n    (void) memcpy(assoc->rsv3, buf, 32);\n    buf += 32;\n    pduLength -= 32;\n\n    if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL)) {\n        const char *s;\n        DCMNET_DEBUG(\"Parsing an A-ASSOCIATE PDU\");\n        if (assoc->type == DUL_TYPEASSOCIATERQ)\n            s = \"A-ASSOCIATE RQ\";\n        else if (assoc->type == DUL_TYPEASSOCIATEAC)\n            s = \"A-ASSOCIATE AC\";\n        else\n            s = \"Unknown: Programming bug in parseAssociate\";\n\n/*      If we hit the \"Unknown type\", there is a programming bug somewhere.\n**      This function is only supposed to parse A-ASSOCIATE PDUs and\n**      expects its input to have been properly screened.\n*/\n        DCMNET_TRACE(\"PDU type: \"\n            << STD_NAMESPACE hex << ((unsigned int)assoc->type)\n            << STD_NAMESPACE dec << \" (\" << s << \"), PDU Length: \" << assoc->length << OFendl\n            << \"DICOM Protocol: \"\n            << STD_NAMESPACE hex << assoc->protocol\n            << STD_NAMESPACE dec << OFendl\n            << \"Called AP Title:  \" << assoc->calledAPTitle << OFendl\n            << \"Calling AP Title: \" << assoc->callingAPTitle);\n    }\n    while ((cond.good()) && (pduLength > 0))\n    {\n        type = *buf;\n        DCMNET_TRACE(\"Parsing remaining \" << pduLength << \" bytes of A-ASSOCIATE PDU\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << ((unsigned int)type));\n        switch (type) {\n        case DUL_TYPEAPPLICATIONCONTEXT:\n            cond = parseSubItem(&assoc->applicationContext,\n                                buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                  return makeUnderflowError(\"Application Context item\", pduLength, itemLength);\n                DCMNET_TRACE(\"Successfully parsed Application Context\");\n            }\n            break;\n        case DUL_TYPEPRESENTATIONCONTEXTRQ:\n        case DUL_TYPEPRESENTATIONCONTEXTAC:\n            context = (PRV_PRESENTATIONCONTEXTITEM*)malloc(sizeof(PRV_PRESENTATIONCONTEXTITEM));\n            if (context == NULL) return EC_MemoryExhausted;\n            (void) memset(context, 0, sizeof(*context));\n            cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n            if (cond.bad()) return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);\n            LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n            DCMNET_TRACE(\"Successfully parsed Presentation Context\");\n            break;\n        case DUL_TYPEUSERINFO:\n            // parse user info, which can contain several sub-items like User\n            // Identity Negotiation or SOP Class Extended Negotiation\n            cond = parseUserInfo(&assoc->userInfo, buf, &itemLength, assoc->type, pduLength);\n            if (cond.bad())\n                return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\"User Information item\", pduLength, itemLength);\n            DCMNET_TRACE(\"Successfully parsed User Information\");\n            break;\n        default:\n            cond = parseDummy(buf, &itemLength, pduLength);\n            if (cond.bad())\n                return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\"unknown item type\", pduLength, itemLength);\n            break;\n        }\n    }\n    return cond;\n}",
        "func": "OFCondition\nparseAssociate(unsigned char *buf, unsigned long pduLength,\n               PRV_ASSOCIATEPDU * assoc)\n{\n    OFCondition cond = EC_Normal;\n    unsigned char\n        type;\n    unsigned long\n        itemLength;\n    PRV_PRESENTATIONCONTEXTITEM\n        * context;\n\n    (void) memset(assoc, 0, sizeof(*assoc));\n    // Check if the PDU actually is long enough for the fields we read\n    if (pduLength < 2 + 2 + 16 + 16 + 32)\n        return makeLengthError(\"associate PDU\", pduLength, 2 + 2 + 16 + 16 + 32);\n\n    assoc->type = *buf++;\n    assoc->rsv1 = *buf++;\n    EXTRACT_LONG_BIG(buf, assoc->length);\n    buf += 4;\n\n    EXTRACT_SHORT_BIG(buf, assoc->protocol);\n    buf += 2;\n    pduLength -= 2;\n    if ((assoc->protocol & DUL_PROTOCOL) == 0)\n    {\n        char buffer[256];\n        sprintf(buffer, \"DUL Unsupported peer protocol %04x; expected %04x in %s\", assoc->protocol, DUL_PROTOCOL, \"parseAssociate\");\n        return makeDcmnetCondition(DULC_UNSUPPORTEDPEERPROTOCOL, OF_error, buffer);\n    }\n    assoc->rsv2[0] = *buf++;\n    pduLength--;\n    assoc->rsv2[1] = *buf++;\n    pduLength--;\n    (void) strncpy(assoc->calledAPTitle, (char *) buf, 16);\n    assoc->calledAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->calledAPTitle);\n\n    buf += 16;\n    pduLength -= 16;\n    (void) strncpy(assoc->callingAPTitle, (char *) buf, 16);\n    assoc->callingAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->callingAPTitle);\n    buf += 16;\n    pduLength -= 16;\n    (void) memcpy(assoc->rsv3, buf, 32);\n    buf += 32;\n    pduLength -= 32;\n\n    if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL)) {\n        const char *s;\n        DCMNET_DEBUG(\"Parsing an A-ASSOCIATE PDU\");\n        if (assoc->type == DUL_TYPEASSOCIATERQ)\n            s = \"A-ASSOCIATE RQ\";\n        else if (assoc->type == DUL_TYPEASSOCIATEAC)\n            s = \"A-ASSOCIATE AC\";\n        else\n            s = \"Unknown: Programming bug in parseAssociate\";\n\n/*      If we hit the \"Unknown type\", there is a programming bug somewhere.\n**      This function is only supposed to parse A-ASSOCIATE PDUs and\n**      expects its input to have been properly screened.\n*/\n        DCMNET_TRACE(\"PDU type: \"\n            << STD_NAMESPACE hex << ((unsigned int)assoc->type)\n            << STD_NAMESPACE dec << \" (\" << s << \"), PDU Length: \" << assoc->length << OFendl\n            << \"DICOM Protocol: \"\n            << STD_NAMESPACE hex << assoc->protocol\n            << STD_NAMESPACE dec << OFendl\n            << \"Called AP Title:  \" << assoc->calledAPTitle << OFendl\n            << \"Calling AP Title: \" << assoc->callingAPTitle);\n    }\n    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    while ((cond.good()) && (pduLength > 0))\n    {\n        type = *buf;\n        DCMNET_TRACE(\"Parsing remaining \" << pduLength << \" bytes of A-ASSOCIATE PDU\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << ((unsigned int)type));\n        switch (type) {\n        case DUL_TYPEAPPLICATIONCONTEXT:\n            cond = parseSubItem(&assoc->applicationContext,\n                                buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                {\n                    cond = makeUnderflowError(\"Application Context item\", pduLength, itemLength);\n                }\n                else\n                {\n                    DCMNET_TRACE(\"Successfully parsed Application Context\");\n                }\n            }\n            break;\n        case DUL_TYPEPRESENTATIONCONTEXTRQ:\n        case DUL_TYPEPRESENTATIONCONTEXTAC:\n            context = (PRV_PRESENTATIONCONTEXTITEM*)malloc(sizeof(PRV_PRESENTATIONCONTEXTITEM));\n            if (context != NULL)\n            {\n                (void) memset(context, 0, sizeof(*context));\n                cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n                if (cond.bad())\n                {\n                    free(context);\n                }\n                else\n                {\n                    buf += itemLength;\n                    if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                    {\n                        cond =  makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);\n                    }\n                    else\n                    {\n                        LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n                        DCMNET_TRACE(\"Successfully parsed Presentation Context\");\n                    }\n                }\n            }\n            else\n            {\n                cond = EC_MemoryExhausted;\n            }\n            break;\n        case DUL_TYPEUSERINFO:\n            // parse user info, which can contain several sub-items like User\n            // Identity Negotiation or SOP Class Extended Negotiation\n            cond = parseUserInfo(&assoc->userInfo, buf, &itemLength, assoc->type, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                {\n                    cond = makeUnderflowError(\"User Information item\", pduLength, itemLength);\n                }\n                else\n                {\n                    DCMNET_TRACE(\"Successfully parsed User Information\");\n                }\n            }\n            break;\n        default:\n            cond = parseDummy(buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                {\n                    cond = makeUnderflowError(\"unknown item type\", pduLength, itemLength);\n                }\n            }\n            break;\n        }\n    }\n    if (cond.bad())\n    {\n      destroyPresentationContextList(&assoc->presentationContextList);\n      destroyUserInformationLists(&assoc->userInfo);\n    }\n    return cond;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,9 +11,6 @@\n         * context;\n \n     (void) memset(assoc, 0, sizeof(*assoc));\n-    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n-    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n-\n     // Check if the PDU actually is long enough for the fields we read\n     if (pduLength < 2 + 2 + 16 + 16 + 32)\n         return makeLengthError(\"associate PDU\", pduLength, 2 + 2 + 16 + 16 + 32);\n@@ -74,6 +71,8 @@\n             << \"Called AP Title:  \" << assoc->calledAPTitle << OFendl\n             << \"Calling AP Title: \" << assoc->callingAPTitle);\n     }\n+    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n+    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n     while ((cond.good()) && (pduLength > 0))\n     {\n         type = *buf;\n@@ -88,43 +87,79 @@\n             {\n                 buf += itemLength;\n                 if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n-                  return makeUnderflowError(\"Application Context item\", pduLength, itemLength);\n-                DCMNET_TRACE(\"Successfully parsed Application Context\");\n+                {\n+                    cond = makeUnderflowError(\"Application Context item\", pduLength, itemLength);\n+                }\n+                else\n+                {\n+                    DCMNET_TRACE(\"Successfully parsed Application Context\");\n+                }\n             }\n             break;\n         case DUL_TYPEPRESENTATIONCONTEXTRQ:\n         case DUL_TYPEPRESENTATIONCONTEXTAC:\n             context = (PRV_PRESENTATIONCONTEXTITEM*)malloc(sizeof(PRV_PRESENTATIONCONTEXTITEM));\n-            if (context == NULL) return EC_MemoryExhausted;\n-            (void) memset(context, 0, sizeof(*context));\n-            cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n-            if (cond.bad()) return cond;\n-            buf += itemLength;\n-            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n-              return makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);\n-            LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n-            DCMNET_TRACE(\"Successfully parsed Presentation Context\");\n+            if (context != NULL)\n+            {\n+                (void) memset(context, 0, sizeof(*context));\n+                cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n+                if (cond.bad())\n+                {\n+                    free(context);\n+                }\n+                else\n+                {\n+                    buf += itemLength;\n+                    if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n+                    {\n+                        cond =  makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);\n+                    }\n+                    else\n+                    {\n+                        LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n+                        DCMNET_TRACE(\"Successfully parsed Presentation Context\");\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                cond = EC_MemoryExhausted;\n+            }\n             break;\n         case DUL_TYPEUSERINFO:\n             // parse user info, which can contain several sub-items like User\n             // Identity Negotiation or SOP Class Extended Negotiation\n             cond = parseUserInfo(&assoc->userInfo, buf, &itemLength, assoc->type, pduLength);\n-            if (cond.bad())\n-                return cond;\n-            buf += itemLength;\n-            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n-              return makeUnderflowError(\"User Information item\", pduLength, itemLength);\n-            DCMNET_TRACE(\"Successfully parsed User Information\");\n+            if (cond.good())\n+            {\n+                buf += itemLength;\n+                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n+                {\n+                    cond = makeUnderflowError(\"User Information item\", pduLength, itemLength);\n+                }\n+                else\n+                {\n+                    DCMNET_TRACE(\"Successfully parsed User Information\");\n+                }\n+            }\n             break;\n         default:\n             cond = parseDummy(buf, &itemLength, pduLength);\n-            if (cond.bad())\n-                return cond;\n-            buf += itemLength;\n-            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n-              return makeUnderflowError(\"unknown item type\", pduLength, itemLength);\n+            if (cond.good())\n+            {\n+                buf += itemLength;\n+                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n+                {\n+                    cond = makeUnderflowError(\"unknown item type\", pduLength, itemLength);\n+                }\n+            }\n             break;\n         }\n     }\n+    if (cond.bad())\n+    {\n+      destroyPresentationContextList(&assoc->presentationContextList);\n+      destroyUserInformationLists(&assoc->userInfo);\n+    }\n     return cond;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;",
                "    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;",
                "",
                "                  return makeUnderflowError(\"Application Context item\", pduLength, itemLength);",
                "                DCMNET_TRACE(\"Successfully parsed Application Context\");",
                "            if (context == NULL) return EC_MemoryExhausted;",
                "            (void) memset(context, 0, sizeof(*context));",
                "            cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);",
                "            if (cond.bad()) return cond;",
                "            buf += itemLength;",
                "            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "              return makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);",
                "            LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);",
                "            DCMNET_TRACE(\"Successfully parsed Presentation Context\");",
                "            if (cond.bad())",
                "                return cond;",
                "            buf += itemLength;",
                "            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "              return makeUnderflowError(\"User Information item\", pduLength, itemLength);",
                "            DCMNET_TRACE(\"Successfully parsed User Information\");",
                "            if (cond.bad())",
                "                return cond;",
                "            buf += itemLength;",
                "            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "              return makeUnderflowError(\"unknown item type\", pduLength, itemLength);"
            ],
            "added_lines": [
                "    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;",
                "    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;",
                "                {",
                "                    cond = makeUnderflowError(\"Application Context item\", pduLength, itemLength);",
                "                }",
                "                else",
                "                {",
                "                    DCMNET_TRACE(\"Successfully parsed Application Context\");",
                "                }",
                "            if (context != NULL)",
                "            {",
                "                (void) memset(context, 0, sizeof(*context));",
                "                cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);",
                "                if (cond.bad())",
                "                {",
                "                    free(context);",
                "                }",
                "                else",
                "                {",
                "                    buf += itemLength;",
                "                    if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "                    {",
                "                        cond =  makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);",
                "                    }",
                "                    else",
                "                    {",
                "                        LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);",
                "                        DCMNET_TRACE(\"Successfully parsed Presentation Context\");",
                "                    }",
                "                }",
                "            }",
                "            else",
                "            {",
                "                cond = EC_MemoryExhausted;",
                "            }",
                "            if (cond.good())",
                "            {",
                "                buf += itemLength;",
                "                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "                {",
                "                    cond = makeUnderflowError(\"User Information item\", pduLength, itemLength);",
                "                }",
                "                else",
                "                {",
                "                    DCMNET_TRACE(\"Successfully parsed User Information\");",
                "                }",
                "            }",
                "            if (cond.good())",
                "            {",
                "                buf += itemLength;",
                "                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "                {",
                "                    cond = makeUnderflowError(\"unknown item type\", pduLength, itemLength);",
                "                }",
                "            }",
                "    if (cond.bad())",
                "    {",
                "      destroyPresentationContextList(&assoc->presentationContextList);",
                "      destroyUserInformationLists(&assoc->userInfo);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41687",
        "func_name": "DCMTK/dcmtk/ASC_destroyAssociation",
        "description": "DCMTK through 3.6.6 does not handle memory free properly. The program malloc a heap memory for parsing data, but does not free it when error in parsing. Sending specific requests to the dcmqrdb program incur the memory leak. An attacker can use it to launch a DoS attack.",
        "git_url": "https://github.com/DCMTK/dcmtk/commit/a9697dfeb672b0b9412c00c7d36d801e27ec85cb",
        "commit_title": "Fixed poss. NULL pointer dereference/double free.",
        "commit_text": " Thanks to Jinsheng Ba <bajinsheng@u.nus.edu> for the report and some patches.",
        "func_before": "OFCondition\nASC_destroyAssociation(T_ASC_Association ** association)\n{\n    OFCondition cond = EC_Normal;\n\n    /* don't worry if already destroyed */\n    if (association == NULL) return EC_Normal;\n    if (*association == NULL) return EC_Normal;\n\n    if ((*association)->DULassociation != NULL) {\n        ASC_dropAssociation(*association);\n    }\n\n    if ((*association)->params != NULL) {\n        cond = ASC_destroyAssociationParameters(&(*association)->params);\n        if (cond.bad()) return cond;\n    }\n\n    if ((*association)->sendPDVBuffer != NULL)\n        free((*association)->sendPDVBuffer);\n\n    free(*association);\n    *association = NULL;\n\n    return EC_Normal;\n}",
        "func": "OFCondition\nASC_destroyAssociation(T_ASC_Association ** association)\n{\n    OFCondition cond = EC_Normal;\n\n    /* don't worry if already destroyed */\n    if (association == NULL) return EC_Normal;\n    if (*association == NULL) return EC_Normal;\n\n    if ((*association)->DULassociation != NULL) {\n        ASC_dropAssociation(*association);\n    }\n\n    if ((*association)->params != NULL) {\n        ASC_destroyAssociationParameters(&(*association)->params);\n    }\n\n    if ((*association)->sendPDVBuffer != NULL)\n        free((*association)->sendPDVBuffer);\n\n    free(*association);\n    *association = NULL;\n\n    return EC_Normal;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,7 @@\n     }\n \n     if ((*association)->params != NULL) {\n-        cond = ASC_destroyAssociationParameters(&(*association)->params);\n-        if (cond.bad()) return cond;\n+        ASC_destroyAssociationParameters(&(*association)->params);\n     }\n \n     if ((*association)->sendPDVBuffer != NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "        cond = ASC_destroyAssociationParameters(&(*association)->params);",
                "        if (cond.bad()) return cond;"
            ],
            "added_lines": [
                "        ASC_destroyAssociationParameters(&(*association)->params);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26365",
        "func_name": "xen-project/xen/parse_nic_config",
        "description": "Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Linux Block and Network PV device frontends don't zero memory regions before sharing them with the backend (CVE-2022-26365, CVE-2022-33740). Additionally the granularity of the grant table doesn't allow sharing less than a 4K page, leading to unrelated data residing in the same 4K page as data shared with a backend being accessible by such backend (CVE-2022-33741, CVE-2022-33742).",
        "git_url": "https://github.com/xen-project/xen/commit/54d8f27d0477937e1f99a414fc1ffd93d184b38a",
        "commit_title": "tools/libxl: report trusted backend status to frontends",
        "commit_text": " Allow administrators to notify a frontend driver that it's backend counterpart is not to be trusted, so the frontend can deploy whatever mitigations required in order to secure itself.  Allow such option for disk and network frontends only, as those are the only hardened ones currently supported.  This is part of XSA-403 ",
        "func_before": "int parse_nic_config(libxl_device_nic *nic, XLU_Config **config, char *token)\n{\n    char *endptr, *oparg;\n    int i;\n    unsigned int val;\n\n    if (MATCH_OPTION(\"type\", token, oparg)) {\n        if (!strcmp(\"vif\", oparg)) {\n            nic->nictype = LIBXL_NIC_TYPE_VIF;\n        } else if (!strcmp(\"ioemu\", oparg)) {\n            nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n        } else {\n            fprintf(stderr, \"Invalid parameter `type'.\\n\");\n            return 1;\n        }\n    } else if (MATCH_OPTION(\"mac\", token, oparg)) {\n        for (i = 0; i < 6; i++) {\n            val = strtoul(oparg, &endptr, 16);\n            if ((oparg == endptr) || (val > 255)) {\n                fprintf(stderr, \"Invalid parameter `mac'.\\n\");\n                return 1;\n            }\n            nic->mac[i] = val;\n            oparg = endptr + 1;\n        }\n    } else if (MATCH_OPTION(\"bridge\", token, oparg)) {\n        replace_string(&nic->bridge, oparg);\n    } else if (MATCH_OPTION(\"netdev\", token, oparg)) {\n        fprintf(stderr, \"the netdev parameter is deprecated, \"\n                        \"please use gatewaydev instead\\n\");\n        replace_string(&nic->gatewaydev, oparg);\n    } else if (MATCH_OPTION(\"gatewaydev\", token, oparg)) {\n        replace_string(&nic->gatewaydev, oparg);\n    } else if (MATCH_OPTION(\"ip\", token, oparg)) {\n        replace_string(&nic->ip, oparg);\n    } else if (MATCH_OPTION(\"script\", token, oparg)) {\n        replace_string(&nic->script, oparg);\n    } else if (MATCH_OPTION(\"backend\", token, oparg)) {\n        replace_string(&nic->backend_domname, oparg);\n    } else if (MATCH_OPTION(\"vifname\", token, oparg)) {\n        replace_string(&nic->ifname, oparg);\n    } else if (MATCH_OPTION(\"model\", token, oparg)) {\n        replace_string(&nic->model, oparg);\n    } else if (MATCH_OPTION(\"rate\", token, oparg)) {\n        parse_vif_rate(config, oparg, nic);\n    } else if (MATCH_OPTION(\"forwarddev\", token, oparg)) {\n        replace_string(&nic->coloft_forwarddev, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_mirror_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_mirror_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_mirror_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_mirror_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_mirror_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_mirror_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_sec_in_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_sec_in_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_sec_in_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_sec_in_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_sec_in_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_sec_in_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector0_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector0_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector0_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector0_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector0_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector0_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector1_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector1_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector1_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector1_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector1_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector1_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector2_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector2_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector2_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector2_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector2_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector2_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_pri_in_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_pri_in_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_pri_in_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_pri_in_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_pri_in_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_pri_in_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_notify_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_notify_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_notify_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_notify_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_notify_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_notify_port, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_mirror_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_mirror_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_mirror_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_mirror_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector0_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector0_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector0_indev\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector0_indev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector0_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector0_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector1_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector1_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector1_indev\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector1_indev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector1_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector1_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_compare_pri_in\", token, oparg)) {\n        replace_string(&nic->colo_compare_pri_in, oparg);\n    } else if (MATCH_OPTION(\"colo_compare_sec_in\", token, oparg)) {\n        replace_string(&nic->colo_compare_sec_in, oparg);\n    } else if (MATCH_OPTION(\"colo_compare_out\", token, oparg)) {\n        replace_string(&nic->colo_compare_out, oparg);\n    } else if (MATCH_OPTION(\"colo_compare_notify_dev\", token, oparg)) {\n        replace_string(&nic->colo_compare_notify_dev, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector0_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector0_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector0_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector0_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector0_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector0_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector1_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector1_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector1_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector1_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector1_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector1_port, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector0_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector0_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector0_indev\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector0_indev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector0_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector0_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector1_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector1_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector1_indev\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector1_indev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector1_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector1_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_rewriter0_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_rewriter0_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_checkpoint_host\", token, oparg)) {\n        replace_string(&nic->colo_checkpoint_host, oparg);\n    } else if (MATCH_OPTION(\"colo_checkpoint_port\", token, oparg)) {\n        replace_string(&nic->colo_checkpoint_port, oparg);\n    } else if (MATCH_OPTION(\"accel\", token, oparg)) {\n        fprintf(stderr, \"the accel parameter for vifs is currently not supported\\n\");\n    } else if (MATCH_OPTION(\"devid\", token, oparg)) {\n        nic->devid = parse_ulong(oparg);\n    } else if (MATCH_OPTION(\"mtu\", token, oparg)) {\n        nic->mtu = parse_ulong(oparg);\n    } else {\n        fprintf(stderr, \"unrecognized argument `%s'\\n\", token);\n        return 1;\n    }\n    return 0;\n}",
        "func": "int parse_nic_config(libxl_device_nic *nic, XLU_Config **config, char *token)\n{\n    char *endptr, *oparg;\n    int i;\n    unsigned int val;\n\n    if (MATCH_OPTION(\"type\", token, oparg)) {\n        if (!strcmp(\"vif\", oparg)) {\n            nic->nictype = LIBXL_NIC_TYPE_VIF;\n        } else if (!strcmp(\"ioemu\", oparg)) {\n            nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n        } else {\n            fprintf(stderr, \"Invalid parameter `type'.\\n\");\n            return 1;\n        }\n    } else if (MATCH_OPTION(\"mac\", token, oparg)) {\n        for (i = 0; i < 6; i++) {\n            val = strtoul(oparg, &endptr, 16);\n            if ((oparg == endptr) || (val > 255)) {\n                fprintf(stderr, \"Invalid parameter `mac'.\\n\");\n                return 1;\n            }\n            nic->mac[i] = val;\n            oparg = endptr + 1;\n        }\n    } else if (MATCH_OPTION(\"bridge\", token, oparg)) {\n        replace_string(&nic->bridge, oparg);\n    } else if (MATCH_OPTION(\"netdev\", token, oparg)) {\n        fprintf(stderr, \"the netdev parameter is deprecated, \"\n                        \"please use gatewaydev instead\\n\");\n        replace_string(&nic->gatewaydev, oparg);\n    } else if (MATCH_OPTION(\"gatewaydev\", token, oparg)) {\n        replace_string(&nic->gatewaydev, oparg);\n    } else if (MATCH_OPTION(\"ip\", token, oparg)) {\n        replace_string(&nic->ip, oparg);\n    } else if (MATCH_OPTION(\"script\", token, oparg)) {\n        replace_string(&nic->script, oparg);\n    } else if (MATCH_OPTION(\"backend\", token, oparg)) {\n        replace_string(&nic->backend_domname, oparg);\n    } else if (MATCH_OPTION(\"vifname\", token, oparg)) {\n        replace_string(&nic->ifname, oparg);\n    } else if (MATCH_OPTION(\"model\", token, oparg)) {\n        replace_string(&nic->model, oparg);\n    } else if (MATCH_OPTION(\"rate\", token, oparg)) {\n        parse_vif_rate(config, oparg, nic);\n    } else if (MATCH_OPTION(\"forwarddev\", token, oparg)) {\n        replace_string(&nic->coloft_forwarddev, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_mirror_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_mirror_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_mirror_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_mirror_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_mirror_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_mirror_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_sec_in_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_sec_in_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_sec_in_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_sec_in_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_sec_in_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_sec_in_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector0_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector0_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector0_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector0_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector0_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector0_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector1_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector1_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector1_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector1_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector1_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector1_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector2_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector2_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector2_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector2_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_redirector2_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_redirector2_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_pri_in_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_pri_in_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_pri_in_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_pri_in_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_pri_in_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_pri_in_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_notify_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_notify_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_notify_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_notify_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_compare_notify_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_compare_notify_port, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_mirror_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_mirror_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_mirror_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_mirror_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector0_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector0_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector0_indev\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector0_indev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector0_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector0_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector1_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector1_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector1_indev\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector1_indev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_redirector1_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_redirector1_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_compare_pri_in\", token, oparg)) {\n        replace_string(&nic->colo_compare_pri_in, oparg);\n    } else if (MATCH_OPTION(\"colo_compare_sec_in\", token, oparg)) {\n        replace_string(&nic->colo_compare_sec_in, oparg);\n    } else if (MATCH_OPTION(\"colo_compare_out\", token, oparg)) {\n        replace_string(&nic->colo_compare_out, oparg);\n    } else if (MATCH_OPTION(\"colo_compare_notify_dev\", token, oparg)) {\n        replace_string(&nic->colo_compare_notify_dev, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector0_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector0_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector0_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector0_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector0_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector0_port, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector1_id\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector1_id, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector1_ip\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector1_ip, oparg);\n    } else if (MATCH_OPTION(\"colo_sock_sec_redirector1_port\", token, oparg)) {\n        replace_string(&nic->colo_sock_sec_redirector1_port, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector0_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector0_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector0_indev\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector0_indev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector0_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector0_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector1_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector1_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector1_indev\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector1_indev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_redirector1_outdev\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_redirector1_outdev, oparg);\n    } else if (MATCH_OPTION(\"colo_filter_sec_rewriter0_queue\", token, oparg)) {\n        replace_string(&nic->colo_filter_sec_rewriter0_queue, oparg);\n    } else if (MATCH_OPTION(\"colo_checkpoint_host\", token, oparg)) {\n        replace_string(&nic->colo_checkpoint_host, oparg);\n    } else if (MATCH_OPTION(\"colo_checkpoint_port\", token, oparg)) {\n        replace_string(&nic->colo_checkpoint_port, oparg);\n    } else if (MATCH_OPTION(\"accel\", token, oparg)) {\n        fprintf(stderr, \"the accel parameter for vifs is currently not supported\\n\");\n    } else if (MATCH_OPTION(\"devid\", token, oparg)) {\n        nic->devid = parse_ulong(oparg);\n    } else if (MATCH_OPTION(\"mtu\", token, oparg)) {\n        nic->mtu = parse_ulong(oparg);\n    } else if (!strcmp(\"trusted\", token)) {\n        libxl_defbool_set(&nic->trusted, true);\n    } else if (!strcmp(\"untrusted\", token)) {\n        libxl_defbool_set(&nic->trusted, false);\n    } else {\n        fprintf(stderr, \"unrecognized argument `%s'\\n\", token);\n        return 1;\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -147,6 +147,10 @@\n         nic->devid = parse_ulong(oparg);\n     } else if (MATCH_OPTION(\"mtu\", token, oparg)) {\n         nic->mtu = parse_ulong(oparg);\n+    } else if (!strcmp(\"trusted\", token)) {\n+        libxl_defbool_set(&nic->trusted, true);\n+    } else if (!strcmp(\"untrusted\", token)) {\n+        libxl_defbool_set(&nic->trusted, false);\n     } else {\n         fprintf(stderr, \"unrecognized argument `%s'\\n\", token);\n         return 1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    } else if (!strcmp(\"trusted\", token)) {",
                "        libxl_defbool_set(&nic->trusted, true);",
                "    } else if (!strcmp(\"untrusted\", token)) {",
                "        libxl_defbool_set(&nic->trusted, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26365",
        "func_name": "xen-project/xen/libxl__device_disk_setdefault",
        "description": "Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Linux Block and Network PV device frontends don't zero memory regions before sharing them with the backend (CVE-2022-26365, CVE-2022-33740). Additionally the granularity of the grant table doesn't allow sharing less than a 4K page, leading to unrelated data residing in the same 4K page as data shared with a backend being accessible by such backend (CVE-2022-33741, CVE-2022-33742).",
        "git_url": "https://github.com/xen-project/xen/commit/54d8f27d0477937e1f99a414fc1ffd93d184b38a",
        "commit_title": "tools/libxl: report trusted backend status to frontends",
        "commit_text": " Allow administrators to notify a frontend driver that it's backend counterpart is not to be trusted, so the frontend can deploy whatever mitigations required in order to secure itself.  Allow such option for disk and network frontends only, as those are the only hardened ones currently supported.  This is part of XSA-403 ",
        "func_before": "static int libxl__device_disk_setdefault(libxl__gc *gc, uint32_t domid,\n                                         libxl_device_disk *disk, bool hotplug)\n{\n    int rc;\n\n    libxl_defbool_setdefault(&disk->discard_enable, !!disk->readwrite);\n    libxl_defbool_setdefault(&disk->colo_enable, false);\n    libxl_defbool_setdefault(&disk->colo_restore_enable, false);\n\n    rc = libxl__resolve_domid(gc, disk->backend_domname, &disk->backend_domid);\n    if (rc < 0) return rc;\n\n    /* Force Qdisk backend for CDROM devices of guests with a device model. */\n    if (disk->is_cdrom != 0 &&\n        libxl__domain_type(gc, domid) == LIBXL_DOMAIN_TYPE_HVM) {\n        if (!(disk->backend == LIBXL_DISK_BACKEND_QDISK ||\n              disk->backend == LIBXL_DISK_BACKEND_UNKNOWN)) {\n            LOGD(ERROR, domid, \"Backend for CD devices on HVM guests must be Qdisk\");\n            return ERROR_FAIL;\n        }\n        disk->backend = LIBXL_DISK_BACKEND_QDISK;\n    }\n\n    rc = libxl__device_disk_set_backend(gc, disk);\n    return rc;\n}",
        "func": "static int libxl__device_disk_setdefault(libxl__gc *gc, uint32_t domid,\n                                         libxl_device_disk *disk, bool hotplug)\n{\n    int rc;\n\n    libxl_defbool_setdefault(&disk->discard_enable, !!disk->readwrite);\n    libxl_defbool_setdefault(&disk->colo_enable, false);\n    libxl_defbool_setdefault(&disk->colo_restore_enable, false);\n    libxl_defbool_setdefault(&disk->trusted, true);\n\n    rc = libxl__resolve_domid(gc, disk->backend_domname, &disk->backend_domid);\n    if (rc < 0) return rc;\n\n    /* Force Qdisk backend for CDROM devices of guests with a device model. */\n    if (disk->is_cdrom != 0 &&\n        libxl__domain_type(gc, domid) == LIBXL_DOMAIN_TYPE_HVM) {\n        if (!(disk->backend == LIBXL_DISK_BACKEND_QDISK ||\n              disk->backend == LIBXL_DISK_BACKEND_UNKNOWN)) {\n            LOGD(ERROR, domid, \"Backend for CD devices on HVM guests must be Qdisk\");\n            return ERROR_FAIL;\n        }\n        disk->backend = LIBXL_DISK_BACKEND_QDISK;\n    }\n\n    rc = libxl__device_disk_set_backend(gc, disk);\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n     libxl_defbool_setdefault(&disk->discard_enable, !!disk->readwrite);\n     libxl_defbool_setdefault(&disk->colo_enable, false);\n     libxl_defbool_setdefault(&disk->colo_restore_enable, false);\n+    libxl_defbool_setdefault(&disk->trusted, true);\n \n     rc = libxl__resolve_domid(gc, disk->backend_domname, &disk->backend_domid);\n     if (rc < 0) return rc;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    libxl_defbool_setdefault(&disk->trusted, true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26365",
        "func_name": "xen-project/xen/device_disk_add",
        "description": "Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Linux Block and Network PV device frontends don't zero memory regions before sharing them with the backend (CVE-2022-26365, CVE-2022-33740). Additionally the granularity of the grant table doesn't allow sharing less than a 4K page, leading to unrelated data residing in the same 4K page as data shared with a backend being accessible by such backend (CVE-2022-33741, CVE-2022-33742).",
        "git_url": "https://github.com/xen-project/xen/commit/54d8f27d0477937e1f99a414fc1ffd93d184b38a",
        "commit_title": "tools/libxl: report trusted backend status to frontends",
        "commit_text": " Allow administrators to notify a frontend driver that it's backend counterpart is not to be trusted, so the frontend can deploy whatever mitigations required in order to secure itself.  Allow such option for disk and network frontends only, as those are the only hardened ones currently supported.  This is part of XSA-403 ",
        "func_before": "static void device_disk_add(libxl__egc *egc, uint32_t domid,\n                           libxl_device_disk *disk,\n                           libxl__ao_device *aodev,\n                           char *get_vdev(libxl__gc *, void *,\n                                          xs_transaction_t),\n                           void *get_vdev_user)\n{\n    STATE_AO_GC(aodev->ao);\n    flexarray_t *front = NULL;\n    flexarray_t *back = NULL;\n    char *dev = NULL, *script;\n    libxl__device *device;\n    int rc;\n    libxl_ctx *ctx = gc->owner;\n    xs_transaction_t t = XBT_NULL;\n    libxl_domain_config d_config;\n    libxl_device_disk disk_saved;\n    libxl__flock *lock = NULL;\n\n    libxl_domain_config_init(&d_config);\n    libxl_device_disk_init(&disk_saved);\n    libxl_device_disk_copy(ctx, &disk_saved, disk);\n\n    libxl_domain_type type = libxl__domain_type(gc, domid);\n    if (type == LIBXL_DOMAIN_TYPE_INVALID) {\n        rc = ERROR_FAIL;\n        goto out;\n    }\n\n    /*\n     * get_vdev != NULL -> local attach\n     * get_vdev == NULL -> block attach\n     *\n     * We don't care about local attach state because it's only\n     * intermediate state.\n     */\n    if (!get_vdev && aodev->update_json) {\n        lock = libxl__lock_domain_userdata(gc, domid);\n        if (!lock) {\n            rc = ERROR_LOCK_FAIL;\n            goto out;\n        }\n\n        rc = libxl__get_domain_configuration(gc, domid, &d_config);\n        if (rc) goto out;\n\n        device_add_domain_config(gc, &d_config, &libxl__disk_devtype,\n                                 &disk_saved);\n\n        rc = libxl__dm_check_start(gc, &d_config, domid);\n        if (rc) goto out;\n    }\n\n    for (;;) {\n        rc = libxl__xs_transaction_start(gc, &t);\n        if (rc) goto out;\n\n        if (get_vdev) {\n            assert(get_vdev_user);\n            disk->vdev = get_vdev(gc, get_vdev_user, t);\n            if (disk->vdev == NULL) {\n                rc = ERROR_FAIL;\n                goto out;\n            }\n        }\n\n        rc = libxl__device_disk_setdefault(gc, domid, disk, aodev->update_json);\n        if (rc) goto out;\n\n        front = flexarray_make(gc, 16, 1);\n        back = flexarray_make(gc, 16, 1);\n\n        GCNEW(device);\n        rc = libxl__device_from_disk(gc, domid, disk, device);\n        if (rc != 0) {\n            LOGD(ERROR, domid, \"Invalid or unsupported\"\" virtual disk identifier %s\",\n                 disk->vdev);\n            goto out;\n        }\n\n        rc = libxl__device_exists(gc, t, device);\n        if (rc < 0) goto out;\n        if (rc == 1) {              /* already exists in xenstore */\n            LOGD(ERROR, domid, \"device already exists in xenstore\");\n            aodev->action = LIBXL__DEVICE_ACTION_ADD; /* for error message */\n            rc = ERROR_DEVICE_EXISTS;\n            goto out;\n        }\n\n        switch (disk->backend) {\n            case LIBXL_DISK_BACKEND_PHY:\n                dev = disk->pdev_path;\n\n                flexarray_append(back, \"params\");\n                flexarray_append(back, dev);\n\n                script = libxl__abs_path(gc, disk->script?: \"block\",\n                                         libxl__xen_script_dir_path());\n                flexarray_append_pair(back, \"script\", script);\n\n                assert(device->backend_kind == LIBXL__DEVICE_KIND_VBD);\n                break;\n\n            case LIBXL_DISK_BACKEND_TAP:\n                LOG(ERROR, \"blktap is not supported\");\n                rc = ERROR_FAIL;\n                goto out;\n            case LIBXL_DISK_BACKEND_QDISK:\n                flexarray_append(back, \"params\");\n                flexarray_append(back, GCSPRINTF(\"%s:%s\",\n                              libxl__device_disk_string_of_format(disk->format),\n                              disk->pdev_path ? : \"\"));\n                if (libxl_defbool_val(disk->colo_enable)) {\n                    flexarray_append(back, \"colo-host\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%s\", disk->colo_host));\n                    flexarray_append(back, \"colo-port\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%d\", disk->colo_port));\n                    flexarray_append(back, \"colo-export\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%s\", disk->colo_export));\n                    flexarray_append(back, \"active-disk\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%s\", disk->active_disk));\n                    flexarray_append(back, \"hidden-disk\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%s\", disk->hidden_disk));\n                }\n                assert(device->backend_kind == LIBXL__DEVICE_KIND_QDISK);\n                break;\n            default:\n                LOGD(ERROR, domid, \"Unrecognized disk backend type: %d\",\n                     disk->backend);\n                rc = ERROR_INVAL;\n                goto out;\n        }\n\n        flexarray_append(back, \"frontend-id\");\n        flexarray_append(back, GCSPRINTF(\"%d\", domid));\n        flexarray_append(back, \"online\");\n        flexarray_append(back, \"1\");\n        flexarray_append(back, \"removable\");\n        flexarray_append(back, GCSPRINTF(\"%d\", (disk->removable) ? 1 : 0));\n        flexarray_append(back, \"bootable\");\n        flexarray_append(back, GCSPRINTF(\"%d\", 1));\n        flexarray_append(back, \"state\");\n        flexarray_append(back, GCSPRINTF(\"%d\", XenbusStateInitialising));\n        flexarray_append(back, \"dev\");\n        flexarray_append(back, disk->vdev);\n        flexarray_append(back, \"type\");\n        flexarray_append(back, libxl__device_disk_string_of_backend(disk->backend));\n        flexarray_append(back, \"mode\");\n        flexarray_append(back, disk->readwrite ? \"w\" : \"r\");\n        flexarray_append(back, \"device-type\");\n        flexarray_append(back, disk->is_cdrom ? \"cdrom\" : \"disk\");\n        if (disk->direct_io_safe) {\n            flexarray_append(back, \"direct-io-safe\");\n            flexarray_append(back, \"1\");\n        }\n        flexarray_append_pair(back, \"discard-enable\",\n                              libxl_defbool_val(disk->discard_enable) ?\n                              \"1\" : \"0\");\n\n        flexarray_append(front, \"backend-id\");\n        flexarray_append(front, GCSPRINTF(\"%d\", disk->backend_domid));\n        flexarray_append(front, \"state\");\n        flexarray_append(front, GCSPRINTF(\"%d\", XenbusStateInitialising));\n        flexarray_append(front, \"virtual-device\");\n        flexarray_append(front, GCSPRINTF(\"%d\", device->devid));\n        flexarray_append(front, \"device-type\");\n        flexarray_append(front, disk->is_cdrom ? \"cdrom\" : \"disk\");\n\n        /*\n         * Old PV kernel disk frontends before 2.6.26 rely on tool stack to\n         * write disk native protocol to frontend node. Xend does this, port\n         * this behaviour to xl.\n         *\n         * New kernels write this node themselves. In that case it just\n         * overwrites an existing node which is OK.\n         */\n        if (type == LIBXL_DOMAIN_TYPE_PV) {\n            const char *protocol =\n                xc_domain_get_native_protocol(ctx->xch, domid);\n            if (protocol) {\n                flexarray_append(front, \"protocol\");\n                flexarray_append(front, libxl__strdup(gc, protocol));\n            }\n        }\n\n        if (!get_vdev && aodev->update_json) {\n            rc = libxl__set_domain_configuration(gc, domid, &d_config);\n            if (rc) goto out;\n        }\n\n        libxl__device_generic_add(gc, t, device,\n                                  libxl__xs_kvs_of_flexarray(gc, back),\n                                  libxl__xs_kvs_of_flexarray(gc, front),\n                                  NULL);\n\n        rc = libxl__xs_transaction_commit(gc, &t);\n        if (!rc) break;\n        if (rc < 0) goto out;\n    }\n\n    aodev->dev = device;\n    aodev->action = LIBXL__DEVICE_ACTION_ADD;\n    libxl__wait_device_connection(egc, aodev);\n\n    rc = 0;\n\nout:\n    libxl__xs_transaction_abort(gc, &t);\n    if (lock) libxl__unlock_file(lock);\n    libxl_device_disk_dispose(&disk_saved);\n    libxl_domain_config_dispose(&d_config);\n    aodev->rc = rc;\n    if (rc) aodev->callback(egc, aodev);\n    return;\n}",
        "func": "static void device_disk_add(libxl__egc *egc, uint32_t domid,\n                           libxl_device_disk *disk,\n                           libxl__ao_device *aodev,\n                           char *get_vdev(libxl__gc *, void *,\n                                          xs_transaction_t),\n                           void *get_vdev_user)\n{\n    STATE_AO_GC(aodev->ao);\n    flexarray_t *front = NULL;\n    flexarray_t *back = NULL;\n    char *dev = NULL, *script;\n    libxl__device *device;\n    int rc;\n    libxl_ctx *ctx = gc->owner;\n    xs_transaction_t t = XBT_NULL;\n    libxl_domain_config d_config;\n    libxl_device_disk disk_saved;\n    libxl__flock *lock = NULL;\n\n    libxl_domain_config_init(&d_config);\n    libxl_device_disk_init(&disk_saved);\n    libxl_device_disk_copy(ctx, &disk_saved, disk);\n\n    libxl_domain_type type = libxl__domain_type(gc, domid);\n    if (type == LIBXL_DOMAIN_TYPE_INVALID) {\n        rc = ERROR_FAIL;\n        goto out;\n    }\n\n    /*\n     * get_vdev != NULL -> local attach\n     * get_vdev == NULL -> block attach\n     *\n     * We don't care about local attach state because it's only\n     * intermediate state.\n     */\n    if (!get_vdev && aodev->update_json) {\n        lock = libxl__lock_domain_userdata(gc, domid);\n        if (!lock) {\n            rc = ERROR_LOCK_FAIL;\n            goto out;\n        }\n\n        rc = libxl__get_domain_configuration(gc, domid, &d_config);\n        if (rc) goto out;\n\n        device_add_domain_config(gc, &d_config, &libxl__disk_devtype,\n                                 &disk_saved);\n\n        rc = libxl__dm_check_start(gc, &d_config, domid);\n        if (rc) goto out;\n    }\n\n    for (;;) {\n        rc = libxl__xs_transaction_start(gc, &t);\n        if (rc) goto out;\n\n        if (get_vdev) {\n            assert(get_vdev_user);\n            disk->vdev = get_vdev(gc, get_vdev_user, t);\n            if (disk->vdev == NULL) {\n                rc = ERROR_FAIL;\n                goto out;\n            }\n        }\n\n        rc = libxl__device_disk_setdefault(gc, domid, disk, aodev->update_json);\n        if (rc) goto out;\n\n        front = flexarray_make(gc, 16, 1);\n        back = flexarray_make(gc, 16, 1);\n\n        GCNEW(device);\n        rc = libxl__device_from_disk(gc, domid, disk, device);\n        if (rc != 0) {\n            LOGD(ERROR, domid, \"Invalid or unsupported\"\" virtual disk identifier %s\",\n                 disk->vdev);\n            goto out;\n        }\n\n        rc = libxl__device_exists(gc, t, device);\n        if (rc < 0) goto out;\n        if (rc == 1) {              /* already exists in xenstore */\n            LOGD(ERROR, domid, \"device already exists in xenstore\");\n            aodev->action = LIBXL__DEVICE_ACTION_ADD; /* for error message */\n            rc = ERROR_DEVICE_EXISTS;\n            goto out;\n        }\n\n        switch (disk->backend) {\n            case LIBXL_DISK_BACKEND_PHY:\n                dev = disk->pdev_path;\n\n                flexarray_append(back, \"params\");\n                flexarray_append(back, dev);\n\n                script = libxl__abs_path(gc, disk->script?: \"block\",\n                                         libxl__xen_script_dir_path());\n                flexarray_append_pair(back, \"script\", script);\n\n                assert(device->backend_kind == LIBXL__DEVICE_KIND_VBD);\n                break;\n\n            case LIBXL_DISK_BACKEND_TAP:\n                LOG(ERROR, \"blktap is not supported\");\n                rc = ERROR_FAIL;\n                goto out;\n            case LIBXL_DISK_BACKEND_QDISK:\n                flexarray_append(back, \"params\");\n                flexarray_append(back, GCSPRINTF(\"%s:%s\",\n                              libxl__device_disk_string_of_format(disk->format),\n                              disk->pdev_path ? : \"\"));\n                if (libxl_defbool_val(disk->colo_enable)) {\n                    flexarray_append(back, \"colo-host\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%s\", disk->colo_host));\n                    flexarray_append(back, \"colo-port\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%d\", disk->colo_port));\n                    flexarray_append(back, \"colo-export\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%s\", disk->colo_export));\n                    flexarray_append(back, \"active-disk\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%s\", disk->active_disk));\n                    flexarray_append(back, \"hidden-disk\");\n                    flexarray_append(back, libxl__sprintf(gc, \"%s\", disk->hidden_disk));\n                }\n                assert(device->backend_kind == LIBXL__DEVICE_KIND_QDISK);\n                break;\n            default:\n                LOGD(ERROR, domid, \"Unrecognized disk backend type: %d\",\n                     disk->backend);\n                rc = ERROR_INVAL;\n                goto out;\n        }\n\n        flexarray_append(back, \"frontend-id\");\n        flexarray_append(back, GCSPRINTF(\"%d\", domid));\n        flexarray_append(back, \"online\");\n        flexarray_append(back, \"1\");\n        flexarray_append(back, \"removable\");\n        flexarray_append(back, GCSPRINTF(\"%d\", (disk->removable) ? 1 : 0));\n        flexarray_append(back, \"bootable\");\n        flexarray_append(back, GCSPRINTF(\"%d\", 1));\n        flexarray_append(back, \"state\");\n        flexarray_append(back, GCSPRINTF(\"%d\", XenbusStateInitialising));\n        flexarray_append(back, \"dev\");\n        flexarray_append(back, disk->vdev);\n        flexarray_append(back, \"type\");\n        flexarray_append(back, libxl__device_disk_string_of_backend(disk->backend));\n        flexarray_append(back, \"mode\");\n        flexarray_append(back, disk->readwrite ? \"w\" : \"r\");\n        flexarray_append(back, \"device-type\");\n        flexarray_append(back, disk->is_cdrom ? \"cdrom\" : \"disk\");\n        if (disk->direct_io_safe) {\n            flexarray_append(back, \"direct-io-safe\");\n            flexarray_append(back, \"1\");\n        }\n        flexarray_append_pair(back, \"discard-enable\",\n                              libxl_defbool_val(disk->discard_enable) ?\n                              \"1\" : \"0\");\n\n        flexarray_append(front, \"backend-id\");\n        flexarray_append(front, GCSPRINTF(\"%d\", disk->backend_domid));\n        flexarray_append(front, \"state\");\n        flexarray_append(front, GCSPRINTF(\"%d\", XenbusStateInitialising));\n        flexarray_append(front, \"virtual-device\");\n        flexarray_append(front, GCSPRINTF(\"%d\", device->devid));\n        flexarray_append(front, \"device-type\");\n        flexarray_append(front, disk->is_cdrom ? \"cdrom\" : \"disk\");\n        flexarray_append(front, \"trusted\");\n        flexarray_append(front, libxl_defbool_val(disk->trusted) ? \"1\" : \"0\");\n\n        /*\n         * Old PV kernel disk frontends before 2.6.26 rely on tool stack to\n         * write disk native protocol to frontend node. Xend does this, port\n         * this behaviour to xl.\n         *\n         * New kernels write this node themselves. In that case it just\n         * overwrites an existing node which is OK.\n         */\n        if (type == LIBXL_DOMAIN_TYPE_PV) {\n            const char *protocol =\n                xc_domain_get_native_protocol(ctx->xch, domid);\n            if (protocol) {\n                flexarray_append(front, \"protocol\");\n                flexarray_append(front, libxl__strdup(gc, protocol));\n            }\n        }\n\n        if (!get_vdev && aodev->update_json) {\n            rc = libxl__set_domain_configuration(gc, domid, &d_config);\n            if (rc) goto out;\n        }\n\n        libxl__device_generic_add(gc, t, device,\n                                  libxl__xs_kvs_of_flexarray(gc, back),\n                                  libxl__xs_kvs_of_flexarray(gc, front),\n                                  NULL);\n\n        rc = libxl__xs_transaction_commit(gc, &t);\n        if (!rc) break;\n        if (rc < 0) goto out;\n    }\n\n    aodev->dev = device;\n    aodev->action = LIBXL__DEVICE_ACTION_ADD;\n    libxl__wait_device_connection(egc, aodev);\n\n    rc = 0;\n\nout:\n    libxl__xs_transaction_abort(gc, &t);\n    if (lock) libxl__unlock_file(lock);\n    libxl_device_disk_dispose(&disk_saved);\n    libxl_domain_config_dispose(&d_config);\n    aodev->rc = rc;\n    if (rc) aodev->callback(egc, aodev);\n    return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -165,6 +165,8 @@\n         flexarray_append(front, GCSPRINTF(\"%d\", device->devid));\n         flexarray_append(front, \"device-type\");\n         flexarray_append(front, disk->is_cdrom ? \"cdrom\" : \"disk\");\n+        flexarray_append(front, \"trusted\");\n+        flexarray_append(front, libxl_defbool_val(disk->trusted) ? \"1\" : \"0\");\n \n         /*\n          * Old PV kernel disk frontends before 2.6.26 rely on tool stack to",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        flexarray_append(front, \"trusted\");",
                "        flexarray_append(front, libxl_defbool_val(disk->trusted) ? \"1\" : \"0\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26365",
        "func_name": "xen-project/xen/libxl__set_xenstore_nic",
        "description": "Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Linux Block and Network PV device frontends don't zero memory regions before sharing them with the backend (CVE-2022-26365, CVE-2022-33740). Additionally the granularity of the grant table doesn't allow sharing less than a 4K page, leading to unrelated data residing in the same 4K page as data shared with a backend being accessible by such backend (CVE-2022-33741, CVE-2022-33742).",
        "git_url": "https://github.com/xen-project/xen/commit/54d8f27d0477937e1f99a414fc1ffd93d184b38a",
        "commit_title": "tools/libxl: report trusted backend status to frontends",
        "commit_text": " Allow administrators to notify a frontend driver that it's backend counterpart is not to be trusted, so the frontend can deploy whatever mitigations required in order to secure itself.  Allow such option for disk and network frontends only, as those are the only hardened ones currently supported.  This is part of XSA-403 ",
        "func_before": "static int libxl__set_xenstore_nic(libxl__gc *gc, uint32_t domid,\n                                   libxl_device_nic *nic,\n                                   flexarray_t *back, flexarray_t *front,\n                                   flexarray_t *ro_front)\n{\n    flexarray_grow(back, 2);\n\n    if (nic->script)\n        flexarray_append_pair(back, \"script\",\n                              libxl__abs_path(gc, nic->script,\n                                              libxl__xen_script_dir_path()));\n\n    if (nic->ifname) {\n        flexarray_append(back, \"vifname\");\n        flexarray_append(back, nic->ifname);\n    }\n\n    if (nic->coloft_forwarddev) {\n        flexarray_append(back, \"forwarddev\");\n        flexarray_append(back, nic->coloft_forwarddev);\n    }\n\n#define MAYBE_ADD_COLO_ARGS(arg) ({                                       \\\n    if (nic->colo_##arg) {                                                \\\n        flexarray_append(back, \"colo_\"#arg);                              \\\n        flexarray_append(back, nic->colo_##arg);                          \\\n    }                                                                     \\\n})\n\n    MAYBE_ADD_COLO_ARGS(sock_mirror_id);\n    MAYBE_ADD_COLO_ARGS(sock_mirror_ip);\n    MAYBE_ADD_COLO_ARGS(sock_mirror_port);\n    MAYBE_ADD_COLO_ARGS(sock_compare_pri_in_id);\n    MAYBE_ADD_COLO_ARGS(sock_compare_pri_in_ip);\n    MAYBE_ADD_COLO_ARGS(sock_compare_pri_in_port);\n    MAYBE_ADD_COLO_ARGS(sock_compare_sec_in_id);\n    MAYBE_ADD_COLO_ARGS(sock_compare_sec_in_ip);\n    MAYBE_ADD_COLO_ARGS(sock_compare_sec_in_port);\n    MAYBE_ADD_COLO_ARGS(sock_compare_notify_id);\n    MAYBE_ADD_COLO_ARGS(sock_compare_notify_ip);\n    MAYBE_ADD_COLO_ARGS(sock_compare_notify_port);\n    MAYBE_ADD_COLO_ARGS(sock_redirector0_id);\n    MAYBE_ADD_COLO_ARGS(sock_redirector0_ip);\n    MAYBE_ADD_COLO_ARGS(sock_redirector0_port);\n    MAYBE_ADD_COLO_ARGS(sock_redirector1_id);\n    MAYBE_ADD_COLO_ARGS(sock_redirector1_ip);\n    MAYBE_ADD_COLO_ARGS(sock_redirector1_port);\n    MAYBE_ADD_COLO_ARGS(sock_redirector2_id);\n    MAYBE_ADD_COLO_ARGS(sock_redirector2_ip);\n    MAYBE_ADD_COLO_ARGS(sock_redirector2_port);\n    MAYBE_ADD_COLO_ARGS(filter_mirror_queue);\n    MAYBE_ADD_COLO_ARGS(filter_mirror_outdev);\n    MAYBE_ADD_COLO_ARGS(filter_redirector0_queue);\n    MAYBE_ADD_COLO_ARGS(filter_redirector0_indev);\n    MAYBE_ADD_COLO_ARGS(filter_redirector0_outdev);\n    MAYBE_ADD_COLO_ARGS(filter_redirector1_queue);\n    MAYBE_ADD_COLO_ARGS(filter_redirector1_indev);\n    MAYBE_ADD_COLO_ARGS(filter_redirector1_outdev);\n    MAYBE_ADD_COLO_ARGS(compare_pri_in);\n    MAYBE_ADD_COLO_ARGS(compare_sec_in);\n    MAYBE_ADD_COLO_ARGS(compare_out);\n    MAYBE_ADD_COLO_ARGS(compare_notify_dev);\n\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector0_id);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector0_ip);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector0_port);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector1_id);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector1_ip);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector1_port);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector0_queue);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector0_indev);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector0_outdev);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector1_queue);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector1_indev);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector1_outdev);\n    MAYBE_ADD_COLO_ARGS(filter_sec_rewriter0_queue);\n    MAYBE_ADD_COLO_ARGS(checkpoint_host);\n    MAYBE_ADD_COLO_ARGS(checkpoint_port);\n\n#undef MAYBE_ADD_COLO_ARGS\n\n    flexarray_append(back, \"mac\");\n    flexarray_append(back,GCSPRINTF(LIBXL_MAC_FMT, LIBXL_MAC_BYTES(nic->mac)));\n    if (nic->ip) {\n        flexarray_append(back, \"ip\");\n        flexarray_append(back, libxl__strdup(gc, nic->ip));\n    }\n    if (nic->gatewaydev) {\n        flexarray_append(back, \"gatewaydev\");\n        flexarray_append(back, libxl__strdup(gc, nic->gatewaydev));\n    }\n\n    if (nic->rate_interval_usecs > 0) {\n        flexarray_append(back, \"rate\");\n        flexarray_append(back, GCSPRINTF(\"%\"PRIu64\",%\"PRIu32\"\",\n                            nic->rate_bytes_per_interval,\n                            nic->rate_interval_usecs));\n    }\n\n    if (nic->mtu != LIBXL_DEVICE_NIC_MTU_DEFAULT) {\n        flexarray_append(back, \"mtu\");\n        flexarray_append(back, GCSPRINTF(\"%u\", nic->mtu));\n    }\n    \n    flexarray_append(back, \"bridge\");\n    flexarray_append(back, libxl__strdup(gc, nic->bridge));\n    flexarray_append(back, \"handle\");\n    flexarray_append(back, GCSPRINTF(\"%d\", nic->devid));\n    flexarray_append(back, \"type\");\n    flexarray_append(back, libxl__strdup(gc,\n                                     libxl_nic_type_to_string(nic->nictype)));\n\n    flexarray_append(front, \"handle\");\n    flexarray_append(front, GCSPRINTF(\"%d\", nic->devid));\n    flexarray_append(front, \"mac\");\n    flexarray_append(front, GCSPRINTF(\n                                    LIBXL_MAC_FMT, LIBXL_MAC_BYTES(nic->mac)));\n\n    flexarray_append(ro_front, \"mtu\");\n    flexarray_append(ro_front, GCSPRINTF(\"%u\", nic->mtu));\n\n    /*\n     * Force backend to wait for hotplug script execution before switching to\n     * connected state.\n     */\n    flexarray_append(back, \"hotplug-status\");\n    flexarray_append(back, \"\");\n\n    return 0;\n}",
        "func": "static int libxl__set_xenstore_nic(libxl__gc *gc, uint32_t domid,\n                                   libxl_device_nic *nic,\n                                   flexarray_t *back, flexarray_t *front,\n                                   flexarray_t *ro_front)\n{\n    flexarray_grow(back, 2);\n\n    if (nic->script)\n        flexarray_append_pair(back, \"script\",\n                              libxl__abs_path(gc, nic->script,\n                                              libxl__xen_script_dir_path()));\n\n    if (nic->ifname) {\n        flexarray_append(back, \"vifname\");\n        flexarray_append(back, nic->ifname);\n    }\n\n    if (nic->coloft_forwarddev) {\n        flexarray_append(back, \"forwarddev\");\n        flexarray_append(back, nic->coloft_forwarddev);\n    }\n\n#define MAYBE_ADD_COLO_ARGS(arg) ({                                       \\\n    if (nic->colo_##arg) {                                                \\\n        flexarray_append(back, \"colo_\"#arg);                              \\\n        flexarray_append(back, nic->colo_##arg);                          \\\n    }                                                                     \\\n})\n\n    MAYBE_ADD_COLO_ARGS(sock_mirror_id);\n    MAYBE_ADD_COLO_ARGS(sock_mirror_ip);\n    MAYBE_ADD_COLO_ARGS(sock_mirror_port);\n    MAYBE_ADD_COLO_ARGS(sock_compare_pri_in_id);\n    MAYBE_ADD_COLO_ARGS(sock_compare_pri_in_ip);\n    MAYBE_ADD_COLO_ARGS(sock_compare_pri_in_port);\n    MAYBE_ADD_COLO_ARGS(sock_compare_sec_in_id);\n    MAYBE_ADD_COLO_ARGS(sock_compare_sec_in_ip);\n    MAYBE_ADD_COLO_ARGS(sock_compare_sec_in_port);\n    MAYBE_ADD_COLO_ARGS(sock_compare_notify_id);\n    MAYBE_ADD_COLO_ARGS(sock_compare_notify_ip);\n    MAYBE_ADD_COLO_ARGS(sock_compare_notify_port);\n    MAYBE_ADD_COLO_ARGS(sock_redirector0_id);\n    MAYBE_ADD_COLO_ARGS(sock_redirector0_ip);\n    MAYBE_ADD_COLO_ARGS(sock_redirector0_port);\n    MAYBE_ADD_COLO_ARGS(sock_redirector1_id);\n    MAYBE_ADD_COLO_ARGS(sock_redirector1_ip);\n    MAYBE_ADD_COLO_ARGS(sock_redirector1_port);\n    MAYBE_ADD_COLO_ARGS(sock_redirector2_id);\n    MAYBE_ADD_COLO_ARGS(sock_redirector2_ip);\n    MAYBE_ADD_COLO_ARGS(sock_redirector2_port);\n    MAYBE_ADD_COLO_ARGS(filter_mirror_queue);\n    MAYBE_ADD_COLO_ARGS(filter_mirror_outdev);\n    MAYBE_ADD_COLO_ARGS(filter_redirector0_queue);\n    MAYBE_ADD_COLO_ARGS(filter_redirector0_indev);\n    MAYBE_ADD_COLO_ARGS(filter_redirector0_outdev);\n    MAYBE_ADD_COLO_ARGS(filter_redirector1_queue);\n    MAYBE_ADD_COLO_ARGS(filter_redirector1_indev);\n    MAYBE_ADD_COLO_ARGS(filter_redirector1_outdev);\n    MAYBE_ADD_COLO_ARGS(compare_pri_in);\n    MAYBE_ADD_COLO_ARGS(compare_sec_in);\n    MAYBE_ADD_COLO_ARGS(compare_out);\n    MAYBE_ADD_COLO_ARGS(compare_notify_dev);\n\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector0_id);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector0_ip);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector0_port);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector1_id);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector1_ip);\n    MAYBE_ADD_COLO_ARGS(sock_sec_redirector1_port);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector0_queue);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector0_indev);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector0_outdev);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector1_queue);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector1_indev);\n    MAYBE_ADD_COLO_ARGS(filter_sec_redirector1_outdev);\n    MAYBE_ADD_COLO_ARGS(filter_sec_rewriter0_queue);\n    MAYBE_ADD_COLO_ARGS(checkpoint_host);\n    MAYBE_ADD_COLO_ARGS(checkpoint_port);\n\n#undef MAYBE_ADD_COLO_ARGS\n\n    flexarray_append(back, \"mac\");\n    flexarray_append(back,GCSPRINTF(LIBXL_MAC_FMT, LIBXL_MAC_BYTES(nic->mac)));\n    if (nic->ip) {\n        flexarray_append(back, \"ip\");\n        flexarray_append(back, libxl__strdup(gc, nic->ip));\n    }\n    if (nic->gatewaydev) {\n        flexarray_append(back, \"gatewaydev\");\n        flexarray_append(back, libxl__strdup(gc, nic->gatewaydev));\n    }\n\n    if (nic->rate_interval_usecs > 0) {\n        flexarray_append(back, \"rate\");\n        flexarray_append(back, GCSPRINTF(\"%\"PRIu64\",%\"PRIu32\"\",\n                            nic->rate_bytes_per_interval,\n                            nic->rate_interval_usecs));\n    }\n\n    if (nic->mtu != LIBXL_DEVICE_NIC_MTU_DEFAULT) {\n        flexarray_append(back, \"mtu\");\n        flexarray_append(back, GCSPRINTF(\"%u\", nic->mtu));\n    }\n    \n    flexarray_append(back, \"bridge\");\n    flexarray_append(back, libxl__strdup(gc, nic->bridge));\n    flexarray_append(back, \"handle\");\n    flexarray_append(back, GCSPRINTF(\"%d\", nic->devid));\n    flexarray_append(back, \"type\");\n    flexarray_append(back, libxl__strdup(gc,\n                                     libxl_nic_type_to_string(nic->nictype)));\n\n    flexarray_append(front, \"handle\");\n    flexarray_append(front, GCSPRINTF(\"%d\", nic->devid));\n    flexarray_append(front, \"mac\");\n    flexarray_append(front, GCSPRINTF(\n                                    LIBXL_MAC_FMT, LIBXL_MAC_BYTES(nic->mac)));\n\n    flexarray_append(ro_front, \"mtu\");\n    flexarray_append(ro_front, GCSPRINTF(\"%u\", nic->mtu));\n\n    /*\n     * Force backend to wait for hotplug script execution before switching to\n     * connected state.\n     */\n    flexarray_append(back, \"hotplug-status\");\n    flexarray_append(back, \"\");\n\n    flexarray_append(front, \"trusted\");\n    flexarray_append(front, libxl_defbool_val(nic->trusted) ? \"1\" : \"0\");\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -126,5 +126,8 @@\n     flexarray_append(back, \"hotplug-status\");\n     flexarray_append(back, \"\");\n \n+    flexarray_append(front, \"trusted\");\n+    flexarray_append(front, libxl_defbool_val(nic->trusted) ? \"1\" : \"0\");\n+\n     return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    flexarray_append(front, \"trusted\");",
                "    flexarray_append(front, libxl_defbool_val(nic->trusted) ? \"1\" : \"0\");",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26365",
        "func_name": "xen-project/xen/libxl__device_nic_setdefault",
        "description": "Linux disk/nic frontends data leaks T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Linux Block and Network PV device frontends don't zero memory regions before sharing them with the backend (CVE-2022-26365, CVE-2022-33740). Additionally the granularity of the grant table doesn't allow sharing less than a 4K page, leading to unrelated data residing in the same 4K page as data shared with a backend being accessible by such backend (CVE-2022-33741, CVE-2022-33742).",
        "git_url": "https://github.com/xen-project/xen/commit/54d8f27d0477937e1f99a414fc1ffd93d184b38a",
        "commit_title": "tools/libxl: report trusted backend status to frontends",
        "commit_text": " Allow administrators to notify a frontend driver that it's backend counterpart is not to be trusted, so the frontend can deploy whatever mitigations required in order to secure itself.  Allow such option for disk and network frontends only, as those are the only hardened ones currently supported.  This is part of XSA-403 ",
        "func_before": "static int libxl__device_nic_setdefault(libxl__gc *gc, uint32_t domid,\n                                        libxl_device_nic *nic, bool hotplug)\n{\n    int rc;\n\n    if (!nic->mtu)\n        nic->mtu = LIBXL_DEVICE_NIC_MTU_DEFAULT;\n    if (!nic->model) {\n        nic->model = strdup(\"rtl8139\");\n        if (!nic->model) return ERROR_NOMEM;\n    }\n    if (libxl__mac_is_default(&nic->mac)) {\n        const uint8_t *r;\n        libxl_uuid uuid;\n\n        libxl_uuid_generate(&uuid);\n        r = libxl_uuid_bytearray(&uuid);\n\n        /* Generate a random MAC address, with Xen's OUI (00:16:3e) */\n        nic->mac[0] = 0x00;\n        nic->mac[1] = 0x16;\n        nic->mac[2] = 0x3e;\n        nic->mac[3] = r[0] & 0x7f;\n        nic->mac[4] = r[1];\n        nic->mac[5] = r[2];\n    }\n    if (!nic->bridge) {\n        nic->bridge = strdup(\"xenbr0\");\n        if (!nic->bridge) return ERROR_NOMEM;\n    }\n    if ( !nic->script && asprintf(&nic->script, \"%s/vif-bridge\",\n                                  libxl__xen_script_dir_path()) < 0 )\n        return ERROR_FAIL;\n\n    rc = libxl__resolve_domid(gc, nic->backend_domname, &nic->backend_domid);\n    if (rc < 0) return rc;\n\n    switch (libxl__domain_type(gc, domid)) {\n    case LIBXL_DOMAIN_TYPE_HVM:\n        if (!nic->nictype) {\n            if (hotplug)\n                nic->nictype = LIBXL_NIC_TYPE_VIF;\n            else\n                nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n        }\n        break;\n    case LIBXL_DOMAIN_TYPE_PVH:\n    case LIBXL_DOMAIN_TYPE_PV:\n        if (nic->nictype == LIBXL_NIC_TYPE_VIF_IOEMU) {\n            LOGD(ERROR, domid,\n            \"trying to create PV or PVH guest with an emulated interface\");\n            return ERROR_INVAL;\n        }\n        nic->nictype = LIBXL_NIC_TYPE_VIF;\n        break;\n    case LIBXL_DOMAIN_TYPE_INVALID:\n        return ERROR_FAIL;\n    default:\n        abort();\n    }\n\n    return rc;\n}",
        "func": "static int libxl__device_nic_setdefault(libxl__gc *gc, uint32_t domid,\n                                        libxl_device_nic *nic, bool hotplug)\n{\n    int rc;\n\n    if (!nic->mtu)\n        nic->mtu = LIBXL_DEVICE_NIC_MTU_DEFAULT;\n    if (!nic->model) {\n        nic->model = strdup(\"rtl8139\");\n        if (!nic->model) return ERROR_NOMEM;\n    }\n    if (libxl__mac_is_default(&nic->mac)) {\n        const uint8_t *r;\n        libxl_uuid uuid;\n\n        libxl_uuid_generate(&uuid);\n        r = libxl_uuid_bytearray(&uuid);\n\n        /* Generate a random MAC address, with Xen's OUI (00:16:3e) */\n        nic->mac[0] = 0x00;\n        nic->mac[1] = 0x16;\n        nic->mac[2] = 0x3e;\n        nic->mac[3] = r[0] & 0x7f;\n        nic->mac[4] = r[1];\n        nic->mac[5] = r[2];\n    }\n    if (!nic->bridge) {\n        nic->bridge = strdup(\"xenbr0\");\n        if (!nic->bridge) return ERROR_NOMEM;\n    }\n    if ( !nic->script && asprintf(&nic->script, \"%s/vif-bridge\",\n                                  libxl__xen_script_dir_path()) < 0 )\n        return ERROR_FAIL;\n\n    rc = libxl__resolve_domid(gc, nic->backend_domname, &nic->backend_domid);\n    if (rc < 0) return rc;\n\n    switch (libxl__domain_type(gc, domid)) {\n    case LIBXL_DOMAIN_TYPE_HVM:\n        if (!nic->nictype) {\n            if (hotplug)\n                nic->nictype = LIBXL_NIC_TYPE_VIF;\n            else\n                nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;\n        }\n        break;\n    case LIBXL_DOMAIN_TYPE_PVH:\n    case LIBXL_DOMAIN_TYPE_PV:\n        if (nic->nictype == LIBXL_NIC_TYPE_VIF_IOEMU) {\n            LOGD(ERROR, domid,\n            \"trying to create PV or PVH guest with an emulated interface\");\n            return ERROR_INVAL;\n        }\n        nic->nictype = LIBXL_NIC_TYPE_VIF;\n        break;\n    case LIBXL_DOMAIN_TYPE_INVALID:\n        return ERROR_FAIL;\n    default:\n        abort();\n    }\n\n    libxl_defbool_setdefault(&nic->trusted, true);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -59,5 +59,7 @@\n         abort();\n     }\n \n+    libxl_defbool_setdefault(&nic->trusted, true);\n+\n     return rc;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    libxl_defbool_setdefault(&nic->trusted, true);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12379",
        "func_name": "kernel/git/gregkh/tty/con_insert_unipair",
        "description": "An issue was discovered in con_insert_unipair in drivers/tty/vt/consolemap.c in the Linux kernel through 5.1.5. There is a memory leak in a certain case of an ENOMEM outcome of kmalloc. NOTE: This id is disputed as not being an issue",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty.git/commit/?h=tty-next&h=84ecc2f6eb1cb12e6d44818f94fa49b50f06e6ac",
        "commit_title": "In function con_insert_unipair(), when allocation for p2 and p1[n]",
        "commit_text": "fails, ENOMEM is returned, but previously allocated p1 is not freed, remains as leaking memory. Thus we should free p1 as well when this allocation fails.  ",
        "func_before": "static int\ncon_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) return -ENOMEM;\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */\n\t}\n\n\tp2[unicode & 0x3f] = fontpos;\n\t\n\tp->sum += (fontpos << 20) + unicode;\n\n\treturn 0;\n}",
        "func": "static int\ncon_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) {\n\t\t\tkfree(p1);\n\t\t\tp->uni_pgdir[n] = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */\n\t}\n\n\tp2[unicode & 0x3f] = fontpos;\n\t\n\tp->sum += (fontpos << 20) + unicode;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,11 @@\n \tp2 = p1[n = (unicode >> 6) & 0x1f];\n \tif (!p2) {\n \t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n-\t\tif (!p2) return -ENOMEM;\n+\t\tif (!p2) {\n+\t\t\tkfree(p1);\n+\t\t\tp->uni_pgdir[n] = NULL;\n+\t\t\treturn -ENOMEM;\n+\t\t}\n \t\tmemset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (!p2) return -ENOMEM;"
            ],
            "added_lines": [
                "\t\tif (!p2) {",
                "\t\t\tkfree(p1);",
                "\t\t\tp->uni_pgdir[n] = NULL;",
                "\t\t\treturn -ENOMEM;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12379",
        "func_name": "kernel/git/gregkh/tty/con_insert_unipair",
        "description": "An issue was discovered in con_insert_unipair in drivers/tty/vt/consolemap.c in the Linux kernel through 5.1.5. There is a memory leak in a certain case of an ENOMEM outcome of kmalloc. NOTE: This id is disputed as not being an issue",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty.git/commit/?h=tty-testing&h=15b3cd8ef46ad1b100e0d3c7e38774f330726820",
        "commit_title": "This reverts commit 84ecc2f6eb1cb12e6d44818f94fa49b50f06e6ac.",
        "commit_text": " con_insert_unipair() is working with a sparse 3-dimensional array:  - p->uni_pgdir[] is the top layer - p1 points to a middle layer - p2 points to a bottom layer  If it needs to allocate a new middle layer, and then fails to allocate a new bottom layer, it would previously free only p2, and now it frees both p1 and p2.  But since the new middle layer was already registered in the top layer, it was not leaked.  However, if it looks up an *existing* middle layer and then fails to allocate a bottom layer, it now frees both p1 and p2 but does *not* free any other bottom layers under p1.  So it *introduces* a memory leak.  The error path also cleared the wrong index in p->uni_pgdir[], introducing a use-after-free.  ",
        "func_before": "static int\ncon_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) {\n\t\t\tkfree(p1);\n\t\t\tp->uni_pgdir[n] = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */\n\t}\n\n\tp2[unicode & 0x3f] = fontpos;\n\t\n\tp->sum += (fontpos << 20) + unicode;\n\n\treturn 0;\n}",
        "func": "static int\ncon_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) return -ENOMEM;\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */\n\t}\n\n\tp2[unicode & 0x3f] = fontpos;\n\t\n\tp->sum += (fontpos << 20) + unicode;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,11 +16,7 @@\n \tp2 = p1[n = (unicode >> 6) & 0x1f];\n \tif (!p2) {\n \t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n-\t\tif (!p2) {\n-\t\t\tkfree(p1);\n-\t\t\tp->uni_pgdir[n] = NULL;\n-\t\t\treturn -ENOMEM;\n-\t\t}\n+\t\tif (!p2) return -ENOMEM;\n \t\tmemset(p2, 0xff, 64*sizeof(u16)); /* No glyphs for the characters (yet) */\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (!p2) {",
                "\t\t\tkfree(p1);",
                "\t\t\tp->uni_pgdir[n] = NULL;",
                "\t\t\treturn -ENOMEM;",
                "\t\t}"
            ],
            "added_lines": [
                "\t\tif (!p2) return -ENOMEM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12975",
        "func_name": "ImageMagick/WriteDPXImage",
        "description": "ImageMagick 7.0.8-34 has a memory leak vulnerability in the WriteDPXImage function in coders/dpx.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ee5b9c56b9ca18ed0750f8a15e0d1a6da92a6e99",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1517",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  const StringInfo\n    *profile;\n\n  DPXInfo\n    dpx;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    flags;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    channels,\n    extent;\n\n  ssize_t\n    count,\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  time_t\n    seconds;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  horizontal_factor=4;\n  vertical_factor=4;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (horizontal_factor != 4) && (vertical_factor != 1) &&\n          (vertical_factor != 2) && (vertical_factor != 4))\n        ThrowWriterException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((image->colorspace == YCbCrColorspace) &&\n      ((horizontal_factor == 2) || (vertical_factor == 2)))\n    if ((image->columns % 2) != 0)\n      image->columns++;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Write file header.\n  */\n  (void) memset(&dpx,0,sizeof(dpx));\n  offset=0;\n  dpx.file.magic=0x53445058U;\n  offset+=WriteBlobLong(image,dpx.file.magic);\n  dpx.file.image_offset=0x2000U;\n  profile=GetImageProfile(image,\"dpx:user-data\");\n  if (profile != (StringInfo *) NULL)\n    {\n      if (GetStringInfoLength(profile) > 1048576)\n        ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n      dpx.file.image_offset+=(unsigned int) GetStringInfoLength(profile);\n      dpx.file.image_offset=(((dpx.file.image_offset+0x2000-1)/0x2000)*0x2000);\n    }\n  offset+=WriteBlobLong(image,dpx.file.image_offset);\n  (void) strncpy(dpx.file.version,\"V2.0\",sizeof(dpx.file.version)-1);\n  offset+=WriteBlob(image,8,(unsigned char *) &dpx.file.version);\n  channels=1;\n  if (IsImageGray(image) == MagickFalse)\n    channels=3;\n  if (image->alpha_trait != UndefinedPixelTrait)\n    channels++;\n  dpx.file.file_size=(unsigned int) (channels*image->columns*image->rows+\n    dpx.file.image_offset);\n  offset+=WriteBlobLong(image,dpx.file.file_size);\n  dpx.file.ditto_key=1U;  /* new frame */\n  offset+=WriteBlobLong(image,dpx.file.ditto_key);\n  dpx.file.generic_size=0x00000680U;\n  offset+=WriteBlobLong(image,dpx.file.generic_size);\n  dpx.file.industry_size=0x00000180U;\n  offset+=WriteBlobLong(image,dpx.file.industry_size);\n  dpx.file.user_size=0;\n  if (profile != (StringInfo *) NULL)\n    {\n      dpx.file.user_size+=(unsigned int) GetStringInfoLength(profile);\n      dpx.file.user_size=(((dpx.file.user_size+0x2000-1)/0x2000)*0x2000);\n    }\n  offset+=WriteBlobLong(image,dpx.file.user_size);\n  value=GetDPXProperty(image,\"dpx:file.filename\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.file.filename,value,sizeof(dpx.file.filename)-1);\n  offset+=WriteBlob(image,sizeof(dpx.file.filename),(unsigned char *)\n    dpx.file.filename);\n  seconds=time((time_t *) NULL);\n  (void) FormatMagickTime(seconds,sizeof(dpx.file.timestamp),\n    dpx.file.timestamp);\n  offset+=WriteBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)\n    dpx.file.timestamp);\n  (void) strncpy(dpx.file.creator,MagickAuthoritativeURL,\n    sizeof(dpx.file.creator)-1);\n  value=GetDPXProperty(image,\"dpx:file.creator\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.file.creator,value,sizeof(dpx.file.creator)-1);\n  offset+=WriteBlob(image,sizeof(dpx.file.creator),(unsigned char *)\n    dpx.file.creator);\n  value=GetDPXProperty(image,\"dpx:file.project\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.file.project,value,sizeof(dpx.file.project)-1);\n  offset+=WriteBlob(image,sizeof(dpx.file.project),(unsigned char *)\n    dpx.file.project);\n  value=GetDPXProperty(image,\"dpx:file.copyright\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.file.copyright,value,sizeof(dpx.file.copyright)-1);\n  offset+=WriteBlob(image,sizeof(dpx.file.copyright),(unsigned char *)\n    dpx.file.copyright);\n  dpx.file.encrypt_key=(~0U);\n  offset+=WriteBlobLong(image,dpx.file.encrypt_key);\n  offset+=WriteBlob(image,sizeof(dpx.file.reserve),(unsigned char *)\n    dpx.file.reserve);\n  /*\n    Write image header.\n  */\n  switch (image->orientation)\n  {\n    default:\n    case TopLeftOrientation: dpx.image.orientation=0; break;\n    case TopRightOrientation: dpx.image.orientation=1; break;\n    case BottomLeftOrientation: dpx.image.orientation=2; break;\n    case BottomRightOrientation: dpx.image.orientation=3; break;\n    case LeftTopOrientation: dpx.image.orientation=4; break;\n    case RightTopOrientation: dpx.image.orientation=5; break;\n    case LeftBottomOrientation: dpx.image.orientation=6; break;\n    case RightBottomOrientation: dpx.image.orientation=7; break;\n  }\n  offset+=WriteBlobShort(image,dpx.image.orientation);\n  dpx.image.number_elements=1;\n  offset+=WriteBlobShort(image,dpx.image.number_elements);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  offset+=WriteBlobLong(image,(unsigned int) image->columns);\n  offset+=WriteBlobLong(image,(unsigned int) image->rows);\n  for (i=0; i < 8; i++)\n  {\n    dpx.image.image_element[i].data_sign=0U;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].data_sign);\n    dpx.image.image_element[i].low_data=0U;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].low_data);\n    dpx.image.image_element[i].low_quantity=0.0f;\n    offset+=WriteBlobFloat(image,dpx.image.image_element[i].low_quantity);\n    dpx.image.image_element[i].high_data=0U;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].high_data);\n    dpx.image.image_element[i].high_quantity=0.0f;\n    offset+=WriteBlobFloat(image,dpx.image.image_element[i].high_quantity);\n    dpx.image.image_element[i].descriptor=0;\n    if (i == 0)\n      switch (image->colorspace)\n      {\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        case YCbCrColorspace:\n        {\n          dpx.image.image_element[i].descriptor=CbYCr444ComponentType;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            dpx.image.image_element[i].descriptor=CbYCrA4444ComponentType;\n          break;\n        }\n        default:\n        {\n          dpx.image.image_element[i].descriptor=RGBComponentType;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            dpx.image.image_element[i].descriptor=RGBAComponentType;\n          if ((image_info->type != TrueColorType) &&\n              (image->alpha_trait == UndefinedPixelTrait) &&\n              (SetImageGray(image,exception) != MagickFalse))\n            dpx.image.image_element[i].descriptor=LumaComponentType;\n          break;\n        }\n      }\n    offset+=WriteBlobByte(image,dpx.image.image_element[i].descriptor);\n    dpx.image.image_element[i].transfer_characteristic=0;\n    if (image->colorspace == LogColorspace)\n      dpx.image.image_element[0].transfer_characteristic=\n        PrintingDensityColorimetric;\n    offset+=WriteBlobByte(image,\n      dpx.image.image_element[i].transfer_characteristic);\n    dpx.image.image_element[i].colorimetric=0;\n    offset+=WriteBlobByte(image,dpx.image.image_element[i].colorimetric);\n    dpx.image.image_element[i].bit_size=0;\n    if (i == 0)\n      dpx.image.image_element[i].bit_size=(unsigned char) image->depth;\n    offset+=WriteBlobByte(image,dpx.image.image_element[i].bit_size);\n    dpx.image.image_element[i].packing=0;\n    if ((image->depth == 10) || (image->depth == 12))\n      dpx.image.image_element[i].packing=1;\n    offset+=WriteBlobShort(image,dpx.image.image_element[i].packing);\n    dpx.image.image_element[i].encoding=0;\n    offset+=WriteBlobShort(image,dpx.image.image_element[i].encoding);\n    dpx.image.image_element[i].data_offset=0U;\n    if (i == 0)\n      dpx.image.image_element[i].data_offset=dpx.file.image_offset;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].data_offset);\n    dpx.image.image_element[i].end_of_line_padding=0U;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].end_of_line_padding);\n    offset+=WriteBlobLong(image,\n      dpx.image.image_element[i].end_of_image_padding);\n    offset+=WriteBlob(image,sizeof(dpx.image.image_element[i].description),\n      (unsigned char *) dpx.image.image_element[i].description);\n  }\n  offset+=WriteBlob(image,sizeof(dpx.image.reserve),(unsigned char *)\n    dpx.image.reserve);\n  /*\n    Write orientation header.\n  */\n  if ((image->rows != image->magick_rows) ||\n      (image->columns != image->magick_columns))\n    {\n      /*\n        These properties are not valid if image size changed.\n      */\n      (void) DeleteImageProperty(image,\"dpx:orientation.x_offset\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.y_offset\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.x_center\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.y_center\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.x_size\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.y_size\");\n    }\n  dpx.orientation.x_offset=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.x_offset\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.x_offset=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.orientation.x_offset);\n  dpx.orientation.y_offset=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.y_offset\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.y_offset=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.orientation.y_offset);\n  dpx.orientation.x_center=0.0f;\n  value=GetDPXProperty(image,\"dpx:orientation.x_center\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.x_center=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.orientation.x_center);\n  dpx.orientation.y_center=0.0f;\n  value=GetDPXProperty(image,\"dpx:orientation.y_center\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.y_center=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.orientation.y_center);\n  dpx.orientation.x_size=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.x_size\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.x_size=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.orientation.x_size);\n  dpx.orientation.y_size=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.y_size\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.y_size=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.orientation.y_size);\n  value=GetDPXProperty(image,\"dpx:orientation.filename\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.orientation.filename,value,\n      sizeof(dpx.orientation.filename)-1);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)\n    dpx.orientation.filename);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)\n    dpx.orientation.timestamp);\n  value=GetDPXProperty(image,\"dpx:orientation.device\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.orientation.device,value,\n      sizeof(dpx.orientation.device)-1);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.device),(unsigned char *)\n    dpx.orientation.device);\n  value=GetDPXProperty(image,\"dpx:orientation.serial\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.orientation.serial,value,\n      sizeof(dpx.orientation.serial)-1);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)\n    dpx.orientation.serial);\n  for (i=0; i < 4; i++)\n    dpx.orientation.border[i]=0;\n  value=GetDPXProperty(image,\"dpx:orientation.border\",exception);\n  if (value != (const char *) NULL)\n    {\n      flags=ParseGeometry(value,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      dpx.orientation.border[0]=(unsigned short) (geometry_info.rho+0.5);\n      dpx.orientation.border[1]=(unsigned short) (geometry_info.sigma+0.5);\n      dpx.orientation.border[2]=(unsigned short) (geometry_info.xi+0.5);\n      dpx.orientation.border[3]=(unsigned short) (geometry_info.psi+0.5);\n    }\n  for (i=0; i < 4; i++)\n    offset+=WriteBlobShort(image,dpx.orientation.border[i]);\n  for (i=0; i < 2; i++)\n    dpx.orientation.aspect_ratio[i]=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.aspect_ratio\",exception);\n  if (value != (const char *) NULL)\n    {\n      flags=ParseGeometry(value,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      dpx.orientation.aspect_ratio[0]=(unsigned int) (geometry_info.rho+0.5);\n      dpx.orientation.aspect_ratio[1]=(unsigned int) (geometry_info.sigma+0.5);\n    }\n  for (i=0; i < 2; i++)\n    offset+=WriteBlobLong(image,dpx.orientation.aspect_ratio[i]);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)\n    dpx.orientation.reserve);\n  /*\n    Write film header.\n  */\n  (void) memset(dpx.film.id,0,sizeof(dpx.film.id));\n  value=GetDPXProperty(image,\"dpx:film.id\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.id,value,sizeof(dpx.film.id)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);\n  (void) memset(dpx.film.type,0,sizeof(dpx.film.type));\n  value=GetDPXProperty(image,\"dpx:film.type\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.type,value,sizeof(dpx.film.type)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.type),(unsigned char *)\n    dpx.film.type);\n  (void) memset(dpx.film.offset,0,sizeof(dpx.film.offset));\n  value=GetDPXProperty(image,\"dpx:film.offset\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.offset,value,sizeof(dpx.film.offset)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.offset),(unsigned char *)\n    dpx.film.offset);\n  (void) memset(dpx.film.prefix,0,sizeof(dpx.film.prefix));\n  value=GetDPXProperty(image,\"dpx:film.prefix\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.prefix,value,sizeof(dpx.film.prefix)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.prefix),(unsigned char *)\n    dpx.film.prefix);\n  (void) memset(dpx.film.count,0,sizeof(dpx.film.count));\n  value=GetDPXProperty(image,\"dpx:film.count\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.count,value,sizeof(dpx.film.count)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.count),(unsigned char *)\n    dpx.film.count);\n  (void) memset(dpx.film.format,0,sizeof(dpx.film.format));\n  value=GetDPXProperty(image,\"dpx:film.format\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.format,value,sizeof(dpx.film.format)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.format),(unsigned char *)\n    dpx.film.format);\n  dpx.film.frame_position=0U;\n  value=GetDPXProperty(image,\"dpx:film.frame_position\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.frame_position=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.film.frame_position);\n  dpx.film.sequence_extent=0U;\n  value=GetDPXProperty(image,\"dpx:film.sequence_extent\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.sequence_extent=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.film.sequence_extent);\n  dpx.film.held_count=0U;\n  value=GetDPXProperty(image,\"dpx:film.held_count\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.held_count=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.film.held_count);\n  dpx.film.frame_rate=0.0f;\n  value=GetDPXProperty(image,\"dpx:film.frame_rate\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.frame_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.film.frame_rate);\n  dpx.film.shutter_angle=0.0f;\n  value=GetDPXProperty(image,\"dpx:film.shutter_angle\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.shutter_angle=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.film.shutter_angle);\n  (void) memset(dpx.film.frame_id,0,sizeof(dpx.film.frame_id));\n  value=GetDPXProperty(image,\"dpx:film.frame_id\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.frame_id,value,sizeof(dpx.film.frame_id)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)\n    dpx.film.frame_id);\n  value=GetDPXProperty(image,\"dpx:film.slate\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.slate,value,sizeof(dpx.film.slate)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.slate),(unsigned char *)\n    dpx.film.slate);\n  offset+=WriteBlob(image,sizeof(dpx.film.reserve),(unsigned char *)\n    dpx.film.reserve);\n  /*\n    Write television header.\n  */\n  value=GetDPXProperty(image,\"dpx:television.time.code\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.time_code=StringToTimeCode(value);\n  offset+=WriteBlobLong(image,dpx.television.time_code);\n  value=GetDPXProperty(image,\"dpx:television.user.bits\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.user_bits=StringToTimeCode(value);\n  offset+=WriteBlobLong(image,dpx.television.user_bits);\n  value=GetDPXProperty(image,\"dpx:television.interlace\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.interlace=(unsigned char) StringToLong(value);\n  offset+=WriteBlobByte(image,dpx.television.interlace);\n  value=GetDPXProperty(image,\"dpx:television.field_number\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.field_number=(unsigned char) StringToLong(value);\n  offset+=WriteBlobByte(image,dpx.television.field_number);\n  dpx.television.video_signal=0;\n  value=GetDPXProperty(image,\"dpx:television.video_signal\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.video_signal=(unsigned char) StringToLong(value);\n  offset+=WriteBlobByte(image,dpx.television.video_signal);\n  dpx.television.padding=0;\n  value=GetDPXProperty(image,\"dpx:television.padding\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.padding=(unsigned char) StringToLong(value);\n  offset+=WriteBlobByte(image,dpx.television.padding);\n  dpx.television.horizontal_sample_rate=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.horizontal_sample_rate\",\n    exception);\n  if (value != (const char *) NULL)\n    dpx.television.horizontal_sample_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.horizontal_sample_rate);\n  dpx.television.vertical_sample_rate=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.vertical_sample_rate\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.vertical_sample_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.vertical_sample_rate);\n  dpx.television.frame_rate=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.frame_rate\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.frame_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.frame_rate);\n  dpx.television.time_offset=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.time_offset\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.time_offset=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.time_offset);\n  dpx.television.gamma=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.gamma\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.gamma=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.gamma);\n  dpx.television.black_level=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.black_level\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.black_level=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.black_level);\n  dpx.television.black_gain=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.black_gain\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.black_gain=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.black_gain);\n  dpx.television.break_point=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.break_point\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.break_point=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.break_point);\n  dpx.television.white_level=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.white_level\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.white_level=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.white_level);\n  dpx.television.integration_times=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.integration_times\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.integration_times=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.integration_times);\n  offset+=WriteBlob(image,sizeof(dpx.television.reserve),(unsigned char *)\n    dpx.television.reserve);\n  /*\n    Write user header.\n  */\n  value=GetDPXProperty(image,\"dpx:user.id\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.user.id,value,sizeof(dpx.user.id)-1);\n  offset+=WriteBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);\n  if (profile != (StringInfo *) NULL)\n    offset+=WriteBlob(image,GetStringInfoLength(profile),\n      GetStringInfoDatum(profile));\n  while (offset < (MagickOffsetType) dpx.image.image_element[0].data_offset)\n  {\n    count=WriteBlobByte(image,0x00);\n    if (count != 1)\n      {\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        break;\n      }\n    offset+=count;\n  }\n  /*\n    Convert pixel packets to DPX raster image.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,dpx.image.image_element[0].packing == 0 ?\n    MagickTrue : MagickFalse);\n  quantum_type=RGBQuantum;\n  if (image->alpha_trait != UndefinedPixelTrait)\n    quantum_type=RGBAQuantum;\n  if (image->colorspace == YCbCrColorspace)\n    {\n      quantum_type=CbYCrQuantum;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        quantum_type=CbYCrAQuantum;\n      if ((horizontal_factor == 2) || (vertical_factor == 2))\n        quantum_type=CbYCrYQuantum;\n    }\n  extent=GetBytesPerRow(image->columns,\n    image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL,image->depth,\n    dpx.image.image_element[0].packing == 0 ? MagickFalse : MagickTrue);\n  if ((image_info->type != TrueColorType) &&\n      (image->alpha_trait == UndefinedPixelTrait) &&\n      (SetImageGray(image,exception) != MagickFalse))\n    {\n      quantum_type=GrayQuantum;\n      extent=GetBytesPerRow(image->columns,1UL,image->depth,\n        dpx.image.image_element[0].packing == 0 ? MagickFalse : MagickTrue);\n    }\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    size_t\n      length;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    count=WriteBlob(image,extent,pixels);\n    if (count != (ssize_t) length)\n      break;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (y < (ssize_t) image->rows)\n    ThrowWriterException(CorruptImageError,\"UnableToWriteImageData\");\n  (void) CloseBlob(image);\n  return(status);\n}",
        "func": "static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  const StringInfo\n    *profile;\n\n  DPXInfo\n    dpx;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    flags;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    channels,\n    extent;\n\n  ssize_t\n    count,\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  time_t\n    seconds;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  horizontal_factor=4;\n  vertical_factor=4;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (horizontal_factor != 4) && (vertical_factor != 1) &&\n          (vertical_factor != 2) && (vertical_factor != 4))\n        ThrowWriterException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((image->colorspace == YCbCrColorspace) &&\n      ((horizontal_factor == 2) || (vertical_factor == 2)))\n    if ((image->columns % 2) != 0)\n      image->columns++;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Write file header.\n  */\n  (void) memset(&dpx,0,sizeof(dpx));\n  offset=0;\n  dpx.file.magic=0x53445058U;\n  offset+=WriteBlobLong(image,dpx.file.magic);\n  dpx.file.image_offset=0x2000U;\n  profile=GetImageProfile(image,\"dpx:user-data\");\n  if (profile != (StringInfo *) NULL)\n    {\n      if (GetStringInfoLength(profile) > 1048576)\n        ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n      dpx.file.image_offset+=(unsigned int) GetStringInfoLength(profile);\n      dpx.file.image_offset=(((dpx.file.image_offset+0x2000-1)/0x2000)*0x2000);\n    }\n  offset+=WriteBlobLong(image,dpx.file.image_offset);\n  (void) strncpy(dpx.file.version,\"V2.0\",sizeof(dpx.file.version)-1);\n  offset+=WriteBlob(image,8,(unsigned char *) &dpx.file.version);\n  channels=1;\n  if (IsImageGray(image) == MagickFalse)\n    channels=3;\n  if (image->alpha_trait != UndefinedPixelTrait)\n    channels++;\n  dpx.file.file_size=(unsigned int) (channels*image->columns*image->rows+\n    dpx.file.image_offset);\n  offset+=WriteBlobLong(image,dpx.file.file_size);\n  dpx.file.ditto_key=1U;  /* new frame */\n  offset+=WriteBlobLong(image,dpx.file.ditto_key);\n  dpx.file.generic_size=0x00000680U;\n  offset+=WriteBlobLong(image,dpx.file.generic_size);\n  dpx.file.industry_size=0x00000180U;\n  offset+=WriteBlobLong(image,dpx.file.industry_size);\n  dpx.file.user_size=0;\n  if (profile != (StringInfo *) NULL)\n    {\n      dpx.file.user_size+=(unsigned int) GetStringInfoLength(profile);\n      dpx.file.user_size=(((dpx.file.user_size+0x2000-1)/0x2000)*0x2000);\n    }\n  offset+=WriteBlobLong(image,dpx.file.user_size);\n  value=GetDPXProperty(image,\"dpx:file.filename\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.file.filename,value,sizeof(dpx.file.filename)-1);\n  offset+=WriteBlob(image,sizeof(dpx.file.filename),(unsigned char *)\n    dpx.file.filename);\n  seconds=time((time_t *) NULL);\n  (void) FormatMagickTime(seconds,sizeof(dpx.file.timestamp),\n    dpx.file.timestamp);\n  offset+=WriteBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)\n    dpx.file.timestamp);\n  (void) strncpy(dpx.file.creator,MagickAuthoritativeURL,\n    sizeof(dpx.file.creator)-1);\n  value=GetDPXProperty(image,\"dpx:file.creator\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.file.creator,value,sizeof(dpx.file.creator)-1);\n  offset+=WriteBlob(image,sizeof(dpx.file.creator),(unsigned char *)\n    dpx.file.creator);\n  value=GetDPXProperty(image,\"dpx:file.project\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.file.project,value,sizeof(dpx.file.project)-1);\n  offset+=WriteBlob(image,sizeof(dpx.file.project),(unsigned char *)\n    dpx.file.project);\n  value=GetDPXProperty(image,\"dpx:file.copyright\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.file.copyright,value,sizeof(dpx.file.copyright)-1);\n  offset+=WriteBlob(image,sizeof(dpx.file.copyright),(unsigned char *)\n    dpx.file.copyright);\n  dpx.file.encrypt_key=(~0U);\n  offset+=WriteBlobLong(image,dpx.file.encrypt_key);\n  offset+=WriteBlob(image,sizeof(dpx.file.reserve),(unsigned char *)\n    dpx.file.reserve);\n  /*\n    Write image header.\n  */\n  switch (image->orientation)\n  {\n    default:\n    case TopLeftOrientation: dpx.image.orientation=0; break;\n    case TopRightOrientation: dpx.image.orientation=1; break;\n    case BottomLeftOrientation: dpx.image.orientation=2; break;\n    case BottomRightOrientation: dpx.image.orientation=3; break;\n    case LeftTopOrientation: dpx.image.orientation=4; break;\n    case RightTopOrientation: dpx.image.orientation=5; break;\n    case LeftBottomOrientation: dpx.image.orientation=6; break;\n    case RightBottomOrientation: dpx.image.orientation=7; break;\n  }\n  offset+=WriteBlobShort(image,dpx.image.orientation);\n  dpx.image.number_elements=1;\n  offset+=WriteBlobShort(image,dpx.image.number_elements);\n  if ((image->columns != (unsigned int) image->columns) ||\n      (image->rows != (unsigned int) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  offset+=WriteBlobLong(image,(unsigned int) image->columns);\n  offset+=WriteBlobLong(image,(unsigned int) image->rows);\n  for (i=0; i < 8; i++)\n  {\n    dpx.image.image_element[i].data_sign=0U;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].data_sign);\n    dpx.image.image_element[i].low_data=0U;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].low_data);\n    dpx.image.image_element[i].low_quantity=0.0f;\n    offset+=WriteBlobFloat(image,dpx.image.image_element[i].low_quantity);\n    dpx.image.image_element[i].high_data=0U;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].high_data);\n    dpx.image.image_element[i].high_quantity=0.0f;\n    offset+=WriteBlobFloat(image,dpx.image.image_element[i].high_quantity);\n    dpx.image.image_element[i].descriptor=0;\n    if (i == 0)\n      switch (image->colorspace)\n      {\n        case Rec601YCbCrColorspace:\n        case Rec709YCbCrColorspace:\n        case YCbCrColorspace:\n        {\n          dpx.image.image_element[i].descriptor=CbYCr444ComponentType;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            dpx.image.image_element[i].descriptor=CbYCrA4444ComponentType;\n          break;\n        }\n        default:\n        {\n          dpx.image.image_element[i].descriptor=RGBComponentType;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            dpx.image.image_element[i].descriptor=RGBAComponentType;\n          if ((image_info->type != TrueColorType) &&\n              (image->alpha_trait == UndefinedPixelTrait) &&\n              (SetImageGray(image,exception) != MagickFalse))\n            dpx.image.image_element[i].descriptor=LumaComponentType;\n          break;\n        }\n      }\n    offset+=WriteBlobByte(image,dpx.image.image_element[i].descriptor);\n    dpx.image.image_element[i].transfer_characteristic=0;\n    if (image->colorspace == LogColorspace)\n      dpx.image.image_element[0].transfer_characteristic=\n        PrintingDensityColorimetric;\n    offset+=WriteBlobByte(image,\n      dpx.image.image_element[i].transfer_characteristic);\n    dpx.image.image_element[i].colorimetric=0;\n    offset+=WriteBlobByte(image,dpx.image.image_element[i].colorimetric);\n    dpx.image.image_element[i].bit_size=0;\n    if (i == 0)\n      dpx.image.image_element[i].bit_size=(unsigned char) image->depth;\n    offset+=WriteBlobByte(image,dpx.image.image_element[i].bit_size);\n    dpx.image.image_element[i].packing=0;\n    if ((image->depth == 10) || (image->depth == 12))\n      dpx.image.image_element[i].packing=1;\n    offset+=WriteBlobShort(image,dpx.image.image_element[i].packing);\n    dpx.image.image_element[i].encoding=0;\n    offset+=WriteBlobShort(image,dpx.image.image_element[i].encoding);\n    dpx.image.image_element[i].data_offset=0U;\n    if (i == 0)\n      dpx.image.image_element[i].data_offset=dpx.file.image_offset;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].data_offset);\n    dpx.image.image_element[i].end_of_line_padding=0U;\n    offset+=WriteBlobLong(image,dpx.image.image_element[i].end_of_line_padding);\n    offset+=WriteBlobLong(image,\n      dpx.image.image_element[i].end_of_image_padding);\n    offset+=WriteBlob(image,sizeof(dpx.image.image_element[i].description),\n      (unsigned char *) dpx.image.image_element[i].description);\n  }\n  offset+=WriteBlob(image,sizeof(dpx.image.reserve),(unsigned char *)\n    dpx.image.reserve);\n  /*\n    Write orientation header.\n  */\n  if ((image->rows != image->magick_rows) ||\n      (image->columns != image->magick_columns))\n    {\n      /*\n        These properties are not valid if image size changed.\n      */\n      (void) DeleteImageProperty(image,\"dpx:orientation.x_offset\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.y_offset\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.x_center\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.y_center\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.x_size\");\n      (void) DeleteImageProperty(image,\"dpx:orientation.y_size\");\n    }\n  dpx.orientation.x_offset=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.x_offset\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.x_offset=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.orientation.x_offset);\n  dpx.orientation.y_offset=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.y_offset\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.y_offset=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.orientation.y_offset);\n  dpx.orientation.x_center=0.0f;\n  value=GetDPXProperty(image,\"dpx:orientation.x_center\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.x_center=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.orientation.x_center);\n  dpx.orientation.y_center=0.0f;\n  value=GetDPXProperty(image,\"dpx:orientation.y_center\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.y_center=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.orientation.y_center);\n  dpx.orientation.x_size=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.x_size\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.x_size=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.orientation.x_size);\n  dpx.orientation.y_size=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.y_size\",exception);\n  if (value != (const char *) NULL)\n    dpx.orientation.y_size=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.orientation.y_size);\n  value=GetDPXProperty(image,\"dpx:orientation.filename\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.orientation.filename,value,\n      sizeof(dpx.orientation.filename)-1);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)\n    dpx.orientation.filename);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)\n    dpx.orientation.timestamp);\n  value=GetDPXProperty(image,\"dpx:orientation.device\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.orientation.device,value,\n      sizeof(dpx.orientation.device)-1);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.device),(unsigned char *)\n    dpx.orientation.device);\n  value=GetDPXProperty(image,\"dpx:orientation.serial\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.orientation.serial,value,\n      sizeof(dpx.orientation.serial)-1);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)\n    dpx.orientation.serial);\n  for (i=0; i < 4; i++)\n    dpx.orientation.border[i]=0;\n  value=GetDPXProperty(image,\"dpx:orientation.border\",exception);\n  if (value != (const char *) NULL)\n    {\n      flags=ParseGeometry(value,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      dpx.orientation.border[0]=(unsigned short) (geometry_info.rho+0.5);\n      dpx.orientation.border[1]=(unsigned short) (geometry_info.sigma+0.5);\n      dpx.orientation.border[2]=(unsigned short) (geometry_info.xi+0.5);\n      dpx.orientation.border[3]=(unsigned short) (geometry_info.psi+0.5);\n    }\n  for (i=0; i < 4; i++)\n    offset+=WriteBlobShort(image,dpx.orientation.border[i]);\n  for (i=0; i < 2; i++)\n    dpx.orientation.aspect_ratio[i]=0U;\n  value=GetDPXProperty(image,\"dpx:orientation.aspect_ratio\",exception);\n  if (value != (const char *) NULL)\n    {\n      flags=ParseGeometry(value,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      dpx.orientation.aspect_ratio[0]=(unsigned int) (geometry_info.rho+0.5);\n      dpx.orientation.aspect_ratio[1]=(unsigned int) (geometry_info.sigma+0.5);\n    }\n  for (i=0; i < 2; i++)\n    offset+=WriteBlobLong(image,dpx.orientation.aspect_ratio[i]);\n  offset+=WriteBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)\n    dpx.orientation.reserve);\n  /*\n    Write film header.\n  */\n  (void) memset(dpx.film.id,0,sizeof(dpx.film.id));\n  value=GetDPXProperty(image,\"dpx:film.id\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.id,value,sizeof(dpx.film.id)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);\n  (void) memset(dpx.film.type,0,sizeof(dpx.film.type));\n  value=GetDPXProperty(image,\"dpx:film.type\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.type,value,sizeof(dpx.film.type)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.type),(unsigned char *)\n    dpx.film.type);\n  (void) memset(dpx.film.offset,0,sizeof(dpx.film.offset));\n  value=GetDPXProperty(image,\"dpx:film.offset\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.offset,value,sizeof(dpx.film.offset)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.offset),(unsigned char *)\n    dpx.film.offset);\n  (void) memset(dpx.film.prefix,0,sizeof(dpx.film.prefix));\n  value=GetDPXProperty(image,\"dpx:film.prefix\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.prefix,value,sizeof(dpx.film.prefix)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.prefix),(unsigned char *)\n    dpx.film.prefix);\n  (void) memset(dpx.film.count,0,sizeof(dpx.film.count));\n  value=GetDPXProperty(image,\"dpx:film.count\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.count,value,sizeof(dpx.film.count)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.count),(unsigned char *)\n    dpx.film.count);\n  (void) memset(dpx.film.format,0,sizeof(dpx.film.format));\n  value=GetDPXProperty(image,\"dpx:film.format\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.format,value,sizeof(dpx.film.format)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.format),(unsigned char *)\n    dpx.film.format);\n  dpx.film.frame_position=0U;\n  value=GetDPXProperty(image,\"dpx:film.frame_position\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.frame_position=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.film.frame_position);\n  dpx.film.sequence_extent=0U;\n  value=GetDPXProperty(image,\"dpx:film.sequence_extent\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.sequence_extent=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.film.sequence_extent);\n  dpx.film.held_count=0U;\n  value=GetDPXProperty(image,\"dpx:film.held_count\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.held_count=(unsigned int) StringToUnsignedLong(value);\n  offset+=WriteBlobLong(image,dpx.film.held_count);\n  dpx.film.frame_rate=0.0f;\n  value=GetDPXProperty(image,\"dpx:film.frame_rate\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.frame_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.film.frame_rate);\n  dpx.film.shutter_angle=0.0f;\n  value=GetDPXProperty(image,\"dpx:film.shutter_angle\",exception);\n  if (value != (const char *) NULL)\n    dpx.film.shutter_angle=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.film.shutter_angle);\n  (void) memset(dpx.film.frame_id,0,sizeof(dpx.film.frame_id));\n  value=GetDPXProperty(image,\"dpx:film.frame_id\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.frame_id,value,sizeof(dpx.film.frame_id)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)\n    dpx.film.frame_id);\n  value=GetDPXProperty(image,\"dpx:film.slate\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.film.slate,value,sizeof(dpx.film.slate)-1);\n  offset+=WriteBlob(image,sizeof(dpx.film.slate),(unsigned char *)\n    dpx.film.slate);\n  offset+=WriteBlob(image,sizeof(dpx.film.reserve),(unsigned char *)\n    dpx.film.reserve);\n  /*\n    Write television header.\n  */\n  value=GetDPXProperty(image,\"dpx:television.time.code\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.time_code=StringToTimeCode(value);\n  offset+=WriteBlobLong(image,dpx.television.time_code);\n  value=GetDPXProperty(image,\"dpx:television.user.bits\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.user_bits=StringToTimeCode(value);\n  offset+=WriteBlobLong(image,dpx.television.user_bits);\n  value=GetDPXProperty(image,\"dpx:television.interlace\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.interlace=(unsigned char) StringToLong(value);\n  offset+=WriteBlobByte(image,dpx.television.interlace);\n  value=GetDPXProperty(image,\"dpx:television.field_number\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.field_number=(unsigned char) StringToLong(value);\n  offset+=WriteBlobByte(image,dpx.television.field_number);\n  dpx.television.video_signal=0;\n  value=GetDPXProperty(image,\"dpx:television.video_signal\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.video_signal=(unsigned char) StringToLong(value);\n  offset+=WriteBlobByte(image,dpx.television.video_signal);\n  dpx.television.padding=0;\n  value=GetDPXProperty(image,\"dpx:television.padding\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.padding=(unsigned char) StringToLong(value);\n  offset+=WriteBlobByte(image,dpx.television.padding);\n  dpx.television.horizontal_sample_rate=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.horizontal_sample_rate\",\n    exception);\n  if (value != (const char *) NULL)\n    dpx.television.horizontal_sample_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.horizontal_sample_rate);\n  dpx.television.vertical_sample_rate=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.vertical_sample_rate\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.vertical_sample_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.vertical_sample_rate);\n  dpx.television.frame_rate=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.frame_rate\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.frame_rate=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.frame_rate);\n  dpx.television.time_offset=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.time_offset\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.time_offset=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.time_offset);\n  dpx.television.gamma=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.gamma\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.gamma=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.gamma);\n  dpx.television.black_level=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.black_level\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.black_level=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.black_level);\n  dpx.television.black_gain=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.black_gain\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.black_gain=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.black_gain);\n  dpx.television.break_point=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.break_point\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.break_point=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.break_point);\n  dpx.television.white_level=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.white_level\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.white_level=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.white_level);\n  dpx.television.integration_times=0.0f;\n  value=GetDPXProperty(image,\"dpx:television.integration_times\",exception);\n  if (value != (const char *) NULL)\n    dpx.television.integration_times=StringToDouble(value,(char **) NULL);\n  offset+=WriteBlobFloat(image,dpx.television.integration_times);\n  offset+=WriteBlob(image,sizeof(dpx.television.reserve),(unsigned char *)\n    dpx.television.reserve);\n  /*\n    Write user header.\n  */\n  value=GetDPXProperty(image,\"dpx:user.id\",exception);\n  if (value != (const char *) NULL)\n    (void) strncpy(dpx.user.id,value,sizeof(dpx.user.id)-1);\n  offset+=WriteBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);\n  if (profile != (StringInfo *) NULL)\n    offset+=WriteBlob(image,GetStringInfoLength(profile),\n      GetStringInfoDatum(profile));\n  while (offset < (MagickOffsetType) dpx.image.image_element[0].data_offset)\n  {\n    count=WriteBlobByte(image,0x00);\n    if (count != 1)\n      {\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        break;\n      }\n    offset+=count;\n  }\n  /*\n    Convert pixel packets to DPX raster image.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,dpx.image.image_element[0].packing == 0 ?\n    MagickTrue : MagickFalse);\n  quantum_type=RGBQuantum;\n  if (image->alpha_trait != UndefinedPixelTrait)\n    quantum_type=RGBAQuantum;\n  if (image->colorspace == YCbCrColorspace)\n    {\n      quantum_type=CbYCrQuantum;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        quantum_type=CbYCrAQuantum;\n      if ((horizontal_factor == 2) || (vertical_factor == 2))\n        quantum_type=CbYCrYQuantum;\n    }\n  extent=GetBytesPerRow(image->columns,\n    image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL,image->depth,\n    dpx.image.image_element[0].packing == 0 ? MagickFalse : MagickTrue);\n  if ((image_info->type != TrueColorType) &&\n      (image->alpha_trait == UndefinedPixelTrait) &&\n      (SetImageGray(image,exception) != MagickFalse))\n    {\n      quantum_type=GrayQuantum;\n      extent=GetBytesPerRow(image->columns,1UL,image->depth,\n        dpx.image.image_element[0].packing == 0 ? MagickFalse : MagickTrue);\n    }\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    size_t\n      length;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (length == 0)\n      break;\n    count=WriteBlob(image,extent,pixels);\n    if (count != (ssize_t) extent)\n      break;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (y < (ssize_t) image->rows)\n    ThrowWriterException(CorruptImageError,\"UnableToWriteImageData\");\n  (void) CloseBlob(image);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -562,8 +562,10 @@\n       break;\n     length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n       quantum_type,pixels,exception);\n+    if (length == 0)\n+      break;\n     count=WriteBlob(image,extent,pixels);\n-    if (count != (ssize_t) length)\n+    if (count != (ssize_t) extent)\n       break;\n     status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n       image->rows);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (count != (ssize_t) length)"
            ],
            "added_lines": [
                "    if (length == 0)",
                "      break;",
                "    if (count != (ssize_t) extent)"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12976",
        "func_name": "ImageMagick/ReadPCLImage",
        "description": "ImageMagick 7.0.8-34 has a memory leak in the ReadPCLImage function in coders/pcl.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/c0fe488e7052f68d4eb7768805a857ef6fef928d",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1520",
        "commit_text": "",
        "func_before": "static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *options,\n    input_filename[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    c;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  /*\n    Determine page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n      {\n        /*\n          Note region defined by crop box.\n        */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n          Note region defined by media box.\n        */\n        count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n    */\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n    if (width > page.width)\n      page.width=width;\n    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    return((Image *) NULL);\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n     page.width,(double) page.height);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n      else\n        (void) FormatLocaleString(options,MagickPathExtent,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n          (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n    read_info->filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    image->page=page;\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *options,\n    input_filename[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    c;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  /*\n    Determine page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n      {\n        /*\n          Note region defined by crop box.\n        */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n          Note region defined by media box.\n        */\n        count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n    */\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n    if (width > page.width)\n      page.width=width;\n    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n      else\n        (void) FormatLocaleString(options,MagickPathExtent,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n          (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n    read_info->filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    image->page=page;\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -174,7 +174,10 @@\n      else\n        delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n   if (delegate_info == (const DelegateInfo *) NULL)\n-    return((Image *) NULL);\n+    {\n+      image=DestroyImage(image);\n+      return((Image *) NULL);\n+    }\n   if ((page.width == 0) || (page.height == 0))\n     (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n   if (image_info->page != (char *) NULL)\n@@ -186,7 +189,7 @@\n   page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n   page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n   (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n-     page.width,(double) page.height);\n+    page.width,(double) page.height);\n   image=DestroyImage(image);\n   read_info=CloneImageInfo(image_info);\n   *read_info->magick='\\0';",
        "diff_line_info": {
            "deleted_lines": [
                "    return((Image *) NULL);",
                "     page.width,(double) page.height);"
            ],
            "added_lines": [
                "    {",
                "      image=DestroyImage(image);",
                "      return((Image *) NULL);",
                "    }",
                "    page.width,(double) page.height);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13133",
        "func_name": "ImageMagick/ReadVIFFImage",
        "description": "ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadBMPImage in coders/bmp.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/fe3066122ef72c82415811d25e9e3fad622c0a99",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1600",
        "commit_text": "",
        "func_before": "static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    if (count != 512)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=ReadBlobSignedLong(image);\n    viff_info.y_offset=ReadBlobSignedLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    /*\n      Verify that we can read this VIFF image.\n    */\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if ((MagickSizeType) (viff_info.map_rows*image->colors) > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((MagickSizeType) viff_info.map_rows > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if ((MagickSizeType) viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=(MagickRealType)\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Create bi-level colormap.\n        */\n        image->colors=2;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        image->colorspace=GRAYColorspace;\n      }\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (HeapOverflowSanityCheck((size_t) number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    if ((MagickSizeType) (bytes_per_pixel*max_packets) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pixels=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n      number_pixels,max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pixels,0,MagickMax(number_pixels,max_packets)*\n      bytes_per_pixel*sizeof(*pixels));\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red),q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green),q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue),q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count == 1) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    if (count != 512)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=ReadBlobSignedLong(image);\n    viff_info.y_offset=ReadBlobSignedLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    /*\n      Verify that we can read this VIFF image.\n    */\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if ((MagickSizeType) (viff_info.map_rows*image->colors) > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((MagickSizeType) viff_info.map_rows > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if ((MagickSizeType) viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=(MagickRealType)\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Create bi-level colormap.\n        */\n        image->colors=2;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        image->colorspace=GRAYColorspace;\n      }\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (HeapOverflowSanityCheck((size_t) number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    if ((MagickSizeType) (bytes_per_pixel*max_packets) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pixels=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n      number_pixels,max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pixels,0,MagickMax(number_pixels,max_packets)*\n      bytes_per_pixel*sizeof(*pixels));\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red),q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green),q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue),q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count == 1) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -633,8 +633,8 @@\n         AcquireNextImage(image_info,image,exception);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n-            image=DestroyImageList(image);\n-            return((Image *) NULL);\n+            status=MagickFalse;\n+            break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),",
        "diff_line_info": {
            "deleted_lines": [
                "            image=DestroyImageList(image);",
                "            return((Image *) NULL);"
            ],
            "added_lines": [
                "            status=MagickFalse;",
                "            break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13137",
        "func_name": "ImageMagick/ReadPSImage",
        "description": "ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadPSImage in coders/ps.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1601",
        "commit_text": "",
        "func_before": "static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"BoundingBox:\"\n#define BeginDocument  \"BeginDocument:\"\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define ICCProfile \"BeginICCProfile:\"\n#define CMYKCustomColor  \"CMYKCustomColor:\"\n#define CMYKProcessColor  \"CMYKProcessColor:\"\n#define DocumentMedia  \"DocumentMedia:\"\n#define DocumentCustomColors  \"DocumentCustomColors:\"\n#define DocumentProcessColors  \"DocumentProcessColors:\"\n#define EndDocument  \"EndDocument:\"\n#define HiResBoundingBox  \"HiResBoundingBox:\"\n#define ImageData  \"ImageData:\"\n#define PageBoundingBox  \"PageBoundingBox:\"\n#define LanguageLevel  \"LanguageLevel:\"\n#define PageMedia  \"PageMedia:\"\n#define Pages  \"Pages:\"\n#define PhotoshopProfile  \"BeginPhotoshop:\"\n#define PostscriptLevel  \"!PS-\"\n#define RenderPostscriptText  \"  Rendering Postscript...  \"\n#define SpotColor  \"+ \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    priority;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) memset(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution=image->resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) memset(&hires_bounds,0,sizeof(hires_bounds));\n  columns=0;\n  rows=0;\n  priority=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  pages=(~0UL);\n  skip=MagickFalse;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4,exception);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\"*Cyan*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Magenta*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Yellow*\",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MagickPathExtent],\n          *value;\n\n        register char\n          *q;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\n          \"ps:SpotColor-%.20g\",(double) (spotcolor++));\n        for (q=command; *q != '\\0'; q++)\n          if (isspace((int) (unsigned char) *q) != 0)\n            break;\n        value=ConstantString(q);\n        (void) SubstituteString(&value,\"(\",\"\");\n        (void) SubstituteString(&value,\")\",\"\");\n        (void) StripString(value);\n        if (*value != '\\0')\n          (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i ==  (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&\n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"ps:HiResBoundingBox\",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"eps:fit-page\");\n  if (option != (char *) NULL)\n    {\n      char\n        *page_geometry;\n\n      page_geometry=GetPageGeometry(option);\n      flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n        &page.height);\n      if (flags == NoValue)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"InvalidGeometry\",\"`%s'\",option);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n        -0.5);\n      page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n        delta.y) -0.5);\n      page_geometry=DestroyString(page_geometry);\n      fitPage=MagickTrue;\n    }\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\"/setpagedevice {pop} bind 1 index where {\"\n    \"dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\"\n    \"<</UseCIEColor true>>setpagedevice\\n\",MagickPathExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MagickPathExtent];\n\n      (void) FormatLocaleString(translate_geometry,MagickPathExtent,\n        \"%g %g translate\\n\",-bounds.x1,-bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g \",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\"eps:use-cropbox\");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\"-dEPSCrop \",MagickPathExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",\n          MagickPathExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename,exception);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\" -c showpage\",MagickPathExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          DelegateError,\"PostscriptDelegateFailed\",\"`%s'\",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  (void) SeekBlob(image,0,SEEK_SET);\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MagickPathExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\"icc\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *q;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \" %lu\",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n        if ((MagickSizeType) length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        profile=BlobToStringInfo((const void *) NULL,length);\n        if (profile != (StringInfo *) NULL)\n          {\n            q=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *q++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\"8bim\",profile,exception);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=(ssize_t) GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,(size_t) (i+1));\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,(size_t) i);\n        (void) SetImageProfile(image,\"xmp\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,\n      MagickPathExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MagickPathExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}",
        "func": "static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"BoundingBox:\"\n#define BeginDocument  \"BeginDocument:\"\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define ICCProfile \"BeginICCProfile:\"\n#define CMYKCustomColor  \"CMYKCustomColor:\"\n#define CMYKProcessColor  \"CMYKProcessColor:\"\n#define DocumentMedia  \"DocumentMedia:\"\n#define DocumentCustomColors  \"DocumentCustomColors:\"\n#define DocumentProcessColors  \"DocumentProcessColors:\"\n#define EndDocument  \"EndDocument:\"\n#define HiResBoundingBox  \"HiResBoundingBox:\"\n#define ImageData  \"ImageData:\"\n#define PageBoundingBox  \"PageBoundingBox:\"\n#define LanguageLevel  \"LanguageLevel:\"\n#define PageMedia  \"PageMedia:\"\n#define Pages  \"Pages:\"\n#define PhotoshopProfile  \"BeginPhotoshop:\"\n#define PostscriptLevel  \"!PS-\"\n#define RenderPostscriptText  \"  Rendering Postscript...  \"\n#define SpotColor  \"+ \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    priority;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) memset(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution=image->resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) memset(&hires_bounds,0,sizeof(hires_bounds));\n  columns=0;\n  rows=0;\n  priority=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  pages=(~0UL);\n  skip=MagickFalse;\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4,exception);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\"*Cyan*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Magenta*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Yellow*\",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MagickPathExtent],\n          *value;\n\n        register char\n          *q;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MagickPathExtent,\n          \"ps:SpotColor-%.20g\",(double) (spotcolor++));\n        for (q=command; *q != '\\0'; q++)\n          if (isspace((int) (unsigned char) *q) != 0)\n            break;\n        value=ConstantString(q);\n        (void) SubstituteString(&value,\"(\",\"\");\n        (void) SubstituteString(&value,\")\",\"\");\n        (void) StripString(value);\n        if (*value != '\\0')\n          (void) SetImageProperty(image,property,value,exception);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i ==  (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&\n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MagickPathExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"ps:HiResBoundingBox\",geometry,exception);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"eps:fit-page\");\n  if (option != (char *) NULL)\n    {\n      char\n        *page_geometry;\n\n      page_geometry=GetPageGeometry(option);\n      flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n        &page.height);\n      if (flags == NoValue)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"InvalidGeometry\",\"`%s'\",option);\n          page_geometry=DestroyString(page_geometry);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      page.width=(size_t) ceil((double) (page.width*image->resolution.x/delta.x)\n        -0.5);\n      page.height=(size_t) ceil((double) (page.height*image->resolution.y/\n        delta.y) -0.5);\n      page_geometry=DestroyString(page_geometry);\n      fitPage=MagickTrue;\n    }\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\"/setpagedevice {pop} bind 1 index where {\"\n    \"dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\"\n    \"<</UseCIEColor true>>setpagedevice\\n\",MagickPathExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MagickPathExtent];\n\n      (void) FormatLocaleString(translate_geometry,MagickPathExtent,\n        \"%g %g translate\\n\",-bounds.x1,-bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g \",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\"eps:use-cropbox\");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\"-dEPSCrop \",MagickPathExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",\n          MagickPathExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename,exception);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\" -c showpage\",MagickPathExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          DelegateError,\"PostscriptDelegateFailed\",\"`%s'\",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  (void) SeekBlob(image,0,SEEK_SET);\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MagickPathExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\"icc\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *q;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \" %lu\",&extent);\n        if (count != 1)\n          continue;\n        length=extent;\n        if ((MagickSizeType) length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        profile=BlobToStringInfo((const void *) NULL,length);\n        if (profile != (StringInfo *) NULL)\n          {\n            q=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *q++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\"8bim\",profile,exception);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=(ssize_t) GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,(size_t) (i+1));\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MagickPathExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,(size_t) i);\n        (void) SetImageProfile(image,\"xmp\",profile,exception);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,\n      MagickPathExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MagickPathExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -347,6 +347,7 @@\n         {\n           (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"InvalidGeometry\",\"`%s'\",option);\n+          page_geometry=DestroyString(page_geometry);\n           image=DestroyImage(image);\n           return((Image *) NULL);\n         }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "          page_geometry=DestroyString(page_geometry);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13301",
        "func_name": "ImageMagick/AnnotateImage",
        "description": "ImageMagick 7.0.8-50 Q16 has memory leaks in AcquireMagickMemory because of an AnnotateImage error.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/f595a1985233c399a05c0c37cc41de16a90dd025",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1589",
        "commit_text": "",
        "func_before": "MagickExport MagickBooleanType AnnotateImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  char\n    *p,\n    primitive[MagickPathExtent],\n    *text,\n    **textlist;\n\n  DrawInfo\n    *annotate,\n    *annotate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    number_lines;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (draw_info->text == (char *) NULL)\n    return(MagickFalse);\n  if (*draw_info->text == '\\0')\n    return(MagickTrue);\n  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  text=annotate->text;\n  annotate->text=(char *) NULL;\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  number_lines=1;\n  for (p=text; *p != '\\0'; p++)\n    if (*p == '\\n')\n      number_lines++;\n  textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    return(MagickFalse);\n  p=text;\n  for (i=0; i < number_lines; i++)\n  {\n    char\n      *q;\n\n    textlist[i]=p;\n    for (q=p; *q != '\\0'; q++)\n      if ((*q == '\\r') || (*q == '\\n'))\n        break;\n    if (*q == '\\r')\n      {\n        *q='\\0';\n        q++;\n      }\n    *q='\\0';\n    p=q+1;\n  }\n  textlist[i]=(char *) NULL;\n  SetGeometry(image,&geometry);\n  SetGeometryInfo(&geometry_info);\n  if (annotate_info->geometry != (char *) NULL)\n    {\n      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,\n        exception);\n      (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n    }\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  status=MagickTrue;\n  (void) memset(&metrics,0,sizeof(metrics));\n  for (i=0; textlist[i] != (char *) NULL; i++)\n  {\n    if (*textlist[i] == '\\0')\n      continue;\n    /*\n      Position text relative to image.\n    */\n    annotate_info->affine.tx=geometry_info.xi-image->page.x;\n    annotate_info->affine.ty=geometry_info.psi-image->page.y;\n    (void) CloneString(&annotate->text,textlist[i]);\n    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))\n      (void) GetTypeMetrics(image,annotate,&metrics,exception);\n    height=(ssize_t) (metrics.ascent-metrics.descent+\n      draw_info->interline_spacing+0.5);\n    switch (annotate->gravity)\n    {\n      case UndefinedGravity:\n      default:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case NorthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent;\n        break;\n      }\n      case NorthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case NorthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent)-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      case WestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case CenterGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case EastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+\n          annotate_info->affine.ry*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case SouthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height-annotate_info->affine.ry*\n          (number_lines-1.0)*height;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0-\n          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width-\n          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n    }\n    switch (annotate->align)\n    {\n      case LeftAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case CenterAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case RightAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      default:\n        break;\n    }\n    if (draw_info->undercolor.alpha != TransparentAlpha)\n      {\n        DrawInfo\n          *undercolor_info;\n\n        /*\n          Text box.\n        */\n        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);\n        undercolor_info->fill=draw_info->undercolor;\n        undercolor_info->affine=draw_info->affine;\n        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;\n        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;\n        (void) FormatLocaleString(primitive,MagickPathExtent,\n          \"rectangle 0.0,0.0 %g,%g\",metrics.origin.x,(double) height);\n        (void) CloneString(&undercolor_info->primitive,primitive);\n        (void) DrawImage(image,undercolor_info,exception);\n        (void) DestroyDrawInfo(undercolor_info);\n      }\n    annotate_info->affine.tx=offset.x;\n    annotate_info->affine.ty=offset.y;\n    (void) FormatLocaleString(primitive,MagickPathExtent,\"stroke-width %g \"\n      \"line 0,0 %g,0\",metrics.underline_thickness,metrics.width);\n    if (annotate->decorate == OverlineDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+\n          metrics.descent-metrics.underline_position));\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n    else\n      if (annotate->decorate == UnderlineDecoration)\n        {\n          annotate_info->affine.ty-=(draw_info->affine.sy*\n            metrics.underline_position);\n          (void) CloneString(&annotate_info->primitive,primitive);\n          (void) DrawImage(image,annotate_info,exception);\n        }\n    /*\n      Annotate image with text.\n    */\n    status=RenderType(image,annotate,&offset,&metrics,exception);\n    if (status == MagickFalse)\n      break;\n    if (annotate->decorate == LineThroughDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(height+\n          metrics.underline_position+metrics.descent)/2.0);\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  annotate=DestroyDrawInfo(annotate);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}",
        "func": "MagickExport MagickBooleanType AnnotateImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  char\n    *p,\n    primitive[MagickPathExtent],\n    *text,\n    **textlist;\n\n  DrawInfo\n    *annotate,\n    *annotate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    number_lines;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (draw_info->text == (char *) NULL)\n    return(MagickFalse);\n  if (*draw_info->text == '\\0')\n    return(MagickTrue);\n  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  text=annotate->text;\n  annotate->text=(char *) NULL;\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  number_lines=1;\n  for (p=text; *p != '\\0'; p++)\n    if (*p == '\\n')\n      number_lines++;\n  textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      return(MagickFalse);\n    }\n  p=text;\n  for (i=0; i < number_lines; i++)\n  {\n    char\n      *q;\n\n    textlist[i]=p;\n    for (q=p; *q != '\\0'; q++)\n      if ((*q == '\\r') || (*q == '\\n'))\n        break;\n    if (*q == '\\r')\n      {\n        *q='\\0';\n        q++;\n      }\n    *q='\\0';\n    p=q+1;\n  }\n  textlist[i]=(char *) NULL;\n  SetGeometry(image,&geometry);\n  SetGeometryInfo(&geometry_info);\n  if (annotate_info->geometry != (char *) NULL)\n    {\n      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,\n        exception);\n      (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n    }\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      textlist=(char **) RelinquishMagickMemory(textlist);\n      return(MagickFalse);\n    }\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  status=MagickTrue;\n  (void) memset(&metrics,0,sizeof(metrics));\n  for (i=0; textlist[i] != (char *) NULL; i++)\n  {\n    if (*textlist[i] == '\\0')\n      continue;\n    /*\n      Position text relative to image.\n    */\n    annotate_info->affine.tx=geometry_info.xi-image->page.x;\n    annotate_info->affine.ty=geometry_info.psi-image->page.y;\n    (void) CloneString(&annotate->text,textlist[i]);\n    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))\n      (void) GetTypeMetrics(image,annotate,&metrics,exception);\n    height=(ssize_t) (metrics.ascent-metrics.descent+\n      draw_info->interline_spacing+0.5);\n    switch (annotate->gravity)\n    {\n      case UndefinedGravity:\n      default:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case NorthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent;\n        break;\n      }\n      case NorthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case NorthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent)-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      case WestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case CenterGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case EastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+\n          annotate_info->affine.ry*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case SouthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height-annotate_info->affine.ry*\n          (number_lines-1.0)*height;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0-\n          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width-\n          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n    }\n    switch (annotate->align)\n    {\n      case LeftAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case CenterAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case RightAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      default:\n        break;\n    }\n    if (draw_info->undercolor.alpha != TransparentAlpha)\n      {\n        DrawInfo\n          *undercolor_info;\n\n        /*\n          Text box.\n        */\n        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);\n        undercolor_info->fill=draw_info->undercolor;\n        undercolor_info->affine=draw_info->affine;\n        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;\n        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;\n        (void) FormatLocaleString(primitive,MagickPathExtent,\n          \"rectangle 0.0,0.0 %g,%g\",metrics.origin.x,(double) height);\n        (void) CloneString(&undercolor_info->primitive,primitive);\n        (void) DrawImage(image,undercolor_info,exception);\n        (void) DestroyDrawInfo(undercolor_info);\n      }\n    annotate_info->affine.tx=offset.x;\n    annotate_info->affine.ty=offset.y;\n    (void) FormatLocaleString(primitive,MagickPathExtent,\"stroke-width %g \"\n      \"line 0,0 %g,0\",metrics.underline_thickness,metrics.width);\n    if (annotate->decorate == OverlineDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+\n          metrics.descent-metrics.underline_position));\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n    else\n      if (annotate->decorate == UnderlineDecoration)\n        {\n          annotate_info->affine.ty-=(draw_info->affine.sy*\n            metrics.underline_position);\n          (void) CloneString(&annotate_info->primitive,primitive);\n          (void) DrawImage(image,annotate_info,exception);\n        }\n    /*\n      Annotate image with text.\n    */\n    status=RenderType(image,annotate,&offset,&metrics,exception);\n    if (status == MagickFalse)\n      break;\n    if (annotate->decorate == LineThroughDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(height+\n          metrics.underline_position+metrics.descent)/2.0);\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  annotate=DestroyDrawInfo(annotate);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,7 +53,11 @@\n       number_lines++;\n   textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n   if (textlist == (char **) NULL)\n-    return(MagickFalse);\n+    {\n+      annotate_info=DestroyDrawInfo(annotate_info);\n+      annotate=DestroyDrawInfo(annotate);\n+      return(MagickFalse);\n+    }\n   p=text;\n   for (i=0; i < number_lines; i++)\n   {\n@@ -82,7 +86,12 @@\n       (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n     }\n   if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n-    return(MagickFalse);\n+    {\n+      annotate_info=DestroyDrawInfo(annotate_info);\n+      annotate=DestroyDrawInfo(annotate);\n+      textlist=(char **) RelinquishMagickMemory(textlist);\n+      return(MagickFalse);\n+    }\n   if (IsGrayColorspace(image->colorspace) != MagickFalse)\n     (void) SetImageColorspace(image,sRGBColorspace,exception);\n   status=MagickTrue;",
        "diff_line_info": {
            "deleted_lines": [
                "    return(MagickFalse);",
                "    return(MagickFalse);"
            ],
            "added_lines": [
                "    {",
                "      annotate_info=DestroyDrawInfo(annotate_info);",
                "      annotate=DestroyDrawInfo(annotate);",
                "      return(MagickFalse);",
                "    }",
                "    {",
                "      annotate_info=DestroyDrawInfo(annotate_info);",
                "      annotate=DestroyDrawInfo(annotate);",
                "      textlist=(char **) RelinquishMagickMemory(textlist);",
                "      return(MagickFalse);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15134",
        "func_name": "RIOT-OS/RIOT/_receive",
        "description": "RIOT through 2019.07 contains a memory leak in the TCP implementation (gnrc_tcp), allowing an attacker to consume all memory available for network packets and thus effectively stopping all network threads from working. This is related to _receive in sys/net/gnrc/transport_layer/tcp/gnrc_tcp_eventloop.c upon receiving an ACK before a SYN.",
        "git_url": "https://github.com/RIOT-OS/RIOT/commit/c6df2064aff1ffb4015d4cedbaefb8850cb50aa8",
        "commit_title": "gnrc_tcp: Fix memory leak",
        "commit_text": "",
        "func_before": "static int _receive(gnrc_pktsnip_t *pkt)\n{\n    /* NOTE: In receiving direction: pkt = payload, payload->next = tcp, tcp->next = nw */\n    uint16_t ctl = 0;\n    uint16_t src = 0;\n    uint16_t dst = 0;\n    uint8_t hdr_size = 0;\n    uint8_t syn = 0;\n    gnrc_pktsnip_t *ip = NULL;\n    gnrc_pktsnip_t *reset = NULL;\n    gnrc_tcp_tcb_t *tcb = NULL;\n    tcp_hdr_t *hdr;\n\n    /* Get write access to the TCP header */\n    gnrc_pktsnip_t *tcp = gnrc_pktbuf_start_write(pkt);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EACCES;\n    }\n    pkt = tcp;\n\n#ifdef MODULE_GNRC_IPV6\n    /* Get IPv6 header, discard packet if doesn't contain an ip header */\n    LL_SEARCH_SCALAR(pkt, ip, type, GNRC_NETTYPE_IPV6);\n    if (ip == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n#endif\n\n    /* Get TCP header */\n    LL_SEARCH_SCALAR(pkt, tcp, type, GNRC_NETTYPE_TCP);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n\n    /* Extract control bits, src and dst ports and check if SYN is set (not SYN+ACK) */\n    hdr = (tcp_hdr_t *)tcp->data;\n    ctl = byteorder_ntohs(hdr->off_ctl);\n    src = byteorder_ntohs(hdr->src_port);\n    dst = byteorder_ntohs(hdr->dst_port);\n    syn = ((ctl & MSK_SYN_ACK) == MSK_SYN);\n\n    /* Validate offset */\n    if (GET_OFFSET(ctl) < TCP_HDR_OFFSET_MIN) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ERANGE;\n    }\n\n    /* Calculate TCP header size */\n    hdr_size = GET_OFFSET(ctl) * 4;\n\n    /* Mark TCP header if it contains any payload */\n    if ((pkt->type == GNRC_NETTYPE_TCP) && (pkt->size != hdr_size)) {\n        tcp = gnrc_pktbuf_mark(pkt, hdr_size, GNRC_NETTYPE_TCP);\n        if (tcp == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(pkt);\n            return -ENOMSG;\n        }\n        pkt->type = GNRC_NETTYPE_UNDEF;\n    }\n\n    /* Validate checksum */\n    if (byteorder_ntohs(hdr->checksum) != _pkt_calc_csum(tcp, ip, pkt)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EINVAL;\n    }\n\n    /* Find TCB to for this packet */\n    mutex_lock(&_list_tcb_lock);\n    tcb = _list_tcb_head;\n    while (tcb) {\n#ifdef MODULE_GNRC_IPV6\n        /* Check if current TCB is fitting for the incomming packet */\n        if (ip->type == GNRC_NETTYPE_IPV6 && tcb->address_family == AF_INET6) {\n            /* If SYN is set, a connection is listening on that port ... */\n            ipv6_addr_t *tmp_addr = NULL;\n            if (syn && tcb->local_port == dst && tcb->state == FSM_STATE_LISTEN) {\n                /* ... and local addr is unspec or pre configured */\n                tmp_addr = &((ipv6_hdr_t *)ip->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->local_addr, (ipv6_addr_t *) tmp_addr) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) tcb->local_addr)) {\n                    break;\n                }\n            }\n\n            /* If SYN is not set and the ports match ... */\n            if (!syn && tcb->local_port == dst && tcb->peer_port == src) {\n                /* .. and the IPv6 addresses match */\n                tmp_addr = &((ipv6_hdr_t * )ip->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->peer_addr, (ipv6_addr_t *) tmp_addr)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* Supress compiler warnings if TCP is build without network layer */\n        (void) syn;\n        (void) src;\n        (void) dst;\n#endif\n        tcb = tcb->next;\n    }\n    mutex_unlock(&_list_tcb_lock);\n\n    /* Call FSM with event RCVD_PKT if a fitting TCB was found */\n    if (tcb != NULL) {\n        _fsm(tcb, FSM_EVENT_RCVD_PKT, pkt, NULL, 0);\n    }\n    /* No fitting TCB has been found. Respond with reset */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((ctl & MSK_RST) != MSK_RST) {\n            _pkt_build_reset_from_pkt(&reset, pkt);\n            gnrc_netapi_send(gnrc_tcp_pid, reset);\n        }\n        return -ENOTCONN;\n    }\n    gnrc_pktbuf_release(pkt);\n    return 0;\n}",
        "func": "static int _receive(gnrc_pktsnip_t *pkt)\n{\n    /* NOTE: In receiving direction: pkt = payload, payload->next = tcp, tcp->next = nw */\n    uint16_t ctl = 0;\n    uint16_t src = 0;\n    uint16_t dst = 0;\n    uint8_t hdr_size = 0;\n    uint8_t syn = 0;\n    gnrc_pktsnip_t *ip = NULL;\n    gnrc_pktsnip_t *reset = NULL;\n    gnrc_tcp_tcb_t *tcb = NULL;\n    tcp_hdr_t *hdr;\n\n    /* Get write access to the TCP header */\n    gnrc_pktsnip_t *tcp = gnrc_pktbuf_start_write(pkt);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : can't write to packet\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EACCES;\n    }\n    pkt = tcp;\n\n#ifdef MODULE_GNRC_IPV6\n    /* Get IPv6 header, discard packet if doesn't contain an ip header */\n    LL_SEARCH_SCALAR(pkt, ip, type, GNRC_NETTYPE_IPV6);\n    if (ip == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no IP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n#endif\n\n    /* Get TCP header */\n    LL_SEARCH_SCALAR(pkt, tcp, type, GNRC_NETTYPE_TCP);\n    if (tcp == NULL) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : pkt contains no TCP Header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return 0;\n    }\n\n    /* Extract control bits, src and dst ports and check if SYN is set (not SYN+ACK) */\n    hdr = (tcp_hdr_t *)tcp->data;\n    ctl = byteorder_ntohs(hdr->off_ctl);\n    src = byteorder_ntohs(hdr->src_port);\n    dst = byteorder_ntohs(hdr->dst_port);\n    syn = ((ctl & MSK_SYN_ACK) == MSK_SYN);\n\n    /* Validate offset */\n    if (GET_OFFSET(ctl) < TCP_HDR_OFFSET_MIN) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : unexpected Offset Value\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ERANGE;\n    }\n\n    /* Calculate TCP header size */\n    hdr_size = GET_OFFSET(ctl) * 4;\n\n    /* Mark TCP header if it contains any payload */\n    if ((pkt->type == GNRC_NETTYPE_TCP) && (pkt->size != hdr_size)) {\n        tcp = gnrc_pktbuf_mark(pkt, hdr_size, GNRC_NETTYPE_TCP);\n        if (tcp == NULL) {\n            DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Header marking failed\\n\");\n            gnrc_pktbuf_release(pkt);\n            return -ENOMSG;\n        }\n        pkt->type = GNRC_NETTYPE_UNDEF;\n    }\n\n    /* Validate checksum */\n    if (byteorder_ntohs(hdr->checksum) != _pkt_calc_csum(tcp, ip, pkt)) {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Invalid checksum\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -EINVAL;\n    }\n\n    /* Find TCB to for this packet */\n    mutex_lock(&_list_tcb_lock);\n    tcb = _list_tcb_head;\n    while (tcb) {\n#ifdef MODULE_GNRC_IPV6\n        /* Check if current TCB is fitting for the incomming packet */\n        if (ip->type == GNRC_NETTYPE_IPV6 && tcb->address_family == AF_INET6) {\n            /* If SYN is set, a connection is listening on that port ... */\n            ipv6_addr_t *tmp_addr = NULL;\n            if (syn && tcb->local_port == dst && tcb->state == FSM_STATE_LISTEN) {\n                /* ... and local addr is unspec or pre configured */\n                tmp_addr = &((ipv6_hdr_t *)ip->data)->dst;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->local_addr, (ipv6_addr_t *) tmp_addr) ||\n                    ipv6_addr_is_unspecified((ipv6_addr_t *) tcb->local_addr)) {\n                    break;\n                }\n            }\n\n            /* If SYN is not set and the ports match ... */\n            if (!syn && tcb->local_port == dst && tcb->peer_port == src) {\n                /* .. and the IPv6 addresses match */\n                tmp_addr = &((ipv6_hdr_t * )ip->data)->src;\n                if (ipv6_addr_equal((ipv6_addr_t *) tcb->peer_addr, (ipv6_addr_t *) tmp_addr)) {\n                    break;\n                }\n            }\n        }\n#else\n        /* Supress compiler warnings if TCP is build without network layer */\n        (void) syn;\n        (void) src;\n        (void) dst;\n#endif\n        tcb = tcb->next;\n    }\n    mutex_unlock(&_list_tcb_lock);\n\n    /* Call FSM with event RCVD_PKT if a fitting TCB was found */\n    if (tcb != NULL) {\n        _fsm(tcb, FSM_EVENT_RCVD_PKT, pkt, NULL, 0);\n    }\n    /* No fitting TCB has been found. Respond with reset */\n    else {\n        DEBUG(\"gnrc_tcp_eventloop.c : _receive() : Can't find fitting tcb\\n\");\n        if ((ctl & MSK_RST) != MSK_RST) {\n            _pkt_build_reset_from_pkt(&reset, pkt);\n            gnrc_netapi_send(gnrc_tcp_pid, reset);\n        }\n        gnrc_pktbuf_release(pkt);\n        return -ENOTCONN;\n    }\n    gnrc_pktbuf_release(pkt);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -121,6 +121,7 @@\n             _pkt_build_reset_from_pkt(&reset, pkt);\n             gnrc_netapi_send(gnrc_tcp_pid, reset);\n         }\n+        gnrc_pktbuf_release(pkt);\n         return -ENOTCONN;\n     }\n     gnrc_pktbuf_release(pkt);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        gnrc_pktbuf_release(pkt);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15807",
        "func_name": "torvalds/linux/sas_ex_discover_expander",
        "description": "In the Linux kernel before 5.1.13, there is a memory leak in drivers/scsi/libsas/sas_expander.c when SAS expander discovery fails. This will cause a BUG and denial of service.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3b0541791453fbe7f42867e310e0c9eb6295364d",
        "commit_title": "The sas_port(phy->port) allocated in sas_ex_discover_expander() will not be",
        "commit_text": "deleted when the expander failed to discover. This will cause resource leak and a further issue of kernel BUG like below:  [159785.843156]  port-2:17:29: trying to add phy phy-2:17:29 fails: it's already part of another port [159785.852144] ------------[ cut here  ]------------ [159785.856833] kernel BUG at drivers/scsi/scsi_transport_sas.c:1086! [159785.863000] Internal error: Oops - BUG: 0 [#1] SMP [159785.867866] CPU: 39 PID: 16993 Comm: kworker/u96:2 Tainted: G W  OE     4.19.25-vhulk1901.1.0.h111.aarch64 #1 [159785.878458] Hardware name: Huawei Technologies Co., Ltd. Hi1620EVBCS/Hi1620EVBCS, BIOS Hi1620 CS B070 1P TA 03/21/2019 [159785.889231] Workqueue: 0000:74:02.0_disco_q sas_discover_domain [159785.895224] pstate: 40c00009 (nZcv daif +PAN +UAO) [159785.900094] pc : sas_port_add_phy+0x188/0x1b8 [159785.904524] lr : sas_port_add_phy+0x188/0x1b8 [159785.908952] sp : ffff0001120e3b80 [159785.912341] x29: ffff0001120e3b80 x28: 0000000000000000 [159785.917727] x27: ffff802ade8f5400 x26: ffff0000681b7560 [159785.923111] x25: ffff802adf11a800 x24: ffff0000680e8000 [159785.928496] x23: ffff802ade8f5728 x22: ffff802ade8f5708 [159785.933880] x21: ffff802adea2db40 x20: ffff802ade8f5400 [159785.939264] x19: ffff802adea2d800 x18: 0000000000000010 [159785.944649] x17: 00000000821bf734 x16: ffff00006714faa0 [159785.950033] x15: ffff0000e8ab4ecf x14: 7261702079646165 [159785.955417] x13: 726c612073277469 x12: ffff00006887b830 [159785.960802] x11: ffff00006773eaa0 x10: 7968702079687020 [159785.966186] x9 : 0000000000002453 x8 : 726f702072656874 [159785.971570] x7 : 6f6e6120666f2074 x6 : ffff802bcfb21290 [159785.976955] x5 : ffff802bcfb21290 x4 : 0000000000000000 [159785.982339] x3 : ffff802bcfb298c8 x2 : 337752b234c2ab00 [159785.987723] x1 : 337752b234c2ab00 x0 : 0000000000000000 [159785.993108] Process kworker/u96:2 (pid: 16993, stack limit = 0x0000000072dae094) [159786.000576] Call trace: [159786.003097]  sas_port_add_phy+0x188/0x1b8 [159786.007179]  sas_ex_get_linkrate.isra.5+0x134/0x140 [159786.012130]  sas_ex_discover_expander+0x128/0x408 [159786.016906]  sas_ex_discover_dev+0x218/0x4c8 [159786.021249]  sas_ex_discover_devices+0x9c/0x1a8 [159786.025852]  sas_discover_root_expander+0x134/0x160 [159786.030802]  sas_discover_domain+0x1b8/0x1e8 [159786.035148]  process_one_work+0x1b4/0x3f8 [159786.039230]  worker_thread+0x54/0x470 [159786.042967]  kthread+0x134/0x138 [159786.046269]  ret_from_fork+0x10/0x18 [159786.049918] Code: 91322300 f0004402 91178042 97fe4c9b (d4210000) [159786.056083] Modules linked in: hns3_enet_ut(OE) hclge(OE) hnae3(OE) hisi_sas_test_hw(OE) hisi_sas_test_main(OE) serdes(OE) [159786.067202] ---[ end trace 03622b9e2d99e196  ]--- [159786.071893] Kernel panic - not syncing: Fatal exception [159786.077190] SMP: stopping secondary CPUs [159786.081192] Kernel Offset: disabled [159786.084753] CPU features: 0x2,a2a00a38  ",
        "func_before": "static struct domain_device *sas_ex_discover_expander(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct sas_expander_device *parent_ex = rphy_to_expander_device(parent->rphy);\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tstruct sas_expander_device *edev;\n\tstruct asd_sas_port *port;\n\tint res;\n\n\tif (phy->routing_attr == DIRECT_ROUTING) {\n\t\tpr_warn(\"ex %016llx:%02d:D <--> ex %016llx:0x%x is not allowed\\n\",\n\t\t\tSAS_ADDR(parent->sas_addr), phy_id,\n\t\t\tSAS_ADDR(phy->attached_sas_addr),\n\t\t\tphy->attached_phy_id);\n\t\treturn NULL;\n\t}\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t/* FIXME: better error handling */\n\tBUG_ON(sas_port_add(phy->port) != 0);\n\n\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\trphy = NULL;\t/* shut gcc up */\n\t\tBUG();\n\t}\n\tport = parent->port;\n\tchild->rphy = rphy;\n\tget_device(&rphy->dev);\n\tedev = rphy_to_expander_device(rphy);\n\tchild->dev_type = phy->attached_dev_type;\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port = port;\n\tchild->iproto = phy->attached_iproto;\n\tchild->tproto = phy->attached_tproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tsas_ex_get_linkrate(parent, child, phy);\n\tedev->level = parent_ex->level + 1;\n\tparent->port->disc.max_level = max(parent->port->disc.max_level,\n\t\t\t\t\t   edev->level);\n\tsas_init_dev(child);\n\tsas_fill_in_rphy(child, rphy);\n\tsas_rphy_add(rphy);\n\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_add_tail(&child->dev_list_node, &parent->port->dev_list);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n\n\tres = sas_discover_expander(child);\n\tif (res) {\n\t\tsas_rphy_delete(rphy);\n\t\tspin_lock_irq(&parent->port->dev_list_lock);\n\t\tlist_del(&child->dev_list_node);\n\t\tspin_unlock_irq(&parent->port->dev_list_lock);\n\t\tsas_put_device(child);\n\t\treturn NULL;\n\t}\n\tlist_add_tail(&child->siblings, &parent->ex_dev.children);\n\treturn child;\n}",
        "func": "static struct domain_device *sas_ex_discover_expander(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct sas_expander_device *parent_ex = rphy_to_expander_device(parent->rphy);\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tstruct sas_expander_device *edev;\n\tstruct asd_sas_port *port;\n\tint res;\n\n\tif (phy->routing_attr == DIRECT_ROUTING) {\n\t\tpr_warn(\"ex %016llx:%02d:D <--> ex %016llx:0x%x is not allowed\\n\",\n\t\t\tSAS_ADDR(parent->sas_addr), phy_id,\n\t\t\tSAS_ADDR(phy->attached_sas_addr),\n\t\t\tphy->attached_phy_id);\n\t\treturn NULL;\n\t}\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t/* FIXME: better error handling */\n\tBUG_ON(sas_port_add(phy->port) != 0);\n\n\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\trphy = NULL;\t/* shut gcc up */\n\t\tBUG();\n\t}\n\tport = parent->port;\n\tchild->rphy = rphy;\n\tget_device(&rphy->dev);\n\tedev = rphy_to_expander_device(rphy);\n\tchild->dev_type = phy->attached_dev_type;\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port = port;\n\tchild->iproto = phy->attached_iproto;\n\tchild->tproto = phy->attached_tproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tsas_ex_get_linkrate(parent, child, phy);\n\tedev->level = parent_ex->level + 1;\n\tparent->port->disc.max_level = max(parent->port->disc.max_level,\n\t\t\t\t\t   edev->level);\n\tsas_init_dev(child);\n\tsas_fill_in_rphy(child, rphy);\n\tsas_rphy_add(rphy);\n\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_add_tail(&child->dev_list_node, &parent->port->dev_list);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n\n\tres = sas_discover_expander(child);\n\tif (res) {\n\t\tsas_rphy_delete(rphy);\n\t\tspin_lock_irq(&parent->port->dev_list_lock);\n\t\tlist_del(&child->dev_list_node);\n\t\tspin_unlock_irq(&parent->port->dev_list_lock);\n\t\tsas_put_device(child);\n\t\tsas_port_delete(phy->port);\n\t\tphy->port = NULL;\n\t\treturn NULL;\n\t}\n\tlist_add_tail(&child->siblings, &parent->ex_dev.children);\n\treturn child;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,6 +69,8 @@\n \t\tlist_del(&child->dev_list_node);\n \t\tspin_unlock_irq(&parent->port->dev_list_lock);\n \t\tsas_put_device(child);\n+\t\tsas_port_delete(phy->port);\n+\t\tphy->port = NULL;\n \t\treturn NULL;\n \t}\n \tlist_add_tail(&child->siblings, &parent->ex_dev.children);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tsas_port_delete(phy->port);",
                "\t\tphy->port = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15916",
        "func_name": "torvalds/linux/register_queue_kobjects",
        "description": "An issue was discovered in the Linux kernel before 5.0.1. There is a memory leak in register_queue_kobjects() in net/core/net-sysfs.c, which will cause denial of service.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=895a5e96dbd6386c8e78e5b78e067dcc67b7f0ab",
        "commit_title": "syzkaller report this:",
        "commit_text": "BUG: memory leak unreferenced object 0xffff88837a71a500 (size 256):   comm \"syz-executor.2\", pid 9770, jiffies 4297825125 (age 17.843s)   hex dump (first 32 bytes):     00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00  .....N..........     ff ff ff ff ff ff ff ff 20 c0 ef 86 ff ff ff ff  ........ .......   backtrace:     [<00000000db12624b>] netdev_register_kobject+0x124/0x2e0 net/core/net-sysfs.c:1751     [<00000000dc49a994>] register_netdevice+0xcc1/0x1270 net/core/dev.c:8516     [<00000000e5f3fea0>] tun_set_iff drivers/net/tun.c:2649 [inline]     [<00000000e5f3fea0>] __tun_chr_ioctl+0x2218/0x3d20 drivers/net/tun.c:2883     [<000000001b8ac127>] vfs_ioctl fs/ioctl.c:46 [inline]     [<000000001b8ac127>] do_vfs_ioctl+0x1a5/0x10e0 fs/ioctl.c:690     [<0000000079b269f8>] ksys_ioctl+0x89/0xa0 fs/ioctl.c:705     [<00000000de649beb>] __do_sys_ioctl fs/ioctl.c:712 [inline]     [<00000000de649beb>] __se_sys_ioctl fs/ioctl.c:710 [inline]     [<00000000de649beb>] __x64_sys_ioctl+0x74/0xb0 fs/ioctl.c:710     [<000000007ebded1e>] do_syscall_64+0xc8/0x580 arch/x86/entry/common.c:290     [<00000000db315d36>] entry_SYSCALL_64_after_hwframe+0x49/0xbe     [<00000000115be9bb>] 0xffffffffffffffff  It should call kset_unregister to free 'dev->queues_kset' in error path of register_queue_kobjects, otherwise will cause a mem leak.  ",
        "func_before": "static int register_queue_kobjects(struct net_device *dev)\n{\n\tint error = 0, txq = 0, rxq = 0, real_rx = 0, real_tx = 0;\n\n#ifdef CONFIG_SYSFS\n\tdev->queues_kset = kset_create_and_add(\"queues\",\n\t\t\t\t\t       NULL, &dev->dev.kobj);\n\tif (!dev->queues_kset)\n\t\treturn -ENOMEM;\n\treal_rx = dev->real_num_rx_queues;\n#endif\n\treal_tx = dev->real_num_tx_queues;\n\n\terror = net_rx_queue_update_kobjects(dev, 0, real_rx);\n\tif (error)\n\t\tgoto error;\n\trxq = real_rx;\n\n\terror = netdev_queue_update_kobjects(dev, 0, real_tx);\n\tif (error)\n\t\tgoto error;\n\ttxq = real_tx;\n\n\treturn 0;\n\nerror:\n\tnetdev_queue_update_kobjects(dev, txq, 0);\n\tnet_rx_queue_update_kobjects(dev, rxq, 0);\n\treturn error;\n}",
        "func": "static int register_queue_kobjects(struct net_device *dev)\n{\n\tint error = 0, txq = 0, rxq = 0, real_rx = 0, real_tx = 0;\n\n#ifdef CONFIG_SYSFS\n\tdev->queues_kset = kset_create_and_add(\"queues\",\n\t\t\t\t\t       NULL, &dev->dev.kobj);\n\tif (!dev->queues_kset)\n\t\treturn -ENOMEM;\n\treal_rx = dev->real_num_rx_queues;\n#endif\n\treal_tx = dev->real_num_tx_queues;\n\n\terror = net_rx_queue_update_kobjects(dev, 0, real_rx);\n\tif (error)\n\t\tgoto error;\n\trxq = real_rx;\n\n\terror = netdev_queue_update_kobjects(dev, 0, real_tx);\n\tif (error)\n\t\tgoto error;\n\ttxq = real_tx;\n\n\treturn 0;\n\nerror:\n\tnetdev_queue_update_kobjects(dev, txq, 0);\n\tnet_rx_queue_update_kobjects(dev, rxq, 0);\n#ifdef CONFIG_SYSFS\n\tkset_unregister(dev->queues_kset);\n#endif\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,5 +26,8 @@\n error:\n \tnetdev_queue_update_kobjects(dev, txq, 0);\n \tnet_rx_queue_update_kobjects(dev, rxq, 0);\n+#ifdef CONFIG_SYSFS\n+\tkset_unregister(dev->queues_kset);\n+#endif\n \treturn error;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef CONFIG_SYSFS",
                "\tkset_unregister(dev->queues_kset);",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15921",
        "func_name": "torvalds/linux/genl_register_family",
        "description": "An issue was discovered in the Linux kernel before 5.0.6. There is a memory leak issue when idr_alloc() fails in genl_register_family() in net/netlink/genetlink.c.",
        "git_url": "https://github.com/torvalds/linux/commit/ceabee6c59943bdd5e1da1a6a20dc7ee5f8113a2",
        "commit_title": "genetlink: Fix a memory leak on error path",
        "commit_text": " In genl_register_family(), when idr_alloc() fails, we forget to free the memory we possibly allocate for family->attrbuf. ",
        "func_before": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\n\tgenl_lock_all();\n\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\n\t/*\n\t * Sadly, a few cases need to be special-cased\n\t * due to them having previously abused the API\n\t * and having used their family ID also as their\n\t * multicast group ID, so we use reserved IDs\n\t * for both to be sure we can do that mapping.\n\t */\n\tif (family == &genl_ctrl) {\n\t\t/* and this needs to be special for initial family lookups */\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\n\tgenl_unlock_all();\n\n\t/* send all events */\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\n\treturn 0;\n\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}",
        "func": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\n\tgenl_lock_all();\n\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\n\t/*\n\t * Sadly, a few cases need to be special-cased\n\t * due to them having previously abused the API\n\t * and having used their family ID also as their\n\t * multicast group ID, so we use reserved IDs\n\t * for both to be sure we can do that mapping.\n\t */\n\tif (family == &genl_ctrl) {\n\t\t/* and this needs to be special for initial family lookups */\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_free;\n\t}\n\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\n\tgenl_unlock_all();\n\n\t/* send all events */\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\n\treturn 0;\n\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\nerrout_free:\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n \t\t\t       start, end + 1, GFP_KERNEL);\n \tif (family->id < 0) {\n \t\terr = family->id;\n-\t\tgoto errout_locked;\n+\t\tgoto errout_free;\n \t}\n \n \terr = genl_validate_assign_mc_groups(family);\n@@ -64,6 +64,7 @@\n \n errout_remove:\n \tidr_remove(&genl_fam_idr, family->id);\n+errout_free:\n \tkfree(family->attrbuf);\n errout_locked:\n \tgenl_unlock_all();",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tgoto errout_locked;"
            ],
            "added_lines": [
                "\t\tgoto errout_free;",
                "errout_free:"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-21017",
        "func_name": "gpac/dinf_Read",
        "description": "GPAC 0.7.1 has a memory leak in dinf_Read in isomedia/box_code_base.c.",
        "git_url": "https://github.com/gpac/gpac/commit/d2371b4b204f0a3c0af51ad4e9b491144dd1225c",
        "commit_title": "prevent dref memleak on invalid input (#1183)",
        "commit_text": "",
        "func_before": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}",
        "func": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_Box* dref;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;\n\t\tgf_isom_box_add_for_dump_mode(s, dref);\n\t}\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,11 @@\n \t\treturn e;\n \t}\n \tif (!((GF_DataInformationBox *)s)->dref) {\n+\t\tGF_Box* dref;\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n-\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n+\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n+\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;\n+\t\tgf_isom_box_add_for_dump_mode(s, dref);\n \t}\n \treturn GF_OK;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);"
            ],
            "added_lines": [
                "\t\tGF_Box* dref;",
                "\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);",
                "\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;",
                "\t\tgf_isom_box_add_for_dump_mode(s, dref);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16708",
        "func_name": "ImageMagick/DestroyXResources",
        "description": "ImageMagick 7.0.8-35 has a memory leak in magick/xwindow.c, related to XCreateImage.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/f391a5f4554fe47eb56d6277ac32d1f698572f0e",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1531",
        "commit_text": "",
        "func_before": "MagickExport void DestroyXResources(void)\n{\n  register int\n    i;\n\n  unsigned int\n    number_windows;\n\n  XWindowInfo\n    *magick_windows[MaxXWindows];\n\n  XWindows\n    *windows;\n\n  DestroyXWidget();\n  windows=XSetWindows((XWindows *) ~0);\n  if ((windows == (XWindows *) NULL) || (windows->display == (Display *) NULL))\n    return;\n  number_windows=0;\n  magick_windows[number_windows++]=(&windows->context);\n  magick_windows[number_windows++]=(&windows->group_leader);\n  magick_windows[number_windows++]=(&windows->backdrop);\n  magick_windows[number_windows++]=(&windows->icon);\n  magick_windows[number_windows++]=(&windows->image);\n  magick_windows[number_windows++]=(&windows->info);\n  magick_windows[number_windows++]=(&windows->magnify);\n  magick_windows[number_windows++]=(&windows->pan);\n  magick_windows[number_windows++]=(&windows->command);\n  magick_windows[number_windows++]=(&windows->widget);\n  magick_windows[number_windows++]=(&windows->popup);\n  for (i=0; i < (int) number_windows; i++)\n  {\n    if (magick_windows[i]->mapped != MagickFalse)\n      {\n        (void) XWithdrawWindow(windows->display,magick_windows[i]->id,\n          magick_windows[i]->screen);\n        magick_windows[i]->mapped=MagickFalse;\n      }\n    if (magick_windows[i]->name != (char *) NULL)\n      magick_windows[i]->name=(char *)\n        RelinquishMagickMemory(magick_windows[i]->name);\n    if (magick_windows[i]->icon_name != (char *) NULL)\n      magick_windows[i]->icon_name=(char *)\n        RelinquishMagickMemory(magick_windows[i]->icon_name);\n    if (magick_windows[i]->cursor != (Cursor) NULL)\n      {\n        (void) XFreeCursor(windows->display,magick_windows[i]->cursor);\n        magick_windows[i]->cursor=(Cursor) NULL;\n      }\n    if (magick_windows[i]->busy_cursor != (Cursor) NULL)\n      {\n        (void) XFreeCursor(windows->display,magick_windows[i]->busy_cursor);\n        magick_windows[i]->busy_cursor=(Cursor) NULL;\n      }\n    if (magick_windows[i]->highlight_stipple != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,\n          magick_windows[i]->highlight_stipple);\n        magick_windows[i]->highlight_stipple=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->shadow_stipple != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,magick_windows[i]->shadow_stipple);\n        magick_windows[i]->shadow_stipple=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->ximage != (XImage *) NULL)\n      {\n        XDestroyImage(magick_windows[i]->ximage);\n        magick_windows[i]->ximage=(XImage *) NULL;\n      }\n    if (magick_windows[i]->pixmap != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,magick_windows[i]->pixmap);\n        magick_windows[i]->pixmap=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->id != (Window) NULL)\n      {\n        (void) XDestroyWindow(windows->display,magick_windows[i]->id);\n        magick_windows[i]->id=(Window) NULL;\n      }\n    if (magick_windows[i]->destroy != MagickFalse)\n      {\n        if (magick_windows[i]->image != (Image *) NULL)\n          {\n            magick_windows[i]->image=DestroyImage(magick_windows[i]->image);\n            magick_windows[i]->image=NewImageList();\n          }\n        if (magick_windows[i]->matte_pixmap != (Pixmap) NULL)\n          {\n            (void) XFreePixmap(windows->display,\n              magick_windows[i]->matte_pixmap);\n            magick_windows[i]->matte_pixmap=(Pixmap) NULL;\n          }\n      }\n    if (magick_windows[i]->segment_info != (void *) NULL)\n      {\n#if defined(MAGICKCORE_HAVE_SHARED_MEMORY)\n        XShmSegmentInfo\n          *segment_info;\n\n        segment_info=(XShmSegmentInfo *) magick_windows[i]->segment_info;\n        if (segment_info != (XShmSegmentInfo *) NULL)\n          if (segment_info[0].shmid >= 0)\n            {\n              if (segment_info[0].shmaddr != NULL)\n                (void) shmdt(segment_info[0].shmaddr);\n              (void) shmctl(segment_info[0].shmid,IPC_RMID,0);\n              segment_info[0].shmaddr=NULL;\n              segment_info[0].shmid=(-1);\n            }\n#endif\n        magick_windows[i]->segment_info=(void *)\n          RelinquishMagickMemory(magick_windows[i]->segment_info);\n      }\n  }\n  windows->icon_resources=(XResourceInfo *)\n    RelinquishMagickMemory(windows->icon_resources);\n  if (windows->icon_pixel != (XPixelInfo *) NULL)\n    {\n      if (windows->icon_pixel->pixels != (unsigned long *) NULL)\n        windows->icon_pixel->pixels=(unsigned long *)\n          RelinquishMagickMemory(windows->icon_pixel->pixels);\n      if (windows->icon_pixel->annotate_context != (GC) NULL)\n        XFreeGC(windows->display,windows->icon_pixel->annotate_context);\n      windows->icon_pixel=(XPixelInfo *)\n        RelinquishMagickMemory(windows->icon_pixel);\n    }\n  if (windows->pixel_info != (XPixelInfo *) NULL)\n    {\n      if (windows->pixel_info->pixels != (unsigned long *) NULL)\n        windows->pixel_info->pixels=(unsigned long *)\n          RelinquishMagickMemory(windows->pixel_info->pixels);\n      if (windows->pixel_info->annotate_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->annotate_context);\n      if (windows->pixel_info->widget_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->widget_context);\n      if (windows->pixel_info->highlight_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->highlight_context);\n      windows->pixel_info=(XPixelInfo *)\n        RelinquishMagickMemory(windows->pixel_info);\n    }\n  if (windows->font_info != (XFontStruct *) NULL)\n    {\n      XFreeFont(windows->display,windows->font_info);\n      windows->font_info=(XFontStruct *) NULL;\n    }\n  if (windows->class_hints != (XClassHint *) NULL)\n    {\n      if (windows->class_hints->res_name != (char *) NULL)\n        windows->class_hints->res_name=DestroyString(\n          windows->class_hints->res_name);\n      if (windows->class_hints->res_class != (char *) NULL)\n        windows->class_hints->res_class=DestroyString(\n          windows->class_hints->res_class);\n      XFree(windows->class_hints);\n      windows->class_hints=(XClassHint *) NULL;\n    }\n  if (windows->manager_hints != (XWMHints *) NULL)\n    {\n      XFree(windows->manager_hints);\n      windows->manager_hints=(XWMHints *) NULL;\n    }\n  if (windows->map_info != (XStandardColormap *) NULL)\n    {\n      XFree(windows->map_info);\n      windows->map_info=(XStandardColormap *) NULL;\n    }\n  if (windows->icon_map != (XStandardColormap *) NULL)\n    {\n      XFree(windows->icon_map);\n      windows->icon_map=(XStandardColormap *) NULL;\n    }\n  if (windows->visual_info != (XVisualInfo *) NULL)\n    {\n      XFree(windows->visual_info);\n      windows->visual_info=(XVisualInfo *) NULL;\n    }\n  if (windows->icon_visual != (XVisualInfo *) NULL)\n    {\n      XFree(windows->icon_visual);\n      windows->icon_visual=(XVisualInfo *) NULL;\n    }\n  (void) XSetWindows((XWindows *) NULL);\n}",
        "func": "MagickExport void DestroyXResources(void)\n{\n  register int\n    i;\n\n  unsigned int\n    number_windows;\n\n  XWindowInfo\n    *magick_windows[MaxXWindows];\n\n  XWindows\n    *windows;\n\n  DestroyXWidget();\n  windows=XSetWindows((XWindows *) ~0);\n  if ((windows == (XWindows *) NULL) || (windows->display == (Display *) NULL))\n    return;\n  number_windows=0;\n  magick_windows[number_windows++]=(&windows->context);\n  magick_windows[number_windows++]=(&windows->group_leader);\n  magick_windows[number_windows++]=(&windows->backdrop);\n  magick_windows[number_windows++]=(&windows->icon);\n  magick_windows[number_windows++]=(&windows->image);\n  magick_windows[number_windows++]=(&windows->info);\n  magick_windows[number_windows++]=(&windows->magnify);\n  magick_windows[number_windows++]=(&windows->pan);\n  magick_windows[number_windows++]=(&windows->command);\n  magick_windows[number_windows++]=(&windows->widget);\n  magick_windows[number_windows++]=(&windows->popup);\n  for (i=0; i < (int) number_windows; i++)\n  {\n    if (magick_windows[i]->mapped != MagickFalse)\n      {\n        (void) XWithdrawWindow(windows->display,magick_windows[i]->id,\n          magick_windows[i]->screen);\n        magick_windows[i]->mapped=MagickFalse;\n      }\n    if (magick_windows[i]->name != (char *) NULL)\n      magick_windows[i]->name=(char *)\n        RelinquishMagickMemory(magick_windows[i]->name);\n    if (magick_windows[i]->icon_name != (char *) NULL)\n      magick_windows[i]->icon_name=(char *)\n        RelinquishMagickMemory(magick_windows[i]->icon_name);\n    if (magick_windows[i]->cursor != (Cursor) NULL)\n      {\n        (void) XFreeCursor(windows->display,magick_windows[i]->cursor);\n        magick_windows[i]->cursor=(Cursor) NULL;\n      }\n    if (magick_windows[i]->busy_cursor != (Cursor) NULL)\n      {\n        (void) XFreeCursor(windows->display,magick_windows[i]->busy_cursor);\n        magick_windows[i]->busy_cursor=(Cursor) NULL;\n      }\n    if (magick_windows[i]->highlight_stipple != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,\n          magick_windows[i]->highlight_stipple);\n        magick_windows[i]->highlight_stipple=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->shadow_stipple != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,magick_windows[i]->shadow_stipple);\n        magick_windows[i]->shadow_stipple=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->matte_image != (XImage *) NULL)\n      {\n        XDestroyImage(magick_windows[i]->matte_image);\n        magick_windows[i]->matte_image=(XImage *) NULL;\n      }\n    if (magick_windows[i]->ximage != (XImage *) NULL)\n      {\n        XDestroyImage(magick_windows[i]->ximage);\n        magick_windows[i]->ximage=(XImage *) NULL;\n      }\n    if (magick_windows[i]->pixmap != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,magick_windows[i]->pixmap);\n        magick_windows[i]->pixmap=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->id != (Window) NULL)\n      {\n        (void) XDestroyWindow(windows->display,magick_windows[i]->id);\n        magick_windows[i]->id=(Window) NULL;\n      }\n    if (magick_windows[i]->destroy != MagickFalse)\n      {\n        if (magick_windows[i]->image != (Image *) NULL)\n          {\n            magick_windows[i]->image=DestroyImage(magick_windows[i]->image);\n            magick_windows[i]->image=NewImageList();\n          }\n        if (magick_windows[i]->matte_pixmap != (Pixmap) NULL)\n          {\n            (void) XFreePixmap(windows->display,\n              magick_windows[i]->matte_pixmap);\n            magick_windows[i]->matte_pixmap=(Pixmap) NULL;\n          }\n      }\n    if (magick_windows[i]->segment_info != (void *) NULL)\n      {\n#if defined(MAGICKCORE_HAVE_SHARED_MEMORY)\n        XShmSegmentInfo\n          *segment_info;\n\n        segment_info=(XShmSegmentInfo *) magick_windows[i]->segment_info;\n        if (segment_info != (XShmSegmentInfo *) NULL)\n          if (segment_info[0].shmid >= 0)\n            {\n              if (segment_info[0].shmaddr != NULL)\n                (void) shmdt(segment_info[0].shmaddr);\n              (void) shmctl(segment_info[0].shmid,IPC_RMID,0);\n              segment_info[0].shmaddr=NULL;\n              segment_info[0].shmid=(-1);\n            }\n#endif\n        magick_windows[i]->segment_info=(void *)\n          RelinquishMagickMemory(magick_windows[i]->segment_info);\n      }\n  }\n  windows->icon_resources=(XResourceInfo *)\n    RelinquishMagickMemory(windows->icon_resources);\n  if (windows->icon_pixel != (XPixelInfo *) NULL)\n    {\n      if (windows->icon_pixel->pixels != (unsigned long *) NULL)\n        windows->icon_pixel->pixels=(unsigned long *)\n          RelinquishMagickMemory(windows->icon_pixel->pixels);\n      if (windows->icon_pixel->annotate_context != (GC) NULL)\n        XFreeGC(windows->display,windows->icon_pixel->annotate_context);\n      windows->icon_pixel=(XPixelInfo *)\n        RelinquishMagickMemory(windows->icon_pixel);\n    }\n  if (windows->pixel_info != (XPixelInfo *) NULL)\n    {\n      if (windows->pixel_info->pixels != (unsigned long *) NULL)\n        windows->pixel_info->pixels=(unsigned long *)\n          RelinquishMagickMemory(windows->pixel_info->pixels);\n      if (windows->pixel_info->annotate_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->annotate_context);\n      if (windows->pixel_info->widget_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->widget_context);\n      if (windows->pixel_info->highlight_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->highlight_context);\n      windows->pixel_info=(XPixelInfo *)\n        RelinquishMagickMemory(windows->pixel_info);\n    }\n  if (windows->font_info != (XFontStruct *) NULL)\n    {\n      XFreeFont(windows->display,windows->font_info);\n      windows->font_info=(XFontStruct *) NULL;\n    }\n  if (windows->class_hints != (XClassHint *) NULL)\n    {\n      if (windows->class_hints->res_name != (char *) NULL)\n        windows->class_hints->res_name=DestroyString(\n          windows->class_hints->res_name);\n      if (windows->class_hints->res_class != (char *) NULL)\n        windows->class_hints->res_class=DestroyString(\n          windows->class_hints->res_class);\n      XFree(windows->class_hints);\n      windows->class_hints=(XClassHint *) NULL;\n    }\n  if (windows->manager_hints != (XWMHints *) NULL)\n    {\n      XFree(windows->manager_hints);\n      windows->manager_hints=(XWMHints *) NULL;\n    }\n  if (windows->map_info != (XStandardColormap *) NULL)\n    {\n      XFree(windows->map_info);\n      windows->map_info=(XStandardColormap *) NULL;\n    }\n  if (windows->icon_map != (XStandardColormap *) NULL)\n    {\n      XFree(windows->icon_map);\n      windows->icon_map=(XStandardColormap *) NULL;\n    }\n  if (windows->visual_info != (XVisualInfo *) NULL)\n    {\n      XFree(windows->visual_info);\n      windows->visual_info=(XVisualInfo *) NULL;\n    }\n  if (windows->icon_visual != (XVisualInfo *) NULL)\n    {\n      XFree(windows->icon_visual);\n      windows->icon_visual=(XVisualInfo *) NULL;\n    }\n  (void) XSetWindows((XWindows *) NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,6 +62,11 @@\n       {\n         (void) XFreePixmap(windows->display,magick_windows[i]->shadow_stipple);\n         magick_windows[i]->shadow_stipple=(Pixmap) NULL;\n+      }\n+    if (magick_windows[i]->matte_image != (XImage *) NULL)\n+      {\n+        XDestroyImage(magick_windows[i]->matte_image);\n+        magick_windows[i]->matte_image=(XImage *) NULL;\n       }\n     if (magick_windows[i]->ximage != (XImage *) NULL)\n       {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      }",
                "    if (magick_windows[i]->matte_image != (XImage *) NULL)",
                "      {",
                "        XDestroyImage(magick_windows[i]->matte_image);",
                "        magick_windows[i]->matte_image=(XImage *) NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16708",
        "func_name": "ImageMagick/ReadDPSImage",
        "description": "ImageMagick 7.0.8-35 has a memory leak in magick/xwindow.c, related to XCreateImage.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/f391a5f4554fe47eb56d6277ac32d1f698572f0e",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1531",
        "commit_text": "",
        "func_before": "static Image *ReadDPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const char\n    *client_name;\n\n  Display\n    *display;\n\n  float\n    pixels_per_point;\n\n  Image\n    *image;\n\n  int\n    sans,\n    status;\n\n  Pixmap\n    pixmap;\n\n  register ssize_t\n    i;\n\n  register Quantum\n    *q;\n\n  register size_t\n    pixel;\n\n  Screen\n    *screen;\n\n  ssize_t\n    x,\n    y;\n\n  XColor\n    *colors;\n\n  XImage\n    *dps_image;\n\n  XRectangle\n    page,\n    bits_per_pixel;\n\n  XResourceInfo\n    resource_info;\n\n  XrmDatabase\n    resource_database;\n\n  XStandardColormap\n    *map_info;\n\n  XVisualInfo\n    *visual_info;\n\n  /*\n    Open X server connection.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  display=XOpenDisplay(image_info->server_name);\n  if (display == (Display *) NULL)\n    return((Image *) NULL);\n  /*\n    Set our forgiving exception handler.\n  */\n  (void) XSetErrorHandler(XError);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  /*\n    Get user defaults from X resource database.\n  */\n  client_name=GetClientName();\n  resource_database=XGetResourceDatabase(display,client_name);\n  XGetResourceInfo(image_info,resource_database,client_name,&resource_info);\n  /*\n    Allocate standard colormap.\n  */\n  map_info=XAllocStandardColormap();\n  visual_info=(XVisualInfo *) NULL;\n  if (map_info == (XStandardColormap *) NULL)\n    ThrowReaderException(ResourceLimitError,\"UnableToCreateStandardColormap\")\n  else\n    {\n      /*\n        Initialize visual info.\n      */\n      (void) CloneString(&resource_info.visual_type,\"default\");\n      visual_info=XBestVisualInfo(display,map_info,&resource_info);\n      map_info->colormap=(Colormap) NULL;\n    }\n  if ((map_info == (XStandardColormap *) NULL) ||\n      (visual_info == (XVisualInfo *) NULL))\n    {\n      image=DestroyImage(image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  /*\n    Create a pixmap the appropriate size for the image.\n  */\n  screen=ScreenOfDisplay(display,visual_info->screen);\n  pixels_per_point=XDPSPixelsPerPoint(screen);\n  if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n    pixels_per_point=MagickMin(image->resolution.x,image->resolution.y)/\n      DefaultResolution;\n  status=XDPSCreatePixmapForEPSF((DPSContext) NULL,screen,\n    GetBlobFileHandle(image),visual_info->depth,pixels_per_point,&pixmap,\n    &bits_per_pixel,&page);\n  if ((status == dps_status_failure) || (status == dps_status_no_extension))\n    {\n      image=DestroyImage(image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  /*\n    Rasterize the file into the pixmap.\n  */\n  status=XDPSImageFileIntoDrawable((DPSContext) NULL,screen,pixmap,\n    GetBlobFileHandle(image),(int) bits_per_pixel.height,visual_info->depth,\n    &page,-page.x,-page.y,pixels_per_point,MagickTrue,MagickFalse,MagickTrue,\n    &sans);\n  if (status != dps_status_success)\n    {\n      image=DestroyImage(image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize DPS X image.\n  */\n  dps_image=XGetImage(display,pixmap,0,0,bits_per_pixel.width,\n    bits_per_pixel.height,AllPlanes,ZPixmap);\n  (void) XFreePixmap(display,pixmap);\n  if (dps_image == (XImage *) NULL)\n    {\n      image=DestroyImage(image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  /*\n    Get the colormap colors.\n  */\n  colors=(XColor *) AcquireQuantumMemory(visual_info->colormap_size,\n    sizeof(*colors));\n  if (colors == (XColor *) NULL)\n    {\n      image=DestroyImage(image);\n      XDestroyImage(dps_image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  if ((visual_info->klass != DirectColor) && (visual_info->klass != TrueColor))\n    for (i=0; i < visual_info->colormap_size; i++)\n    {\n      colors[i].pixel=(size_t) i;\n      colors[i].pad=0;\n    }\n  else\n    {\n      size_t\n        blue,\n        blue_bit,\n        green,\n        green_bit,\n        red,\n        red_bit;\n\n      /*\n        DirectColor or TrueColor visual.\n      */\n      red=0;\n      green=0;\n      blue=0;\n      red_bit=visual_info->red_mask & (~(visual_info->red_mask)+1);\n      green_bit=visual_info->green_mask & (~(visual_info->green_mask)+1);\n      blue_bit=visual_info->blue_mask & (~(visual_info->blue_mask)+1);\n      for (i=0; i < visual_info->colormap_size; i++)\n      {\n        colors[i].pixel=red | green | blue;\n        colors[i].pad=0;\n        red+=red_bit;\n        if (red > visual_info->red_mask)\n          red=0;\n        green+=green_bit;\n        if (green > visual_info->green_mask)\n          green=0;\n        blue+=blue_bit;\n        if (blue > visual_info->blue_mask)\n          blue=0;\n      }\n    }\n  (void) XQueryColors(display,XDefaultColormap(display,visual_info->screen),\n    colors,visual_info->colormap_size);\n  /*\n    Convert X image to MIFF format.\n  */\n  if ((visual_info->klass != TrueColor) && (visual_info->klass != DirectColor))\n    image->storage_class=PseudoClass;\n  image->columns=(size_t) dps_image->width;\n  image->rows=(size_t) dps_image->height;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      colors=(XColor *) RelinquishMagickMemory(colors);\n      XDestroyImage(dps_image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      colors=(XColor *) RelinquishMagickMemory(colors);\n      XDestroyImage(dps_image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return(DestroyImageList(image));\n    }\n  switch (image->storage_class)\n  {\n    case DirectClass:\n    default:\n    {\n      register size_t\n        color,\n        index;\n\n      size_t\n        blue_mask,\n        blue_shift,\n        green_mask,\n        green_shift,\n        red_mask,\n        red_shift;\n\n      /*\n        Determine shift and mask for red, green, and blue.\n      */\n      red_mask=visual_info->red_mask;\n      red_shift=0;\n      while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n      {\n        red_mask>>=1;\n        red_shift++;\n      }\n      green_mask=visual_info->green_mask;\n      green_shift=0;\n      while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n      {\n        green_mask>>=1;\n        green_shift++;\n      }\n      blue_mask=visual_info->blue_mask;\n      blue_shift=0;\n      while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n      {\n        blue_mask>>=1;\n        blue_shift++;\n      }\n      /*\n        Convert X image to DirectClass packets.\n      */\n      if ((visual_info->colormap_size > 0) &&\n          (visual_info->klass == DirectColor))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=XGetPixel(dps_image,x,y);\n            index=(pixel >> red_shift) & red_mask;\n            SetPixelRed(image,ScaleShortToQuantum(colors[index].red),q);\n            index=(pixel >> green_shift) & green_mask;\n            SetPixelGreen(image,ScaleShortToQuantum(colors[index].green),q);\n            index=(pixel >> blue_shift) & blue_mask;\n            SetPixelBlue(image,ScaleShortToQuantum(colors[index].blue),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=XGetPixel(dps_image,x,y);\n            color=(pixel >> red_shift) & red_mask;\n            color=(color*65535L)/red_mask;\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\n            color=(pixel >> green_shift) & green_mask;\n            color=(color*65535L)/green_mask;\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),q);\n            color=(pixel >> blue_shift) & blue_mask;\n            color=(color*65535L)/blue_mask;\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n            break;\n        }\n      break;\n    }\n    case PseudoClass:\n    {\n      /*\n        Create colormap.\n      */\n      if (AcquireImageColormap(image,(size_t) visual_info->colormap_size,exception) == MagickFalse)\n        {\n          image=DestroyImage(image);\n          colors=(XColor *) RelinquishMagickMemory(colors);\n          XDestroyImage(dps_image);\n          XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n            (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n          return((Image *) NULL);\n        }\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        image->colormap[colors[i].pixel].red=ScaleShortToQuantum(colors[i].red);\n        image->colormap[colors[i].pixel].green=\n          ScaleShortToQuantum(colors[i].green);\n        image->colormap[colors[i].pixel].blue=\n          ScaleShortToQuantum(colors[i].blue);\n      }\n      /*\n        Convert X image to PseudoClass packets.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelIndex(image,(unsigned short) XGetPixel(dps_image,x,y),q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n          break;\n      }\n      break;\n    }\n  }\n  colors=(XColor *) RelinquishMagickMemory(colors);\n  XDestroyImage(dps_image);\n  if (image->storage_class == PseudoClass)\n    (void) SyncImage(image,exception);\n  /*\n    Rasterize matte image.\n  */\n  status=XDPSCreatePixmapForEPSF((DPSContext) NULL,screen,\n    GetBlobFileHandle(image),1,pixels_per_point,&pixmap,&bits_per_pixel,&page);\n  if ((status != dps_status_failure) && (status != dps_status_no_extension))\n    {\n      status=XDPSImageFileIntoDrawable((DPSContext) NULL,screen,pixmap,\n        GetBlobFileHandle(image),(int) bits_per_pixel.height,1,&page,-page.x,\n        -page.y,pixels_per_point,MagickTrue,MagickTrue,MagickTrue,&sans);\n      if (status == dps_status_success)\n        {\n          XImage\n            *matte_image;\n\n          /*\n            Initialize image matte.\n          */\n          matte_image=XGetImage(display,pixmap,0,0,bits_per_pixel.width,\n            bits_per_pixel.height,AllPlanes,ZPixmap);\n          (void) XFreePixmap(display,pixmap);\n          if (matte_image != (XImage *) NULL)\n            {\n              image->storage_class=DirectClass;\n              image->alpha_trait=BlendPixelTrait;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n                if (q == (Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  SetPixelAlpha(image,OpaqueAlpha,q);\n                  if (XGetPixel(matte_image,x,y) == 0)\n                    SetPixelAlpha(image,TransparentAlpha,q);\n                  q+=GetPixelChannels(image);\n                }\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n              XDestroyImage(matte_image);\n            }\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n    (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadDPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const char\n    *client_name;\n\n  Display\n    *display;\n\n  float\n    pixels_per_point;\n\n  Image\n    *image;\n\n  int\n    sans,\n    status;\n\n  Pixmap\n    pixmap;\n\n  register ssize_t\n    i;\n\n  register Quantum\n    *q;\n\n  register size_t\n    pixel;\n\n  Screen\n    *screen;\n\n  ssize_t\n    x,\n    y;\n\n  XColor\n    *colors;\n\n  XImage\n    *dps_image;\n\n  XRectangle\n    page,\n    bits_per_pixel;\n\n  XResourceInfo\n    resource_info;\n\n  XrmDatabase\n    resource_database;\n\n  XStandardColormap\n    *map_info;\n\n  XVisualInfo\n    *visual_info;\n\n  /*\n    Open X server connection.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  display=XOpenDisplay(image_info->server_name);\n  if (display == (Display *) NULL)\n    return((Image *) NULL);\n  /*\n    Set our forgiving exception handler.\n  */\n  (void) XSetErrorHandler(XError);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Get user defaults from X resource database.\n  */\n  client_name=GetClientName();\n  resource_database=XGetResourceDatabase(display,client_name);\n  XGetResourceInfo(image_info,resource_database,client_name,&resource_info);\n  /*\n    Allocate standard colormap.\n  */\n  map_info=XAllocStandardColormap();\n  visual_info=(XVisualInfo *) NULL;\n  if (map_info == (XStandardColormap *) NULL)\n    ThrowReaderException(ResourceLimitError,\"UnableToCreateStandardColormap\")\n  else\n    {\n      /*\n        Initialize visual info.\n      */\n      (void) CloneString(&resource_info.visual_type,\"default\");\n      visual_info=XBestVisualInfo(display,map_info,&resource_info);\n      map_info->colormap=(Colormap) NULL;\n    }\n  if ((map_info == (XStandardColormap *) NULL) ||\n      (visual_info == (XVisualInfo *) NULL))\n    {\n      image=DestroyImage(image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  /*\n    Create a pixmap the appropriate size for the image.\n  */\n  screen=ScreenOfDisplay(display,visual_info->screen);\n  pixels_per_point=XDPSPixelsPerPoint(screen);\n  if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n    pixels_per_point=MagickMin(image->resolution.x,image->resolution.y)/\n      DefaultResolution;\n  status=XDPSCreatePixmapForEPSF((DPSContext) NULL,screen,\n    GetBlobFileHandle(image),visual_info->depth,pixels_per_point,&pixmap,\n    &bits_per_pixel,&page);\n  if ((status == dps_status_failure) || (status == dps_status_no_extension))\n    {\n      image=DestroyImage(image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  /*\n    Rasterize the file into the pixmap.\n  */\n  status=XDPSImageFileIntoDrawable((DPSContext) NULL,screen,pixmap,\n    GetBlobFileHandle(image),(int) bits_per_pixel.height,visual_info->depth,\n    &page,-page.x,-page.y,pixels_per_point,MagickTrue,MagickFalse,MagickTrue,\n    &sans);\n  if (status != dps_status_success)\n    {\n      image=DestroyImage(image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize DPS X image.\n  */\n  dps_image=XGetImage(display,pixmap,0,0,bits_per_pixel.width,\n    bits_per_pixel.height,AllPlanes,ZPixmap);\n  (void) XFreePixmap(display,pixmap);\n  if (dps_image == (XImage *) NULL)\n    {\n      image=DestroyImage(image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  /*\n    Get the colormap colors.\n  */\n  colors=(XColor *) AcquireQuantumMemory(visual_info->colormap_size,\n    sizeof(*colors));\n  if (colors == (XColor *) NULL)\n    {\n      image=DestroyImage(image);\n      XDestroyImage(dps_image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return((Image *) NULL);\n    }\n  if ((visual_info->klass != DirectColor) && (visual_info->klass != TrueColor))\n    for (i=0; i < visual_info->colormap_size; i++)\n    {\n      colors[i].pixel=(size_t) i;\n      colors[i].pad=0;\n    }\n  else\n    {\n      size_t\n        blue,\n        blue_bit,\n        green,\n        green_bit,\n        red,\n        red_bit;\n\n      /*\n        DirectColor or TrueColor visual.\n      */\n      red=0;\n      green=0;\n      blue=0;\n      red_bit=visual_info->red_mask & (~(visual_info->red_mask)+1);\n      green_bit=visual_info->green_mask & (~(visual_info->green_mask)+1);\n      blue_bit=visual_info->blue_mask & (~(visual_info->blue_mask)+1);\n      for (i=0; i < visual_info->colormap_size; i++)\n      {\n        colors[i].pixel=red | green | blue;\n        colors[i].pad=0;\n        red+=red_bit;\n        if (red > visual_info->red_mask)\n          red=0;\n        green+=green_bit;\n        if (green > visual_info->green_mask)\n          green=0;\n        blue+=blue_bit;\n        if (blue > visual_info->blue_mask)\n          blue=0;\n      }\n    }\n  (void) XQueryColors(display,XDefaultColormap(display,visual_info->screen),\n    colors,visual_info->colormap_size);\n  /*\n    Convert X image to MIFF format.\n  */\n  if ((visual_info->klass != TrueColor) && (visual_info->klass != DirectColor))\n    image->storage_class=PseudoClass;\n  image->columns=(size_t) dps_image->width;\n  image->rows=(size_t) dps_image->height;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      colors=(XColor *) RelinquishMagickMemory(colors);\n      XDestroyImage(dps_image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      colors=(XColor *) RelinquishMagickMemory(colors);\n      XDestroyImage(dps_image);\n      XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n        (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n      return(DestroyImageList(image));\n    }\n  switch (image->storage_class)\n  {\n    case DirectClass:\n    default:\n    {\n      register size_t\n        color,\n        index;\n\n      size_t\n        blue_mask,\n        blue_shift,\n        green_mask,\n        green_shift,\n        red_mask,\n        red_shift;\n\n      /*\n        Determine shift and mask for red, green, and blue.\n      */\n      red_mask=visual_info->red_mask;\n      red_shift=0;\n      while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n      {\n        red_mask>>=1;\n        red_shift++;\n      }\n      green_mask=visual_info->green_mask;\n      green_shift=0;\n      while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n      {\n        green_mask>>=1;\n        green_shift++;\n      }\n      blue_mask=visual_info->blue_mask;\n      blue_shift=0;\n      while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n      {\n        blue_mask>>=1;\n        blue_shift++;\n      }\n      /*\n        Convert X image to DirectClass packets.\n      */\n      if ((visual_info->colormap_size > 0) &&\n          (visual_info->klass == DirectColor))\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=XGetPixel(dps_image,x,y);\n            index=(pixel >> red_shift) & red_mask;\n            SetPixelRed(image,ScaleShortToQuantum(colors[index].red),q);\n            index=(pixel >> green_shift) & green_mask;\n            SetPixelGreen(image,ScaleShortToQuantum(colors[index].green),q);\n            index=(pixel >> blue_shift) & blue_mask;\n            SetPixelBlue(image,ScaleShortToQuantum(colors[index].blue),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n            break;\n        }\n      else\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=XGetPixel(dps_image,x,y);\n            color=(pixel >> red_shift) & red_mask;\n            color=(color*65535L)/red_mask;\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\n            color=(pixel >> green_shift) & green_mask;\n            color=(color*65535L)/green_mask;\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),q);\n            color=(pixel >> blue_shift) & blue_mask;\n            color=(color*65535L)/blue_mask;\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n            break;\n        }\n      break;\n    }\n    case PseudoClass:\n    {\n      /*\n        Create colormap.\n      */\n      if (AcquireImageColormap(image,(size_t) visual_info->colormap_size,exception) == MagickFalse)\n        {\n          image=DestroyImage(image);\n          colors=(XColor *) RelinquishMagickMemory(colors);\n          XDestroyImage(dps_image);\n          XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n            (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n          return((Image *) NULL);\n        }\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        image->colormap[colors[i].pixel].red=ScaleShortToQuantum(colors[i].red);\n        image->colormap[colors[i].pixel].green=\n          ScaleShortToQuantum(colors[i].green);\n        image->colormap[colors[i].pixel].blue=\n          ScaleShortToQuantum(colors[i].blue);\n      }\n      /*\n        Convert X image to PseudoClass packets.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelIndex(image,(unsigned short) XGetPixel(dps_image,x,y),q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n          break;\n      }\n      break;\n    }\n  }\n  colors=(XColor *) RelinquishMagickMemory(colors);\n  XDestroyImage(dps_image);\n  if (image->storage_class == PseudoClass)\n    (void) SyncImage(image,exception);\n  /*\n    Rasterize matte image.\n  */\n  status=XDPSCreatePixmapForEPSF((DPSContext) NULL,screen,\n    GetBlobFileHandle(image),1,pixels_per_point,&pixmap,&bits_per_pixel,&page);\n  if ((status != dps_status_failure) && (status != dps_status_no_extension))\n    {\n      status=XDPSImageFileIntoDrawable((DPSContext) NULL,screen,pixmap,\n        GetBlobFileHandle(image),(int) bits_per_pixel.height,1,&page,-page.x,\n        -page.y,pixels_per_point,MagickTrue,MagickTrue,MagickTrue,&sans);\n      if (status == dps_status_success)\n        {\n          XImage\n            *matte_image;\n\n          /*\n            Initialize image matte.\n          */\n          matte_image=XGetImage(display,pixmap,0,0,bits_per_pixel.width,\n            bits_per_pixel.height,AllPlanes,ZPixmap);\n          (void) XFreePixmap(display,pixmap);\n          if (matte_image != (XImage *) NULL)\n            {\n              image->storage_class=DirectClass;\n              image->alpha_trait=BlendPixelTrait;\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n                if (q == (Quantum *) NULL)\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  SetPixelAlpha(image,OpaqueAlpha,q);\n                  if (XGetPixel(matte_image,x,y) == 0)\n                    SetPixelAlpha(image,TransparentAlpha,q);\n                  q+=GetPixelChannels(image);\n                }\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n              XDestroyImage(matte_image);\n            }\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n    (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,7 +80,10 @@\n   image=AcquireImage(image_info,exception);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n-    return((Image *) NULL);\n+    {\n+      image=DestroyImageList(image);\n+      return((Image *) NULL);\n+    }\n   /*\n     Get user defaults from X resource database.\n   */",
        "diff_line_info": {
            "deleted_lines": [
                "    return((Image *) NULL);"
            ],
            "added_lines": [
                "    {",
                "      image=DestroyImageList(image);",
                "      return((Image *) NULL);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16710",
        "func_name": "ImageMagick/ReadDOTImage",
        "description": "ImageMagick 7.0.8-35 has a memory leak in coders/dot.c, as demonstrated by AcquireMagickMemory in MagickCore/memory.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ba21957ed064e1960f39a0d3aac762f39ddc614a",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1528",
        "commit_text": "",
        "func_before": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent];\n\n  const char\n    *option;\n\n  graph_t\n    *graph;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  /*\n    Read SVG graph.\n  */\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent];\n\n  const char\n    *option;\n\n  graph_t\n    *graph;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  /*\n    Read SVG graph.\n  */\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,10 @@\n   image=AcquireImage(image_info,exception);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n-    return((Image *) NULL);\n+    {\n+      image=DestroyImageList(image);\n+      return((Image *) NULL);\n+    }\n   read_info=CloneImageInfo(image_info);\n   SetImageInfoBlob(read_info,(void *) NULL,0);\n   (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);",
        "diff_line_info": {
            "deleted_lines": [
                "    return((Image *) NULL);"
            ],
            "added_lines": [
                "    {",
                "      image=DestroyImageList(image);",
                "      return((Image *) NULL);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16711",
        "func_name": "ImageMagick/Huffman2DEncodeImage",
        "description": "ImageMagick 7.0.8-40 has a memory leak in Huffman2DEncodeImage in coders/ps2.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ba0e05ee5a983c202f1030c7901ed6b3ed7d652c",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1542",
        "commit_text": "",
        "func_before": "static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  status=MagickTrue;\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}",
        "func": "static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  write_info=DestroyImageInfo(write_info);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  status=MagickTrue;\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,19 +16,19 @@\n   unsigned char\n     *group4;\n \n-  status=MagickTrue;\n+  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n+  if (group4_image == (Image *) NULL)\n+    return(MagickFalse);\n   write_info=CloneImageInfo(image_info);\n   (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n   (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n-  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n-  if (group4_image == (Image *) NULL)\n-    return(MagickFalse);\n   group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n     exception);\n+  write_info=DestroyImageInfo(write_info);\n   group4_image=DestroyImage(group4_image);\n   if (group4 == (unsigned char *) NULL)\n     return(MagickFalse);\n-  write_info=DestroyImageInfo(write_info);\n+  status=MagickTrue;\n   if (WriteBlob(image,length,group4) != (ssize_t) length)\n     status=MagickFalse;\n   group4=(unsigned char *) RelinquishMagickMemory(group4);",
        "diff_line_info": {
            "deleted_lines": [
                "  status=MagickTrue;",
                "  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);",
                "  if (group4_image == (Image *) NULL)",
                "    return(MagickFalse);",
                "  write_info=DestroyImageInfo(write_info);"
            ],
            "added_lines": [
                "  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);",
                "  if (group4_image == (Image *) NULL)",
                "    return(MagickFalse);",
                "  write_info=DestroyImageInfo(write_info);",
                "  status=MagickTrue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16712",
        "func_name": "ImageMagick/Huffman2DEncodeImage",
        "description": "ImageMagick 7.0.8-43 has a memory leak in Huffman2DEncodeImage in coders/ps3.c, as demonstrated by WritePS3Image.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7b04c53c69792243d66d6876f843b850b3cc002b",
        "commit_title": "Fixed memory leaks reported in #1557.",
        "commit_text": "",
        "func_before": "static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  status=MagickTrue;\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}",
        "func": "static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  status=MagickTrue;\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  write_info=DestroyImageInfo(write_info);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,19 +16,19 @@\n   unsigned char\n     *group4;\n \n+  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n+  if (group4_image == (Image *) NULL)\n+    return(MagickFalse);\n   status=MagickTrue;\n   write_info=CloneImageInfo(image_info);\n   (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n   (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n-  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n-  if (group4_image == (Image *) NULL)\n-    return(MagickFalse);\n   group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n     exception);\n   group4_image=DestroyImage(group4_image);\n+  write_info=DestroyImageInfo(write_info);\n   if (group4 == (unsigned char *) NULL)\n     return(MagickFalse);\n-  write_info=DestroyImageInfo(write_info);\n   if (WriteBlob(image,length,group4) != (ssize_t) length)\n     status=MagickFalse;\n   group4=(unsigned char *) RelinquishMagickMemory(group4);",
        "diff_line_info": {
            "deleted_lines": [
                "  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);",
                "  if (group4_image == (Image *) NULL)",
                "    return(MagickFalse);",
                "  write_info=DestroyImageInfo(write_info);"
            ],
            "added_lines": [
                "  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);",
                "  if (group4_image == (Image *) NULL)",
                "    return(MagickFalse);",
                "  write_info=DestroyImageInfo(write_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16712",
        "func_name": "ImageMagick/Huffman2DEncodeImage",
        "description": "ImageMagick 7.0.8-43 has a memory leak in Huffman2DEncodeImage in coders/ps3.c, as demonstrated by WritePS3Image.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7b04c53c69792243d66d6876f843b850b3cc002b",
        "commit_title": "Fixed memory leaks reported in #1557.",
        "commit_text": "",
        "func_before": "static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  status=MagickTrue;\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}",
        "func": "static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  status=MagickTrue;\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  write_info=DestroyImageInfo(write_info);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,19 +16,19 @@\n   unsigned char\n     *group4;\n \n+  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n+  if (group4_image == (Image *) NULL)\n+    return(MagickFalse);\n   status=MagickTrue;\n   write_info=CloneImageInfo(image_info);\n   (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n   (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n-  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n-  if (group4_image == (Image *) NULL)\n-    return(MagickFalse);\n   group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n     exception);\n   group4_image=DestroyImage(group4_image);\n+  write_info=DestroyImageInfo(write_info);\n   if (group4 == (unsigned char *) NULL)\n     return(MagickFalse);\n-  write_info=DestroyImageInfo(write_info);\n   if (WriteBlob(image,length,group4) != (ssize_t) length)\n     status=MagickFalse;\n   group4=(unsigned char *) RelinquishMagickMemory(group4);",
        "diff_line_info": {
            "deleted_lines": [
                "  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);",
                "  if (group4_image == (Image *) NULL)",
                "    return(MagickFalse);",
                "  write_info=DestroyImageInfo(write_info);"
            ],
            "added_lines": [
                "  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);",
                "  if (group4_image == (Image *) NULL)",
                "    return(MagickFalse);",
                "  write_info=DestroyImageInfo(write_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16713",
        "func_name": "ImageMagick/ReadDOTImage",
        "description": "ImageMagick 7.0.8-43 has a memory leak in coders/dot.c, as demonstrated by PingImage in MagickCore/constitute.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/f050a9b18ba537952abf20db2e18d62f07b4956e",
        "commit_title": "Fixed memory leak reported in #1558 and fixed other leak.",
        "commit_text": "",
        "func_before": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent];\n\n  const char\n    *option;\n\n  graph_t\n    *graph;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  /*\n    Read SVG graph.\n  */\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent];\n\n  const char\n    *option;\n\n  graph_t\n    *graph;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return(DestroyImageList(image));\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  image=DestroyImageList(image);\n  /*\n    Read SVG graph.\n  */\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,10 +32,7 @@\n   image=AcquireImage(image_info,exception);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n-    {\n-      image=DestroyImageList(image);\n-      return((Image *) NULL);\n-    }\n+    return(DestroyImageList(image));\n   read_info=CloneImageInfo(image_info);\n   SetImageInfoBlob(read_info,(void *) NULL,0);\n   (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n@@ -50,7 +47,7 @@\n   if (graph == (graph_t *) NULL)\n     {\n       (void) RelinquishUniqueFileResource(read_info->filename);\n-      return ((Image *) NULL);\n+      return(DestroyImageList(image));\n     }\n   option=GetImageOption(image_info,\"dot:layout-engine\");\n   if (option == (const char *) NULL)\n@@ -60,6 +57,7 @@\n   gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n   gvFreeLayout(graphic_context,graph);\n   agclose(graph);\n+  image=DestroyImageList(image);\n   /*\n     Read SVG graph.\n   */",
        "diff_line_info": {
            "deleted_lines": [
                "    {",
                "      image=DestroyImageList(image);",
                "      return((Image *) NULL);",
                "    }",
                "      return ((Image *) NULL);"
            ],
            "added_lines": [
                "    return(DestroyImageList(image));",
                "      return(DestroyImageList(image));",
                "  image=DestroyImageList(image);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16994",
        "func_name": "torvalds/linux/sit_init_net",
        "description": "In the Linux kernel before 5.0, a memory leak exists in sit_init_net() in net/ipv6/sit.c when register_netdev() fails to register sitn->fb_tunnel_dev, which may cause denial of service, aka CID-07f12b26e21a.",
        "git_url": "https://github.com/torvalds/linux/commit/07f12b26e21ab359261bf75cfcb424fdc7daeb6d",
        "commit_title": "net: sit: fix memory leak in sit_init_net()",
        "commit_text": " If register_netdev() is failed to register sitn->fb_tunnel_dev, it will go to err_reg_dev and forget to free netdev(sitn->fb_tunnel_dev).  BUG: memory leak unreferenced object 0xffff888378daad00 (size 512):   comm \"syz-executor.1\", pid 4006, jiffies 4295121142 (age 16.115s)   hex dump (first 32 bytes):     00 e6 ed c0 83 88 ff ff 00 00 00 00 00 00 00 00  ................     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ backtrace:     [<00000000d6dcb63e>] kvmalloc include/linux/mm.h:577 [inline]     [<00000000d6dcb63e>] kvzalloc include/linux/mm.h:585 [inline]     [<00000000d6dcb63e>] netif_alloc_netdev_queues net/core/dev.c:8380 [inline]     [<00000000d6dcb63e>] alloc_netdev_mqs+0x600/0xcc0 net/core/dev.c:8970     [<00000000867e172f>] sit_init_net+0x295/0xa40 net/ipv6/sit.c:1848     [<00000000871019fa>] ops_init+0xad/0x3e0 net/core/net_namespace.c:129     [<00000000319507f6>] setup_net+0x2ba/0x690 net/core/net_namespace.c:314     [<0000000087db4f96>] copy_net_ns+0x1dc/0x330 net/core/net_namespace.c:437     [<0000000057efc651>] create_new_namespaces+0x382/0x730 kernel/nsproxy.c:107     [<00000000676f83de>] copy_namespaces+0x2ed/0x3d0 kernel/nsproxy.c:165     [<0000000030b74bac>] copy_process.part.27+0x231e/0x6db0 kernel/fork.c:1919     [<00000000fff78746>] copy_process kernel/fork.c:1713 [inline]     [<00000000fff78746>] _do_fork+0x1bc/0xe90 kernel/fork.c:2224     [<000000001c2e0d1c>] do_syscall_64+0xc8/0x580 arch/x86/entry/common.c:290     [<00000000ec48bd44>] entry_SYSCALL_64_after_hwframe+0x49/0xbe     [<0000000039acff8a>] 0xffffffffffffffff ",
        "func_before": "static int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tstruct ip_tunnel *t;\n\tint err;\n\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\tsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;\n\t/* FB netdevice is special: we have one, and only one per netns.\n\t * Allowing to move it to another netns is clearly unsafe.\n\t */\n\tsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\n\terr = register_netdev(sitn->fb_tunnel_dev);\n\tif (err)\n\t\tgoto err_reg_dev;\n\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\n\tt = netdev_priv(sitn->fb_tunnel_dev);\n\n\tstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);\n\treturn 0;\n\nerr_reg_dev:\n\tipip6_dev_free(sitn->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}",
        "func": "static int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tstruct ip_tunnel *t;\n\tint err;\n\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\tsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;\n\t/* FB netdevice is special: we have one, and only one per netns.\n\t * Allowing to move it to another netns is clearly unsafe.\n\t */\n\tsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\n\terr = register_netdev(sitn->fb_tunnel_dev);\n\tif (err)\n\t\tgoto err_reg_dev;\n\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\n\tt = netdev_priv(sitn->fb_tunnel_dev);\n\n\tstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);\n\treturn 0;\n\nerr_reg_dev:\n\tipip6_dev_free(sitn->fb_tunnel_dev);\n\tfree_netdev(sitn->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,7 @@\n \n err_reg_dev:\n \tipip6_dev_free(sitn->fb_tunnel_dev);\n+\tfree_netdev(sitn->fb_tunnel_dev);\n err_alloc_dev:\n \treturn err;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tfree_netdev(sitn->fb_tunnel_dev);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16995",
        "func_name": "torvalds/linux/hsr_dev_finalize",
        "description": "In the Linux kernel before 5.0.3, a memory leak exits in hsr_dev_finalize() in net/hsr/hsr_device.c if hsr_add_port fails to add a port, which may cause denial of service, aka CID-6caabe7f197d.",
        "git_url": "https://github.com/torvalds/linux/commit/6caabe7f197d3466d238f70915d65301f1716626",
        "commit_title": "net: hsr: fix memory leak in hsr_dev_finalize()",
        "commit_text": " If hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER) failed to add port, it directly returns res and forgets to free the node that allocated in hsr_create_self_node(), and forgets to delete the node->mac_list linked in hsr->self_node_db.  BUG: memory leak unreferenced object 0xffff8881cfa0c780 (size 64):   comm \"syz-executor.0\", pid 2077, jiffies 4294717969 (age 2415.377s)   hex dump (first 32 bytes):     e0 c7 a0 cf 81 88 ff ff 00 02 00 00 00 00 ad de  ................     00 e6 49 cd 81 88 ff ff c0 9b 87 d0 81 88 ff ff  ..I.............   backtrace:     [<00000000e2ff5070>] hsr_dev_finalize+0x736/0x960 [hsr]     [<000000003ed2e597>] hsr_newlink+0x2b2/0x3e0 [hsr]     [<000000003fa8c6b6>] __rtnl_newlink+0xf1f/0x1600 net/core/rtnetlink.c:3182     [<000000001247a7ad>] rtnl_newlink+0x66/0x90 net/core/rtnetlink.c:3240     [<00000000e7d1b61d>] rtnetlink_rcv_msg+0x54e/0xb90 net/core/rtnetlink.c:5130     [<000000005556bd3a>] netlink_rcv_skb+0x129/0x340 net/netlink/af_netlink.c:2477     [<00000000741d5ee6>] netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]     [<00000000741d5ee6>] netlink_unicast+0x49a/0x650 net/netlink/af_netlink.c:1336     [<000000009d56f9b7>] netlink_sendmsg+0x88b/0xdf0 net/netlink/af_netlink.c:1917     [<0000000046b35c59>] sock_sendmsg_nosec net/socket.c:621 [inline]     [<0000000046b35c59>] sock_sendmsg+0xc3/0x100 net/socket.c:631     [<00000000d208adc9>] __sys_sendto+0x33e/0x560 net/socket.c:1786     [<00000000b582837a>] __do_sys_sendto net/socket.c:1798 [inline]     [<00000000b582837a>] __se_sys_sendto net/socket.c:1794 [inline]     [<00000000b582837a>] __x64_sys_sendto+0xdd/0x1b0 net/socket.c:1794     [<00000000c866801d>] do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290     [<00000000fea382d9>] entry_SYSCALL_64_after_hwframe+0x49/0xbe     [<00000000e01dacb3>] 0xffffffffffffffff ",
        "func_before": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n\tif (res)\n\t\treturn res;\n\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\nfail:\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\n\n\treturn res;\n}",
        "func": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n\tif (res)\n\t\tgoto err_add_port;\n\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\nfail:\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\nerr_add_port:\n\thsr_del_node(&hsr->self_node_db);\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,7 +46,7 @@\n \n \tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n \tif (res)\n-\t\treturn res;\n+\t\tgoto err_add_port;\n \n \tres = register_netdevice(hsr_dev);\n \tif (res)\n@@ -66,6 +66,8 @@\n fail:\n \thsr_for_each_port(hsr, port)\n \t\thsr_del_port(port);\n+err_add_port:\n+\thsr_del_node(&hsr->self_node_db);\n \n \treturn res;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn res;"
            ],
            "added_lines": [
                "\t\tgoto err_add_port;",
                "err_add_port:",
                "\thsr_del_node(&hsr->self_node_db);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/region16_intersect_rect",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* newItems;\n\tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n\tRECTANGLE_16* dstPtr;\n\tUINT32 nbRects, usedRects;\n\tRECTANGLE_16 common, newExtents;\n\tassert(src);\n\tassert(src->data);\n\tsrcPtr = region16_rects(src, &nbRects);\n\n\tif (!nbRects)\n\t{\n\t\tregion16_clear(dst);\n\t\treturn TRUE;\n\t}\n\n\tsrcExtents = region16_extents(src);\n\n\tif (nbRects == 1)\n\t{\n\t\tBOOL intersects = rectangles_intersection(srcExtents, rect, &common);\n\t\tregion16_clear(dst);\n\n\t\tif (intersects)\n\t\t\treturn region16_union_rect(dst, dst, &common);\n\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion(nbRects);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstPtr = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\tZeroMemory(&newExtents, sizeof(newExtents));\n\n\t/* accumulate intersecting rectangles, the final region16_simplify_bands() will\n\t * do all the bad job to recreate correct rectangles\n\t */\n\tfor (endPtr = srcPtr + nbRects; (srcPtr < endPtr) && (rect->bottom > srcPtr->top); srcPtr++)\n\t{\n\t\tif (rectangles_intersection(srcPtr, rect, &common))\n\t\t{\n\t\t\t*dstPtr = common;\n\t\t\tusedRects++;\n\t\t\tdstPtr++;\n\n\t\t\tif (rectangle_is_empty(&newExtents))\n\t\t\t{\n\t\t\t\t/* Check if the existing newExtents is empty. If it is empty, use\n\t\t\t\t * new common directly. We do not need to check common rectangle\n\t\t\t\t * because the rectangles_intersection() ensures that it is not empty.\n\t\t\t\t */\n\t\t\t\tnewExtents = common;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnewExtents.top = MIN(common.top, newExtents.top);\n\t\t\t\tnewExtents.left = MIN(common.left, newExtents.left);\n\t\t\t\tnewExtents.bottom = MAX(common.bottom, newExtents.bottom);\n\t\t\t\tnewExtents.right = MAX(common.right, newExtents.right);\n\t\t\t}\n\t\t}\n\t}\n\n\tnewItems->nbRects = usedRects;\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\n\tif ((dst->data->size > 0) && (dst->data != &empty_region))\n\t\tfree(dst->data);\n\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->extents = newExtents;\n\treturn region16_simplify_bands(dst);\n}",
        "func": "BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* data;\n\tREGION16_DATA* newItems;\n\tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n\tRECTANGLE_16* dstPtr;\n\tUINT32 nbRects, usedRects;\n\tRECTANGLE_16 common, newExtents;\n\tassert(src);\n\tassert(src->data);\n\tsrcPtr = region16_rects(src, &nbRects);\n\n\tif (!nbRects)\n\t{\n\t\tregion16_clear(dst);\n\t\treturn TRUE;\n\t}\n\n\tsrcExtents = region16_extents(src);\n\n\tif (nbRects == 1)\n\t{\n\t\tBOOL intersects = rectangles_intersection(srcExtents, rect, &common);\n\t\tregion16_clear(dst);\n\n\t\tif (intersects)\n\t\t\treturn region16_union_rect(dst, dst, &common);\n\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion(nbRects);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstPtr = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\tZeroMemory(&newExtents, sizeof(newExtents));\n\n\t/* accumulate intersecting rectangles, the final region16_simplify_bands() will\n\t * do all the bad job to recreate correct rectangles\n\t */\n\tfor (endPtr = srcPtr + nbRects; (srcPtr < endPtr) && (rect->bottom > srcPtr->top); srcPtr++)\n\t{\n\t\tif (rectangles_intersection(srcPtr, rect, &common))\n\t\t{\n\t\t\t*dstPtr = common;\n\t\t\tusedRects++;\n\t\t\tdstPtr++;\n\n\t\t\tif (rectangle_is_empty(&newExtents))\n\t\t\t{\n\t\t\t\t/* Check if the existing newExtents is empty. If it is empty, use\n\t\t\t\t * new common directly. We do not need to check common rectangle\n\t\t\t\t * because the rectangles_intersection() ensures that it is not empty.\n\t\t\t\t */\n\t\t\t\tnewExtents = common;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnewExtents.top = MIN(common.top, newExtents.top);\n\t\t\t\tnewExtents.left = MIN(common.left, newExtents.left);\n\t\t\t\tnewExtents.bottom = MAX(common.bottom, newExtents.bottom);\n\t\t\t\tnewExtents.right = MAX(common.right, newExtents.right);\n\t\t\t}\n\t\t}\n\t}\n\n\tnewItems->nbRects = usedRects;\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\n\tif ((dst->data->size > 0) && (dst->data != &empty_region))\n\t\tfree(dst->data);\n\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->extents = newExtents;\n\treturn region16_simplify_bands(dst);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n {\n+\tREGION16_DATA* data;\n \tREGION16_DATA* newItems;\n \tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n \tRECTANGLE_16* dstPtr;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tREGION16_DATA* data;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/region16_simplify_bands",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "static BOOL region16_simplify_bands(REGION16* region)\n{\n\t/** Simplify consecutive bands that touch and have the same items\n\t *\n\t *  ====================          ====================\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |\t   ====>    | 1 |  |  2  |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================          ====================\n\t *\n\t */\n\tRECTANGLE_16* band1, *band2, *endPtr, *endBand, *tmp;\n\tint nbRects, finalNbRects;\n\tint bandItems, toMove;\n\tfinalNbRects = nbRects = region16_n_rects(region);\n\n\tif (nbRects < 2)\n\t\treturn TRUE;\n\n\tband1 = region16_rects_noconst(region);\n\tendPtr = band1 + nbRects;\n\n\tdo\n\t{\n\t\tband2 = next_band(band1, endPtr, &bandItems);\n\n\t\tif (band2 == endPtr)\n\t\t\tbreak;\n\n\t\tif ((band1->bottom == band2->top) && band_match(band1, band2, endPtr))\n\t\t{\n\t\t\t/* adjust the bottom of band1 items */\n\t\t\ttmp = band1;\n\n\t\t\twhile (tmp < band2)\n\t\t\t{\n\t\t\t\ttmp->bottom = band2->bottom;\n\t\t\t\ttmp++;\n\t\t\t}\n\n\t\t\t/* override band2, we don't move band1 pointer as the band after band2\n\t\t\t * may be merged too */\n\t\t\tendBand = band2 + bandItems;\n\t\t\ttoMove = (endPtr - endBand) * sizeof(RECTANGLE_16);\n\n\t\t\tif (toMove)\n\t\t\t\tMoveMemory(band2, endBand, toMove);\n\n\t\t\tfinalNbRects -= bandItems;\n\t\t\tendPtr -= bandItems;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tint allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tregion->data = realloc(region->data, allocSize);\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion->data->nbRects = finalNbRects;\n\t\tregion->data->size = allocSize;\n\t}\n\n\treturn TRUE;\n}",
        "func": "static BOOL region16_simplify_bands(REGION16* region)\n{\n\t/** Simplify consecutive bands that touch and have the same items\n\t *\n\t *  ====================          ====================\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |\t   ====>    | 1 |  |  2  |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================          ====================\n\t *\n\t */\n\tRECTANGLE_16* band1, *band2, *endPtr, *endBand, *tmp;\n\tint nbRects, finalNbRects;\n\tint bandItems, toMove;\n\tfinalNbRects = nbRects = region16_n_rects(region);\n\n\tif (nbRects < 2)\n\t\treturn TRUE;\n\n\tband1 = region16_rects_noconst(region);\n\tendPtr = band1 + nbRects;\n\n\tdo\n\t{\n\t\tband2 = next_band(band1, endPtr, &bandItems);\n\n\t\tif (band2 == endPtr)\n\t\t\tbreak;\n\n\t\tif ((band1->bottom == band2->top) && band_match(band1, band2, endPtr))\n\t\t{\n\t\t\t/* adjust the bottom of band1 items */\n\t\t\ttmp = band1;\n\n\t\t\twhile (tmp < band2)\n\t\t\t{\n\t\t\t\ttmp->bottom = band2->bottom;\n\t\t\t\ttmp++;\n\t\t\t}\n\n\t\t\t/* override band2, we don't move band1 pointer as the band after band2\n\t\t\t * may be merged too */\n\t\t\tendBand = band2 + bandItems;\n\t\t\ttoMove = (endPtr - endBand) * sizeof(RECTANGLE_16);\n\n\t\t\tif (toMove)\n\t\t\t\tMoveMemory(band2, endBand, toMove);\n\n\t\t\tfinalNbRects -= bandItems;\n\t\t\tendPtr -= bandItems;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tREGION16_DATA* data;\n\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tdata = realloc(region->data, allocSize);\n\t\tif (!data)\n\t\t\tfree(region->data);\n\t\tregion->data = data;\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion->data->nbRects = finalNbRects;\n\t\tregion->data->size = allocSize;\n\t}\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,8 +60,12 @@\n \n \tif (finalNbRects != nbRects)\n \t{\n-\t\tint allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n-\t\tregion->data = realloc(region->data, allocSize);\n+\t\tREGION16_DATA* data;\n+\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n+\t\tdata = realloc(region->data, allocSize);\n+\t\tif (!data)\n+\t\t\tfree(region->data);\n+\t\tregion->data = data;\n \n \t\tif (!region->data)\n \t\t{",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tint allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));",
                "\t\tregion->data = realloc(region->data, allocSize);"
            ],
            "added_lines": [
                "\t\tREGION16_DATA* data;",
                "\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));",
                "\t\tdata = realloc(region->data, allocSize);",
                "\t\tif (!data)",
                "\t\t\tfree(region->data);",
                "\t\tregion->data = data;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/region16_union_rect",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n\tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n\tdstExtents->right = MAX(rect->right, srcExtents->right);\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->data->nbRects = usedRects;\n\treturn region16_simplify_bands(dst);\n}",
        "func": "BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* data;\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tREGION16_DATA* tmpItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n\tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n\tdstExtents->right = MAX(rect->right, srcExtents->right);\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\ttmpItems = realloc(newItems, newItems->size);\n\tif (!tmpItems)\n\t\tfree(newItems);\n\tnewItems = tmpItems;\n\tdst->data = newItems;\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->data->nbRects = usedRects;\n\treturn region16_simplify_bands(dst);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,11 @@\n BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n {\n+\tREGION16_DATA* data;\n \tconst RECTANGLE_16* srcExtents;\n \tRECTANGLE_16* dstExtents;\n \tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n \tREGION16_DATA* newItems = NULL;\n+\tREGION16_DATA* tmpItems = NULL;\n \tRECTANGLE_16* dstRect = NULL;\n \tUINT32 usedRects, srcNbRects;\n \tUINT16 topInterBand;\n@@ -188,7 +190,11 @@\n \tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n \tdstExtents->right = MAX(rect->right, srcExtents->right);\n \tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n-\tdst->data = realloc(newItems, newItems->size);\n+\ttmpItems = realloc(newItems, newItems->size);\n+\tif (!tmpItems)\n+\t\tfree(newItems);\n+\tnewItems = tmpItems;\n+\tdst->data = newItems;\n \n \tif (!dst->data)\n \t{",
        "diff_line_info": {
            "deleted_lines": [
                "\tdst->data = realloc(newItems, newItems->size);"
            ],
            "added_lines": [
                "\tREGION16_DATA* data;",
                "\tREGION16_DATA* tmpItems = NULL;",
                "\ttmpItems = realloc(newItems, newItems->size);",
                "\tif (!tmpItems)",
                "\t\tfree(newItems);",
                "\tnewItems = tmpItems;",
                "\tdst->data = newItems;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/HuffmanTree_makeFromFrequencies",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\n{\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  /*initialize all lengths to 0*/\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}",
        "func": "static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\n{\n\tunsigned* lengths;\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n\tif (!lengths)\n\t\tfree(tree->lengths);\n\ttree->lengths = lengths;\n  if(!tree->lengths) return 83; /*alloc fail*/\n  /*initialize all lengths to 0*/\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,15 @@\n static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                 size_t mincodes, size_t numcodes, unsigned maxbitlen)\n {\n+\tunsigned* lengths;\n   unsigned error = 0;\n   while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n   tree->maxbitlen = maxbitlen;\n   tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n-  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n+  lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n+\tif (!lengths)\n+\t\tfree(tree->lengths);\n+\ttree->lengths = lengths;\n   if(!tree->lengths) return 83; /*alloc fail*/\n   /*initialize all lengths to 0*/\n   memset(tree->lengths, 0, numcodes * sizeof(unsigned));",
        "diff_line_info": {
            "deleted_lines": [
                "  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));"
            ],
            "added_lines": [
                "\tunsigned* lengths;",
                "  lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));",
                "\tif (!lengths)",
                "\t\tfree(tree->lengths);",
                "\ttree->lengths = lengths;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/tr_esc_str",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "LPSTR tr_esc_str(LPCSTR arg, bool format)\n{\n\tLPSTR tmp = NULL;\n\tsize_t cs = 0, x, ds, len;\n\tsize_t s;\n\n\tif (NULL == arg)\n\t\treturn NULL;\n\n\ts = strlen(arg);\n\n\t/* Find trailing whitespaces */\n\twhile ((s > 0) && isspace(arg[s - 1]))\n\t\ts--;\n\n\t/* Prepare a initial buffer with the size of the result string. */\n\tds = s + 1;\n\n\tif (s)\n\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\tif (NULL == tmp)\n\t{\n\t\tfprintf(stderr,  \"Could not allocate string buffer.\\n\");\n\t\texit(-2);\n\t}\n\n\t/* Copy character for character and check, if it is necessary to escape. */\n\tmemset(tmp, 0, ds * sizeof(CHAR));\n\n\tfor (x = 0; x < s; x++)\n\t{\n\t\tswitch (arg[x])\n\t\t{\n\t\t\tcase '<':\n\t\t\t\tlen = format ? 13 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-3);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"<replaceable>\", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"&lt;\", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tlen = format ? 14 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-4);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"</replaceable>\", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"&lt;\", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\t\tds += 5;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-5);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 's';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '\"':\n\t\t\t\tds += 5;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-6);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'q';\n\t\t\t\ttmp[cs++] = 'u';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 't';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '&':\n\t\t\t\tds += 4;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-7);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'm';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttmp[cs++] = arg[x];\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Assure, the string is '\\0' terminated. */\n\t\ttmp[ds - 1] = '\\0';\n\t}\n\n\treturn tmp;\n}",
        "func": "LPSTR tr_esc_str(LPCSTR arg, bool format)\n{\n\tLPSTR tmp = NULL;\n\tLPSTR tmp2 = NULL;\n\tsize_t cs = 0, x, ds, len;\n\tsize_t s;\n\n\tif (NULL == arg)\n\t\treturn NULL;\n\n\ts = strlen(arg);\n\n\t/* Find trailing whitespaces */\n\twhile ((s > 0) && isspace(arg[s - 1]))\n\t\ts--;\n\n\t/* Prepare a initial buffer with the size of the result string. */\n\tds = s + 1;\n\n\tif (s)\n\t{\n\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\tif (!tmp2)\n\t\t\tfree(tmp);\n\t\ttmp = tmp2;\n\t}\n\n\tif (NULL == tmp)\n\t{\n\t\tfprintf(stderr,  \"Could not allocate string buffer.\\n\");\n\t\texit(-2);\n\t}\n\n\t/* Copy character for character and check, if it is necessary to escape. */\n\tmemset(tmp, 0, ds * sizeof(CHAR));\n\n\tfor (x = 0; x < s; x++)\n\t{\n\t\tswitch (arg[x])\n\t\t{\n\t\t\tcase '<':\n\t\t\t\tlen = format ? 13 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-3);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"<replaceable>\", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"&lt;\", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tlen = format ? 14 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-4);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"</replaceable>\", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"&lt;\", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\t\tds += 5;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-5);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 's';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '\"':\n\t\t\t\tds += 5;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-6);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'q';\n\t\t\t\ttmp[cs++] = 'u';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 't';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '&':\n\t\t\t\tds += 4;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-7);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'm';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttmp[cs++] = arg[x];\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Assure, the string is '\\0' terminated. */\n\t\ttmp[ds - 1] = '\\0';\n\t}\n\n\treturn tmp;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n LPSTR tr_esc_str(LPCSTR arg, bool format)\n {\n \tLPSTR tmp = NULL;\n+\tLPSTR tmp2 = NULL;\n \tsize_t cs = 0, x, ds, len;\n \tsize_t s;\n \n@@ -17,7 +18,12 @@\n \tds = s + 1;\n \n \tif (s)\n-\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t{\n+\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\tif (!tmp2)\n+\t\t\tfree(tmp);\n+\t\ttmp = tmp2;\n+\t}\n \n \tif (NULL == tmp)\n \t{\n@@ -35,7 +41,10 @@\n \t\t\tcase '<':\n \t\t\t\tlen = format ? 13 : 4;\n \t\t\t\tds += len - 1;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{\n@@ -56,7 +65,10 @@\n \t\t\tcase '>':\n \t\t\t\tlen = format ? 14 : 4;\n \t\t\t\tds += len - 1;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{\n@@ -76,7 +88,10 @@\n \n \t\t\tcase '\\'':\n \t\t\t\tds += 5;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{\n@@ -94,7 +109,10 @@\n \n \t\t\tcase '\"':\n \t\t\t\tds += 5;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{\n@@ -112,7 +130,10 @@\n \n \t\t\tcase '&':\n \t\t\t\tds += 4;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{",
        "diff_line_info": {
            "deleted_lines": [
                "\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));"
            ],
            "added_lines": [
                "\tLPSTR tmp2 = NULL;",
                "\t{",
                "\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\tif (!tmp2)",
                "\t\t\tfree(tmp);",
                "\t\ttmp = tmp2;",
                "\t}",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17340",
        "func_name": "xen-project/xen/gnttab_transfer",
        "description": "An issue was discovered in Xen through 4.11.x allowing x86 guest OS users to cause a denial of service or gain privileges because grant-table transfer requests are mishandled.",
        "git_url": "https://github.com/xen-project/xen/commit/6d4f36c3fecc0a6a0991716199612c81d909316e",
        "commit_title": "gnttab: set page refcount for copy-on-grant-transfer",
        "commit_text": " Commit 5cc77f9098 (\"32-on-64: Fix domain address-size clamping, implement\"), which introduced this functionality, took care of clearing the old page's PGC_allocated, but failed to set the bit (and install the associated reference) on the newly allocated one. Furthermore the \"mfn\" local variable was never updated, and hence the wrong MFN was passed to guest_physmap_add_page() (and back to the destination domain) in this case, leading to an IOMMU mapping into an unowned page.  Ideally the code would use assign_pages(), but the call to gnttab_prepare_for_transfer() sits in the middle of the actions mirroring that function.  This is XSA-284. ",
        "func_before": "static long\ngnttab_transfer(\n    XEN_GUEST_HANDLE_PARAM(gnttab_transfer_t) uop, unsigned int count)\n{\n    struct domain *d = current->domain;\n    struct domain *e;\n    struct page_info *page;\n    int i;\n    struct gnttab_transfer gop;\n    mfn_t mfn;\n    unsigned int max_bitsize;\n    struct active_grant_entry *act;\n\n    for ( i = 0; i < count; i++ )\n    {\n        bool_t okay;\n        int rc;\n\n        if ( i && hypercall_preempt_check() )\n            return i;\n\n        /* Read from caller address space. */\n        if ( unlikely(__copy_from_guest(&gop, uop, 1)) )\n        {\n            gdprintk(XENLOG_INFO, \"error reading req %d/%u\\n\",\n                    i, count);\n            return -EFAULT;\n        }\n\n#ifdef CONFIG_X86\n        {\n            p2m_type_t p2mt;\n\n            mfn = get_gfn_unshare(d, gop.mfn, &p2mt);\n            if ( p2m_is_shared(p2mt) || !p2m_is_valid(p2mt) )\n                mfn = INVALID_MFN;\n        }\n#else\n        mfn = gfn_to_mfn(d, _gfn(gop.mfn));\n#endif\n\n        /* Check the passed page frame for basic validity. */\n        if ( unlikely(!mfn_valid(mfn)) )\n        {\n#ifdef CONFIG_X86\n            put_gfn(d, gop.mfn);\n#endif\n            gdprintk(XENLOG_INFO, \"out-of-range %lx\\n\", (unsigned long)gop.mfn);\n            gop.status = GNTST_bad_page;\n            goto copyback;\n        }\n\n        page = mfn_to_page(mfn);\n        if ( (rc = steal_page(d, page, 0)) < 0 )\n        {\n#ifdef CONFIG_X86\n            put_gfn(d, gop.mfn);\n#endif\n            gop.status = rc == -EINVAL ? GNTST_bad_page : GNTST_general_error;\n            goto copyback;\n        }\n\n        rc = guest_physmap_remove_page(d, _gfn(gop.mfn), mfn, 0);\n        gnttab_flush_tlb(d);\n        if ( rc )\n        {\n            gdprintk(XENLOG_INFO,\n                     \"can't remove GFN %\"PRI_xen_pfn\" (MFN %#\"PRI_mfn\")\\n\",\n                     gop.mfn, mfn_x(mfn));\n            gop.status = GNTST_general_error;\n            goto put_gfn_and_copyback;\n        }\n\n        /* Find the target domain. */\n        if ( unlikely((e = rcu_lock_domain_by_id(gop.domid)) == NULL) )\n        {\n            gdprintk(XENLOG_INFO, \"can't find d%d\\n\", gop.domid);\n            gop.status = GNTST_bad_domain;\n            goto put_gfn_and_copyback;\n        }\n\n        if ( xsm_grant_transfer(XSM_HOOK, d, e) )\n        {\n            gop.status = GNTST_permission_denied;\n        unlock_and_copyback:\n            rcu_unlock_domain(e);\n        put_gfn_and_copyback:\n#ifdef CONFIG_X86\n            put_gfn(d, gop.mfn);\n#endif\n            page->count_info &= ~(PGC_count_mask|PGC_allocated);\n            free_domheap_page(page);\n            goto copyback;\n        }\n\n        max_bitsize = domain_clamp_alloc_bitsize(\n            e, e->grant_table->gt_version > 1 || paging_mode_translate(e)\n               ? BITS_PER_LONG + PAGE_SHIFT : 32 + PAGE_SHIFT);\n        if ( max_bitsize < BITS_PER_LONG + PAGE_SHIFT &&\n             (mfn_x(mfn) >> (max_bitsize - PAGE_SHIFT)) )\n        {\n            struct page_info *new_page;\n\n            new_page = alloc_domheap_page(e, MEMF_no_owner |\n                                             MEMF_bits(max_bitsize));\n            if ( new_page == NULL )\n            {\n                gop.status = GNTST_address_too_big;\n                goto unlock_and_copyback;\n            }\n\n            copy_domain_page(page_to_mfn(new_page), mfn);\n\n            page->count_info &= ~(PGC_count_mask|PGC_allocated);\n            free_domheap_page(page);\n            page = new_page;\n        }\n\n        spin_lock(&e->page_alloc_lock);\n\n        /*\n         * Check that 'e' will accept the page and has reservation\n         * headroom.  Also, a domain mustn't have PGC_allocated\n         * pages when it is dying.\n         */\n        if ( unlikely(e->is_dying) ||\n             unlikely(e->tot_pages >= e->max_pages) )\n        {\n            spin_unlock(&e->page_alloc_lock);\n\n            if ( e->is_dying )\n                gdprintk(XENLOG_INFO, \"Transferee d%d is dying\\n\",\n                         e->domain_id);\n            else\n                gdprintk(XENLOG_INFO,\n                         \"Transferee d%d has no headroom (tot %u, max %u)\\n\",\n                         e->domain_id, e->tot_pages, e->max_pages);\n\n            gop.status = GNTST_general_error;\n            goto unlock_and_copyback;\n        }\n\n        /* Okay, add the page to 'e'. */\n        if ( unlikely(domain_adjust_tot_pages(e, 1) == 1) )\n            get_knownalive_domain(e);\n\n        /*\n         * We must drop the lock to avoid a possible deadlock in\n         * gnttab_prepare_for_transfer.  We have reserved a page in e so can\n         * safely drop the lock and re-aquire it later to add page to the\n         * pagelist.\n         */\n        spin_unlock(&e->page_alloc_lock);\n        okay = gnttab_prepare_for_transfer(e, d, gop.ref);\n        spin_lock(&e->page_alloc_lock);\n\n        if ( unlikely(!okay) || unlikely(e->is_dying) )\n        {\n            bool_t drop_dom_ref = !domain_adjust_tot_pages(e, -1);\n\n            spin_unlock(&e->page_alloc_lock);\n\n            if ( okay /* i.e. e->is_dying due to the surrounding if() */ )\n                gdprintk(XENLOG_INFO, \"Transferee d%d is now dying\\n\",\n                         e->domain_id);\n\n            if ( drop_dom_ref )\n                put_domain(e);\n            gop.status = GNTST_general_error;\n            goto unlock_and_copyback;\n        }\n\n        page_list_add_tail(page, &e->page_list);\n        page_set_owner(page, e);\n\n        spin_unlock(&e->page_alloc_lock);\n#ifdef CONFIG_X86\n        put_gfn(d, gop.mfn);\n#endif\n\n        TRACE_1D(TRC_MEM_PAGE_GRANT_TRANSFER, e->domain_id);\n\n        /* Tell the guest about its new page frame. */\n        grant_read_lock(e->grant_table);\n        act = active_entry_acquire(e->grant_table, gop.ref);\n\n        if ( e->grant_table->gt_version == 1 )\n        {\n            grant_entry_v1_t *sha = &shared_entry_v1(e->grant_table, gop.ref);\n\n            guest_physmap_add_page(e, _gfn(sha->frame), mfn, 0);\n            if ( !paging_mode_translate(e) )\n                sha->frame = mfn_x(mfn);\n        }\n        else\n        {\n            grant_entry_v2_t *sha = &shared_entry_v2(e->grant_table, gop.ref);\n\n            guest_physmap_add_page(e, _gfn(sha->full_page.frame), mfn, 0);\n            if ( !paging_mode_translate(e) )\n                sha->full_page.frame = mfn_x(mfn);\n        }\n        smp_wmb();\n        shared_entry_header(e->grant_table, gop.ref)->flags |=\n            GTF_transfer_completed;\n\n        active_entry_release(act);\n        grant_read_unlock(e->grant_table);\n\n        rcu_unlock_domain(e);\n\n        gop.status = GNTST_okay;\n\n    copyback:\n        if ( unlikely(__copy_field_to_guest(uop, &gop, status)) )\n        {\n            gdprintk(XENLOG_INFO, \"error writing resp %d/%u\\n\", i, count);\n            return -EFAULT;\n        }\n        guest_handle_add_offset(uop, 1);\n    }\n\n    return 0;\n}",
        "func": "static long\ngnttab_transfer(\n    XEN_GUEST_HANDLE_PARAM(gnttab_transfer_t) uop, unsigned int count)\n{\n    struct domain *d = current->domain;\n    struct domain *e;\n    struct page_info *page;\n    int i;\n    struct gnttab_transfer gop;\n    mfn_t mfn;\n    unsigned int max_bitsize;\n    struct active_grant_entry *act;\n\n    for ( i = 0; i < count; i++ )\n    {\n        bool_t okay;\n        int rc;\n\n        if ( i && hypercall_preempt_check() )\n            return i;\n\n        /* Read from caller address space. */\n        if ( unlikely(__copy_from_guest(&gop, uop, 1)) )\n        {\n            gdprintk(XENLOG_INFO, \"error reading req %d/%u\\n\",\n                    i, count);\n            return -EFAULT;\n        }\n\n#ifdef CONFIG_X86\n        {\n            p2m_type_t p2mt;\n\n            mfn = get_gfn_unshare(d, gop.mfn, &p2mt);\n            if ( p2m_is_shared(p2mt) || !p2m_is_valid(p2mt) )\n                mfn = INVALID_MFN;\n        }\n#else\n        mfn = gfn_to_mfn(d, _gfn(gop.mfn));\n#endif\n\n        /* Check the passed page frame for basic validity. */\n        if ( unlikely(!mfn_valid(mfn)) )\n        {\n#ifdef CONFIG_X86\n            put_gfn(d, gop.mfn);\n#endif\n            gdprintk(XENLOG_INFO, \"out-of-range %lx\\n\", (unsigned long)gop.mfn);\n            gop.status = GNTST_bad_page;\n            goto copyback;\n        }\n\n        page = mfn_to_page(mfn);\n        if ( (rc = steal_page(d, page, 0)) < 0 )\n        {\n#ifdef CONFIG_X86\n            put_gfn(d, gop.mfn);\n#endif\n            gop.status = rc == -EINVAL ? GNTST_bad_page : GNTST_general_error;\n            goto copyback;\n        }\n\n        rc = guest_physmap_remove_page(d, _gfn(gop.mfn), mfn, 0);\n        gnttab_flush_tlb(d);\n        if ( rc )\n        {\n            gdprintk(XENLOG_INFO,\n                     \"can't remove GFN %\"PRI_xen_pfn\" (MFN %#\"PRI_mfn\")\\n\",\n                     gop.mfn, mfn_x(mfn));\n            gop.status = GNTST_general_error;\n            goto put_gfn_and_copyback;\n        }\n\n        /* Find the target domain. */\n        if ( unlikely((e = rcu_lock_domain_by_id(gop.domid)) == NULL) )\n        {\n            gdprintk(XENLOG_INFO, \"can't find d%d\\n\", gop.domid);\n            gop.status = GNTST_bad_domain;\n            goto put_gfn_and_copyback;\n        }\n\n        if ( xsm_grant_transfer(XSM_HOOK, d, e) )\n        {\n            gop.status = GNTST_permission_denied;\n        unlock_and_copyback:\n            rcu_unlock_domain(e);\n        put_gfn_and_copyback:\n#ifdef CONFIG_X86\n            put_gfn(d, gop.mfn);\n#endif\n            page->count_info &= ~(PGC_count_mask|PGC_allocated);\n            free_domheap_page(page);\n            goto copyback;\n        }\n\n        max_bitsize = domain_clamp_alloc_bitsize(\n            e, e->grant_table->gt_version > 1 || paging_mode_translate(e)\n               ? BITS_PER_LONG + PAGE_SHIFT : 32 + PAGE_SHIFT);\n        if ( max_bitsize < BITS_PER_LONG + PAGE_SHIFT &&\n             (mfn_x(mfn) >> (max_bitsize - PAGE_SHIFT)) )\n        {\n            struct page_info *new_page;\n\n            new_page = alloc_domheap_page(e, MEMF_no_owner |\n                                             MEMF_bits(max_bitsize));\n            if ( new_page == NULL )\n            {\n                gop.status = GNTST_address_too_big;\n                goto unlock_and_copyback;\n            }\n\n            copy_domain_page(page_to_mfn(new_page), mfn);\n\n            page->count_info &= ~(PGC_count_mask|PGC_allocated);\n            free_domheap_page(page);\n            page = new_page;\n            page->count_info = PGC_allocated | 1;\n            mfn = page_to_mfn(page);\n        }\n\n        spin_lock(&e->page_alloc_lock);\n\n        /*\n         * Check that 'e' will accept the page and has reservation\n         * headroom.  Also, a domain mustn't have PGC_allocated\n         * pages when it is dying.\n         */\n        if ( unlikely(e->is_dying) ||\n             unlikely(e->tot_pages >= e->max_pages) )\n        {\n            spin_unlock(&e->page_alloc_lock);\n\n            if ( e->is_dying )\n                gdprintk(XENLOG_INFO, \"Transferee d%d is dying\\n\",\n                         e->domain_id);\n            else\n                gdprintk(XENLOG_INFO,\n                         \"Transferee d%d has no headroom (tot %u, max %u)\\n\",\n                         e->domain_id, e->tot_pages, e->max_pages);\n\n            gop.status = GNTST_general_error;\n            goto unlock_and_copyback;\n        }\n\n        /* Okay, add the page to 'e'. */\n        if ( unlikely(domain_adjust_tot_pages(e, 1) == 1) )\n            get_knownalive_domain(e);\n\n        /*\n         * We must drop the lock to avoid a possible deadlock in\n         * gnttab_prepare_for_transfer.  We have reserved a page in e so can\n         * safely drop the lock and re-aquire it later to add page to the\n         * pagelist.\n         */\n        spin_unlock(&e->page_alloc_lock);\n        okay = gnttab_prepare_for_transfer(e, d, gop.ref);\n        spin_lock(&e->page_alloc_lock);\n\n        if ( unlikely(!okay) || unlikely(e->is_dying) )\n        {\n            bool_t drop_dom_ref = !domain_adjust_tot_pages(e, -1);\n\n            spin_unlock(&e->page_alloc_lock);\n\n            if ( okay /* i.e. e->is_dying due to the surrounding if() */ )\n                gdprintk(XENLOG_INFO, \"Transferee d%d is now dying\\n\",\n                         e->domain_id);\n\n            if ( drop_dom_ref )\n                put_domain(e);\n            gop.status = GNTST_general_error;\n            goto unlock_and_copyback;\n        }\n\n        page_list_add_tail(page, &e->page_list);\n        page_set_owner(page, e);\n\n        spin_unlock(&e->page_alloc_lock);\n#ifdef CONFIG_X86\n        put_gfn(d, gop.mfn);\n#endif\n\n        TRACE_1D(TRC_MEM_PAGE_GRANT_TRANSFER, e->domain_id);\n\n        /* Tell the guest about its new page frame. */\n        grant_read_lock(e->grant_table);\n        act = active_entry_acquire(e->grant_table, gop.ref);\n\n        if ( e->grant_table->gt_version == 1 )\n        {\n            grant_entry_v1_t *sha = &shared_entry_v1(e->grant_table, gop.ref);\n\n            guest_physmap_add_page(e, _gfn(sha->frame), mfn, 0);\n            if ( !paging_mode_translate(e) )\n                sha->frame = mfn_x(mfn);\n        }\n        else\n        {\n            grant_entry_v2_t *sha = &shared_entry_v2(e->grant_table, gop.ref);\n\n            guest_physmap_add_page(e, _gfn(sha->full_page.frame), mfn, 0);\n            if ( !paging_mode_translate(e) )\n                sha->full_page.frame = mfn_x(mfn);\n        }\n        smp_wmb();\n        shared_entry_header(e->grant_table, gop.ref)->flags |=\n            GTF_transfer_completed;\n\n        active_entry_release(act);\n        grant_read_unlock(e->grant_table);\n\n        rcu_unlock_domain(e);\n\n        gop.status = GNTST_okay;\n\n    copyback:\n        if ( unlikely(__copy_field_to_guest(uop, &gop, status)) )\n        {\n            gdprintk(XENLOG_INFO, \"error writing resp %d/%u\\n\", i, count);\n            return -EFAULT;\n        }\n        guest_handle_add_offset(uop, 1);\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -114,6 +114,8 @@\n             page->count_info &= ~(PGC_count_mask|PGC_allocated);\n             free_domheap_page(page);\n             page = new_page;\n+            page->count_info = PGC_allocated | 1;\n+            mfn = page_to_mfn(page);\n         }\n \n         spin_lock(&e->page_alloc_lock);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            page->count_info = PGC_allocated | 1;",
                "            mfn = page_to_mfn(page);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-23578",
        "func_name": "tensorflow/ImmutableExecutorState::Initialize",
        "description": "Tensorflow is an Open Source Machine Learning Framework. If a graph node is invalid, TensorFlow can leak memory in the implementation of `ImmutableExecutorState::Initialize`. Here, we set `item->kernel` to `nullptr` but it is a simple `OpKernel*` pointer so the memory that was previously allocated to it would leak. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/c79ccba517dbb1a0ccb9b01ee3bd2a63748b60dd",
        "commit_title": "Fix memory leak when a graph node is invalid.",
        "commit_text": " If a graph node is invalid but a kernel is created then we set the kernel back to `nullptr` but we forget to delete it. Hence, we get a memory leak.  PiperOrigin-RevId: 408968108",
        "func_before": "Status ImmutableExecutorState::Initialize(const Graph& graph) {\n  TF_RETURN_IF_ERROR(gview_.Initialize(&graph));\n\n  // Build the information about frames in this subgraph.\n  ControlFlowInfo cf_info;\n  TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));\n\n  for (auto& it : cf_info.unique_frame_names) {\n    EnsureFrameInfo(it)->nodes =\n        absl::make_unique<std::vector<const NodeItem*>>();\n  }\n  root_frame_info_ = frame_info_[\"\"].get();\n\n  pending_ids_.resize(gview_.num_nodes());\n\n  // Preprocess every node in the graph to create an instance of op\n  // kernel for each node.\n  requires_control_flow_ = false;\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {\n      requires_control_flow_ = true;\n    } else if (IsRecv(n)) {\n      // A Recv node from a different device may produce dead tensors from\n      // non-local control-flow nodes.\n      //\n      // TODO(mrry): Track whether control flow was present in the\n      // pre-partitioned graph, and enable the caller (e.g.\n      // `DirectSession`) to relax this constraint.\n      string send_device;\n      string recv_device;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"send_device\", &send_device));\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"recv_device\", &recv_device));\n      if (send_device != recv_device) {\n        requires_control_flow_ = true;\n      }\n    }\n\n    const int id = n->id();\n    const string& frame_name = cf_info.frame_names[id];\n    FrameInfo* frame_info = EnsureFrameInfo(frame_name);\n\n    NodeItem* item = gview_.node(id);\n    item->node_id = id;\n\n    item->input_start = frame_info->total_inputs;\n    frame_info->total_inputs += n->num_inputs();\n\n    Status s = params_.create_kernel(n->properties(), &item->kernel);\n    if (!s.ok()) {\n      item->kernel = nullptr;\n      s = AttachDef(s, *n);\n      return s;\n    }\n    CHECK(item->kernel);\n    item->kernel_is_async = (item->kernel->AsAsync() != nullptr);\n    item->is_merge = IsMerge(n);\n    item->is_any_consumer_merge_or_control_trigger = false;\n    for (const Node* consumer : n->out_nodes()) {\n      if (IsMerge(consumer) || IsControlTrigger(consumer)) {\n        item->is_any_consumer_merge_or_control_trigger = true;\n        break;\n      }\n    }\n    const Tensor* const_tensor = item->kernel->const_tensor();\n    if (const_tensor) {\n      // Hold onto a shallow copy of the constant tensor in `*this` so that the\n      // reference count does not drop to 1. This prevents the constant tensor\n      // from being forwarded, and its buffer reused.\n      const_tensors_.emplace_back(*const_tensor);\n    }\n    item->const_tensor = const_tensor;\n    item->is_noop = (item->kernel->type_string_view() == \"NoOp\");\n    item->is_enter = IsEnter(n);\n    if (item->is_enter) {\n      bool is_constant_enter;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"is_constant\", &is_constant_enter));\n      item->is_constant_enter = is_constant_enter;\n\n      string frame_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &frame_name));\n      FrameInfo* frame_info = frame_info_[frame_name].get();\n\n      int parallel_iterations;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"parallel_iterations\", &parallel_iterations));\n\n      if (frame_info->parallel_iterations == -1) {\n        frame_info->parallel_iterations = parallel_iterations;\n      } else if (frame_info->parallel_iterations != parallel_iterations) {\n        LOG(WARNING) << \"Loop frame \\\"\" << frame_name\n                     << \"\\\" had two different values for parallel_iterations: \"\n                     << frame_info->parallel_iterations << \" vs. \"\n                     << parallel_iterations << \".\";\n      }\n\n      if (enter_frame_info_.size() <= id) {\n        enter_frame_info_.resize(id + 1);\n      }\n      enter_frame_info_[id] = frame_info;\n    } else {\n      item->is_constant_enter = false;\n    }\n    item->is_exit = IsExit(n);\n    item->is_control_trigger = IsControlTrigger(n);\n    item->is_source = IsSource(n);\n    item->is_enter_exit_or_next_iter =\n        (IsEnter(n) || IsExit(n) || IsNextIteration(n));\n    item->is_transfer_node = IsTransferNode(n);\n    item->is_initialization_op = IsInitializationOp(n);\n    item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);\n    item->is_next_iteration = IsNextIteration(n);\n    item->is_distributed_communication = IsDistributedCommunication(n);\n\n    // Compute the maximum values we'll store for this node in the\n    // pending counts data structure, and allocate a handle in\n    // that frame's pending counts data structure that has enough\n    // space to store these maximal count values.\n    size_t max_pending, max_dead;\n    GetMaxPendingCounts(n, &max_pending, &max_dead);\n    pending_ids_[id] =\n        frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);\n\n    // See if this node is a root node, and if so, add item to root_nodes_.\n    if (n->in_edges().empty()) {\n      root_nodes_.push_back(item);\n    }\n\n    // Initialize static information about the frames in the graph.\n    frame_info->nodes->push_back(item);\n    if (item->is_enter) {\n      string enter_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &enter_name));\n      EnsureFrameInfo(enter_name)->input_count++;\n    }\n\n    // Record information about whether each output of the op is used.\n    std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);\n    std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);\n    int32_t unused_outputs = n->num_outputs();\n    for (const Edge* e : n->out_edges()) {\n      if (IsSink(e->dst())) continue;\n      if (e->src_output() >= 0) {\n        if (!outputs_required[e->src_output()]) {\n          --unused_outputs;\n          outputs_required[e->src_output()] = true;\n        }\n      }\n    }\n    if (unused_outputs > 0) {\n      for (int i = 0; i < n->num_outputs(); ++i) {\n        if (!outputs_required[i]) {\n          metrics::RecordUnusedOutput(n->type_string());\n        }\n      }\n      item->outputs_required = std::move(outputs_required);\n    }\n  }\n\n  // Rewrite each `EdgeInfo::input_slot` member to refer directly to the input\n  // location.\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    const int id = n->id();\n    NodeItem* item = gview_.node(id);\n\n    for (EdgeInfo& e : item->mutable_output_edges()) {\n      const int dst_id = e.dst_id;\n      NodeItem* dst_item = gview_.node(dst_id);\n      e.input_slot += dst_item->input_start;\n    }\n  }\n\n  // Initialize PendingCounts only after pending_ids_[node.id] is initialized\n  // for all nodes.\n  InitializePending(&graph, cf_info);\n  return gview_.SetAllocAttrs(&graph, params_.device);\n}",
        "func": "Status ImmutableExecutorState::Initialize(const Graph& graph) {\n  TF_RETURN_IF_ERROR(gview_.Initialize(&graph));\n\n  // Build the information about frames in this subgraph.\n  ControlFlowInfo cf_info;\n  TF_RETURN_IF_ERROR(BuildControlFlowInfo(&graph, &cf_info));\n\n  for (auto& it : cf_info.unique_frame_names) {\n    EnsureFrameInfo(it)->nodes =\n        absl::make_unique<std::vector<const NodeItem*>>();\n  }\n  root_frame_info_ = frame_info_[\"\"].get();\n\n  pending_ids_.resize(gview_.num_nodes());\n\n  // Preprocess every node in the graph to create an instance of op\n  // kernel for each node.\n  requires_control_flow_ = false;\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    if (IsSwitch(n) || IsMerge(n) || IsEnter(n) || IsExit(n)) {\n      requires_control_flow_ = true;\n    } else if (IsRecv(n)) {\n      // A Recv node from a different device may produce dead tensors from\n      // non-local control-flow nodes.\n      //\n      // TODO(mrry): Track whether control flow was present in the\n      // pre-partitioned graph, and enable the caller (e.g.\n      // `DirectSession`) to relax this constraint.\n      string send_device;\n      string recv_device;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"send_device\", &send_device));\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"recv_device\", &recv_device));\n      if (send_device != recv_device) {\n        requires_control_flow_ = true;\n      }\n    }\n\n    const int id = n->id();\n    const string& frame_name = cf_info.frame_names[id];\n    FrameInfo* frame_info = EnsureFrameInfo(frame_name);\n\n    NodeItem* item = gview_.node(id);\n    item->node_id = id;\n\n    item->input_start = frame_info->total_inputs;\n    frame_info->total_inputs += n->num_inputs();\n\n    Status s = params_.create_kernel(n->properties(), &item->kernel);\n    if (!s.ok()) {\n      params_.delete_kernel(item->kernel);\n      item->kernel = nullptr;\n      s = AttachDef(s, *n);\n      return s;\n    }\n    CHECK(item->kernel);\n    item->kernel_is_async = (item->kernel->AsAsync() != nullptr);\n    item->is_merge = IsMerge(n);\n    item->is_any_consumer_merge_or_control_trigger = false;\n    for (const Node* consumer : n->out_nodes()) {\n      if (IsMerge(consumer) || IsControlTrigger(consumer)) {\n        item->is_any_consumer_merge_or_control_trigger = true;\n        break;\n      }\n    }\n    const Tensor* const_tensor = item->kernel->const_tensor();\n    if (const_tensor) {\n      // Hold onto a shallow copy of the constant tensor in `*this` so that the\n      // reference count does not drop to 1. This prevents the constant tensor\n      // from being forwarded, and its buffer reused.\n      const_tensors_.emplace_back(*const_tensor);\n    }\n    item->const_tensor = const_tensor;\n    item->is_noop = (item->kernel->type_string_view() == \"NoOp\");\n    item->is_enter = IsEnter(n);\n    if (item->is_enter) {\n      bool is_constant_enter;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"is_constant\", &is_constant_enter));\n      item->is_constant_enter = is_constant_enter;\n\n      string frame_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &frame_name));\n      FrameInfo* frame_info = frame_info_[frame_name].get();\n\n      int parallel_iterations;\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(n->attrs(), \"parallel_iterations\", &parallel_iterations));\n\n      if (frame_info->parallel_iterations == -1) {\n        frame_info->parallel_iterations = parallel_iterations;\n      } else if (frame_info->parallel_iterations != parallel_iterations) {\n        LOG(WARNING) << \"Loop frame \\\"\" << frame_name\n                     << \"\\\" had two different values for parallel_iterations: \"\n                     << frame_info->parallel_iterations << \" vs. \"\n                     << parallel_iterations << \".\";\n      }\n\n      if (enter_frame_info_.size() <= id) {\n        enter_frame_info_.resize(id + 1);\n      }\n      enter_frame_info_[id] = frame_info;\n    } else {\n      item->is_constant_enter = false;\n    }\n    item->is_exit = IsExit(n);\n    item->is_control_trigger = IsControlTrigger(n);\n    item->is_source = IsSource(n);\n    item->is_enter_exit_or_next_iter =\n        (IsEnter(n) || IsExit(n) || IsNextIteration(n));\n    item->is_transfer_node = IsTransferNode(n);\n    item->is_initialization_op = IsInitializationOp(n);\n    item->is_recv_or_switch = IsRecv(n) || IsSwitch(n);\n    item->is_next_iteration = IsNextIteration(n);\n    item->is_distributed_communication = IsDistributedCommunication(n);\n\n    // Compute the maximum values we'll store for this node in the\n    // pending counts data structure, and allocate a handle in\n    // that frame's pending counts data structure that has enough\n    // space to store these maximal count values.\n    size_t max_pending, max_dead;\n    GetMaxPendingCounts(n, &max_pending, &max_dead);\n    pending_ids_[id] =\n        frame_info->pending_counts_layout.CreateHandle(max_pending, max_dead);\n\n    // See if this node is a root node, and if so, add item to root_nodes_.\n    if (n->in_edges().empty()) {\n      root_nodes_.push_back(item);\n    }\n\n    // Initialize static information about the frames in the graph.\n    frame_info->nodes->push_back(item);\n    if (item->is_enter) {\n      string enter_name;\n      TF_RETURN_IF_ERROR(GetNodeAttr(n->attrs(), \"frame_name\", &enter_name));\n      EnsureFrameInfo(enter_name)->input_count++;\n    }\n\n    // Record information about whether each output of the op is used.\n    std::unique_ptr<bool[]> outputs_required(new bool[n->num_outputs()]);\n    std::fill(&outputs_required[0], &outputs_required[n->num_outputs()], false);\n    int32_t unused_outputs = n->num_outputs();\n    for (const Edge* e : n->out_edges()) {\n      if (IsSink(e->dst())) continue;\n      if (e->src_output() >= 0) {\n        if (!outputs_required[e->src_output()]) {\n          --unused_outputs;\n          outputs_required[e->src_output()] = true;\n        }\n      }\n    }\n    if (unused_outputs > 0) {\n      for (int i = 0; i < n->num_outputs(); ++i) {\n        if (!outputs_required[i]) {\n          metrics::RecordUnusedOutput(n->type_string());\n        }\n      }\n      item->outputs_required = std::move(outputs_required);\n    }\n  }\n\n  // Rewrite each `EdgeInfo::input_slot` member to refer directly to the input\n  // location.\n  for (const Node* n : graph.nodes()) {\n    if (IsSink(n)) continue;\n    const int id = n->id();\n    NodeItem* item = gview_.node(id);\n\n    for (EdgeInfo& e : item->mutable_output_edges()) {\n      const int dst_id = e.dst_id;\n      NodeItem* dst_item = gview_.node(dst_id);\n      e.input_slot += dst_item->input_start;\n    }\n  }\n\n  // Initialize PendingCounts only after pending_ids_[node.id] is initialized\n  // for all nodes.\n  InitializePending(&graph, cf_info);\n  return gview_.SetAllocAttrs(&graph, params_.device);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,6 +48,7 @@\n \n     Status s = params_.create_kernel(n->properties(), &item->kernel);\n     if (!s.ok()) {\n+      params_.delete_kernel(item->kernel);\n       item->kernel = nullptr;\n       s = AttachDef(s, *n);\n       return s;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      params_.delete_kernel(item->kernel);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-23585",
        "func_name": "tensorflow/DecodePngV2",
        "description": "Tensorflow is an Open Source Machine Learning Framework. When decoding PNG images TensorFlow can produce a memory leak if the image is invalid. After calling `png::CommonInitDecode(..., &decode)`, the `decode` value contains allocated buffers which can only be freed by calling `png::CommonFreeDecode(&decode)`. However, several error case in the function implementation invoke the `OP_REQUIRES` macro which immediately terminates the execution of the function, without allowing for the memory free to occur. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/ab51e5b813573dc9f51efa335aebcf2994125ee9",
        "commit_title": "Prevent memory leak in decoding PNG images.",
        "commit_text": " PiperOrigin-RevId: 409300653",
        "func_before": "void DecodePngV2(OpKernelContext* context, StringPiece input) {\n    int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n    png::DecodeContext decode;\n    OP_REQUIRES(\n        context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n        errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n\n    // Verify that width and height are not too large:\n    // - verify width and height don't overflow int.\n    // - width can later be multiplied by channels_ and sizeof(uint16), so\n    //   verify single dimension is not too large.\n    // - verify when width and height are multiplied together, there are a few\n    //   bits to spare as well.\n    const int width = static_cast<int>(decode.width);\n    const int height = static_cast<int>(decode.height);\n    const int64_t total_size =\n        static_cast<int64_t>(width) * static_cast<int64_t>(height);\n    if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n        width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n        height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"PNG size too large for int: \",\n                                          decode.width, \" by \", decode.height));\n    }\n\n    Tensor* output = nullptr;\n    // By the existing API, we support decoding PNG with `DecodeGif` op.\n    // We need to make sure to return 4-D shapes when using `DecodeGif`.\n    if (op_type_ == \"DecodeGif\") {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({1, height, width, decode.channels}), &output));\n    } else {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({height, width, decode.channels}), &output));\n    }\n\n    if (op_type_ == \"DecodeBmp\") {\n      // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here\n      // because currently `decode_(jpeg|png|gif)` ops can decode any one of\n      // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode\n      // anything but bmp formats. This behavior needs to be revisited. For more\n      // details, please refer to the bug.\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"Trying to decode PNG format using DecodeBmp op. Use \"\n                      \"`decode_png` or `decode_image` instead.\"));\n    } else if (op_type_ == \"DecodeAndCropJpeg\") {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                      \"detected PNG.\"));\n    }\n\n    if (data_type_ == DataType::DT_UINT8) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n              decode.channels * width * sizeof(uint8), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_UINT16) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n              decode.channels * width * sizeof(uint16), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_FLOAT) {\n      // `png::CommonFinishDecode` does not support `float`. First allocate\n      // uint16 buffer for the image and decode in uint16 (lossless). Wrap the\n      // buffer in `unique_ptr` so that we don't forget to delete the buffer.\n      std::unique_ptr<uint16[]> buffer(\n          new uint16[height * width * decode.channels]);\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                  decode.channels * width * sizeof(uint16),\n                                  &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n\n      // Convert uint16 image data to desired data type.\n      // Use eigen threadpooling to speed up the copy operation.\n      const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n      TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                  decode.channels);\n      float scale = 1. / std::numeric_limits<uint16>::max();\n      // Fill output tensor with desired dtype.\n      output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n    }\n  }",
        "func": "void DecodePngV2(OpKernelContext* context, StringPiece input) {\n    int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n    png::DecodeContext decode;\n    OP_REQUIRES(\n        context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n        errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n\n    // If we reach this point, then there is data in `decode` which must be\n    // freed by the time we end execution in this function. We cannot call\n    // `png::CommonFreeDecode()` before an `OP_REQUIRES` because if\n    // `OP_REQUIRES` constraint is satisfied then the data would be freed\n    // prematurely. Instead, let's use a `Cleanup` object.\n    auto cleanup = gtl::MakeCleanup([&decode]() {\n      std::cerr << \"Cleanup called...\\n\";\n      png::CommonFreeDecode(&decode);\n    });\n\n    // Verify that width and height are not too large:\n    // - verify width and height don't overflow int.\n    // - width can later be multiplied by channels_ and sizeof(uint16), so\n    //   verify single dimension is not too large.\n    // - verify when width and height are multiplied together, there are a few\n    //   bits to spare as well.\n    const int width = static_cast<int>(decode.width);\n    const int height = static_cast<int>(decode.height);\n    const int64_t total_size =\n        static_cast<int64_t>(width) * static_cast<int64_t>(height);\n    if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n        width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n        height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"PNG size too large for int: \",\n                                          decode.width, \" by \", decode.height));\n    }\n\n    Tensor* output = nullptr;\n    // By the existing API, we support decoding PNG with `DecodeGif` op.\n    // We need to make sure to return 4-D shapes when using `DecodeGif`.\n    if (op_type_ == \"DecodeGif\") {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({1, height, width, decode.channels}), &output));\n    } else {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({height, width, decode.channels}), &output));\n    }\n\n    if (op_type_ == \"DecodeBmp\") {\n      // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here\n      // because currently `decode_(jpeg|png|gif)` ops can decode any one of\n      // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode\n      // anything but bmp formats. This behavior needs to be revisited. For more\n      // details, please refer to the bug.\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"Trying to decode PNG format using DecodeBmp op. Use \"\n                      \"`decode_png` or `decode_image` instead.\"));\n    } else if (op_type_ == \"DecodeAndCropJpeg\") {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                      \"detected PNG.\"));\n    }\n\n    if (data_type_ == DataType::DT_UINT8) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n              decode.channels * width * sizeof(uint8), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_UINT16) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n              decode.channels * width * sizeof(uint16), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_FLOAT) {\n      // `png::CommonFinishDecode` does not support `float`. First allocate\n      // uint16 buffer for the image and decode in uint16 (lossless). Wrap the\n      // buffer in `unique_ptr` so that we don't forget to delete the buffer.\n      std::unique_ptr<uint16[]> buffer(\n          new uint16[height * width * decode.channels]);\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                  decode.channels * width * sizeof(uint16),\n                                  &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n\n      // Convert uint16 image data to desired data type.\n      // Use eigen threadpooling to speed up the copy operation.\n      const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n      TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                  decode.channels);\n      float scale = 1. / std::numeric_limits<uint16>::max();\n      // Fill output tensor with desired dtype.\n      output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,16 @@\n     OP_REQUIRES(\n         context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n         errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n+\n+    // If we reach this point, then there is data in `decode` which must be\n+    // freed by the time we end execution in this function. We cannot call\n+    // `png::CommonFreeDecode()` before an `OP_REQUIRES` because if\n+    // `OP_REQUIRES` constraint is satisfied then the data would be freed\n+    // prematurely. Instead, let's use a `Cleanup` object.\n+    auto cleanup = gtl::MakeCleanup([&decode]() {\n+      std::cerr << \"Cleanup called...\\n\";\n+      png::CommonFreeDecode(&decode);\n+    });\n \n     // Verify that width and height are not too large:\n     // - verify width and height don't overflow int.",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    // If we reach this point, then there is data in `decode` which must be",
                "    // freed by the time we end execution in this function. We cannot call",
                "    // `png::CommonFreeDecode()` before an `OP_REQUIRES` because if",
                "    // `OP_REQUIRES` constraint is satisfied then the data would be freed",
                "    // prematurely. Instead, let's use a `Cleanup` object.",
                "    auto cleanup = gtl::MakeCleanup([&decode]() {",
                "      std::cerr << \"Cleanup called...\\n\";",
                "      png::CommonFreeDecode(&decode);",
                "    });"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24959",
        "func_name": "torvalds/linux/yam_siocdevprivate",
        "description": "An issue was discovered in the Linux kernel before 5.16.5. There is a memory leak in yam_siocdevprivate in drivers/net/hamradio/yam.c.",
        "git_url": "https://github.com/torvalds/linux/commit/29eb31542787e1019208a2e1047bb7c76c069536",
        "commit_title": "yam: fix a memory leak in yam_siocdevprivate()",
        "commit_text": " ym needs to be free when ym->cmd != SIOCYAMSMCS. ",
        "func_before": "static int yam_siocdevprivate(struct net_device *dev, struct ifreq *ifr, void __user *data, int cmd)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tstruct yamdrv_ioctl_cfg yi;\n\tstruct yamdrv_ioctl_mcs *ym;\n\tint ioctl_cmd;\n\n\tif (copy_from_user(&ioctl_cmd, data, sizeof(int)))\n\t\treturn -EFAULT;\n\n\tif (yp->magic != YAM_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -EINVAL;\n\n\tswitch (ioctl_cmd) {\n\n\tcase SIOCYAMRESERVED:\n\t\treturn -EINVAL;\t\t\t/* unused */\n\n\tcase SIOCYAMSMCS:\n\t\tif (netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tym = memdup_user(data, sizeof(struct yamdrv_ioctl_mcs));\n\t\tif (IS_ERR(ym))\n\t\t\treturn PTR_ERR(ym);\n\t\tif (ym->cmd != SIOCYAMSMCS)\n\t\t\treturn -EINVAL;\n\t\tif (ym->bitrate > YAM_MAXBITRATE) {\n\t\t\tkfree(ym);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* setting predef as 0 for loading userdefined mcs data */\n\t\tadd_mcs(ym->bits, ym->bitrate, 0);\n\t\tkfree(ym);\n\t\tbreak;\n\n\tcase SIOCYAMSCFG:\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&yi, data, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\treturn -EFAULT;\n\n\t\tif (yi.cmd != SIOCYAMSCFG)\n\t\t\treturn -EINVAL;\n\t\tif ((yi.cfg.mask & YAM_IOBASE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_IRQ) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_BITRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_BAUDRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\n\t\tif (yi.cfg.mask & YAM_IOBASE) {\n\t\t\typ->iobase = yi.cfg.iobase;\n\t\t\tdev->base_addr = yi.cfg.iobase;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_IRQ) {\n\t\t\tif (yi.cfg.irq > 15)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->irq = yi.cfg.irq;\n\t\t\tdev->irq = yi.cfg.irq;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BITRATE) {\n\t\t\tif (yi.cfg.bitrate > YAM_MAXBITRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->bitrate = yi.cfg.bitrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BAUDRATE) {\n\t\t\tif (yi.cfg.baudrate > YAM_MAXBAUDRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->baudrate = yi.cfg.baudrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_MODE) {\n\t\t\tif (yi.cfg.mode > YAM_MAXMODE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->dupmode = yi.cfg.mode;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_HOLDDLY) {\n\t\t\tif (yi.cfg.holddly > YAM_MAXHOLDDLY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->holdd = yi.cfg.holddly;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXDELAY) {\n\t\t\tif (yi.cfg.txdelay > YAM_MAXTXDELAY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txd = yi.cfg.txdelay;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXTAIL) {\n\t\t\tif (yi.cfg.txtail > YAM_MAXTXTAIL)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txtail = yi.cfg.txtail;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_PERSIST) {\n\t\t\tif (yi.cfg.persist > YAM_MAXPERSIST)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->pers = yi.cfg.persist;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_SLOTTIME) {\n\t\t\tif (yi.cfg.slottime > YAM_MAXSLOTTIME)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->slot = yi.cfg.slottime;\n\t\t\typ->slotcnt = yp->slot / 10;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCYAMGCFG:\n\t\tmemset(&yi, 0, sizeof(yi));\n\t\tyi.cfg.mask = 0xffffffff;\n\t\tyi.cfg.iobase = yp->iobase;\n\t\tyi.cfg.irq = yp->irq;\n\t\tyi.cfg.bitrate = yp->bitrate;\n\t\tyi.cfg.baudrate = yp->baudrate;\n\t\tyi.cfg.mode = yp->dupmode;\n\t\tyi.cfg.txdelay = yp->txd;\n\t\tyi.cfg.holddly = yp->holdd;\n\t\tyi.cfg.txtail = yp->txtail;\n\t\tyi.cfg.persist = yp->pers;\n\t\tyi.cfg.slottime = yp->slot;\n\t\tif (copy_to_user(data, &yi, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}",
        "func": "static int yam_siocdevprivate(struct net_device *dev, struct ifreq *ifr, void __user *data, int cmd)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tstruct yamdrv_ioctl_cfg yi;\n\tstruct yamdrv_ioctl_mcs *ym;\n\tint ioctl_cmd;\n\n\tif (copy_from_user(&ioctl_cmd, data, sizeof(int)))\n\t\treturn -EFAULT;\n\n\tif (yp->magic != YAM_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -EINVAL;\n\n\tswitch (ioctl_cmd) {\n\n\tcase SIOCYAMRESERVED:\n\t\treturn -EINVAL;\t\t\t/* unused */\n\n\tcase SIOCYAMSMCS:\n\t\tif (netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tym = memdup_user(data, sizeof(struct yamdrv_ioctl_mcs));\n\t\tif (IS_ERR(ym))\n\t\t\treturn PTR_ERR(ym);\n\t\tif (ym->cmd != SIOCYAMSMCS || ym->bitrate > YAM_MAXBITRATE) {\n\t\t\tkfree(ym);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* setting predef as 0 for loading userdefined mcs data */\n\t\tadd_mcs(ym->bits, ym->bitrate, 0);\n\t\tkfree(ym);\n\t\tbreak;\n\n\tcase SIOCYAMSCFG:\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&yi, data, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\treturn -EFAULT;\n\n\t\tif (yi.cmd != SIOCYAMSCFG)\n\t\t\treturn -EINVAL;\n\t\tif ((yi.cfg.mask & YAM_IOBASE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_IRQ) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_BITRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\t\tif ((yi.cfg.mask & YAM_BAUDRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t/* Cannot change this parameter when up */\n\n\t\tif (yi.cfg.mask & YAM_IOBASE) {\n\t\t\typ->iobase = yi.cfg.iobase;\n\t\t\tdev->base_addr = yi.cfg.iobase;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_IRQ) {\n\t\t\tif (yi.cfg.irq > 15)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->irq = yi.cfg.irq;\n\t\t\tdev->irq = yi.cfg.irq;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BITRATE) {\n\t\t\tif (yi.cfg.bitrate > YAM_MAXBITRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->bitrate = yi.cfg.bitrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BAUDRATE) {\n\t\t\tif (yi.cfg.baudrate > YAM_MAXBAUDRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->baudrate = yi.cfg.baudrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_MODE) {\n\t\t\tif (yi.cfg.mode > YAM_MAXMODE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->dupmode = yi.cfg.mode;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_HOLDDLY) {\n\t\t\tif (yi.cfg.holddly > YAM_MAXHOLDDLY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->holdd = yi.cfg.holddly;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXDELAY) {\n\t\t\tif (yi.cfg.txdelay > YAM_MAXTXDELAY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txd = yi.cfg.txdelay;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXTAIL) {\n\t\t\tif (yi.cfg.txtail > YAM_MAXTXTAIL)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txtail = yi.cfg.txtail;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_PERSIST) {\n\t\t\tif (yi.cfg.persist > YAM_MAXPERSIST)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->pers = yi.cfg.persist;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_SLOTTIME) {\n\t\t\tif (yi.cfg.slottime > YAM_MAXSLOTTIME)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->slot = yi.cfg.slottime;\n\t\t\typ->slotcnt = yp->slot / 10;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCYAMGCFG:\n\t\tmemset(&yi, 0, sizeof(yi));\n\t\tyi.cfg.mask = 0xffffffff;\n\t\tyi.cfg.iobase = yp->iobase;\n\t\tyi.cfg.irq = yp->irq;\n\t\tyi.cfg.bitrate = yp->bitrate;\n\t\tyi.cfg.baudrate = yp->baudrate;\n\t\tyi.cfg.mode = yp->dupmode;\n\t\tyi.cfg.txdelay = yp->txd;\n\t\tyi.cfg.holddly = yp->holdd;\n\t\tyi.cfg.txtail = yp->txtail;\n\t\tyi.cfg.persist = yp->pers;\n\t\tyi.cfg.slottime = yp->slot;\n\t\tif (copy_to_user(data, &yi, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,9 +28,7 @@\n \t\tym = memdup_user(data, sizeof(struct yamdrv_ioctl_mcs));\n \t\tif (IS_ERR(ym))\n \t\t\treturn PTR_ERR(ym);\n-\t\tif (ym->cmd != SIOCYAMSMCS)\n-\t\t\treturn -EINVAL;\n-\t\tif (ym->bitrate > YAM_MAXBITRATE) {\n+\t\tif (ym->cmd != SIOCYAMSMCS || ym->bitrate > YAM_MAXBITRATE) {\n \t\t\tkfree(ym);\n \t\t\treturn -EINVAL;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (ym->cmd != SIOCYAMSMCS)",
                "\t\t\treturn -EINVAL;",
                "\t\tif (ym->bitrate > YAM_MAXBITRATE) {"
            ],
            "added_lines": [
                "\t\tif (ym->cmd != SIOCYAMSMCS || ym->bitrate > YAM_MAXBITRATE) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-35858",
        "func_name": "Samsung/mTower/TEE_PopulateTransientObject",
        "description": "The TEE_PopulateTransientObject and __utee_from_attr functions in Samsung mTower 0.3.0 allow a trusted application to trigger a memory overwrite, denial of service, and information disclosure by invoking the function TEE_PopulateTransientObject with a large number in the parameter attrCount.",
        "git_url": "https://github.com/Samsung/mTower/commit/6b325fd26bf06bee17abd3fd3fd4b0aa0e74e7b2",
        "commit_title": "Fixed CVE-2022-35858",
        "commit_text": "",
        "func_before": "TEE_Result TEE_PopulateTransientObject(TEE_ObjectHandle object,\n\t\t\t\t       const TEE_Attribute *attrs,\n\t\t\t\t       uint32_t attrCount)\n{\n\tTEE_Result res;\n\tTEE_ObjectInfo info;\n\tstruct utee_attribute ua[attrCount];\n\n\t__utee_check_attr_in_annotation(attrs, attrCount);\n\n\tres = utee_cryp_obj_get_info((unsigned long)object, &info);\n\tif (res != TEE_SUCCESS)\n\t\tTEE_Panic(res);\n\n\t/* Must be a transient object */\n\tif ((info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\tTEE_Panic(0);\n\n\t/* Must not be initialized already */\n\tif ((info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\tTEE_Panic(0);\n\n\t__utee_from_attr(ua, attrs, attrCount);\n\tres = utee_cryp_obj_populate((unsigned long)object, ua, attrCount);\n\tif (res != TEE_SUCCESS && res != TEE_ERROR_BAD_PARAMETERS)\n\t\tTEE_Panic(res);\n\treturn res;\n}",
        "func": "TEE_Result TEE_PopulateTransientObject(TEE_ObjectHandle object,\n\t\t\t\t       const TEE_Attribute *attrs,\n\t\t\t\t       uint32_t attrCount)\n{\n\tTEE_Result res;\n\tTEE_ObjectInfo info;\n\n\tif (attrCount > 4) {\n\t\tTEE_Panic(TEE_ERROR_BAD_PARAMETERS);\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\tstruct utee_attribute ua[attrCount];\n\n\t__utee_check_attr_in_annotation(attrs, attrCount);\n\n\tres = utee_cryp_obj_get_info((unsigned long)object, &info);\n\tif (res != TEE_SUCCESS)\n\t\tTEE_Panic(res);\n\n\t/* Must be a transient object */\n\tif ((info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\tTEE_Panic(0);\n\n\t/* Must not be initialized already */\n\tif ((info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\tTEE_Panic(0);\n\n\t__utee_from_attr(ua, attrs, attrCount);\n\tres = utee_cryp_obj_populate((unsigned long)object, ua, attrCount);\n\tif (res != TEE_SUCCESS && res != TEE_ERROR_BAD_PARAMETERS)\n\t\tTEE_Panic(res);\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,11 @@\n {\n \tTEE_Result res;\n \tTEE_ObjectInfo info;\n+\n+\tif (attrCount > 4) {\n+\t\tTEE_Panic(TEE_ERROR_BAD_PARAMETERS);\n+\t\treturn TEE_ERROR_BAD_PARAMETERS;\n+\t}\n \tstruct utee_attribute ua[attrCount];\n \n \t__utee_check_attr_in_annotation(attrs, attrCount);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (attrCount > 4) {",
                "\t\tTEE_Panic(TEE_ERROR_BAD_PARAMETERS);",
                "\t\treturn TEE_ERROR_BAD_PARAMETERS;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3736",
        "func_name": "torvalds/linux/mbochs_dev_init",
        "description": "A flaw was found in the Linux kernel. A memory leak problem was found in mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated devices. This flaw could allow a local attacker to leak internal kernel information.",
        "git_url": "https://github.com/torvalds/linux/commit/de5494af4815a4c9328536c72741229b7de88e7f",
        "commit_title": "vfio/mbochs: Fix missing error unwind of mbochs_used_mbytes",
        "commit_text": " Convert mbochs to use an atomic scheme for this like mtty was changed into. The atomic fixes various race conditions with probing. Add the missing error unwind. Also add the missing kfree of mdev_state->pages.  Co-developed-by: Alex Williamson <alex.williamson@redhat.com> Link: https://lore.kernel.org/r/2-v4-9ea22c5e6afb+1adf-vfio_reflck_jgg@nvidia.com",
        "func_before": "static int __init mbochs_dev_init(void)\n{\n\tint ret = 0;\n\n\tret = alloc_chrdev_region(&mbochs_devt, 0, MINORMASK + 1, MBOCHS_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Error: failed to register mbochs_dev, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcdev_init(&mbochs_cdev, &vd_fops);\n\tcdev_add(&mbochs_cdev, mbochs_devt, MINORMASK + 1);\n\tpr_info(\"%s: major %d\\n\", __func__, MAJOR(mbochs_devt));\n\n\tret = mdev_register_driver(&mbochs_driver);\n\tif (ret)\n\t\tgoto err_cdev;\n\n\tmbochs_class = class_create(THIS_MODULE, MBOCHS_CLASS_NAME);\n\tif (IS_ERR(mbochs_class)) {\n\t\tpr_err(\"Error: failed to register mbochs_dev class\\n\");\n\t\tret = PTR_ERR(mbochs_class);\n\t\tgoto err_driver;\n\t}\n\tmbochs_dev.class = mbochs_class;\n\tmbochs_dev.release = mbochs_device_release;\n\tdev_set_name(&mbochs_dev, \"%s\", MBOCHS_NAME);\n\n\tret = device_register(&mbochs_dev);\n\tif (ret)\n\t\tgoto err_class;\n\n\tret = mdev_register_device(&mbochs_dev, &mdev_fops);\n\tif (ret)\n\t\tgoto err_device;\n\n\treturn 0;\n\nerr_device:\n\tdevice_unregister(&mbochs_dev);\nerr_class:\n\tclass_destroy(mbochs_class);\nerr_driver:\n\tmdev_unregister_driver(&mbochs_driver);\nerr_cdev:\n\tcdev_del(&mbochs_cdev);\n\tunregister_chrdev_region(mbochs_devt, MINORMASK + 1);\n\treturn ret;\n}",
        "func": "static int __init mbochs_dev_init(void)\n{\n\tint ret = 0;\n\n\tatomic_set(&mbochs_avail_mbytes, max_mbytes);\n\n\tret = alloc_chrdev_region(&mbochs_devt, 0, MINORMASK + 1, MBOCHS_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Error: failed to register mbochs_dev, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcdev_init(&mbochs_cdev, &vd_fops);\n\tcdev_add(&mbochs_cdev, mbochs_devt, MINORMASK + 1);\n\tpr_info(\"%s: major %d\\n\", __func__, MAJOR(mbochs_devt));\n\n\tret = mdev_register_driver(&mbochs_driver);\n\tif (ret)\n\t\tgoto err_cdev;\n\n\tmbochs_class = class_create(THIS_MODULE, MBOCHS_CLASS_NAME);\n\tif (IS_ERR(mbochs_class)) {\n\t\tpr_err(\"Error: failed to register mbochs_dev class\\n\");\n\t\tret = PTR_ERR(mbochs_class);\n\t\tgoto err_driver;\n\t}\n\tmbochs_dev.class = mbochs_class;\n\tmbochs_dev.release = mbochs_device_release;\n\tdev_set_name(&mbochs_dev, \"%s\", MBOCHS_NAME);\n\n\tret = device_register(&mbochs_dev);\n\tif (ret)\n\t\tgoto err_class;\n\n\tret = mdev_register_device(&mbochs_dev, &mdev_fops);\n\tif (ret)\n\t\tgoto err_device;\n\n\treturn 0;\n\nerr_device:\n\tdevice_unregister(&mbochs_dev);\nerr_class:\n\tclass_destroy(mbochs_class);\nerr_driver:\n\tmdev_unregister_driver(&mbochs_driver);\nerr_cdev:\n\tcdev_del(&mbochs_cdev);\n\tunregister_chrdev_region(mbochs_devt, MINORMASK + 1);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n static int __init mbochs_dev_init(void)\n {\n \tint ret = 0;\n+\n+\tatomic_set(&mbochs_avail_mbytes, max_mbytes);\n \n \tret = alloc_chrdev_region(&mbochs_devt, 0, MINORMASK + 1, MBOCHS_NAME);\n \tif (ret < 0) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tatomic_set(&mbochs_avail_mbytes, max_mbytes);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3736",
        "func_name": "torvalds/linux/mbochs_probe",
        "description": "A flaw was found in the Linux kernel. A memory leak problem was found in mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated devices. This flaw could allow a local attacker to leak internal kernel information.",
        "git_url": "https://github.com/torvalds/linux/commit/de5494af4815a4c9328536c72741229b7de88e7f",
        "commit_title": "vfio/mbochs: Fix missing error unwind of mbochs_used_mbytes",
        "commit_text": " Convert mbochs to use an atomic scheme for this like mtty was changed into. The atomic fixes various race conditions with probing. Add the missing error unwind. Also add the missing kfree of mdev_state->pages.  Co-developed-by: Alex Williamson <alex.williamson@redhat.com> Link: https://lore.kernel.org/r/2-v4-9ea22c5e6afb+1adf-vfio_reflck_jgg@nvidia.com",
        "func_before": "static int mbochs_probe(struct mdev_device *mdev)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\n\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n\t\treturn -ENOMEM;\n\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\treturn -ENOMEM;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\n\tmbochs_used_mbytes += type->mbytes;\n\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\n\nerr_mem:\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n\treturn ret;\n}",
        "func": "static int mbochs_probe(struct mdev_device *mdev)\n{\n\tint avail_mbytes = atomic_read(&mbochs_avail_mbytes);\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\n\tdo {\n\t\tif (avail_mbytes < type->mbytes)\n\t\t\treturn -ENOSPC;\n\t} while (!atomic_try_cmpxchg(&mbochs_avail_mbytes, &avail_mbytes,\n\t\t\t\t     avail_mbytes - type->mbytes));\n\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\tgoto err_avail;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\nerr_mem:\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\nerr_avail:\n\tatomic_add(type->mbytes, &mbochs_avail_mbytes);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,17 +1,21 @@\n static int mbochs_probe(struct mdev_device *mdev)\n {\n+\tint avail_mbytes = atomic_read(&mbochs_avail_mbytes);\n \tconst struct mbochs_type *type =\n \t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n \tstruct device *dev = mdev_dev(mdev);\n \tstruct mdev_state *mdev_state;\n \tint ret = -ENOMEM;\n \n-\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n-\t\treturn -ENOMEM;\n+\tdo {\n+\t\tif (avail_mbytes < type->mbytes)\n+\t\t\treturn -ENOSPC;\n+\t} while (!atomic_try_cmpxchg(&mbochs_avail_mbytes, &avail_mbytes,\n+\t\t\t\t     avail_mbytes - type->mbytes));\n \n \tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n \tif (mdev_state == NULL)\n-\t\treturn -ENOMEM;\n+\t\tgoto err_avail;\n \tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n \n \tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n@@ -42,16 +46,16 @@\n \tmbochs_create_config_space(mdev_state);\n \tmbochs_reset(mdev_state);\n \n-\tmbochs_used_mbytes += type->mbytes;\n-\n \tret = vfio_register_group_dev(&mdev_state->vdev);\n \tif (ret)\n \t\tgoto err_mem;\n \tdev_set_drvdata(&mdev->dev, mdev_state);\n \treturn 0;\n-\n err_mem:\n+\tkfree(mdev_state->pages);\n \tkfree(mdev_state->vconfig);\n \tkfree(mdev_state);\n+err_avail:\n+\tatomic_add(type->mbytes, &mbochs_avail_mbytes);\n \treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)",
                "\t\treturn -ENOMEM;",
                "\t\treturn -ENOMEM;",
                "\tmbochs_used_mbytes += type->mbytes;",
                "",
                ""
            ],
            "added_lines": [
                "\tint avail_mbytes = atomic_read(&mbochs_avail_mbytes);",
                "\tdo {",
                "\t\tif (avail_mbytes < type->mbytes)",
                "\t\t\treturn -ENOSPC;",
                "\t} while (!atomic_try_cmpxchg(&mbochs_avail_mbytes, &avail_mbytes,",
                "\t\t\t\t     avail_mbytes - type->mbytes));",
                "\t\tgoto err_avail;",
                "\tkfree(mdev_state->pages);",
                "err_avail:",
                "\tatomic_add(type->mbytes, &mbochs_avail_mbytes);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3736",
        "func_name": "torvalds/linux/mbochs_remove",
        "description": "A flaw was found in the Linux kernel. A memory leak problem was found in mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated devices. This flaw could allow a local attacker to leak internal kernel information.",
        "git_url": "https://github.com/torvalds/linux/commit/de5494af4815a4c9328536c72741229b7de88e7f",
        "commit_title": "vfio/mbochs: Fix missing error unwind of mbochs_used_mbytes",
        "commit_text": " Convert mbochs to use an atomic scheme for this like mtty was changed into. The atomic fixes various race conditions with probing. Add the missing error unwind. Also add the missing kfree of mdev_state->pages.  Co-developed-by: Alex Williamson <alex.williamson@redhat.com> Link: https://lore.kernel.org/r/2-v4-9ea22c5e6afb+1adf-vfio_reflck_jgg@nvidia.com",
        "func_before": "static void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\n\tmbochs_used_mbytes -= mdev_state->type->mbytes;\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}",
        "func": "static void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tatomic_add(mdev_state->type->mbytes, &mbochs_avail_mbytes);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,8 @@\n {\n \tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n \n-\tmbochs_used_mbytes -= mdev_state->type->mbytes;\n \tvfio_unregister_group_dev(&mdev_state->vdev);\n+\tatomic_add(mdev_state->type->mbytes, &mbochs_avail_mbytes);\n \tkfree(mdev_state->pages);\n \tkfree(mdev_state->vconfig);\n \tkfree(mdev_state);",
        "diff_line_info": {
            "deleted_lines": [
                "\tmbochs_used_mbytes -= mdev_state->type->mbytes;"
            ],
            "added_lines": [
                "\tatomic_add(mdev_state->type->mbytes, &mbochs_avail_mbytes);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3736",
        "func_name": "torvalds/linux/available_instances_show",
        "description": "A flaw was found in the Linux kernel. A memory leak problem was found in mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated devices. This flaw could allow a local attacker to leak internal kernel information.",
        "git_url": "https://github.com/torvalds/linux/commit/de5494af4815a4c9328536c72741229b7de88e7f",
        "commit_title": "vfio/mbochs: Fix missing error unwind of mbochs_used_mbytes",
        "commit_text": " Convert mbochs to use an atomic scheme for this like mtty was changed into. The atomic fixes various race conditions with probing. Add the missing error unwind. Also add the missing kfree of mdev_state->pages.  Co-developed-by: Alex Williamson <alex.williamson@redhat.com> Link: https://lore.kernel.org/r/2-v4-9ea22c5e6afb+1adf-vfio_reflck_jgg@nvidia.com",
        "func_before": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\n\treturn sprintf(buf, \"%d\\n\", count);\n}",
        "func": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = atomic_read(&mbochs_avail_mbytes) / type->mbytes;\n\n\treturn sprintf(buf, \"%d\\n\", count);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n {\n \tconst struct mbochs_type *type =\n \t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n-\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n+\tint count = atomic_read(&mbochs_avail_mbytes) / type->mbytes;\n \n \treturn sprintf(buf, \"%d\\n\", count);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;"
            ],
            "added_lines": [
                "\tint count = atomic_read(&mbochs_avail_mbytes) / type->mbytes;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3905",
        "func_name": "openvswitch/ovs/ipf_extract_frags_from_batch",
        "description": "A memory leak was found in Open vSwitch (OVS) during userspace IP fragmentation processing. An attacker could use this flaw to potentially exhaust available memory by keeping sending packet fragments.",
        "git_url": "https://github.com/openvswitch/ovs/commit/803ed12e31b0377c37d7aa8c94b3b92f2081e349",
        "commit_title": "ipf: release unhandled packets from the batch",
        "commit_text": " Since 640d4db788ed (\"ipf: Fix a use-after-free error, ...\") the ipf framework unconditionally allocates a new dp_packet to track individual fragments.  This prevents a use-after-free.  However, an additional issue was present - even when the packet buffer is cloned, if the ip fragment handling code keeps it, the original buffer is leaked during the refill loop.  Even in the original processing code, the hardcoded dnsteal branches would always leak a packet buffer from the refill loop.  This can be confirmed with valgrind:  ==717566== 16,672 (4,480 direct, 12,192 indirect) bytes in 8 blocks are definitely lost in loss record 390 of 390 ==717566==    at 0x484086F: malloc (vg_replace_malloc.c:380) ==717566==    by 0x537BFD: xmalloc__ (util.c:137) ==717566==    by 0x537BFD: xmalloc (util.c:172) ==717566==    by 0x46DDD4: dp_packet_new (dp-packet.c:153) ==717566==    by 0x46DDD4: dp_packet_new_with_headroom (dp-packet.c:163) ==717566==    by 0x550AA6: netdev_linux_batch_rxq_recv_sock.constprop.0 (netdev-linux.c:1262) ==717566==    by 0x5512AF: netdev_linux_rxq_recv (netdev-linux.c:1511) ==717566==    by 0x4AB7E0: netdev_rxq_recv (netdev.c:727) ==717566==    by 0x47F00D: dp_netdev_process_rxq_port (dpif-netdev.c:4699) ==717566==    by 0x47FD13: dpif_netdev_run (dpif-netdev.c:5957) ==717566==    by 0x4331D2: type_run (ofproto-dpif.c:370) ==717566==    by 0x41DFD8: ofproto_type_run (ofproto.c:1768) ==717566==    by 0x40A7FB: bridge_run__ (bridge.c:3245) ==717566==    by 0x411269: bridge_run (bridge.c:3310) ==717566==    by 0x406E6C: main (ovs-vswitchd.c:127)  The fix is to delete the original packet when it isn't able to be reinserted into the packet batch.  Subsequent valgrind runs show that the packets are not leaked from the batch any longer.  Reported-at: https://github.com/openvswitch/ovs-issues/issues/226",
        "func_before": "static void\nipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}",
        "func": "static void\nipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,8 @@\n             ovs_mutex_lock(&ipf->ipf_lock);\n             if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                 dp_packet_batch_refill(pb, pkt, pb_idx);\n+            } else {\n+                dp_packet_delete(pkt);\n             }\n             ovs_mutex_unlock(&ipf->ipf_lock);\n         } else {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            } else {",
                "                dp_packet_delete(pkt);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42523",
        "func_name": "hughsie/colord/cd_device_db_load",
        "description": "There are two Information Disclosure vulnerabilities in colord, and they lie in colord/src/cd-device-db.c and colord/src/cd-profile-db.c separately. They exist because the 'err_msg' of 'sqlite3_exec' is not releasing after use, while libxml2 emphasizes that the caller needs to release it.",
        "git_url": "https://github.com/hughsie/colord/commit/adf41f36cf7214d7d6fa8d528b74eba47c377405",
        "commit_title": "Fix a small memory leak in sqlite3_exec()",
        "commit_text": " Fixes https://github.com/hughsie/colord/issues/110",
        "func_before": "gboolean  \ncd_device_db_load (CdDeviceDb *ddb,\n\t\t    const gchar *filename,\n\t\t    GError  **error)\n{\n\tCdDeviceDbPrivate *priv = GET_PRIVATE (ddb);\n\tconst gchar *statement;\n\tgchar *error_msg = NULL;\n\tgint rc;\n\tg_autofree gchar *path = NULL;\n\n\tg_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);\n\tg_return_val_if_fail (priv->db == NULL, FALSE);\n\n\t/* ensure the path exists */\n\tpath = g_path_get_dirname (filename);\n\tif (!cd_main_mkdir_with_parents (path, error))\n\t\treturn FALSE;\n\n\tg_debug (\"CdDeviceDb: trying to open database '%s'\", filename);\n\tg_info (\"Using device database file %s\", filename);\n\trc = sqlite3_open (filename, &priv->db);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"Can't open database: %s\\n\",\n\t\t\t     sqlite3_errmsg (priv->db));\n\t\tsqlite3_close (priv->db);\n\t\treturn FALSE;\n\t}\n\n\t/* we don't need to keep doing fsync */\n\tsqlite3_exec (priv->db, \"PRAGMA synchronous=OFF\",\n\t\t      NULL, NULL, NULL);\n\n\t/* check devices */\n\trc = sqlite3_exec (priv->db, \"SELECT * FROM devices LIMIT 1\",\n\t\t\t   NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_debug (\"CdDeviceDb: creating table to repair: %s\", error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tstatement = \"CREATE TABLE devices (\"\n\t\t\t    \"device_id TEXT PRIMARY KEY,\"\n\t\t\t    \"device TEXT);\";\n\t\tsqlite3_exec (priv->db, statement, NULL, NULL, NULL);\n\t}\n\n\t/* check properties version 2 */\n\trc = sqlite3_exec (priv->db, \"SELECT * FROM properties_v2 LIMIT 1\",\n\t\t\t   NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tstatement = \"CREATE TABLE properties_v2 (\"\n\t\t\t    \"device_id TEXT,\"\n\t\t\t    \"property TEXT,\"\n\t\t\t    \"value TEXT,\"\n\t\t\t    \"PRIMARY KEY (device_id, property));\";\n\t\tsqlite3_exec (priv->db, statement, NULL, NULL, NULL);\n\t}\n\treturn TRUE;\n}",
        "func": "gboolean  \ncd_device_db_load (CdDeviceDb *ddb,\n\t\t    const gchar *filename,\n\t\t    GError  **error)\n{\n\tCdDeviceDbPrivate *priv = GET_PRIVATE (ddb);\n\tconst gchar *statement;\n\tgchar *error_msg = NULL;\n\tgint rc;\n\tg_autofree gchar *path = NULL;\n\n\tg_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);\n\tg_return_val_if_fail (priv->db == NULL, FALSE);\n\n\t/* ensure the path exists */\n\tpath = g_path_get_dirname (filename);\n\tif (!cd_main_mkdir_with_parents (path, error))\n\t\treturn FALSE;\n\n\tg_debug (\"CdDeviceDb: trying to open database '%s'\", filename);\n\tg_info (\"Using device database file %s\", filename);\n\trc = sqlite3_open (filename, &priv->db);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"Can't open database: %s\\n\",\n\t\t\t     sqlite3_errmsg (priv->db));\n\t\tsqlite3_close (priv->db);\n\t\treturn FALSE;\n\t}\n\n\t/* we don't need to keep doing fsync */\n\tsqlite3_exec (priv->db, \"PRAGMA synchronous=OFF\",\n\t\t      NULL, NULL, NULL);\n\n\t/* check devices */\n\trc = sqlite3_exec (priv->db, \"SELECT * FROM devices LIMIT 1\",\n\t\t\t   NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_debug (\"CdDeviceDb: creating table to repair: %s\", error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tstatement = \"CREATE TABLE devices (\"\n\t\t\t    \"device_id TEXT PRIMARY KEY,\"\n\t\t\t    \"device TEXT);\";\n\t\tsqlite3_exec (priv->db, statement, NULL, NULL, NULL);\n\t}\n\n\t/* check properties version 2 */\n\trc = sqlite3_exec (priv->db, \"SELECT * FROM properties_v2 LIMIT 1\",\n\t\t\t   NULL, NULL, NULL);\n\tif (rc != SQLITE_OK) {\n\t\tstatement = \"CREATE TABLE properties_v2 (\"\n\t\t\t    \"device_id TEXT,\"\n\t\t\t    \"property TEXT,\"\n\t\t\t    \"value TEXT,\"\n\t\t\t    \"PRIMARY KEY (device_id, property));\";\n\t\tsqlite3_exec (priv->db, statement, NULL, NULL, NULL);\n\t}\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,7 +48,7 @@\n \n \t/* check properties version 2 */\n \trc = sqlite3_exec (priv->db, \"SELECT * FROM properties_v2 LIMIT 1\",\n-\t\t\t   NULL, NULL, &error_msg);\n+\t\t\t   NULL, NULL, NULL);\n \tif (rc != SQLITE_OK) {\n \t\tstatement = \"CREATE TABLE properties_v2 (\"\n \t\t\t    \"device_id TEXT,\"",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t   NULL, NULL, &error_msg);"
            ],
            "added_lines": [
                "\t\t\t   NULL, NULL, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2963",
        "func_name": "jasper-software/jasper/cmdopts_parse",
        "description": "A vulnerability found in jasper. This security vulnerability happens because of a memory leak bug in function cmdopts_parse that can cause a crash or segmentation fault.",
        "git_url": "https://github.com/jasper-software/jasper/commit/d99636fad60629785efd1ef72da772a8ef68f54c",
        "commit_title": "fix memory leaks in function cmdopts_parse",
        "commit_text": "",
        "func_before": "cmdopts_t *cmdopts_parse(int argc, char **argv)\n{\n\tenum {\n\t\tCMDOPT_HELP = 0,\n\t\tCMDOPT_VERBOSE,\n\t\tCMDOPT_QUIET,\n\t\tCMDOPT_INFILE,\n\t\tCMDOPT_INFMT,\n\t\tCMDOPT_INOPT,\n\t\tCMDOPT_OUTFILE,\n\t\tCMDOPT_OUTFMT,\n\t\tCMDOPT_OUTOPT,\n\t\tCMDOPT_VERSION,\n\t\tCMDOPT_DEBUG,\n\t\tCMDOPT_CMPTNO,\n\t\tCMDOPT_SRGB,\n\t\tCMDOPT_MAXMEM,\n\t\tCMDOPT_LIST_ENABLED_CODECS,\n\t\tCMDOPT_LIST_ALL_CODECS,\n\t\tCMDOPT_ENABLE_FORMAT,\n\t\tCMDOPT_ENABLE_ALL_FORMATS,\n\t};\n\n\tstatic const jas_opt_t cmdoptions[] = {\n\t\t{CMDOPT_HELP, \"help\", 0},\n\t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n\t\t{CMDOPT_QUIET, \"quiet\", 0},\n\t\t{CMDOPT_QUIET, \"q\", 0},\n\t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n\t\t{CMDOPT_VERSION, \"version\", 0},\n\t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n\t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n\t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n\t\t{CMDOPT_SRGB, \"S\", 0},\n\t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n\t\t{CMDOPT_LIST_ENABLED_CODECS, \"list-enabled-formats\", 0},\n\t\t{CMDOPT_LIST_ALL_CODECS, \"list-all-formats\", 0},\n\t\t{CMDOPT_ENABLE_FORMAT, \"enable-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_ENABLE_ALL_FORMATS, \"enable-all-formats\", 0},\n\t\t{-1, 0, 0}\n\t};\n\n\tcmdopts_t *cmdopts;\n\tint c;\n\n\tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n\t\tfprintf(stderr, \"error: insufficient memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcmdopts->infile = 0;\n\tcmdopts->infmt = -1;\n\tcmdopts->infmt_str = 0;\n\tcmdopts->inopts = 0;\n\tcmdopts->inoptsbuf[0] = '\\0';\n\tcmdopts->outfile = 0;\n\tcmdopts->outfmt = -1;\n\tcmdopts->outfmt_str = 0;\n\tcmdopts->outopts = 0;\n\tcmdopts->outoptsbuf[0] = '\\0';\n\tcmdopts->verbose = 0;\n\tcmdopts->version = 0;\n\tcmdopts->cmptno = -1;\n\tcmdopts->debug = 0;\n\tcmdopts->srgb = 0;\n\tcmdopts->list_codecs = 0;\n\tcmdopts->list_codecs_all = 0;\n\tcmdopts->help = 0;\n\tcmdopts->max_mem = get_default_max_mem_usage();\n\tcmdopts->enable_format = 0;\n\tcmdopts->enable_all_formats = 0;\n\n\twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n\t\tswitch (c) {\n\t\tcase CMDOPT_HELP:\n\t\t\tcmdopts->help = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERBOSE:\n\t\t\tcmdopts->verbose = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_QUIET:\n\t\t\tcmdopts->verbose = -1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERSION:\n\t\t\tcmdopts->version = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ENABLED_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 0;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ALL_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_DEBUG:\n\t\t\tcmdopts->debug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_INFILE:\n\t\t\tcmdopts->infile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INFMT:\n\t\t\tcmdopts->infmt_str= jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INOPT:\n\t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFILE:\n\t\t\tcmdopts->outfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFMT:\n\t\t\tcmdopts->outfmt_str = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTOPT:\n\t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_CMPTNO:\n\t\t\tcmdopts->cmptno = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_SRGB:\n\t\t\tcmdopts->srgb = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_MAXMEM:\n\t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_FORMAT:\n\t\t\tcmdopts->enable_format = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_ALL_FORMATS:\n\t\t\tcmdopts->enable_all_formats = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbadusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (jas_optind < argc) {\n\t\tfprintf(stderr,\n\t\t  \"warning: ignoring bogus command line argument %s\\n\",\n\t\t  argv[jas_optind]);\n\t\t++jas_optind;\n\t}\n\n\tif (cmdopts->version || cmdopts->list_codecs || cmdopts->help) {\n\t\tgoto done;\n\t}\n\n\tif (!cmdopts->outfmt_str && !cmdopts->outfile) {\n\t\tfprintf(stderr, \"error: cannot determine output format\\n\");\n\t\tbadusage();\n\t}\n\ndone:\n\treturn cmdopts;\n}",
        "func": "cmdopts_t *cmdopts_parse(int argc, char **argv)\n{\n\tenum {\n\t\tCMDOPT_HELP = 0,\n\t\tCMDOPT_VERBOSE,\n\t\tCMDOPT_QUIET,\n\t\tCMDOPT_INFILE,\n\t\tCMDOPT_INFMT,\n\t\tCMDOPT_INOPT,\n\t\tCMDOPT_OUTFILE,\n\t\tCMDOPT_OUTFMT,\n\t\tCMDOPT_OUTOPT,\n\t\tCMDOPT_VERSION,\n\t\tCMDOPT_DEBUG,\n\t\tCMDOPT_CMPTNO,\n\t\tCMDOPT_SRGB,\n\t\tCMDOPT_MAXMEM,\n\t\tCMDOPT_LIST_ENABLED_CODECS,\n\t\tCMDOPT_LIST_ALL_CODECS,\n\t\tCMDOPT_ENABLE_FORMAT,\n\t\tCMDOPT_ENABLE_ALL_FORMATS,\n\t};\n\n\tstatic const jas_opt_t cmdoptions[] = {\n\t\t{CMDOPT_HELP, \"help\", 0},\n\t\t{CMDOPT_VERBOSE, \"verbose\", 0},\n\t\t{CMDOPT_QUIET, \"quiet\", 0},\n\t\t{CMDOPT_QUIET, \"q\", 0},\n\t\t{CMDOPT_INFILE, \"input\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFILE, \"f\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"input-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INFMT, \"t\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"input-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_INOPT, \"o\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"output\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFILE, \"F\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"output-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTFMT, \"T\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"output-option\", JAS_OPT_HASARG},\n\t\t{CMDOPT_OUTOPT, \"O\", JAS_OPT_HASARG},\n\t\t{CMDOPT_VERSION, \"version\", 0},\n\t\t{CMDOPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n\t\t{CMDOPT_CMPTNO, \"cmptno\", JAS_OPT_HASARG},\n\t\t{CMDOPT_SRGB, \"force-srgb\", 0},\n\t\t{CMDOPT_SRGB, \"S\", 0},\n\t\t{CMDOPT_MAXMEM, \"memory-limit\", JAS_OPT_HASARG},\n\t\t{CMDOPT_LIST_ENABLED_CODECS, \"list-enabled-formats\", 0},\n\t\t{CMDOPT_LIST_ALL_CODECS, \"list-all-formats\", 0},\n\t\t{CMDOPT_ENABLE_FORMAT, \"enable-format\", JAS_OPT_HASARG},\n\t\t{CMDOPT_ENABLE_ALL_FORMATS, \"enable-all-formats\", 0},\n\t\t{-1, 0, 0}\n\t};\n\n\tcmdopts_t *cmdopts;\n\tint c;\n\n\tif (!(cmdopts = malloc(sizeof(cmdopts_t)))) {\n\t\tfprintf(stderr, \"error: insufficient memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tcmdopts->infile = 0;\n\tcmdopts->infmt = -1;\n\tcmdopts->infmt_str = 0;\n\tcmdopts->inopts = 0;\n\tcmdopts->inoptsbuf[0] = '\\0';\n\tcmdopts->outfile = 0;\n\tcmdopts->outfmt = -1;\n\tcmdopts->outfmt_str = 0;\n\tcmdopts->outopts = 0;\n\tcmdopts->outoptsbuf[0] = '\\0';\n\tcmdopts->verbose = 0;\n\tcmdopts->version = 0;\n\tcmdopts->cmptno = -1;\n\tcmdopts->debug = 0;\n\tcmdopts->srgb = 0;\n\tcmdopts->list_codecs = 0;\n\tcmdopts->list_codecs_all = 0;\n\tcmdopts->help = 0;\n\tcmdopts->max_mem = get_default_max_mem_usage();\n\tcmdopts->enable_format = 0;\n\tcmdopts->enable_all_formats = 0;\n\n\twhile ((c = jas_getopt(argc, argv, cmdoptions)) != EOF) {\n\t\tswitch (c) {\n\t\tcase CMDOPT_HELP:\n\t\t\tcmdopts->help = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERBOSE:\n\t\t\tcmdopts->verbose = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_QUIET:\n\t\t\tcmdopts->verbose = -1;\n\t\t\tbreak;\n\t\tcase CMDOPT_VERSION:\n\t\t\tcmdopts->version = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ENABLED_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 0;\n\t\t\tbreak;\n\t\tcase CMDOPT_LIST_ALL_CODECS:\n\t\t\tcmdopts->list_codecs = 1;\n\t\t\tcmdopts->list_codecs_all = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_DEBUG:\n\t\t\tcmdopts->debug = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_INFILE:\n\t\t\tcmdopts->infile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INFMT:\n\t\t\tcmdopts->infmt_str= jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_INOPT:\n\t\t\taddopt(cmdopts->inoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->inopts = cmdopts->inoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFILE:\n\t\t\tcmdopts->outfile = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTFMT:\n\t\t\tcmdopts->outfmt_str = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_OUTOPT:\n\t\t\taddopt(cmdopts->outoptsbuf, OPTSMAX, jas_optarg);\n\t\t\tcmdopts->outopts = cmdopts->outoptsbuf;\n\t\t\tbreak;\n\t\tcase CMDOPT_CMPTNO:\n\t\t\tcmdopts->cmptno = atoi(jas_optarg);\n\t\t\tbreak;\n\t\tcase CMDOPT_SRGB:\n\t\t\tcmdopts->srgb = 1;\n\t\t\tbreak;\n\t\tcase CMDOPT_MAXMEM:\n\t\t\tcmdopts->max_mem = strtoull(jas_optarg, 0, 10);\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_FORMAT:\n\t\t\tcmdopts->enable_format = jas_optarg;\n\t\t\tbreak;\n\t\tcase CMDOPT_ENABLE_ALL_FORMATS:\n\t\t\tcmdopts->enable_all_formats = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcmdopts_destroy(cmdopts);\n\t\t\tbadusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (jas_optind < argc) {\n\t\tfprintf(stderr,\n\t\t  \"warning: ignoring bogus command line argument %s\\n\",\n\t\t  argv[jas_optind]);\n\t\t++jas_optind;\n\t}\n\n\tif (cmdopts->version || cmdopts->list_codecs || cmdopts->help) {\n\t\tgoto done;\n\t}\n\n\tif (!cmdopts->outfmt_str && !cmdopts->outfile) {\n\t\tfprintf(stderr, \"error: cannot determine output format\\n\");\n\t\tcmdopts_destroy(cmdopts);\n\t\tbadusage();\n\t}\n\ndone:\n\treturn cmdopts;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -142,6 +142,7 @@\n \t\t\tcmdopts->enable_all_formats = 1;\n \t\t\tbreak;\n \t\tdefault:\n+\t\t\tcmdopts_destroy(cmdopts);\n \t\t\tbadusage();\n \t\t\tbreak;\n \t\t}\n@@ -160,6 +161,7 @@\n \n \tif (!cmdopts->outfmt_str && !cmdopts->outfile) {\n \t\tfprintf(stderr, \"error: cannot determine output format\\n\");\n+\t\tcmdopts_destroy(cmdopts);\n \t\tbadusage();\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tcmdopts_destroy(cmdopts);",
                "\t\tcmdopts_destroy(cmdopts);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3526",
        "func_name": "kernel/git/pabeni/net-next/macvlan_handle_frame",
        "description": "A vulnerability classified as problematic was found in Linux Kernel. This vulnerability affects the function macvlan_handle_frame of the file drivers/net/macvlan.c of the component skb. The manipulation leads to memory leak. The attack can be initiated remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211024.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/pabeni/net-next.git/commit/?h=e16b859872b87650bb55b12cca5a5fcdc49c1442",
        "commit_title": "The MACVLAN receive handler clones skbs to all matching source MACVLAN",
        "commit_text": "interfaces, before it passes the packet along to match on destination based MACVLANs.  When using the MACVLAN nodst mode, passing the packet to destination based MACVLANs is omitted and the handler returns with RX_HANDLER_CONSUMED. However, the passed skb is not freed, leaking for any packet processed with the nodst option.  Properly free the skb when consuming packets to fix that leak.  ",
        "func_before": "static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)\n{\n\tstruct macvlan_port *port;\n\tstruct sk_buff *skb = *pskb;\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\tconst struct macvlan_dev *vlan;\n\tconst struct macvlan_dev *src;\n\tstruct net_device *dev;\n\tunsigned int len = 0;\n\tint ret;\n\trx_handler_result_t handle_res;\n\n\t/* Packets from dev_loopback_xmit() do not have L2 header, bail out */\n\tif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\n\t\treturn RX_HANDLER_PASS;\n\n\tport = macvlan_port_get_rcu(skb->dev);\n\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\tunsigned int hash;\n\n\t\tskb = ip_check_defrag(dev_net(skb->dev), skb, IP_DEFRAG_MACVLAN);\n\t\tif (!skb)\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t*pskb = skb;\n\t\teth = eth_hdr(skb);\n\t\tif (macvlan_forward_source(skb, port, eth->h_source))\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\tsrc = macvlan_hash_lookup(port, eth->h_source);\n\t\tif (src && src->mode != MACVLAN_MODE_VEPA &&\n\t\t    src->mode != MACVLAN_MODE_BRIDGE) {\n\t\t\t/* forward to original port. */\n\t\t\tvlan = src;\n\t\t\tret = macvlan_broadcast_one(skb, vlan, eth, 0) ?:\n\t\t\t      __netif_rx(skb);\n\t\t\thandle_res = RX_HANDLER_CONSUMED;\n\t\t\tgoto out;\n\t\t}\n\n\t\thash = mc_hash(NULL, eth->h_dest);\n\t\tif (test_bit(hash, port->mc_filter))\n\t\t\tmacvlan_broadcast_enqueue(port, src, skb);\n\n\t\treturn RX_HANDLER_PASS;\n\t}\n\n\tif (macvlan_forward_source(skb, port, eth->h_source))\n\t\treturn RX_HANDLER_CONSUMED;\n\tif (macvlan_passthru(port))\n\t\tvlan = list_first_or_null_rcu(&port->vlans,\n\t\t\t\t\t      struct macvlan_dev, list);\n\telse\n\t\tvlan = macvlan_hash_lookup(port, eth->h_dest);\n\tif (!vlan || vlan->mode == MACVLAN_MODE_SOURCE)\n\t\treturn RX_HANDLER_PASS;\n\n\tdev = vlan->dev;\n\tif (unlikely(!(dev->flags & IFF_UP))) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\tlen = skb->len + ETH_HLEN;\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tret = NET_RX_DROP;\n\t\thandle_res = RX_HANDLER_CONSUMED;\n\t\tgoto out;\n\t}\n\n\t*pskb = skb;\n\tskb->dev = dev;\n\tskb->pkt_type = PACKET_HOST;\n\n\tret = NET_RX_SUCCESS;\n\thandle_res = RX_HANDLER_ANOTHER;\nout:\n\tmacvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, false);\n\treturn handle_res;\n}",
        "func": "static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)\n{\n\tstruct macvlan_port *port;\n\tstruct sk_buff *skb = *pskb;\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\tconst struct macvlan_dev *vlan;\n\tconst struct macvlan_dev *src;\n\tstruct net_device *dev;\n\tunsigned int len = 0;\n\tint ret;\n\trx_handler_result_t handle_res;\n\n\t/* Packets from dev_loopback_xmit() do not have L2 header, bail out */\n\tif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\n\t\treturn RX_HANDLER_PASS;\n\n\tport = macvlan_port_get_rcu(skb->dev);\n\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\tunsigned int hash;\n\n\t\tskb = ip_check_defrag(dev_net(skb->dev), skb, IP_DEFRAG_MACVLAN);\n\t\tif (!skb)\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t*pskb = skb;\n\t\teth = eth_hdr(skb);\n\t\tif (macvlan_forward_source(skb, port, eth->h_source)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t}\n\t\tsrc = macvlan_hash_lookup(port, eth->h_source);\n\t\tif (src && src->mode != MACVLAN_MODE_VEPA &&\n\t\t    src->mode != MACVLAN_MODE_BRIDGE) {\n\t\t\t/* forward to original port. */\n\t\t\tvlan = src;\n\t\t\tret = macvlan_broadcast_one(skb, vlan, eth, 0) ?:\n\t\t\t      __netif_rx(skb);\n\t\t\thandle_res = RX_HANDLER_CONSUMED;\n\t\t\tgoto out;\n\t\t}\n\n\t\thash = mc_hash(NULL, eth->h_dest);\n\t\tif (test_bit(hash, port->mc_filter))\n\t\t\tmacvlan_broadcast_enqueue(port, src, skb);\n\n\t\treturn RX_HANDLER_PASS;\n\t}\n\n\tif (macvlan_forward_source(skb, port, eth->h_source)) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\tif (macvlan_passthru(port))\n\t\tvlan = list_first_or_null_rcu(&port->vlans,\n\t\t\t\t\t      struct macvlan_dev, list);\n\telse\n\t\tvlan = macvlan_hash_lookup(port, eth->h_dest);\n\tif (!vlan || vlan->mode == MACVLAN_MODE_SOURCE)\n\t\treturn RX_HANDLER_PASS;\n\n\tdev = vlan->dev;\n\tif (unlikely(!(dev->flags & IFF_UP))) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\tlen = skb->len + ETH_HLEN;\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tret = NET_RX_DROP;\n\t\thandle_res = RX_HANDLER_CONSUMED;\n\t\tgoto out;\n\t}\n\n\t*pskb = skb;\n\tskb->dev = dev;\n\tskb->pkt_type = PACKET_HOST;\n\n\tret = NET_RX_SUCCESS;\n\thandle_res = RX_HANDLER_ANOTHER;\nout:\n\tmacvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, false);\n\treturn handle_res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,8 +23,10 @@\n \t\t\treturn RX_HANDLER_CONSUMED;\n \t\t*pskb = skb;\n \t\teth = eth_hdr(skb);\n-\t\tif (macvlan_forward_source(skb, port, eth->h_source))\n+\t\tif (macvlan_forward_source(skb, port, eth->h_source)) {\n+\t\t\tkfree_skb(skb);\n \t\t\treturn RX_HANDLER_CONSUMED;\n+\t\t}\n \t\tsrc = macvlan_hash_lookup(port, eth->h_source);\n \t\tif (src && src->mode != MACVLAN_MODE_VEPA &&\n \t\t    src->mode != MACVLAN_MODE_BRIDGE) {\n@@ -43,8 +45,10 @@\n \t\treturn RX_HANDLER_PASS;\n \t}\n \n-\tif (macvlan_forward_source(skb, port, eth->h_source))\n+\tif (macvlan_forward_source(skb, port, eth->h_source)) {\n+\t\tkfree_skb(skb);\n \t\treturn RX_HANDLER_CONSUMED;\n+\t}\n \tif (macvlan_passthru(port))\n \t\tvlan = list_first_or_null_rcu(&port->vlans,\n \t\t\t\t\t      struct macvlan_dev, list);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (macvlan_forward_source(skb, port, eth->h_source))",
                "\tif (macvlan_forward_source(skb, port, eth->h_source))"
            ],
            "added_lines": [
                "\t\tif (macvlan_forward_source(skb, port, eth->h_source)) {",
                "\t\t\tkfree_skb(skb);",
                "\t\t}",
                "\tif (macvlan_forward_source(skb, port, eth->h_source)) {",
                "\t\tkfree_skb(skb);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3543",
        "func_name": "kernel/git/bpf/bpf-next/unix_release_sock",
        "description": "A vulnerability, which was classified as problematic, has been found in Linux Kernel. This issue affects the function unix_sock_destructor/unix_release_sock of the file net/unix/af_unix.c of the component BPF. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211043.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?h=7a62ed61367b8fd01bae1e18e30602c25060d824",
        "commit_title": "syzbot reported a sequence of memory leaks, and one of them indicated we",
        "commit_text": "failed to free a whole sk:    unreferenced object 0xffff8880126e0000 (size 1088):     comm \"syz-executor419\", pid 326, jiffies 4294773607 (age 12.609s)     hex dump (first 32 bytes):       00 00 00 00 00 00 00 00 7d 00 00 00 00 00 00 00  ........}.......       01 00 07 40 00 00 00 00 00 00 00 00 00 00 00 00  ...@............     backtrace:       [<000000006fefe750>] sk_prot_alloc+0x64/0x2a0 net/core/sock.c:1970       [<0000000074006db5>] sk_alloc+0x3b/0x800 net/core/sock.c:2029       [<00000000728cd434>] unix_create1+0xaf/0x920 net/unix/af_unix.c:928       [<00000000a279a139>] unix_create+0x113/0x1d0 net/unix/af_unix.c:997       [<0000000068259812>] __sock_create+0x2ab/0x550 net/socket.c:1516       [<00000000da1521e1>] sock_create net/socket.c:1566 [inline]       [<00000000da1521e1>] __sys_socketpair+0x1a8/0x550 net/socket.c:1698       [<000000007ab259e1>] __do_sys_socketpair net/socket.c:1751 [inline]       [<000000007ab259e1>] __se_sys_socketpair net/socket.c:1748 [inline]       [<000000007ab259e1>] __x64_sys_socketpair+0x97/0x100 net/socket.c:1748       [<000000007dedddc1>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]       [<000000007dedddc1>] do_syscall_64+0x38/0x90 arch/x86/entry/common.c:80       [<000000009456679f>] entry_SYSCALL_64_after_hwframe+0x63/0xcd  We can reproduce this issue by creating two AF_UNIX SOCK_STREAM sockets, send()ing an OOB skb to each other, and close()ing them without consuming the OOB skbs.    int skpair[2];    socketpair(AF_UNIX, SOCK_STREAM, 0, skpair);    send(skpair[0], \"x\", 1, MSG_OOB);   send(skpair[1], \"x\", 1, MSG_OOB);    close(skpair[0]);   close(skpair[1]);  Currently, we free an OOB skb in unix_sock_destructor() which is called via __sk_free(), but it's too late because the receiver's unix_sk(sk)->oob_skb is accounted against the sender's sk->sk_wmem_alloc and __sk_free() is called only when sk->sk_wmem_alloc is 0.  In the repro sequences, we do not consume the OOB skb, so both two sk's sock_put() never reach __sk_free() due to the positive sk->sk_wmem_alloc. Then, no one can consume the OOB skb nor call __sk_free(), and we finally leak the two whole sk.  Thus, we must free the unconsumed OOB skb earlier when close()ing the socket.  ",
        "func_before": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tstruct path path;\n\tint state;\n\n\tunix_remove_socket(sock_net(sk), sk);\n\tunix_remove_bsd_socket(sk);\n\n\t/* Clear state */\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\n\tskpair = unix_peer(sk);\n\tunix_peer(sk) = NULL;\n\n\tunix_state_unlock(sk);\n\n\twake_up_interruptible_all(&u->peer_wait);\n\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\t/* No more writes */\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); /* It may now die */\n\t}\n\n\t/* Try to flush out this socket. Throw out buffers at least */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\t/* passed fds are erased in the kfree_skb hook\t      */\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\n\tif (path.dentry)\n\t\tpath_put(&path);\n\n\tsock_put(sk);\n\n\t/* ---- Socket is dead now and most probably destroyed ---- */\n\n\t/*\n\t * Fixme: BSD difference: In BSD all sockets connected to us get\n\t *\t  ECONNRESET and we die on the spot. In Linux we behave\n\t *\t  like files and pipes do and wait for the last\n\t *\t  dereference.\n\t *\n\t * Can't we simply set sock->err?\n\t *\n\t *\t  What the above comment does talk about? --ANK(980817)\n\t */\n\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t/* Garbage collect fds */\n}",
        "func": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tstruct path path;\n\tint state;\n\n\tunix_remove_socket(sock_net(sk), sk);\n\tunix_remove_bsd_socket(sk);\n\n\t/* Clear state */\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\n\tskpair = unix_peer(sk);\n\tunix_peer(sk) = NULL;\n\n\tunix_state_unlock(sk);\n\n#if IS_ENABLED(CONFIG_AF_UNIX_OOB)\n\tif (u->oob_skb) {\n\t\tkfree_skb(u->oob_skb);\n\t\tu->oob_skb = NULL;\n\t}\n#endif\n\n\twake_up_interruptible_all(&u->peer_wait);\n\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\t/* No more writes */\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); /* It may now die */\n\t}\n\n\t/* Try to flush out this socket. Throw out buffers at least */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\t/* passed fds are erased in the kfree_skb hook\t      */\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\n\tif (path.dentry)\n\t\tpath_put(&path);\n\n\tsock_put(sk);\n\n\t/* ---- Socket is dead now and most probably destroyed ---- */\n\n\t/*\n\t * Fixme: BSD difference: In BSD all sockets connected to us get\n\t *\t  ECONNRESET and we die on the spot. In Linux we behave\n\t *\t  like files and pipes do and wait for the last\n\t *\t  dereference.\n\t *\n\t * Can't we simply set sock->err?\n\t *\n\t *\t  What the above comment does talk about? --ANK(980817)\n\t */\n\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t/* Garbage collect fds */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,13 @@\n \tunix_peer(sk) = NULL;\n \n \tunix_state_unlock(sk);\n+\n+#if IS_ENABLED(CONFIG_AF_UNIX_OOB)\n+\tif (u->oob_skb) {\n+\t\tkfree_skb(u->oob_skb);\n+\t\tu->oob_skb = NULL;\n+\t}\n+#endif\n \n \twake_up_interruptible_all(&u->peer_wait);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "#if IS_ENABLED(CONFIG_AF_UNIX_OOB)",
                "\tif (u->oob_skb) {",
                "\t\tkfree_skb(u->oob_skb);",
                "\t\tu->oob_skb = NULL;",
                "\t}",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3543",
        "func_name": "kernel/git/bpf/bpf-next/unix_sock_destructor",
        "description": "A vulnerability, which was classified as problematic, has been found in Linux Kernel. This issue affects the function unix_sock_destructor/unix_release_sock of the file net/unix/af_unix.c of the component BPF. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211043.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?h=7a62ed61367b8fd01bae1e18e30602c25060d824",
        "commit_title": "syzbot reported a sequence of memory leaks, and one of them indicated we",
        "commit_text": "failed to free a whole sk:    unreferenced object 0xffff8880126e0000 (size 1088):     comm \"syz-executor419\", pid 326, jiffies 4294773607 (age 12.609s)     hex dump (first 32 bytes):       00 00 00 00 00 00 00 00 7d 00 00 00 00 00 00 00  ........}.......       01 00 07 40 00 00 00 00 00 00 00 00 00 00 00 00  ...@............     backtrace:       [<000000006fefe750>] sk_prot_alloc+0x64/0x2a0 net/core/sock.c:1970       [<0000000074006db5>] sk_alloc+0x3b/0x800 net/core/sock.c:2029       [<00000000728cd434>] unix_create1+0xaf/0x920 net/unix/af_unix.c:928       [<00000000a279a139>] unix_create+0x113/0x1d0 net/unix/af_unix.c:997       [<0000000068259812>] __sock_create+0x2ab/0x550 net/socket.c:1516       [<00000000da1521e1>] sock_create net/socket.c:1566 [inline]       [<00000000da1521e1>] __sys_socketpair+0x1a8/0x550 net/socket.c:1698       [<000000007ab259e1>] __do_sys_socketpair net/socket.c:1751 [inline]       [<000000007ab259e1>] __se_sys_socketpair net/socket.c:1748 [inline]       [<000000007ab259e1>] __x64_sys_socketpair+0x97/0x100 net/socket.c:1748       [<000000007dedddc1>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]       [<000000007dedddc1>] do_syscall_64+0x38/0x90 arch/x86/entry/common.c:80       [<000000009456679f>] entry_SYSCALL_64_after_hwframe+0x63/0xcd  We can reproduce this issue by creating two AF_UNIX SOCK_STREAM sockets, send()ing an OOB skb to each other, and close()ing them without consuming the OOB skbs.    int skpair[2];    socketpair(AF_UNIX, SOCK_STREAM, 0, skpair);    send(skpair[0], \"x\", 1, MSG_OOB);   send(skpair[1], \"x\", 1, MSG_OOB);    close(skpair[0]);   close(skpair[1]);  Currently, we free an OOB skb in unix_sock_destructor() which is called via __sk_free(), but it's too late because the receiver's unix_sk(sk)->oob_skb is accounted against the sender's sk->sk_wmem_alloc and __sk_free() is called only when sk->sk_wmem_alloc is 0.  In the repro sequences, we do not consume the OOB skb, so both two sk's sock_put() never reach __sk_free() due to the positive sk->sk_wmem_alloc. Then, no one can consume the OOB skb nor call __sk_free(), and we finally leak the two whole sk.  Thus, we must free the unconsumed OOB skb earlier when close()ing the socket.  ",
        "func_before": "static void unix_sock_destructor(struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n#if IS_ENABLED(CONFIG_AF_UNIX_OOB)\n\tif (u->oob_skb) {\n\t\tkfree_skb(u->oob_skb);\n\t\tu->oob_skb = NULL;\n\t}\n#endif\n\tDEBUG_NET_WARN_ON_ONCE(refcount_read(&sk->sk_wmem_alloc));\n\tDEBUG_NET_WARN_ON_ONCE(!sk_unhashed(sk));\n\tDEBUG_NET_WARN_ON_ONCE(sk->sk_socket);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_info(\"Attempt to release alive unix socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tif (u->addr)\n\t\tunix_release_addr(u->addr);\n\n\tatomic_long_dec(&unix_nr_socks);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n#ifdef UNIX_REFCNT_DEBUG\n\tpr_debug(\"UNIX %p is destroyed, %ld are still alive.\\n\", sk,\n\t\tatomic_long_read(&unix_nr_socks));\n#endif\n}",
        "func": "static void unix_sock_destructor(struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tDEBUG_NET_WARN_ON_ONCE(refcount_read(&sk->sk_wmem_alloc));\n\tDEBUG_NET_WARN_ON_ONCE(!sk_unhashed(sk));\n\tDEBUG_NET_WARN_ON_ONCE(sk->sk_socket);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_info(\"Attempt to release alive unix socket: %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tif (u->addr)\n\t\tunix_release_addr(u->addr);\n\n\tatomic_long_dec(&unix_nr_socks);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n#ifdef UNIX_REFCNT_DEBUG\n\tpr_debug(\"UNIX %p is destroyed, %ld are still alive.\\n\", sk,\n\t\tatomic_long_read(&unix_nr_socks));\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,12 +4,6 @@\n \n \tskb_queue_purge(&sk->sk_receive_queue);\n \n-#if IS_ENABLED(CONFIG_AF_UNIX_OOB)\n-\tif (u->oob_skb) {\n-\t\tkfree_skb(u->oob_skb);\n-\t\tu->oob_skb = NULL;\n-\t}\n-#endif\n \tDEBUG_NET_WARN_ON_ONCE(refcount_read(&sk->sk_wmem_alloc));\n \tDEBUG_NET_WARN_ON_ONCE(!sk_unhashed(sk));\n \tDEBUG_NET_WARN_ON_ONCE(sk->sk_socket);",
        "diff_line_info": {
            "deleted_lines": [
                "#if IS_ENABLED(CONFIG_AF_UNIX_OOB)",
                "\tif (u->oob_skb) {",
                "\t\tkfree_skb(u->oob_skb);",
                "\t\tu->oob_skb = NULL;",
                "\t}",
                "#endif"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-3619",
        "func_name": "kernel/git/bluetooth/bluetooth-next/l2cap_recv_acldata",
        "description": "A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function l2cap_recv_acldata of the file net/bluetooth/l2cap_core.c of the component Bluetooth. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. VDB-211918 is the identifier assigned to this vulnerability.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?h=97097c85c088e11651146da32a4e1cdb9dfa6193",
        "commit_title": "Syzkaller reports a memory leak as follows:",
        "commit_text": "==================================== BUG: memory leak unreferenced object 0xffff88810d81ac00 (size 240):   [...]   hex dump (first 32 bytes):     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................   backtrace:     [<ffffffff838733d9>] __alloc_skb+0x1f9/0x270 net/core/skbuff.c:418     [<ffffffff833f742f>] alloc_skb include/linux/skbuff.h:1257 [inline]     [<ffffffff833f742f>] bt_skb_alloc include/net/bluetooth/bluetooth.h:469 [inline]     [<ffffffff833f742f>] vhci_get_user drivers/bluetooth/hci_vhci.c:391 [inline]     [<ffffffff833f742f>] vhci_write+0x5f/0x230 drivers/bluetooth/hci_vhci.c:511     [<ffffffff815e398d>] call_write_iter include/linux/fs.h:2192 [inline]     [<ffffffff815e398d>] new_sync_write fs/read_write.c:491 [inline]     [<ffffffff815e398d>] vfs_write+0x42d/0x540 fs/read_write.c:578     [<ffffffff815e3cdd>] ksys_write+0x9d/0x160 fs/read_write.c:631     [<ffffffff845e0645>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]     [<ffffffff845e0645>] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80     [<ffffffff84600087>] entry_SYSCALL_64_after_hwframe+0x63/0xcd ====================================  HCI core will uses hci_rx_work() to process frame, which is queued to the hdev->rx_q tail in hci_recv_frame() by HCI driver.  Yet the problem is that, HCI core may not free the skb after handling ACL data packets. To be more specific, when start fragment does not contain the L2CAP length, HCI core just copies skb into conn->rx_skb and finishes frame process in l2cap_recv_acldata(), without freeing the skb, which triggers the above memory leak.  This patch solves it by releasing the relative skb, after processing the above case in l2cap_recv_acldata().  Link: https://lore.kernel.org/all/0000000000000d0b1905e6aaef64@google.com/ Reported-and-tested-by: syzbot+8f819e36e01022991cfa@syzkaller.appspotmail.com ",
        "func_before": "void l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tint len;\n\n\t/* For AMP controller do not create l2cap conn */\n\tif (!conn && hcon->hdev->dev_type != HCI_PRIMARY)\n\t\tgoto drop;\n\n\tif (!conn)\n\t\tconn = l2cap_conn_add(hcon);\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %u flags 0x%x\", conn, skb->len, flags);\n\n\tswitch (flags) {\n\tcase ACL_START:\n\tcase ACL_START_NO_FLUSH:\n\tcase ACL_COMPLETE:\n\t\tif (conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected start frame (len %d)\", skb->len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t}\n\n\t\t/* Start fragment may not contain the L2CAP length so just\n\t\t * copy the initial byte when that happens and use conn->mtu as\n\t\t * expected length.\n\t\t */\n\t\tif (skb->len < L2CAP_LEN_SIZE) {\n\t\t\tif (l2cap_recv_frag(conn, skb, conn->mtu) < 0)\n\t\t\t\tgoto drop;\n\t\t\treturn;\n\t\t}\n\n\t\tlen = get_unaligned_le16(skb->data) + L2CAP_HDR_SIZE;\n\n\t\tif (len == skb->len) {\n\t\t\t/* Complete frame received */\n\t\t\tl2cap_recv_frame(conn, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tBT_DBG(\"Start: total len %d, frag len %u\", len, skb->len);\n\n\t\tif (skb->len > len) {\n\t\t\tBT_ERR(\"Frame is too long (len %u, expected len %d)\",\n\t\t\t       skb->len, len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tif (l2cap_recv_frag(conn, skb, len) < 0)\n\t\t\tgoto drop;\n\n\t\tbreak;\n\n\tcase ACL_CONT:\n\t\tBT_DBG(\"Cont: frag len %u (expecting %u)\", skb->len, conn->rx_len);\n\n\t\tif (!conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected continuation frame (len %d)\", skb->len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Complete the L2CAP length if it has not been read */\n\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE) {\n\t\t\tif (l2cap_recv_len(conn, skb) < 0) {\n\t\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\t/* Header still could not be read just continue */\n\t\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE)\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (skb->len > conn->rx_len) {\n\t\t\tBT_ERR(\"Fragment is too long (len %u, expected %u)\",\n\t\t\t       skb->len, conn->rx_len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tl2cap_recv_frag(conn, skb, skb->len);\n\n\t\tif (!conn->rx_len) {\n\t\t\t/* Complete frame received. l2cap_recv_frame\n\t\t\t * takes ownership of the skb so set the global\n\t\t\t * rx_skb pointer to NULL first.\n\t\t\t */\n\t\t\tstruct sk_buff *rx_skb = conn->rx_skb;\n\t\t\tconn->rx_skb = NULL;\n\t\t\tl2cap_recv_frame(conn, rx_skb);\n\t\t}\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}",
        "func": "void l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tint len;\n\n\t/* For AMP controller do not create l2cap conn */\n\tif (!conn && hcon->hdev->dev_type != HCI_PRIMARY)\n\t\tgoto drop;\n\n\tif (!conn)\n\t\tconn = l2cap_conn_add(hcon);\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %u flags 0x%x\", conn, skb->len, flags);\n\n\tswitch (flags) {\n\tcase ACL_START:\n\tcase ACL_START_NO_FLUSH:\n\tcase ACL_COMPLETE:\n\t\tif (conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected start frame (len %d)\", skb->len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t}\n\n\t\t/* Start fragment may not contain the L2CAP length so just\n\t\t * copy the initial byte when that happens and use conn->mtu as\n\t\t * expected length.\n\t\t */\n\t\tif (skb->len < L2CAP_LEN_SIZE) {\n\t\t\tl2cap_recv_frag(conn, skb, conn->mtu);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = get_unaligned_le16(skb->data) + L2CAP_HDR_SIZE;\n\n\t\tif (len == skb->len) {\n\t\t\t/* Complete frame received */\n\t\t\tl2cap_recv_frame(conn, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tBT_DBG(\"Start: total len %d, frag len %u\", len, skb->len);\n\n\t\tif (skb->len > len) {\n\t\t\tBT_ERR(\"Frame is too long (len %u, expected len %d)\",\n\t\t\t       skb->len, len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tif (l2cap_recv_frag(conn, skb, len) < 0)\n\t\t\tgoto drop;\n\n\t\tbreak;\n\n\tcase ACL_CONT:\n\t\tBT_DBG(\"Cont: frag len %u (expecting %u)\", skb->len, conn->rx_len);\n\n\t\tif (!conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected continuation frame (len %d)\", skb->len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Complete the L2CAP length if it has not been read */\n\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE) {\n\t\t\tif (l2cap_recv_len(conn, skb) < 0) {\n\t\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\t/* Header still could not be read just continue */\n\t\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len > conn->rx_len) {\n\t\t\tBT_ERR(\"Fragment is too long (len %u, expected %u)\",\n\t\t\t       skb->len, conn->rx_len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tl2cap_recv_frag(conn, skb, skb->len);\n\n\t\tif (!conn->rx_len) {\n\t\t\t/* Complete frame received. l2cap_recv_frame\n\t\t\t * takes ownership of the skb so set the global\n\t\t\t * rx_skb pointer to NULL first.\n\t\t\t */\n\t\t\tstruct sk_buff *rx_skb = conn->rx_skb;\n\t\t\tconn->rx_skb = NULL;\n\t\t\tl2cap_recv_frame(conn, rx_skb);\n\t\t}\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,9 +30,8 @@\n \t\t * expected length.\n \t\t */\n \t\tif (skb->len < L2CAP_LEN_SIZE) {\n-\t\t\tif (l2cap_recv_frag(conn, skb, conn->mtu) < 0)\n-\t\t\t\tgoto drop;\n-\t\t\treturn;\n+\t\t\tl2cap_recv_frag(conn, skb, conn->mtu);\n+\t\t\tbreak;\n \t\t}\n \n \t\tlen = get_unaligned_le16(skb->data) + L2CAP_HDR_SIZE;\n@@ -76,7 +75,7 @@\n \n \t\t\t/* Header still could not be read just continue */\n \t\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE)\n-\t\t\t\treturn;\n+\t\t\t\tbreak;\n \t\t}\n \n \t\tif (skb->len > conn->rx_len) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (l2cap_recv_frag(conn, skb, conn->mtu) < 0)",
                "\t\t\t\tgoto drop;",
                "\t\t\treturn;",
                "\t\t\t\treturn;"
            ],
            "added_lines": [
                "\t\t\tl2cap_recv_frag(conn, skb, conn->mtu);",
                "\t\t\tbreak;",
                "\t\t\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3624",
        "func_name": "kernel/git/klassert/ipsec-next/rlb_arp_xmit",
        "description": "A vulnerability was found in Linux Kernel and classified as problematic. Affected by this issue is the function rlb_arp_xmit of the file drivers/net/bonding/bond_alb.c of the component IPsec. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211928.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next.git/commit/?h=4f5d33f4f798b1c6d92b613f0087f639d9836971",
        "commit_title": "Commit d5410ac7b0ba (\"net:bonding:support balance-alb interface",
        "commit_text": "with vlan to bridge\") introduced a reference count leak by not releasing the reference acquired by ip_dev_find().  Remedy this by insuring the reference is released.  Link: https://lore.kernel.org/r/26758.1660194413@famine ",
        "func_before": "static struct slave *rlb_arp_xmit(struct sk_buff *skb, struct bonding *bond)\n{\n\tstruct slave *tx_slave = NULL;\n\tstruct net_device *dev;\n\tstruct arp_pkt *arp;\n\n\tif (!pskb_network_may_pull(skb, sizeof(*arp)))\n\t\treturn NULL;\n\tarp = (struct arp_pkt *)skb_network_header(skb);\n\n\t/* Don't modify or load balance ARPs that do not originate locally\n\t * (e.g.,arrive via a bridge).\n\t */\n\tif (!bond_slave_has_mac_rx(bond, arp->mac_src))\n\t\treturn NULL;\n\n\tdev = ip_dev_find(dev_net(bond->dev), arp->ip_src);\n\tif (dev) {\n\t\tif (netif_is_bridge_master(dev))\n\t\t\treturn NULL;\n\t}\n\n\tif (arp->op_code == htons(ARPOP_REPLY)) {\n\t\t/* the arp must be sent on the selected rx channel */\n\t\ttx_slave = rlb_choose_channel(skb, bond, arp);\n\t\tif (tx_slave)\n\t\t\tbond_hw_addr_copy(arp->mac_src, tx_slave->dev->dev_addr,\n\t\t\t\t\t  tx_slave->dev->addr_len);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): Server sent ARP Reply packet\\n\",\n\t\t\t   tx_slave ? tx_slave->dev->name : \"NULL\");\n\t} else if (arp->op_code == htons(ARPOP_REQUEST)) {\n\t\t/* Create an entry in the rx_hashtbl for this client as a\n\t\t * place holder.\n\t\t * When the arp reply is received the entry will be updated\n\t\t * with the correct unicast address of the client.\n\t\t */\n\t\ttx_slave = rlb_choose_channel(skb, bond, arp);\n\n\t\t/* The ARP reply packets must be delayed so that\n\t\t * they can cancel out the influence of the ARP request.\n\t\t */\n\t\tbond->alb_info.rlb_update_delay_counter = RLB_UPDATE_DELAY;\n\n\t\t/* arp requests are broadcast and are sent on the primary\n\t\t * the arp request will collapse all clients on the subnet to\n\t\t * the primary slave. We must register these clients to be\n\t\t * updated with their assigned mac.\n\t\t */\n\t\trlb_req_update_subnet_clients(bond, arp->ip_src);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): Server sent ARP Request packet\\n\",\n\t\t\t   tx_slave ? tx_slave->dev->name : \"NULL\");\n\t}\n\n\treturn tx_slave;\n}",
        "func": "static struct slave *rlb_arp_xmit(struct sk_buff *skb, struct bonding *bond)\n{\n\tstruct slave *tx_slave = NULL;\n\tstruct net_device *dev;\n\tstruct arp_pkt *arp;\n\n\tif (!pskb_network_may_pull(skb, sizeof(*arp)))\n\t\treturn NULL;\n\tarp = (struct arp_pkt *)skb_network_header(skb);\n\n\t/* Don't modify or load balance ARPs that do not originate locally\n\t * (e.g.,arrive via a bridge).\n\t */\n\tif (!bond_slave_has_mac_rx(bond, arp->mac_src))\n\t\treturn NULL;\n\n\tdev = ip_dev_find(dev_net(bond->dev), arp->ip_src);\n\tif (dev) {\n\t\tif (netif_is_bridge_master(dev)) {\n\t\t\tdev_put(dev);\n\t\t\treturn NULL;\n\t\t}\n\t\tdev_put(dev);\n\t}\n\n\tif (arp->op_code == htons(ARPOP_REPLY)) {\n\t\t/* the arp must be sent on the selected rx channel */\n\t\ttx_slave = rlb_choose_channel(skb, bond, arp);\n\t\tif (tx_slave)\n\t\t\tbond_hw_addr_copy(arp->mac_src, tx_slave->dev->dev_addr,\n\t\t\t\t\t  tx_slave->dev->addr_len);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): Server sent ARP Reply packet\\n\",\n\t\t\t   tx_slave ? tx_slave->dev->name : \"NULL\");\n\t} else if (arp->op_code == htons(ARPOP_REQUEST)) {\n\t\t/* Create an entry in the rx_hashtbl for this client as a\n\t\t * place holder.\n\t\t * When the arp reply is received the entry will be updated\n\t\t * with the correct unicast address of the client.\n\t\t */\n\t\ttx_slave = rlb_choose_channel(skb, bond, arp);\n\n\t\t/* The ARP reply packets must be delayed so that\n\t\t * they can cancel out the influence of the ARP request.\n\t\t */\n\t\tbond->alb_info.rlb_update_delay_counter = RLB_UPDATE_DELAY;\n\n\t\t/* arp requests are broadcast and are sent on the primary\n\t\t * the arp request will collapse all clients on the subnet to\n\t\t * the primary slave. We must register these clients to be\n\t\t * updated with their assigned mac.\n\t\t */\n\t\trlb_req_update_subnet_clients(bond, arp->ip_src);\n\t\tnetdev_dbg(bond->dev, \"(slave %s): Server sent ARP Request packet\\n\",\n\t\t\t   tx_slave ? tx_slave->dev->name : \"NULL\");\n\t}\n\n\treturn tx_slave;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,8 +16,11 @@\n \n \tdev = ip_dev_find(dev_net(bond->dev), arp->ip_src);\n \tif (dev) {\n-\t\tif (netif_is_bridge_master(dev))\n+\t\tif (netif_is_bridge_master(dev)) {\n+\t\t\tdev_put(dev);\n \t\t\treturn NULL;\n+\t\t}\n+\t\tdev_put(dev);\n \t}\n \n \tif (arp->op_code == htons(ARPOP_REPLY)) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (netif_is_bridge_master(dev))"
            ],
            "added_lines": [
                "\t\tif (netif_is_bridge_master(dev)) {",
                "\t\t\tdev_put(dev);",
                "\t\t}",
                "\t\tdev_put(dev);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3629",
        "func_name": "kernel/git/klassert/ipsec-next/vsock_connect",
        "description": "A vulnerability was found in Linux Kernel. It has been declared as problematic. This vulnerability affects the function vsock_connect of the file net/vmw_vsock/af_vsock.c. The manipulation leads to memory leak. The complexity of an attack is rather high. The exploitation appears to be difficult. It is recommended to apply a patch to fix this issue. VDB-211930 is the identifier assigned to this vulnerability.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next.git/commit/?h=7e97cfed9929eaabc41829c395eb0d1350fccb9d",
        "commit_title": "An O_NONBLOCK vsock_connect() request may try to reschedule",
        "commit_text": "@connect_work.  Imagine the following sequence of vsock_connect() requests:    1. The 1st, non-blocking request schedules @connect_work, which will      expire after 200 jiffies.  Socket state is now SS_CONNECTING;    2. Later, the 2nd, blocking request gets interrupted by a signal after      a few jiffies while waiting for the connection to be established.      Socket state is back to SS_UNCONNECTED, but @connect_work is still      pending, and will expire after 100 jiffies.    3. Now, the 3rd, non-blocking request tries to schedule @connect_work      again.  Since @connect_work is already scheduled,      schedule_delayed_work() silently returns.  sock_hold() is called      twice, but sock_put() will only be called once in      vsock_connect_timeout(), causing a memory leak reported by syzbot:    BUG: memory leak   unreferenced object 0xffff88810ea56a40 (size 1232):     comm \"syz-executor756\", pid 3604, jiffies 4294947681 (age 12.350s)     hex dump (first 32 bytes):       00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................       28 00 07 40 00 00 00 00 00 00 00 00 00 00 00 00  (..@............     backtrace:       [<ffffffff837c830e>] sk_prot_alloc+0x3e/0x1b0 net/core/sock.c:1930       [<ffffffff837cbe22>] sk_alloc+0x32/0x2e0 net/core/sock.c:1989       [<ffffffff842ccf68>] __vsock_create.constprop.0+0x38/0x320 net/vmw_vsock/af_vsock.c:734       [<ffffffff842ce8f1>] vsock_create+0xc1/0x2d0 net/vmw_vsock/af_vsock.c:2203       [<ffffffff837c0cbb>] __sock_create+0x1ab/0x2b0 net/socket.c:1468       [<ffffffff837c3acf>] sock_create net/socket.c:1519 [inline]       [<ffffffff837c3acf>] __sys_socket+0x6f/0x140 net/socket.c:1561       [<ffffffff837c3bba>] __do_sys_socket net/socket.c:1570 [inline]       [<ffffffff837c3bba>] __se_sys_socket net/socket.c:1568 [inline]       [<ffffffff837c3bba>] __x64_sys_socket+0x1a/0x20 net/socket.c:1568       [<ffffffff84512815>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]       [<ffffffff84512815>] do_syscall_64+0x35/0x80 arch/x86/entry/common.c:80       [<ffffffff84600068>] entry_SYSCALL_64_after_hwframe+0x44/0xae   <...>  Use mod_delayed_work() instead: if @connect_work is already scheduled, reschedule it, and undo sock_hold() to keep the reference count balanced.  Reported-and-tested-by: syzbot+b03f55bf128f9a38f064@syzkaller.appspotmail.com Co-developed-by: Stefano Garzarella <sgarzare@redhat.com> ",
        "func_before": "static int vsock_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len, int flags)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tconst struct vsock_transport *transport;\n\tstruct sockaddr_vm *remote_addr;\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\n\terr = 0;\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\n\tlock_sock(sk);\n\n\t/* XXX AF_UNSPEC should make us disconnect like AF_INET. */\n\tswitch (sock->state) {\n\tcase SS_CONNECTED:\n\t\terr = -EISCONN;\n\t\tgoto out;\n\tcase SS_DISCONNECTING:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\tcase SS_CONNECTING:\n\t\t/* This continues on so we can move sock into the SS_CONNECTED\n\t\t * state once the connection has completed (at which point err\n\t\t * will be set to zero also).  Otherwise, we will either wait\n\t\t * for the connection or return -EALREADY should this be a\n\t\t * non-blocking call.\n\t\t */\n\t\terr = -EALREADY;\n\t\tif (flags & O_NONBLOCK)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tif ((sk->sk_state == TCP_LISTEN) ||\n\t\t    vsock_addr_cast(addr, addr_len, &remote_addr) != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Set the remote address that we are connecting to. */\n\t\tmemcpy(&vsk->remote_addr, remote_addr,\n\t\t       sizeof(vsk->remote_addr));\n\n\t\terr = vsock_assign_transport(vsk, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttransport = vsk->transport;\n\n\t\t/* The hypervisor and well-known contexts do not have socket\n\t\t * endpoints.\n\t\t */\n\t\tif (!transport ||\n\t\t    !transport->stream_allow(remote_addr->svm_cid,\n\t\t\t\t\t     remote_addr->svm_port)) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = vsock_auto_bind(vsk);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tsk->sk_state = TCP_SYN_SENT;\n\n\t\terr = transport->connect(vsk);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\t/* Mark sock as connecting and set the error code to in\n\t\t * progress in case this is a non-blocking connect.\n\t\t */\n\t\tsock->state = SS_CONNECTING;\n\t\terr = -EINPROGRESS;\n\t}\n\n\t/* The receive path will handle all communication until we are able to\n\t * enter the connected state.  Here we wait for the connection to be\n\t * completed or a notification of an error.\n\t */\n\ttimeout = vsk->connect_timeout;\n\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\twhile (sk->sk_state != TCP_ESTABLISHED && sk->sk_err == 0) {\n\t\tif (flags & O_NONBLOCK) {\n\t\t\t/* If we're not going to block, we schedule a timeout\n\t\t\t * function to generate a timeout on the connection\n\t\t\t * attempt, in case the peer doesn't respond in a\n\t\t\t * timely manner. We hold on to the socket until the\n\t\t\t * timeout fires.\n\t\t\t */\n\t\t\tsock_hold(sk);\n\t\t\tschedule_delayed_work(&vsk->connect_work, timeout);\n\n\t\t\t/* Skip ahead to preserve error code set above. */\n\t\t\tgoto out_wait;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tlock_sock(sk);\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeout);\n\t\t\tsk->sk_state = sk->sk_state == TCP_ESTABLISHED ? TCP_CLOSING : TCP_CLOSE;\n\t\t\tsock->state = SS_UNCONNECTED;\n\t\t\tvsock_transport_cancel_pkt(vsk);\n\t\t\tvsock_remove_connected(vsk);\n\t\t\tgoto out_wait;\n\t\t} else if (timeout == 0) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tsk->sk_state = TCP_CLOSE;\n\t\t\tsock->state = SS_UNCONNECTED;\n\t\t\tvsock_transport_cancel_pkt(vsk);\n\t\t\tgoto out_wait;\n\t\t}\n\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t}\n\n\tif (sk->sk_err) {\n\t\terr = -sk->sk_err;\n\t\tsk->sk_state = TCP_CLOSE;\n\t\tsock->state = SS_UNCONNECTED;\n\t} else {\n\t\terr = 0;\n\t}\n\nout_wait:\n\tfinish_wait(sk_sleep(sk), &wait);\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
        "func": "static int vsock_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len, int flags)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tconst struct vsock_transport *transport;\n\tstruct sockaddr_vm *remote_addr;\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\n\terr = 0;\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\n\tlock_sock(sk);\n\n\t/* XXX AF_UNSPEC should make us disconnect like AF_INET. */\n\tswitch (sock->state) {\n\tcase SS_CONNECTED:\n\t\terr = -EISCONN;\n\t\tgoto out;\n\tcase SS_DISCONNECTING:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\tcase SS_CONNECTING:\n\t\t/* This continues on so we can move sock into the SS_CONNECTED\n\t\t * state once the connection has completed (at which point err\n\t\t * will be set to zero also).  Otherwise, we will either wait\n\t\t * for the connection or return -EALREADY should this be a\n\t\t * non-blocking call.\n\t\t */\n\t\terr = -EALREADY;\n\t\tif (flags & O_NONBLOCK)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tif ((sk->sk_state == TCP_LISTEN) ||\n\t\t    vsock_addr_cast(addr, addr_len, &remote_addr) != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Set the remote address that we are connecting to. */\n\t\tmemcpy(&vsk->remote_addr, remote_addr,\n\t\t       sizeof(vsk->remote_addr));\n\n\t\terr = vsock_assign_transport(vsk, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttransport = vsk->transport;\n\n\t\t/* The hypervisor and well-known contexts do not have socket\n\t\t * endpoints.\n\t\t */\n\t\tif (!transport ||\n\t\t    !transport->stream_allow(remote_addr->svm_cid,\n\t\t\t\t\t     remote_addr->svm_port)) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = vsock_auto_bind(vsk);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tsk->sk_state = TCP_SYN_SENT;\n\n\t\terr = transport->connect(vsk);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\t/* Mark sock as connecting and set the error code to in\n\t\t * progress in case this is a non-blocking connect.\n\t\t */\n\t\tsock->state = SS_CONNECTING;\n\t\terr = -EINPROGRESS;\n\t}\n\n\t/* The receive path will handle all communication until we are able to\n\t * enter the connected state.  Here we wait for the connection to be\n\t * completed or a notification of an error.\n\t */\n\ttimeout = vsk->connect_timeout;\n\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\twhile (sk->sk_state != TCP_ESTABLISHED && sk->sk_err == 0) {\n\t\tif (flags & O_NONBLOCK) {\n\t\t\t/* If we're not going to block, we schedule a timeout\n\t\t\t * function to generate a timeout on the connection\n\t\t\t * attempt, in case the peer doesn't respond in a\n\t\t\t * timely manner. We hold on to the socket until the\n\t\t\t * timeout fires.\n\t\t\t */\n\t\t\tsock_hold(sk);\n\n\t\t\t/* If the timeout function is already scheduled,\n\t\t\t * reschedule it, then ungrab the socket refcount to\n\t\t\t * keep it balanced.\n\t\t\t */\n\t\t\tif (mod_delayed_work(system_wq, &vsk->connect_work,\n\t\t\t\t\t     timeout))\n\t\t\t\tsock_put(sk);\n\n\t\t\t/* Skip ahead to preserve error code set above. */\n\t\t\tgoto out_wait;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tlock_sock(sk);\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeout);\n\t\t\tsk->sk_state = sk->sk_state == TCP_ESTABLISHED ? TCP_CLOSING : TCP_CLOSE;\n\t\t\tsock->state = SS_UNCONNECTED;\n\t\t\tvsock_transport_cancel_pkt(vsk);\n\t\t\tvsock_remove_connected(vsk);\n\t\t\tgoto out_wait;\n\t\t} else if (timeout == 0) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tsk->sk_state = TCP_CLOSE;\n\t\t\tsock->state = SS_UNCONNECTED;\n\t\t\tvsock_transport_cancel_pkt(vsk);\n\t\t\tgoto out_wait;\n\t\t}\n\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t}\n\n\tif (sk->sk_err) {\n\t\terr = -sk->sk_err;\n\t\tsk->sk_state = TCP_CLOSE;\n\t\tsock->state = SS_UNCONNECTED;\n\t} else {\n\t\terr = 0;\n\t}\n\nout_wait:\n\tfinish_wait(sk_sleep(sk), &wait);\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -94,7 +94,14 @@\n \t\t\t * timeout fires.\n \t\t\t */\n \t\t\tsock_hold(sk);\n-\t\t\tschedule_delayed_work(&vsk->connect_work, timeout);\n+\n+\t\t\t/* If the timeout function is already scheduled,\n+\t\t\t * reschedule it, then ungrab the socket refcount to\n+\t\t\t * keep it balanced.\n+\t\t\t */\n+\t\t\tif (mod_delayed_work(system_wq, &vsk->connect_work,\n+\t\t\t\t\t     timeout))\n+\t\t\t\tsock_put(sk);\n \n \t\t\t/* Skip ahead to preserve error code set above. */\n \t\t\tgoto out_wait;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tschedule_delayed_work(&vsk->connect_work, timeout);"
            ],
            "added_lines": [
                "",
                "\t\t\t/* If the timeout function is already scheduled,",
                "\t\t\t * reschedule it, then ungrab the socket refcount to",
                "\t\t\t * keep it balanced.",
                "\t\t\t */",
                "\t\t\tif (mod_delayed_work(system_wq, &vsk->connect_work,",
                "\t\t\t\t\t     timeout))",
                "\t\t\t\tsock_put(sk);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3630",
        "func_name": "kernel/git/klassert/ipsec-next/__fscache_invalidate",
        "description": "A vulnerability was found in Linux Kernel. It has been rated as problematic. This issue affects some unknown processing of the file fs/fscache/cookie.c of the component IPsec. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211931.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next.git/commit/?h=fb24771faf72a2fd62b3b6287af3c610c3ec9cf1",
        "commit_title": "It's possible for a request to invalidate a fscache_cookie will come in",
        "commit_text": "while we're already processing an invalidation. If that happens we currently take an extra access reference that will leak. Only call __fscache_begin_cookie_access if the FSCACHE_COOKIE_DO_INVALIDATE bit was previously clear.  Also, ensure that we attempt to clear the bit when the cookie is \"FAILED\" and put the reference to avoid an access leak.  Suggested-by: David Howells <dhowells@redhat.com> ",
        "func_before": "void __fscache_invalidate(struct fscache_cookie *cookie,\n\t\t\t  const void *aux_data, loff_t new_size,\n\t\t\t  unsigned int flags)\n{\n\tbool is_caching;\n\n\t_enter(\"c=%x\", cookie->debug_id);\n\n\tfscache_stat(&fscache_n_invalidates);\n\n\tif (WARN(test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags),\n\t\t \"Trying to invalidate relinquished cookie\\n\"))\n\t\treturn;\n\n\tif ((flags & FSCACHE_INVAL_DIO_WRITE) &&\n\t    test_and_set_bit(FSCACHE_COOKIE_DISABLED, &cookie->flags))\n\t\treturn;\n\n\tspin_lock(&cookie->lock);\n\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\tfscache_update_aux(cookie, aux_data, &new_size);\n\tcookie->inval_counter++;\n\ttrace_fscache_invalidate(cookie, new_size);\n\n\tswitch (cookie->state) {\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING: /* is_still_valid will catch it */\n\tdefault:\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" [no %u]\", cookie->state);\n\t\treturn;\n\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\t\t__fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie);\n\t\tset_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags);\n\t\tfallthrough;\n\tcase FSCACHE_COOKIE_STATE_CREATING:\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" [look %x]\", cookie->inval_counter);\n\t\treturn;\n\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tis_caching = fscache_begin_cookie_access(\n\t\t\tcookie, fscache_access_invalidate_cookie);\n\t\tif (is_caching)\n\t\t\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_INVALIDATING);\n\t\tspin_unlock(&cookie->lock);\n\t\twake_up_cookie_state(cookie);\n\n\t\tif (is_caching)\n\t\t\tfscache_queue_cookie(cookie, fscache_cookie_get_inval_work);\n\t\t_leave(\" [inv]\");\n\t\treturn;\n\t}\n}",
        "func": "void __fscache_invalidate(struct fscache_cookie *cookie,\n\t\t\t  const void *aux_data, loff_t new_size,\n\t\t\t  unsigned int flags)\n{\n\tbool is_caching;\n\n\t_enter(\"c=%x\", cookie->debug_id);\n\n\tfscache_stat(&fscache_n_invalidates);\n\n\tif (WARN(test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags),\n\t\t \"Trying to invalidate relinquished cookie\\n\"))\n\t\treturn;\n\n\tif ((flags & FSCACHE_INVAL_DIO_WRITE) &&\n\t    test_and_set_bit(FSCACHE_COOKIE_DISABLED, &cookie->flags))\n\t\treturn;\n\n\tspin_lock(&cookie->lock);\n\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\tfscache_update_aux(cookie, aux_data, &new_size);\n\tcookie->inval_counter++;\n\ttrace_fscache_invalidate(cookie, new_size);\n\n\tswitch (cookie->state) {\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING: /* is_still_valid will catch it */\n\tdefault:\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" [no %u]\", cookie->state);\n\t\treturn;\n\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\t\tif (!test_and_set_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\t__fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie);\n\t\tfallthrough;\n\tcase FSCACHE_COOKIE_STATE_CREATING:\n\t\tspin_unlock(&cookie->lock);\n\t\t_leave(\" [look %x]\", cookie->inval_counter);\n\t\treturn;\n\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tis_caching = fscache_begin_cookie_access(\n\t\t\tcookie, fscache_access_invalidate_cookie);\n\t\tif (is_caching)\n\t\t\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_INVALIDATING);\n\t\tspin_unlock(&cookie->lock);\n\t\twake_up_cookie_state(cookie);\n\n\t\tif (is_caching)\n\t\t\tfscache_queue_cookie(cookie, fscache_cookie_get_inval_work);\n\t\t_leave(\" [inv]\");\n\t\treturn;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,8 +30,8 @@\n \t\treturn;\n \n \tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n-\t\t__fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie);\n-\t\tset_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags);\n+\t\tif (!test_and_set_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n+\t\t\t__fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie);\n \t\tfallthrough;\n \tcase FSCACHE_COOKIE_STATE_CREATING:\n \t\tspin_unlock(&cookie->lock);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t__fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie);",
                "\t\tset_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags);"
            ],
            "added_lines": [
                "\t\tif (!test_and_set_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))",
                "\t\t\t__fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3630",
        "func_name": "kernel/git/klassert/ipsec-next/fscache_cookie_state_machine",
        "description": "A vulnerability was found in Linux Kernel. It has been rated as problematic. This issue affects some unknown processing of the file fs/fscache/cookie.c of the component IPsec. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211931.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next.git/commit/?h=fb24771faf72a2fd62b3b6287af3c610c3ec9cf1",
        "commit_title": "It's possible for a request to invalidate a fscache_cookie will come in",
        "commit_text": "while we're already processing an invalidation. If that happens we currently take an extra access reference that will leak. Only call __fscache_begin_cookie_access if the FSCACHE_COOKIE_DO_INVALIDATE bit was previously clear.  Also, ensure that we attempt to clear the bit when the cookie is \"FAILED\" and put the reference to avoid an access leak.  Suggested-by: David Howells <dhowells@redhat.com> ",
        "func_before": "static void fscache_cookie_state_machine(struct fscache_cookie *cookie)\n{\n\tenum fscache_cookie_state state;\n\tbool wake = false;\n\n\t_enter(\"c=%x\", cookie->debug_id);\n\nagain:\n\tspin_lock(&cookie->lock);\nagain_locked:\n\tstate = cookie->state;\n\tswitch (state) {\n\tcase FSCACHE_COOKIE_STATE_QUIESCENT:\n\t\t/* The QUIESCENT state is jumped to the LOOKING_UP state by\n\t\t * fscache_use_cookie().\n\t\t */\n\n\t\tif (atomic_read(&cookie->n_accesses) == 0 &&\n\t\t    test_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_RELINQUISHING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_init_access_gate(cookie);\n\t\tfscache_perform_lookup(cookie);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING:\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_perform_invalidation(cookie);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags)) {\n\t\t\tspin_unlock(&cookie->lock);\n\t\t\tfscache_prepare_to_write(cookie);\n\t\t\tspin_lock(&cookie->lock);\n\t\t}\n\t\tif (test_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_LRU_DISCARDING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tfallthrough;\n\n\tcase FSCACHE_COOKIE_STATE_FAILED:\n\t\tif (atomic_read(&cookie->n_accesses) != 0)\n\t\t\tbreak;\n\t\tif (test_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_RELINQUISHING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tif (test_bit(FSCACHE_COOKIE_DO_WITHDRAW, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_WITHDRAWING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\tcase FSCACHE_COOKIE_STATE_WITHDRAWING:\n\t\tif (cookie->cache_priv) {\n\t\t\tspin_unlock(&cookie->lock);\n\t\t\tcookie->volume->cache->ops->withdraw_cookie(cookie);\n\t\t\tspin_lock(&cookie->lock);\n\t\t}\n\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);\n\n\t\tswitch (state) {\n\t\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_relinquish);\n\t\t\tfscache_unhash_cookie(cookie);\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_DROPPED);\n\t\t\twake = true;\n\t\t\tgoto out;\n\t\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_lru_discard);\n\t\t\tbreak;\n\t\tcase FSCACHE_COOKIE_STATE_WITHDRAWING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_withdraw);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_bit(FSCACHE_COOKIE_NEEDS_UPDATE, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_WITHDRAW, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\t\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_QUIESCENT);\n\t\twake = true;\n\t\tgoto again_locked;\n\n\tcase FSCACHE_COOKIE_STATE_DROPPED:\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ONCE(1, \"Cookie %x in unexpected state %u\\n\",\n\t\t\t  cookie->debug_id, state);\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&cookie->lock);\n\tif (wake)\n\t\twake_up_cookie_state(cookie);\n\t_leave(\"\");\n}",
        "func": "static void fscache_cookie_state_machine(struct fscache_cookie *cookie)\n{\n\tenum fscache_cookie_state state;\n\tbool wake = false;\n\n\t_enter(\"c=%x\", cookie->debug_id);\n\nagain:\n\tspin_lock(&cookie->lock);\nagain_locked:\n\tstate = cookie->state;\n\tswitch (state) {\n\tcase FSCACHE_COOKIE_STATE_QUIESCENT:\n\t\t/* The QUIESCENT state is jumped to the LOOKING_UP state by\n\t\t * fscache_use_cookie().\n\t\t */\n\n\t\tif (atomic_read(&cookie->n_accesses) == 0 &&\n\t\t    test_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_RELINQUISHING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_init_access_gate(cookie);\n\t\tfscache_perform_lookup(cookie);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING:\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_perform_invalidation(cookie);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags)) {\n\t\t\tspin_unlock(&cookie->lock);\n\t\t\tfscache_prepare_to_write(cookie);\n\t\t\tspin_lock(&cookie->lock);\n\t\t}\n\t\tif (test_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_LRU_DISCARDING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tfallthrough;\n\n\tcase FSCACHE_COOKIE_STATE_FAILED:\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);\n\n\t\tif (atomic_read(&cookie->n_accesses) != 0)\n\t\t\tbreak;\n\t\tif (test_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_RELINQUISHING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tif (test_bit(FSCACHE_COOKIE_DO_WITHDRAW, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_WITHDRAWING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\tcase FSCACHE_COOKIE_STATE_WITHDRAWING:\n\t\tif (cookie->cache_priv) {\n\t\t\tspin_unlock(&cookie->lock);\n\t\t\tcookie->volume->cache->ops->withdraw_cookie(cookie);\n\t\t\tspin_lock(&cookie->lock);\n\t\t}\n\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);\n\n\t\tswitch (state) {\n\t\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_relinquish);\n\t\t\tfscache_unhash_cookie(cookie);\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_DROPPED);\n\t\t\twake = true;\n\t\t\tgoto out;\n\t\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_lru_discard);\n\t\t\tbreak;\n\t\tcase FSCACHE_COOKIE_STATE_WITHDRAWING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_withdraw);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_bit(FSCACHE_COOKIE_NEEDS_UPDATE, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_WITHDRAW, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\t\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_QUIESCENT);\n\t\twake = true;\n\t\tgoto again_locked;\n\n\tcase FSCACHE_COOKIE_STATE_DROPPED:\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ONCE(1, \"Cookie %x in unexpected state %u\\n\",\n\t\t\t  cookie->debug_id, state);\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&cookie->lock);\n\tif (wake)\n\t\twake_up_cookie_state(cookie);\n\t_leave(\"\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,6 +50,9 @@\n \t\tfallthrough;\n \n \tcase FSCACHE_COOKIE_STATE_FAILED:\n+\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n+\t\t\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);\n+\n \t\tif (atomic_read(&cookie->n_accesses) != 0)\n \t\t\tbreak;\n \t\tif (test_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags)) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))",
                "\t\t\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3633",
        "func_name": "kernel/git/klassert/ipsec-next/j1939_session_destroy",
        "description": "A vulnerability classified as problematic has been found in Linux Kernel. Affected is the function j1939_session_destroy of the file net/can/j1939/transport.c. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211932.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next.git/commit/?h=8c21c54a53ab21842f5050fa090f26b03c0313d6",
        "commit_title": "We need to drop skb references taken in j1939_session_skb_queue() when",
        "commit_text": "destroying a session in j1939_session_destroy(). Otherwise those skbs would be lost.  Link to Syzkaller info and repro: https://forge.ispras.ru/issues/11743.  Found by Linux Verification Center (linuxtesting.org) with Syzkaller.  V1: https://lore.kernel.org/all/20220708175949.539064-1-pchelkin@ispras.ru  Suggested-by: Oleksij Rempel <o.rempel@pengutronix.de> Link: https://lore.kernel.org/all/20220805150216.66313-1-pchelkin@ispras.ru ",
        "func_before": "static void j1939_session_destroy(struct j1939_session *session)\n{\n\tif (session->transmission) {\n\t\tif (session->err)\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_TX_ABORT);\n\t\telse\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_TX_ACK);\n\t} else if (session->err) {\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_RX_ABORT);\n\t}\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\tWARN_ON_ONCE(!list_empty(&session->sk_session_queue_entry));\n\tWARN_ON_ONCE(!list_empty(&session->active_session_list_entry));\n\n\tskb_queue_purge(&session->skb_queue);\n\t__j1939_session_drop(session);\n\tj1939_priv_put(session->priv);\n\tkfree(session);\n}",
        "func": "static void j1939_session_destroy(struct j1939_session *session)\n{\n\tstruct sk_buff *skb;\n\n\tif (session->transmission) {\n\t\tif (session->err)\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_TX_ABORT);\n\t\telse\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_TX_ACK);\n\t} else if (session->err) {\n\t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_RX_ABORT);\n\t}\n\n\tnetdev_dbg(session->priv->ndev, \"%s: 0x%p\\n\", __func__, session);\n\n\tWARN_ON_ONCE(!list_empty(&session->sk_session_queue_entry));\n\tWARN_ON_ONCE(!list_empty(&session->active_session_list_entry));\n\n\twhile ((skb = skb_dequeue(&session->skb_queue)) != NULL) {\n\t\t/* drop ref taken in j1939_session_skb_queue() */\n\t\tskb_unref(skb);\n\t\tkfree_skb(skb);\n\t}\n\t__j1939_session_drop(session);\n\tj1939_priv_put(session->priv);\n\tkfree(session);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n static void j1939_session_destroy(struct j1939_session *session)\n {\n+\tstruct sk_buff *skb;\n+\n \tif (session->transmission) {\n \t\tif (session->err)\n \t\t\tj1939_sk_errqueue(session, J1939_ERRQUEUE_TX_ABORT);\n@@ -14,7 +16,11 @@\n \tWARN_ON_ONCE(!list_empty(&session->sk_session_queue_entry));\n \tWARN_ON_ONCE(!list_empty(&session->active_session_list_entry));\n \n-\tskb_queue_purge(&session->skb_queue);\n+\twhile ((skb = skb_dequeue(&session->skb_queue)) != NULL) {\n+\t\t/* drop ref taken in j1939_session_skb_queue() */\n+\t\tskb_unref(skb);\n+\t\tkfree_skb(skb);\n+\t}\n \t__j1939_session_drop(session);\n \tj1939_priv_put(session->priv);\n \tkfree(session);",
        "diff_line_info": {
            "deleted_lines": [
                "\tskb_queue_purge(&session->skb_queue);"
            ],
            "added_lines": [
                "\tstruct sk_buff *skb;",
                "",
                "\twhile ((skb = skb_dequeue(&session->skb_queue)) != NULL) {",
                "\t\t/* drop ref taken in j1939_session_skb_queue() */",
                "\t\tskb_unref(skb);",
                "\t\tkfree_skb(skb);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-43151",
        "func_name": "hzeller/timg/QueryBackgroundColor",
        "description": "timg v1.4.4 was discovered to contain a memory leak via the function timg::QueryBackgroundColor() at /timg/src/term-query.cc.",
        "git_url": "https://github.com/hzeller/timg/commit/e9667ea2c811aa9eb399b631aef9bba0d3711834",
        "commit_title": "Remove memory leak.",
        "commit_text": " Fixes #92",
        "func_before": "char *QueryBackgroundColor() {\n    // The response might take a while. Typically, this should be only a\n    // few milliseconds, but there can be situations over slow ssh\n    // connections or very slow machines where it takes a little.\n    // Allocate some overall budget of time we allow for this to finish.\n    // We're running this asynchronously, so we already can start decoding\n    // images while this query is still running. Only the first image that\n    // actually needs transparency alpha blending would have to wait for the\n    // result if it is not there already. No impact on other images.\n    //\n    // Budget relatively high to accomodate for slow machine/flaky\n    // network (testing on a Raspberry Pi Zero W over flaky wireless\n    // connection resulted in up to 1.2ish seconds).\n    const Duration kTimeBudget = Duration::Millis(1500);\n\n    constexpr char query_background_color[] = \"\\033]11;?\\033\\\\\";\n    constexpr size_t kColorLen = 18;  // strlen(\"rgb:1234/1234/1234\")\n\n    // Query and testing the response. It is the query-string with the\n    // question mark replaced with the requested information.\n    //\n    // We have to deal with two situations\n    //  * The response might take a while (see above in kTimeBudget)\n    //    and have to wait for the full time budget.\n    //  * Unfortunately, we can't shorten that time with the trick we do\n    //    below with a DSR 5 dummy query: turns out that alacritty answers\n    //    these out-of-order https://github.com/alacritty/alacritty/issues/4872\n    //  * The terminal outputs the response as if it was 'typed in', so we\n    //    might not only get the response from the terminal itself, but also\n    //    characters from user pressing a key while we do our query.\n    //    So we might get random bytes before the actual response, possibly\n    //    in multiple read calls until we actually get something we expect.\n    //    Make sure to accumulate reads in a more spacious buffer than the\n    //    expected response and finish once we found what we're looking for.\n    char buffer[512];\n    const char *const start_color = QueryTerminal(\n        query_background_color, buffer, sizeof(buffer), kTimeBudget,\n        [](const char *data, size_t len) -> const char * {\n            // We might've gotten some spurious bytes in the beginning from\n            // keypresses, so find where the color starts.\n            const char *found = (const char *)memmem(data, len, \"rgb:\", 4);\n            if (found && len - (found - data) > kColorLen)  // at least 1 more\n                return found;  // Found start of color sequence and enough\n                               // bytes.\n            return nullptr;\n        });\n\n    if (!start_color) return nullptr;\n\n    // Assemble a standard #rrggbb string into our existing buffer.\n    // NB, save, as this is not overlapping buffer areas\n    buffer[0] = '#';\n    memcpy(&buffer[1], &start_color[4], 2);\n    memcpy(&buffer[3], &start_color[9], 2);\n    memcpy(&buffer[5], &start_color[14], 2);\n    buffer[7] = '\\0';\n\n    return strdup(buffer);\n}",
        "func": "const char *QueryBackgroundColor() {\n    // The response might take a while. Typically, this should be only a\n    // few milliseconds, but there can be situations over slow ssh\n    // connections or very slow machines where it takes a little.\n    // Allocate some overall budget of time we allow for this to finish.\n    // We're running this asynchronously, so we already can start decoding\n    // images while this query is still running. Only the first image that\n    // actually needs transparency alpha blending would have to wait for the\n    // result if it is not there already. No impact on other images.\n    //\n    // Budget relatively high to accomodate for slow machine/flaky\n    // network (testing on a Raspberry Pi Zero W over flaky wireless\n    // connection resulted in up to 1.2ish seconds).\n    const Duration kTimeBudget = Duration::Millis(1500);\n\n    constexpr char query_background_color[] = \"\\033]11;?\\033\\\\\";\n    constexpr size_t kColorLen = 18;  // strlen(\"rgb:1234/1234/1234\")\n\n    // Query and testing the response. It is the query-string with the\n    // question mark replaced with the requested information.\n    //\n    // We have to deal with two situations\n    //  * The response might take a while (see above in kTimeBudget)\n    //    and have to wait for the full time budget.\n    //  * Unfortunately, we can't shorten that time with the trick we do\n    //    below with a DSR 5 dummy query: turns out that alacritty answers\n    //    these out-of-order https://github.com/alacritty/alacritty/issues/4872\n    //  * The terminal outputs the response as if it was 'typed in', so we\n    //    might not only get the response from the terminal itself, but also\n    //    characters from user pressing a key while we do our query.\n    //    So we might get random bytes before the actual response, possibly\n    //    in multiple read calls until we actually get something we expect.\n    //    Make sure to accumulate reads in a more spacious buffer than the\n    //    expected response and finish once we found what we're looking for.\n    char buffer[512];\n    const char *const start_color = QueryTerminal(\n        query_background_color, buffer, sizeof(buffer), kTimeBudget,\n        [](const char *data, size_t len) -> const char * {\n            // We might've gotten some spurious bytes in the beginning from\n            // keypresses, so find where the color starts.\n            const char *found = (const char *)memmem(data, len, \"rgb:\", 4);\n            if (found && len - (found - data) > kColorLen)  // at least 1 more\n                return found;  // Found start of color sequence and enough\n                               // bytes.\n            return nullptr;\n        });\n\n    if (!start_color) return nullptr;\n\n    // Assemble a standard #rrggbb string into global static buffer.\n    static char result[8];\n    result[0] = '#';\n    memcpy(&result[1], &start_color[4], 2);\n    memcpy(&result[3], &start_color[9], 2);\n    memcpy(&result[5], &start_color[14], 2);\n    result[7] = '\\0';\n\n    return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-char *QueryBackgroundColor() {\n+const char *QueryBackgroundColor() {\n     // The response might take a while. Typically, this should be only a\n     // few milliseconds, but there can be situations over slow ssh\n     // connections or very slow machines where it takes a little.\n@@ -47,13 +47,13 @@\n \n     if (!start_color) return nullptr;\n \n-    // Assemble a standard #rrggbb string into our existing buffer.\n-    // NB, save, as this is not overlapping buffer areas\n-    buffer[0] = '#';\n-    memcpy(&buffer[1], &start_color[4], 2);\n-    memcpy(&buffer[3], &start_color[9], 2);\n-    memcpy(&buffer[5], &start_color[14], 2);\n-    buffer[7] = '\\0';\n+    // Assemble a standard #rrggbb string into global static buffer.\n+    static char result[8];\n+    result[0] = '#';\n+    memcpy(&result[1], &start_color[4], 2);\n+    memcpy(&result[3], &start_color[9], 2);\n+    memcpy(&result[5], &start_color[14], 2);\n+    result[7] = '\\0';\n \n-    return strdup(buffer);\n+    return result;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "char *QueryBackgroundColor() {",
                "    // Assemble a standard #rrggbb string into our existing buffer.",
                "    // NB, save, as this is not overlapping buffer areas",
                "    buffer[0] = '#';",
                "    memcpy(&buffer[1], &start_color[4], 2);",
                "    memcpy(&buffer[3], &start_color[9], 2);",
                "    memcpy(&buffer[5], &start_color[14], 2);",
                "    buffer[7] = '\\0';",
                "    return strdup(buffer);"
            ],
            "added_lines": [
                "const char *QueryBackgroundColor() {",
                "    // Assemble a standard #rrggbb string into global static buffer.",
                "    static char result[8];",
                "    result[0] = '#';",
                "    memcpy(&result[1], &start_color[4], 2);",
                "    memcpy(&result[3], &start_color[9], 2);",
                "    memcpy(&result[5], &start_color[14], 2);",
                "    result[7] = '\\0';",
                "    return result;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-43151",
        "func_name": "hzeller/timg/BufferedWriteSequencer::~BufferedWriteSequencer",
        "description": "timg v1.4.4 was discovered to contain a memory leak via the function timg::QueryBackgroundColor() at /timg/src/term-query.cc.",
        "git_url": "https://github.com/hzeller/timg/commit/e9667ea2c811aa9eb399b631aef9bba0d3711834",
        "commit_title": "Remove memory leak.",
        "commit_text": " Fixes #92",
        "func_before": "BufferedWriteSequencer::~BufferedWriteSequencer() {\n    Flush();\n    {\n        std::lock_guard<std::mutex> l(work_lock_);\n        work_.push({nullptr, 0, SeqType::ControlWrite, {}});  // Exit condition\n    }\n    work_sync_.notify_all();\n    work_executor_->join();\n    while (!mempool_.empty()) {\n        free(mempool_.front());\n        mempool_.pop();\n    }\n}",
        "func": "BufferedWriteSequencer::~BufferedWriteSequencer() {\n    Flush();\n    {\n        std::lock_guard<std::mutex> l(work_lock_);\n        work_.push({nullptr, 0, SeqType::ControlWrite, {}});  // Exit condition\n    }\n    work_sync_.notify_all();\n    work_executor_->join();\n    while (!mempool_.empty()) {\n        free(mempool_.front());\n        mempool_.pop();\n    }\n    delete work_executor_;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,4 +10,5 @@\n         free(mempool_.front());\n         mempool_.pop();\n     }\n+    delete work_executor_;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    delete work_executor_;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/build",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/d174fefa90487ddd25ebc618028f67b2e8a1f795",
        "commit_title": "tools/xenstore: make the internal memory data base the default",
        "commit_text": " Having a file backed data base has the only advantage of being capable to dump the contents of it while Xenstore is running, and potentially using less swap space in case the data base can't be kept in memory.  It has the major disadvantage of a huge performance overhead: switching to keep the data base in memory only speeds up live update of xenstored with 120000 nodes from 20 minutes to 11 seconds. A complete tree walk of this configuration will be reduced from 7 seconds to 280 msecs (measured by \"xenstore-control check\").  So make the internal memory data base the default and enhance the \"--internal-db\" command line parameter to take an optional parameter allowing to switch the internal data base back to the file based one.  This is part of XSA-419. ",
        "func_before": "static int build(xc_interface *xch)\n{\n    char cmdline[512];\n    int rv, xs_fd;\n    struct xc_dom_image *dom = NULL;\n    int limit_kb = (maxmem ? : memory) * 1024 + X86_HVM_NR_SPECIAL_PAGES * 4;\n    uint64_t mem_size = MB(memory);\n    uint64_t max_size = MB(maxmem ? : memory);\n    struct e820entry e820[3];\n    struct xen_domctl_createdomain config = {\n        .ssidref = SECINITSID_DOMU,\n        .flags = XEN_DOMCTL_CDF_xs_domain,\n        .max_vcpus = 1,\n        .max_evtchn_port = -1, /* No limit. */\n\n        /*\n         * 1 grant frame is enough: we don't need many grants.\n         * Mini-OS doesn't like less than 4, though, so use 4.\n         * 128 maptrack frames: 256 entries per frame, enough for 32768 domains.\n         * Currently Mini-OS only supports grant v1.\n         */\n        .max_grant_frames = 4,\n        .max_maptrack_frames = 128,\n        .grant_opts = XEN_DOMCTL_GRANT_version(1),\n    };\n\n    xs_fd = open(\"/dev/xen/xenbus_backend\", O_RDWR);\n    if ( xs_fd == -1 )\n    {\n        fprintf(stderr, \"Could not open /dev/xen/xenbus_backend\\n\");\n        return -1;\n    }\n\n    if ( flask )\n    {\n        rv = xc_flask_context_to_sid(xch, flask, strlen(flask), &config.ssidref);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_flask_context_to_sid failed\\n\");\n            goto err;\n        }\n    }\n\n    dom = xc_dom_allocate(xch, NULL, NULL);\n    if ( !dom )\n    {\n        fprintf(stderr, \"xc_dom_allocate failed\\n\");\n        rv = -1;\n        goto err;\n    }\n\n    rv = xc_dom_kernel_file(dom, kernel);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_kernel_file failed\\n\");\n        goto err;\n    }\n\n    if ( ramdisk )\n    {\n        rv = xc_dom_module_file(dom, ramdisk, NULL);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_dom_module_file failed\\n\");\n            goto err;\n        }\n    }\n\n    rv = xc_dom_boot_xen_init(dom, xch, domid);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_boot_xen_init failed\\n\");\n        goto err;\n    }\n\n    dom->container_type = XC_DOM_HVM_CONTAINER;\n    rv = xc_dom_parse_image(dom);\n    if ( rv )\n    {\n        dom->container_type = XC_DOM_PV_CONTAINER;\n        rv = xc_dom_parse_image(dom);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_dom_parse_image failed\\n\");\n            goto err;\n        }\n    }\n    else\n    {\n        config.flags |= XEN_DOMCTL_CDF_hvm | XEN_DOMCTL_CDF_hap;\n        config.arch.emulation_flags = XEN_X86_EMU_LAPIC;\n        dom->target_pages = mem_size >> XC_PAGE_SHIFT;\n        dom->mmio_size = GB(4) - LAPIC_BASE_ADDRESS;\n        dom->lowmem_end = (mem_size > LAPIC_BASE_ADDRESS) ?\n                          LAPIC_BASE_ADDRESS : mem_size;\n        dom->highmem_end = (mem_size > LAPIC_BASE_ADDRESS) ?\n                           GB(4) + mem_size - LAPIC_BASE_ADDRESS : 0;\n        dom->mmio_start = LAPIC_BASE_ADDRESS;\n        dom->max_vcpus = 1;\n        e820[0].addr = 0;\n        e820[0].size = (max_size > LAPIC_BASE_ADDRESS) ?\n                       LAPIC_BASE_ADDRESS : max_size;\n        e820[0].type = E820_RAM;\n        e820[1].addr = (X86_HVM_END_SPECIAL_REGION -\n                        X86_HVM_NR_SPECIAL_PAGES) << XC_PAGE_SHIFT;\n        e820[1].size = X86_HVM_NR_SPECIAL_PAGES << XC_PAGE_SHIFT;\n        e820[1].type = E820_RESERVED;\n        e820[2].addr = GB(4);\n        e820[2].size = (max_size > LAPIC_BASE_ADDRESS) ?\n                       max_size - LAPIC_BASE_ADDRESS : 0;\n        e820[2].type = E820_RAM;\n    }\n\n    rv = xc_domain_create(xch, &domid, &config);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_create failed\\n\");\n        goto err;\n    }\n    rv = xc_domain_max_vcpus(xch, domid, config.max_vcpus);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_max_vcpus failed\\n\");\n        goto err;\n    }\n    rv = xc_domain_setmaxmem(xch, domid, limit_kb);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_setmaxmem failed\\n\");\n        goto err;\n    }\n    console_evtchn = xc_evtchn_alloc_unbound(xch, domid, 0);\n    if ( console_evtchn < 0 )\n    {\n        fprintf(stderr, \"xc_evtchn_alloc_unbound failed\\n\");\n        goto err;\n    }\n\n    if ( dom->container_type == XC_DOM_PV_CONTAINER )\n    {\n        rv = xc_domain_set_memmap_limit(xch, domid, limit_kb);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_domain_set_memmap_limit failed\\n\");\n            goto err;\n        }\n    }\n\n    rv = ioctl(xs_fd, IOCTL_XENBUS_BACKEND_SETUP, domid);\n    if ( rv < 0 )\n    {\n        fprintf(stderr, \"Xenbus setup ioctl failed\\n\");\n        goto err;\n    }\n\n    if ( param )\n        snprintf(cmdline, 512, \"--event %d --internal-db %s\", rv, param);\n    else\n        snprintf(cmdline, 512, \"--event %d --internal-db\", rv);\n\n    dom->guest_domid = domid;\n    dom->cmdline = xc_dom_strdup(dom, cmdline);\n    dom->xenstore_domid = domid;\n    dom->console_evtchn = console_evtchn;\n\n    rv = xc_dom_mem_init(dom, memory);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_mem_init failed\\n\");\n        goto err;\n    }\n    rv = xc_dom_boot_mem_init(dom);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_boot_mem_init failed\\n\");\n        goto err;\n    }\n    if ( dom->container_type == XC_DOM_HVM_CONTAINER )\n    {\n        rv = xc_domain_set_memory_map(xch, domid, e820,\n                                      dom->highmem_end ? 3 : 2);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_domain_set_memory_map failed\\n\");\n            goto err;\n        }\n    }\n    rv = xc_dom_build_image(dom);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_build_image failed\\n\");\n        goto err;\n    }\n    rv = xc_dom_boot_image(dom);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_boot_image failed\\n\");\n        goto err;\n    }\n    rv = xc_dom_gnttab_init(dom);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_gnttab_init failed\\n\");\n        goto err;\n    }\n\n    rv = xc_domain_set_virq_handler(xch, domid, VIRQ_DOM_EXC);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_set_virq_handler failed\\n\");\n        goto err;\n    }\n    rv = xc_domain_unpause(xch, domid);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_unpause failed\\n\");\n        goto err;\n    }\n\n    rv = 0;\n    console_gfn = (dom->container_type == XC_DOM_PV_CONTAINER)\n                  ? xc_dom_p2m(dom, dom->console_pfn)\n                  : dom->console_pfn;\n\nerr:\n    if ( dom )\n        xc_dom_release(dom);\n    if ( xs_fd >= 0 )\n        close(xs_fd);\n\n    /* if we failed then destroy the domain */\n    if ( rv && domid != ~0 )\n        xc_domain_destroy(xch, domid);\n\n    return rv;\n}",
        "func": "static int build(xc_interface *xch)\n{\n    char cmdline[512];\n    int rv, xs_fd;\n    struct xc_dom_image *dom = NULL;\n    int limit_kb = (maxmem ? : memory) * 1024 + X86_HVM_NR_SPECIAL_PAGES * 4;\n    uint64_t mem_size = MB(memory);\n    uint64_t max_size = MB(maxmem ? : memory);\n    struct e820entry e820[3];\n    struct xen_domctl_createdomain config = {\n        .ssidref = SECINITSID_DOMU,\n        .flags = XEN_DOMCTL_CDF_xs_domain,\n        .max_vcpus = 1,\n        .max_evtchn_port = -1, /* No limit. */\n\n        /*\n         * 1 grant frame is enough: we don't need many grants.\n         * Mini-OS doesn't like less than 4, though, so use 4.\n         * 128 maptrack frames: 256 entries per frame, enough for 32768 domains.\n         * Currently Mini-OS only supports grant v1.\n         */\n        .max_grant_frames = 4,\n        .max_maptrack_frames = 128,\n        .grant_opts = XEN_DOMCTL_GRANT_version(1),\n    };\n\n    xs_fd = open(\"/dev/xen/xenbus_backend\", O_RDWR);\n    if ( xs_fd == -1 )\n    {\n        fprintf(stderr, \"Could not open /dev/xen/xenbus_backend\\n\");\n        return -1;\n    }\n\n    if ( flask )\n    {\n        rv = xc_flask_context_to_sid(xch, flask, strlen(flask), &config.ssidref);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_flask_context_to_sid failed\\n\");\n            goto err;\n        }\n    }\n\n    dom = xc_dom_allocate(xch, NULL, NULL);\n    if ( !dom )\n    {\n        fprintf(stderr, \"xc_dom_allocate failed\\n\");\n        rv = -1;\n        goto err;\n    }\n\n    rv = xc_dom_kernel_file(dom, kernel);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_kernel_file failed\\n\");\n        goto err;\n    }\n\n    if ( ramdisk )\n    {\n        rv = xc_dom_module_file(dom, ramdisk, NULL);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_dom_module_file failed\\n\");\n            goto err;\n        }\n    }\n\n    rv = xc_dom_boot_xen_init(dom, xch, domid);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_boot_xen_init failed\\n\");\n        goto err;\n    }\n\n    dom->container_type = XC_DOM_HVM_CONTAINER;\n    rv = xc_dom_parse_image(dom);\n    if ( rv )\n    {\n        dom->container_type = XC_DOM_PV_CONTAINER;\n        rv = xc_dom_parse_image(dom);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_dom_parse_image failed\\n\");\n            goto err;\n        }\n    }\n    else\n    {\n        config.flags |= XEN_DOMCTL_CDF_hvm | XEN_DOMCTL_CDF_hap;\n        config.arch.emulation_flags = XEN_X86_EMU_LAPIC;\n        dom->target_pages = mem_size >> XC_PAGE_SHIFT;\n        dom->mmio_size = GB(4) - LAPIC_BASE_ADDRESS;\n        dom->lowmem_end = (mem_size > LAPIC_BASE_ADDRESS) ?\n                          LAPIC_BASE_ADDRESS : mem_size;\n        dom->highmem_end = (mem_size > LAPIC_BASE_ADDRESS) ?\n                           GB(4) + mem_size - LAPIC_BASE_ADDRESS : 0;\n        dom->mmio_start = LAPIC_BASE_ADDRESS;\n        dom->max_vcpus = 1;\n        e820[0].addr = 0;\n        e820[0].size = (max_size > LAPIC_BASE_ADDRESS) ?\n                       LAPIC_BASE_ADDRESS : max_size;\n        e820[0].type = E820_RAM;\n        e820[1].addr = (X86_HVM_END_SPECIAL_REGION -\n                        X86_HVM_NR_SPECIAL_PAGES) << XC_PAGE_SHIFT;\n        e820[1].size = X86_HVM_NR_SPECIAL_PAGES << XC_PAGE_SHIFT;\n        e820[1].type = E820_RESERVED;\n        e820[2].addr = GB(4);\n        e820[2].size = (max_size > LAPIC_BASE_ADDRESS) ?\n                       max_size - LAPIC_BASE_ADDRESS : 0;\n        e820[2].type = E820_RAM;\n    }\n\n    rv = xc_domain_create(xch, &domid, &config);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_create failed\\n\");\n        goto err;\n    }\n    rv = xc_domain_max_vcpus(xch, domid, config.max_vcpus);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_max_vcpus failed\\n\");\n        goto err;\n    }\n    rv = xc_domain_setmaxmem(xch, domid, limit_kb);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_setmaxmem failed\\n\");\n        goto err;\n    }\n    console_evtchn = xc_evtchn_alloc_unbound(xch, domid, 0);\n    if ( console_evtchn < 0 )\n    {\n        fprintf(stderr, \"xc_evtchn_alloc_unbound failed\\n\");\n        goto err;\n    }\n\n    if ( dom->container_type == XC_DOM_PV_CONTAINER )\n    {\n        rv = xc_domain_set_memmap_limit(xch, domid, limit_kb);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_domain_set_memmap_limit failed\\n\");\n            goto err;\n        }\n    }\n\n    rv = ioctl(xs_fd, IOCTL_XENBUS_BACKEND_SETUP, domid);\n    if ( rv < 0 )\n    {\n        fprintf(stderr, \"Xenbus setup ioctl failed\\n\");\n        goto err;\n    }\n\n    if ( param )\n        snprintf(cmdline, 512, \"--event %d %s\", rv, param);\n    else\n        snprintf(cmdline, 512, \"--event %d\", rv);\n\n    dom->guest_domid = domid;\n    dom->cmdline = xc_dom_strdup(dom, cmdline);\n    dom->xenstore_domid = domid;\n    dom->console_evtchn = console_evtchn;\n\n    rv = xc_dom_mem_init(dom, memory);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_mem_init failed\\n\");\n        goto err;\n    }\n    rv = xc_dom_boot_mem_init(dom);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_boot_mem_init failed\\n\");\n        goto err;\n    }\n    if ( dom->container_type == XC_DOM_HVM_CONTAINER )\n    {\n        rv = xc_domain_set_memory_map(xch, domid, e820,\n                                      dom->highmem_end ? 3 : 2);\n        if ( rv )\n        {\n            fprintf(stderr, \"xc_domain_set_memory_map failed\\n\");\n            goto err;\n        }\n    }\n    rv = xc_dom_build_image(dom);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_build_image failed\\n\");\n        goto err;\n    }\n    rv = xc_dom_boot_image(dom);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_boot_image failed\\n\");\n        goto err;\n    }\n    rv = xc_dom_gnttab_init(dom);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_dom_gnttab_init failed\\n\");\n        goto err;\n    }\n\n    rv = xc_domain_set_virq_handler(xch, domid, VIRQ_DOM_EXC);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_set_virq_handler failed\\n\");\n        goto err;\n    }\n    rv = xc_domain_unpause(xch, domid);\n    if ( rv )\n    {\n        fprintf(stderr, \"xc_domain_unpause failed\\n\");\n        goto err;\n    }\n\n    rv = 0;\n    console_gfn = (dom->container_type == XC_DOM_PV_CONTAINER)\n                  ? xc_dom_p2m(dom, dom->console_pfn)\n                  : dom->console_pfn;\n\nerr:\n    if ( dom )\n        xc_dom_release(dom);\n    if ( xs_fd >= 0 )\n        close(xs_fd);\n\n    /* if we failed then destroy the domain */\n    if ( rv && domid != ~0 )\n        xc_domain_destroy(xch, domid);\n\n    return rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -154,9 +154,9 @@\n     }\n \n     if ( param )\n-        snprintf(cmdline, 512, \"--event %d --internal-db %s\", rv, param);\n+        snprintf(cmdline, 512, \"--event %d %s\", rv, param);\n     else\n-        snprintf(cmdline, 512, \"--event %d --internal-db\", rv);\n+        snprintf(cmdline, 512, \"--event %d\", rv);\n \n     dom->guest_domid = domid;\n     dom->cmdline = xc_dom_strdup(dom, cmdline);",
        "diff_line_info": {
            "deleted_lines": [
                "        snprintf(cmdline, 512, \"--event %d --internal-db %s\", rv, param);",
                "        snprintf(cmdline, 512, \"--event %d --internal-db\", rv);"
            ],
            "added_lines": [
                "        snprintf(cmdline, 512, \"--event %d %s\", rv, param);",
                "        snprintf(cmdline, 512, \"--event %d\", rv);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/main",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/d174fefa90487ddd25ebc618028f67b2e8a1f795",
        "commit_title": "tools/xenstore: make the internal memory data base the default",
        "commit_text": " Having a file backed data base has the only advantage of being capable to dump the contents of it while Xenstore is running, and potentially using less swap space in case the data base can't be kept in memory.  It has the major disadvantage of a huge performance overhead: switching to keep the data base in memory only speeds up live update of xenstored with 120000 nodes from 20 minutes to 11 seconds. A complete tree walk of this configuration will be reduced from 7 seconds to 280 msecs (measured by \"xenstore-control check\").  So make the internal memory data base the default and enhance the \"--internal-db\" command line parameter to take an optional parameter allowing to switch the internal data base back to the file based one.  This is part of XSA-419. ",
        "func_before": "int main(int argc, char *argv[])\n{\n\tint opt;\n\tint sock_pollfd_idx = -1;\n\tbool dofork = true;\n\tbool outputpid = false;\n\tbool no_domain_init = false;\n\tbool live_update = false;\n\tconst char *pidfile = NULL;\n\tint timeout;\n\n\torig_argc = argc;\n\torig_argv = argv;\n\n\twhile ((opt = getopt_long(argc, argv, \"DE:F:HKNPS:t:A:M:Q:q:T:RVW:w:U\",\n\t\t\t\t  options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'D':\n\t\t\tno_domain_init = true;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tquota_nb_entry_per_domain = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tusage();\n\t\t\treturn 0;\n\t\tcase 'N':\n\t\t\tdofork = false;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\toutputpid = true;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trecovery = false;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tquota_max_entry_size = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tquota_max_transaction = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttracefile = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\ttdb_flags = TDB_INTERNAL|TDB_NOLOCK;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tkeep_orphans = true;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tverbose = true;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tquota_nb_watch_per_domain = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tquota_nb_perms_per_node = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tquota_max_path_len = strtol(optarg, NULL, 10);\n\t\t\tquota_max_path_len = min(XENSTORE_REL_PATH_MAX,\n\t\t\t\t\t\t quota_max_path_len);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tset_quota(optarg, false);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tset_quota(optarg, true);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tset_timeout(optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdom0_event = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tdom0_domid = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpriv_domid = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n#ifndef NO_LIVE_UPDATE\n\t\tcase 'U':\n\t\t\tlive_update = true;\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\tif (optind != argc)\n\t\tbarf(\"%s: No arguments desired\", argv[0]);\n\n\treopen_log();\n\n\t/* make sure xenstored directories exist */\n\t/* Errors ignored here, will be reported when we open files */\n\tmkdir(xs_daemon_rundir(), 0755);\n\tmkdir(xs_daemon_rootdir(), 0755);\n\n\tif (dofork) {\n\t\topenlog(\"xenstored\", 0, LOG_DAEMON);\n\t\tif (!live_update)\n\t\t\tdaemonize();\n\t}\n\tif (pidfile)\n\t\twrite_pidfile(pidfile);\n\n\t/* Talloc leak reports go to stderr, which is closed if we fork. */\n\tif (!dofork)\n\t\ttalloc_enable_leak_report_full();\n\n\t/* Don't kill us with SIGPIPE. */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\ttalloc_enable_null_tracking();\n\n#ifndef NO_SOCKETS\n\tif (!live_update)\n\t\tinit_sockets();\n#endif\n\n\tinit_pipe(reopen_log_pipe);\n\n\t/* Listen to hypervisor. */\n\tif (!no_domain_init && !live_update) {\n\t\tdomain_init(-1);\n\t\tdom0_init();\n\t}\n\n\tif (outputpid) {\n\t\tprintf(\"%ld\\n\", (long)getpid());\n\t\tfflush(stdout);\n\t}\n\n\t/* redirect to /dev/null now we're ready to accept connections */\n\tif (dofork && !live_update)\n\t\tfinish_daemonize();\n#ifndef __MINIOS__\n\tif (dofork)\n\t\txprintf = trace;\n#endif\n\n\tsignal(SIGHUP, trigger_reopen_log);\n\tif (tracefile)\n\t\ttracefile = talloc_strdup(NULL, tracefile);\n\n#ifndef NO_LIVE_UPDATE\n\t/* Read state in case of live update. */\n\tif (live_update)\n\t\tlu_read_state();\n#endif\n\n\t/* Get ready to listen to the tools. */\n\tinitialize_fds(&sock_pollfd_idx, &timeout);\n\n#if defined(XEN_SYSTEMD_ENABLED)\n\tif (!live_update) {\n\t\tsd_notify(1, \"READY=1\");\n\t\tfprintf(stderr, SD_NOTICE \"xenstored is ready\\n\");\n\t}\n#endif\n\n\t/* Main loop. */\n\tfor (;;) {\n\t\tstruct connection *conn, *next;\n\n\t\tif (poll(fds, nr_fds, timeout) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tbarf_perror(\"Poll failed\");\n\t\t}\n\n\t\tif (reopen_log_pipe0_pollfd_idx != -1) {\n\t\t\tif (fds[reopen_log_pipe0_pollfd_idx].revents\n\t\t\t    & ~POLLIN) {\n\t\t\t\tclose(reopen_log_pipe[0]);\n\t\t\t\tclose(reopen_log_pipe[1]);\n\t\t\t\tinit_pipe(reopen_log_pipe);\n\t\t\t} else if (fds[reopen_log_pipe0_pollfd_idx].revents\n\t\t\t\t   & POLLIN) {\n\t\t\t\tchar c;\n\t\t\t\tif (read(reopen_log_pipe[0], &c, 1) != 1)\n\t\t\t\t\tbarf_perror(\"read failed\");\n\t\t\t\treopen_log();\n\t\t\t}\n\t\t\treopen_log_pipe0_pollfd_idx = -1;\n\t\t}\n\n\t\tif (sock_pollfd_idx != -1) {\n\t\t\tif (fds[sock_pollfd_idx].revents & ~POLLIN) {\n\t\t\t\tbarf_perror(\"sock poll failed\");\n\t\t\t\tbreak;\n\t\t\t} else if (fds[sock_pollfd_idx].revents & POLLIN) {\n\t\t\t\taccept_connection(sock);\n\t\t\t\tsock_pollfd_idx = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (xce_pollfd_idx != -1) {\n\t\t\tif (fds[xce_pollfd_idx].revents & ~POLLIN) {\n\t\t\t\tbarf_perror(\"xce_handle poll failed\");\n\t\t\t\tbreak;\n\t\t\t} else if (fds[xce_pollfd_idx].revents & POLLIN) {\n\t\t\t\thandle_event();\n\t\t\t\txce_pollfd_idx = -1;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_safe(conn, next, &connections, list) {\n\t\t\ttalloc_increase_ref_count(conn);\n\n\t\t\tif (conn_can_read(conn))\n\t\t\t\thandle_input(conn);\n\t\t\tif (talloc_free(conn) == 0)\n\t\t\t\tcontinue;\n\n\t\t\ttalloc_increase_ref_count(conn);\n\n\t\t\tif (conn_can_write(conn))\n\t\t\t\thandle_output(conn);\n\t\t\tif (talloc_free(conn) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tconn->pollfd_idx = -1;\n\t\t}\n\n\t\tif (delayed_requests) {\n\t\t\tlist_for_each_entry(conn, &connections, list) {\n\t\t\t\tstruct delayed_request *req, *tmp;\n\n\t\t\t\tlist_for_each_entry_safe(req, tmp,\n\t\t\t\t\t\t\t &conn->delayed, list)\n\t\t\t\t\tcall_delayed(req);\n\t\t\t}\n\t\t}\n\n\t\tinitialize_fds(&sock_pollfd_idx, &timeout);\n\t}\n}",
        "func": "int main(int argc, char *argv[])\n{\n\tint opt;\n\tint sock_pollfd_idx = -1;\n\tbool dofork = true;\n\tbool outputpid = false;\n\tbool no_domain_init = false;\n\tbool live_update = false;\n\tconst char *pidfile = NULL;\n\tint timeout;\n\n\torig_argc = argc;\n\torig_argv = argv;\n\n\twhile ((opt = getopt_long(argc, argv,\n\t\t\t\t  \"DE:F:HI::KNPS:t:A:M:Q:q:T:RVW:w:U\",\n\t\t\t\t  options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'D':\n\t\t\tno_domain_init = true;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tquota_nb_entry_per_domain = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tusage();\n\t\t\treturn 0;\n\t\tcase 'N':\n\t\t\tdofork = false;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\toutputpid = true;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trecovery = false;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tquota_max_entry_size = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tquota_max_transaction = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttracefile = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tif (optarg && !strcmp(optarg, \"off\"))\n\t\t\t\ttdb_flags = 0;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tkeep_orphans = true;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tverbose = true;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tquota_nb_watch_per_domain = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tquota_nb_perms_per_node = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tquota_max_path_len = strtol(optarg, NULL, 10);\n\t\t\tquota_max_path_len = min(XENSTORE_REL_PATH_MAX,\n\t\t\t\t\t\t quota_max_path_len);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tset_quota(optarg, false);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tset_quota(optarg, true);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tset_timeout(optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdom0_event = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tdom0_domid = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpriv_domid = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n#ifndef NO_LIVE_UPDATE\n\t\tcase 'U':\n\t\t\tlive_update = true;\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\tif (optind != argc)\n\t\tbarf(\"%s: No arguments desired\", argv[0]);\n\n\treopen_log();\n\n\t/* make sure xenstored directories exist */\n\t/* Errors ignored here, will be reported when we open files */\n\tmkdir(xs_daemon_rundir(), 0755);\n\tmkdir(xs_daemon_rootdir(), 0755);\n\n\tif (dofork) {\n\t\topenlog(\"xenstored\", 0, LOG_DAEMON);\n\t\tif (!live_update)\n\t\t\tdaemonize();\n\t}\n\tif (pidfile)\n\t\twrite_pidfile(pidfile);\n\n\t/* Talloc leak reports go to stderr, which is closed if we fork. */\n\tif (!dofork)\n\t\ttalloc_enable_leak_report_full();\n\n\t/* Don't kill us with SIGPIPE. */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\ttalloc_enable_null_tracking();\n\n#ifndef NO_SOCKETS\n\tif (!live_update)\n\t\tinit_sockets();\n#endif\n\n\tinit_pipe(reopen_log_pipe);\n\n\t/* Listen to hypervisor. */\n\tif (!no_domain_init && !live_update) {\n\t\tdomain_init(-1);\n\t\tdom0_init();\n\t}\n\n\tif (outputpid) {\n\t\tprintf(\"%ld\\n\", (long)getpid());\n\t\tfflush(stdout);\n\t}\n\n\t/* redirect to /dev/null now we're ready to accept connections */\n\tif (dofork && !live_update)\n\t\tfinish_daemonize();\n#ifndef __MINIOS__\n\tif (dofork)\n\t\txprintf = trace;\n#endif\n\n\tsignal(SIGHUP, trigger_reopen_log);\n\tif (tracefile)\n\t\ttracefile = talloc_strdup(NULL, tracefile);\n\n#ifndef NO_LIVE_UPDATE\n\t/* Read state in case of live update. */\n\tif (live_update)\n\t\tlu_read_state();\n#endif\n\n\t/* Get ready to listen to the tools. */\n\tinitialize_fds(&sock_pollfd_idx, &timeout);\n\n#if defined(XEN_SYSTEMD_ENABLED)\n\tif (!live_update) {\n\t\tsd_notify(1, \"READY=1\");\n\t\tfprintf(stderr, SD_NOTICE \"xenstored is ready\\n\");\n\t}\n#endif\n\n\t/* Main loop. */\n\tfor (;;) {\n\t\tstruct connection *conn, *next;\n\n\t\tif (poll(fds, nr_fds, timeout) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tbarf_perror(\"Poll failed\");\n\t\t}\n\n\t\tif (reopen_log_pipe0_pollfd_idx != -1) {\n\t\t\tif (fds[reopen_log_pipe0_pollfd_idx].revents\n\t\t\t    & ~POLLIN) {\n\t\t\t\tclose(reopen_log_pipe[0]);\n\t\t\t\tclose(reopen_log_pipe[1]);\n\t\t\t\tinit_pipe(reopen_log_pipe);\n\t\t\t} else if (fds[reopen_log_pipe0_pollfd_idx].revents\n\t\t\t\t   & POLLIN) {\n\t\t\t\tchar c;\n\t\t\t\tif (read(reopen_log_pipe[0], &c, 1) != 1)\n\t\t\t\t\tbarf_perror(\"read failed\");\n\t\t\t\treopen_log();\n\t\t\t}\n\t\t\treopen_log_pipe0_pollfd_idx = -1;\n\t\t}\n\n\t\tif (sock_pollfd_idx != -1) {\n\t\t\tif (fds[sock_pollfd_idx].revents & ~POLLIN) {\n\t\t\t\tbarf_perror(\"sock poll failed\");\n\t\t\t\tbreak;\n\t\t\t} else if (fds[sock_pollfd_idx].revents & POLLIN) {\n\t\t\t\taccept_connection(sock);\n\t\t\t\tsock_pollfd_idx = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (xce_pollfd_idx != -1) {\n\t\t\tif (fds[xce_pollfd_idx].revents & ~POLLIN) {\n\t\t\t\tbarf_perror(\"xce_handle poll failed\");\n\t\t\t\tbreak;\n\t\t\t} else if (fds[xce_pollfd_idx].revents & POLLIN) {\n\t\t\t\thandle_event();\n\t\t\t\txce_pollfd_idx = -1;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_safe(conn, next, &connections, list) {\n\t\t\ttalloc_increase_ref_count(conn);\n\n\t\t\tif (conn_can_read(conn))\n\t\t\t\thandle_input(conn);\n\t\t\tif (talloc_free(conn) == 0)\n\t\t\t\tcontinue;\n\n\t\t\ttalloc_increase_ref_count(conn);\n\n\t\t\tif (conn_can_write(conn))\n\t\t\t\thandle_output(conn);\n\t\t\tif (talloc_free(conn) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tconn->pollfd_idx = -1;\n\t\t}\n\n\t\tif (delayed_requests) {\n\t\t\tlist_for_each_entry(conn, &connections, list) {\n\t\t\t\tstruct delayed_request *req, *tmp;\n\n\t\t\t\tlist_for_each_entry_safe(req, tmp,\n\t\t\t\t\t\t\t &conn->delayed, list)\n\t\t\t\t\tcall_delayed(req);\n\t\t\t}\n\t\t}\n\n\t\tinitialize_fds(&sock_pollfd_idx, &timeout);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,8 @@\n \torig_argc = argc;\n \torig_argv = argv;\n \n-\twhile ((opt = getopt_long(argc, argv, \"DE:F:HKNPS:t:A:M:Q:q:T:RVW:w:U\",\n+\twhile ((opt = getopt_long(argc, argv,\n+\t\t\t\t  \"DE:F:HI::KNPS:t:A:M:Q:q:T:RVW:w:U\",\n \t\t\t\t  options, NULL)) != -1) {\n \t\tswitch (opt) {\n \t\tcase 'D':\n@@ -46,7 +47,8 @@\n \t\t\ttracefile = optarg;\n \t\t\tbreak;\n \t\tcase 'I':\n-\t\t\ttdb_flags = TDB_INTERNAL|TDB_NOLOCK;\n+\t\t\tif (optarg && !strcmp(optarg, \"off\"))\n+\t\t\t\ttdb_flags = 0;\n \t\t\tbreak;\n \t\tcase 'K':\n \t\t\tkeep_orphans = true;",
        "diff_line_info": {
            "deleted_lines": [
                "\twhile ((opt = getopt_long(argc, argv, \"DE:F:HKNPS:t:A:M:Q:q:T:RVW:w:U\",",
                "\t\t\ttdb_flags = TDB_INTERNAL|TDB_NOLOCK;"
            ],
            "added_lines": [
                "\twhile ((opt = getopt_long(argc, argv,",
                "\t\t\t\t  \"DE:F:HI::KNPS:t:A:M:Q:q:T:RVW:w:U\",",
                "\t\t\tif (optarg && !strcmp(optarg, \"off\"))",
                "\t\t\t\ttdb_flags = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/usage",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/d174fefa90487ddd25ebc618028f67b2e8a1f795",
        "commit_title": "tools/xenstore: make the internal memory data base the default",
        "commit_text": " Having a file backed data base has the only advantage of being capable to dump the contents of it while Xenstore is running, and potentially using less swap space in case the data base can't be kept in memory.  It has the major disadvantage of a huge performance overhead: switching to keep the data base in memory only speeds up live update of xenstored with 120000 nodes from 20 minutes to 11 seconds. A complete tree walk of this configuration will be reduced from 7 seconds to 280 msecs (measured by \"xenstore-control check\").  So make the internal memory data base the default and enhance the \"--internal-db\" command line parameter to take an optional parameter allowing to switch the internal data base back to the file based one.  This is part of XSA-419. ",
        "func_before": "static void usage(void)\n{\n\tfprintf(stderr,\n\"Usage:\\n\"\n\"\\n\"\n\"  xenstored <options>\\n\"\n\"\\n\"\n\"where options may include:\\n\"\n\"\\n\"\n\"  -D, --no-domain-init    to state that xenstored should not initialise dom0,\\n\"\n\"  -F, --pid-file <file>   giving a file for the daemon's pid to be written,\\n\"\n\"  -H, --help              to output this message,\\n\"\n\"  -N, --no-fork           to request that the daemon does not fork,\\n\"\n\"  -P, --output-pid        to request that the pid of the daemon is output,\\n\"\n\"  -T, --trace-file <file> giving the file for logging, and\\n\"\n\"  -E, --entry-nb <nb>     limit the number of entries per domain,\\n\"\n\"  -S, --entry-size <size> limit the size of entry per domain, and\\n\"\n\"  -W, --watch-nb <nb>     limit the number of watches per domain,\\n\"\n\"  -t, --transaction <nb>  limit the number of transaction allowed per domain,\\n\"\n\"  -A, --perm-nb <nb>      limit the number of permissions per node,\\n\"\n\"  -M, --path-max <chars>  limit the allowed Xenstore node path length,\\n\"\n\"  -Q, --quota <what>=<nb> set the quota <what> to the value <nb>, allowed\\n\"\n\"                          quotas are:\\n\"\n\"                          transaction-nodes: number of accessed node per\\n\"\n\"                                             transaction\\n\"\n\"                          memory: total used memory per domain for nodes,\\n\"\n\"                                  transactions, watches and requests, above\\n\"\n\"                                  which Xenstore will stop talking to domain\\n\"\n\"                          outstanding: number of outstanding requests\\n\"\n\"  -q, --quota-soft <what>=<nb> set a soft quota <what> to the value <nb>,\\n\"\n\"                          causing a warning to be issued via syslog() if the\\n\"\n\"                          limit is violated, allowed quotas are:\\n\"\n\"                          memory: see above\\n\"\n\"  -w, --timeout <what>=<seconds>   set the timeout in seconds for <what>,\\n\"\n\"                          allowed timeout candidates are:\\n\"\n\"                          watch-event: time a watch-event is kept pending\\n\"\n\"  -R, --no-recovery       to request that no recovery should be attempted when\\n\"\n\"                          the store is corrupted (debug only),\\n\"\n\"  -I, --internal-db       store database in memory, not on disk\\n\"\n\"  -K, --keep-orphans      don't delete nodes owned by a domain when the\\n\"\n\"                          domain is deleted (this is a security risk!)\\n\"\n\"  -V, --verbose           to request verbose execution.\\n\");\n}",
        "func": "static void usage(void)\n{\n\tfprintf(stderr,\n\"Usage:\\n\"\n\"\\n\"\n\"  xenstored <options>\\n\"\n\"\\n\"\n\"where options may include:\\n\"\n\"\\n\"\n\"  -D, --no-domain-init    to state that xenstored should not initialise dom0,\\n\"\n\"  -F, --pid-file <file>   giving a file for the daemon's pid to be written,\\n\"\n\"  -H, --help              to output this message,\\n\"\n\"  -N, --no-fork           to request that the daemon does not fork,\\n\"\n\"  -P, --output-pid        to request that the pid of the daemon is output,\\n\"\n\"  -T, --trace-file <file> giving the file for logging, and\\n\"\n\"  -E, --entry-nb <nb>     limit the number of entries per domain,\\n\"\n\"  -S, --entry-size <size> limit the size of entry per domain, and\\n\"\n\"  -W, --watch-nb <nb>     limit the number of watches per domain,\\n\"\n\"  -t, --transaction <nb>  limit the number of transaction allowed per domain,\\n\"\n\"  -A, --perm-nb <nb>      limit the number of permissions per node,\\n\"\n\"  -M, --path-max <chars>  limit the allowed Xenstore node path length,\\n\"\n\"  -Q, --quota <what>=<nb> set the quota <what> to the value <nb>, allowed\\n\"\n\"                          quotas are:\\n\"\n\"                          transaction-nodes: number of accessed node per\\n\"\n\"                                             transaction\\n\"\n\"                          memory: total used memory per domain for nodes,\\n\"\n\"                                  transactions, watches and requests, above\\n\"\n\"                                  which Xenstore will stop talking to domain\\n\"\n\"                          outstanding: number of outstanding requests\\n\"\n\"  -q, --quota-soft <what>=<nb> set a soft quota <what> to the value <nb>,\\n\"\n\"                          causing a warning to be issued via syslog() if the\\n\"\n\"                          limit is violated, allowed quotas are:\\n\"\n\"                          memory: see above\\n\"\n\"  -w, --timeout <what>=<seconds>   set the timeout in seconds for <what>,\\n\"\n\"                          allowed timeout candidates are:\\n\"\n\"                          watch-event: time a watch-event is kept pending\\n\"\n\"  -R, --no-recovery       to request that no recovery should be attempted when\\n\"\n\"                          the store is corrupted (debug only),\\n\"\n\"  -I, --internal-db [on|off] store database in memory, not on disk, default is\\n\"\n\"                          memory, with \\\"--internal-db off\\\" it is on disk\\n\"\n\"  -K, --keep-orphans      don't delete nodes owned by a domain when the\\n\"\n\"                          domain is deleted (this is a security risk!)\\n\"\n\"  -V, --verbose           to request verbose execution.\\n\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,8 @@\n \"                          watch-event: time a watch-event is kept pending\\n\"\n \"  -R, --no-recovery       to request that no recovery should be attempted when\\n\"\n \"                          the store is corrupted (debug only),\\n\"\n-\"  -I, --internal-db       store database in memory, not on disk\\n\"\n+\"  -I, --internal-db [on|off] store database in memory, not on disk, default is\\n\"\n+\"                          memory, with \\\"--internal-db off\\\" it is on disk\\n\"\n \"  -K, --keep-orphans      don't delete nodes owned by a domain when the\\n\"\n \"                          domain is deleted (this is a security risk!)\\n\"\n \"  -V, --verbose           to request verbose execution.\\n\");",
        "diff_line_info": {
            "deleted_lines": [
                "\"  -I, --internal-db       store database in memory, not on disk\\n\""
            ],
            "added_lines": [
                "\"  -I, --internal-db [on|off] store database in memory, not on disk, default is\\n\"",
                "\"                          memory, with \\\"--internal-db off\\\" it is on disk\\n\""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/domain_entry_dec",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "void domain_entry_dec(struct connection *conn, struct node *node)\n{\n\tstruct domain *d;\n\tunsigned int domid;\n\n\tif (!conn)\n\t\treturn;\n\n\tdomid = node->perms.p ? node->perms.p[0].id : conn->id;\n\n\tif (conn->transaction) {\n\t\ttransaction_entry_dec(conn->transaction, domid);\n\t} else {\n\t\td = (domid == conn->id && conn->domain) ? conn->domain\n\t\t    : find_domain_struct(domid);\n\t\tif (d) {\n\t\t\td->nbentry--;\n\t\t} else {\n\t\t\terrno = ENOENT;\n\t\t\tcorrupt(conn,\n\t\t\t\t\"Node \\\"%s\\\" owned by non-existing domain %u\\n\",\n\t\t\t\tnode->name, domid);\n\t\t}\n\t}\n}",
        "func": "void domain_entry_dec(struct connection *conn, struct node *node)\n{\n\tstruct domain *d;\n\tunsigned int domid;\n\n\tif (!node->perms.p)\n\t\treturn;\n\n\tdomid = node->perms.p ? node->perms.p[0].id : conn->id;\n\n\tif (conn && conn->transaction) {\n\t\ttransaction_entry_dec(conn->transaction, domid);\n\t} else {\n\t\td = (conn && domid == conn->id && conn->domain) ? conn->domain\n\t\t    : find_domain_struct(domid);\n\t\tif (d) {\n\t\t\td->nbentry--;\n\t\t} else {\n\t\t\terrno = ENOENT;\n\t\t\tcorrupt(conn,\n\t\t\t\t\"Node \\\"%s\\\" owned by non-existing domain %u\\n\",\n\t\t\t\tnode->name, domid);\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,15 +3,15 @@\n \tstruct domain *d;\n \tunsigned int domid;\n \n-\tif (!conn)\n+\tif (!node->perms.p)\n \t\treturn;\n \n \tdomid = node->perms.p ? node->perms.p[0].id : conn->id;\n \n-\tif (conn->transaction) {\n+\tif (conn && conn->transaction) {\n \t\ttransaction_entry_dec(conn->transaction, domid);\n \t} else {\n-\t\td = (domid == conn->id && conn->domain) ? conn->domain\n+\t\td = (conn && domid == conn->id && conn->domain) ? conn->domain\n \t\t    : find_domain_struct(domid);\n \t\tif (d) {\n \t\t\td->nbentry--;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!conn)",
                "\tif (conn->transaction) {",
                "\t\td = (domid == conn->id && conn->domain) ? conn->domain"
            ],
            "added_lines": [
                "\tif (!node->perms.p)",
                "\tif (conn && conn->transaction) {",
                "\t\td = (conn && domid == conn->id && conn->domain) ? conn->domain"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/domain_adjust_node_perms",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "int domain_adjust_node_perms(struct connection *conn, struct node *node)\n{\n\tunsigned int i;\n\tint ret;\n\n\tret = chk_domain_generation(node->perms.p[0].id, node->generation);\n\n\t/* If the owner doesn't exist any longer give it to priv domain. */\n\tif (!ret) {\n\t\t/*\n\t\t * In theory we'd need to update the number of dom0 nodes here,\n\t\t * but we could be called for a read of the node. So better\n\t\t * avoid the risk to overflow the node count of dom0.\n\t\t */\n\t\tnode->perms.p[0].id = priv_domid;\n\t}\n\n\tfor (i = 1; i < node->perms.num; i++) {\n\t\tif (node->perms.p[i].perms & XS_PERM_IGNORE)\n\t\t\tcontinue;\n\t\tret = chk_domain_generation(node->perms.p[i].id,\n\t\t\t\t\t    node->generation);\n\t\tif (!ret)\n\t\t\tnode->perms.p[i].perms |= XS_PERM_IGNORE;\n\t}\n\n\treturn 0;\n}",
        "func": "int domain_adjust_node_perms(struct node *node)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 1; i < node->perms.num; i++) {\n\t\tif (node->perms.p[i].perms & XS_PERM_IGNORE)\n\t\t\tcontinue;\n\t\tret = chk_domain_generation(node->perms.p[i].id,\n\t\t\t\t\t    node->generation);\n\t\tif (!ret)\n\t\t\tnode->perms.p[i].perms |= XS_PERM_IGNORE;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,19 +1,7 @@\n-int domain_adjust_node_perms(struct connection *conn, struct node *node)\n+int domain_adjust_node_perms(struct node *node)\n {\n \tunsigned int i;\n \tint ret;\n-\n-\tret = chk_domain_generation(node->perms.p[0].id, node->generation);\n-\n-\t/* If the owner doesn't exist any longer give it to priv domain. */\n-\tif (!ret) {\n-\t\t/*\n-\t\t * In theory we'd need to update the number of dom0 nodes here,\n-\t\t * but we could be called for a read of the node. So better\n-\t\t * avoid the risk to overflow the node count of dom0.\n-\t\t */\n-\t\tnode->perms.p[0].id = priv_domid;\n-\t}\n \n \tfor (i = 1; i < node->perms.num; i++) {\n \t\tif (node->perms.p[i].perms & XS_PERM_IGNORE)",
        "diff_line_info": {
            "deleted_lines": [
                "int domain_adjust_node_perms(struct connection *conn, struct node *node)",
                "",
                "\tret = chk_domain_generation(node->perms.p[0].id, node->generation);",
                "",
                "\t/* If the owner doesn't exist any longer give it to priv domain. */",
                "\tif (!ret) {",
                "\t\t/*",
                "\t\t * In theory we'd need to update the number of dom0 nodes here,",
                "\t\t * but we could be called for a read of the node. So better",
                "\t\t * avoid the risk to overflow the node count of dom0.",
                "\t\t */",
                "\t\tnode->perms.p[0].id = priv_domid;",
                "\t}"
            ],
            "added_lines": [
                "int domain_adjust_node_perms(struct node *node)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/domain_memory_add",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "int domain_memory_add(unsigned int domid, int mem, bool no_quota_check)\n{\n\tstruct domain *domain;\n\n\tdomain = find_domain_struct(domid);\n\tif (domain) {\n\t\t/*\n\t\t * domain_chk_quota() will print warning and also store whether\n\t\t * the soft/hard quota has been hit. So check no_quota_check\n\t\t * *after*.\n\t\t */\n\t\tif (domain_chk_quota(domain, domain->memory + mem) &&\n\t\t    !no_quota_check)\n\t\t\treturn ENOMEM;\n\t\tdomain->memory += mem;\n\t} else {\n\t\t/*\n\t\t * The domain the memory is to be accounted for should always\n\t\t * exist, as accounting is done either for a domain related to\n\t\t * the current connection, or for the domain owning a node\n\t\t * (which is always existing, as the owner of the node is\n\t\t * tested to exist and replaced by domid 0 if not).\n\t\t * So not finding the related domain MUST be an error in the\n\t\t * data base.\n\t\t */\n\t\terrno = ENOENT;\n\t\tcorrupt(NULL, \"Accounting called for non-existing domain %u\\n\",\n\t\t\tdomid);\n\t\treturn ENOENT;\n\t}\n\n\treturn 0;\n}",
        "func": "int domain_memory_add(unsigned int domid, int mem, bool no_quota_check)\n{\n\tstruct domain *domain;\n\n\tdomain = find_domain_struct(domid);\n\tif (domain) {\n\t\t/*\n\t\t * domain_chk_quota() will print warning and also store whether\n\t\t * the soft/hard quota has been hit. So check no_quota_check\n\t\t * *after*.\n\t\t */\n\t\tif (domain_chk_quota(domain, domain->memory + mem) &&\n\t\t    !no_quota_check)\n\t\t\treturn ENOMEM;\n\t\tdomain->memory += mem;\n\t} else {\n\t\t/*\n\t\t * The domain the memory is to be accounted for should always\n\t\t * exist, as accounting is done either for a domain related to\n\t\t * the current connection, or for the domain owning a node\n\t\t * (which is always existing, as the owner of the node is\n\t\t * tested to exist and deleted or replaced by domid 0 if not).\n\t\t * So not finding the related domain MUST be an error in the\n\t\t * data base.\n\t\t */\n\t\terrno = ENOENT;\n\t\tcorrupt(NULL, \"Accounting called for non-existing domain %u\\n\",\n\t\t\tdomid);\n\t\treturn ENOENT;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n \t\t * exist, as accounting is done either for a domain related to\n \t\t * the current connection, or for the domain owning a node\n \t\t * (which is always existing, as the owner of the node is\n-\t\t * tested to exist and replaced by domid 0 if not).\n+\t\t * tested to exist and deleted or replaced by domid 0 if not).\n \t\t * So not finding the related domain MUST be an error in the\n \t\t * data base.\n \t\t */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t * tested to exist and replaced by domid 0 if not)."
            ],
            "added_lines": [
                "\t\t * tested to exist and deleted or replaced by domid 0 if not)."
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/destroy_domain",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "static int destroy_domain(void *_domain)\n{\n\tstruct domain *domain = _domain;\n\n\tlist_del(&domain->list);\n\n\tif (!domain->introduced)\n\t\treturn 0;\n\n\tif (domain->port) {\n\t\tif (xenevtchn_unbind(xce_handle, domain->port) == -1)\n\t\t\teprintf(\"> Unbinding port %i failed!\\n\", domain->port);\n\t}\n\n\tif (domain->interface) {\n\t\t/* Domain 0 was mapped by dom0_init, so it must be unmapped\n\t\t   using munmap() and not the grant unmap call. */\n\t\tif (domain->domid == 0)\n\t\t\tunmap_xenbus(domain->interface);\n\t\telse\n\t\t\tunmap_interface(domain->interface);\n\t}\n\n\tfire_watches(NULL, domain, \"@releaseDomain\", NULL, true, NULL);\n\n\twrl_domain_destroy(domain);\n\n\treturn 0;\n}",
        "func": "static int destroy_domain(void *_domain)\n{\n\tstruct domain *domain = _domain;\n\n\tdomain_tree_remove(domain);\n\n\tlist_del(&domain->list);\n\n\tif (!domain->introduced)\n\t\treturn 0;\n\n\tif (domain->port) {\n\t\tif (xenevtchn_unbind(xce_handle, domain->port) == -1)\n\t\t\teprintf(\"> Unbinding port %i failed!\\n\", domain->port);\n\t}\n\n\tif (domain->interface) {\n\t\t/* Domain 0 was mapped by dom0_init, so it must be unmapped\n\t\t   using munmap() and not the grant unmap call. */\n\t\tif (domain->domid == 0)\n\t\t\tunmap_xenbus(domain->interface);\n\t\telse\n\t\t\tunmap_interface(domain->interface);\n\t}\n\n\tfire_watches(NULL, domain, \"@releaseDomain\", NULL, true, NULL);\n\n\twrl_domain_destroy(domain);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n static int destroy_domain(void *_domain)\n {\n \tstruct domain *domain = _domain;\n+\n+\tdomain_tree_remove(domain);\n \n \tlist_del(&domain->list);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tdomain_tree_remove(domain);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/domain_entry_inc",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "int domain_entry_inc(struct connection *conn, struct node *node)\n{\n\tstruct domain *d;\n\tunsigned int domid;\n\n\tif (!conn)\n\t\treturn 0;\n\n\tdomid = node->perms.p ? node->perms.p[0].id : conn->id;\n\n\tif (conn->transaction) {\n\t\ttransaction_entry_inc(conn->transaction, domid);\n\t} else {\n\t\td = (domid == conn->id && conn->domain) ? conn->domain\n\t\t    : find_or_alloc_existing_domain(domid);\n\t\tif (d)\n\t\t\td->nbentry++;\n\t\telse\n\t\t\treturn ENOMEM;\n\t}\n\n\treturn 0;\n}",
        "func": "int domain_entry_inc(struct connection *conn, struct node *node)\n{\n\tstruct domain *d;\n\tunsigned int domid;\n\n\tif (!node->perms.p)\n\t\treturn 0;\n\n\tdomid = node->perms.p[0].id;\n\n\tif (conn && conn->transaction) {\n\t\ttransaction_entry_inc(conn->transaction, domid);\n\t} else {\n\t\td = (conn && domid == conn->id && conn->domain) ? conn->domain\n\t\t    : find_or_alloc_existing_domain(domid);\n\t\tif (d)\n\t\t\td->nbentry++;\n\t\telse\n\t\t\treturn ENOMEM;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,15 +3,15 @@\n \tstruct domain *d;\n \tunsigned int domid;\n \n-\tif (!conn)\n+\tif (!node->perms.p)\n \t\treturn 0;\n \n-\tdomid = node->perms.p ? node->perms.p[0].id : conn->id;\n+\tdomid = node->perms.p[0].id;\n \n-\tif (conn->transaction) {\n+\tif (conn && conn->transaction) {\n \t\ttransaction_entry_inc(conn->transaction, domid);\n \t} else {\n-\t\td = (domid == conn->id && conn->domain) ? conn->domain\n+\t\td = (conn && domid == conn->id && conn->domain) ? conn->domain\n \t\t    : find_or_alloc_existing_domain(domid);\n \t\tif (d)\n \t\t\td->nbentry++;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!conn)",
                "\tdomid = node->perms.p ? node->perms.p[0].id : conn->id;",
                "\tif (conn->transaction) {",
                "\t\td = (domid == conn->id && conn->domain) ? conn->domain"
            ],
            "added_lines": [
                "\tif (!node->perms.p)",
                "\tdomid = node->perms.p[0].id;",
                "\tif (conn && conn->transaction) {",
                "\t\td = (conn && domid == conn->id && conn->domain) ? conn->domain"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/main",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "int main(int argc, char *argv[])\n{\n\tint opt;\n\tint sock_pollfd_idx = -1;\n\tbool dofork = true;\n\tbool outputpid = false;\n\tbool no_domain_init = false;\n\tbool live_update = false;\n\tconst char *pidfile = NULL;\n\tint timeout;\n\n\torig_argc = argc;\n\torig_argv = argv;\n\n\twhile ((opt = getopt_long(argc, argv, \"DE:F:HNPS:t:A:M:Q:q:T:RVW:w:U\",\n\t\t\t\t  options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'D':\n\t\t\tno_domain_init = true;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tquota_nb_entry_per_domain = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tusage();\n\t\t\treturn 0;\n\t\tcase 'N':\n\t\t\tdofork = false;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\toutputpid = true;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trecovery = false;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tquota_max_entry_size = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tquota_max_transaction = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttracefile = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\ttdb_flags = TDB_INTERNAL|TDB_NOLOCK;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tverbose = true;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tquota_nb_watch_per_domain = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tquota_nb_perms_per_node = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tquota_max_path_len = strtol(optarg, NULL, 10);\n\t\t\tquota_max_path_len = min(XENSTORE_REL_PATH_MAX,\n\t\t\t\t\t\t quota_max_path_len);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tset_quota(optarg, false);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tset_quota(optarg, true);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tset_timeout(optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdom0_event = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tdom0_domid = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpriv_domid = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n#ifndef NO_LIVE_UPDATE\n\t\tcase 'U':\n\t\t\tlive_update = true;\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\tif (optind != argc)\n\t\tbarf(\"%s: No arguments desired\", argv[0]);\n\n\treopen_log();\n\n\t/* make sure xenstored directories exist */\n\t/* Errors ignored here, will be reported when we open files */\n\tmkdir(xs_daemon_rundir(), 0755);\n\tmkdir(xs_daemon_rootdir(), 0755);\n\n\tif (dofork) {\n\t\topenlog(\"xenstored\", 0, LOG_DAEMON);\n\t\tif (!live_update)\n\t\t\tdaemonize();\n\t}\n\tif (pidfile)\n\t\twrite_pidfile(pidfile);\n\n\t/* Talloc leak reports go to stderr, which is closed if we fork. */\n\tif (!dofork)\n\t\ttalloc_enable_leak_report_full();\n\n\t/* Don't kill us with SIGPIPE. */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\ttalloc_enable_null_tracking();\n\n#ifndef NO_SOCKETS\n\tif (!live_update)\n\t\tinit_sockets();\n#endif\n\n\tinit_pipe(reopen_log_pipe);\n\n\t/* Listen to hypervisor. */\n\tif (!no_domain_init && !live_update) {\n\t\tdomain_init(-1);\n\t\tdom0_init();\n\t}\n\n\tif (outputpid) {\n\t\tprintf(\"%ld\\n\", (long)getpid());\n\t\tfflush(stdout);\n\t}\n\n\t/* redirect to /dev/null now we're ready to accept connections */\n\tif (dofork && !live_update)\n\t\tfinish_daemonize();\n#ifndef __MINIOS__\n\tif (dofork)\n\t\txprintf = trace;\n#endif\n\n\tsignal(SIGHUP, trigger_reopen_log);\n\tif (tracefile)\n\t\ttracefile = talloc_strdup(NULL, tracefile);\n\n#ifndef NO_LIVE_UPDATE\n\t/* Read state in case of live update. */\n\tif (live_update)\n\t\tlu_read_state();\n#endif\n\n\t/* Get ready to listen to the tools. */\n\tinitialize_fds(&sock_pollfd_idx, &timeout);\n\n#if defined(XEN_SYSTEMD_ENABLED)\n\tif (!live_update) {\n\t\tsd_notify(1, \"READY=1\");\n\t\tfprintf(stderr, SD_NOTICE \"xenstored is ready\\n\");\n\t}\n#endif\n\n\t/* Main loop. */\n\tfor (;;) {\n\t\tstruct connection *conn, *next;\n\n\t\tif (poll(fds, nr_fds, timeout) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tbarf_perror(\"Poll failed\");\n\t\t}\n\n\t\tif (reopen_log_pipe0_pollfd_idx != -1) {\n\t\t\tif (fds[reopen_log_pipe0_pollfd_idx].revents\n\t\t\t    & ~POLLIN) {\n\t\t\t\tclose(reopen_log_pipe[0]);\n\t\t\t\tclose(reopen_log_pipe[1]);\n\t\t\t\tinit_pipe(reopen_log_pipe);\n\t\t\t} else if (fds[reopen_log_pipe0_pollfd_idx].revents\n\t\t\t\t   & POLLIN) {\n\t\t\t\tchar c;\n\t\t\t\tif (read(reopen_log_pipe[0], &c, 1) != 1)\n\t\t\t\t\tbarf_perror(\"read failed\");\n\t\t\t\treopen_log();\n\t\t\t}\n\t\t\treopen_log_pipe0_pollfd_idx = -1;\n\t\t}\n\n\t\tif (sock_pollfd_idx != -1) {\n\t\t\tif (fds[sock_pollfd_idx].revents & ~POLLIN) {\n\t\t\t\tbarf_perror(\"sock poll failed\");\n\t\t\t\tbreak;\n\t\t\t} else if (fds[sock_pollfd_idx].revents & POLLIN) {\n\t\t\t\taccept_connection(sock);\n\t\t\t\tsock_pollfd_idx = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (xce_pollfd_idx != -1) {\n\t\t\tif (fds[xce_pollfd_idx].revents & ~POLLIN) {\n\t\t\t\tbarf_perror(\"xce_handle poll failed\");\n\t\t\t\tbreak;\n\t\t\t} else if (fds[xce_pollfd_idx].revents & POLLIN) {\n\t\t\t\thandle_event();\n\t\t\t\txce_pollfd_idx = -1;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_safe(conn, next, &connections, list) {\n\t\t\ttalloc_increase_ref_count(conn);\n\n\t\t\tif (conn_can_read(conn))\n\t\t\t\thandle_input(conn);\n\t\t\tif (talloc_free(conn) == 0)\n\t\t\t\tcontinue;\n\n\t\t\ttalloc_increase_ref_count(conn);\n\n\t\t\tif (conn_can_write(conn))\n\t\t\t\thandle_output(conn);\n\t\t\tif (talloc_free(conn) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tconn->pollfd_idx = -1;\n\t\t}\n\n\t\tif (delayed_requests) {\n\t\t\tlist_for_each_entry(conn, &connections, list) {\n\t\t\t\tstruct delayed_request *req, *tmp;\n\n\t\t\t\tlist_for_each_entry_safe(req, tmp,\n\t\t\t\t\t\t\t &conn->delayed, list)\n\t\t\t\t\tcall_delayed(req);\n\t\t\t}\n\t\t}\n\n\t\tinitialize_fds(&sock_pollfd_idx, &timeout);\n\t}\n}",
        "func": "int main(int argc, char *argv[])\n{\n\tint opt;\n\tint sock_pollfd_idx = -1;\n\tbool dofork = true;\n\tbool outputpid = false;\n\tbool no_domain_init = false;\n\tbool live_update = false;\n\tconst char *pidfile = NULL;\n\tint timeout;\n\n\torig_argc = argc;\n\torig_argv = argv;\n\n\twhile ((opt = getopt_long(argc, argv, \"DE:F:HKNPS:t:A:M:Q:q:T:RVW:w:U\",\n\t\t\t\t  options, NULL)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'D':\n\t\t\tno_domain_init = true;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tquota_nb_entry_per_domain = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tusage();\n\t\t\treturn 0;\n\t\tcase 'N':\n\t\t\tdofork = false;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\toutputpid = true;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trecovery = false;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tquota_max_entry_size = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tquota_max_transaction = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\ttracefile = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\ttdb_flags = TDB_INTERNAL|TDB_NOLOCK;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tkeep_orphans = true;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tverbose = true;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tquota_nb_watch_per_domain = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tquota_nb_perms_per_node = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tquota_max_path_len = strtol(optarg, NULL, 10);\n\t\t\tquota_max_path_len = min(XENSTORE_REL_PATH_MAX,\n\t\t\t\t\t\t quota_max_path_len);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tset_quota(optarg, false);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tset_quota(optarg, true);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tset_timeout(optarg);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdom0_event = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tdom0_domid = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpriv_domid = strtol(optarg, NULL, 10);\n\t\t\tbreak;\n#ifndef NO_LIVE_UPDATE\n\t\tcase 'U':\n\t\t\tlive_update = true;\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\tif (optind != argc)\n\t\tbarf(\"%s: No arguments desired\", argv[0]);\n\n\treopen_log();\n\n\t/* make sure xenstored directories exist */\n\t/* Errors ignored here, will be reported when we open files */\n\tmkdir(xs_daemon_rundir(), 0755);\n\tmkdir(xs_daemon_rootdir(), 0755);\n\n\tif (dofork) {\n\t\topenlog(\"xenstored\", 0, LOG_DAEMON);\n\t\tif (!live_update)\n\t\t\tdaemonize();\n\t}\n\tif (pidfile)\n\t\twrite_pidfile(pidfile);\n\n\t/* Talloc leak reports go to stderr, which is closed if we fork. */\n\tif (!dofork)\n\t\ttalloc_enable_leak_report_full();\n\n\t/* Don't kill us with SIGPIPE. */\n\tsignal(SIGPIPE, SIG_IGN);\n\n\ttalloc_enable_null_tracking();\n\n#ifndef NO_SOCKETS\n\tif (!live_update)\n\t\tinit_sockets();\n#endif\n\n\tinit_pipe(reopen_log_pipe);\n\n\t/* Listen to hypervisor. */\n\tif (!no_domain_init && !live_update) {\n\t\tdomain_init(-1);\n\t\tdom0_init();\n\t}\n\n\tif (outputpid) {\n\t\tprintf(\"%ld\\n\", (long)getpid());\n\t\tfflush(stdout);\n\t}\n\n\t/* redirect to /dev/null now we're ready to accept connections */\n\tif (dofork && !live_update)\n\t\tfinish_daemonize();\n#ifndef __MINIOS__\n\tif (dofork)\n\t\txprintf = trace;\n#endif\n\n\tsignal(SIGHUP, trigger_reopen_log);\n\tif (tracefile)\n\t\ttracefile = talloc_strdup(NULL, tracefile);\n\n#ifndef NO_LIVE_UPDATE\n\t/* Read state in case of live update. */\n\tif (live_update)\n\t\tlu_read_state();\n#endif\n\n\t/* Get ready to listen to the tools. */\n\tinitialize_fds(&sock_pollfd_idx, &timeout);\n\n#if defined(XEN_SYSTEMD_ENABLED)\n\tif (!live_update) {\n\t\tsd_notify(1, \"READY=1\");\n\t\tfprintf(stderr, SD_NOTICE \"xenstored is ready\\n\");\n\t}\n#endif\n\n\t/* Main loop. */\n\tfor (;;) {\n\t\tstruct connection *conn, *next;\n\n\t\tif (poll(fds, nr_fds, timeout) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tbarf_perror(\"Poll failed\");\n\t\t}\n\n\t\tif (reopen_log_pipe0_pollfd_idx != -1) {\n\t\t\tif (fds[reopen_log_pipe0_pollfd_idx].revents\n\t\t\t    & ~POLLIN) {\n\t\t\t\tclose(reopen_log_pipe[0]);\n\t\t\t\tclose(reopen_log_pipe[1]);\n\t\t\t\tinit_pipe(reopen_log_pipe);\n\t\t\t} else if (fds[reopen_log_pipe0_pollfd_idx].revents\n\t\t\t\t   & POLLIN) {\n\t\t\t\tchar c;\n\t\t\t\tif (read(reopen_log_pipe[0], &c, 1) != 1)\n\t\t\t\t\tbarf_perror(\"read failed\");\n\t\t\t\treopen_log();\n\t\t\t}\n\t\t\treopen_log_pipe0_pollfd_idx = -1;\n\t\t}\n\n\t\tif (sock_pollfd_idx != -1) {\n\t\t\tif (fds[sock_pollfd_idx].revents & ~POLLIN) {\n\t\t\t\tbarf_perror(\"sock poll failed\");\n\t\t\t\tbreak;\n\t\t\t} else if (fds[sock_pollfd_idx].revents & POLLIN) {\n\t\t\t\taccept_connection(sock);\n\t\t\t\tsock_pollfd_idx = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (xce_pollfd_idx != -1) {\n\t\t\tif (fds[xce_pollfd_idx].revents & ~POLLIN) {\n\t\t\t\tbarf_perror(\"xce_handle poll failed\");\n\t\t\t\tbreak;\n\t\t\t} else if (fds[xce_pollfd_idx].revents & POLLIN) {\n\t\t\t\thandle_event();\n\t\t\t\txce_pollfd_idx = -1;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_safe(conn, next, &connections, list) {\n\t\t\ttalloc_increase_ref_count(conn);\n\n\t\t\tif (conn_can_read(conn))\n\t\t\t\thandle_input(conn);\n\t\t\tif (talloc_free(conn) == 0)\n\t\t\t\tcontinue;\n\n\t\t\ttalloc_increase_ref_count(conn);\n\n\t\t\tif (conn_can_write(conn))\n\t\t\t\thandle_output(conn);\n\t\t\tif (talloc_free(conn) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tconn->pollfd_idx = -1;\n\t\t}\n\n\t\tif (delayed_requests) {\n\t\t\tlist_for_each_entry(conn, &connections, list) {\n\t\t\t\tstruct delayed_request *req, *tmp;\n\n\t\t\t\tlist_for_each_entry_safe(req, tmp,\n\t\t\t\t\t\t\t &conn->delayed, list)\n\t\t\t\t\tcall_delayed(req);\n\t\t\t}\n\t\t}\n\n\t\tinitialize_fds(&sock_pollfd_idx, &timeout);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \torig_argc = argc;\n \torig_argv = argv;\n \n-\twhile ((opt = getopt_long(argc, argv, \"DE:F:HNPS:t:A:M:Q:q:T:RVW:w:U\",\n+\twhile ((opt = getopt_long(argc, argv, \"DE:F:HKNPS:t:A:M:Q:q:T:RVW:w:U\",\n \t\t\t\t  options, NULL)) != -1) {\n \t\tswitch (opt) {\n \t\tcase 'D':\n@@ -47,6 +47,9 @@\n \t\t\tbreak;\n \t\tcase 'I':\n \t\t\ttdb_flags = TDB_INTERNAL|TDB_NOLOCK;\n+\t\t\tbreak;\n+\t\tcase 'K':\n+\t\t\tkeep_orphans = true;\n \t\t\tbreak;\n \t\tcase 'V':\n \t\t\tverbose = true;",
        "diff_line_info": {
            "deleted_lines": [
                "\twhile ((opt = getopt_long(argc, argv, \"DE:F:HNPS:t:A:M:Q:q:T:RVW:w:U\","
            ],
            "added_lines": [
                "\twhile ((opt = getopt_long(argc, argv, \"DE:F:HKNPS:t:A:M:Q:q:T:RVW:w:U\",",
                "\t\t\tbreak;",
                "\t\tcase 'K':",
                "\t\t\tkeep_orphans = true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/usage",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "static void usage(void)\n{\n\tfprintf(stderr,\n\"Usage:\\n\"\n\"\\n\"\n\"  xenstored <options>\\n\"\n\"\\n\"\n\"where options may include:\\n\"\n\"\\n\"\n\"  -D, --no-domain-init    to state that xenstored should not initialise dom0,\\n\"\n\"  -F, --pid-file <file>   giving a file for the daemon's pid to be written,\\n\"\n\"  -H, --help              to output this message,\\n\"\n\"  -N, --no-fork           to request that the daemon does not fork,\\n\"\n\"  -P, --output-pid        to request that the pid of the daemon is output,\\n\"\n\"  -T, --trace-file <file> giving the file for logging, and\\n\"\n\"  -E, --entry-nb <nb>     limit the number of entries per domain,\\n\"\n\"  -S, --entry-size <size> limit the size of entry per domain, and\\n\"\n\"  -W, --watch-nb <nb>     limit the number of watches per domain,\\n\"\n\"  -t, --transaction <nb>  limit the number of transaction allowed per domain,\\n\"\n\"  -A, --perm-nb <nb>      limit the number of permissions per node,\\n\"\n\"  -M, --path-max <chars>  limit the allowed Xenstore node path length,\\n\"\n\"  -Q, --quota <what>=<nb> set the quota <what> to the value <nb>, allowed\\n\"\n\"                          quotas are:\\n\"\n\"                          transaction-nodes: number of accessed node per\\n\"\n\"                                             transaction\\n\"\n\"                          memory: total used memory per domain for nodes,\\n\"\n\"                                  transactions, watches and requests, above\\n\"\n\"                                  which Xenstore will stop talking to domain\\n\"\n\"                          outstanding: number of outstanding requests\\n\"\n\"  -q, --quota-soft <what>=<nb> set a soft quota <what> to the value <nb>,\\n\"\n\"                          causing a warning to be issued via syslog() if the\\n\"\n\"                          limit is violated, allowed quotas are:\\n\"\n\"                          memory: see above\\n\"\n\"  -w, --timeout <what>=<seconds>   set the timeout in seconds for <what>,\\n\"\n\"                          allowed timeout candidates are:\\n\"\n\"                          watch-event: time a watch-event is kept pending\\n\"\n\"  -R, --no-recovery       to request that no recovery should be attempted when\\n\"\n\"                          the store is corrupted (debug only),\\n\"\n\"  -I, --internal-db       store database in memory, not on disk\\n\"\n\"  -V, --verbose           to request verbose execution.\\n\");\n}",
        "func": "static void usage(void)\n{\n\tfprintf(stderr,\n\"Usage:\\n\"\n\"\\n\"\n\"  xenstored <options>\\n\"\n\"\\n\"\n\"where options may include:\\n\"\n\"\\n\"\n\"  -D, --no-domain-init    to state that xenstored should not initialise dom0,\\n\"\n\"  -F, --pid-file <file>   giving a file for the daemon's pid to be written,\\n\"\n\"  -H, --help              to output this message,\\n\"\n\"  -N, --no-fork           to request that the daemon does not fork,\\n\"\n\"  -P, --output-pid        to request that the pid of the daemon is output,\\n\"\n\"  -T, --trace-file <file> giving the file for logging, and\\n\"\n\"  -E, --entry-nb <nb>     limit the number of entries per domain,\\n\"\n\"  -S, --entry-size <size> limit the size of entry per domain, and\\n\"\n\"  -W, --watch-nb <nb>     limit the number of watches per domain,\\n\"\n\"  -t, --transaction <nb>  limit the number of transaction allowed per domain,\\n\"\n\"  -A, --perm-nb <nb>      limit the number of permissions per node,\\n\"\n\"  -M, --path-max <chars>  limit the allowed Xenstore node path length,\\n\"\n\"  -Q, --quota <what>=<nb> set the quota <what> to the value <nb>, allowed\\n\"\n\"                          quotas are:\\n\"\n\"                          transaction-nodes: number of accessed node per\\n\"\n\"                                             transaction\\n\"\n\"                          memory: total used memory per domain for nodes,\\n\"\n\"                                  transactions, watches and requests, above\\n\"\n\"                                  which Xenstore will stop talking to domain\\n\"\n\"                          outstanding: number of outstanding requests\\n\"\n\"  -q, --quota-soft <what>=<nb> set a soft quota <what> to the value <nb>,\\n\"\n\"                          causing a warning to be issued via syslog() if the\\n\"\n\"                          limit is violated, allowed quotas are:\\n\"\n\"                          memory: see above\\n\"\n\"  -w, --timeout <what>=<seconds>   set the timeout in seconds for <what>,\\n\"\n\"                          allowed timeout candidates are:\\n\"\n\"                          watch-event: time a watch-event is kept pending\\n\"\n\"  -R, --no-recovery       to request that no recovery should be attempted when\\n\"\n\"                          the store is corrupted (debug only),\\n\"\n\"  -I, --internal-db       store database in memory, not on disk\\n\"\n\"  -K, --keep-orphans      don't delete nodes owned by a domain when the\\n\"\n\"                          domain is deleted (this is a security risk!)\\n\"\n\"  -V, --verbose           to request verbose execution.\\n\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,5 +37,7 @@\n \"  -R, --no-recovery       to request that no recovery should be attempted when\\n\"\n \"                          the store is corrupted (debug only),\\n\"\n \"  -I, --internal-db       store database in memory, not on disk\\n\"\n+\"  -K, --keep-orphans      don't delete nodes owned by a domain when the\\n\"\n+\"                          domain is deleted (this is a security risk!)\\n\"\n \"  -V, --verbose           to request verbose execution.\\n\");\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\"  -K, --keep-orphans      don't delete nodes owned by a domain when the\\n\"",
                "\"                          domain is deleted (this is a security risk!)\\n\""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/do_rm",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "static int do_rm(const void *ctx, struct connection *conn,\n\t\t struct buffered_data *in)\n{\n\tstruct node *node;\n\tint ret;\n\tchar *name;\n\tchar *parentname;\n\n\tnode = get_node_canonicalized(conn, ctx, onearg(in), &name,\n\t\t\t\t      XS_PERM_WRITE);\n\tif (!node) {\n\t\t/* Didn't exist already?  Fine, if parent exists. */\n\t\tif (errno == ENOENT) {\n\t\t\tif (!name)\n\t\t\t\treturn ENOMEM;\n\t\t\tparentname = get_parent(ctx, name);\n\t\t\tif (!parentname)\n\t\t\t\treturn errno;\n\t\t\tnode = read_node(conn, ctx, parentname);\n\t\t\tif (node) {\n\t\t\t\tsend_ack(conn, XS_RM);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* Restore errno, just in case. */\n\t\t\tif (!read_node_can_propagate_errno())\n\t\t\t\terrno = ENOENT;\n\t\t}\n\t\treturn errno;\n\t}\n\n\tif (streq(name, \"/\"))\n\t\treturn EINVAL;\n\n\tret = _rm(conn, ctx, name);\n\tif (ret)\n\t\treturn ret;\n\n\tsend_ack(conn, XS_RM);\n\n\treturn 0;\n}",
        "func": "static int do_rm(const void *ctx, struct connection *conn,\n\t\t struct buffered_data *in)\n{\n\tstruct node *node;\n\tint ret;\n\tchar *name;\n\tchar *parentname;\n\n\tnode = get_node_canonicalized(conn, ctx, onearg(in), &name,\n\t\t\t\t      XS_PERM_WRITE);\n\tif (!node) {\n\t\t/* Didn't exist already?  Fine, if parent exists. */\n\t\tif (errno == ENOENT) {\n\t\t\tif (!name)\n\t\t\t\treturn ENOMEM;\n\t\t\tparentname = get_parent(ctx, name);\n\t\t\tif (!parentname)\n\t\t\t\treturn errno;\n\t\t\tnode = read_node(conn, ctx, parentname);\n\t\t\tif (node) {\n\t\t\t\tsend_ack(conn, XS_RM);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* Restore errno, just in case. */\n\t\t\tif (!read_node_can_propagate_errno())\n\t\t\t\terrno = ENOENT;\n\t\t}\n\t\treturn errno;\n\t}\n\n\tif (streq(name, \"/\"))\n\t\treturn EINVAL;\n\n\tret = rm_node(conn, ctx, name);\n\tif (ret)\n\t\treturn ret;\n\n\tsend_ack(conn, XS_RM);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \tif (streq(name, \"/\"))\n \t\treturn EINVAL;\n \n-\tret = _rm(conn, ctx, name);\n+\tret = rm_node(conn, ctx, name);\n \tif (ret)\n \t\treturn ret;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tret = _rm(conn, ctx, name);"
            ],
            "added_lines": [
                "\tret = rm_node(conn, ctx, name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/read_node",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "struct node *read_node(struct connection *conn, const void *ctx,\n\t\t       const char *name)\n{\n\tTDB_DATA key, data;\n\tstruct xs_tdb_record_hdr *hdr;\n\tstruct node *node;\n\tint err;\n\n\tnode = talloc(ctx, struct node);\n\tif (!node) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tnode->name = talloc_strdup(node, name);\n\tif (!node->name) {\n\t\ttalloc_free(node);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tif (transaction_prepend(conn, name, &key))\n\t\treturn NULL;\n\n\tdata = tdb_fetch(tdb_ctx, key);\n\n\tif (data.dptr == NULL) {\n\t\tif (tdb_error(tdb_ctx) == TDB_ERR_NOEXIST) {\n\t\t\tnode->generation = NO_GENERATION;\n\t\t\terr = access_node(conn, node, NODE_ACCESS_READ, NULL);\n\t\t\terrno = err ? : ENOENT;\n\t\t} else {\n\t\t\tlog(\"TDB error on read: %s\", tdb_errorstr(tdb_ctx));\n\t\t\terrno = EIO;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tnode->parent = NULL;\n\ttalloc_steal(node, data.dptr);\n\n\t/* Datalen, childlen, number of permissions */\n\thdr = (void *)data.dptr;\n\tnode->generation = hdr->generation;\n\tnode->perms.num = hdr->num_perms;\n\tnode->datalen = hdr->datalen;\n\tnode->childlen = hdr->childlen;\n\n\t/* Permissions are struct xs_permissions. */\n\tnode->perms.p = hdr->perms;\n\tnode->acc.domid = node->perms.p[0].id;\n\tnode->acc.memory = data.dsize;\n\tif (domain_adjust_node_perms(conn, node))\n\t\tgoto error;\n\n\t/* If owner is gone reset currently accounted memory size. */\n\tif (node->acc.domid != node->perms.p[0].id)\n\t\tnode->acc.memory = 0;\n\n\t/* Data is binary blob (usually ascii, no nul). */\n\tnode->data = node->perms.p + hdr->num_perms;\n\t/* Children is strings, nul separated. */\n\tnode->children = node->data + node->datalen;\n\n\tif (access_node(conn, node, NODE_ACCESS_READ, NULL))\n\t\tgoto error;\n\n\treturn node;\n\n error:\n\terr = errno;\n\ttalloc_free(node);\n\terrno = err;\n\treturn NULL;\n}",
        "func": "struct node *read_node(struct connection *conn, const void *ctx,\n\t\t       const char *name)\n{\n\tTDB_DATA key, data;\n\tstruct xs_tdb_record_hdr *hdr;\n\tstruct node *node;\n\tint err;\n\n\tnode = talloc(ctx, struct node);\n\tif (!node) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tnode->name = talloc_strdup(node, name);\n\tif (!node->name) {\n\t\ttalloc_free(node);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tif (transaction_prepend(conn, name, &key))\n\t\treturn NULL;\n\n\tdata = tdb_fetch(tdb_ctx, key);\n\n\tif (data.dptr == NULL) {\n\t\tif (tdb_error(tdb_ctx) == TDB_ERR_NOEXIST) {\n\t\t\tnode->generation = NO_GENERATION;\n\t\t\terr = access_node(conn, node, NODE_ACCESS_READ, NULL);\n\t\t\terrno = err ? : ENOENT;\n\t\t} else {\n\t\t\tlog(\"TDB error on read: %s\", tdb_errorstr(tdb_ctx));\n\t\t\terrno = EIO;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tnode->parent = NULL;\n\ttalloc_steal(node, data.dptr);\n\n\t/* Datalen, childlen, number of permissions */\n\thdr = (void *)data.dptr;\n\tnode->generation = hdr->generation;\n\tnode->perms.num = hdr->num_perms;\n\tnode->datalen = hdr->datalen;\n\tnode->childlen = hdr->childlen;\n\n\t/* Permissions are struct xs_permissions. */\n\tnode->perms.p = hdr->perms;\n\tnode->acc.domid = node->perms.p[0].id;\n\tnode->acc.memory = data.dsize;\n\tif (domain_adjust_node_perms(node))\n\t\tgoto error;\n\n\t/* If owner is gone reset currently accounted memory size. */\n\tif (node->acc.domid != node->perms.p[0].id)\n\t\tnode->acc.memory = 0;\n\n\t/* Data is binary blob (usually ascii, no nul). */\n\tnode->data = node->perms.p + hdr->num_perms;\n\t/* Children is strings, nul separated. */\n\tnode->children = node->data + node->datalen;\n\n\tif (access_node(conn, node, NODE_ACCESS_READ, NULL))\n\t\tgoto error;\n\n\treturn node;\n\n error:\n\terr = errno;\n\ttalloc_free(node);\n\terrno = err;\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n \tnode->perms.p = hdr->perms;\n \tnode->acc.domid = node->perms.p[0].id;\n \tnode->acc.memory = data.dsize;\n-\tif (domain_adjust_node_perms(conn, node))\n+\tif (domain_adjust_node_perms(node))\n \t\tgoto error;\n \n \t/* If owner is gone reset currently accounted memory size. */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (domain_adjust_node_perms(conn, node))"
            ],
            "added_lines": [
                "\tif (domain_adjust_node_perms(node))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42322",
        "func_name": "xen-project/xen/write_node_raw",
        "description": "Xenstore: Cooperating guests can create arbitrary numbers of nodes T[his CNA information record relates to multiple CVEs; the text explains which aspects/vulnerabilities correspond to which CVE.] Since the fix of XSA-322 any Xenstore node owned by a removed domain will be modified to be owned by Dom0. This will allow two malicious guests working together to create an arbitrary number of Xenstore nodes. This is possible by domain A letting domain B write into domain A's local Xenstore tree. Domain B can then create many nodes and reboot. The nodes created by domain B will now be owned by Dom0. By repeating this process over and over again an arbitrary number of nodes can be created, as Dom0's number of nodes isn't limited by Xenstore quota.",
        "git_url": "https://github.com/xen-project/xen/commit/755d3f9debf8879448211fffb018f556136f6a79",
        "commit_title": "tools/xenstore: remove nodes owned by destroyed domain",
        "commit_text": " In case a domain is removed from Xenstore, remove all nodes owned by it per default.  This tackles the problem that nodes might be created by a domain outside its home path in Xenstore, leading to Xenstore hogging more and more memory. Domain quota don't work in this case if the guest is rebooting in between.  Since XSA-322 ownership of such stale nodes is transferred to dom0, which is helping against unintended access, but not against OOM of Xenstore.  As a fallback for weird cases add a Xenstore start parameter for keeping today's way to handle stale nodes, adding the risk of Xenstore hitting an OOM situation.  This is part of XSA-419 / CVE-2022-42322. ",
        "func_before": "int write_node_raw(struct connection *conn, TDB_DATA *key, struct node *node,\n\t\t   bool no_quota_check)\n{\n\tTDB_DATA data;\n\tvoid *p;\n\tstruct xs_tdb_record_hdr *hdr;\n\n\tif (domain_adjust_node_perms(conn, node))\n\t\treturn errno;\n\n\tdata.dsize = sizeof(*hdr)\n\t\t+ node->perms.num * sizeof(node->perms.p[0])\n\t\t+ node->datalen + node->childlen;\n\n\tif (!no_quota_check && domain_is_unprivileged(conn) &&\n\t    data.dsize >= quota_max_entry_size) {\n\t\terrno = ENOSPC;\n\t\treturn errno;\n\t}\n\n\tdata.dptr = talloc_size(node, data.dsize);\n\tif (!data.dptr) {\n\t\terrno = ENOMEM;\n\t\treturn errno;\n\t}\n\n\thdr = (void *)data.dptr;\n\thdr->generation = node->generation;\n\thdr->num_perms = node->perms.num;\n\thdr->datalen = node->datalen;\n\thdr->childlen = node->childlen;\n\n\tmemcpy(hdr->perms, node->perms.p,\n\t       node->perms.num * sizeof(*node->perms.p));\n\tp = hdr->perms + node->perms.num;\n\tmemcpy(p, node->data, node->datalen);\n\tp += node->datalen;\n\tmemcpy(p, node->children, node->childlen);\n\n\tif (do_tdb_write(conn, key, &data, &node->acc, no_quota_check))\n\t\treturn EIO;\n\n\treturn 0;\n}",
        "func": "int write_node_raw(struct connection *conn, TDB_DATA *key, struct node *node,\n\t\t   bool no_quota_check)\n{\n\tTDB_DATA data;\n\tvoid *p;\n\tstruct xs_tdb_record_hdr *hdr;\n\n\tif (domain_adjust_node_perms(node))\n\t\treturn errno;\n\n\tdata.dsize = sizeof(*hdr)\n\t\t+ node->perms.num * sizeof(node->perms.p[0])\n\t\t+ node->datalen + node->childlen;\n\n\tif (!no_quota_check && domain_is_unprivileged(conn) &&\n\t    data.dsize >= quota_max_entry_size) {\n\t\terrno = ENOSPC;\n\t\treturn errno;\n\t}\n\n\tdata.dptr = talloc_size(node, data.dsize);\n\tif (!data.dptr) {\n\t\terrno = ENOMEM;\n\t\treturn errno;\n\t}\n\n\thdr = (void *)data.dptr;\n\thdr->generation = node->generation;\n\thdr->num_perms = node->perms.num;\n\thdr->datalen = node->datalen;\n\thdr->childlen = node->childlen;\n\n\tmemcpy(hdr->perms, node->perms.p,\n\t       node->perms.num * sizeof(*node->perms.p));\n\tp = hdr->perms + node->perms.num;\n\tmemcpy(p, node->data, node->datalen);\n\tp += node->datalen;\n\tmemcpy(p, node->children, node->childlen);\n\n\tif (do_tdb_write(conn, key, &data, &node->acc, no_quota_check))\n\t\treturn EIO;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tvoid *p;\n \tstruct xs_tdb_record_hdr *hdr;\n \n-\tif (domain_adjust_node_perms(conn, node))\n+\tif (domain_adjust_node_perms(node))\n \t\treturn errno;\n \n \tdata.dsize = sizeof(*hdr)",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (domain_adjust_node_perms(conn, node))"
            ],
            "added_lines": [
                "\tif (domain_adjust_node_perms(node))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-43254",
        "func_name": "gpac/gf_isom_delete_movie",
        "description": "GPAC v2.1-DEV-rev368-gfd054169b-master was discovered to contain a memory leak via the component gf_list_new at utils/list.c.",
        "git_url": "https://github.com/gpac/gpac/commit/4520e38aa030f059264c69b426bd8133206fbfe6",
        "commit_title": "fixed #2284",
        "commit_text": "",
        "func_before": "void gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}",
        "func": "void gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n\n\tif (mov->emsgs)\n\t\tgf_isom_box_array_del(mov->emsgs);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,9 @@\n \n \tif (mov->block_buffer)\n \t\tgf_free(mov->block_buffer);\n+\n+\tif (mov->emsgs)\n+\t\tgf_isom_box_array_del(mov->emsgs);\n #endif\n \tif (mov->last_producer_ref_time)\n \t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (mov->emsgs)",
                "\t\tgf_isom_box_array_del(mov->emsgs);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-43255",
        "func_name": "gpac/load_xmt_done",
        "description": "GPAC v2.1-DEV-rev368-gfd054169b-master was discovered to contain a memory leak via the component gf_odf_new_iod at odf/odf_code.c.",
        "git_url": "https://github.com/gpac/gpac/commit/d82e1340d7fd5ceea205e0f173500102f3237eb4",
        "commit_title": "fixed #2285",
        "commit_text": "",
        "func_before": "static void load_xmt_done(GF_SceneLoader *load)\n{\n\tGF_XMTParser *parser = (GF_XMTParser *)load->loader_priv;\n\tif (!parser) return;\n\n\twhile (1) {\n\t\tXMTNodeStack *st = (XMTNodeStack *)gf_list_last(parser->nodes);\n\t\tif (!st) break;\n\t\tgf_list_rem_last(parser->nodes);\n\t\tgf_node_register(st->node, NULL);\n\t\tgf_node_unregister(st->node, NULL);\n\t\tgf_free(st);\n\t}\n\tif (parser->x3d_root) gf_free(parser->x3d_root);\n\tgf_list_del(parser->nodes);\n\tgf_list_del(parser->descriptors);\n\tgf_list_del(parser->def_nodes);\n\tgf_list_del(parser->peeked_nodes);\n\n\tgf_list_del(parser->inserted_routes);\n\tgf_list_del(parser->unresolved_routes);\n\tgf_list_del(parser->od_links);\n\tgf_list_del(parser->esd_links);\n\tgf_xml_sax_del(parser->sax_parser);\n\tif (parser->script_to_load) gf_list_del(parser->script_to_load);\n\tgf_free(parser);\n\tload->loader_priv = NULL;\n}",
        "func": "static void load_xmt_done(GF_SceneLoader *load)\n{\n\tGF_XMTParser *parser = (GF_XMTParser *)load->loader_priv;\n\tif (!parser) return;\n\n\twhile (1) {\n\t\tXMTNodeStack *st = (XMTNodeStack *)gf_list_last(parser->nodes);\n\t\tif (!st) break;\n\t\tgf_list_rem_last(parser->nodes);\n\t\tgf_node_register(st->node, NULL);\n\t\tgf_node_unregister(st->node, NULL);\n\t\tgf_free(st);\n\t}\n\tif (parser->x3d_root) gf_free(parser->x3d_root);\n\tgf_list_del(parser->nodes);\n\t//we may have one root desc remaining if error\n\tif (gf_list_count(parser->descriptors)) {\n\t\tGF_Descriptor *desc = gf_list_get(parser->descriptors, 0);\n\t\tgf_odf_desc_del(desc);\n\t}\n\tgf_list_del(parser->descriptors);\n\tgf_list_del(parser->def_nodes);\n\tgf_list_del(parser->peeked_nodes);\n\n\tgf_list_del(parser->inserted_routes);\n\tgf_list_del(parser->unresolved_routes);\n\tgf_list_del(parser->od_links);\n\tgf_list_del(parser->esd_links);\n\tgf_xml_sax_del(parser->sax_parser);\n\tif (parser->script_to_load) gf_list_del(parser->script_to_load);\n\tgf_free(parser);\n\tload->loader_priv = NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,11 @@\n \t}\n \tif (parser->x3d_root) gf_free(parser->x3d_root);\n \tgf_list_del(parser->nodes);\n+\t//we may have one root desc remaining if error\n+\tif (gf_list_count(parser->descriptors)) {\n+\t\tGF_Descriptor *desc = gf_list_get(parser->descriptors, 0);\n+\t\tgf_odf_desc_del(desc);\n+\t}\n \tgf_list_del(parser->descriptors);\n \tgf_list_del(parser->def_nodes);\n \tgf_list_del(parser->peeked_nodes);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t//we may have one root desc remaining if error",
                "\tif (gf_list_count(parser->descriptors)) {",
                "\t\tGF_Descriptor *desc = gf_list_get(parser->descriptors, 0);",
                "\t\tgf_odf_desc_del(desc);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-8916",
        "func_name": "openthread/wpantund/main",
        "description": "A memory leak in Openthread's wpantund versions up to commit 0e5d1601febb869f583e944785e5685c6c747be7, when used in an environment where wpanctl is directly interfacing with the control driver (eg: debug environments) can allow an attacker to crash the service (DoS). We recommend updating, or to restrict access in your debug environments.",
        "git_url": "https://github.com/openthread/wpantund/commit/0e5d1601febb869f583e944785e5685c6c747be7",
        "commit_title": "[wpanctl] free dbus connection and error on exit.",
        "commit_text": "",
        "func_before": "int main(int argc, char * argv[])\n{\n\tint c;\n\tbool ignore_driver_version_mismatch = false;\n\tDBusError error;\n\tDBusConnection* connection;\n\n\tdbus_error_init(&error);\n\n\tsrandom(time(NULL));\n\n\twhile (1) {\n\t\tstatic struct option long_options[] = {\n\t\t\t{\"help\", no_argument, 0, 'h'},\n\t\t\t{\"version\", no_argument, 0, 'v'},\n\t\t\t{\"ignore-mismatch\", no_argument, 0, 'i'},\n\t\t\t{\"debug\", no_argument, 0, 'd'},\n\t\t\t{\"interface\", required_argument, 0, 'I'},\n\t\t\t{\"file\", required_argument, 0, 'f'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n\n\t\tint option_index = 0;\n\n\t\tif ((optind < argc) && (find_cmd(argv[optind]) != NULL)) {\n\t\t\t// This is where the wpanctl command starts; skip\n\t\t\t// parsing the flags since they may belong to the command\n\t\t\tbreak;\n\t}\n\n\t\tc = getopt_long(argc, argv, \"hvidI:f:\", long_options,\n\t\t\t\t&option_index);\n\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\tprint_version();\n\t\tprint_arg_list_help(option_list,\n\t\t                    argv[0],\n\t\t                    \"[options] <sub-command> [args]\");\n\t\tprint_commands();\n\t\tgRet = ERRORCODE_HELP;\n\t\tgoto bail;\n\n\t\tcase 'v':\n\t\t\tprint_version();\n\t\t\tgRet = 0;\n\t\t\tgoto bail;\n\n\t\tcase 'd':\n\t\t\tgDebugMode++;\n\t\t\tbreak;\n\n\t\tcase 'I':\n\t\t\tsnprintf(gInterfaceName, sizeof(gInterfaceName),\n\t\t\t\t \"%s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tignore_driver_version_mismatch = true;\n\t\t\tbreak;\n\n\t\tcase 'f':\n#if HAVE_LIBREADLINE\n\t\t\tif (NULL == freopen(optarg, \"r\", stdin))\n\t\t\t{\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"%s: error: Unable to open file \\\"%s\\\".\\n\",\n\t\t\t\t\t\targv[0], optarg);\n\t\t\t\treturn ERRORCODE_BADARG;\n\t\t\t}\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s: Cannot read from file \\\"%s\\\" : Missing readline library.\\n\",\n\t\t\t\targv[0], optarg);\n\t\t\treturn ERRORCODE_BADARG;\n#endif\n\t\tdefault:\n\t\tbreak;\n\t}\n\t}\n\n\tistty = isatty(fileno(stdin));\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: isatty(fileno(stdin)) = %d\\n\", istty);\n\t}\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: Will use interface '%s'.\\n\", gInterfaceName);\n\t}\n\n#if HAVE_PWD_H\n\tif (getuid() == 0 && strcmp(WPANTUND_SERVICE_USER, \"root\")) {\n\t\tuid_t target_uid = 0;\n\t\tgid_t target_gid = 0;\n\t\tstruct passwd *passwd = getpwnam(WPANTUND_SERVICE_USER);\n\n\t\tif (passwd == NULL) {\n\t\t\tfprintf(stderr, \"getpwnam: Unable to lookup user \\\"%s\\\".\", WPANTUND_SERVICE_USER);\n\t\t\tgRet = ERRORCODE_ERRNO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttarget_uid = passwd->pw_uid;\n\t\ttarget_gid = passwd->pw_gid;\n\n\t\tif (target_gid != 0) {\n\t\t\tif (setgid(target_gid) != 0) {\n\t\t\t\tperror(\"setgid\");\n\t\t\t\tgRet = ERRORCODE_ERRNO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tif (target_uid != 0) {\n\t\t\tif (setuid(target_uid) != 0) {\n\t\t\t\tperror(\"setuid\");\n\t\t\t\tgRet = ERRORCODE_ERRNO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n#endif // HAVE_PWD_H\n\n\tif (getenv(\"WPANCTL_DBUS_NAME\") && gDebugMode>=1)\n\t\tfprintf(stderr, \"DEBUG: Using dbus \\\"%s\\\"\\n\", getenv(\"WPANCTL_DBUS_NAME\"));\n\n\tsetenv(\"WPANCTL_DBUS_NAME\", WPAN_TUNNEL_DBUS_NAME, 0);\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: trying dbus_bus_get(DBUS_BUS_SYSTEM). . .\\n\");\n\t}\n\n\tconnection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);\n\n\trequire_string(connection != NULL, bail, error.message);\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: DBusConnection: %p\\n\", connection);\n\t}\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: Registering DBusConnection. . .\\n\");\n\t}\n\n\tdbus_bus_register(connection, &error);\n\trequire_string(error.name == NULL, bail, error.message);\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: DBusConnection registered.\\n\");\n\t}\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: Requesting DBus name \\\"%s\\\". . .\\n\",WPAN_TUNNEL_DBUS_NAME \".wpanctl\");\n\t}\n\n\tdbus_bus_request_name(connection,\n\t                      WPAN_TUNNEL_DBUS_NAME \".wpanctl\",\n\t                      0,\n\t                      &error);\n\n\tif (gDebugMode >= 1) {\n\t\tif (error.name != NULL) {\n\t\t\tfprintf(stderr, \"DEBUG: Requesting DBus name \\\"%s\\\" failed (no biggie): %s\\n\",WPAN_TUNNEL_DBUS_NAME \".wpanctl\", error.name);\n\t\t} else {\n\t\t\tfprintf(stderr, \"DEBUG: Requesting DBus name \\\"%s\\\" succeded.\\n\",WPAN_TUNNEL_DBUS_NAME \".wpanctl\");\n\t\t}\n\t}\n\n\t// Don't fail if we can't get the name. It isn't a big deal.\n\t//require_string(error.name == NULL, bail, error.message);\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: Performing wpantund version check. . .\\n\");\n\t}\n\n\t// Make sure that we are compatible with the copy of wpantund\n\t// that is currently running.\n\tgRet = wpan_dbus_version_check(connection);\n\n\tif (gRet != 0) {\n\t\tfprintf(stderr,\n\t\t        \"%s: error: `wpantund` is either not running, locked up, or incompatible with this version of `wpanctl`.\\n\",\n\t\t        argv[0]\n\t\t        );\n\t\tif (!ignore_driver_version_mismatch)\n\t\t\tgoto bail;\n\t} else {\n\t\tif (gDebugMode >= 1) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"DEBUG: wpantund version check succeded.\\n\");\n\t\t}\n\t}\n\n\tif (optind < argc) {\n\t\t\tif (gDebugMode >= 1) {\n\t\t\tfprintf(stderr, \"DEBUG: Executing command '%s'. . .\\n\",\n\t\t\t\targv[optind]);\n\t\t}\n\n\t\targc -= optind;\n\t\targv += optind;\n\n\t\toptind = 0;\n\t\tgRet = exec_command(argc, argv);\n\t\tgoto bail;\n\t}\n\n\tif (istty) {\n#if !HAVE_LIBREADLINE\n\t\tfprintf(stderr,\n\t\t        \"%s: error: Interactive mode disabled: Compiled without libeditline or libreadline support.\\n\",\n\t\t        argv[0]\n\t\t        );\n\t\tprint_arg_list_help(option_list,\n\t\t                    argv[0],\n\t\t                    \"[options] <sub-command> [args]\");\n\t\tprint_commands();\n\t\tgRet = ERRORCODE_NOCOMMAND;\n\t\tgoto bail;\n#else   // HAVE_LIBREADLINE\n\t\tsetenv(\"WPANCTL_HISTORY_FILE\", tilde_expand(\"~/.wpanctl_history\"), 0);\n\n\t\tgRet = initialize_readline();\n\t\tif(gRet) {\n\t\t\tfprintf(stderr,\n\t\t\t        \"%s: error: Failed to initialize readline: %d\\n\",\n\t\t\t        argv[0], gRet\n\t\t\t        );\n\t\t\tgoto bail;\n\t\t}\n#endif  // HAVE_LIBREADLINE\n\t}\n\n\t// Command mode.\n\twhile ((gRet != ERRORCODE_QUIT) && !feof(stdin)) {\n\t\toptind = 0;\n#if HAVE_LIBREADLINE\n\t\tif (istty) {\n\t\t\tint dbus_fd = -1;\n\n\t\t\tdbus_connection_get_unix_fd(connection, &dbus_fd);\n\n\t\t\tstruct pollfd polltable[2] = {\n\t\t\t\t{ fileno(stdin), POLLIN | POLLHUP,               0                         },\n\t\t\t\t{ dbus_fd,               POLLIN | POLLHUP,               0                         },\n\t\t\t};\n\n\t\t\tif (poll(\n\t\t\t        polltable,\n\t\t\t        (dbus_fd >= 0) ? 2 : 1,\n\t\t\t        1000\n\t\t\t        ) < 0\n\t\t\t    ) {\n\t\t\t\tif (errno == EINTR) {\n\t\t\t\t\t// We just caught a signal.\n\t\t\t\t\t// Do nothing.\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (polltable[0].revents)\n\t\t\t\trl_callback_read_char();\n\t\t} else\n#endif  // HAVE_LIBREADLINE\n\t\t{\n\t\t\tchar linebuffer[200];\n\t\t\tprocess_input_line(fgets(linebuffer, sizeof(linebuffer), stdin));\n\t\t}\n\n\t\tdbus_connection_read_write_dispatch(connection, 0);\n\t}\n\tprintf(\"\\n\");\n\nbail:\n#if HAVE_LIBREADLINE\n\trl_callback_handler_remove();\n#endif  // HAVE_LIBREADLINE\n\tif (gRet == ERRORCODE_QUIT)\n\t\tgRet = 0;\n\n\treturn gRet;\n}",
        "func": "int main(int argc, char * argv[])\n{\n\tint c;\n\tbool ignore_driver_version_mismatch = false;\n\tDBusError error;\n\tDBusConnection* connection = NULL;\n\n\tdbus_error_init(&error);\n\n\tsrandom(time(NULL));\n\n\twhile (1) {\n\t\tstatic struct option long_options[] = {\n\t\t\t{\"help\", no_argument, 0, 'h'},\n\t\t\t{\"version\", no_argument, 0, 'v'},\n\t\t\t{\"ignore-mismatch\", no_argument, 0, 'i'},\n\t\t\t{\"debug\", no_argument, 0, 'd'},\n\t\t\t{\"interface\", required_argument, 0, 'I'},\n\t\t\t{\"file\", required_argument, 0, 'f'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n\n\t\tint option_index = 0;\n\n\t\tif ((optind < argc) && (find_cmd(argv[optind]) != NULL)) {\n\t\t\t// This is where the wpanctl command starts; skip\n\t\t\t// parsing the flags since they may belong to the command\n\t\t\tbreak;\n\t}\n\n\t\tc = getopt_long(argc, argv, \"hvidI:f:\", long_options,\n\t\t\t\t&option_index);\n\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 'h':\n\t\tprint_version();\n\t\tprint_arg_list_help(option_list,\n\t\t                    argv[0],\n\t\t                    \"[options] <sub-command> [args]\");\n\t\tprint_commands();\n\t\tgRet = ERRORCODE_HELP;\n\t\tgoto bail;\n\n\t\tcase 'v':\n\t\t\tprint_version();\n\t\t\tgRet = 0;\n\t\t\tgoto bail;\n\n\t\tcase 'd':\n\t\t\tgDebugMode++;\n\t\t\tbreak;\n\n\t\tcase 'I':\n\t\t\tsnprintf(gInterfaceName, sizeof(gInterfaceName),\n\t\t\t\t \"%s\", optarg);\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tignore_driver_version_mismatch = true;\n\t\t\tbreak;\n\n\t\tcase 'f':\n#if HAVE_LIBREADLINE\n\t\t\tif (NULL == freopen(optarg, \"r\", stdin))\n\t\t\t{\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"%s: error: Unable to open file \\\"%s\\\".\\n\",\n\t\t\t\t\t\targv[0], optarg);\n\t\t\t\treturn ERRORCODE_BADARG;\n\t\t\t}\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s: Cannot read from file \\\"%s\\\" : Missing readline library.\\n\",\n\t\t\t\targv[0], optarg);\n\t\t\treturn ERRORCODE_BADARG;\n#endif\n\t\tdefault:\n\t\tbreak;\n\t}\n\t}\n\n\tistty = isatty(fileno(stdin));\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: isatty(fileno(stdin)) = %d\\n\", istty);\n\t}\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: Will use interface '%s'.\\n\", gInterfaceName);\n\t}\n\n#if HAVE_PWD_H\n\tif (getuid() == 0 && strcmp(WPANTUND_SERVICE_USER, \"root\")) {\n\t\tuid_t target_uid = 0;\n\t\tgid_t target_gid = 0;\n\t\tstruct passwd *passwd = getpwnam(WPANTUND_SERVICE_USER);\n\n\t\tif (passwd == NULL) {\n\t\t\tfprintf(stderr, \"getpwnam: Unable to lookup user \\\"%s\\\".\", WPANTUND_SERVICE_USER);\n\t\t\tgRet = ERRORCODE_ERRNO;\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttarget_uid = passwd->pw_uid;\n\t\ttarget_gid = passwd->pw_gid;\n\n\t\tif (target_gid != 0) {\n\t\t\tif (setgid(target_gid) != 0) {\n\t\t\t\tperror(\"setgid\");\n\t\t\t\tgRet = ERRORCODE_ERRNO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tif (target_uid != 0) {\n\t\t\tif (setuid(target_uid) != 0) {\n\t\t\t\tperror(\"setuid\");\n\t\t\t\tgRet = ERRORCODE_ERRNO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n#endif // HAVE_PWD_H\n\n\tif (getenv(\"WPANCTL_DBUS_NAME\") && gDebugMode>=1)\n\t\tfprintf(stderr, \"DEBUG: Using dbus \\\"%s\\\"\\n\", getenv(\"WPANCTL_DBUS_NAME\"));\n\n\tsetenv(\"WPANCTL_DBUS_NAME\", WPAN_TUNNEL_DBUS_NAME, 0);\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: trying dbus_bus_get(DBUS_BUS_SYSTEM). . .\\n\");\n\t}\n\n\tconnection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);\n\n\trequire_string(connection != NULL, bail, error.message);\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: DBusConnection: %p\\n\", connection);\n\t}\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: Registering DBusConnection. . .\\n\");\n\t}\n\n\tdbus_bus_register(connection, &error);\n\trequire_string(error.name == NULL, bail, error.message);\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: DBusConnection registered.\\n\");\n\t}\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: Requesting DBus name \\\"%s\\\". . .\\n\",WPAN_TUNNEL_DBUS_NAME \".wpanctl\");\n\t}\n\n\tdbus_bus_request_name(connection,\n\t                      WPAN_TUNNEL_DBUS_NAME \".wpanctl\",\n\t                      0,\n\t                      &error);\n\n\tif (gDebugMode >= 1) {\n\t\tif (error.name != NULL) {\n\t\t\tfprintf(stderr, \"DEBUG: Requesting DBus name \\\"%s\\\" failed (no biggie): %s\\n\",WPAN_TUNNEL_DBUS_NAME \".wpanctl\", error.name);\n\t\t} else {\n\t\t\tfprintf(stderr, \"DEBUG: Requesting DBus name \\\"%s\\\" succeded.\\n\",WPAN_TUNNEL_DBUS_NAME \".wpanctl\");\n\t\t}\n\t}\n\n\t// Don't fail if we can't get the name. It isn't a big deal.\n\t//require_string(error.name == NULL, bail, error.message);\n\n\tif (gDebugMode >= 1) {\n\t\tfprintf(stderr, \"DEBUG: Performing wpantund version check. . .\\n\");\n\t}\n\n\t// Make sure that we are compatible with the copy of wpantund\n\t// that is currently running.\n\tgRet = wpan_dbus_version_check(connection);\n\n\tif (gRet != 0) {\n\t\tfprintf(stderr,\n\t\t        \"%s: error: `wpantund` is either not running, locked up, or incompatible with this version of `wpanctl`.\\n\",\n\t\t        argv[0]\n\t\t        );\n\t\tif (!ignore_driver_version_mismatch)\n\t\t\tgoto bail;\n\t} else {\n\t\tif (gDebugMode >= 1) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"DEBUG: wpantund version check succeded.\\n\");\n\t\t}\n\t}\n\n\tif (optind < argc) {\n\t\t\tif (gDebugMode >= 1) {\n\t\t\tfprintf(stderr, \"DEBUG: Executing command '%s'. . .\\n\",\n\t\t\t\targv[optind]);\n\t\t}\n\n\t\targc -= optind;\n\t\targv += optind;\n\n\t\toptind = 0;\n\t\tgRet = exec_command(argc, argv);\n\t\tgoto bail;\n\t}\n\n\tif (istty) {\n#if !HAVE_LIBREADLINE\n\t\tfprintf(stderr,\n\t\t        \"%s: error: Interactive mode disabled: Compiled without libeditline or libreadline support.\\n\",\n\t\t        argv[0]\n\t\t        );\n\t\tprint_arg_list_help(option_list,\n\t\t                    argv[0],\n\t\t                    \"[options] <sub-command> [args]\");\n\t\tprint_commands();\n\t\tgRet = ERRORCODE_NOCOMMAND;\n\t\tgoto bail;\n#else   // HAVE_LIBREADLINE\n\t\tsetenv(\"WPANCTL_HISTORY_FILE\", tilde_expand(\"~/.wpanctl_history\"), 0);\n\n\t\tgRet = initialize_readline();\n\t\tif(gRet) {\n\t\t\tfprintf(stderr,\n\t\t\t        \"%s: error: Failed to initialize readline: %d\\n\",\n\t\t\t        argv[0], gRet\n\t\t\t        );\n\t\t\tgoto bail;\n\t\t}\n#endif  // HAVE_LIBREADLINE\n\t}\n\n\t// Command mode.\n\twhile ((gRet != ERRORCODE_QUIT) && !feof(stdin)) {\n\t\toptind = 0;\n#if HAVE_LIBREADLINE\n\t\tif (istty) {\n\t\t\tint dbus_fd = -1;\n\n\t\t\tdbus_connection_get_unix_fd(connection, &dbus_fd);\n\n\t\t\tstruct pollfd polltable[2] = {\n\t\t\t\t{ fileno(stdin), POLLIN | POLLHUP,               0                         },\n\t\t\t\t{ dbus_fd,               POLLIN | POLLHUP,               0                         },\n\t\t\t};\n\n\t\t\tif (poll(\n\t\t\t        polltable,\n\t\t\t        (dbus_fd >= 0) ? 2 : 1,\n\t\t\t        1000\n\t\t\t        ) < 0\n\t\t\t    ) {\n\t\t\t\tif (errno == EINTR) {\n\t\t\t\t\t// We just caught a signal.\n\t\t\t\t\t// Do nothing.\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (polltable[0].revents)\n\t\t\t\trl_callback_read_char();\n\t\t} else\n#endif  // HAVE_LIBREADLINE\n\t\t{\n\t\t\tchar linebuffer[200];\n\t\t\tprocess_input_line(fgets(linebuffer, sizeof(linebuffer), stdin));\n\t\t}\n\n\t\tdbus_connection_read_write_dispatch(connection, 0);\n\t}\n\tprintf(\"\\n\");\n\nbail:\n#if HAVE_LIBREADLINE\n\trl_callback_handler_remove();\n#endif  // HAVE_LIBREADLINE\n\tif (gRet == ERRORCODE_QUIT)\n\t\tgRet = 0;\n\n\tif (connection) {\n\t\tdbus_connection_unref(connection);\n\t}\n\n\tdbus_error_free(&error);\n\n\treturn gRet;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \tint c;\n \tbool ignore_driver_version_mismatch = false;\n \tDBusError error;\n-\tDBusConnection* connection;\n+\tDBusConnection* connection = NULL;\n \n \tdbus_error_init(&error);\n \n@@ -283,5 +283,11 @@\n \tif (gRet == ERRORCODE_QUIT)\n \t\tgRet = 0;\n \n+\tif (connection) {\n+\t\tdbus_connection_unref(connection);\n+\t}\n+\n+\tdbus_error_free(&error);\n+\n \treturn gRet;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tDBusConnection* connection;"
            ],
            "added_lines": [
                "\tDBusConnection* connection = NULL;",
                "\tif (connection) {",
                "\t\tdbus_connection_unref(connection);",
                "\t}",
                "",
                "\tdbus_error_free(&error);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-6502",
        "func_name": "OpenSC/main",
        "description": "sc_context_create in ctx.c in libopensc in OpenSC 0.19.0 has a memory leak, as demonstrated by a call from eidenv.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/0d7967549751b7032f22b437106b41444aff0ba9",
        "commit_title": "Small memory leak fix (CVE-2019-6502 in #1586)",
        "commit_text": " CVE-2019-6502 was assigned to what appears to be a very minor memory leak that only occurs on an error-case in a CLI tool. If util_connect_card fails, we still need to release the sc context previously allocated by sc_context_create else memory will leak.",
        "func_before": "int main(int argc, char **argv)\n{\n\tsc_context_t *ctx = NULL;\n\tsc_context_param_t ctx_param;\n\tsc_card_t *card = NULL;\n\tint r;\n\n\t/* get options */\n\tdecode_options(argc, argv);\n\n\t/* connect to the card */\n\tmemset(&ctx_param, 0, sizeof(ctx_param));\n\tctx_param.ver      = 0;\n\tctx_param.app_name = app_name;\n\n\tr = sc_context_create(&ctx, &ctx_param);\n\tif (r) {\n\tfprintf(stderr, \"Failed to establish context: %s\\n\",\n\t\tsc_strerror(r));\n\t\treturn 1;\n\t}\n\tr = util_connect_card(ctx, &card, opt_reader, opt_wait, 0);\n\tif (r) {\n\t\tfprintf(stderr, \"Failed to connect to card: %s\\n\", sc_strerror(r));\n\t\treturn 1;\n\t}\n\n\t/* Check card type */\n\tif (card->type == SC_CARD_TYPE_MCRD_ESTEID_V30)\n\t\tdo_esteid(card);\n\telse if (card->type == SC_CARD_TYPE_BELPIC_EID)\n\t\tdo_belpic(card);\n\telse {\n\t\tfprintf(stderr, \"Not an EstEID or Belpic card!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (exec_program) {\n\t\tchar *const largv[] = {exec_program, NULL};\n\t\tsc_unlock(card);\n\t\tsc_disconnect_card(card);\n\t\tsc_release_context(ctx);\n\t\texecv(exec_program, largv);\n\t\t/* we should not get here */\n\t\tperror(\"execv()\");\n\t\texit(1);\n\t}\n\nout:\n\tsc_unlock(card);\n\tsc_disconnect_card(card);\n\tsc_release_context(ctx);\n\texit(exit_status);\n}",
        "func": "int main(int argc, char **argv)\n{\n\tsc_context_t *ctx = NULL;\n\tsc_context_param_t ctx_param;\n\tsc_card_t *card = NULL;\n\tint r;\n\n\t/* get options */\n\tdecode_options(argc, argv);\n\n\t/* connect to the card */\n\tmemset(&ctx_param, 0, sizeof(ctx_param));\n\tctx_param.ver      = 0;\n\tctx_param.app_name = app_name;\n\n\tr = sc_context_create(&ctx, &ctx_param);\n\tif (r) {\n\tfprintf(stderr, \"Failed to establish context: %s\\n\",\n\t\tsc_strerror(r));\n\t\treturn 1;\n\t}\n\tr = util_connect_card(ctx, &card, opt_reader, opt_wait, 0);\n\tif (r) {\n\t\tfprintf(stderr, \"Failed to connect to card: %s\\n\", sc_strerror(r));\n\t\tsc_release_context(ctx);\n\t\treturn 1;\n\t}\n\n\t/* Check card type */\n\tif (card->type == SC_CARD_TYPE_MCRD_ESTEID_V30)\n\t\tdo_esteid(card);\n\telse if (card->type == SC_CARD_TYPE_BELPIC_EID)\n\t\tdo_belpic(card);\n\telse {\n\t\tfprintf(stderr, \"Not an EstEID or Belpic card!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (exec_program) {\n\t\tchar *const largv[] = {exec_program, NULL};\n\t\tsc_unlock(card);\n\t\tsc_disconnect_card(card);\n\t\tsc_release_context(ctx);\n\t\texecv(exec_program, largv);\n\t\t/* we should not get here */\n\t\tperror(\"execv()\");\n\t\texit(1);\n\t}\n\nout:\n\tsc_unlock(card);\n\tsc_disconnect_card(card);\n\tsc_release_context(ctx);\n\texit(exit_status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,7 @@\n \tr = util_connect_card(ctx, &card, opt_reader, opt_wait, 0);\n \tif (r) {\n \t\tfprintf(stderr, \"Failed to connect to card: %s\\n\", sc_strerror(r));\n+\t\tsc_release_context(ctx);\n \t\treturn 1;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tsc_release_context(ctx);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7395",
        "func_name": "ImageMagick/WritePSDChannel",
        "description": "In ImageMagick before 7.0.8-25, a memory leak exists in WritePSDChannel in coders/psd.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/8a43abefb38c5e29138e1c9c515b313363541c06",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1451",
        "commit_text": "",
        "func_before": "static size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  const CompressionType compression,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n#define CHUNK 16384\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,compression,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,next_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      memset(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}",
        "func": "static size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  const CompressionType compression,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n#define CHUNK 16384\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,compression,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,next_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      memset(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n            compressed_pixels);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -75,6 +75,8 @@\n       if (deflateInit(&stream,level) != Z_OK)\n         {\n           quantum_info=DestroyQuantumInfo(quantum_info);\n+          compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n+            compressed_pixels);\n           return(0);\n         }\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "          compressed_pixels=(unsigned char *) RelinquishMagickMemory(",
                "            compressed_pixels);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7396",
        "func_name": "ImageMagick/ReadSIXELImage",
        "description": "In ImageMagick before 7.0.8-25, a memory leak exists in ReadSIXELImage in coders/sixel.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/748a03651e5b138bcaf160d15133de2f4b1b89ce",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1452",
        "commit_text": "",
        "func_before": "static Image *ReadSIXELImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *sixel_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    i,\n    j,\n    y;\n\n  unsigned char\n    *sixel_pixels,\n    *sixel_palette;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SIXEL file.\n  */\n  length=MagickPathExtent;\n  sixel_buffer=(char *) AcquireQuantumMemory((size_t) length+MagickPathExtent,\n    sizeof(*sixel_buffer));\n  p=sixel_buffer;\n  if (sixel_buffer != (char *) NULL)\n    while (ReadBlobString(image,p) != (char *) NULL)\n    {\n      if ((*p == '#') && ((p == sixel_buffer) || (*(p-1) == '\\n')))\n        continue;\n      if ((*p == '}') && (*(p+1) == ';'))\n        break;\n      p+=strlen(p);\n      if ((size_t) (p-sixel_buffer+MagickPathExtent+1) < length)\n        continue;\n      length<<=1;\n      sixel_buffer=(char *) ResizeQuantumMemory(sixel_buffer,length+\n        MagickPathExtent+1,sizeof(*sixel_buffer));\n      if (sixel_buffer == (char *) NULL)\n        break;\n      p=sixel_buffer+strlen(sixel_buffer);\n    }\n  if (sixel_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  sixel_buffer[length]='\\0';\n  /*\n    Decode SIXEL\n  */\n  if (sixel_decode(image,(unsigned char *) sixel_buffer,&sixel_pixels,&image->columns,&image->rows,&sixel_palette,&image->colors,exception) == MagickFalse)\n    {\n      sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n  image->depth=24;\n  image->storage_class=PseudoClass;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      return(DestroyImageList(image));\n    }\n\n  if (AcquireImageColormap(image,image->colors, exception) == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i = 0; i < (ssize_t) image->colors; ++i) {\n    image->colormap[i].red   = ScaleCharToQuantum(sixel_palette[i * 4 + 0]);\n    image->colormap[i].green = ScaleCharToQuantum(sixel_palette[i * 4 + 1]);\n    image->colormap[i].blue  = ScaleCharToQuantum(sixel_palette[i * 4 + 2]);\n  }\n\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          j=(ssize_t) sixel_pixels[y * image->columns + x];\n          SetPixelIndex(image,j,q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n          sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadSIXELImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *sixel_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    i,\n    j,\n    y;\n\n  unsigned char\n    *sixel_pixels,\n    *sixel_palette;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SIXEL file.\n  */\n  length=MagickPathExtent;\n  sixel_buffer=(char *) AcquireQuantumMemory((size_t) length+MagickPathExtent,\n    sizeof(*sixel_buffer));\n  p=sixel_buffer;\n  if (sixel_buffer != (char *) NULL)\n    while (ReadBlobString(image,p) != (char *) NULL)\n    {\n      if ((*p == '#') && ((p == sixel_buffer) || (*(p-1) == '\\n')))\n        continue;\n      if ((*p == '}') && (*(p+1) == ';'))\n        break;\n      p+=strlen(p);\n      if ((size_t) (p-sixel_buffer+MagickPathExtent+1) < length)\n        continue;\n      length<<=1;\n      sixel_buffer=(char *) ResizeQuantumMemory(sixel_buffer,length+\n        MagickPathExtent+1,sizeof(*sixel_buffer));\n      if (sixel_buffer == (char *) NULL)\n        break;\n      p=sixel_buffer+strlen(sixel_buffer);\n    }\n  if (sixel_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  sixel_buffer[length]='\\0';\n  /*\n    Decode SIXEL\n  */\n  if (sixel_decode(image,(unsigned char *) sixel_buffer,&sixel_pixels,&image->columns,&image->rows,&sixel_palette,&image->colors,exception) == MagickFalse)\n    {\n      sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n  image->depth=24;\n  image->storage_class=PseudoClass;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      return(DestroyImageList(image));\n    }\n\n  if (AcquireImageColormap(image,image->colors, exception) == MagickFalse)\n    {\n      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n      sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i = 0; i < (ssize_t) image->colors; ++i) {\n    image->colormap[i].red   = ScaleCharToQuantum(sixel_palette[i * 4 + 0]);\n    image->colormap[i].green = ScaleCharToQuantum(sixel_palette[i * 4 + 1]);\n    image->colormap[i].blue  = ScaleCharToQuantum(sixel_palette[i * 4 + 2]);\n  }\n\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          j=(ssize_t) sixel_pixels[y * image->columns + x];\n          SetPixelIndex(image,j,q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n          sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n  sixel_palette=(unsigned char *) RelinquishMagickMemory(sixel_palette);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,6 +80,7 @@\n   if (sixel_decode(image,(unsigned char *) sixel_buffer,&sixel_pixels,&image->columns,&image->rows,&sixel_palette,&image->colors,exception) == MagickFalse)\n     {\n       sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n+      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n       ThrowReaderException(CorruptImageError,\"CorruptImage\");\n     }\n   sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7398",
        "func_name": "ImageMagick/WriteDIBImage",
        "description": "In ImageMagick before 7.0.8-25, a memory leak exists in WriteDIBImage in coders/dib.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/9cf2f738f714eba6d47be1127ed255acd2b51750",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1453",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteDIBImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  DIBInfo\n    dib_info;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *dib_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize DIB raster file header.\n  */\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  if (image->storage_class == DirectClass)\n    {\n      /*\n        Full color DIB raster.\n      */\n      dib_info.number_colors=0;\n      dib_info.bits_per_pixel=(unsigned short) (image->alpha_trait ? 32 : 24);\n    }\n  else\n    {\n      /*\n        Colormapped DIB raster.\n      */\n      dib_info.bits_per_pixel=8;\n      if (image_info->depth > 8)\n        dib_info.bits_per_pixel=16;\n      if (SetImageMonochrome(image,exception) != MagickFalse)\n        dib_info.bits_per_pixel=1;\n      dib_info.number_colors=(unsigned int) (dib_info.bits_per_pixel == 16 ? 0 :\n        (1UL << dib_info.bits_per_pixel));\n    }\n  bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);\n  dib_info.size=40;\n  dib_info.width=(int) image->columns;\n  dib_info.height=(int) image->rows;\n  dib_info.planes=1;\n  dib_info.compression=(unsigned int) (dib_info.bits_per_pixel == 16 ?\n    BI_BITFIELDS : BI_RGB);\n  dib_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n  dib_info.x_pixels=75*39;\n  dib_info.y_pixels=75*39;\n  switch (image->units)\n  {\n    case UndefinedResolution:\n    case PixelsPerInchResolution:\n    {\n      dib_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n      dib_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n      break;\n    }\n    case PixelsPerCentimeterResolution:\n    {\n      dib_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n      dib_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n      break;\n    }\n  }\n  dib_info.colors_important=dib_info.number_colors;\n  /*\n    Convert MIFF to DIB raster pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->rows,MagickMax(\n    bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(pixels,0,dib_info.image_size);\n  switch (dib_info.bits_per_pixel)\n  {\n    case 1:\n    {\n      register unsigned char\n        bit,\n        byte;\n\n      /*\n        Convert PseudoClass image to a DIB monochrome image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=pixels+(image->rows-y-1)*bytes_per_line;\n        bit=0;\n        byte=0;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          byte<<=1;\n          byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n          bit++;\n          if (bit == 8)\n            {\n              *q++=byte;\n              bit=0;\n              byte=0;\n            }\n           p+=GetPixelChannels(image);\n         }\n         if (bit != 0)\n           {\n             *q++=(unsigned char) (byte << (8-bit));\n             x++;\n           }\n        for (x=(ssize_t) (image->columns+7)/8; x < (ssize_t) bytes_per_line; x++)\n          *q++=0x00;\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      break;\n    }\n    case 8:\n    {\n      /*\n        Convert PseudoClass packet to DIB pixel.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=pixels+(image->rows-y-1)*bytes_per_line;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(unsigned char) GetPixelIndex(image,p);\n          p+=GetPixelChannels(image);\n        }\n        for ( ; x < (ssize_t) bytes_per_line; x++)\n          *q++=0x00;\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        word;\n      /*\n        Convert PseudoClass packet to DIB pixel.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=pixels+(image->rows-y-1)*bytes_per_line;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          word=(unsigned short) ((ScaleColor8to5((unsigned char)\n            ScaleQuantumToChar(GetPixelRed(image,p))) << 11) | (ScaleColor8to6(\n            (unsigned char) ScaleQuantumToChar(GetPixelGreen(image,p))) << 5) |\n            (ScaleColor8to5((unsigned char) ScaleQuantumToChar((unsigned char)\n            GetPixelBlue(image,p)) << 0)));\n          *q++=(unsigned char)(word & 0xff);\n          *q++=(unsigned char)(word >> 8);\n          p+=GetPixelChannels(image);\n        }\n        for (x=(ssize_t) (2*image->columns); x < (ssize_t) bytes_per_line; x++)\n          *q++=0x00;\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      break;\n    }\n    case 24:\n    case 32:\n    {\n      /*\n        Convert DirectClass packet to DIB RGB pixel.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=pixels+(image->rows-y-1)*bytes_per_line;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n          if (image->alpha_trait != UndefinedPixelTrait)\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n        if (dib_info.bits_per_pixel == 24)\n          for (x=(ssize_t) (3*image->columns); x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      break;\n    }\n  }\n  if (dib_info.bits_per_pixel == 8)\n    if (image_info->compression != NoCompression)\n      {\n        size_t\n          length;\n\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        length=2UL*(bytes_per_line+2UL)+2UL;\n        dib_data=(unsigned char *) AcquireQuantumMemory(length,\n          (image->rows+2UL)*sizeof(*dib_data));\n        if (dib_data == (unsigned char *) NULL)\n          {\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        dib_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n          pixels,dib_data);\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n        pixels=dib_data;\n        dib_info.compression = BI_RLE8;\n      }\n  /*\n    Write DIB header.\n  */\n  (void) WriteBlobLSBLong(image,dib_info.size);\n  (void) WriteBlobLSBLong(image,(unsigned int) dib_info.width);\n  (void) WriteBlobLSBLong(image,(unsigned int) dib_info.height);\n  (void) WriteBlobLSBShort(image,(unsigned short) dib_info.planes);\n  (void) WriteBlobLSBShort(image,dib_info.bits_per_pixel);\n  (void) WriteBlobLSBLong(image,dib_info.compression);\n  (void) WriteBlobLSBLong(image,dib_info.image_size);\n  (void) WriteBlobLSBLong(image,dib_info.x_pixels);\n  (void) WriteBlobLSBLong(image,dib_info.y_pixels);\n  (void) WriteBlobLSBLong(image,dib_info.number_colors);\n  (void) WriteBlobLSBLong(image,dib_info.colors_important);\n  if (image->storage_class == PseudoClass)\n    {\n      if (dib_info.bits_per_pixel <= 8)\n        {\n          unsigned char\n            *dib_colormap;\n\n          /*\n            Dump colormap to file.\n          */\n          dib_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            (1UL << dib_info.bits_per_pixel),4*sizeof(*dib_colormap));\n          if (dib_colormap == (unsigned char *) NULL)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          q=dib_colormap;\n          for (i=0; i < (ssize_t) MagickMin(image->colors,dib_info.number_colors); i++)\n          {\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n            *q++=(Quantum) 0x0;\n          }\n          for ( ; i < (ssize_t) (1L << dib_info.bits_per_pixel); i++)\n          {\n            *q++=(Quantum) 0x0;\n            *q++=(Quantum) 0x0;\n            *q++=(Quantum) 0x0;\n            *q++=(Quantum) 0x0;\n          }\n          (void) WriteBlob(image,(size_t) (4*(1 << dib_info.bits_per_pixel)),\n            dib_colormap);\n          dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);\n        }\n      else\n        if ((dib_info.bits_per_pixel == 16) &&\n            (dib_info.compression == BI_BITFIELDS))\n          {\n            (void) WriteBlobLSBLong(image,0xf800);\n            (void) WriteBlobLSBLong(image,0x07e0);\n            (void) WriteBlobLSBLong(image,0x001f);\n          }\n    }\n  (void) WriteBlob(image,dib_info.image_size,pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WriteDIBImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  DIBInfo\n    dib_info;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *dib_data,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize DIB raster file header.\n  */\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  if (image->storage_class == DirectClass)\n    {\n      /*\n        Full color DIB raster.\n      */\n      dib_info.number_colors=0;\n      dib_info.bits_per_pixel=(unsigned short) (image->alpha_trait ? 32 : 24);\n    }\n  else\n    {\n      /*\n        Colormapped DIB raster.\n      */\n      dib_info.bits_per_pixel=8;\n      if (image_info->depth > 8)\n        dib_info.bits_per_pixel=16;\n      if (SetImageMonochrome(image,exception) != MagickFalse)\n        dib_info.bits_per_pixel=1;\n      dib_info.number_colors=(unsigned int) (dib_info.bits_per_pixel == 16 ? 0 :\n        (1UL << dib_info.bits_per_pixel));\n    }\n  bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);\n  dib_info.size=40;\n  dib_info.width=(int) image->columns;\n  dib_info.height=(int) image->rows;\n  dib_info.planes=1;\n  dib_info.compression=(unsigned int) (dib_info.bits_per_pixel == 16 ?\n    BI_BITFIELDS : BI_RGB);\n  dib_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n  dib_info.x_pixels=75*39;\n  dib_info.y_pixels=75*39;\n  switch (image->units)\n  {\n    case UndefinedResolution:\n    case PixelsPerInchResolution:\n    {\n      dib_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n      dib_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n      break;\n    }\n    case PixelsPerCentimeterResolution:\n    {\n      dib_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n      dib_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n      break;\n    }\n  }\n  dib_info.colors_important=dib_info.number_colors;\n  /*\n    Convert MIFF to DIB raster pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->rows,MagickMax(\n    bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(pixels,0,dib_info.image_size);\n  switch (dib_info.bits_per_pixel)\n  {\n    case 1:\n    {\n      register unsigned char\n        bit,\n        byte;\n\n      /*\n        Convert PseudoClass image to a DIB monochrome image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=pixels+(image->rows-y-1)*bytes_per_line;\n        bit=0;\n        byte=0;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          byte<<=1;\n          byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n          bit++;\n          if (bit == 8)\n            {\n              *q++=byte;\n              bit=0;\n              byte=0;\n            }\n           p+=GetPixelChannels(image);\n         }\n         if (bit != 0)\n           {\n             *q++=(unsigned char) (byte << (8-bit));\n             x++;\n           }\n        for (x=(ssize_t) (image->columns+7)/8; x < (ssize_t) bytes_per_line; x++)\n          *q++=0x00;\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      break;\n    }\n    case 8:\n    {\n      /*\n        Convert PseudoClass packet to DIB pixel.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=pixels+(image->rows-y-1)*bytes_per_line;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(unsigned char) GetPixelIndex(image,p);\n          p+=GetPixelChannels(image);\n        }\n        for ( ; x < (ssize_t) bytes_per_line; x++)\n          *q++=0x00;\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        word;\n      /*\n        Convert PseudoClass packet to DIB pixel.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=pixels+(image->rows-y-1)*bytes_per_line;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          word=(unsigned short) ((ScaleColor8to5((unsigned char)\n            ScaleQuantumToChar(GetPixelRed(image,p))) << 11) | (ScaleColor8to6(\n            (unsigned char) ScaleQuantumToChar(GetPixelGreen(image,p))) << 5) |\n            (ScaleColor8to5((unsigned char) ScaleQuantumToChar((unsigned char)\n            GetPixelBlue(image,p)) << 0)));\n          *q++=(unsigned char)(word & 0xff);\n          *q++=(unsigned char)(word >> 8);\n          p+=GetPixelChannels(image);\n        }\n        for (x=(ssize_t) (2*image->columns); x < (ssize_t) bytes_per_line; x++)\n          *q++=0x00;\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      break;\n    }\n    case 24:\n    case 32:\n    {\n      /*\n        Convert DirectClass packet to DIB RGB pixel.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          break;\n        q=pixels+(image->rows-y-1)*bytes_per_line;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n          if (image->alpha_trait != UndefinedPixelTrait)\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n        if (dib_info.bits_per_pixel == 24)\n          for (x=(ssize_t) (3*image->columns); x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      break;\n    }\n  }\n  if (dib_info.bits_per_pixel == 8)\n    if (image_info->compression != NoCompression)\n      {\n        size_t\n          length;\n\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        length=2UL*(bytes_per_line+2UL)+2UL;\n        dib_data=(unsigned char *) AcquireQuantumMemory(length,\n          (image->rows+2UL)*sizeof(*dib_data));\n        if (dib_data == (unsigned char *) NULL)\n          {\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        dib_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n          pixels,dib_data);\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n        pixels=dib_data;\n        dib_info.compression = BI_RLE8;\n      }\n  /*\n    Write DIB header.\n  */\n  (void) WriteBlobLSBLong(image,dib_info.size);\n  (void) WriteBlobLSBLong(image,(unsigned int) dib_info.width);\n  (void) WriteBlobLSBLong(image,(unsigned int) dib_info.height);\n  (void) WriteBlobLSBShort(image,(unsigned short) dib_info.planes);\n  (void) WriteBlobLSBShort(image,dib_info.bits_per_pixel);\n  (void) WriteBlobLSBLong(image,dib_info.compression);\n  (void) WriteBlobLSBLong(image,dib_info.image_size);\n  (void) WriteBlobLSBLong(image,dib_info.x_pixels);\n  (void) WriteBlobLSBLong(image,dib_info.y_pixels);\n  (void) WriteBlobLSBLong(image,dib_info.number_colors);\n  (void) WriteBlobLSBLong(image,dib_info.colors_important);\n  if (image->storage_class == PseudoClass)\n    {\n      if (dib_info.bits_per_pixel <= 8)\n        {\n          unsigned char\n            *dib_colormap;\n\n          /*\n            Dump colormap to file.\n          */\n          dib_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            (1UL << dib_info.bits_per_pixel),4*sizeof(*dib_colormap));\n          if (dib_colormap == (unsigned char *) NULL)\n            {\n              pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          q=dib_colormap;\n          for (i=0; i < (ssize_t) MagickMin(image->colors,dib_info.number_colors); i++)\n          {\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n            *q++=(Quantum) 0x0;\n          }\n          for ( ; i < (ssize_t) (1L << dib_info.bits_per_pixel); i++)\n          {\n            *q++=(Quantum) 0x0;\n            *q++=(Quantum) 0x0;\n            *q++=(Quantum) 0x0;\n            *q++=(Quantum) 0x0;\n          }\n          (void) WriteBlob(image,(size_t) (4*(1 << dib_info.bits_per_pixel)),\n            dib_colormap);\n          dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);\n        }\n      else\n        if ((dib_info.bits_per_pixel == 16) &&\n            (dib_info.compression == BI_BITFIELDS))\n          {\n            (void) WriteBlobLSBLong(image,0xf800);\n            (void) WriteBlobLSBLong(image,0x07e0);\n            (void) WriteBlobLSBLong(image,0x001f);\n          }\n    }\n  (void) WriteBlob(image,dib_info.image_size,pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -287,7 +287,10 @@\n           dib_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n             (1UL << dib_info.bits_per_pixel),4*sizeof(*dib_colormap));\n           if (dib_colormap == (unsigned char *) NULL)\n-            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+            {\n+              pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n+              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+            }\n           q=dib_colormap;\n           for (i=0; i < (ssize_t) MagickMin(image->colors,dib_info.number_colors); i++)\n           {",
        "diff_line_info": {
            "deleted_lines": [
                "            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "            {",
                "              pixels=(unsigned char *) RelinquishMagickMemory(pixels);",
                "              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-9004",
        "func_name": "eclipse-wakaama/wakaama/coap_parse_message",
        "description": "In Eclipse Wakaama (formerly liblwm2m) 1.0, core/er-coap-13/er-coap-13.c in lwm2mserver in the LWM2M server mishandles invalid options, leading to a memory leak. Processing of a single crafted packet leads to leaking (wasting) 24 bytes of memory. This can lead to termination of the LWM2M server after exhausting all available memory.",
        "git_url": "https://github.com/eclipse-wakaama/wakaama/commit/533f285ff6fd9c2284fd290bdfbd355e302ae9a4",
        "commit_title": "Fix memory leak with bad options.",
        "commit_text": " Option processing can allocate memory. Encountering a bad option was returning and error without freeing that memory. This adds the necessary calls to free the memory to fix #425. ",
        "func_before": "coap_status_t\ncoap_parse_message(void *packet, uint8_t *data, uint16_t data_len)\n{\n  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;\n  uint8_t *current_option;\n  unsigned int option_number = 0;\n  unsigned int option_delta = 0;\n  size_t option_length = 0;\n  unsigned int *x;\n\n  /* Initialize packet */\n  memset(coap_pkt, 0, sizeof(coap_packet_t));\n\n  /* pointer to packet bytes */\n  coap_pkt->buffer = data;\n\n  /* parse header fields */\n  coap_pkt->version = (COAP_HEADER_VERSION_MASK & coap_pkt->buffer[0])>>COAP_HEADER_VERSION_POSITION;\n  coap_pkt->type = (COAP_HEADER_TYPE_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TYPE_POSITION;\n  coap_pkt->token_len = MIN(COAP_TOKEN_LEN, (COAP_HEADER_TOKEN_LEN_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TOKEN_LEN_POSITION);\n  coap_pkt->code = coap_pkt->buffer[1];\n  coap_pkt->mid = coap_pkt->buffer[2]<<8 | coap_pkt->buffer[3];\n\n  if (coap_pkt->version != 1)\n  {\n    coap_error_message = \"CoAP version must be 1\";\n    return BAD_REQUEST_4_00;\n  }\n\n  current_option = data + COAP_HEADER_LEN;\n\n  if (coap_pkt->token_len != 0)\n  {\n      memcpy(coap_pkt->token, current_option, coap_pkt->token_len);\n      SET_OPTION(coap_pkt, COAP_OPTION_TOKEN);\n\n      PRINTF(\"Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->token_len,\n        coap_pkt->token[0],\n        coap_pkt->token[1],\n        coap_pkt->token[2],\n        coap_pkt->token[3],\n        coap_pkt->token[4],\n        coap_pkt->token[5],\n        coap_pkt->token[6],\n        coap_pkt->token[7]\n      ); /*FIXME always prints 8 bytes */\n  }\n\n  /* parse options */\n  current_option += coap_pkt->token_len;\n\n  while (current_option < data+data_len)\n  {\n    /* Payload marker 0xFF, currently only checking for 0xF* because rest is reserved */\n    if ((current_option[0] & 0xF0)==0xF0)\n    {\n      coap_pkt->payload = ++current_option;\n      coap_pkt->payload_len = data_len - (coap_pkt->payload - data);\n\n      break;\n    }\n\n    option_delta = current_option[0]>>4;\n    option_length = current_option[0] & 0x0F;\n    ++current_option;\n\n    /* avoids code duplication without function overhead */\n    x = &option_delta;\n    do\n    {\n      if (*x==13)\n      {\n        *x += current_option[0];\n        ++current_option;\n      }\n      else if (*x==14)\n      {\n        *x += 255;\n        *x += current_option[0]<<8;\n        ++current_option;\n        *x += current_option[0];\n        ++current_option;\n      }\n    }\n    while (x!=(unsigned int *)&option_length && (x=(unsigned int *)&option_length));\n\n    option_number += option_delta;\n\n    if (current_option + option_length > data + data_len)\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u) has invalid length.\\n\", option_number, option_delta, option_length);\n        return BAD_REQUEST_4_00;\n    }\n    else\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u): \", option_number, option_delta, option_length);\n    }\n\n    SET_OPTION(coap_pkt, option_number);\n\n    switch (option_number)\n    {\n      case COAP_OPTION_CONTENT_TYPE:\n        coap_pkt->content_type = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Content-Format [%u]\\n\", coap_pkt->content_type);\n        break;\n      case COAP_OPTION_MAX_AGE:\n        coap_pkt->max_age = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Max-Age [%lu]\\n\", coap_pkt->max_age);\n        break;\n      case COAP_OPTION_ETAG:\n        coap_pkt->etag_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->etag, current_option, coap_pkt->etag_len);\n        PRINTF(\"ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->etag_len,\n          coap_pkt->etag[0],\n          coap_pkt->etag[1],\n          coap_pkt->etag[2],\n          coap_pkt->etag[3],\n          coap_pkt->etag[4],\n          coap_pkt->etag[5],\n          coap_pkt->etag[6],\n          coap_pkt->etag[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_ACCEPT:\n        if (coap_pkt->accept_num < COAP_MAX_ACCEPT_NUM)\n        {\n          coap_pkt->accept[coap_pkt->accept_num] = coap_parse_int_option(current_option, option_length);\n          coap_pkt->accept_num += 1;\n          PRINTF(\"Accept [%u]\\n\", coap_pkt->content_type);\n        }\n        break;\n      case COAP_OPTION_IF_MATCH:\n        /*FIXME support multiple ETags */\n        coap_pkt->if_match_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->if_match, current_option, coap_pkt->if_match_len);\n        PRINTF(\"If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->if_match_len,\n          coap_pkt->if_match[0],\n          coap_pkt->if_match[1],\n          coap_pkt->if_match[2],\n          coap_pkt->if_match[3],\n          coap_pkt->if_match[4],\n          coap_pkt->if_match[5],\n          coap_pkt->if_match[6],\n          coap_pkt->if_match[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_IF_NONE_MATCH:\n        coap_pkt->if_none_match = 1;\n        PRINTF(\"If-None-Match\\n\");\n        break;\n\n      case COAP_OPTION_URI_HOST:\n        coap_pkt->uri_host = current_option;\n        coap_pkt->uri_host_len = option_length;\n        PRINTF(\"Uri-Host [%.*s]\\n\", coap_pkt->uri_host_len, coap_pkt->uri_host);\n        break;\n      case COAP_OPTION_URI_PORT:\n        coap_pkt->uri_port = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Uri-Port [%u]\\n\", coap_pkt->uri_port);\n        break;\n      case COAP_OPTION_URI_PATH:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_path), &(coap_pkt->uri_path_len), current_option, option_length, 0);\n        coap_add_multi_option( &(coap_pkt->uri_path), current_option, option_length, 1);\n        PRINTF(\"Uri-Path [%.*s]\\n\", option_length, current_option);\n        break;\n      case COAP_OPTION_URI_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_query), &(coap_pkt->uri_query_len), current_option, option_length, '&');\n        coap_add_multi_option( &(coap_pkt->uri_query), current_option, option_length, 1);\n        PRINTF(\"Uri-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_LOCATION_PATH:\n        coap_add_multi_option( &(coap_pkt->location_path), current_option, option_length, 1);\n        break;\n      case COAP_OPTION_LOCATION_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        coap_merge_multi_option( &(coap_pkt->location_query), &(coap_pkt->location_query_len), current_option, option_length, '&');\n        PRINTF(\"Location-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_PROXY_URI:\n        /*FIXME check for own end-point */\n        coap_pkt->proxy_uri = current_option;\n        coap_pkt->proxy_uri_len = option_length;\n        /*TODO length > 270 not implemented (actually not required) */\n        PRINTF(\"Proxy-Uri NOT IMPLEMENTED [%.*s]\\n\", coap_pkt->proxy_uri_len, coap_pkt->proxy_uri);\n        coap_error_message = \"This is a constrained server (Contiki)\";\n        return PROXYING_NOT_SUPPORTED_5_05;\n        break;\n\n      case COAP_OPTION_OBSERVE:\n        coap_pkt->observe = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Observe [%lu]\\n\", coap_pkt->observe);\n        break;\n      case COAP_OPTION_BLOCK2:\n        coap_pkt->block2_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block2_more = (coap_pkt->block2_num & 0x08)>>3;\n        coap_pkt->block2_size = 16 << (coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_offset = (coap_pkt->block2_num & ~0x0000000F)<<(coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_num >>= 4;\n        PRINTF(\"Block2 [%lu%s (%u B/blk)]\\n\", coap_pkt->block2_num, coap_pkt->block2_more ? \"+\" : \"\", coap_pkt->block2_size);\n        break;\n      case COAP_OPTION_BLOCK1:\n        coap_pkt->block1_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block1_more = (coap_pkt->block1_num & 0x08)>>3;\n        coap_pkt->block1_size = 16 << (coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_offset = (coap_pkt->block1_num & ~0x0000000F)<<(coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_num >>= 4;\n        PRINTF(\"Block1 [%lu%s (%u B/blk)]\\n\", coap_pkt->block1_num, coap_pkt->block1_more ? \"+\" : \"\", coap_pkt->block1_size);\n        break;\n      case COAP_OPTION_SIZE:\n        coap_pkt->size = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Size [%lu]\\n\", coap_pkt->size);\n        break;\n      default:\n        PRINTF(\"unknown (%u)\\n\", option_number);\n        /* Check if critical (odd) */\n        if (option_number & 1)\n        {\n          coap_error_message = \"Unsupported critical option\";\n          return BAD_OPTION_4_02;\n        }\n    }\n\n    current_option += option_length;\n  } /* for */\n  PRINTF(\"-Done parsing-------\\n\");\n\n\n\n  return NO_ERROR;\n}",
        "func": "coap_status_t\ncoap_parse_message(void *packet, uint8_t *data, uint16_t data_len)\n{\n  coap_packet_t *const coap_pkt = (coap_packet_t *) packet;\n  uint8_t *current_option;\n  unsigned int option_number = 0;\n  unsigned int option_delta = 0;\n  size_t option_length = 0;\n  unsigned int *x;\n\n  /* Initialize packet */\n  memset(coap_pkt, 0, sizeof(coap_packet_t));\n\n  /* pointer to packet bytes */\n  coap_pkt->buffer = data;\n\n  /* parse header fields */\n  coap_pkt->version = (COAP_HEADER_VERSION_MASK & coap_pkt->buffer[0])>>COAP_HEADER_VERSION_POSITION;\n  coap_pkt->type = (COAP_HEADER_TYPE_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TYPE_POSITION;\n  coap_pkt->token_len = MIN(COAP_TOKEN_LEN, (COAP_HEADER_TOKEN_LEN_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TOKEN_LEN_POSITION);\n  coap_pkt->code = coap_pkt->buffer[1];\n  coap_pkt->mid = coap_pkt->buffer[2]<<8 | coap_pkt->buffer[3];\n\n  if (coap_pkt->version != 1)\n  {\n    coap_error_message = \"CoAP version must be 1\";\n    return BAD_REQUEST_4_00;\n  }\n\n  current_option = data + COAP_HEADER_LEN;\n\n  if (coap_pkt->token_len != 0)\n  {\n      memcpy(coap_pkt->token, current_option, coap_pkt->token_len);\n      SET_OPTION(coap_pkt, COAP_OPTION_TOKEN);\n\n      PRINTF(\"Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->token_len,\n        coap_pkt->token[0],\n        coap_pkt->token[1],\n        coap_pkt->token[2],\n        coap_pkt->token[3],\n        coap_pkt->token[4],\n        coap_pkt->token[5],\n        coap_pkt->token[6],\n        coap_pkt->token[7]\n      ); /*FIXME always prints 8 bytes */\n  }\n\n  /* parse options */\n  current_option += coap_pkt->token_len;\n\n  while (current_option < data+data_len)\n  {\n    /* Payload marker 0xFF, currently only checking for 0xF* because rest is reserved */\n    if ((current_option[0] & 0xF0)==0xF0)\n    {\n      coap_pkt->payload = ++current_option;\n      coap_pkt->payload_len = data_len - (coap_pkt->payload - data);\n\n      break;\n    }\n\n    option_delta = current_option[0]>>4;\n    option_length = current_option[0] & 0x0F;\n    ++current_option;\n\n    /* avoids code duplication without function overhead */\n    x = &option_delta;\n    do\n    {\n      if (*x==13)\n      {\n        *x += current_option[0];\n        ++current_option;\n      }\n      else if (*x==14)\n      {\n        *x += 255;\n        *x += current_option[0]<<8;\n        ++current_option;\n        *x += current_option[0];\n        ++current_option;\n      }\n    }\n    while (x!=(unsigned int *)&option_length && (x=(unsigned int *)&option_length));\n\n    option_number += option_delta;\n\n    if (current_option + option_length > data + data_len)\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u) has invalid length.\\n\", option_number, option_delta, option_length);\n        coap_free_header(coap_pkt);\n        return BAD_REQUEST_4_00;\n    }\n    else\n    {\n        PRINTF(\"OPTION %u (delta %u, len %u): \", option_number, option_delta, option_length);\n    }\n\n    SET_OPTION(coap_pkt, option_number);\n\n    switch (option_number)\n    {\n      case COAP_OPTION_CONTENT_TYPE:\n        coap_pkt->content_type = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Content-Format [%u]\\n\", coap_pkt->content_type);\n        break;\n      case COAP_OPTION_MAX_AGE:\n        coap_pkt->max_age = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Max-Age [%lu]\\n\", coap_pkt->max_age);\n        break;\n      case COAP_OPTION_ETAG:\n        coap_pkt->etag_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->etag, current_option, coap_pkt->etag_len);\n        PRINTF(\"ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->etag_len,\n          coap_pkt->etag[0],\n          coap_pkt->etag[1],\n          coap_pkt->etag[2],\n          coap_pkt->etag[3],\n          coap_pkt->etag[4],\n          coap_pkt->etag[5],\n          coap_pkt->etag[6],\n          coap_pkt->etag[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_ACCEPT:\n        if (coap_pkt->accept_num < COAP_MAX_ACCEPT_NUM)\n        {\n          coap_pkt->accept[coap_pkt->accept_num] = coap_parse_int_option(current_option, option_length);\n          coap_pkt->accept_num += 1;\n          PRINTF(\"Accept [%u]\\n\", coap_pkt->content_type);\n        }\n        break;\n      case COAP_OPTION_IF_MATCH:\n        /*FIXME support multiple ETags */\n        coap_pkt->if_match_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));\n        memcpy(coap_pkt->if_match, current_option, coap_pkt->if_match_len);\n        PRINTF(\"If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\\n\", coap_pkt->if_match_len,\n          coap_pkt->if_match[0],\n          coap_pkt->if_match[1],\n          coap_pkt->if_match[2],\n          coap_pkt->if_match[3],\n          coap_pkt->if_match[4],\n          coap_pkt->if_match[5],\n          coap_pkt->if_match[6],\n          coap_pkt->if_match[7]\n        ); /*FIXME always prints 8 bytes */\n        break;\n      case COAP_OPTION_IF_NONE_MATCH:\n        coap_pkt->if_none_match = 1;\n        PRINTF(\"If-None-Match\\n\");\n        break;\n\n      case COAP_OPTION_URI_HOST:\n        coap_pkt->uri_host = current_option;\n        coap_pkt->uri_host_len = option_length;\n        PRINTF(\"Uri-Host [%.*s]\\n\", coap_pkt->uri_host_len, coap_pkt->uri_host);\n        break;\n      case COAP_OPTION_URI_PORT:\n        coap_pkt->uri_port = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Uri-Port [%u]\\n\", coap_pkt->uri_port);\n        break;\n      case COAP_OPTION_URI_PATH:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_path), &(coap_pkt->uri_path_len), current_option, option_length, 0);\n        coap_add_multi_option( &(coap_pkt->uri_path), current_option, option_length, 1);\n        PRINTF(\"Uri-Path [%.*s]\\n\", option_length, current_option);\n        break;\n      case COAP_OPTION_URI_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        // coap_merge_multi_option( (char **) &(coap_pkt->uri_query), &(coap_pkt->uri_query_len), current_option, option_length, '&');\n        coap_add_multi_option( &(coap_pkt->uri_query), current_option, option_length, 1);\n        PRINTF(\"Uri-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_LOCATION_PATH:\n        coap_add_multi_option( &(coap_pkt->location_path), current_option, option_length, 1);\n        break;\n      case COAP_OPTION_LOCATION_QUERY:\n        /* coap_merge_multi_option() operates in-place on the IPBUF, but final packet field should be const string -> cast to string */\n        coap_merge_multi_option( &(coap_pkt->location_query), &(coap_pkt->location_query_len), current_option, option_length, '&');\n        PRINTF(\"Location-Query [%.*s]\\n\", option_length, current_option);\n        break;\n\n      case COAP_OPTION_PROXY_URI:\n        /*FIXME check for own end-point */\n        coap_pkt->proxy_uri = current_option;\n        coap_pkt->proxy_uri_len = option_length;\n        /*TODO length > 270 not implemented (actually not required) */\n        PRINTF(\"Proxy-Uri NOT IMPLEMENTED [%.*s]\\n\", coap_pkt->proxy_uri_len, coap_pkt->proxy_uri);\n        coap_error_message = \"This is a constrained server (Contiki)\";\n        return PROXYING_NOT_SUPPORTED_5_05;\n        break;\n\n      case COAP_OPTION_OBSERVE:\n        coap_pkt->observe = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Observe [%lu]\\n\", coap_pkt->observe);\n        break;\n      case COAP_OPTION_BLOCK2:\n        coap_pkt->block2_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block2_more = (coap_pkt->block2_num & 0x08)>>3;\n        coap_pkt->block2_size = 16 << (coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_offset = (coap_pkt->block2_num & ~0x0000000F)<<(coap_pkt->block2_num & 0x07);\n        coap_pkt->block2_num >>= 4;\n        PRINTF(\"Block2 [%lu%s (%u B/blk)]\\n\", coap_pkt->block2_num, coap_pkt->block2_more ? \"+\" : \"\", coap_pkt->block2_size);\n        break;\n      case COAP_OPTION_BLOCK1:\n        coap_pkt->block1_num = coap_parse_int_option(current_option, option_length);\n        coap_pkt->block1_more = (coap_pkt->block1_num & 0x08)>>3;\n        coap_pkt->block1_size = 16 << (coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_offset = (coap_pkt->block1_num & ~0x0000000F)<<(coap_pkt->block1_num & 0x07);\n        coap_pkt->block1_num >>= 4;\n        PRINTF(\"Block1 [%lu%s (%u B/blk)]\\n\", coap_pkt->block1_num, coap_pkt->block1_more ? \"+\" : \"\", coap_pkt->block1_size);\n        break;\n      case COAP_OPTION_SIZE:\n        coap_pkt->size = coap_parse_int_option(current_option, option_length);\n        PRINTF(\"Size [%lu]\\n\", coap_pkt->size);\n        break;\n      default:\n        PRINTF(\"unknown (%u)\\n\", option_number);\n        /* Check if critical (odd) */\n        if (option_number & 1)\n        {\n          coap_error_message = \"Unsupported critical option\";\n          coap_free_header(coap_pkt);\n          return BAD_OPTION_4_02;\n        }\n    }\n\n    current_option += option_length;\n  } /* for */\n  PRINTF(\"-Done parsing-------\\n\");\n\n\n\n  return NO_ERROR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -89,6 +89,7 @@\n     if (current_option + option_length > data + data_len)\n     {\n         PRINTF(\"OPTION %u (delta %u, len %u) has invalid length.\\n\", option_number, option_delta, option_length);\n+        coap_free_header(coap_pkt);\n         return BAD_REQUEST_4_00;\n     }\n     else\n@@ -221,6 +222,7 @@\n         if (option_number & 1)\n         {\n           coap_error_message = \"Unsupported critical option\";\n+          coap_free_header(coap_pkt);\n           return BAD_OPTION_4_02;\n         }\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        coap_free_header(coap_pkt);",
                "          coap_free_header(coap_pkt);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-7175",
        "func_name": "ImageMagick/DecodeImage",
        "description": "In ImageMagick before 7.0.8-25, some memory leaks exist in DecodeImage in coders/pcd.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1450",
        "commit_text": "",
        "func_before": "static MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n  unsigned char *chroma1,unsigned char *chroma2,ExceptionInfo *exception)\n{\n#define IsSync(sum)  ((sum & 0xffffff00UL) == 0xfffffe00UL)\n#define PCDGetBits(n) \\\n{  \\\n  sum=(sum << n) & 0xffffffff; \\\n  bits-=n; \\\n  while (bits <= 24) \\\n  { \\\n    if (p >= (buffer+0x800)) \\\n      { \\\n        count=ReadBlob(image,0x800,buffer); \\\n        p=buffer; \\\n      } \\\n    sum|=((unsigned int) (*p) << (24-bits)); \\\n    bits+=8; \\\n    p++; \\\n  } \\\n}\n\n  typedef struct PCDTable\n  {\n    unsigned int\n      length,\n      sequence;\n\n    MagickStatusType\n      mask;\n\n    unsigned char\n      key;\n  } PCDTable;\n\n  PCDTable\n    *pcd_table[3];\n\n  register ssize_t\n    i,\n    j;\n\n  register PCDTable\n    *r;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bits,\n    length,\n    plane,\n    pcd_length[3],\n    row,\n    sum;\n\n  ssize_t\n    count,\n    quantum;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Initialize Huffman tables.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(luma != (unsigned char *) NULL);\n  assert(chroma1 != (unsigned char *) NULL);\n  assert(chroma2 != (unsigned char *) NULL);\n  buffer=(unsigned char *) AcquireQuantumMemory(0x800,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  sum=0;\n  bits=32;\n  p=buffer+0x800;\n  for (i=0; i < 3; i++)\n  {\n    pcd_table[i]=(PCDTable *) NULL;\n    pcd_length[i]=0;\n  }\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n  {\n    PCDGetBits(8);\n    length=(sum & 0xff)+1;\n    pcd_table[i]=(PCDTable *) AcquireQuantumMemory(length,\n      sizeof(*pcd_table[i]));\n    if (pcd_table[i] == (PCDTable *) NULL)\n      {\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    r=pcd_table[i];\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      PCDGetBits(8);\n      r->length=(unsigned int) (sum & 0xff)+1;\n      if (r->length > 16)\n        {\n          buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n          return(MagickFalse);\n        }\n      PCDGetBits(16);\n      r->sequence=(unsigned int) (sum & 0xffff) << 16;\n      PCDGetBits(8);\n      r->key=(unsigned char) (sum & 0xff);\n      r->mask=(~((1U << (32-r->length))-1));\n      r++;\n    }\n    pcd_length[i]=(size_t) length;\n  }\n  /*\n    Search for Sync byte.\n  */\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  while ((sum & 0x00fff000UL) != 0x00fff000UL)\n    PCDGetBits(8);\n  while (IsSync(sum) == 0)\n    PCDGetBits(1);\n  /*\n    Recover the Huffman encoded luminance and chrominance deltas.\n  */\n  count=0;\n  length=0;\n  plane=0;\n  row=0;\n  q=luma;\n  for ( ; ; )\n  {\n    if (IsSync(sum) != 0)\n      {\n        /*\n          Determine plane and row number.\n        */\n        PCDGetBits(16);\n        row=((sum >> 9) & 0x1fff);\n        if (row == image->rows)\n          break;\n        PCDGetBits(8);\n        plane=sum >> 30;\n        PCDGetBits(16);\n        switch (plane)\n        {\n          case 0:\n          {\n            q=luma+row*image->columns;\n            count=(ssize_t) image->columns;\n            break;\n          }\n          case 2:\n          {\n            q=chroma1+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          case 3:\n          {\n            q=chroma2+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          default:\n          {\n            for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n              pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n            buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n            ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n              image->filename);\n          }\n        }\n        length=pcd_length[plane];\n        continue;\n      }\n    /*\n      Decode luminance or chrominance deltas.\n    */\n    r=pcd_table[plane];\n    for (i=0; ((i < (ssize_t) length) && ((sum & r->mask) != r->sequence)); i++)\n      r++;\n    if ((row > image->rows) || (r == (PCDTable *) NULL))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        while ((sum & 0x00fff000) != 0x00fff000)\n          PCDGetBits(8);\n        while (IsSync(sum) == 0)\n          PCDGetBits(1);\n        continue;\n      }\n    if (r->key < 128)\n      quantum=(ssize_t) (*q)+r->key;\n    else\n      quantum=(ssize_t) (*q)+r->key-256;\n    *q=(unsigned char) ((quantum < 0) ? 0 : (quantum > 255) ? 255 : quantum);\n    q++;\n    PCDGetBits(r->length);\n    count--;\n  }\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n    pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n  unsigned char *chroma1,unsigned char *chroma2,ExceptionInfo *exception)\n{\n#define IsSync(sum)  ((sum & 0xffffff00UL) == 0xfffffe00UL)\n#define PCDGetBits(n) \\\n{  \\\n  sum=(sum << n) & 0xffffffff; \\\n  bits-=n; \\\n  while (bits <= 24) \\\n  { \\\n    if (p >= (buffer+0x800)) \\\n      { \\\n        count=ReadBlob(image,0x800,buffer); \\\n        p=buffer; \\\n      } \\\n    sum|=((unsigned int) (*p) << (24-bits)); \\\n    bits+=8; \\\n    p++; \\\n  } \\\n}\n\n  typedef struct PCDTable\n  {\n    unsigned int\n      length,\n      sequence;\n\n    MagickStatusType\n      mask;\n\n    unsigned char\n      key;\n  } PCDTable;\n\n  PCDTable\n    *pcd_table[3];\n\n  register ssize_t\n    i,\n    j;\n\n  register PCDTable\n    *r;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bits,\n    length,\n    plane,\n    pcd_length[3],\n    row,\n    sum;\n\n  ssize_t\n    count,\n    quantum;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Initialize Huffman tables.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(luma != (unsigned char *) NULL);\n  assert(chroma1 != (unsigned char *) NULL);\n  assert(chroma2 != (unsigned char *) NULL);\n  buffer=(unsigned char *) AcquireQuantumMemory(0x800,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  sum=0;\n  bits=32;\n  p=buffer+0x800;\n  for (i=0; i < 3; i++)\n  {\n    pcd_table[i]=(PCDTable *) NULL;\n    pcd_length[i]=0;\n  }\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n  {\n    PCDGetBits(8);\n    length=(sum & 0xff)+1;\n    pcd_table[i]=(PCDTable *) AcquireQuantumMemory(length,\n      sizeof(*pcd_table[i]));\n    if (pcd_table[i] == (PCDTable *) NULL)\n      {\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        for (j=0; j < i; j++)\n          pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    r=pcd_table[i];\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      PCDGetBits(8);\n      r->length=(unsigned int) (sum & 0xff)+1;\n      if (r->length > 16)\n        {\n          buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n          for (j=0; j <= i; j++)\n            pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);\n          return(MagickFalse);\n        }\n      PCDGetBits(16);\n      r->sequence=(unsigned int) (sum & 0xffff) << 16;\n      PCDGetBits(8);\n      r->key=(unsigned char) (sum & 0xff);\n      r->mask=(~((1U << (32-r->length))-1));\n      r++;\n    }\n    pcd_length[i]=(size_t) length;\n  }\n  /*\n    Search for Sync byte.\n  */\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  while ((sum & 0x00fff000UL) != 0x00fff000UL)\n    PCDGetBits(8);\n  while (IsSync(sum) == 0)\n    PCDGetBits(1);\n  /*\n    Recover the Huffman encoded luminance and chrominance deltas.\n  */\n  count=0;\n  length=0;\n  plane=0;\n  row=0;\n  q=luma;\n  for ( ; ; )\n  {\n    if (IsSync(sum) != 0)\n      {\n        /*\n          Determine plane and row number.\n        */\n        PCDGetBits(16);\n        row=((sum >> 9) & 0x1fff);\n        if (row == image->rows)\n          break;\n        PCDGetBits(8);\n        plane=sum >> 30;\n        PCDGetBits(16);\n        switch (plane)\n        {\n          case 0:\n          {\n            q=luma+row*image->columns;\n            count=(ssize_t) image->columns;\n            break;\n          }\n          case 2:\n          {\n            q=chroma1+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          case 3:\n          {\n            q=chroma2+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          default:\n          {\n            for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n              pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n            buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n            ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n              image->filename);\n          }\n        }\n        length=pcd_length[plane];\n        continue;\n      }\n    /*\n      Decode luminance or chrominance deltas.\n    */\n    r=pcd_table[plane];\n    for (i=0; ((i < (ssize_t) length) && ((sum & r->mask) != r->sequence)); i++)\n      r++;\n    if ((row > image->rows) || (r == (PCDTable *) NULL))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        while ((sum & 0x00fff000) != 0x00fff000)\n          PCDGetBits(8);\n        while (IsSync(sum) == 0)\n          PCDGetBits(1);\n        continue;\n      }\n    if (r->key < 128)\n      quantum=(ssize_t) (*q)+r->key;\n    else\n      quantum=(ssize_t) (*q)+r->key-256;\n    *q=(unsigned char) ((quantum < 0) ? 0 : (quantum > 255) ? 255 : quantum);\n    q++;\n    PCDGetBits(r->length);\n    count--;\n  }\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n    pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -92,6 +92,8 @@\n     if (pcd_table[i] == (PCDTable *) NULL)\n       {\n         buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n+        for (j=0; j < i; j++)\n+          pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);\n         ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n           image->filename);\n       }\n@@ -103,6 +105,8 @@\n       if (r->length > 16)\n         {\n           buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n+          for (j=0; j <= i; j++)\n+            pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);\n           return(MagickFalse);\n         }\n       PCDGetBits(16);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        for (j=0; j < i; j++)",
                "          pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);",
                "          for (j=0; j <= i; j++)",
                "            pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-9857",
        "func_name": "kernel/git/jack/linux-fs/inotify_update_existing_watch",
        "description": "In the Linux kernel through 5.0.2, the function inotify_update_existing_watch() in fs/notify/inotify/inotify_user.c neglects to call fsnotify_put_mark() with IN_MASK_CREATE after fsnotify_find_mark(), which will cause a memory leak (aka refcount leak). Finally, this will cause a denial of service.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs.git/commit/?h=fsnotify&h=62c9d2674b31d4c8a674bee86b7edc6da2803aea",
        "commit_title": "Commit 4d97f7d53da7dc83 (\"inotify: Add flag IN_MASK_CREATE for",
        "commit_text": "inotify_add_watch()\") forgot to call fsnotify_put_mark() with IN_MASK_CREATE after fsnotify_find_mark()  ",
        "func_before": "static int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\t__u32 mask;\n\tint add = (arg & IN_MASK_ADD);\n\tint create = (arg & IN_MASK_CREATE);\n\tint ret;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\telse if (create)\n\t\treturn -EEXIST;\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tspin_lock(&fsn_mark->lock);\n\told_mask = fsn_mark->mask;\n\tif (add)\n\t\tfsn_mark->mask |= mask;\n\telse\n\t\tfsn_mark->mask = mask;\n\tnew_mask = fsn_mark->mask;\n\tspin_unlock(&fsn_mark->lock);\n\n\tif (old_mask != new_mask) {\n\t\t/* more bits in old than in new? */\n\t\tint dropped = (old_mask & ~new_mask);\n\t\t/* more bits in this fsn_mark than the inode's mask? */\n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\n\t\t/* update the inode with this new fsn_mark */\n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_mask(inode->i_fsnotify_marks);\n\n\t}\n\n\t/* return the wd */\n\tret = i_mark->wd;\n\n\t/* match the get from fsnotify_find_mark() */\n\tfsnotify_put_mark(fsn_mark);\n\n\treturn ret;\n}",
        "func": "static int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\t__u32 mask;\n\tint add = (arg & IN_MASK_ADD);\n\tint create = (arg & IN_MASK_CREATE);\n\tint ret;\n\n\tmask = inotify_arg_to_mask(arg);\n\n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\telse if (create) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\n\tspin_lock(&fsn_mark->lock);\n\told_mask = fsn_mark->mask;\n\tif (add)\n\t\tfsn_mark->mask |= mask;\n\telse\n\t\tfsn_mark->mask = mask;\n\tnew_mask = fsn_mark->mask;\n\tspin_unlock(&fsn_mark->lock);\n\n\tif (old_mask != new_mask) {\n\t\t/* more bits in old than in new? */\n\t\tint dropped = (old_mask & ~new_mask);\n\t\t/* more bits in this fsn_mark than the inode's mask? */\n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\n\t\t/* update the inode with this new fsn_mark */\n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_mask(inode->i_fsnotify_marks);\n\n\t}\n\n\t/* return the wd */\n\tret = i_mark->wd;\n\nout:\n\t/* match the get from fsnotify_find_mark() */\n\tfsnotify_put_mark(fsn_mark);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,8 +15,10 @@\n \tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n \tif (!fsn_mark)\n \t\treturn -ENOENT;\n-\telse if (create)\n-\t\treturn -EEXIST;\n+\telse if (create) {\n+\t\tret = -EEXIST;\n+\t\tgoto out;\n+\t}\n \n \ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n \n@@ -44,6 +46,7 @@\n \t/* return the wd */\n \tret = i_mark->wd;\n \n+out:\n \t/* match the get from fsnotify_find_mark() */\n \tfsnotify_put_mark(fsn_mark);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\telse if (create)",
                "\t\treturn -EEXIST;"
            ],
            "added_lines": [
                "\telse if (create) {",
                "\t\tret = -EEXIST;",
                "\t\tgoto out;",
                "\t}",
                "out:"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10649",
        "func_name": "ImageMagick/SVGEndElement",
        "description": "In ImageMagick 7.0.8-36 Q16, there is a memory leak in the function SVGKeyValuePairs of coders/svg.c, which allows an attacker to cause a denial of service via a crafted image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d3ae9c19125c8704b4866381f7a064ca2cbdc006",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1533",
        "commit_text": "",
        "func_before": "static void SVGEndElement(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Called when the end of an element has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.endElement(%s)\",name);\n  svg_info=(SVGInfo *) context;\n  if (strchr((char *) name,':') != (char *) NULL)\n    {\n      /*\n        Skip over namespace.\n      */\n      for ( ; *name != ':'; name++) ;\n      name++;\n    }\n  switch (*name)\n  {\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) name,\"circle\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"circle\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"circle %g,%g %g,%g\\n\",\n            svg_info->element.cx,svg_info->element.cy,svg_info->element.cx,\n            svg_info->element.cy+svg_info->element.minor);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"clipPath\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop clip-path\\n\");\n          break;\n        }\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare((const char *) name,\"defs\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop defs\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"desc\") == 0)\n        {\n          register char\n            *p;\n\n          if (*svg_info->text == '\\0')\n            break;\n          (void) fputc('#',svg_info->file);\n          for (p=svg_info->text; *p != '\\0'; p++)\n          {\n            (void) fputc(*p,svg_info->file);\n            if (*p == '\\n')\n              (void) fputc('#',svg_info->file);\n          }\n          (void) fputc('\\n',svg_info->file);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n        {\n          double\n            angle;\n\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"ellipse\\\"\\n\");\n          angle=svg_info->element.angle;\n          (void) FormatLocaleFile(svg_info->file,\"ellipse %g,%g %g,%g 0,360\\n\",\n            svg_info->element.cx,svg_info->element.cy,\n            angle == 0.0 ? svg_info->element.major : svg_info->element.minor,\n            angle == 0.0 ? svg_info->element.minor : svg_info->element.major);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare((const char *) name,\"foreignObject\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) name,\"g\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) name,\"image\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"image Over %g,%g %g,%g \\\"%s\\\"\\n\",svg_info->bounds.x,\n            svg_info->bounds.y,svg_info->bounds.width,svg_info->bounds.height,\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) name,\"line\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"line\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"line %g,%g %g,%g\\n\",\n            svg_info->segment.x1,svg_info->segment.y1,svg_info->segment.x2,\n            svg_info->segment.y2);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"linearGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) name,\"mask\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop mask\\n\");\n          break;\n        }\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare((const char *) name,\"pattern\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop pattern\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"path\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"path\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"path \\\"%s\\\"\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polygon\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polygon\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polygon %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polyline\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polyline\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polyline %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare((const char *) name,\"radialGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"rect\") == 0)\n        {\n          if ((svg_info->radius.x == 0.0) && (svg_info->radius.y == 0.0))\n            {\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"rect\\\"\\n\");\n              if ((fabs(svg_info->bounds.width-1.0) < MagickEpsilon) &&\n                  (fabs(svg_info->bounds.height-1.0) < MagickEpsilon))\n                (void) FormatLocaleFile(svg_info->file,\"point %g,%g\\n\",\n                  svg_info->bounds.x,svg_info->bounds.y);\n              else\n                (void) FormatLocaleFile(svg_info->file,\n                  \"rectangle %g,%g %g,%g\\n\",svg_info->bounds.x,\n                  svg_info->bounds.y,svg_info->bounds.x+svg_info->bounds.width,\n                  svg_info->bounds.y+svg_info->bounds.height);\n              (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n              break;\n            }\n          if (svg_info->radius.x == 0.0)\n            svg_info->radius.x=svg_info->radius.y;\n          if (svg_info->radius.y == 0.0)\n            svg_info->radius.y=svg_info->radius.x;\n          (void) FormatLocaleFile(svg_info->file,\n            \"roundRectangle %g,%g %g,%g %g,%g\\n\",\n            svg_info->bounds.x,svg_info->bounds.y,svg_info->bounds.x+\n            svg_info->bounds.width,svg_info->bounds.y+svg_info->bounds.height,\n            svg_info->radius.x,svg_info->radius.y);\n          svg_info->radius.x=0.0;\n          svg_info->radius.y=0.0;\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare((const char *) name,\"stop\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"stop-color \\\"%s\\\" %s\\n\",\n            svg_info->stop_color,svg_info->offset);\n          break;\n        }\n      if (LocaleCompare((char *) name,\"style\") == 0)\n        {\n          char\n            *keyword,\n            **tokens,\n            *value;\n\n          register ssize_t\n            j;\n\n          size_t\n            number_tokens;\n\n          /*\n            Find style definitions in svg_info->text.\n          */\n          tokens=SVGKeyValuePairs(context,'{','}',svg_info->text,\n            &number_tokens);\n          if (tokens == (char **) NULL)\n            break;\n          for (j=0; j < (ssize_t) (number_tokens-1); j+=2)\n          {\n            keyword=(char *) tokens[j];\n            value=(char *) tokens[j+1];\n            (void) FormatLocaleFile(svg_info->file,\"push class \\\"%s\\\"\\n\",\n              *keyword == '.' ? keyword+1 : keyword);\n            SVGProcessStyleElement(context,name,value);\n            (void) FormatLocaleFile(svg_info->file,\"pop class\\n\");\n          }\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"svg\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          svg_info->svgDepth--;\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"symbol\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop symbol\\n\");\n          break;\n        }\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare((const char *) name,\"text\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              SVGStripString(MagickTrue,svg_info->text);\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text 0,0 \\\"%s\\\"\\n\",text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n              svg_info->center.x=0.0;\n              svg_info->center.y=0.0;\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"tspan\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"tspan\\\"\\n\");\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text %g,%g \\\"%s\\\"\\n\",\n                svg_info->bounds.x-svg_info->center.x,svg_info->bounds.y-\n                svg_info->center.y,text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"title\") == 0)\n        {\n          if (*svg_info->text == '\\0')\n            break;\n          (void) CloneString(&svg_info->title,svg_info->text);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare((char *) name,\"use\") == 0)\n        {\n          if ((svg_info->bounds.x != 0.0) || (svg_info->bounds.y != 0.0))\n            (void) FormatLocaleFile(svg_info->file,\"translate %g,%g\\n\",\n              svg_info->bounds.x,svg_info->bounds.y);\n          (void) FormatLocaleFile(svg_info->file,\"use \\\"url(%s)\\\"\\n\",\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  *svg_info->text='\\0';\n  (void) memset(&svg_info->element,0,sizeof(svg_info->element));\n  (void) memset(&svg_info->segment,0,sizeof(svg_info->segment));\n  svg_info->n--;\n}",
        "func": "static void SVGEndElement(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Called when the end of an element has been detected.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.endElement(%s)\",name);\n  svg_info=(SVGInfo *) context;\n  if (strchr((char *) name,':') != (char *) NULL)\n    {\n      /*\n        Skip over namespace.\n      */\n      for ( ; *name != ':'; name++) ;\n      name++;\n    }\n  switch (*name)\n  {\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare((const char *) name,\"circle\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"circle\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"circle %g,%g %g,%g\\n\",\n            svg_info->element.cx,svg_info->element.cy,svg_info->element.cx,\n            svg_info->element.cy+svg_info->element.minor);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"clipPath\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop clip-path\\n\");\n          break;\n        }\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare((const char *) name,\"defs\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop defs\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"desc\") == 0)\n        {\n          register char\n            *p;\n\n          if (*svg_info->text == '\\0')\n            break;\n          (void) fputc('#',svg_info->file);\n          for (p=svg_info->text; *p != '\\0'; p++)\n          {\n            (void) fputc(*p,svg_info->file);\n            if (*p == '\\n')\n              (void) fputc('#',svg_info->file);\n          }\n          (void) fputc('\\n',svg_info->file);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare((const char *) name,\"ellipse\") == 0)\n        {\n          double\n            angle;\n\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"ellipse\\\"\\n\");\n          angle=svg_info->element.angle;\n          (void) FormatLocaleFile(svg_info->file,\"ellipse %g,%g %g,%g 0,360\\n\",\n            svg_info->element.cx,svg_info->element.cy,\n            angle == 0.0 ? svg_info->element.major : svg_info->element.minor,\n            angle == 0.0 ? svg_info->element.minor : svg_info->element.major);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleCompare((const char *) name,\"foreignObject\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare((const char *) name,\"g\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare((const char *) name,\"image\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\n            \"image Over %g,%g %g,%g \\\"%s\\\"\\n\",svg_info->bounds.x,\n            svg_info->bounds.y,svg_info->bounds.width,svg_info->bounds.height,\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare((const char *) name,\"line\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"line\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"line %g,%g %g,%g\\n\",\n            svg_info->segment.x1,svg_info->segment.y1,svg_info->segment.x2,\n            svg_info->segment.y2);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"linearGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare((const char *) name,\"mask\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop mask\\n\");\n          break;\n        }\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare((const char *) name,\"pattern\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop pattern\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"path\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"path\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"path \\\"%s\\\"\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polygon\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polygon\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polygon %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"polyline\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"class \\\"polyline\\\"\\n\");\n          (void) FormatLocaleFile(svg_info->file,\"polyline %s\\n\",\n            svg_info->vertices);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare((const char *) name,\"radialGradient\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop gradient\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"rect\") == 0)\n        {\n          if ((svg_info->radius.x == 0.0) && (svg_info->radius.y == 0.0))\n            {\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"rect\\\"\\n\");\n              if ((fabs(svg_info->bounds.width-1.0) < MagickEpsilon) &&\n                  (fabs(svg_info->bounds.height-1.0) < MagickEpsilon))\n                (void) FormatLocaleFile(svg_info->file,\"point %g,%g\\n\",\n                  svg_info->bounds.x,svg_info->bounds.y);\n              else\n                (void) FormatLocaleFile(svg_info->file,\n                  \"rectangle %g,%g %g,%g\\n\",svg_info->bounds.x,\n                  svg_info->bounds.y,svg_info->bounds.x+svg_info->bounds.width,\n                  svg_info->bounds.y+svg_info->bounds.height);\n              (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n              break;\n            }\n          if (svg_info->radius.x == 0.0)\n            svg_info->radius.x=svg_info->radius.y;\n          if (svg_info->radius.y == 0.0)\n            svg_info->radius.y=svg_info->radius.x;\n          (void) FormatLocaleFile(svg_info->file,\n            \"roundRectangle %g,%g %g,%g %g,%g\\n\",\n            svg_info->bounds.x,svg_info->bounds.y,svg_info->bounds.x+\n            svg_info->bounds.width,svg_info->bounds.y+svg_info->bounds.height,\n            svg_info->radius.x,svg_info->radius.y);\n          svg_info->radius.x=0.0;\n          svg_info->radius.y=0.0;\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare((const char *) name,\"stop\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"stop-color \\\"%s\\\" %s\\n\",\n            svg_info->stop_color,svg_info->offset);\n          break;\n        }\n      if (LocaleCompare((char *) name,\"style\") == 0)\n        {\n          char\n            *keyword,\n            **tokens,\n            *value;\n\n          register ssize_t\n            j;\n\n          size_t\n            number_tokens;\n\n          /*\n            Find style definitions in svg_info->text.\n          */\n          tokens=SVGKeyValuePairs(context,'{','}',svg_info->text,\n            &number_tokens);\n          if (tokens == (char **) NULL)\n            break;\n          for (j=0; j < (ssize_t) (number_tokens-1); j+=2)\n          {\n            keyword=(char *) tokens[j];\n            value=(char *) tokens[j+1];\n            (void) FormatLocaleFile(svg_info->file,\"push class \\\"%s\\\"\\n\",\n              *keyword == '.' ? keyword+1 : keyword);\n            SVGProcessStyleElement(context,name,value);\n            (void) FormatLocaleFile(svg_info->file,\"pop class\\n\");\n          }\n          for (j=0; tokens[j] != (char *) NULL; j++)\n            tokens[j]=DestroyString(tokens[j]);\n          tokens=(char **) RelinquishMagickMemory(tokens);\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"svg\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          svg_info->svgDepth--;\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"symbol\") == 0)\n        {\n          (void) FormatLocaleFile(svg_info->file,\"pop symbol\\n\");\n          break;\n        }\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare((const char *) name,\"text\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              SVGStripString(MagickTrue,svg_info->text);\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text 0,0 \\\"%s\\\"\\n\",text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n              svg_info->center.x=0.0;\n              svg_info->center.y=0.0;\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"tspan\") == 0)\n        {\n          if (*svg_info->text != '\\0')\n            {\n              char\n                *text;\n\n              (void) FormatLocaleFile(svg_info->file,\"class \\\"tspan\\\"\\n\");\n              text=EscapeString(svg_info->text,'\\\"');\n              (void) FormatLocaleFile(svg_info->file,\"text %g,%g \\\"%s\\\"\\n\",\n                svg_info->bounds.x-svg_info->center.x,svg_info->bounds.y-\n                svg_info->center.y,text);\n              text=DestroyString(text);\n              *svg_info->text='\\0';\n            }\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      if (LocaleCompare((const char *) name,\"title\") == 0)\n        {\n          if (*svg_info->text == '\\0')\n            break;\n          (void) CloneString(&svg_info->title,svg_info->text);\n          *svg_info->text='\\0';\n          break;\n        }\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare((char *) name,\"use\") == 0)\n        {\n          if ((svg_info->bounds.x != 0.0) || (svg_info->bounds.y != 0.0))\n            (void) FormatLocaleFile(svg_info->file,\"translate %g,%g\\n\",\n              svg_info->bounds.x,svg_info->bounds.y);\n          (void) FormatLocaleFile(svg_info->file,\"use \\\"url(%s)\\\"\\n\",\n            svg_info->url);\n          (void) FormatLocaleFile(svg_info->file,\"pop graphic-context\\n\");\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  *svg_info->text='\\0';\n  (void) memset(&svg_info->element,0,sizeof(svg_info->element));\n  (void) memset(&svg_info->segment,0,sizeof(svg_info->segment));\n  svg_info->n--;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -261,6 +261,9 @@\n             SVGProcessStyleElement(context,name,value);\n             (void) FormatLocaleFile(svg_info->file,\"pop class\\n\");\n           }\n+          for (j=0; tokens[j] != (char *) NULL; j++)\n+            tokens[j]=DestroyString(tokens[j]);\n+          tokens=(char **) RelinquishMagickMemory(tokens);\n           break;\n         }\n       if (LocaleCompare((const char *) name,\"svg\") == 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "          for (j=0; tokens[j] != (char *) NULL; j++)",
                "            tokens[j]=DestroyString(tokens[j]);",
                "          tokens=(char **) RelinquishMagickMemory(tokens);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11463",
        "func_name": "libarchive/archive_read_format_zip_cleanup",
        "description": "A memory leak in archive_read_format_zip_cleanup in archive_read_support_format_zip.c in libarchive 3.3.4-dev allows remote attackers to cause a denial of service via a crafted ZIP file because of a HAVE_LZMA_H typo. NOTE: this only affects users who downloaded the development code from GitHub. Users of the product's official releases are unaffected.",
        "git_url": "https://github.com/libarchive/libarchive/commit/ba641f73f3d758d9032b3f0e5597a9c6e593a505",
        "commit_title": "Fix typo in preprocessor macro in archive_read_format_zip_cleanup()",
        "commit_text": " Frees lzma_stream on cleanup()  Fixes #1165",
        "func_before": "static int\narchive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\n\tzip = (struct zip *)(a->format->data);\n\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\n\tfree(zip->uncompressed_buffer);\n\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}",
        "func": "static int\narchive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\n\tzip = (struct zip *)(a->format->data);\n\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n\n#if HAVE_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\n\tfree(zip->uncompressed_buffer);\n\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \t\tinflateEnd(&zip->stream);\n #endif\n \n-#if HAVA_LZMA_H && HAVE_LIBLZMA\n+#if HAVE_LZMA_H && HAVE_LIBLZMA\n     if (zip->zipx_lzma_valid) {\n \t\tlzma_end(&zip->zipx_lzma_stream);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "#if HAVA_LZMA_H && HAVE_LIBLZMA"
            ],
            "added_lines": [
                "#if HAVE_LZMA_H && HAVE_LIBLZMA"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39176",
        "func_name": "sonicdoe/detect-character-encoding/NAN_METHOD",
        "description": "detect-character-encoding is a package for detecting character encoding using ICU. In detect-character-encoding v0.3.0 and earlier, allocated memory is not released. The problem has been patched in detect-character-encoding v0.3.1.",
        "git_url": "https://github.com/sonicdoe/detect-character-encoding/commit/d44356927b92e3b13e178071bf6d7c671766f588",
        "commit_title": "Fix memory leak by properly closing `charsetDetector`",
        "commit_text": "",
        "func_before": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\n\tcharsetDetector = ucsdet_open(&errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\treturn;\n\t}\n\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\treturn;\n\t}\n\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\treturn;\n\t}\n\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\treturn;\n\t}\n\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\n\tinfo.GetReturnValue().Set(obj);\n}",
        "func": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\n\tcharsetDetector = ucsdet_open(&errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,7 @@\n \n \tif(U_FAILURE(errorCode)) {\n \t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n+\t\tucsdet_close(charsetDetector);\n \t\treturn;\n \t}\n \n@@ -30,6 +31,7 @@\n \n \tif(U_FAILURE(errorCode)) {\n \t\tNan::ThrowError(\"Failed to detect charset.\");\n+\t\tucsdet_close(charsetDetector);\n \t\treturn;\n \t}\n \n@@ -37,6 +39,7 @@\n \n \tif(U_FAILURE(errorCode)) {\n \t\tNan::ThrowError(\"Failed to get name from charset match.\");\n+\t\tucsdet_close(charsetDetector);\n \t\treturn;\n \t}\n \n@@ -44,6 +47,7 @@\n \n \tif(U_FAILURE(errorCode)) {\n \t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n+\t\tucsdet_close(charsetDetector);\n \t\treturn;\n \t}\n \n@@ -52,4 +56,5 @@\n \tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n \n \tinfo.GetReturnValue().Set(obj);\n+\tucsdet_close(charsetDetector);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tucsdet_close(charsetDetector);",
                "\t\tucsdet_close(charsetDetector);",
                "\t\tucsdet_close(charsetDetector);",
                "\t\tucsdet_close(charsetDetector);",
                "\tucsdet_close(charsetDetector);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33364",
        "func_name": "gpac/gf_isom_parse_movie_boxes_internal",
        "description": "Memory leak in the def_parent_box_new function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.",
        "git_url": "https://github.com/gpac/gpac/commit/fe5155cf047252d1c4cb91602048bfa682af0ea7",
        "commit_title": "fixed #1783 (fuzz)",
        "commit_text": "",
        "func_before": "static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Box *a;\n\tu64 totSize, mdat_end=0;\n\tGF_Err e = GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n\t\treturn e;\n\t}\n\n\t/*restart from where we stopped last*/\n\ttotSize = mov->current_top_box_start;\n\tif (mov->bytes_removed) {\n\t\tassert(totSize >= mov->bytes_removed);\n\t\ttotSize -= mov->bytes_removed;\n\t}\n\tgf_bs_seek(mov->movieFileMap->bs, totSize);\n#endif\n\n\n\t/*while we have some data, parse our boxes*/\n\twhile (gf_bs_available(mov->movieFileMap->bs)) {\n\t\t*bytesMissing = 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n#endif\n\n\t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n\n\t\tif (e >= 0) {\n\n\t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t/*our mdat is uncomplete, only valid for READ ONLY files...*/\n\t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn e;\n\t\t} else {\n\t\t\treturn e;\n\t\t}\n\n\t\tswitch (a->type) {\n\t\t/*MOOV box*/\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tif (mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->moov = (GF_MovieBox *)a;\n\t\t\tmov->original_moov_offset = mov->current_top_box_start;\n\t\t\t/*set our pointer to the movie*/\n\t\t\tmov->moov->mov = mov;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tgf_isom_setup_traf_inheritance(mov);\n\t\t\t}\n#endif\n\n#endif\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\n\t\t\ttotSize += a->size;\n\n            if (!mov->moov->mvhd) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                return GF_ISOM_INVALID_FILE;\n            }\n\n            if (mov->meta) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\n\t\t\t//dump senc info in dump mode\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\n\t\t\t\t\tif (trak->sample_encryption) {\n\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n            if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                gf_isom_push_mdat_end(mov, mdat_end);\n                mdat_end=0;\n            }\n\t\t\tbreak;\n\n\t\t/*META box*/\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tif (mov->meta) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->meta = (GF_MetaBox *)a;\n\t\t\tmov->original_meta_offset = mov->current_top_box_start;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\ttotSize += a->size;\n            if (mov->moov) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/*we only keep the MDAT in READ for dump purposes*/\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tif (!mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t\t\tif (!mov->mdat) {\n\t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n\t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n#endif\n\t\t\t\telse gf_isom_box_del(a); //in other modes we don't care\n\n\n\t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                    mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                    if (mov->moov) {\n                        gf_isom_push_mdat_end(mov, mdat_end);\n                        mdat_end=0;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if we don't have any MDAT yet, create one (edit-write mode)\n\t\t\tWe only work with one mdat, but we're puting it at the place\n\t\t\tof the first mdat found when opening a file for editing*/\n\t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\tif (e) {\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->brand) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->brand = (GF_FileTypeBox *)a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_OTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->otyp) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tmov->otyp = (GF_Box *)a;\n\t\t\t\ttotSize += a->size;\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n\t\t\t\tif (brand) {\n\t\t\t\t\ts32 pos;\n\t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n\t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n\t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n\t\t\t\t\tmov->brand = brand;\n\t\t\t\t\tif (pos<0) pos=0;\n\t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t/*ONE AND ONLY ONE PDIN*/\n\t\t\tif (mov->pdin) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\t{\n\t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n\t\t\tswitch (brand) {\n\t\t\tcase GF_ISOM_BRAND_SISX:\n\t\t\tcase GF_ISOM_BRAND_RISX:\n\t\t\tcase GF_ISOM_BRAND_SSSS:\n\t\t\t\tmov->is_index_segment = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*fall-through*/\n\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n\t\t\t) {\n\t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n\t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n\t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n\n\t\t\t\t}\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n\n\t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n\t\t\t\t\tmov->seg_styp = a;\n\t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n\t\t\t\t\tmov->seg_ssix = a;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n\t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n\t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n\t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n\t\t\t//no support for inplace rewrite for fragmented files\n\t\t\tgf_isom_disable_inplace_rewrite(mov);\n\t\t\tif (!mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n\t\t\t}\n\t\t\tif (mov->single_moof_mode) {\n\t\t\t\tmov->single_moof_state++;\n\t\t\t\tif (mov->single_moof_state > 1) {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n\n\t\t\ttotSize += a->size;\n\t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n\n\t\t\t/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/\n\t\t\tFixTrackID(mov);\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tFixSDTPInTRAF(mov->moof);\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\tif (traf->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*read & debug: store at root level*/\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_list_add(mov->TopBoxes, a);\n\t\t\t\t/*also update pointers to trex for debug*/\n\t\t\t\tif (mov->moov) {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tu32 j=0;\n\t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttraf->trex = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly\n\t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->sample_encryption) {\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n\t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n\t\t\t\tmov->moof = NULL;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\t/*merge all info*/\n\t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\t//done with moov\n\t\t\tif (mov->root_sidx) {\n\t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n\t\t\t\tmov->root_sidx = NULL;\n\t\t\t}\n\t\t\tif (mov->root_ssix) {\n\t\t\t\tgf_isom_box_del(mov->seg_ssix);\n\t\t\t\tmov->root_ssix = NULL;\n\t\t\t}\n\t\t\tif (mov->seg_styp) {\n\t\t\t\tgf_isom_box_del(mov->seg_styp);\n\t\t\t\tmov->seg_styp = NULL;\n\t\t\t}\n\t\t\tmov->sidx_start_offset = 0;\n\t\t\tmov->sidx_end_offset = 0;\n\t\t\tmov->styp_start_offset = 0;\n\t\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t{\n\t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n\t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n\t\t\t\tu8 *c = (u8 *) box->data;\n\t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n\t\t\t\t\tmov->is_jp2 = 1;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PRFT:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\t//keep the last one read\n\t\t\t\tif (mov->last_producer_ref_time)\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\telse\n\t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t//fallthrough\n\n\t\tdefault:\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*remember where we left, in case we append an entire number of movie fragments*/\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n#endif\n\t}\n\n\t/*we need at least moov or meta*/\n\tif (!mov->moov && !mov->meta\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t        && !mov->moof && !mov->is_index_segment\n#endif\n\t   ) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\t/*we MUST have movie header*/\n\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\tif (mov->moov && !mov->moov->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t/*we MUST have meta handler*/\n\t\tif (mov->meta && !mov->meta->handler) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tif (mov->moov) {\n\t\t/*set the default interleaving time*/\n\t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*in edit mode with successfully loaded fragments, delete all fragment signaling since\n\t\tfile is no longer fragmented*/\n\t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n\t\t\tmov->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t}\n\n\t//create a default mdat if none was found\n\tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\tif (e) return e;\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn GF_OK;\n}",
        "func": "static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Box *a;\n\tu64 totSize, mdat_end=0;\n\tGF_Err e = GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n\t\treturn e;\n\t}\n\n\t/*restart from where we stopped last*/\n\ttotSize = mov->current_top_box_start;\n\tif (mov->bytes_removed) {\n\t\tassert(totSize >= mov->bytes_removed);\n\t\ttotSize -= mov->bytes_removed;\n\t}\n\tgf_bs_seek(mov->movieFileMap->bs, totSize);\n#endif\n\n\n\t/*while we have some data, parse our boxes*/\n\twhile (gf_bs_available(mov->movieFileMap->bs)) {\n\t\t*bytesMissing = 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n#endif\n\n\t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n\n\t\tif (e >= 0) {\n\n\t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t/*our mdat is uncomplete, only valid for READ ONLY files...*/\n\t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn e;\n\t\t} else {\n\t\t\treturn e;\n\t\t}\n\n\t\tswitch (a->type) {\n\t\t/*MOOV box*/\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tif (mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->moov = (GF_MovieBox *)a;\n\t\t\tmov->original_moov_offset = mov->current_top_box_start;\n\t\t\t/*set our pointer to the movie*/\n\t\t\tmov->moov->mov = mov;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tgf_isom_setup_traf_inheritance(mov);\n\t\t\t}\n#endif\n\n#endif\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\n\t\t\ttotSize += a->size;\n\n            if (!mov->moov->mvhd) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                return GF_ISOM_INVALID_FILE;\n            }\n\n            if (mov->meta) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\n\t\t\t//dump senc info in dump mode\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\n\t\t\t\t\tif (trak->sample_encryption) {\n\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n            if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                gf_isom_push_mdat_end(mov, mdat_end);\n                mdat_end=0;\n            }\n\t\t\tbreak;\n\n\t\t/*META box*/\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tif (mov->meta) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->meta = (GF_MetaBox *)a;\n\t\t\tmov->original_meta_offset = mov->current_top_box_start;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\ttotSize += a->size;\n            if (mov->moov) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/*we only keep the MDAT in READ for dump purposes*/\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tif (!mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t\t\tif (!mov->mdat) {\n\t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n\t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n#endif\n\t\t\t\telse gf_isom_box_del(a); //in other modes we don't care\n\n\n\t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                    mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                    if (mov->moov) {\n                        gf_isom_push_mdat_end(mov, mdat_end);\n                        mdat_end=0;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if we don't have any MDAT yet, create one (edit-write mode)\n\t\t\tWe only work with one mdat, but we're puting it at the place\n\t\t\tof the first mdat found when opening a file for editing*/\n\t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\tif (e) {\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->brand) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->brand = (GF_FileTypeBox *)a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_OTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->otyp) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tmov->otyp = (GF_Box *)a;\n\t\t\t\ttotSize += a->size;\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n\t\t\t\tif (brand) {\n\t\t\t\t\ts32 pos;\n\t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n\t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n\t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n\t\t\t\t\tmov->brand = brand;\n\t\t\t\t\tif (pos<0) pos=0;\n\t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t/*ONE AND ONLY ONE PDIN*/\n\t\t\tif (mov->pdin) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\t{\n\t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n\t\t\tswitch (brand) {\n\t\t\tcase GF_ISOM_BRAND_SISX:\n\t\t\tcase GF_ISOM_BRAND_RISX:\n\t\t\tcase GF_ISOM_BRAND_SSSS:\n\t\t\t\tmov->is_index_segment = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*fall-through*/\n\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n\t\t\t) {\n\t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n\t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n\t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n\n\t\t\t\t}\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n\n\t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n\t\t\t\t\tmov->seg_styp = a;\n\t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n\t\t\t\t\tmov->seg_ssix = a;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n\t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n\t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n\t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n\t\t\t//no support for inplace rewrite for fragmented files\n\t\t\tgf_isom_disable_inplace_rewrite(mov);\n\t\t\tif (!mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n\t\t\t}\n\t\t\tif (mov->single_moof_mode) {\n\t\t\t\tmov->single_moof_state++;\n\t\t\t\tif (mov->single_moof_state > 1) {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n\n\t\t\ttotSize += a->size;\n\t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n\n\t\t\t/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/\n\t\t\tFixTrackID(mov);\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tFixSDTPInTRAF(mov->moof);\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\tif (traf->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*read & debug: store at root level*/\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_list_add(mov->TopBoxes, a);\n\t\t\t\t/*also update pointers to trex for debug*/\n\t\t\t\tif (mov->moov) {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tu32 j=0;\n\t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttraf->trex = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly\n\t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->sample_encryption) {\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n\t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n\t\t\t\tmov->moof = NULL;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\t/*merge all info*/\n\t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\t//done with moov\n\t\t\tif (mov->root_sidx) {\n\t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n\t\t\t\tmov->root_sidx = NULL;\n\t\t\t}\n\t\t\tif (mov->root_ssix) {\n\t\t\t\tgf_isom_box_del(mov->seg_ssix);\n\t\t\t\tmov->root_ssix = NULL;\n\t\t\t}\n\t\t\tif (mov->seg_styp) {\n\t\t\t\tgf_isom_box_del(mov->seg_styp);\n\t\t\t\tmov->seg_styp = NULL;\n\t\t\t}\n\t\t\tmov->sidx_start_offset = 0;\n\t\t\tmov->sidx_end_offset = 0;\n\t\t\tmov->styp_start_offset = 0;\n\t\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t{\n\t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n\t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n\t\t\t\tu8 *c = (u8 *) box->data;\n\t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n\t\t\t\t\tmov->is_jp2 = 1;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PRFT:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\t//keep the last one read\n\t\t\t\tif (mov->last_producer_ref_time)\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\telse\n\t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t//fallthrough\n\n\t\tdefault:\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*remember where we left, in case we append an entire number of movie fragments*/\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n#endif\n\t}\n\n\t/*we need at least moov or meta*/\n\tif (!mov->moov && !mov->meta\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t        && !mov->moof && !mov->is_index_segment\n#endif\n\t   ) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\t/*we MUST have movie header*/\n\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\tif (mov->moov && !mov->moov->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t/*we MUST have meta handler*/\n\t\tif (mov->meta && !mov->meta->handler) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tif (mov->moov) {\n\t\t/*set the default interleaving time*/\n\t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*in edit mode with successfully loaded fragments, delete all fragment signaling since\n\t\tfile is no longer fragmented*/\n\t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n\t\t\tmov->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t}\n\n\t//create a default mdat if none was found\n\tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\tif (e) return e;\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -209,6 +209,7 @@\n \t\t\t\t\tif (pos<0) pos=0;\n \t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n \t\t\t\t}\n+\t\t\t\tgf_isom_box_del(a);\n \t\t\t}\n \t\t\tbreak;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tgf_isom_box_del(a);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33366",
        "func_name": "gpac/gf_isom_oinf_read_entry",
        "description": "Memory leak in the gf_isom_oinf_read_entry function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.",
        "git_url": "https://github.com/gpac/gpac/commit/0a85029d694f992f3631e2f249e4999daee15cbf",
        "commit_title": "fixed #1785 (fuzz)",
        "commit_text": "",
        "func_before": "GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr->scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl->general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl->general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);\n\t\top->maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\top->avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\top->maxBitRate = gf_bs_read_u32(bs);\n\t\t\top->avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_add(ptr->operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep->dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tif (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {\n\t\t\tgf_free(dep);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_add(ptr->dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}",
        "func": "GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)\n{\n\tGF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;\n\tu32 i, j, count;\n\n\tif (!ptr) return GF_BAD_PARAM;\n\tptr->scalability_mask = gf_bs_read_u16(bs);\n\tgf_bs_read_int(bs, 2);//reserved\n\tcount = gf_bs_read_int(bs, 6);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_ProfileTierLevel *ptl;\n\t\tGF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);\n\t\tif (!ptl) return GF_OUT_OF_MEM;\n\t\tptl->general_profile_space = gf_bs_read_int(bs, 2);\n\t\tptl->general_tier_flag= gf_bs_read_int(bs, 1);\n\t\tptl->general_profile_idc = gf_bs_read_int(bs, 5);\n\t\tptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);\n\t\tptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);\n\t\tptl->general_level_idc = gf_bs_read_u8(bs);\n\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) {\n\t\t\tgf_free(op);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);\n\t\top->maxChromaFormat = gf_bs_read_int(bs, 2);\n\t\top->maxBitDepth = gf_bs_read_int(bs, 3) + 8;\n\t\tgf_bs_read_int(bs, 1);//reserved\n\t\top->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\top->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\tif (op->frame_rate_info_flag) {\n\t\t\top->avgFrameRate = gf_bs_read_u16(bs);\n\t\t\tgf_bs_read_int(bs, 6); //reserved\n\t\t\top->constantFrameRate = gf_bs_read_int(bs, 2);\n\t\t}\n\t\tif (op->bit_rate_info_flag) {\n\t\t\top->maxBitRate = gf_bs_read_u32(bs);\n\t\t\top->avgBitRate = gf_bs_read_u32(bs);\n\t\t}\n\t\tgf_list_add(ptr->operating_points, op);\n\t}\n\tcount = gf_bs_read_u8(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\t\tdep->dependent_layerID = gf_bs_read_u8(bs);\n\t\tdep->num_layers_dependent_on = gf_bs_read_u8(bs);\n\t\tif (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {\n\t\t\tgf_free(dep);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < dep->num_layers_dependent_on; j++)\n\t\t\tdep->dependent_on_layerID[j] = gf_bs_read_u8(bs);\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (ptr->scalability_mask & (1 << j))\n\t\t\t\tdep->dimension_identifier[j] = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_add(ptr->dependency_layers, dep);\n\t}\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,8 +27,10 @@\n \t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n \t\top->max_temporal_id = gf_bs_read_u8(bs);\n \t\top->layer_count = gf_bs_read_u8(bs);\n-\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))\n+\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) {\n+\t\t\tgf_free(op);\n \t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n+\t\t}\n \t\tfor (j = 0; j < op->layer_count; j++) {\n \t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n \t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))"
            ],
            "added_lines": [
                "\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) {",
                "\t\t\tgf_free(op);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33361",
        "func_name": "gpac/afra_box_read",
        "description": "Memory leak in the afra_box_read function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.",
        "git_url": "https://github.com/gpac/gpac/commit/a51f951b878c2b73c1d8e2f1518c7cdc5fb82c3f",
        "commit_title": "fixed #1782 (fuzz)",
        "commit_text": "",
        "func_before": "GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
        "func": "GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \tfor (i=0; i<ptr->entry_count; i++) {\n \t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n \t\tif (!ae) return GF_OUT_OF_MEM;\n+\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n \n \t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\tae->time = gf_bs_read_u64(bs);\n@@ -27,8 +28,6 @@\n \t\t\tISOM_DECREASE_SIZE(ptr, 4)\n \t\t\tae->offset = gf_bs_read_u32(bs);\n \t\t}\n-\n-\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n \t}\n \n \tif (ptr->global_entries) {\n@@ -37,6 +36,8 @@\n \t\tfor (i=0; i<ptr->global_entry_count; i++) {\n \t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n \t\t\tif (!ae) return GF_OUT_OF_MEM;\n+\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n+\n \t\t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\t\tae->time = gf_bs_read_u64(bs);\n \t\t\tif (ptr->long_ids) {\n@@ -57,8 +58,6 @@\n \t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n \t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n \t\t\t}\n-\n-\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n \t\t}\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "\t\tgf_list_insert(ptr->local_access_entries, ae, i);",
                "",
                "\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);"
            ],
            "added_lines": [
                "\t\tgf_list_insert(ptr->local_access_entries, ae, i);",
                "\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33363",
        "func_name": "gpac/infe_box_read",
        "description": "Memory leak in the infe_box_read function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.",
        "git_url": "https://github.com/gpac/gpac/commit/ec64c7b8966d7e4642d12debb888be5acf18efb9",
        "commit_title": "fixed #1786 (fuzz)",
        "commit_text": "",
        "func_before": "GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}",
        "func": "GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_encoding) {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\t//we could throw an error but we silently accept this infe\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,10 +31,13 @@\n \t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n \t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n \t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n-\t\t\t} else {\n+\t\t\t} else if (!ptr->content_encoding) {\n \t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n \t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n \t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n+\t\t\t} else {\n+\t\t\t\t//we could throw an error but we silently accept this infe\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t\tstring_start += string_len;\n \t\t\tstring_len = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t} else {"
            ],
            "added_lines": [
                "\t\t\t} else if (!ptr->content_encoding) {",
                "\t\t\t} else {",
                "\t\t\t\t//we could throw an error but we silently accept this infe",
                "\t\t\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33365",
        "func_name": "gpac/gf_isom_get_root_od",
        "description": "Memory leak in the gf_isom_get_root_od function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.",
        "git_url": "https://github.com/gpac/gpac/commit/984787de3d414a5f7d43d0b4584d9469dff2a5a5",
        "commit_title": "fixed #1784 (fuzz)",
        "commit_text": "",
        "func_before": "GF_EXPORT\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)\n{\n\tGF_Descriptor *desc;\n\tGF_ObjectDescriptor *od;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_IsomInitialObjectDescriptor *isom_iod;\n\tGF_ESD *esd;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tu8 useIOD;\n\n\tif (!movie || !movie->moov) return NULL;\n\tif (!movie->moov->iods) return NULL;\n\n\tif (movie->disable_odf_translate) {\n\t\t//duplicate our descriptor\n\t\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\t\tif (movie->LastError) return NULL;\n\t\treturn desc;\n\t}\n\tod = NULL;\n\tiod = NULL;\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tod = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\tif (!od) return NULL;\n\n\t\tmemset(od, 0, sizeof(GF_ObjectDescriptor));\n\t\tod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 0;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tiod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\tif (!iod) return NULL;\n\n\t\tmemset(iod, 0, sizeof(GF_InitialObjectDescriptor));\n\t\tiod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t//duplicate our descriptor\n\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\tif (movie->LastError) return NULL;\n\n\tif (!useIOD) {\n\t\tisom_od = (GF_IsomObjectDescriptor *)desc;\n\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\tisom_od->extensionDescriptors = NULL;\n\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\tisom_od->IPMP_Descriptors = NULL;\n\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\tisom_od->OCIDescriptors = NULL;\n\t\tod->URLString = isom_od->URLString;\n\t\tisom_od->URLString = NULL;\n\t\tod->tag = GF_ODF_OD_TAG;\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) od);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)od;\n\t} else {\n\t\tisom_iod = (GF_IsomInitialObjectDescriptor *)desc;\n\t\tiod->objectDescriptorID = isom_iod->objectDescriptorID;\n\t\tiod->extensionDescriptors = isom_iod->extensionDescriptors;\n\t\tisom_iod->extensionDescriptors = NULL;\n\t\tiod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;\n\t\tisom_iod->IPMP_Descriptors = NULL;\n\t\tiod->OCIDescriptors = isom_iod->OCIDescriptors;\n\t\tisom_iod->OCIDescriptors = NULL;\n\t\tiod->URLString = isom_iod->URLString;\n\t\tisom_iod->URLString = NULL;\n\t\tiod->tag = GF_ODF_IOD_TAG;\n\n\t\tiod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;\n\t\tiod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;\n\t\tiod->inlineProfileFlag = isom_iod->inlineProfileFlag;\n\t\tiod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;\n\t\tiod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;\n\t\tiod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;\n\t\tiod->IPMPToolList = isom_iod->IPMPToolList;\n\t\tisom_iod->IPMPToolList = NULL;\n\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)iod;\n\t}\n}",
        "func": "GF_EXPORT\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)\n{\n\tGF_Descriptor *desc;\n\tGF_ObjectDescriptor *od;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_IsomInitialObjectDescriptor *isom_iod;\n\tGF_ESD *esd;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tu8 useIOD;\n\n\tif (!movie || !movie->moov) return NULL;\n\tif (!movie->moov->iods) return NULL;\n\n\tif (movie->disable_odf_translate) {\n\t\t//duplicate our descriptor\n\t\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\t\tif (movie->LastError) return NULL;\n\t\treturn desc;\n\t}\n\tod = NULL;\n\tiod = NULL;\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tod = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\tif (!od) return NULL;\n\n\t\tmemset(od, 0, sizeof(GF_ObjectDescriptor));\n\t\tod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 0;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tiod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\tif (!iod) return NULL;\n\n\t\tmemset(iod, 0, sizeof(GF_InitialObjectDescriptor));\n\t\tiod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t//duplicate our descriptor\n\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\tif (movie->LastError) {\n\t\tif (od) {\n\t\t\tgf_list_del(od->ESDescriptors);\n\t\t\tgf_free(od);\n\t\t}\n\t\tif (iod) {\n\t\t\tgf_list_del(iod->ESDescriptors);\n\t\t\tgf_free(iod);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!useIOD) {\n\t\tisom_od = (GF_IsomObjectDescriptor *)desc;\n\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\tisom_od->extensionDescriptors = NULL;\n\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\tisom_od->IPMP_Descriptors = NULL;\n\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\tisom_od->OCIDescriptors = NULL;\n\t\tod->URLString = isom_od->URLString;\n\t\tisom_od->URLString = NULL;\n\t\tod->tag = GF_ODF_OD_TAG;\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) od);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)od;\n\t} else {\n\t\tisom_iod = (GF_IsomInitialObjectDescriptor *)desc;\n\t\tiod->objectDescriptorID = isom_iod->objectDescriptorID;\n\t\tiod->extensionDescriptors = isom_iod->extensionDescriptors;\n\t\tisom_iod->extensionDescriptors = NULL;\n\t\tiod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;\n\t\tisom_iod->IPMP_Descriptors = NULL;\n\t\tiod->OCIDescriptors = isom_iod->OCIDescriptors;\n\t\tisom_iod->OCIDescriptors = NULL;\n\t\tiod->URLString = isom_iod->URLString;\n\t\tisom_iod->URLString = NULL;\n\t\tiod->tag = GF_ODF_IOD_TAG;\n\n\t\tiod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;\n\t\tiod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;\n\t\tiod->inlineProfileFlag = isom_iod->inlineProfileFlag;\n\t\tiod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;\n\t\tiod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;\n\t\tiod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;\n\t\tiod->IPMPToolList = isom_iod->IPMPToolList;\n\t\tisom_iod->IPMPToolList = NULL;\n\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)iod;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,7 +46,17 @@\n \n \t//duplicate our descriptor\n \tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n-\tif (movie->LastError) return NULL;\n+\tif (movie->LastError) {\n+\t\tif (od) {\n+\t\t\tgf_list_del(od->ESDescriptors);\n+\t\t\tgf_free(od);\n+\t\t}\n+\t\tif (iod) {\n+\t\t\tgf_list_del(iod->ESDescriptors);\n+\t\t\tgf_free(iod);\n+\t\t}\n+\t\treturn NULL;\n+\t}\n \n \tif (!useIOD) {\n \t\tisom_od = (GF_IsomObjectDescriptor *)desc;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (movie->LastError) return NULL;"
            ],
            "added_lines": [
                "\tif (movie->LastError) {",
                "\t\tif (od) {",
                "\t\t\tgf_list_del(od->ESDescriptors);",
                "\t\t\tgf_free(od);",
                "\t\t}",
                "\t\tif (iod) {",
                "\t\t\tgf_list_del(iod->ESDescriptors);",
                "\t\t\tgf_free(iod);",
                "\t\t}",
                "\t\treturn NULL;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-20665",
        "func_name": "cloudwu/rudp/rudp_delete",
        "description": "rudp v0.6 was discovered to contain a memory leak in the component main.c.",
        "git_url": "https://github.com/cloudwu/rudp/commit/3fddfb0159ca9b9b002e50d27f021bc8b1e8013f",
        "commit_title": "Fix a memory leak, see #6",
        "commit_text": "",
        "func_before": "void\nrudp_delete(struct rudp *U) {\n\tfree_message_list(U->send_queue.head);\n\tfree_message_list(U->recv_queue.head);\n\tfree_message_list(U->send_history.head);\n\tfree_message_list(U->free_list);\n\tclear_outpackage(U);\n\tfree(U->send_again.a);\n}",
        "func": "void\nrudp_delete(struct rudp *U) {\n\tfree_message_list(U->send_queue.head);\n\tfree_message_list(U->recv_queue.head);\n\tfree_message_list(U->send_history.head);\n\tfree_message_list(U->free_list);\n\tclear_outpackage(U);\n\tfree(U->send_again.a);\n\tfree(U);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,4 +6,5 @@\n \tfree_message_list(U->free_list);\n \tclear_outpackage(U);\n \tfree(U->send_again.a);\n+\tfree(U);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tfree(U);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-47941",
        "func_name": "torvalds/linux/smb2_handle_negotiate",
        "description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. fs/ksmbd/smb2pdu.c omits a kfree call in certain smb2_handle_negotiate error conditions, aka a memory leak.",
        "git_url": "https://github.com/torvalds/linux/commit/aa7253c2393f6dcd6a1468b0792f6da76edad917",
        "commit_title": "ksmbd: fix memory leak in smb2_handle_negotiate",
        "commit_text": " The allocated memory didn't free under an error path in smb2_handle_negotiate().  Cc: stable@vger.kernel.org",
        "func_before": "int smb2_handle_negotiate(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_negotiate_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_negotiate_rsp *rsp = smb2_get_msg(work->response_buf);\n\tint rc = 0;\n\tunsigned int smb2_buf_len, smb2_neg_size;\n\t__le32 status;\n\n\tksmbd_debug(SMB, \"Received negotiate request\\n\");\n\tconn->need_neg = false;\n\tif (ksmbd_conn_good(work)) {\n\t\tpr_err(\"conn->tcp_status is already in CifsGood State\\n\");\n\t\twork->send_no_response = 1;\n\t\treturn rc;\n\t}\n\n\tif (req->DialectCount == 0) {\n\t\tpr_err(\"malformed packet\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tsmb2_buf_len = get_rfc1002_len(work->request_buf);\n\tsmb2_neg_size = offsetof(struct smb2_negotiate_req, Dialects);\n\tif (smb2_neg_size > smb2_buf_len) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (conn->dialect == SMB311_PROT_ID) {\n\t\tunsigned int nego_ctxt_off = le32_to_cpu(req->NegotiateContextOffset);\n\n\t\tif (smb2_buf_len < nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size > nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    smb2_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tconn->cli_cap = le32_to_cpu(req->Capabilities);\n\tswitch (conn->dialect) {\n\tcase SMB311_PROT_ID:\n\t\tconn->preauth_info =\n\t\t\tkzalloc(sizeof(struct preauth_integrity_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!conn->preauth_info) {\n\t\t\trc = -ENOMEM;\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tstatus = deassemble_neg_contexts(conn, req,\n\t\t\t\t\t\t get_rfc1002_len(work->request_buf));\n\t\tif (status != STATUS_SUCCESS) {\n\t\t\tpr_err(\"deassemble_neg_contexts error(0x%x)\\n\",\n\t\t\t       status);\n\t\t\trsp->hdr.Status = status;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\trc = init_smb3_11_server(conn);\n\t\tif (rc < 0) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tksmbd_gen_preauth_integrity_hash(conn,\n\t\t\t\t\t\t work->request_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\t\trsp->NegotiateContextOffset =\n\t\t\t\tcpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\t\tassemble_neg_contexts(conn, rsp, work->response_buf);\n\t\tbreak;\n\tcase SMB302_PROT_ID:\n\t\tinit_smb3_02_server(conn);\n\t\tbreak;\n\tcase SMB30_PROT_ID:\n\t\tinit_smb3_0_server(conn);\n\t\tbreak;\n\tcase SMB21_PROT_ID:\n\t\tinit_smb2_1_server(conn);\n\t\tbreak;\n\tcase SMB2X_PROT_ID:\n\tcase BAD_PROT_ID:\n\tdefault:\n\t\tksmbd_debug(SMB, \"Server dialect :0x%x not supported\\n\",\n\t\t\t    conn->dialect);\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\n\t/* For stats */\n\tconn->connection_type = conn->dialect;\n\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\tmemcpy(conn->ClientGUID, req->ClientGUID,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\tconn->cli_sec_mode = le16_to_cpu(req->SecurityMode);\n\n\trsp->StructureSize = cpu_to_le16(65);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying server\n\t */\n\tmemset(rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\tksmbd_debug(SMB, \"negotiate context offset %d, count %d\\n\",\n\t\t    le32_to_cpu(rsp->NegotiateContextOffset),\n\t\t    le16_to_cpu(rsp->NegotiateContextCount));\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\t\t\t  le16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf, sizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\t AUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tconn->use_spnego = true;\n\n\tif ((server_conf.signing == KSMBD_CONFIG_OPT_AUTO ||\n\t     server_conf.signing == KSMBD_CONFIG_OPT_DISABLED) &&\n\t    req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED_LE)\n\t\tconn->sign = true;\n\telse if (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY) {\n\t\tserver_conf.enforced_signing = true;\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\t\tconn->sign = true;\n\t}\n\n\tconn->srv_sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tksmbd_conn_set_need_negotiate(work);\n\nerr_out:\n\tif (rc < 0)\n\t\tsmb2_set_err_rsp(work);\n\n\treturn rc;\n}",
        "func": "int smb2_handle_negotiate(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_negotiate_req *req = smb2_get_msg(work->request_buf);\n\tstruct smb2_negotiate_rsp *rsp = smb2_get_msg(work->response_buf);\n\tint rc = 0;\n\tunsigned int smb2_buf_len, smb2_neg_size;\n\t__le32 status;\n\n\tksmbd_debug(SMB, \"Received negotiate request\\n\");\n\tconn->need_neg = false;\n\tif (ksmbd_conn_good(work)) {\n\t\tpr_err(\"conn->tcp_status is already in CifsGood State\\n\");\n\t\twork->send_no_response = 1;\n\t\treturn rc;\n\t}\n\n\tif (req->DialectCount == 0) {\n\t\tpr_err(\"malformed packet\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tsmb2_buf_len = get_rfc1002_len(work->request_buf);\n\tsmb2_neg_size = offsetof(struct smb2_negotiate_req, Dialects);\n\tif (smb2_neg_size > smb2_buf_len) {\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tif (conn->dialect == SMB311_PROT_ID) {\n\t\tunsigned int nego_ctxt_off = le32_to_cpu(req->NegotiateContextOffset);\n\n\t\tif (smb2_buf_len < nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size > nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    nego_ctxt_off) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tif (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >\n\t\t    smb2_buf_len) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tconn->cli_cap = le32_to_cpu(req->Capabilities);\n\tswitch (conn->dialect) {\n\tcase SMB311_PROT_ID:\n\t\tconn->preauth_info =\n\t\t\tkzalloc(sizeof(struct preauth_integrity_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!conn->preauth_info) {\n\t\t\trc = -ENOMEM;\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tstatus = deassemble_neg_contexts(conn, req,\n\t\t\t\t\t\t get_rfc1002_len(work->request_buf));\n\t\tif (status != STATUS_SUCCESS) {\n\t\t\tpr_err(\"deassemble_neg_contexts error(0x%x)\\n\",\n\t\t\t       status);\n\t\t\trsp->hdr.Status = status;\n\t\t\trc = -EINVAL;\n\t\t\tkfree(conn->preauth_info);\n\t\t\tconn->preauth_info = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\trc = init_smb3_11_server(conn);\n\t\tif (rc < 0) {\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\t\tkfree(conn->preauth_info);\n\t\t\tconn->preauth_info = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tksmbd_gen_preauth_integrity_hash(conn,\n\t\t\t\t\t\t work->request_buf,\n\t\t\t\t\t\t conn->preauth_info->Preauth_HashValue);\n\t\trsp->NegotiateContextOffset =\n\t\t\t\tcpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\t\tassemble_neg_contexts(conn, rsp, work->response_buf);\n\t\tbreak;\n\tcase SMB302_PROT_ID:\n\t\tinit_smb3_02_server(conn);\n\t\tbreak;\n\tcase SMB30_PROT_ID:\n\t\tinit_smb3_0_server(conn);\n\t\tbreak;\n\tcase SMB21_PROT_ID:\n\t\tinit_smb2_1_server(conn);\n\t\tbreak;\n\tcase SMB2X_PROT_ID:\n\tcase BAD_PROT_ID:\n\tdefault:\n\t\tksmbd_debug(SMB, \"Server dialect :0x%x not supported\\n\",\n\t\t\t    conn->dialect);\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\trsp->Capabilities = cpu_to_le32(conn->vals->capabilities);\n\n\t/* For stats */\n\tconn->connection_type = conn->dialect;\n\n\trsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);\n\trsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);\n\trsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);\n\n\tmemcpy(conn->ClientGUID, req->ClientGUID,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\tconn->cli_sec_mode = le16_to_cpu(req->SecurityMode);\n\n\trsp->StructureSize = cpu_to_le16(65);\n\trsp->DialectRevision = cpu_to_le16(conn->dialect);\n\t/* Not setting conn guid rsp->ServerGUID, as it\n\t * not used by client for identifying server\n\t */\n\tmemset(rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\n\trsp->SystemTime = cpu_to_le64(ksmbd_systime());\n\trsp->ServerStartTime = 0;\n\tksmbd_debug(SMB, \"negotiate context offset %d, count %d\\n\",\n\t\t    le32_to_cpu(rsp->NegotiateContextOffset),\n\t\t    le16_to_cpu(rsp->NegotiateContextCount));\n\n\trsp->SecurityBufferOffset = cpu_to_le16(128);\n\trsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);\n\tksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +\n\t\t\t\t  le16_to_cpu(rsp->SecurityBufferOffset));\n\tinc_rfc1001_len(work->response_buf, sizeof(struct smb2_negotiate_rsp) -\n\t\t\tsizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +\n\t\t\t AUTH_GSS_LENGTH);\n\trsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;\n\tconn->use_spnego = true;\n\n\tif ((server_conf.signing == KSMBD_CONFIG_OPT_AUTO ||\n\t     server_conf.signing == KSMBD_CONFIG_OPT_DISABLED) &&\n\t    req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED_LE)\n\t\tconn->sign = true;\n\telse if (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY) {\n\t\tserver_conf.enforced_signing = true;\n\t\trsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;\n\t\tconn->sign = true;\n\t}\n\n\tconn->srv_sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tksmbd_conn_set_need_negotiate(work);\n\nerr_out:\n\tif (rc < 0)\n\t\tsmb2_set_err_rsp(work);\n\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -79,12 +79,16 @@\n \t\t\t       status);\n \t\t\trsp->hdr.Status = status;\n \t\t\trc = -EINVAL;\n+\t\t\tkfree(conn->preauth_info);\n+\t\t\tconn->preauth_info = NULL;\n \t\t\tgoto err_out;\n \t\t}\n \n \t\trc = init_smb3_11_server(conn);\n \t\tif (rc < 0) {\n \t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n+\t\t\tkfree(conn->preauth_info);\n+\t\t\tconn->preauth_info = NULL;\n \t\t\tgoto err_out;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tkfree(conn->preauth_info);",
                "\t\t\tconn->preauth_info = NULL;",
                "\t\t\tkfree(conn->preauth_info);",
                "\t\t\tconn->preauth_info = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-46489",
        "func_name": "gpac/gf_isom_box_parse_ex",
        "description": "GPAC version 2.1-DEV-rev505-gb9577e6ad-master was discovered to contain a memory leak via the gf_isom_box_parse_ex function at box_funcs.c.",
        "git_url": "https://github.com/gpac/gpac/commit/44e8616ec6d0c37498cdacb81375b09249fa9daa",
        "commit_title": "fixed #2328",
        "commit_text": "",
        "func_before": "GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) return GF_OUT_OF_MEM;\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\t\tif (is_root_box && (e==GF_SKIP_BOX))\n\t\t\te = GF_ISOM_INVALID_FILE;\n\n\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}",
        "func": "GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)\n{\n\tu32 type, uuid_type, hdr_size, restore_type;\n\tu64 size, start, comp_start, end;\n\tchar uuid[16];\n\tGF_Err e;\n\tGF_BitStream *uncomp_bs = NULL;\n\tu8 *uncomp_data = NULL;\n\tu32 compressed_size=0;\n\tGF_Box *newBox;\n\tBool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;\n\tBool is_special = GF_TRUE;\n\t\n\tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n\t*outBox = NULL;\n\tif (gf_bs_available(bs) < 8) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\n\tcomp_start = start = gf_bs_get_position(bs);\n\n\tuuid_type = 0;\n\tsize = (u64) gf_bs_read_u32(bs);\n\thdr_size = 4;\n\t/*fix for some boxes found in some old hinted files*/\n\tif ((size >= 2) && (size <= 4)) {\n\t\tsize = 4;\n\t\ttype = GF_ISOM_BOX_TYPE_VOID;\n\t} else {\n\t\ttype = gf_bs_read_u32(bs);\n\t\thdr_size += 4;\n\t\t/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/\n\t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n\t\t\tsize = 12;\n\t\tif (!size) {\n\t\t\tif (is_root_box) {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n\t\t\t\t}\n\t\t\t\tsize = gf_bs_available(bs) + 8;\n\t\t\t} else {\n\t\t\t\tif (!skip_logs) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\\n\", gf_4cc_to_str(type), type, start));\n\t\t\t\t\treturn GF_SKIP_BOX;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\tif (is_root_box && (size>=8)) {\n\t\t\tBool do_uncompress = GF_FALSE;\n\t\t\tu8 *compb = NULL;\n\t\t\tu32 osize = 0;\n\t\t\tu32 otype = type;\n\t\t\tif (type==GF_4CC('!', 'm', 'o', 'f')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOF;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 'm', 'o', 'v')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_MOOV;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 'i', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SIDX;\n\t\t\t}\n\t\t\telse if (type==GF_4CC('!', 's', 's', 'x')) {\n\t\t\t\tdo_uncompress = GF_TRUE;\n\t\t\t\ttype = GF_ISOM_BOX_TYPE_SSIX;\n\t\t\t}\n\n\t\t\tif (do_uncompress) {\n\t\t\t\tcompb = gf_malloc((u32) (size-8));\n\t\t\t\tif (!compb) return GF_OUT_OF_MEM;\n\n\t\t\t\tcompressed_size = (u32) (size - 8);\n\t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n\t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n\t\t\t\tif (e) {\n\t\t\t\t\tgf_free(compb);\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t//keep size as complete box size for tests below\n\t\t\t\tsize = osize + 8;\n\t\t\t\tuncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);\n\t\t\t\tbs = uncomp_bs;\n\t\t\t\tstart = 0;\n\t\t\t\tgf_free(compb);\n\t\t\t}\n\t\t}\n\t}\n\n#define ERR_EXIT(_e) { \\\n\t\tif (uncomp_bs) {\\\n\t\t\tgf_free(uncomp_data);\\\n\t\t\tgf_bs_del(uncomp_bs); \\\n\t\t}\\\n\t\treturn _e;\\\n\t}\n\n\t/*handle uuid*/\n\tmemset(uuid, 0, 16);\n\tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n\t\tif (gf_bs_available(bs) < 16) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tgf_bs_read_data(bs, uuid, 16);\n\t\thdr_size += 16;\n\t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n\t}\n\n\t//handle large box\n\tif (size == 1) {\n\t\tif (gf_bs_available(bs) < 8) {\n\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t\t}\n\t\tsize = gf_bs_read_u64(bs);\n\t\thdr_size += 8;\n\t}\n\tif (!skip_logs)\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), size,  start));\n\n\tif ( size < hdr_size ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\t//if parent size is given, make sure box fits within parent\n\tif (parent_size && (parent_size<size)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n\t}\n\trestore_type = 0;\n\tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n\t\tu64 cookie = gf_bs_get_cookie(bs);\n\t\trestore_type = type;\n\t\tif (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)\n\t\t\ttype = GF_QT_SUBTYPE_RAW_VID;\n\t\telse\n\t\t\ttype = GF_QT_SUBTYPE_RAW_AUD;\n\n\t}\n\n\t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n\tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n\t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n\t} else {\n\t\t//OK, create the box based on the type\n\t\tis_special = GF_FALSE;\n\t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n\t}\n\n\t//OK, init and read this box\n\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n\t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n\t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n\t}\n\n\tif (!newBox->type) newBox->type = type;\n\tif (restore_type)\n\t\tnewBox->type = restore_type;\n\n\tend = gf_bs_available(bs);\n\tif (size - hdr_size > end ) {\n\t\tnewBox->size = size - hdr_size - end;\n\t\t*outBox = newBox;\n\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n\t}\n\n\tnewBox->size = size - hdr_size;\n\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tif (e) {\n\t\tif (gf_opts_get_bool(\"core\", \"no-check\"))\n\t\t\te = GF_OK;\n\t}\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n\n\tif (uncomp_bs) {\n\t\tgf_free(uncomp_data);\n\t\tgf_bs_del(uncomp_bs);\n\t\tif (e) {\n\t\t\tgf_isom_box_del(newBox);\n\t\t\t*outBox = NULL;\n\t\t\treturn e;\n\t\t}\n\t\t//move size to real bitstream offsets for tests below\n\t\tsize -= 8;\n\t\t//remember compressed vs real size info for moof in order to properly recompute data_offset/base_data_offset\n\t\tif (type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\t((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for moov in order to properly recompute chunk offset\n\t\telse if (type==GF_ISOM_BOX_TYPE_MOOV) {\n\t\t\t((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t\t((GF_MovieBox *)newBox)->file_offset = comp_start;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\t//remember compressed vs real size info for dump\n\t\telse if (type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;\n\t\t}\n\t\tnewBox->internal_flags = GF_ISOM_BOX_COMPRESSED;\n\t}\n\n\n\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\tgf_isom_box_del(newBox);\n\t\t*outBox = NULL;\n\t\tif (is_root_box && (e==GF_SKIP_BOX))\n\t\t\te = GF_ISOM_INVALID_FILE;\n\n\t\tif (!skip_logs && (e!=GF_SKIP_BOX)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n\t\t}\n\t\t//we don't try to reparse known boxes that have been failing (too dangerous)\n\t\treturn e;\n\t}\n\n\tif (end-start > size) {\n\t\tif (!skip_logs) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), size, start, (end-start) ));\n\t\t}\n\t\t/*let's still try to load the file since no error was notified*/\n\t\tgf_bs_seek(bs, start+size);\n\t} else if (end-start < size) {\n\t\tu32 to_skip = (u32) (size-(end-start));\n\t\tif (!skip_logs) {\n\t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n\t\t\t\tunused_bytes += to_skip;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs, to_skip);\n\t}\n\t*outBox = newBox;\n\n\treturn e;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -70,11 +70,13 @@\n \n \t\t\tif (do_uncompress) {\n \t\t\t\tcompb = gf_malloc((u32) (size-8));\n+\t\t\t\tif (!compb) return GF_OUT_OF_MEM;\n \n \t\t\t\tcompressed_size = (u32) (size - 8);\n \t\t\t\tgf_bs_read_data(bs, compb, compressed_size);\n \t\t\t\te = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);\n \t\t\t\tif (e) {\n+\t\t\t\t\tgf_free(compb);\n \t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Failed to uncompress payload for box type %s (0x%08X)\\n\", gf_4cc_to_str(otype), otype));\n \t\t\t\t\treturn e;\n \t\t\t\t}\n@@ -88,11 +90,20 @@\n \t\t\t}\n \t\t}\n \t}\n+\n+#define ERR_EXIT(_e) { \\\n+\t\tif (uncomp_bs) {\\\n+\t\t\tgf_free(uncomp_data);\\\n+\t\t\tgf_bs_del(uncomp_bs); \\\n+\t\t}\\\n+\t\treturn _e;\\\n+\t}\n+\n \t/*handle uuid*/\n \tmemset(uuid, 0, 16);\n \tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n \t\tif (gf_bs_available(bs) < 16) {\n-\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n+\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n \t\t}\n \t\tgf_bs_read_data(bs, uuid, 16);\n \t\thdr_size += 16;\n@@ -102,7 +113,7 @@\n \t//handle large box\n \tif (size == 1) {\n \t\tif (gf_bs_available(bs) < 8) {\n-\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n+\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n \t\t}\n \t\tsize = gf_bs_read_u64(bs);\n \t\thdr_size += 8;\n@@ -112,12 +123,12 @@\n \n \tif ( size < hdr_size ) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLD\" less than box header size %d\\n\", gf_4cc_to_str(type), size, hdr_size));\n-\t\treturn GF_ISOM_INVALID_FILE;\n+\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n \t}\n \t//if parent size is given, make sure box fits within parent\n \tif (parent_size && (parent_size<size)) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Box %s size \"LLU\" is larger than remaining parent size \"LLU\"\\n\", gf_4cc_to_str(type), size, parent_size ));\n-\t\treturn GF_ISOM_INVALID_FILE;\n+\t\tERR_EXIT(GF_ISOM_INVALID_FILE);\n \t}\n \trestore_type = 0;\n \tif ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {\n@@ -133,25 +144,25 @@\n \t//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type\n \tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n \t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n-\t\tif (!newBox) return GF_OUT_OF_MEM;\n+\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n \t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n \t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n \t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n-\t\tif (!newBox) return GF_OUT_OF_MEM;\n+\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n \t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n \t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n \t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n-\t\tif (!newBox) return GF_OUT_OF_MEM;\n+\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n \t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n \t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n \t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n-\t\tif (!newBox) return GF_OUT_OF_MEM;\n+\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n \t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n \t} else {\n \t\t//OK, create the box based on the type\n \t\tis_special = GF_FALSE;\n \t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n-\t\tif (!newBox) return GF_OUT_OF_MEM;\n+\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);\n \t}\n \n \t//OK, init and read this box\n@@ -168,7 +179,7 @@\n \tif (size - hdr_size > end ) {\n \t\tnewBox->size = size - hdr_size - end;\n \t\t*outBox = newBox;\n-\t\treturn GF_ISOM_INCOMPLETE_FILE;\n+\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);\n \t}\n \n \tnewBox->size = size - hdr_size;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\treturn GF_ISOM_INCOMPLETE_FILE;",
                "\t\t\treturn GF_ISOM_INCOMPLETE_FILE;",
                "\t\treturn GF_ISOM_INVALID_FILE;",
                "\t\treturn GF_ISOM_INVALID_FILE;",
                "\t\tif (!newBox) return GF_OUT_OF_MEM;",
                "\t\tif (!newBox) return GF_OUT_OF_MEM;",
                "\t\tif (!newBox) return GF_OUT_OF_MEM;",
                "\t\tif (!newBox) return GF_OUT_OF_MEM;",
                "\t\tif (!newBox) return GF_OUT_OF_MEM;",
                "\t\treturn GF_ISOM_INCOMPLETE_FILE;"
            ],
            "added_lines": [
                "\t\t\t\tif (!compb) return GF_OUT_OF_MEM;",
                "\t\t\t\t\tgf_free(compb);",
                "",
                "#define ERR_EXIT(_e) { \\",
                "\t\tif (uncomp_bs) {\\",
                "\t\t\tgf_free(uncomp_data);\\",
                "\t\t\tgf_bs_del(uncomp_bs); \\",
                "\t\t}\\",
                "\t\treturn _e;\\",
                "\t}",
                "",
                "\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);",
                "\t\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);",
                "\t\tERR_EXIT(GF_ISOM_INVALID_FILE);",
                "\t\tERR_EXIT(GF_ISOM_INVALID_FILE);",
                "\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);",
                "\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);",
                "\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);",
                "\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);",
                "\t\tif (!newBox) ERR_EXIT(GF_OUT_OF_MEM);",
                "\t\tERR_EXIT(GF_ISOM_INCOMPLETE_FILE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-46489",
        "func_name": "gpac/gf_gz_decompress_payload",
        "description": "GPAC version 2.1-DEV-rev505-gb9577e6ad-master was discovered to contain a memory leak via the gf_isom_box_parse_ex function at box_funcs.c.",
        "git_url": "https://github.com/gpac/gpac/commit/44e8616ec6d0c37498cdacb81375b09249fa9daa",
        "commit_title": "fixed #2328",
        "commit_text": "",
        "func_before": "GF_EXPORT\nGF_Err gf_gz_decompress_payload(u8 *data, u32 data_len, u8 **uncompressed_data, u32 *out_size)\n{\n\tz_stream d_stream;\n\tGF_Err e = GF_OK;\n\tint err;\n\tBool owns_buffer=GF_TRUE;\n\tu32 size = 4096;\n\n\tif (! *uncompressed_data) {\n\t\t*uncompressed_data = (char*)gf_malloc(sizeof(char)*4096);\n\t\tif (!*uncompressed_data) return GF_OUT_OF_MEM;\n\t} else {\n\t\towns_buffer = GF_FALSE;\n\t\tsize = *out_size;\n\t}\n\n\td_stream.zalloc = (alloc_func)0;\n\td_stream.zfree = (free_func)0;\n\td_stream.opaque = (voidpf)0;\n\td_stream.next_in  = (Bytef*)data;\n\td_stream.avail_in = data_len;\n\td_stream.next_out = (Bytef*) *uncompressed_data;\n\td_stream.avail_out = size;\n\n\terr = inflateInit2(&d_stream, 16+MAX_WBITS);\n\n\tif (err == Z_OK) {\n\t\twhile (d_stream.total_in < data_len) {\n\t\t\terr = inflate(&d_stream, Z_NO_FLUSH);\n\t\t\tif (err < Z_OK) {\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err==Z_STREAM_END) break;\n\n\t\t\tsize *= 2;\n\t\t\t*uncompressed_data = (char*)gf_realloc(*uncompressed_data, sizeof(char)*size);\n\t\t\tif (!*uncompressed_data) return GF_OUT_OF_MEM;\n\t\t\td_stream.avail_out = (u32) (size - d_stream.total_out);\n\t\t\td_stream.next_out = (Bytef*) ( *uncompressed_data + d_stream.total_out);\n\t\t}\n\t\t*out_size = (u32) d_stream.total_out;\n\t\tinflateEnd(&d_stream);\n\t\treturn e;\n\t}\n\tif (e!=GF_OK) {\n\t\tif (owns_buffer) {\n\t\t\tgf_free(*uncompressed_data);\n\t\t\t*uncompressed_data = NULL;\n\t\t}\n\t}\n\treturn e;\n}",
        "func": "GF_EXPORT\nGF_Err gf_gz_decompress_payload(u8 *data, u32 data_len, u8 **uncompressed_data, u32 *out_size)\n{\n\tz_stream d_stream;\n\tGF_Err e = GF_OK;\n\tint err;\n\tBool owns_buffer=GF_TRUE;\n\tu32 size = 4096;\n\n\tif (! *uncompressed_data) {\n\t\t*uncompressed_data = (char*)gf_malloc(sizeof(char)*4096);\n\t\tif (!*uncompressed_data) return GF_OUT_OF_MEM;\n\t} else {\n\t\towns_buffer = GF_FALSE;\n\t\tsize = *out_size;\n\t}\n\n\td_stream.zalloc = (alloc_func)0;\n\td_stream.zfree = (free_func)0;\n\td_stream.opaque = (voidpf)0;\n\td_stream.next_in  = (Bytef*)data;\n\td_stream.avail_in = data_len;\n\td_stream.next_out = (Bytef*) *uncompressed_data;\n\td_stream.avail_out = size;\n\n\terr = inflateInit2(&d_stream, 16+MAX_WBITS);\n\n\tif (err == Z_OK) {\n\t\twhile (d_stream.total_in < data_len) {\n\t\t\terr = inflate(&d_stream, Z_NO_FLUSH);\n\t\t\tif (err < Z_OK) {\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err==Z_STREAM_END) break;\n\n\t\t\tsize *= 2;\n\t\t\t*uncompressed_data = (char*)gf_realloc(*uncompressed_data, sizeof(char)*size);\n\t\t\tif (!*uncompressed_data) return GF_OUT_OF_MEM;\n\t\t\td_stream.avail_out = (u32) (size - d_stream.total_out);\n\t\t\td_stream.next_out = (Bytef*) ( *uncompressed_data + d_stream.total_out);\n\t\t}\n\t\t*out_size = (u32) d_stream.total_out;\n\t\tinflateEnd(&d_stream);\n\t}\n\tif (e!=GF_OK) {\n\t\tif (owns_buffer) {\n\t\t\tgf_free(*uncompressed_data);\n\t\t\t*uncompressed_data = NULL;\n\t\t}\n\t}\n\treturn e;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,6 @@\n \t\t}\n \t\t*out_size = (u32) d_stream.total_out;\n \t\tinflateEnd(&d_stream);\n-\t\treturn e;\n \t}\n \tif (e!=GF_OK) {\n \t\tif (owns_buffer) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn e;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-46490",
        "func_name": "gpac/abst_box_read",
        "description": "GPAC version 2.1-DEV-rev505-gb9577e6ad-master was discovered to contain a memory leak via the afrt_box_read function at box_code_adobe.c.",
        "git_url": "https://github.com/gpac/gpac/commit/8968a510250e8c70a611221d63fe0a45b7d3a551",
        "commit_title": "fixed #2327",
        "commit_text": "",
        "func_before": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e = GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*(tmp_strsize+1));\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*(tmp_strsize+1) );\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->server_entry_count != gf_list_count(ptr->server_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\tif (ptr->quality_entry_count != gf_list_count(ptr->quality_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\tif (ptr->segment_run_table_count != gf_list_count(ptr->segment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\tif (ptr->fragment_run_table_count != gf_list_count(ptr->fragment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tgf_free(tmp_str);\n\treturn e;\n}",
        "func": "GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tBool zfound=GF_FALSE;\n\tGF_Err e = GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*(tmp_strsize+1));\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*(tmp_strsize+1) );\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_add(ptr->server_entry_table, gf_strdup(tmp_str));\n\t\t}\n\t}\n\tif (ptr->server_entry_count != gf_list_count(ptr->server_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tzfound = GF_FALSE;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j]) {\n\t\t\t\tzfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_add(ptr->quality_entry_table, gf_strdup(tmp_str));\n\t\t}\n\t}\n\tif (ptr->quality_entry_count != gf_list_count(ptr->quality_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\tzfound = GF_FALSE;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i]) {\n\t\t\tzfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\tif (ptr->segment_run_table_count != gf_list_count(ptr->segment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgoto exit;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\tif (ptr->fragment_run_table_count != gf_list_count(ptr->fragment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tgf_free(tmp_str);\n\treturn e;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -63,7 +63,7 @@\n \t\t\tgoto exit;\n \t\t}\n \t\tif (j) {\n-\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n+\t\t\tgf_list_add(ptr->server_entry_table, gf_strdup(tmp_str));\n \t\t}\n \t}\n \tif (ptr->server_entry_count != gf_list_count(ptr->server_entry_table)) {\n@@ -93,7 +93,7 @@\n \t\t\tgoto exit;\n \t\t}\n \t\tif (j) {\n-\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n+\t\t\tgf_list_add(ptr->quality_entry_table, gf_strdup(tmp_str));\n \t\t}\n \t}\n \tif (ptr->quality_entry_count != gf_list_count(ptr->quality_entry_table)) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);",
                "\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);"
            ],
            "added_lines": [
                "\t\t\tgf_list_add(ptr->server_entry_table, gf_strdup(tmp_str));",
                "\t\t\tgf_list_add(ptr->quality_entry_table, gf_strdup(tmp_str));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-46490",
        "func_name": "gpac/afra_box_read",
        "description": "GPAC version 2.1-DEV-rev505-gb9577e6ad-master was discovered to contain a memory leak via the afrt_box_read function at box_code_adobe.c.",
        "git_url": "https://github.com/gpac/gpac/commit/8968a510250e8c70a611221d63fe0a45b7d3a551",
        "commit_title": "fixed #2327",
        "commit_text": "",
        "func_before": "GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
        "func": "GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->local_access_entries, ae);\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tgf_list_add(ptr->global_access_entries, ae);\n\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \tfor (i=0; i<ptr->entry_count; i++) {\n \t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n \t\tif (!ae) return GF_OUT_OF_MEM;\n-\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n+\t\tgf_list_add(ptr->local_access_entries, ae);\n \n \t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\tae->time = gf_bs_read_u64(bs);\n@@ -36,7 +36,7 @@\n \t\tfor (i=0; i<ptr->global_entry_count; i++) {\n \t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n \t\t\tif (!ae) return GF_OUT_OF_MEM;\n-\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n+\t\t\tgf_list_add(ptr->global_access_entries, ae);\n \n \t\t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\t\tae->time = gf_bs_read_u64(bs);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tgf_list_insert(ptr->local_access_entries, ae, i);",
                "\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);"
            ],
            "added_lines": [
                "\t\tgf_list_add(ptr->local_access_entries, ae);",
                "\t\t\tgf_list_add(ptr->global_access_entries, ae);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-46490",
        "func_name": "gpac/afrt_box_read",
        "description": "GPAC version 2.1-DEV-rev505-gb9577e6ad-master was discovered to contain a memory leak via the afrt_box_read function at box_code_adobe.c.",
        "git_url": "https://github.com/gpac/gpac/commit/8968a510250e8c70a611221d63fe0a45b7d3a551",
        "commit_title": "fixed #2327",
        "commit_text": "",
        "func_before": "GF_Err afrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize = (u32) ptr->size;\n\t\tif (!tmp_strsize) return GF_ISOM_INVALID_FILE;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize+1);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\ttmp_str[tmp_strsize]=0;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->fragment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / 16 < ptr->fragment_run_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = gf_malloc(sizeof(GF_AdobeFragmentRunEntry));\n\t\tif (!fre) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tfre->first_fragment = gf_bs_read_u32(bs);\n\t\tfre->first_fragment_timestamp = gf_bs_read_u64(bs);\n\t\tfre->fragment_duration = gf_bs_read_u32(bs);\n\t\tif (!fre->fragment_duration) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\tfre->discontinuity_indicator = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_entry_table, fre, i);\n\t}\n\n\treturn GF_OK;\n}",
        "func": "GF_Err afrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize = (u32) ptr->size;\n\t\tif (!tmp_strsize) return GF_ISOM_INVALID_FILE;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize+1);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->quality_segment_url_modifiers, tmp_str);\n\t\ttmp_str[tmp_strsize]=0;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->fragment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / 16 < ptr->fragment_run_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = gf_malloc(sizeof(GF_AdobeFragmentRunEntry));\n\t\tif (!fre) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->fragment_run_entry_table, fre);\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tfre->first_fragment = gf_bs_read_u32(bs);\n\t\tfre->first_fragment_timestamp = gf_bs_read_u64(bs);\n\t\tfre->fragment_duration = gf_bs_read_u32(bs);\n\t\tif (!fre->fragment_duration) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\tfre->discontinuity_indicator = gf_bs_read_u8(bs);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \t\tif (!tmp_strsize) return GF_ISOM_INVALID_FILE;\n \t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize+1);\n \t\tif (!tmp_str) return GF_OUT_OF_MEM;\n+\t\tgf_list_add(ptr->quality_segment_url_modifiers, tmp_str);\n \t\ttmp_str[tmp_strsize]=0;\n \t\twhile (tmp_strsize) {\n \t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n@@ -26,7 +27,6 @@\n \t\t\t\tbreak;\n \t\t\tj++;\n \t\t}\n-\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n \t}\n \n \tISOM_DECREASE_SIZE(ptr, 4)\n@@ -36,6 +36,7 @@\n \tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n \t\tGF_AdobeFragmentRunEntry *fre = gf_malloc(sizeof(GF_AdobeFragmentRunEntry));\n \t\tif (!fre) return GF_OUT_OF_MEM;\n+\t\tgf_list_add(ptr->fragment_run_entry_table, fre);\n \t\tISOM_DECREASE_SIZE(ptr, 16)\n \t\tfre->first_fragment = gf_bs_read_u32(bs);\n \t\tfre->first_fragment_timestamp = gf_bs_read_u64(bs);\n@@ -44,7 +45,6 @@\n \t\t\tISOM_DECREASE_SIZE(ptr, 1)\n \t\t\tfre->discontinuity_indicator = gf_bs_read_u8(bs);\n \t\t}\n-\t\tgf_list_insert(ptr->fragment_run_entry_table, fre, i);\n \t}\n \n \treturn GF_OK;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);",
                "\t\tgf_list_insert(ptr->fragment_run_entry_table, fre, i);"
            ],
            "added_lines": [
                "\t\tgf_list_add(ptr->quality_segment_url_modifiers, tmp_str);",
                "\t\tgf_list_add(ptr->fragment_run_entry_table, fre);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-46490",
        "func_name": "gpac/asrt_box_read",
        "description": "GPAC version 2.1-DEV-rev505-gb9577e6ad-master was discovered to contain a memory leak via the afrt_box_read function at box_code_adobe.c.",
        "git_url": "https://github.com/gpac/gpac/commit/8968a510250e8c70a611221d63fe0a45b7d3a551",
        "commit_title": "fixed #2327",
        "commit_text": "",
        "func_before": "GF_Err asrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size;\n\t\tif (!tmp_strsize) return GF_ISOM_INVALID_FILE;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize+1);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\ttmp_str[tmp_strsize]=0;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->segment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < ptr->segment_run_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = gf_malloc(sizeof(GF_AdobeSegmentRunEntry));\n\t\tif (!sre) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tsre->first_segment = gf_bs_read_u32(bs);\n\t\tsre->fragment_per_segment = gf_bs_read_u32(bs);\n\t\tgf_list_insert(ptr->segment_run_entry_table, sre, i);\n\t}\n\n\treturn GF_OK;\n}",
        "func": "GF_Err asrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size;\n\t\tif (!tmp_strsize) return GF_ISOM_INVALID_FILE;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize+1);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->quality_segment_url_modifiers, tmp_str);\n\t\ttmp_str[tmp_strsize]=0;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->segment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size / 8 < ptr->segment_run_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = gf_malloc(sizeof(GF_AdobeSegmentRunEntry));\n\t\tif (!sre) return GF_OUT_OF_MEM;\n\t\tgf_list_add(ptr->segment_run_entry_table, sre);\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tsre->first_segment = gf_bs_read_u32(bs);\n\t\tsre->fragment_per_segment = gf_bs_read_u32(bs);\n\t}\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n \t\tif (!tmp_strsize) return GF_ISOM_INVALID_FILE;\n \t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize+1);\n \t\tif (!tmp_str) return GF_OUT_OF_MEM;\n+\t\tgf_list_add(ptr->quality_segment_url_modifiers, tmp_str);\n \t\ttmp_str[tmp_strsize]=0;\n \t\twhile (tmp_strsize) {\n \t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n@@ -23,7 +24,6 @@\n \t\t\t\tbreak;\n \t\t\tj++;\n \t\t}\n-\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n \t}\n \n \tISOM_DECREASE_SIZE(ptr, 4)\n@@ -34,10 +34,10 @@\n \tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n \t\tGF_AdobeSegmentRunEntry *sre = gf_malloc(sizeof(GF_AdobeSegmentRunEntry));\n \t\tif (!sre) return GF_OUT_OF_MEM;\n+\t\tgf_list_add(ptr->segment_run_entry_table, sre);\n \t\tISOM_DECREASE_SIZE(ptr, 8)\n \t\tsre->first_segment = gf_bs_read_u32(bs);\n \t\tsre->fragment_per_segment = gf_bs_read_u32(bs);\n-\t\tgf_list_insert(ptr->segment_run_entry_table, sre, i);\n \t}\n \n \treturn GF_OK;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);",
                "\t\tgf_list_insert(ptr->segment_run_entry_table, sre, i);"
            ],
            "added_lines": [
                "\t\tgf_list_add(ptr->quality_segment_url_modifiers, tmp_str);",
                "\t\tgf_list_add(ptr->segment_run_entry_table, sre);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4743",
        "func_name": "libsdl-org/SDL/GLES_CreateTexture",
        "description": "A potential memory leak issue was discovered in SDL2 in GLES_CreateTexture() function in SDL_render_gles.c. The vulnerability allows an attacker to cause a denial of service attack. The vulnerability affects SDL2 v2.0.4 and above. SDL-1.x are not affected.",
        "git_url": "https://github.com/libsdl-org/SDL/commit/00b67f55727bc0944c3266e2b875440da132ce4b",
        "commit_title": "Fix potential memory leak in GLES_CreateTexture",
        "commit_text": "",
        "func_before": "static int\nGLES_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *data;\n    GLint internalFormat;\n    GLenum format, type;\n    int texture_w, texture_h;\n    GLenum scaleMode;\n    GLenum result;\n\n    GLES_ActivateRenderer(renderer);\n\n    switch (texture->format) {\n    case SDL_PIXELFORMAT_ABGR8888:\n        internalFormat = GL_RGBA;\n        format = GL_RGBA;\n        type = GL_UNSIGNED_BYTE;\n        break;\n    default:\n        return SDL_SetError(\"Texture format not supported\");\n    }\n\n    data = (GLES_TextureData *) SDL_calloc(1, sizeof(*data));\n    if (!data) {\n        return SDL_OutOfMemory();\n    }\n\n    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n        data->pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);\n        data->pixels = SDL_calloc(1, texture->h * data->pitch);\n        if (!data->pixels) {\n            SDL_free(data);\n            return SDL_OutOfMemory();\n        }\n    }\n\n\n    if (texture->access == SDL_TEXTUREACCESS_TARGET) {\n        if (!renderdata->GL_OES_framebuffer_object_supported) {\n            SDL_free(data);\n            return SDL_SetError(\"GL_OES_framebuffer_object not supported\");\n        }\n        data->fbo = GLES_GetFBO(renderer->driverdata, texture->w, texture->h);\n    } else {\n        data->fbo = NULL;\n    }\n\n\n    renderdata->glGetError();\n    renderdata->glEnable(GL_TEXTURE_2D);\n    renderdata->glGenTextures(1, &data->texture);\n    result = renderdata->glGetError();\n    if (result != GL_NO_ERROR) {\n        SDL_free(data);\n        return GLES_SetError(\"glGenTextures()\", result);\n    }\n\n    data->type = GL_TEXTURE_2D;\n    /* no NPOV textures allowed in OpenGL ES (yet) */\n    texture_w = SDL_powerof2(texture->w);\n    texture_h = SDL_powerof2(texture->h);\n    data->texw = (GLfloat) texture->w / texture_w;\n    data->texh = (GLfloat) texture->h / texture_h;\n\n    data->format = format;\n    data->formattype = type;\n    scaleMode = (texture->scaleMode == SDL_ScaleModeNearest) ? GL_NEAREST : GL_LINEAR;\n    renderdata->glBindTexture(data->type, data->texture);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MIN_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MAG_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\n    renderdata->glTexImage2D(data->type, 0, internalFormat, texture_w,\n                             texture_h, 0, format, type, NULL);\n    renderdata->glDisable(GL_TEXTURE_2D);\n    renderdata->drawstate.texture = texture;\n    renderdata->drawstate.texturing = SDL_FALSE;\n\n    result = renderdata->glGetError();\n    if (result != GL_NO_ERROR) {\n        SDL_free(data);\n        return GLES_SetError(\"glTexImage2D()\", result);\n    }\n\n    texture->driverdata = data;\n    return 0;\n}",
        "func": "static int\nGLES_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)\n{\n    GLES_RenderData *renderdata = (GLES_RenderData *) renderer->driverdata;\n    GLES_TextureData *data;\n    GLint internalFormat;\n    GLenum format, type;\n    int texture_w, texture_h;\n    GLenum scaleMode;\n    GLenum result;\n\n    GLES_ActivateRenderer(renderer);\n\n    switch (texture->format) {\n    case SDL_PIXELFORMAT_ABGR8888:\n        internalFormat = GL_RGBA;\n        format = GL_RGBA;\n        type = GL_UNSIGNED_BYTE;\n        break;\n    default:\n        return SDL_SetError(\"Texture format not supported\");\n    }\n\n    data = (GLES_TextureData *) SDL_calloc(1, sizeof(*data));\n    if (!data) {\n        return SDL_OutOfMemory();\n    }\n\n    if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n        data->pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);\n        data->pixels = SDL_calloc(1, texture->h * data->pitch);\n        if (!data->pixels) {\n            SDL_free(data);\n            return SDL_OutOfMemory();\n        }\n    }\n\n\n    if (texture->access == SDL_TEXTUREACCESS_TARGET) {\n        if (!renderdata->GL_OES_framebuffer_object_supported) {\n            SDL_free(data);\n            return SDL_SetError(\"GL_OES_framebuffer_object not supported\");\n        }\n        data->fbo = GLES_GetFBO(renderer->driverdata, texture->w, texture->h);\n    } else {\n        data->fbo = NULL;\n    }\n\n\n    renderdata->glGetError();\n    renderdata->glEnable(GL_TEXTURE_2D);\n    renderdata->glGenTextures(1, &data->texture);\n    result = renderdata->glGetError();\n    if (result != GL_NO_ERROR) {\n        if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n            SDL_free(data->pixels);\n        }\n        SDL_free(data);\n        return GLES_SetError(\"glGenTextures()\", result);\n    }\n\n    data->type = GL_TEXTURE_2D;\n    /* no NPOV textures allowed in OpenGL ES (yet) */\n    texture_w = SDL_powerof2(texture->w);\n    texture_h = SDL_powerof2(texture->h);\n    data->texw = (GLfloat) texture->w / texture_w;\n    data->texh = (GLfloat) texture->h / texture_h;\n\n    data->format = format;\n    data->formattype = type;\n    scaleMode = (texture->scaleMode == SDL_ScaleModeNearest) ? GL_NEAREST : GL_LINEAR;\n    renderdata->glBindTexture(data->type, data->texture);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MIN_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_MAG_FILTER, scaleMode);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    renderdata->glTexParameteri(data->type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\n    renderdata->glTexImage2D(data->type, 0, internalFormat, texture_w,\n                             texture_h, 0, format, type, NULL);\n    renderdata->glDisable(GL_TEXTURE_2D);\n    renderdata->drawstate.texture = texture;\n    renderdata->drawstate.texturing = SDL_FALSE;\n\n    result = renderdata->glGetError();\n    if (result != GL_NO_ERROR) {\n        if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n            SDL_free(data->pixels);\n        }\n        SDL_free(data);\n        return GLES_SetError(\"glTexImage2D()\", result);\n    }\n\n    texture->driverdata = data;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -52,6 +52,9 @@\n     renderdata->glGenTextures(1, &data->texture);\n     result = renderdata->glGetError();\n     if (result != GL_NO_ERROR) {\n+        if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n+            SDL_free(data->pixels);\n+        }\n         SDL_free(data);\n         return GLES_SetError(\"glGenTextures()\", result);\n     }\n@@ -80,6 +83,9 @@\n \n     result = renderdata->glGetError();\n     if (result != GL_NO_ERROR) {\n+        if (texture->access == SDL_TEXTUREACCESS_STREAMING) {\n+            SDL_free(data->pixels);\n+        }\n         SDL_free(data);\n         return GLES_SetError(\"glTexImage2D()\", result);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (texture->access == SDL_TEXTUREACCESS_STREAMING) {",
                "            SDL_free(data->pixels);",
                "        }",
                "        if (texture->access == SDL_TEXTUREACCESS_STREAMING) {",
                "            SDL_free(data->pixels);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-23145",
        "func_name": "gpac/lsr_read_rare_full",
        "description": "GPAC version 2.2-rev0-gab012bbfb-master was discovered to contain a memory leak in lsr_read_rare_full function.",
        "git_url": "https://github.com/gpac/gpac/commit/4ade98128cbc41d5115b97a41ca2e59529c8dd5f",
        "commit_title": "fixed #2365",
        "commit_text": "",
        "func_before": "static void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 i, nb_rare, field_rare;\n\ts32 field_tag;\n\n\tGF_LSR_READ_INT(lsr, nb_rare, 1, \"has_rare\");\n\tif (!nb_rare) return;\n\tGF_LSR_READ_INT(lsr, nb_rare, 6, \"nbOfAttributes\");\n\n\tfor (i=0; i<nb_rare; i++) {\n\t\tGF_LSR_READ_INT(lsr, field_rare, 6, \"attributeRARE\");\n\n\t\t/*lsr extend*/\n\t\tif (field_rare==49) {\n\t\t\tu32 extID, len, j;\n\t\t\twhile (1) {\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, \"extensionID\");\n\t\t\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tif (extID==2) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, len, 2, \"nbOfAttributes\");\n\t\t\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, extID, 3, \"attributeRARE\");\n\t\t\t\t\t\tswitch (extID) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"syncMaster\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, \"focusHighlight\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, \"initialVisibility\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"fullscreen\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, \"requiredFonts\", GF_FALSE, GF_TRUE);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_read_int(lsr->bs, len);\n\t\t\t\t}\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, 1, \"hasNextExtension\");\n\t\t\t\tif (!extID) break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfield_tag = gf_lsr_rare_type_to_attribute(field_rare);\n\t\tif (field_tag==-1) {\n\t\t\treturn;\n\t\t}\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info);\n\t\tif (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED;\n\t\tif (lsr->last_error) return;\n\n\t\tswitch (field_tag) {\n\t\tcase TAG_SVG_ATT__class:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"class\");\n\t\t\tbreak;\n\t\t/*properties*/\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"audio-level\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color:\n\t\t\tlsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, \"color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"color-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, \"display\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display_align:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, \"display-align\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_rule:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, \"fill-rule\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_image_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"image-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_line_increment:\n\t\t\tlsr_read_line_increment_type(lsr, info.far_ptr, \"line-increment\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_pointer_events:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, \"pointer-events\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_shape_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"shape-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"solid-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"solid-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"stop-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stop-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dasharray:\n\t\t{\n\t\t\tu32 j, flag;\n\t\t\tSVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"dashArray\");\n\t\t\tif (flag) {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.count = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tda->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<da->array.count; j++) {\n\t\t\t\t\tda->array.vals[j] = lsr_read_fixed_16_8(lsr, \"dash\");\n\t\t\t\t\tda->array.units[j] = 0;\n\t\t\t\t\tif (lsr->last_error) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dashoffset:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"dashOffset\");\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_stroke_linecap:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, \"stroke-linecap\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_linejoin:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, \"stroke-linejoin\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_miterlimit:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"miterLimit\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stroke-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_width:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"strokeWidth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_anchor:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, \"text-achor\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"text-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"viewport-fill\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"viewport-fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_vector_effect:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, \"vector-effect\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_visibility:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, \"visibility\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredExtensions:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredExtensions\", GF_TRUE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFormats:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredFormats\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFeatures:\n\t\t{\n\t\t\tu32 j, fcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tfor (j=0; j<fcount; j++) {\n\t\t\t\tu32 fval;\n\t\t\t\tGF_LSR_READ_INT(lsr, fval, 6, \"feature\");\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_systemLanguage:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"systemLanguage\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_base:\n\t\t\tlsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, \"xml:base\");\n\t\t\t((XMLRI*)info.far_ptr)->type = XMLRI_STRING;\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_lang:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xml:lang\");\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_space:\n\t\t\tGF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, \"xml:space\");\n\t\t\tbreak;\n\t\t/*focusable*/\n\t\tcase TAG_SVG_ATT_nav_next:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNext\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_prev:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusPrev\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_focusable:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, \"focusable\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_transform:\n\t\t\tlsr_read_matrix(lsr, info.far_ptr);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_decoration:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"textDecoration\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_font_variant:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, \"font-variant\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_family:\n\t\t{\n\t\t\tu32 flag;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isInherit\");\n\t\t\tif (flag) {\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT;\n\t\t\t} else {\n\t\t\t\tchar *ft;\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE;\n\t\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, \"fontIndex\");\n\t\t\t\tft = (char*)gf_list_get(lsr->font_table, flag);\n\t\t\t\tif (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_size:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"fontSize\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_style:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, \"fontStyle\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_weight:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, \"fontWeight\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_title:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xlink:title\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_type:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:type\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_role:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:role\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_arcrole:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:arcrole\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_actuate:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 2, \"xlink:actuate\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_show:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:show\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_end:\n\t\t\tlsr_read_smil_times(lsr, NULL, 0, info.far_ptr, \"end\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_max:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_min:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (lsr->last_error) return;\n\t}\n}",
        "func": "static void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n)\n{\n\tGF_FieldInfo info;\n\tu32 i, nb_rare, field_rare;\n\ts32 field_tag;\n\n\tGF_LSR_READ_INT(lsr, nb_rare, 1, \"has_rare\");\n\tif (!nb_rare) return;\n\tGF_LSR_READ_INT(lsr, nb_rare, 6, \"nbOfAttributes\");\n\n\tfor (i=0; i<nb_rare; i++) {\n\t\tGF_LSR_READ_INT(lsr, field_rare, 6, \"attributeRARE\");\n\n\t\t/*lsr extend*/\n\t\tif (field_rare==49) {\n\t\t\tu32 extID, len, j;\n\t\t\twhile (1) {\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, \"extensionID\");\n\t\t\t\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tif (extID==2) {\n\t\t\t\t\tGF_LSR_READ_INT(lsr, len, 2, \"nbOfAttributes\");\n\t\t\t\t\tfor (j=0; j<len; j++) {\n\t\t\t\t\t\tGF_LSR_READ_INT(lsr, extID, 3, \"attributeRARE\");\n\t\t\t\t\t\tswitch (extID) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"syncMaster\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, \"focusHighlight\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, \"initialVisibility\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, \"fullscreen\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info);\n\t\t\t\t\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, \"requiredFonts\", GF_FALSE, GF_TRUE);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_read_int(lsr->bs, len);\n\t\t\t\t}\n\t\t\t\tGF_LSR_READ_INT(lsr, extID, 1, \"hasNextExtension\");\n\t\t\t\tif (!extID) break;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfield_tag = gf_lsr_rare_type_to_attribute(field_rare);\n\t\tif (field_tag==-1) {\n\t\t\treturn;\n\t\t}\n\t\tlsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info);\n\t\tif (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED;\n\t\tif (lsr->last_error) return;\n\n\t\tswitch (field_tag) {\n\t\tcase TAG_SVG_ATT__class:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"class\");\n\t\t\tbreak;\n\t\t/*properties*/\n\t\tcase TAG_SVG_ATT_audio_level:\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"audio-level\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color:\n\t\t\tlsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, \"color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_color_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"color-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, \"display\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_display_align:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, \"display-align\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_fill_rule:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, \"fill-rule\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_image_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, \"image-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_line_increment:\n\t\t\tlsr_read_line_increment_type(lsr, info.far_ptr, \"line-increment\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_pointer_events:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, \"pointer-events\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_shape_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"shape-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"solid-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_solid_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"solid-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_color:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"stop-color\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stop_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stop-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dasharray:\n\t\t{\n\t\t\tu32 j, flag;\n\t\t\tSVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"dashArray\");\n\t\t\tif (flag) {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_INHERIT;\n\t\t\t} else {\n\t\t\t\tda->type=SVG_STROKEDASHARRAY_ARRAY;\n\t\t\t\tda->array.count = lsr_read_vluimsbf5(lsr, \"len\");\n\t\t\t\tda->array.vals = (Fixed*)gf_realloc(da->array.vals, sizeof(Fixed)*da->array.count);\n\t\t\t\tda->array.units = (u8*)gf_realloc(da->array.units, sizeof(u8)*da->array.count);\n\t\t\t\tif (!da->array.vals || !da->array.units) {\n\t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (j=0; j<da->array.count; j++) {\n\t\t\t\t\tda->array.vals[j] = lsr_read_fixed_16_8(lsr, \"dash\");\n\t\t\t\t\tda->array.units[j] = 0;\n\t\t\t\t\tif (lsr->last_error) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_dashoffset:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"dashOffset\");\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_stroke_linecap:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, \"stroke-linecap\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_linejoin:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, \"stroke-linejoin\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_miterlimit:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"miterLimit\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"stroke-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_stroke_width:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"strokeWidth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_anchor:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, \"text-achor\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_rendering:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, \"text-rendering\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill:\n\t\t\tlsr_read_paint(lsr, info.far_ptr, \"viewport-fill\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_viewport_fill_opacity:\n\t\t\t((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE;\n\t\t\t((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, \"viewport-fill-opacity\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_vector_effect:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, \"vector-effect\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_visibility:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, \"visibility\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredExtensions:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredExtensions\", GF_TRUE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFormats:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"requiredFormats\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_requiredFeatures:\n\t\t{\n\t\t\tu32 j, fcount = lsr_read_vluimsbf5(lsr, \"count\");\n\t\t\tfor (j=0; j<fcount; j++) {\n\t\t\t\tu32 fval;\n\t\t\t\tGF_LSR_READ_INT(lsr, fval, 6, \"feature\");\n\t\t\t\tif (lsr->last_error) return;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_systemLanguage:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"systemLanguage\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_base:\n\t\t\tlsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, \"xml:base\");\n\t\t\t((XMLRI*)info.far_ptr)->type = XMLRI_STRING;\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_lang:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xml:lang\");\n\t\t\tbreak;\n\t\tcase TAG_XML_ATT_space:\n\t\t\tGF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, \"xml:space\");\n\t\t\tbreak;\n\t\t/*focusable*/\n\t\tcase TAG_SVG_ATT_nav_next:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNext\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_up_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusNorthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_prev:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusPrev\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouth\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_down_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusSouthWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_left:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusEast\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_focusable:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, \"focusable\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_nav_right:\n\t\t\tlsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, \"focusWest\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_transform:\n\t\t\tlsr_read_matrix(lsr, info.far_ptr);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_text_decoration:\n\t\t\tlsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, \"textDecoration\", GF_FALSE, GF_FALSE);\n\t\t\tbreak;\n\n\t\tcase TAG_SVG_ATT_font_variant:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, \"font-variant\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_family:\n\t\t{\n\t\t\tu32 flag;\n\t\t\tGF_LSR_READ_INT(lsr, flag, 1, \"isInherit\");\n\t\t\tif (flag) {\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT;\n\t\t\t} else {\n\t\t\t\tchar *ft;\n\t\t\t\t((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE;\n\t\t\t\tGF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, \"fontIndex\");\n\t\t\t\tft = (char*)gf_list_get(lsr->font_table, flag);\n\t\t\t\tif (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_size:\n\t\t\tlsr_read_fixed_16_8i(lsr, info.far_ptr, \"fontSize\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_style:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, \"fontStyle\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_font_weight:\n\t\t\tGF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, \"fontWeight\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_title:\n\t\t\tlsr_read_byte_align_string(lsr, info.far_ptr, \"xlink:title\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_type:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:type\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_role:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:role\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_arcrole:\n\t\t\tlsr_read_any_uri(lsr, info.far_ptr, \"xlink:arcrole\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_actuate:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 2, \"xlink:actuate\");\n\t\t\tbreak;\n\t\tcase TAG_XLINK_ATT_show:\n\t\t\t/*TODO FIXME*/\n\t\t\tGF_LSR_READ_INT(lsr, field_rare, 3, \"xlink:show\");\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_end:\n\t\t\tlsr_read_smil_times(lsr, NULL, 0, info.far_ptr, \"end\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_max:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\tcase TAG_SVG_ATT_min:\n\t\t\tlsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, \"min\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (lsr->last_error) return;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -123,8 +123,8 @@\n \t\t\t} else {\n \t\t\t\tda->type=SVG_STROKEDASHARRAY_ARRAY;\n \t\t\t\tda->array.count = lsr_read_vluimsbf5(lsr, \"len\");\n-\t\t\t\tda->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);\n-\t\t\t\tda->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count);\n+\t\t\t\tda->array.vals = (Fixed*)gf_realloc(da->array.vals, sizeof(Fixed)*da->array.count);\n+\t\t\t\tda->array.units = (u8*)gf_realloc(da->array.units, sizeof(u8)*da->array.count);\n \t\t\t\tif (!da->array.vals || !da->array.units) {\n \t\t\t\t\tlsr->last_error = GF_OUT_OF_MEM;\n \t\t\t\t\treturn;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tda->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count);",
                "\t\t\t\tda->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count);"
            ],
            "added_lines": [
                "\t\t\t\tda->array.vals = (Fixed*)gf_realloc(da->array.vals, sizeof(Fixed)*da->array.count);",
                "\t\t\t\tda->array.units = (u8*)gf_realloc(da->array.units, sizeof(u8)*da->array.count);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25566",
        "func_name": "gssapi/gss-ntlmssp/parse_user_name",
        "description": "GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM authentication. Prior to version 1.2.0, a memory leak can be triggered when parsing usernames which can trigger a denial-of-service. The domain portion of a username may be overridden causing an allocated memory area the size of the domain name to be leaked. An attacker can leak memory via the main `gss_accept_sec_context` entry point, potentially causing a denial-of-service. This issue is fixed in version 1.2.0.\n\n",
        "git_url": "https://github.com/gssapi/gss-ntlmssp/commit/8660fb16474054e692a596e9c79670cd4d3954f4",
        "commit_title": "GHSL-2023-010: Memory leak when parsing usernames",
        "commit_text": " Memory leak when parsing usernames (GHSL-2023-010)  Fixes defect GHSL-2023-010 found by the GitHub Security Lab team via oss-fuzz.  The domain portion may be overridden causing an allocated memory area the size of the domain name to be lost. This could be used to mount a DoS by depleeting the server memory. ",
        "func_before": "static uint32_t parse_user_name(uint32_t *minor_status,\n                                const char *str, size_t len,\n                                char **domain, char **username)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n    char *at, *sep;\n\n    if (len > MAX_NAME_LEN) {\n        return GSSERRS(ERR_NAMETOOLONG, GSS_S_BAD_NAME);\n    }\n\n    *username = NULL;\n    *domain = NULL;\n\n    /* let's check if there are '@' or '\\' signs */\n    at = memchr(str, '@', len);\n    sep = memchr(str, '\\\\', len);\n\n    /* Check if enterprise name first */\n    if (at && sep) {\n        /* we may have an enterprise name here */\n        char strbuf[len + 1];\n        char *buf = strbuf;\n        bool domain_handled = false;\n\n        /* copy buf to manipulate it */\n        memcpy(buf, str, len);\n        buf[len] = '\\0';\n\n        /* adjust pointers relative to new buffer */\n        sep = buf + (sep - str);\n        at = buf + (at - str);\n\n        if (sep > at) {\n            /* domain name contains an '@' sign ... */\n            if (*(sep + 1) == '@') {\n                /* invalid case of XXX@YYY\\@ZZZ*/\n                set_GSSERR(EINVAL);\n                goto done;\n            }\n        } else if (at - sep == 1) {\n            /* it's just a '\\@' escape */\n            /* no leading domain */\n            sep = NULL;\n        }\n\n        if (sep) {\n            /* leading domain, copy if domain name is not empty */\n            domain_handled = true;\n\n            /* terminate and copy domain, even if empty */\n            /* NOTE: this is important for the Windbind integration case\n             * where we need to tell the machinery to *not* add the default\n             * domain name, it happens when the domain is NULL. */\n            *sep = '\\0';\n            *domain = strdup(buf);\n            if (NULL == *domain) {\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n            /* point buf at username part */\n            len = len - (sep - buf) - 1;\n            buf = sep + 1;\n        }\n\n        for (at = strchr(buf, '@'); at != NULL; at = strchr(at, '@')) {\n            if (*(at - 1) == '\\\\') {\n                if (domain_handled) {\n                    /* Invalid forms like DOM\\foo\\@bar or foo@bar\\@baz */\n                    free(*domain);\n                    *domain = NULL;\n                    set_GSSERR(EINVAL);\n                    goto done;\n                }\n                /* remove escape, moving all including terminating '\\0' */\n                memmove(at - 1, at, len - (at - buf) + 1);\n            } else if (!domain_handled) {\n                /* an '@' without escape and no previous\n                 * domain was split out.\n                 * the rest of the string is the domain */\n                *at = '\\0';\n                *domain = strdup(at + 1);\n                if (NULL == *domain) {\n                    set_GSSERR(ENOMEM);\n                    goto done;\n                }\n                /* note we continue the loop to check if any invalid\n                 * \\@ escapes is found in the domain part */\n            }\n            at += 1;\n        }\n\n        *username = strdup(buf);\n        if (NULL == *username) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n\n        /* we got an enterprise name, return */\n        set_GSSERRS(0, GSS_S_COMPLETE);\n        goto done;\n    }\n\n    /* Check if in classic DOMAIN\\User windows format */\n    if (sep) {\n        retmaj = string_split(&retmin, '\\\\', str, len, domain, username);\n        goto done;\n    }\n\n    /* else accept a user@domain format too */\n    if (at) {\n        retmaj = string_split(&retmin, '@', str, len, username, domain);\n        goto done;\n    }\n\n    /* finally, take string as simple user name */\n    *username = strndup(str, len);\n    if (NULL == *username) {\n        set_GSSERR(ENOMEM);\n    }\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    return GSSERR();\n}",
        "func": "static uint32_t parse_user_name(uint32_t *minor_status,\n                                const char *str, size_t len,\n                                char **domain, char **username)\n{\n    uint32_t retmaj;\n    uint32_t retmin;\n    char *at, *sep;\n\n    if (len > MAX_NAME_LEN) {\n        return GSSERRS(ERR_NAMETOOLONG, GSS_S_BAD_NAME);\n    }\n\n    *username = NULL;\n    *domain = NULL;\n\n    /* let's check if there are '@' or '\\' signs */\n    at = memchr(str, '@', len);\n    sep = memchr(str, '\\\\', len);\n\n    /* Check if enterprise name first */\n    if (at && sep) {\n        /* we may have an enterprise name here */\n        char strbuf[len + 1];\n        char *buf = strbuf;\n\n        /* copy buf to manipulate it */\n        memcpy(buf, str, len);\n        buf[len] = '\\0';\n\n        /* adjust pointers relative to new buffer */\n        sep = buf + (sep - str);\n        at = buf + (at - str);\n\n        if (sep > at) {\n            /* domain name contains an '@' sign ... */\n            if (*(sep + 1) == '@') {\n                /* invalid case of XXX@YYY\\@ZZZ*/\n                set_GSSERR(EINVAL);\n                goto done;\n            }\n        } else if (at - sep == 1) {\n            /* it's just a '\\@' escape */\n            /* no leading domain */\n            sep = NULL;\n        }\n\n        if (sep) {\n            /* terminate and copy domain, even if empty */\n            /* NOTE: this is important for the Windbind integration case\n             * where we need to tell the machinery to *not* add the default\n             * domain name, it happens when the domain is NULL. */\n            *sep = '\\0';\n            *domain = strdup(buf);\n            if (NULL == *domain) {\n                set_GSSERR(ENOMEM);\n                goto done;\n            }\n            /* point buf at username part */\n            len = len - (sep - buf) - 1;\n            buf = sep + 1;\n        }\n\n        for (at = strchr(buf, '@'); at != NULL; at = strchr(at, '@')) {\n            if (*(at - 1) == '\\\\') {\n                if (*domain) {\n                    /* Invalid forms like DOM\\foo\\@bar or foo@bar\\@baz */\n                    free(*domain);\n                    *domain = NULL;\n                    set_GSSERR(EINVAL);\n                    goto done;\n                }\n                /* remove escape, moving all including terminating '\\0' */\n                memmove(at - 1, at, len - (at - buf) + 1);\n            } else if (!*domain) {\n                /* an '@' without escape and no previous\n                 * domain was split out.\n                 * the rest of the string is the domain */\n                *at = '\\0';\n                *domain = strdup(at + 1);\n                if (NULL == *domain) {\n                    set_GSSERR(ENOMEM);\n                    goto done;\n                }\n                /* note we continue the loop to check if any invalid\n                 * \\@ escapes is found in the domain part */\n            }\n            at += 1;\n        }\n\n        *username = strdup(buf);\n        if (NULL == *username) {\n            set_GSSERR(ENOMEM);\n            goto done;\n        }\n\n        /* we got an enterprise name, return */\n        set_GSSERRS(0, GSS_S_COMPLETE);\n        goto done;\n    }\n\n    /* Check if in classic DOMAIN\\User windows format */\n    if (sep) {\n        retmaj = string_split(&retmin, '\\\\', str, len, domain, username);\n        goto done;\n    }\n\n    /* else accept a user@domain format too */\n    if (at) {\n        retmaj = string_split(&retmin, '@', str, len, username, domain);\n        goto done;\n    }\n\n    /* finally, take string as simple user name */\n    *username = strndup(str, len);\n    if (NULL == *username) {\n        set_GSSERR(ENOMEM);\n    }\n    set_GSSERRS(0, GSS_S_COMPLETE);\n\ndone:\n    return GSSERR();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,6 @@\n         /* we may have an enterprise name here */\n         char strbuf[len + 1];\n         char *buf = strbuf;\n-        bool domain_handled = false;\n \n         /* copy buf to manipulate it */\n         memcpy(buf, str, len);\n@@ -46,9 +45,6 @@\n         }\n \n         if (sep) {\n-            /* leading domain, copy if domain name is not empty */\n-            domain_handled = true;\n-\n             /* terminate and copy domain, even if empty */\n             /* NOTE: this is important for the Windbind integration case\n              * where we need to tell the machinery to *not* add the default\n@@ -66,7 +62,7 @@\n \n         for (at = strchr(buf, '@'); at != NULL; at = strchr(at, '@')) {\n             if (*(at - 1) == '\\\\') {\n-                if (domain_handled) {\n+                if (*domain) {\n                     /* Invalid forms like DOM\\foo\\@bar or foo@bar\\@baz */\n                     free(*domain);\n                     *domain = NULL;\n@@ -75,7 +71,7 @@\n                 }\n                 /* remove escape, moving all including terminating '\\0' */\n                 memmove(at - 1, at, len - (at - buf) + 1);\n-            } else if (!domain_handled) {\n+            } else if (!*domain) {\n                 /* an '@' without escape and no previous\n                  * domain was split out.\n                  * the rest of the string is the domain */",
        "diff_line_info": {
            "deleted_lines": [
                "        bool domain_handled = false;",
                "            /* leading domain, copy if domain name is not empty */",
                "            domain_handled = true;",
                "",
                "                if (domain_handled) {",
                "            } else if (!domain_handled) {"
            ],
            "added_lines": [
                "                if (*domain) {",
                "            } else if (!*domain) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0597",
        "func_name": "torvalds/linux/within_cpu_entry",
        "description": "A flaw possibility of memory leak in the Linux kernel cpu_entry_area mapping of X86 CPU data to memory was found in the way user can guess location of exception stack(s) or other important data. A local user could use this flaw to get access to some important data with expected location in memory.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=97e3d26b5e5f371b3ee223d94dd123e6c442ba80",
        "commit_title": "Seth found that the CPU-entry-area; the piece of per-cpu data that is",
        "commit_text": "mapped into the userspace page-tables for kPTI is not subject to any randomization -- irrespective of kASLR settings.  On x86_64 a whole P4D (512 GB) of virtual address space is reserved for this structure, which is plenty large enough to randomize things a little.  As such, use a straight forward randomization scheme that avoids duplicates to spread the existing CPUs over the available space.    [ bp: Fix le build. ]  ",
        "func_before": "static inline bool within_cpu_entry(unsigned long addr, unsigned long end)\n{\n\tint cpu;\n\n\t/* CPU entry erea is always used for CPU entry */\n\tif (within_area(addr, end, CPU_ENTRY_AREA_BASE,\n\t\t\tCPU_ENTRY_AREA_TOTAL_SIZE))\n\t\treturn true;\n\n\t/*\n\t * When FSGSBASE is enabled, paranoid_entry() fetches the per-CPU\n\t * GSBASE value via __per_cpu_offset or pcpu_unit_offsets.\n\t */\n#ifdef CONFIG_SMP\n\tif (within_area(addr, end, (unsigned long)__per_cpu_offset,\n\t\t\tsizeof(unsigned long) * nr_cpu_ids))\n\t\treturn true;\n#else\n\tif (within_area(addr, end, (unsigned long)&pcpu_unit_offsets,\n\t\t\tsizeof(pcpu_unit_offsets)))\n\t\treturn true;\n#endif\n\n\tfor_each_possible_cpu(cpu) {\n\t\t/* The original rw GDT is being used after load_direct_gdt() */\n\t\tif (within_area(addr, end, (unsigned long)get_cpu_gdt_rw(cpu),\n\t\t\t\tGDT_SIZE))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * cpu_tss_rw is not directly referenced by hardware, but\n\t\t * cpu_tss_rw is also used in CPU entry code,\n\t\t */\n\t\tif (within_area(addr, end,\n\t\t\t\t(unsigned long)&per_cpu(cpu_tss_rw, cpu),\n\t\t\t\tsizeof(struct tss_struct)))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * cpu_tlbstate.user_pcid_flush_mask is used for CPU entry.\n\t\t * If a data breakpoint on it, it will cause an unwanted #DB.\n\t\t * Protect the full cpu_tlbstate structure to be sure.\n\t\t */\n\t\tif (within_area(addr, end,\n\t\t\t\t(unsigned long)&per_cpu(cpu_tlbstate, cpu),\n\t\t\t\tsizeof(struct tlb_state)))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * When in guest (X86_FEATURE_HYPERVISOR), local_db_save()\n\t\t * will read per-cpu cpu_dr7 before clear dr7 register.\n\t\t */\n\t\tif (within_area(addr, end, (unsigned long)&per_cpu(cpu_dr7, cpu),\n\t\t\t\tsizeof(cpu_dr7)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
        "func": "static inline bool within_cpu_entry(unsigned long addr, unsigned long end)\n{\n\tint cpu;\n\n\t/* CPU entry erea is always used for CPU entry */\n\tif (within_area(addr, end, CPU_ENTRY_AREA_BASE,\n\t\t\tCPU_ENTRY_AREA_MAP_SIZE))\n\t\treturn true;\n\n\t/*\n\t * When FSGSBASE is enabled, paranoid_entry() fetches the per-CPU\n\t * GSBASE value via __per_cpu_offset or pcpu_unit_offsets.\n\t */\n#ifdef CONFIG_SMP\n\tif (within_area(addr, end, (unsigned long)__per_cpu_offset,\n\t\t\tsizeof(unsigned long) * nr_cpu_ids))\n\t\treturn true;\n#else\n\tif (within_area(addr, end, (unsigned long)&pcpu_unit_offsets,\n\t\t\tsizeof(pcpu_unit_offsets)))\n\t\treturn true;\n#endif\n\n\tfor_each_possible_cpu(cpu) {\n\t\t/* The original rw GDT is being used after load_direct_gdt() */\n\t\tif (within_area(addr, end, (unsigned long)get_cpu_gdt_rw(cpu),\n\t\t\t\tGDT_SIZE))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * cpu_tss_rw is not directly referenced by hardware, but\n\t\t * cpu_tss_rw is also used in CPU entry code,\n\t\t */\n\t\tif (within_area(addr, end,\n\t\t\t\t(unsigned long)&per_cpu(cpu_tss_rw, cpu),\n\t\t\t\tsizeof(struct tss_struct)))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * cpu_tlbstate.user_pcid_flush_mask is used for CPU entry.\n\t\t * If a data breakpoint on it, it will cause an unwanted #DB.\n\t\t * Protect the full cpu_tlbstate structure to be sure.\n\t\t */\n\t\tif (within_area(addr, end,\n\t\t\t\t(unsigned long)&per_cpu(cpu_tlbstate, cpu),\n\t\t\t\tsizeof(struct tlb_state)))\n\t\t\treturn true;\n\n\t\t/*\n\t\t * When in guest (X86_FEATURE_HYPERVISOR), local_db_save()\n\t\t * will read per-cpu cpu_dr7 before clear dr7 register.\n\t\t */\n\t\tif (within_area(addr, end, (unsigned long)&per_cpu(cpu_dr7, cpu),\n\t\t\t\tsizeof(cpu_dr7)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \n \t/* CPU entry erea is always used for CPU entry */\n \tif (within_area(addr, end, CPU_ENTRY_AREA_BASE,\n-\t\t\tCPU_ENTRY_AREA_TOTAL_SIZE))\n+\t\t\tCPU_ENTRY_AREA_MAP_SIZE))\n \t\treturn true;\n \n \t/*",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tCPU_ENTRY_AREA_TOTAL_SIZE))"
            ],
            "added_lines": [
                "\t\t\tCPU_ENTRY_AREA_MAP_SIZE))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0597",
        "func_name": "torvalds/linux/setup_cpu_entry_areas",
        "description": "A flaw possibility of memory leak in the Linux kernel cpu_entry_area mapping of X86 CPU data to memory was found in the way user can guess location of exception stack(s) or other important data. A local user could use this flaw to get access to some important data with expected location in memory.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=97e3d26b5e5f371b3ee223d94dd123e6c442ba80",
        "commit_title": "Seth found that the CPU-entry-area; the piece of per-cpu data that is",
        "commit_text": "mapped into the userspace page-tables for kPTI is not subject to any randomization -- irrespective of kASLR settings.  On x86_64 a whole P4D (512 GB) of virtual address space is reserved for this structure, which is plenty large enough to randomize things a little.  As such, use a straight forward randomization scheme that avoids duplicates to spread the existing CPUs over the available space.    [ bp: Fix le build. ]  ",
        "func_before": "void __init setup_cpu_entry_areas(void)\n{\n\tunsigned int cpu;\n\n\tsetup_cpu_entry_area_ptes();\n\n\tfor_each_possible_cpu(cpu)\n\t\tsetup_cpu_entry_area(cpu);\n\n\t/*\n\t * This is the last essential update to swapper_pgdir which needs\n\t * to be synchronized to initial_page_table on 32bit.\n\t */\n\tsync_initial_page_table();\n}",
        "func": "void __init setup_cpu_entry_areas(void)\n{\n\tunsigned int cpu;\n\n\tinit_cea_offsets();\n\n\tsetup_cpu_entry_area_ptes();\n\n\tfor_each_possible_cpu(cpu)\n\t\tsetup_cpu_entry_area(cpu);\n\n\t/*\n\t * This is the last essential update to swapper_pgdir which needs\n\t * to be synchronized to initial_page_table on 32bit.\n\t */\n\tsync_initial_page_table();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n void __init setup_cpu_entry_areas(void)\n {\n \tunsigned int cpu;\n+\n+\tinit_cea_offsets();\n \n \tsetup_cpu_entry_area_ptes();\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tinit_cea_offsets();"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0597",
        "func_name": "torvalds/linux/get_cpu_entry_area",
        "description": "A flaw possibility of memory leak in the Linux kernel cpu_entry_area mapping of X86 CPU data to memory was found in the way user can guess location of exception stack(s) or other important data. A local user could use this flaw to get access to some important data with expected location in memory.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=97e3d26b5e5f371b3ee223d94dd123e6c442ba80",
        "commit_title": "Seth found that the CPU-entry-area; the piece of per-cpu data that is",
        "commit_text": "mapped into the userspace page-tables for kPTI is not subject to any randomization -- irrespective of kASLR settings.  On x86_64 a whole P4D (512 GB) of virtual address space is reserved for this structure, which is plenty large enough to randomize things a little.  As such, use a straight forward randomization scheme that avoids duplicates to spread the existing CPUs over the available space.    [ bp: Fix le build. ]  ",
        "func_before": "cpu_entry_area *get_cpu_entry_area(int cpu)\n{\n\tunsigned long va = CPU_ENTRY_AREA_PER_CPU + cpu * CPU_ENTRY_AREA_SIZE;\n\tBUILD_BUG_ON(sizeof(struct cpu_entry_area) % PAGE_SIZE != 0);\n\n\treturn (struct cpu_entry_area *) va;\n}",
        "func": "cpu_entry_area *get_cpu_entry_area(int cpu)\n{\n\tunsigned long va = CPU_ENTRY_AREA_PER_CPU + cea_offset(cpu) * CPU_ENTRY_AREA_SIZE;\n\tBUILD_BUG_ON(sizeof(struct cpu_entry_area) % PAGE_SIZE != 0);\n\n\treturn (struct cpu_entry_area *) va;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n cpu_entry_area *get_cpu_entry_area(int cpu)\n {\n-\tunsigned long va = CPU_ENTRY_AREA_PER_CPU + cpu * CPU_ENTRY_AREA_SIZE;\n+\tunsigned long va = CPU_ENTRY_AREA_PER_CPU + cea_offset(cpu) * CPU_ENTRY_AREA_SIZE;\n \tBUILD_BUG_ON(sizeof(struct cpu_entry_area) % PAGE_SIZE != 0);\n \n \treturn (struct cpu_entry_area *) va;",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned long va = CPU_ENTRY_AREA_PER_CPU + cpu * CPU_ENTRY_AREA_SIZE;"
            ],
            "added_lines": [
                "\tunsigned long va = CPU_ENTRY_AREA_PER_CPU + cea_offset(cpu) * CPU_ENTRY_AREA_SIZE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0597",
        "func_name": "torvalds/linux/setup_cpu_entry_area_ptes",
        "description": "A flaw possibility of memory leak in the Linux kernel cpu_entry_area mapping of X86 CPU data to memory was found in the way user can guess location of exception stack(s) or other important data. A local user could use this flaw to get access to some important data with expected location in memory.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=97e3d26b5e5f371b3ee223d94dd123e6c442ba80",
        "commit_title": "Seth found that the CPU-entry-area; the piece of per-cpu data that is",
        "commit_text": "mapped into the userspace page-tables for kPTI is not subject to any randomization -- irrespective of kASLR settings.  On x86_64 a whole P4D (512 GB) of virtual address space is reserved for this structure, which is plenty large enough to randomize things a little.  As such, use a straight forward randomization scheme that avoids duplicates to spread the existing CPUs over the available space.    [ bp: Fix le build. ]  ",
        "func_before": "static __init void setup_cpu_entry_area_ptes(void)\n{\n#ifdef CONFIG_X86_32\n\tunsigned long start, end;\n\n\t/* The +1 is for the readonly IDT: */\n\tBUILD_BUG_ON((CPU_ENTRY_AREA_PAGES+1)*PAGE_SIZE != CPU_ENTRY_AREA_MAP_SIZE);\n\tBUILD_BUG_ON(CPU_ENTRY_AREA_TOTAL_SIZE != CPU_ENTRY_AREA_MAP_SIZE);\n\tBUG_ON(CPU_ENTRY_AREA_BASE & ~PMD_MASK);\n\n\tstart = CPU_ENTRY_AREA_BASE;\n\tend = start + CPU_ENTRY_AREA_MAP_SIZE;\n\n\t/* Careful here: start + PMD_SIZE might wrap around */\n\tfor (; start < end && start >= CPU_ENTRY_AREA_BASE; start += PMD_SIZE)\n\t\tpopulate_extra_pte(start);\n#endif\n}",
        "func": "static __init void setup_cpu_entry_area_ptes(void)\n{\n#ifdef CONFIG_X86_32\n\tunsigned long start, end;\n\n\t/* The +1 is for the readonly IDT: */\n\tBUILD_BUG_ON((CPU_ENTRY_AREA_PAGES+1)*PAGE_SIZE != CPU_ENTRY_AREA_MAP_SIZE);\n\tBUG_ON(CPU_ENTRY_AREA_BASE & ~PMD_MASK);\n\n\tstart = CPU_ENTRY_AREA_BASE;\n\tend = start + CPU_ENTRY_AREA_MAP_SIZE;\n\n\t/* Careful here: start + PMD_SIZE might wrap around */\n\tfor (; start < end && start >= CPU_ENTRY_AREA_BASE; start += PMD_SIZE)\n\t\tpopulate_extra_pte(start);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,6 @@\n \n \t/* The +1 is for the readonly IDT: */\n \tBUILD_BUG_ON((CPU_ENTRY_AREA_PAGES+1)*PAGE_SIZE != CPU_ENTRY_AREA_MAP_SIZE);\n-\tBUILD_BUG_ON(CPU_ENTRY_AREA_TOTAL_SIZE != CPU_ENTRY_AREA_MAP_SIZE);\n \tBUG_ON(CPU_ENTRY_AREA_BASE & ~PMD_MASK);\n \n \tstart = CPU_ENTRY_AREA_BASE;",
        "diff_line_info": {
            "deleted_lines": [
                "\tBUILD_BUG_ON(CPU_ENTRY_AREA_TOTAL_SIZE != CPU_ENTRY_AREA_MAP_SIZE);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2023-26257",
        "func_name": "COVESA/dlt-daemon/set_ecuid",
        "description": "An issue was discovered in the Connected Vehicle Systems Alliance (COVESA; formerly GENIVI) dlt-daemon through 2.18.8. Dynamic memory is not released after it is allocated in dlt-control-common.c.",
        "git_url": "https://github.com/COVESA/dlt-daemon/commit/b6149e203f919c899fefc702a17fbb78bdec3700",
        "commit_title": "Fix memory leak",
        "commit_text": " Free the ecuid_conf in case of memory alllocated ",
        "func_before": "void set_ecuid(char *ecuid)\n{\n    char *ecuid_conf = NULL;\n\n    if (local_ecuid != ecuid) {\n        /* If user pass NULL, read ECUId from dlt.conf */\n        if (ecuid == NULL) {\n            if (dlt_parse_config_param(\"ECUId\", &ecuid_conf) == 0) {\n                memset(local_ecuid, 0, DLT_CTRL_ECUID_LEN);\n                strncpy(local_ecuid, ecuid_conf, DLT_CTRL_ECUID_LEN);\n                local_ecuid[DLT_CTRL_ECUID_LEN - 1] = '\\0';\n            }\n            else {\n                pr_error(\"Cannot read ECUid from dlt.conf\\n\");\n            }\n        }\n        else {\n            /* Set user passed ECUID */\n            memset(local_ecuid, 0, DLT_CTRL_ECUID_LEN);\n            strncpy(local_ecuid, ecuid, DLT_CTRL_ECUID_LEN);\n            local_ecuid[DLT_CTRL_ECUID_LEN - 1] = '\\0';\n        }\n    }\n}",
        "func": "void set_ecuid(char *ecuid)\n{\n    char *ecuid_conf = NULL;\n\n    if (local_ecuid != ecuid) {\n        /* If user pass NULL, read ECUId from dlt.conf */\n        if (ecuid == NULL) {\n            if (dlt_parse_config_param(\"ECUId\", &ecuid_conf) == 0) {\n                memset(local_ecuid, 0, DLT_CTRL_ECUID_LEN);\n                strncpy(local_ecuid, ecuid_conf, DLT_CTRL_ECUID_LEN);\n                if (ecuid_conf !=NULL)\n                    free(ecuid_conf);\n                local_ecuid[DLT_CTRL_ECUID_LEN - 1] = '\\0';\n            }\n            else {\n                pr_error(\"Cannot read ECUid from dlt.conf\\n\");\n            }\n        }\n        else {\n            /* Set user passed ECUID */\n            memset(local_ecuid, 0, DLT_CTRL_ECUID_LEN);\n            strncpy(local_ecuid, ecuid, DLT_CTRL_ECUID_LEN);\n            local_ecuid[DLT_CTRL_ECUID_LEN - 1] = '\\0';\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,8 @@\n             if (dlt_parse_config_param(\"ECUId\", &ecuid_conf) == 0) {\n                 memset(local_ecuid, 0, DLT_CTRL_ECUID_LEN);\n                 strncpy(local_ecuid, ecuid_conf, DLT_CTRL_ECUID_LEN);\n+                if (ecuid_conf !=NULL)\n+                    free(ecuid_conf);\n                 local_ecuid[DLT_CTRL_ECUID_LEN - 1] = '\\0';\n             }\n             else {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                if (ecuid_conf !=NULL)",
                "                    free(ecuid_conf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4002",
        "func_name": "torvalds/linux/__unmap_hugepage_range",
        "description": "A memory leak flaw in the Linux kernel's hugetlbfs memory usage was found in the way the user maps some regions of memory twice using shmget() which are aligned to PUD alignment with the fault of some of the memory pages. A local user could use this flaw to get unauthorized access to some data.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a4a118f2eead1d6c49e00765de89878288d4b890",
        "commit_title": "When __unmap_hugepage_range() calls to huge_pmd_unshare() succeed, a TLB",
        "commit_text": "flush is missing.  This TLB flush must be performed before releasing the i_mmap_rwsem, in order to prevent an unshared PMDs page from being released and reused before the TLB flush took place.  Arguably, a comprehensive solution would use mmu_gather interface to batch the TLB flushes and the PMDs page release, however it is not an easy solution: (1) try_to_unmap_one() and try_to_migrate_one() also call huge_pmd_unshare() and they cannot use the mmu_gather interface; and (2) deferring the release of the page reference for the PMDs page until after i_mmap_rwsem is dropeed can confuse huge_pmd_unshare() into thinking PMDs are shared when they are not.  Fix __unmap_hugepage_range() by adding the missing TLB flush, and forcing a flush when unshare is successful.  Cc: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com> Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com> Cc: Andrew Morton <akpm@linux-foundation.org> ",
        "func_before": "static void __unmap_hugepage_range(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t\t\t   unsigned long start, unsigned long end,\n\t\t\t\t   struct page *ref_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address;\n\tpte_t *ptep;\n\tpte_t pte;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long sz = huge_page_size(h);\n\tstruct mmu_notifier_range range;\n\n\tWARN_ON(!is_vm_hugetlb_page(vma));\n\tBUG_ON(start & ~huge_page_mask(h));\n\tBUG_ON(end & ~huge_page_mask(h));\n\n\t/*\n\t * This is a hugetlb vma, all the pte entries should point\n\t * to huge page.\n\t */\n\ttlb_change_page_size(tlb, sz);\n\ttlb_start_vma(tlb, vma);\n\n\t/*\n\t * If sharing possible, alert mmu notifiers of worst case.\n\t */\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, mm, start,\n\t\t\t\tend);\n\tadjust_range_if_pmd_sharing_possible(vma, &range.start, &range.end);\n\tmmu_notifier_invalidate_range_start(&range);\n\taddress = start;\n\tfor (; address < end; address += sz) {\n\t\tptep = huge_pte_offset(mm, address, sz);\n\t\tif (!ptep)\n\t\t\tcontinue;\n\n\t\tptl = huge_pte_lock(h, mm, ptep);\n\t\tif (huge_pmd_unshare(mm, vma, &address, ptep)) {\n\t\t\tspin_unlock(ptl);\n\t\t\t/*\n\t\t\t * We just unmapped a page of PMDs by clearing a PUD.\n\t\t\t * The caller's TLB flush range should cover this area.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tpte = huge_ptep_get(ptep);\n\t\tif (huge_pte_none(pte)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Migrating hugepage or HWPoisoned hugepage is already\n\t\t * unmapped and its refcount is dropped, so just clear pte here.\n\t\t */\n\t\tif (unlikely(!pte_present(pte))) {\n\t\t\thuge_pte_clear(mm, address, ptep, sz);\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = pte_page(pte);\n\t\t/*\n\t\t * If a reference page is supplied, it is because a specific\n\t\t * page is being unmapped, not a range. Ensure the page we\n\t\t * are about to unmap is the actual page of interest.\n\t\t */\n\t\tif (ref_page) {\n\t\t\tif (page != ref_page) {\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Mark the VMA as having unmapped its page so that\n\t\t\t * future faults in this VMA will fail rather than\n\t\t\t * looking like data was lost\n\t\t\t */\n\t\t\tset_vma_resv_flags(vma, HPAGE_RESV_UNMAPPED);\n\t\t}\n\n\t\tpte = huge_ptep_get_and_clear(mm, address, ptep);\n\t\ttlb_remove_huge_tlb_entry(h, tlb, ptep, address);\n\t\tif (huge_pte_dirty(pte))\n\t\t\tset_page_dirty(page);\n\n\t\thugetlb_count_sub(pages_per_huge_page(h), mm);\n\t\tpage_remove_rmap(page, true);\n\n\t\tspin_unlock(ptl);\n\t\ttlb_remove_page_size(tlb, page, huge_page_size(h));\n\t\t/*\n\t\t * Bail out after unmapping reference page if supplied\n\t\t */\n\t\tif (ref_page)\n\t\t\tbreak;\n\t}\n\tmmu_notifier_invalidate_range_end(&range);\n\ttlb_end_vma(tlb, vma);\n}",
        "func": "static void __unmap_hugepage_range(struct mmu_gather *tlb, struct vm_area_struct *vma,\n\t\t\t\t   unsigned long start, unsigned long end,\n\t\t\t\t   struct page *ref_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address;\n\tpte_t *ptep;\n\tpte_t pte;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long sz = huge_page_size(h);\n\tstruct mmu_notifier_range range;\n\tbool force_flush = false;\n\n\tWARN_ON(!is_vm_hugetlb_page(vma));\n\tBUG_ON(start & ~huge_page_mask(h));\n\tBUG_ON(end & ~huge_page_mask(h));\n\n\t/*\n\t * This is a hugetlb vma, all the pte entries should point\n\t * to huge page.\n\t */\n\ttlb_change_page_size(tlb, sz);\n\ttlb_start_vma(tlb, vma);\n\n\t/*\n\t * If sharing possible, alert mmu notifiers of worst case.\n\t */\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, mm, start,\n\t\t\t\tend);\n\tadjust_range_if_pmd_sharing_possible(vma, &range.start, &range.end);\n\tmmu_notifier_invalidate_range_start(&range);\n\taddress = start;\n\tfor (; address < end; address += sz) {\n\t\tptep = huge_pte_offset(mm, address, sz);\n\t\tif (!ptep)\n\t\t\tcontinue;\n\n\t\tptl = huge_pte_lock(h, mm, ptep);\n\t\tif (huge_pmd_unshare(mm, vma, &address, ptep)) {\n\t\t\tspin_unlock(ptl);\n\t\t\ttlb_flush_pmd_range(tlb, address & PUD_MASK, PUD_SIZE);\n\t\t\tforce_flush = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpte = huge_ptep_get(ptep);\n\t\tif (huge_pte_none(pte)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Migrating hugepage or HWPoisoned hugepage is already\n\t\t * unmapped and its refcount is dropped, so just clear pte here.\n\t\t */\n\t\tif (unlikely(!pte_present(pte))) {\n\t\t\thuge_pte_clear(mm, address, ptep, sz);\n\t\t\tspin_unlock(ptl);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = pte_page(pte);\n\t\t/*\n\t\t * If a reference page is supplied, it is because a specific\n\t\t * page is being unmapped, not a range. Ensure the page we\n\t\t * are about to unmap is the actual page of interest.\n\t\t */\n\t\tif (ref_page) {\n\t\t\tif (page != ref_page) {\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Mark the VMA as having unmapped its page so that\n\t\t\t * future faults in this VMA will fail rather than\n\t\t\t * looking like data was lost\n\t\t\t */\n\t\t\tset_vma_resv_flags(vma, HPAGE_RESV_UNMAPPED);\n\t\t}\n\n\t\tpte = huge_ptep_get_and_clear(mm, address, ptep);\n\t\ttlb_remove_huge_tlb_entry(h, tlb, ptep, address);\n\t\tif (huge_pte_dirty(pte))\n\t\t\tset_page_dirty(page);\n\n\t\thugetlb_count_sub(pages_per_huge_page(h), mm);\n\t\tpage_remove_rmap(page, true);\n\n\t\tspin_unlock(ptl);\n\t\ttlb_remove_page_size(tlb, page, huge_page_size(h));\n\t\t/*\n\t\t * Bail out after unmapping reference page if supplied\n\t\t */\n\t\tif (ref_page)\n\t\t\tbreak;\n\t}\n\tmmu_notifier_invalidate_range_end(&range);\n\ttlb_end_vma(tlb, vma);\n\n\t/*\n\t * If we unshared PMDs, the TLB flush was not recorded in mmu_gather. We\n\t * could defer the flush until now, since by holding i_mmap_rwsem we\n\t * guaranteed that the last refernece would not be dropped. But we must\n\t * do the flushing before we return, as otherwise i_mmap_rwsem will be\n\t * dropped and the last reference to the shared PMDs page might be\n\t * dropped as well.\n\t *\n\t * In theory we could defer the freeing of the PMD pages as well, but\n\t * huge_pmd_unshare() relies on the exact page_count for the PMD page to\n\t * detect sharing, so we cannot defer the release of the page either.\n\t * Instead, do flush now.\n\t */\n\tif (force_flush)\n\t\ttlb_flush_mmu_tlbonly(tlb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,7 @@\n \tstruct hstate *h = hstate_vma(vma);\n \tunsigned long sz = huge_page_size(h);\n \tstruct mmu_notifier_range range;\n+\tbool force_flush = false;\n \n \tWARN_ON(!is_vm_hugetlb_page(vma));\n \tBUG_ON(start & ~huge_page_mask(h));\n@@ -39,10 +40,8 @@\n \t\tptl = huge_pte_lock(h, mm, ptep);\n \t\tif (huge_pmd_unshare(mm, vma, &address, ptep)) {\n \t\t\tspin_unlock(ptl);\n-\t\t\t/*\n-\t\t\t * We just unmapped a page of PMDs by clearing a PUD.\n-\t\t\t * The caller's TLB flush range should cover this area.\n-\t\t\t */\n+\t\t\ttlb_flush_pmd_range(tlb, address & PUD_MASK, PUD_SIZE);\n+\t\t\tforce_flush = true;\n \t\t\tcontinue;\n \t\t}\n \n@@ -99,4 +98,20 @@\n \t}\n \tmmu_notifier_invalidate_range_end(&range);\n \ttlb_end_vma(tlb, vma);\n+\n+\t/*\n+\t * If we unshared PMDs, the TLB flush was not recorded in mmu_gather. We\n+\t * could defer the flush until now, since by holding i_mmap_rwsem we\n+\t * guaranteed that the last refernece would not be dropped. But we must\n+\t * do the flushing before we return, as otherwise i_mmap_rwsem will be\n+\t * dropped and the last reference to the shared PMDs page might be\n+\t * dropped as well.\n+\t *\n+\t * In theory we could defer the freeing of the PMD pages as well, but\n+\t * huge_pmd_unshare() relies on the exact page_count for the PMD page to\n+\t * detect sharing, so we cannot defer the release of the page either.\n+\t * Instead, do flush now.\n+\t */\n+\tif (force_flush)\n+\t\ttlb_flush_mmu_tlbonly(tlb);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t/*",
                "\t\t\t * We just unmapped a page of PMDs by clearing a PUD.",
                "\t\t\t * The caller's TLB flush range should cover this area.",
                "\t\t\t */"
            ],
            "added_lines": [
                "\tbool force_flush = false;",
                "\t\t\ttlb_flush_pmd_range(tlb, address & PUD_MASK, PUD_SIZE);",
                "\t\t\tforce_flush = true;",
                "",
                "\t/*",
                "\t * If we unshared PMDs, the TLB flush was not recorded in mmu_gather. We",
                "\t * could defer the flush until now, since by holding i_mmap_rwsem we",
                "\t * guaranteed that the last refernece would not be dropped. But we must",
                "\t * do the flushing before we return, as otherwise i_mmap_rwsem will be",
                "\t * dropped and the last reference to the shared PMDs page might be",
                "\t * dropped as well.",
                "\t *",
                "\t * In theory we could defer the freeing of the PMD pages as well, but",
                "\t * huge_pmd_unshare() relies on the exact page_count for the PMD page to",
                "\t * detect sharing, so we cannot defer the release of the page either.",
                "\t * Instead, do flush now.",
                "\t */",
                "\tif (force_flush)",
                "\t\ttlb_flush_mmu_tlbonly(tlb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4002",
        "func_name": "torvalds/linux/move_hugetlb_page_tables",
        "description": "A memory leak flaw in the Linux kernel's hugetlbfs memory usage was found in the way the user maps some regions of memory twice using shmget() which are aligned to PUD alignment with the fault of some of the memory pages. A local user could use this flaw to get unauthorized access to some data.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=13e4ad2ce8df6e058ef482a31fdd81c725b0f7ea",
        "commit_title": "We must flush the TLB before releasing i_mmap_rwsem to avoid the",
        "commit_text": "potential reuse of an unshared PMDs page.  This is not true in the case of move_hugetlb_page_tables().  The last reference on the page table can therefore be dropped before the TLB flush took place.  Prevent it by reordering the operations and flushing the TLB before releasing i_mmap_rwsem.  Cc: Mina Almasry <almasrymina@google.com> Cc: Andrew Morton <akpm@linux-foundation.org> ",
        "func_before": "int move_hugetlb_page_tables(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct *new_vma,\n\t\t\t     unsigned long old_addr, unsigned long new_addr,\n\t\t\t     unsigned long len)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tunsigned long sz = huge_page_size(h);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_end = old_addr + len;\n\tunsigned long old_addr_copy;\n\tpte_t *src_pte, *dst_pte;\n\tstruct mmu_notifier_range range;\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, mm, old_addr,\n\t\t\t\told_end);\n\tadjust_range_if_pmd_sharing_possible(vma, &range.start, &range.end);\n\tmmu_notifier_invalidate_range_start(&range);\n\t/* Prevent race with file truncation */\n\ti_mmap_lock_write(mapping);\n\tfor (; old_addr < old_end; old_addr += sz, new_addr += sz) {\n\t\tsrc_pte = huge_pte_offset(mm, old_addr, sz);\n\t\tif (!src_pte)\n\t\t\tcontinue;\n\t\tif (huge_pte_none(huge_ptep_get(src_pte)))\n\t\t\tcontinue;\n\n\t\t/* old_addr arg to huge_pmd_unshare() is a pointer and so the\n\t\t * arg may be modified. Pass a copy instead to preserve the\n\t\t * value in old_addr.\n\t\t */\n\t\told_addr_copy = old_addr;\n\n\t\tif (huge_pmd_unshare(mm, vma, &old_addr_copy, src_pte))\n\t\t\tcontinue;\n\n\t\tdst_pte = huge_pte_alloc(mm, new_vma, new_addr, sz);\n\t\tif (!dst_pte)\n\t\t\tbreak;\n\n\t\tmove_huge_pte(vma, old_addr, new_addr, src_pte);\n\t}\n\ti_mmap_unlock_write(mapping);\n\tflush_tlb_range(vma, old_end - len, old_end);\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn len + old_addr - old_end;\n}",
        "func": "int move_hugetlb_page_tables(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct *new_vma,\n\t\t\t     unsigned long old_addr, unsigned long new_addr,\n\t\t\t     unsigned long len)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tunsigned long sz = huge_page_size(h);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_end = old_addr + len;\n\tunsigned long old_addr_copy;\n\tpte_t *src_pte, *dst_pte;\n\tstruct mmu_notifier_range range;\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, mm, old_addr,\n\t\t\t\told_end);\n\tadjust_range_if_pmd_sharing_possible(vma, &range.start, &range.end);\n\tmmu_notifier_invalidate_range_start(&range);\n\t/* Prevent race with file truncation */\n\ti_mmap_lock_write(mapping);\n\tfor (; old_addr < old_end; old_addr += sz, new_addr += sz) {\n\t\tsrc_pte = huge_pte_offset(mm, old_addr, sz);\n\t\tif (!src_pte)\n\t\t\tcontinue;\n\t\tif (huge_pte_none(huge_ptep_get(src_pte)))\n\t\t\tcontinue;\n\n\t\t/* old_addr arg to huge_pmd_unshare() is a pointer and so the\n\t\t * arg may be modified. Pass a copy instead to preserve the\n\t\t * value in old_addr.\n\t\t */\n\t\told_addr_copy = old_addr;\n\n\t\tif (huge_pmd_unshare(mm, vma, &old_addr_copy, src_pte))\n\t\t\tcontinue;\n\n\t\tdst_pte = huge_pte_alloc(mm, new_vma, new_addr, sz);\n\t\tif (!dst_pte)\n\t\t\tbreak;\n\n\t\tmove_huge_pte(vma, old_addr, new_addr, src_pte);\n\t}\n\tflush_tlb_range(vma, old_end - len, old_end);\n\tmmu_notifier_invalidate_range_end(&range);\n\ti_mmap_unlock_write(mapping);\n\n\treturn len + old_addr - old_end;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,9 +40,9 @@\n \n \t\tmove_huge_pte(vma, old_addr, new_addr, src_pte);\n \t}\n-\ti_mmap_unlock_write(mapping);\n \tflush_tlb_range(vma, old_end - len, old_end);\n \tmmu_notifier_invalidate_range_end(&range);\n+\ti_mmap_unlock_write(mapping);\n \n \treturn len + old_addr - old_end;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\ti_mmap_unlock_write(mapping);"
            ],
            "added_lines": [
                "\ti_mmap_unlock_write(mapping);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3744",
        "func_name": "torvalds/linux/ccp_run_aes_gcm_cmd",
        "description": "A memory leak flaw was found in the Linux kernel in the ccp_run_aes_gcm_cmd() function in drivers/crypto/ccp/ccp-ops.c, which allows attackers to cause a denial of service (memory consumption). This vulnerability is similar with the older CVE-2019-18808.",
        "git_url": "https://github.com/torvalds/linux/commit/505d9dcb0f7ddf9d075e729523a33d38642ae680",
        "commit_title": "crypto: ccp - fix resource leaks in ccp_run_aes_gcm_cmd()",
        "commit_text": " There are three bugs in this code:  1) If we ccp_init_data() fails for &src then we need to free aad.    Use goto e_aad instead of goto e_ctx. 2) The label to free the &final_wa was named incorrectly as \"e_tag\" but    it should have been \"e_final_wa\".  One error path leaked &final_wa. 3) The &tag was leaked on one error path.  In that case, I added a free    before the goto because the resource was local to that block. ",
        "func_before": "static noinline_for_stack int\nccp_run_aes_gcm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\n{\n\tstruct ccp_aes_engine *aes = &cmd->u.aes;\n\tstruct ccp_dm_workarea key, ctx, final_wa, tag;\n\tstruct ccp_data src, dst;\n\tstruct ccp_data aad;\n\tstruct ccp_op op;\n\tunsigned int dm_offset;\n\tunsigned int authsize;\n\tunsigned int jobid;\n\tunsigned int ilen;\n\tbool in_place = true; /* Default value */\n\t__be64 *final;\n\tint ret;\n\n\tstruct scatterlist *p_inp, sg_inp[2];\n\tstruct scatterlist *p_tag, sg_tag[2];\n\tstruct scatterlist *p_outp, sg_outp[2];\n\tstruct scatterlist *p_aad;\n\n\tif (!aes->iv)\n\t\treturn -EINVAL;\n\n\tif (!((aes->key_len == AES_KEYSIZE_128) ||\n\t\t(aes->key_len == AES_KEYSIZE_192) ||\n\t\t(aes->key_len == AES_KEYSIZE_256)))\n\t\treturn -EINVAL;\n\n\tif (!aes->key) /* Gotta have a key SGL */\n\t\treturn -EINVAL;\n\n\t/* Zero defaults to 16 bytes, the maximum size */\n\tauthsize = aes->authsize ? aes->authsize : AES_BLOCK_SIZE;\n\tswitch (authsize) {\n\tcase 16:\n\tcase 15:\n\tcase 14:\n\tcase 13:\n\tcase 12:\n\tcase 8:\n\tcase 4:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* First, decompose the source buffer into AAD & PT,\n\t * and the destination buffer into AAD, CT & tag, or\n\t * the input into CT & tag.\n\t * It is expected that the input and output SGs will\n\t * be valid, even if the AAD and input lengths are 0.\n\t */\n\tp_aad = aes->src;\n\tp_inp = scatterwalk_ffwd(sg_inp, aes->src, aes->aad_len);\n\tp_outp = scatterwalk_ffwd(sg_outp, aes->dst, aes->aad_len);\n\tif (aes->action == CCP_AES_ACTION_ENCRYPT) {\n\t\tilen = aes->src_len;\n\t\tp_tag = scatterwalk_ffwd(sg_tag, p_outp, ilen);\n\t} else {\n\t\t/* Input length for decryption includes tag */\n\t\tilen = aes->src_len - authsize;\n\t\tp_tag = scatterwalk_ffwd(sg_tag, p_inp, ilen);\n\t}\n\n\tjobid = CCP_NEW_JOBID(cmd_q->ccp);\n\n\tmemset(&op, 0, sizeof(op));\n\top.cmd_q = cmd_q;\n\top.jobid = jobid;\n\top.sb_key = cmd_q->sb_key; /* Pre-allocated */\n\top.sb_ctx = cmd_q->sb_ctx; /* Pre-allocated */\n\top.init = 1;\n\top.u.aes.type = aes->type;\n\n\t/* Copy the key to the LSB */\n\tret = ccp_init_dm_workarea(&key, cmd_q,\n\t\t\t\t   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES,\n\t\t\t\t   DMA_TO_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tdm_offset = CCP_SB_BYTES - aes->key_len;\n\tret = ccp_set_dm_area(&key, dm_offset, aes->key, 0, aes->key_len);\n\tif (ret)\n\t\tgoto e_key;\n\tret = ccp_copy_to_sb(cmd_q, &key, op.jobid, op.sb_key,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_key;\n\t}\n\n\t/* Copy the context (IV) to the LSB.\n\t * There is an assumption here that the IV is 96 bits in length, plus\n\t * a nonce of 32 bits. If no IV is present, use a zeroed buffer.\n\t */\n\tret = ccp_init_dm_workarea(&ctx, cmd_q,\n\t\t\t\t   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\tif (ret)\n\t\tgoto e_key;\n\n\tdm_offset = CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES - aes->iv_len;\n\tret = ccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\n\tif (ret)\n\t\tgoto e_ctx;\n\n\tret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_ctx;\n\t}\n\n\top.init = 1;\n\tif (aes->aad_len > 0) {\n\t\t/* Step 1: Run a GHASH over the Additional Authenticated Data */\n\t\tret = ccp_init_data(&aad, cmd_q, p_aad, aes->aad_len,\n\t\t\t\t    AES_BLOCK_SIZE,\n\t\t\t\t    DMA_TO_DEVICE);\n\t\tif (ret)\n\t\t\tgoto e_ctx;\n\n\t\top.u.aes.mode = CCP_AES_MODE_GHASH;\n\t\top.u.aes.action = CCP_AES_GHASHAAD;\n\n\t\twhile (aad.sg_wa.bytes_left) {\n\t\t\tccp_prepare_data(&aad, NULL, &op, AES_BLOCK_SIZE, true);\n\n\t\t\tret = cmd_q->ccp->vdata->perform->aes(&op);\n\t\t\tif (ret) {\n\t\t\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\t\t\tgoto e_aad;\n\t\t\t}\n\n\t\t\tccp_process_data(&aad, NULL, &op);\n\t\t\top.init = 0;\n\t\t}\n\t}\n\n\top.u.aes.mode = CCP_AES_MODE_GCTR;\n\top.u.aes.action = aes->action;\n\n\tif (ilen > 0) {\n\t\t/* Step 2: Run a GCTR over the plaintext */\n\t\tin_place = (sg_virt(p_inp) == sg_virt(p_outp)) ? true : false;\n\n\t\tret = ccp_init_data(&src, cmd_q, p_inp, ilen,\n\t\t\t\t    AES_BLOCK_SIZE,\n\t\t\t\t    in_place ? DMA_BIDIRECTIONAL\n\t\t\t\t\t     : DMA_TO_DEVICE);\n\t\tif (ret)\n\t\t\tgoto e_ctx;\n\n\t\tif (in_place) {\n\t\t\tdst = src;\n\t\t} else {\n\t\t\tret = ccp_init_data(&dst, cmd_q, p_outp, ilen,\n\t\t\t\t\t    AES_BLOCK_SIZE, DMA_FROM_DEVICE);\n\t\t\tif (ret)\n\t\t\t\tgoto e_src;\n\t\t}\n\n\t\top.soc = 0;\n\t\top.eom = 0;\n\t\top.init = 1;\n\t\twhile (src.sg_wa.bytes_left) {\n\t\t\tccp_prepare_data(&src, &dst, &op, AES_BLOCK_SIZE, true);\n\t\t\tif (!src.sg_wa.bytes_left) {\n\t\t\t\tunsigned int nbytes = ilen % AES_BLOCK_SIZE;\n\n\t\t\t\tif (nbytes) {\n\t\t\t\t\top.eom = 1;\n\t\t\t\t\top.u.aes.size = (nbytes * 8) - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = cmd_q->ccp->vdata->perform->aes(&op);\n\t\t\tif (ret) {\n\t\t\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\t\t\tgoto e_dst;\n\t\t\t}\n\n\t\t\tccp_process_data(&src, &dst, &op);\n\t\t\top.init = 0;\n\t\t}\n\t}\n\n\t/* Step 3: Update the IV portion of the context with the original IV */\n\tret = ccp_copy_from_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t       CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_dst;\n\t}\n\n\tret = ccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\n\tif (ret)\n\t\tgoto e_dst;\n\n\tret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_dst;\n\t}\n\n\t/* Step 4: Concatenate the lengths of the AAD and source, and\n\t * hash that 16 byte buffer.\n\t */\n\tret = ccp_init_dm_workarea(&final_wa, cmd_q, AES_BLOCK_SIZE,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\tif (ret)\n\t\tgoto e_dst;\n\tfinal = (__be64 *)final_wa.address;\n\tfinal[0] = cpu_to_be64(aes->aad_len * 8);\n\tfinal[1] = cpu_to_be64(ilen * 8);\n\n\tmemset(&op, 0, sizeof(op));\n\top.cmd_q = cmd_q;\n\top.jobid = jobid;\n\top.sb_key = cmd_q->sb_key; /* Pre-allocated */\n\top.sb_ctx = cmd_q->sb_ctx; /* Pre-allocated */\n\top.init = 1;\n\top.u.aes.type = aes->type;\n\top.u.aes.mode = CCP_AES_MODE_GHASH;\n\top.u.aes.action = CCP_AES_GHASHFINAL;\n\top.src.type = CCP_MEMTYPE_SYSTEM;\n\top.src.u.dma.address = final_wa.dma.address;\n\top.src.u.dma.length = AES_BLOCK_SIZE;\n\top.dst.type = CCP_MEMTYPE_SYSTEM;\n\top.dst.u.dma.address = final_wa.dma.address;\n\top.dst.u.dma.length = AES_BLOCK_SIZE;\n\top.eom = 1;\n\top.u.aes.size = 0;\n\tret = cmd_q->ccp->vdata->perform->aes(&op);\n\tif (ret)\n\t\tgoto e_dst;\n\n\tif (aes->action == CCP_AES_ACTION_ENCRYPT) {\n\t\t/* Put the ciphered tag after the ciphertext. */\n\t\tccp_get_dm_area(&final_wa, 0, p_tag, 0, authsize);\n\t} else {\n\t\t/* Does this ciphered tag match the input? */\n\t\tret = ccp_init_dm_workarea(&tag, cmd_q, authsize,\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t\tif (ret)\n\t\t\tgoto e_tag;\n\t\tret = ccp_set_dm_area(&tag, 0, p_tag, 0, authsize);\n\t\tif (ret)\n\t\t\tgoto e_tag;\n\n\t\tret = crypto_memneq(tag.address, final_wa.address,\n\t\t\t\t    authsize) ? -EBADMSG : 0;\n\t\tccp_dm_free(&tag);\n\t}\n\ne_tag:\n\tccp_dm_free(&final_wa);\n\ne_dst:\n\tif (ilen > 0 && !in_place)\n\t\tccp_free_data(&dst, cmd_q);\n\ne_src:\n\tif (ilen > 0)\n\t\tccp_free_data(&src, cmd_q);\n\ne_aad:\n\tif (aes->aad_len)\n\t\tccp_free_data(&aad, cmd_q);\n\ne_ctx:\n\tccp_dm_free(&ctx);\n\ne_key:\n\tccp_dm_free(&key);\n\n\treturn ret;\n}",
        "func": "static noinline_for_stack int\nccp_run_aes_gcm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\n{\n\tstruct ccp_aes_engine *aes = &cmd->u.aes;\n\tstruct ccp_dm_workarea key, ctx, final_wa, tag;\n\tstruct ccp_data src, dst;\n\tstruct ccp_data aad;\n\tstruct ccp_op op;\n\tunsigned int dm_offset;\n\tunsigned int authsize;\n\tunsigned int jobid;\n\tunsigned int ilen;\n\tbool in_place = true; /* Default value */\n\t__be64 *final;\n\tint ret;\n\n\tstruct scatterlist *p_inp, sg_inp[2];\n\tstruct scatterlist *p_tag, sg_tag[2];\n\tstruct scatterlist *p_outp, sg_outp[2];\n\tstruct scatterlist *p_aad;\n\n\tif (!aes->iv)\n\t\treturn -EINVAL;\n\n\tif (!((aes->key_len == AES_KEYSIZE_128) ||\n\t\t(aes->key_len == AES_KEYSIZE_192) ||\n\t\t(aes->key_len == AES_KEYSIZE_256)))\n\t\treturn -EINVAL;\n\n\tif (!aes->key) /* Gotta have a key SGL */\n\t\treturn -EINVAL;\n\n\t/* Zero defaults to 16 bytes, the maximum size */\n\tauthsize = aes->authsize ? aes->authsize : AES_BLOCK_SIZE;\n\tswitch (authsize) {\n\tcase 16:\n\tcase 15:\n\tcase 14:\n\tcase 13:\n\tcase 12:\n\tcase 8:\n\tcase 4:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* First, decompose the source buffer into AAD & PT,\n\t * and the destination buffer into AAD, CT & tag, or\n\t * the input into CT & tag.\n\t * It is expected that the input and output SGs will\n\t * be valid, even if the AAD and input lengths are 0.\n\t */\n\tp_aad = aes->src;\n\tp_inp = scatterwalk_ffwd(sg_inp, aes->src, aes->aad_len);\n\tp_outp = scatterwalk_ffwd(sg_outp, aes->dst, aes->aad_len);\n\tif (aes->action == CCP_AES_ACTION_ENCRYPT) {\n\t\tilen = aes->src_len;\n\t\tp_tag = scatterwalk_ffwd(sg_tag, p_outp, ilen);\n\t} else {\n\t\t/* Input length for decryption includes tag */\n\t\tilen = aes->src_len - authsize;\n\t\tp_tag = scatterwalk_ffwd(sg_tag, p_inp, ilen);\n\t}\n\n\tjobid = CCP_NEW_JOBID(cmd_q->ccp);\n\n\tmemset(&op, 0, sizeof(op));\n\top.cmd_q = cmd_q;\n\top.jobid = jobid;\n\top.sb_key = cmd_q->sb_key; /* Pre-allocated */\n\top.sb_ctx = cmd_q->sb_ctx; /* Pre-allocated */\n\top.init = 1;\n\top.u.aes.type = aes->type;\n\n\t/* Copy the key to the LSB */\n\tret = ccp_init_dm_workarea(&key, cmd_q,\n\t\t\t\t   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES,\n\t\t\t\t   DMA_TO_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tdm_offset = CCP_SB_BYTES - aes->key_len;\n\tret = ccp_set_dm_area(&key, dm_offset, aes->key, 0, aes->key_len);\n\tif (ret)\n\t\tgoto e_key;\n\tret = ccp_copy_to_sb(cmd_q, &key, op.jobid, op.sb_key,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_key;\n\t}\n\n\t/* Copy the context (IV) to the LSB.\n\t * There is an assumption here that the IV is 96 bits in length, plus\n\t * a nonce of 32 bits. If no IV is present, use a zeroed buffer.\n\t */\n\tret = ccp_init_dm_workarea(&ctx, cmd_q,\n\t\t\t\t   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\tif (ret)\n\t\tgoto e_key;\n\n\tdm_offset = CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES - aes->iv_len;\n\tret = ccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\n\tif (ret)\n\t\tgoto e_ctx;\n\n\tret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_ctx;\n\t}\n\n\top.init = 1;\n\tif (aes->aad_len > 0) {\n\t\t/* Step 1: Run a GHASH over the Additional Authenticated Data */\n\t\tret = ccp_init_data(&aad, cmd_q, p_aad, aes->aad_len,\n\t\t\t\t    AES_BLOCK_SIZE,\n\t\t\t\t    DMA_TO_DEVICE);\n\t\tif (ret)\n\t\t\tgoto e_ctx;\n\n\t\top.u.aes.mode = CCP_AES_MODE_GHASH;\n\t\top.u.aes.action = CCP_AES_GHASHAAD;\n\n\t\twhile (aad.sg_wa.bytes_left) {\n\t\t\tccp_prepare_data(&aad, NULL, &op, AES_BLOCK_SIZE, true);\n\n\t\t\tret = cmd_q->ccp->vdata->perform->aes(&op);\n\t\t\tif (ret) {\n\t\t\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\t\t\tgoto e_aad;\n\t\t\t}\n\n\t\t\tccp_process_data(&aad, NULL, &op);\n\t\t\top.init = 0;\n\t\t}\n\t}\n\n\top.u.aes.mode = CCP_AES_MODE_GCTR;\n\top.u.aes.action = aes->action;\n\n\tif (ilen > 0) {\n\t\t/* Step 2: Run a GCTR over the plaintext */\n\t\tin_place = (sg_virt(p_inp) == sg_virt(p_outp)) ? true : false;\n\n\t\tret = ccp_init_data(&src, cmd_q, p_inp, ilen,\n\t\t\t\t    AES_BLOCK_SIZE,\n\t\t\t\t    in_place ? DMA_BIDIRECTIONAL\n\t\t\t\t\t     : DMA_TO_DEVICE);\n\t\tif (ret)\n\t\t\tgoto e_aad;\n\n\t\tif (in_place) {\n\t\t\tdst = src;\n\t\t} else {\n\t\t\tret = ccp_init_data(&dst, cmd_q, p_outp, ilen,\n\t\t\t\t\t    AES_BLOCK_SIZE, DMA_FROM_DEVICE);\n\t\t\tif (ret)\n\t\t\t\tgoto e_src;\n\t\t}\n\n\t\top.soc = 0;\n\t\top.eom = 0;\n\t\top.init = 1;\n\t\twhile (src.sg_wa.bytes_left) {\n\t\t\tccp_prepare_data(&src, &dst, &op, AES_BLOCK_SIZE, true);\n\t\t\tif (!src.sg_wa.bytes_left) {\n\t\t\t\tunsigned int nbytes = ilen % AES_BLOCK_SIZE;\n\n\t\t\t\tif (nbytes) {\n\t\t\t\t\top.eom = 1;\n\t\t\t\t\top.u.aes.size = (nbytes * 8) - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = cmd_q->ccp->vdata->perform->aes(&op);\n\t\t\tif (ret) {\n\t\t\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\t\t\tgoto e_dst;\n\t\t\t}\n\n\t\t\tccp_process_data(&src, &dst, &op);\n\t\t\top.init = 0;\n\t\t}\n\t}\n\n\t/* Step 3: Update the IV portion of the context with the original IV */\n\tret = ccp_copy_from_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t       CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_dst;\n\t}\n\n\tret = ccp_set_dm_area(&ctx, dm_offset, aes->iv, 0, aes->iv_len);\n\tif (ret)\n\t\tgoto e_dst;\n\n\tret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_dst;\n\t}\n\n\t/* Step 4: Concatenate the lengths of the AAD and source, and\n\t * hash that 16 byte buffer.\n\t */\n\tret = ccp_init_dm_workarea(&final_wa, cmd_q, AES_BLOCK_SIZE,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\tif (ret)\n\t\tgoto e_dst;\n\tfinal = (__be64 *)final_wa.address;\n\tfinal[0] = cpu_to_be64(aes->aad_len * 8);\n\tfinal[1] = cpu_to_be64(ilen * 8);\n\n\tmemset(&op, 0, sizeof(op));\n\top.cmd_q = cmd_q;\n\top.jobid = jobid;\n\top.sb_key = cmd_q->sb_key; /* Pre-allocated */\n\top.sb_ctx = cmd_q->sb_ctx; /* Pre-allocated */\n\top.init = 1;\n\top.u.aes.type = aes->type;\n\top.u.aes.mode = CCP_AES_MODE_GHASH;\n\top.u.aes.action = CCP_AES_GHASHFINAL;\n\top.src.type = CCP_MEMTYPE_SYSTEM;\n\top.src.u.dma.address = final_wa.dma.address;\n\top.src.u.dma.length = AES_BLOCK_SIZE;\n\top.dst.type = CCP_MEMTYPE_SYSTEM;\n\top.dst.u.dma.address = final_wa.dma.address;\n\top.dst.u.dma.length = AES_BLOCK_SIZE;\n\top.eom = 1;\n\top.u.aes.size = 0;\n\tret = cmd_q->ccp->vdata->perform->aes(&op);\n\tif (ret)\n\t\tgoto e_final_wa;\n\n\tif (aes->action == CCP_AES_ACTION_ENCRYPT) {\n\t\t/* Put the ciphered tag after the ciphertext. */\n\t\tccp_get_dm_area(&final_wa, 0, p_tag, 0, authsize);\n\t} else {\n\t\t/* Does this ciphered tag match the input? */\n\t\tret = ccp_init_dm_workarea(&tag, cmd_q, authsize,\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\t\tif (ret)\n\t\t\tgoto e_final_wa;\n\t\tret = ccp_set_dm_area(&tag, 0, p_tag, 0, authsize);\n\t\tif (ret) {\n\t\t\tccp_dm_free(&tag);\n\t\t\tgoto e_final_wa;\n\t\t}\n\n\t\tret = crypto_memneq(tag.address, final_wa.address,\n\t\t\t\t    authsize) ? -EBADMSG : 0;\n\t\tccp_dm_free(&tag);\n\t}\n\ne_final_wa:\n\tccp_dm_free(&final_wa);\n\ne_dst:\n\tif (ilen > 0 && !in_place)\n\t\tccp_free_data(&dst, cmd_q);\n\ne_src:\n\tif (ilen > 0)\n\t\tccp_free_data(&src, cmd_q);\n\ne_aad:\n\tif (aes->aad_len)\n\t\tccp_free_data(&aad, cmd_q);\n\ne_ctx:\n\tccp_dm_free(&ctx);\n\ne_key:\n\tccp_dm_free(&key);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -151,7 +151,7 @@\n \t\t\t\t    in_place ? DMA_BIDIRECTIONAL\n \t\t\t\t\t     : DMA_TO_DEVICE);\n \t\tif (ret)\n-\t\t\tgoto e_ctx;\n+\t\t\tgoto e_aad;\n \n \t\tif (in_place) {\n \t\t\tdst = src;\n@@ -236,7 +236,7 @@\n \top.u.aes.size = 0;\n \tret = cmd_q->ccp->vdata->perform->aes(&op);\n \tif (ret)\n-\t\tgoto e_dst;\n+\t\tgoto e_final_wa;\n \n \tif (aes->action == CCP_AES_ACTION_ENCRYPT) {\n \t\t/* Put the ciphered tag after the ciphertext. */\n@@ -246,17 +246,19 @@\n \t\tret = ccp_init_dm_workarea(&tag, cmd_q, authsize,\n \t\t\t\t\t   DMA_BIDIRECTIONAL);\n \t\tif (ret)\n-\t\t\tgoto e_tag;\n+\t\t\tgoto e_final_wa;\n \t\tret = ccp_set_dm_area(&tag, 0, p_tag, 0, authsize);\n-\t\tif (ret)\n-\t\t\tgoto e_tag;\n+\t\tif (ret) {\n+\t\t\tccp_dm_free(&tag);\n+\t\t\tgoto e_final_wa;\n+\t\t}\n \n \t\tret = crypto_memneq(tag.address, final_wa.address,\n \t\t\t\t    authsize) ? -EBADMSG : 0;\n \t\tccp_dm_free(&tag);\n \t}\n \n-e_tag:\n+e_final_wa:\n \tccp_dm_free(&final_wa);\n \n e_dst:",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tgoto e_ctx;",
                "\t\tgoto e_dst;",
                "\t\t\tgoto e_tag;",
                "\t\tif (ret)",
                "\t\t\tgoto e_tag;",
                "e_tag:"
            ],
            "added_lines": [
                "\t\t\tgoto e_aad;",
                "\t\tgoto e_final_wa;",
                "\t\t\tgoto e_final_wa;",
                "\t\tif (ret) {",
                "\t\t\tccp_dm_free(&tag);",
                "\t\t\tgoto e_final_wa;",
                "\t\t}",
                "e_final_wa:"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26878",
        "func_name": "torvalds/linux/virtbt_rx_handle",
        "description": "drivers/bluetooth/virtio_bt.c in the Linux kernel before 5.16.3 has a memory leak (socket buffers have memory allocated but not freed).",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=1d0688421449718c6c5f46e458a378c9b530ba18",
        "commit_title": "On the reception of packets with an invalid packet type, the memory of",
        "commit_text": "the allocated socket buffers is never freed. Add a default case that frees these to avoid a memory leak.  ",
        "func_before": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\t}\n}",
        "func": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\tdefault:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,5 +13,8 @@\n \t\thci_skb_pkt_type(skb) = pkt_type;\n \t\thci_recv_frame(vbt->hdev, skb);\n \t\tbreak;\n+\tdefault:\n+\t\tkfree_skb(skb);\n+\t\tbreak;\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tdefault:",
                "\t\tkfree_skb(skb);",
                "\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0742",
        "func_name": "torvalds/linux/igmp6_event_report",
        "description": "Memory leak in icmp6 implementation in Linux Kernel 5.13+ allows a remote attacker to DoS a host by making it go out-of-memory via icmp6 packets of type 130 or 131. We recommend upgrading past commit 2d3916f3189172d5c69d33065c3c21119fe539fc.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=2d3916f3189172d5c69d33065c3c21119fe539fc",
        "commit_title": "While investigating on why a synchronize_net() has been added recently",
        "commit_text": "in ipv6_mc_down(), I found that igmp6_event_query() and igmp6_event_report() might drop skbs in some cases.  Discussion about removing synchronize_net() from ipv6_mc_down() will happen in a different thread.  Cc: Taehee Yoo <ap420073@gmail.com> Cc: Cong Wang <xiyou.wangcong@gmail.com> Cc: David Ahern <dsahern@kernel.org> Link: https://lore.kernel.org/r/20220303173728.937869-1-eric.dumazet@gmail.com ",
        "func_before": "int igmp6_event_report(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev)\n\t\treturn -EINVAL;\n\n\tif (idev->dead) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_bh(&idev->mc_report_lock);\n\tif (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_report_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_report_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t}\n\tspin_unlock_bh(&idev->mc_report_lock);\n\n\treturn 0;\n}",
        "func": "void igmp6_event_report(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev || idev->dead)\n\t\tgoto out;\n\n\tspin_lock_bh(&idev->mc_report_lock);\n\tif (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_report_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_report_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t\tskb = NULL;\n\t}\n\tspin_unlock_bh(&idev->mc_report_lock);\nout:\n\tkfree_skb(skb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,22 +1,18 @@\n-int igmp6_event_report(struct sk_buff *skb)\n+void igmp6_event_report(struct sk_buff *skb)\n {\n \tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n \n-\tif (!idev)\n-\t\treturn -EINVAL;\n-\n-\tif (idev->dead) {\n-\t\tkfree_skb(skb);\n-\t\treturn -ENODEV;\n-\t}\n+\tif (!idev || idev->dead)\n+\t\tgoto out;\n \n \tspin_lock_bh(&idev->mc_report_lock);\n \tif (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS) {\n \t\t__skb_queue_tail(&idev->mc_report_queue, skb);\n \t\tif (!mod_delayed_work(mld_wq, &idev->mc_report_work, 0))\n \t\t\tin6_dev_hold(idev);\n+\t\tskb = NULL;\n \t}\n \tspin_unlock_bh(&idev->mc_report_lock);\n-\n-\treturn 0;\n+out:\n+\tkfree_skb(skb);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "int igmp6_event_report(struct sk_buff *skb)",
                "\tif (!idev)",
                "\t\treturn -EINVAL;",
                "",
                "\tif (idev->dead) {",
                "\t\tkfree_skb(skb);",
                "\t\treturn -ENODEV;",
                "\t}",
                "",
                "\treturn 0;"
            ],
            "added_lines": [
                "void igmp6_event_report(struct sk_buff *skb)",
                "\tif (!idev || idev->dead)",
                "\t\tgoto out;",
                "\t\tskb = NULL;",
                "out:",
                "\tkfree_skb(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0742",
        "func_name": "torvalds/linux/igmp6_event_query",
        "description": "Memory leak in icmp6 implementation in Linux Kernel 5.13+ allows a remote attacker to DoS a host by making it go out-of-memory via icmp6 packets of type 130 or 131. We recommend upgrading past commit 2d3916f3189172d5c69d33065c3c21119fe539fc.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=2d3916f3189172d5c69d33065c3c21119fe539fc",
        "commit_title": "While investigating on why a synchronize_net() has been added recently",
        "commit_text": "in ipv6_mc_down(), I found that igmp6_event_query() and igmp6_event_report() might drop skbs in some cases.  Discussion about removing synchronize_net() from ipv6_mc_down() will happen in a different thread.  Cc: Taehee Yoo <ap420073@gmail.com> Cc: Cong Wang <xiyou.wangcong@gmail.com> Cc: David Ahern <dsahern@kernel.org> Link: https://lore.kernel.org/r/20220303173728.937869-1-eric.dumazet@gmail.com ",
        "func_before": "int igmp6_event_query(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev)\n\t\treturn -EINVAL;\n\n\tif (idev->dead) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_bh(&idev->mc_query_lock);\n\tif (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_query_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_query_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t}\n\tspin_unlock_bh(&idev->mc_query_lock);\n\n\treturn 0;\n}",
        "func": "void igmp6_event_query(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev || idev->dead)\n\t\tgoto out;\n\n\tspin_lock_bh(&idev->mc_query_lock);\n\tif (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_query_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_query_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t\tskb = NULL;\n\t}\n\tspin_unlock_bh(&idev->mc_query_lock);\nout:\n\tkfree_skb(skb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,22 +1,18 @@\n-int igmp6_event_query(struct sk_buff *skb)\n+void igmp6_event_query(struct sk_buff *skb)\n {\n \tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n \n-\tif (!idev)\n-\t\treturn -EINVAL;\n-\n-\tif (idev->dead) {\n-\t\tkfree_skb(skb);\n-\t\treturn -ENODEV;\n-\t}\n+\tif (!idev || idev->dead)\n+\t\tgoto out;\n \n \tspin_lock_bh(&idev->mc_query_lock);\n \tif (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS) {\n \t\t__skb_queue_tail(&idev->mc_query_queue, skb);\n \t\tif (!mod_delayed_work(mld_wq, &idev->mc_query_work, 0))\n \t\t\tin6_dev_hold(idev);\n+\t\tskb = NULL;\n \t}\n \tspin_unlock_bh(&idev->mc_query_lock);\n-\n-\treturn 0;\n+out:\n+\tkfree_skb(skb);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "int igmp6_event_query(struct sk_buff *skb)",
                "\tif (!idev)",
                "\t\treturn -EINVAL;",
                "",
                "\tif (idev->dead) {",
                "\t\tkfree_skb(skb);",
                "\t\treturn -ENODEV;",
                "\t}",
                "",
                "\treturn 0;"
            ],
            "added_lines": [
                "void igmp6_event_query(struct sk_buff *skb)",
                "\tif (!idev || idev->dead)",
                "\t\tgoto out;",
                "\t\tskb = NULL;",
                "out:",
                "\tkfree_skb(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0854",
        "func_name": "torvalds/linux/swiotlb_tbl_map_single",
        "description": "A memory leak flaw was found in the Linux kernels DMA subsystem, in the way a user calls DMA_FROM_DEVICE. This flaw allows a local user to read random memory from the kernel space.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/kernel/dma/swiotlb.c?h=v5.17-rc8&h=aa6f8dcbab473f3a3c7454b74caa46d36cdc5d13",
        "commit_title": "Unfortunately, we ended up merging an old version of the patch \"fix info",
        "commit_text": "leak with DMA_FROM_DEVICE\" instead of merging the latest one. Christoph (the swiotlb maintainer), he asked me to create an incremental fix (after I have pointed this out the mix up, and asked him for guidance). So here we go.  The main differences between what we got and what was agreed are: * swiotlb_sync_single_for_device is also required to do an extra bounce * We decided not to introduce DMA_ATTR_OVERWRITE until we have exploiters * The implantation of DMA_ATTR_OVERWRITE is flawed: DMA_ATTR_OVERWRITE   must take precedence over DMA_ATTR_SKIP_CPU_SYNC  Thus this patch removes DMA_ATTR_OVERWRITE, and makes swiotlb_sync_single_for_device() bounce unconditionally (that is, also when dir == DMA_TO_DEVICE) in order do avoid synchronising back stale data from the swiotlb buffer.  Let me note, that if the size used with dma_sync_* API is less than the size used with dma_[un]map_*, under certain circumstances we may still end up with swiotlb not being transparent. In that sense, this is no perfect fix either.  To get this bullet proof, we would have to bounce the entire mapping/bounce buffer. For that we would have to figure out the starting address, and the size of the mapping in swiotlb_sync_single_for_device(). While this does seem possible, there seems to be no firm consensus on how things are supposed to work.  Cc: stable@vger.kernel.org ",
        "func_before": "phys_addr_t swiotlb_tbl_map_single(struct device *dev, phys_addr_t orig_addr,\n\t\tsize_t mapping_size, size_t alloc_size,\n\t\tunsigned int alloc_align_mask, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned int i;\n\tint index;\n\tphys_addr_t tlb_addr;\n\n\tif (!mem)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (cc_platform_has(CC_ATTR_MEM_ENCRYPT))\n\t\tpr_warn_once(\"Memory encryption is active and system is using DMA bounce buffers\\n\");\n\n\tif (mapping_size > alloc_size) {\n\t\tdev_warn_once(dev, \"Invalid sizes (mapping: %zd bytes, alloc: %zd bytes)\",\n\t\t\t      mapping_size, alloc_size);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\tindex = swiotlb_find_slots(dev, orig_addr,\n\t\t\t\t   alloc_size + offset, alloc_align_mask);\n\tif (index == -1) {\n\t\tif (!(attrs & DMA_ATTR_NO_WARN))\n\t\t\tdev_warn_ratelimited(dev,\n\t\"swiotlb buffer is full (sz: %zd bytes), total %lu (slots), used %lu (slots)\\n\",\n\t\t\t\t alloc_size, mem->nslabs, mem->used);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nr_slots(alloc_size + offset); i++)\n\t\tmem->slots[index + i].orig_addr = slot_addr(orig_addr, i);\n\ttlb_addr = slot_addr(mem->start, index) + offset;\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (!(attrs & DMA_ATTR_OVERWRITE) || dir == DMA_TO_DEVICE ||\n\t    dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);\n\treturn tlb_addr;\n}",
        "func": "phys_addr_t swiotlb_tbl_map_single(struct device *dev, phys_addr_t orig_addr,\n\t\tsize_t mapping_size, size_t alloc_size,\n\t\tunsigned int alloc_align_mask, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n\tstruct io_tlb_mem *mem = dev->dma_io_tlb_mem;\n\tunsigned int offset = swiotlb_align_offset(dev, orig_addr);\n\tunsigned int i;\n\tint index;\n\tphys_addr_t tlb_addr;\n\n\tif (!mem)\n\t\tpanic(\"Can not allocate SWIOTLB buffer earlier and can't now provide you with the DMA bounce buffer\");\n\n\tif (cc_platform_has(CC_ATTR_MEM_ENCRYPT))\n\t\tpr_warn_once(\"Memory encryption is active and system is using DMA bounce buffers\\n\");\n\n\tif (mapping_size > alloc_size) {\n\t\tdev_warn_once(dev, \"Invalid sizes (mapping: %zd bytes, alloc: %zd bytes)\",\n\t\t\t      mapping_size, alloc_size);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\tindex = swiotlb_find_slots(dev, orig_addr,\n\t\t\t\t   alloc_size + offset, alloc_align_mask);\n\tif (index == -1) {\n\t\tif (!(attrs & DMA_ATTR_NO_WARN))\n\t\t\tdev_warn_ratelimited(dev,\n\t\"swiotlb buffer is full (sz: %zd bytes), total %lu (slots), used %lu (slots)\\n\",\n\t\t\t\t alloc_size, mem->nslabs, mem->used);\n\t\treturn (phys_addr_t)DMA_MAPPING_ERROR;\n\t}\n\n\t/*\n\t * Save away the mapping from the original address to the DMA address.\n\t * This is needed when we sync the memory.  Then we sync the buffer if\n\t * needed.\n\t */\n\tfor (i = 0; i < nr_slots(alloc_size + offset); i++)\n\t\tmem->slots[index + i].orig_addr = slot_addr(orig_addr, i);\n\ttlb_addr = slot_addr(mem->start, index) + offset;\n\t/*\n\t * When dir == DMA_FROM_DEVICE we could omit the copy from the orig\n\t * to the tlb buffer, if we knew for sure the device will\n\t * overwirte the entire current content. But we don't. Thus\n\t * unconditional bounce may prevent leaking swiotlb content (i.e.\n\t * kernel memory) to user-space.\n\t */\n\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);\n\treturn tlb_addr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,9 +39,13 @@\n \tfor (i = 0; i < nr_slots(alloc_size + offset); i++)\n \t\tmem->slots[index + i].orig_addr = slot_addr(orig_addr, i);\n \ttlb_addr = slot_addr(mem->start, index) + offset;\n-\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n-\t    (!(attrs & DMA_ATTR_OVERWRITE) || dir == DMA_TO_DEVICE ||\n-\t    dir == DMA_BIDIRECTIONAL))\n-\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);\n+\t/*\n+\t * When dir == DMA_FROM_DEVICE we could omit the copy from the orig\n+\t * to the tlb buffer, if we knew for sure the device will\n+\t * overwirte the entire current content. But we don't. Thus\n+\t * unconditional bounce may prevent leaking swiotlb content (i.e.\n+\t * kernel memory) to user-space.\n+\t */\n+\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);\n \treturn tlb_addr;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&",
                "\t    (!(attrs & DMA_ATTR_OVERWRITE) || dir == DMA_TO_DEVICE ||",
                "\t    dir == DMA_BIDIRECTIONAL))",
                "\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);"
            ],
            "added_lines": [
                "\t/*",
                "\t * When dir == DMA_FROM_DEVICE we could omit the copy from the orig",
                "\t * to the tlb buffer, if we knew for sure the device will",
                "\t * overwirte the entire current content. But we don't. Thus",
                "\t * unconditional bounce may prevent leaking swiotlb content (i.e.",
                "\t * kernel memory) to user-space.",
                "\t */",
                "\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_TO_DEVICE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0854",
        "func_name": "torvalds/linux/swiotlb_sync_single_for_device",
        "description": "A memory leak flaw was found in the Linux kernels DMA subsystem, in the way a user calls DMA_FROM_DEVICE. This flaw allows a local user to read random memory from the kernel space.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/kernel/dma/swiotlb.c?h=v5.17-rc8&h=aa6f8dcbab473f3a3c7454b74caa46d36cdc5d13",
        "commit_title": "Unfortunately, we ended up merging an old version of the patch \"fix info",
        "commit_text": "leak with DMA_FROM_DEVICE\" instead of merging the latest one. Christoph (the swiotlb maintainer), he asked me to create an incremental fix (after I have pointed this out the mix up, and asked him for guidance). So here we go.  The main differences between what we got and what was agreed are: * swiotlb_sync_single_for_device is also required to do an extra bounce * We decided not to introduce DMA_ATTR_OVERWRITE until we have exploiters * The implantation of DMA_ATTR_OVERWRITE is flawed: DMA_ATTR_OVERWRITE   must take precedence over DMA_ATTR_SKIP_CPU_SYNC  Thus this patch removes DMA_ATTR_OVERWRITE, and makes swiotlb_sync_single_for_device() bounce unconditionally (that is, also when dir == DMA_TO_DEVICE) in order do avoid synchronising back stale data from the swiotlb buffer.  Let me note, that if the size used with dma_sync_* API is less than the size used with dma_[un]map_*, under certain circumstances we may still end up with swiotlb not being transparent. In that sense, this is no perfect fix either.  To get this bullet proof, we would have to bounce the entire mapping/bounce buffer. For that we would have to figure out the starting address, and the size of the mapping in swiotlb_sync_single_for_device(). While this does seem possible, there seems to be no firm consensus on how things are supposed to work.  Cc: stable@vger.kernel.org ",
        "func_before": "void swiotlb_sync_single_for_device(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n}",
        "func": "void swiotlb_sync_single_for_device(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\t/*\n\t * Unconditional bounce is necessary to avoid corruption on\n\t * sync_*_for_cpu or dma_ummap_* when the device didn't overwrite\n\t * the whole lengt of the bounce buffer.\n\t */\n\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n\tBUG_ON(!valid_dma_direction(dir));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,11 @@\n void swiotlb_sync_single_for_device(struct device *dev, phys_addr_t tlb_addr,\n \t\tsize_t size, enum dma_data_direction dir)\n {\n-\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)\n-\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n-\telse\n-\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n+\t/*\n+\t * Unconditional bounce is necessary to avoid corruption on\n+\t * sync_*_for_cpu or dma_ummap_* when the device didn't overwrite\n+\t * the whole lengt of the bounce buffer.\n+\t */\n+\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n+\tBUG_ON(!valid_dma_direction(dir));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)",
                "\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);",
                "\telse",
                "\t\tBUG_ON(dir != DMA_FROM_DEVICE);"
            ],
            "added_lines": [
                "\t/*",
                "\t * Unconditional bounce is necessary to avoid corruption on",
                "\t * sync_*_for_cpu or dma_ummap_* when the device didn't overwrite",
                "\t * the whole lengt of the bounce buffer.",
                "\t */",
                "\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);",
                "\tBUG_ON(!valid_dma_direction(dir));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-27950",
        "func_name": "torvalds/linux/elo_probe",
        "description": "In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak exists for a certain hid_parse error condition.",
        "git_url": "https://github.com/torvalds/linux/commit/817b8b9c5396d2b2d92311b46719aad5d3339dbe",
        "commit_title": "HID: elo: fix memory leak in elo_probe",
        "commit_text": " When hid_parse() in elo_probe() fails, it forgets to call usb_put_dev to decrease the refcount.  Fix this by adding usb_put_dev() in the error handling code of elo_probe(). ",
        "func_before": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tkfree(priv);\n\treturn ret;\n}",
        "func": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,6 +36,7 @@\n \n \treturn 0;\n err_free:\n+\tusb_put_dev(udev);\n \tkfree(priv);\n \treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tusb_put_dev(udev);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1515",
        "func_name": "tbeu/matio/ReadNextFunctionHandle",
        "description": "A memory leak was discovered in matio 1.5.21 and earlier in Mat_VarReadNextInfo5() in mat5.c via a crafted file. This issue can potentially result in DoS.",
        "git_url": "https://github.com/tbeu/matio/commit/fda62e1a0668b1a2758a23d1290b6ea009f59302",
        "commit_title": "Fix memory leak",
        "commit_text": " As reported by https://github.com/tbeu/matio/issues/186",
        "func_before": "static size_t\nReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = Mat_MulDims(matvar, &nelems);\n    matvar->data_size = sizeof(matvar_t *);\n    err |= Mul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err )\n        return 0;\n\n    matvar->data = malloc(matvar->nbytes);\n    if ( matvar->data != NULL ) {\n        size_t i;\n        matvar_t **functions = (matvar_t **)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            functions[i] = Mat_VarReadNextInfo(mat);\n            err = NULL == functions[i];\n            if ( err )\n                break;\n        }\n        if ( err ) {\n            free(matvar->data);\n            matvar->data = NULL;\n            matvar->data_size = 0;\n            matvar->nbytes = 0;\n        }\n    } else {\n        matvar->data_size = 0;\n        matvar->nbytes = 0;\n    }\n\n    return 0;\n}",
        "func": "static size_t\nReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = Mat_MulDims(matvar, &nelems);\n    matvar->data_size = sizeof(matvar_t *);\n    err |= Mul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err )\n        return 0;\n\n    matvar->data = malloc(matvar->nbytes);\n    if ( matvar->data != NULL ) {\n        size_t i;\n        matvar_t **functions = (matvar_t **)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            functions[i] = Mat_VarReadNextInfo(mat);\n            err = NULL == functions[i];\n            if ( err )\n                break;\n        }\n        if ( err ) {\n            size_t j;\n            for ( j = 0; j < i; j++ ) {\n                free(functions[i]);\n            }\n            free(matvar->data);\n            matvar->data = NULL;\n            matvar->data_size = 0;\n            matvar->nbytes = 0;\n        }\n    } else {\n        matvar->data_size = 0;\n        matvar->nbytes = 0;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,10 @@\n                 break;\n         }\n         if ( err ) {\n+            size_t j;\n+            for ( j = 0; j < i; j++ ) {\n+                free(functions[i]);\n+            }\n             free(matvar->data);\n             matvar->data = NULL;\n             matvar->data_size = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            size_t j;",
                "            for ( j = 0; j < i; j++ ) {",
                "                free(functions[i]);",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41959",
        "func_name": "jerryscript-project/jerryscript/ecma_regexp_match_helper",
        "description": "JerryScript Git version 14ff5bf does not sufficiently track and release allocated memory via jerry-core/ecma/operations/ecma-regexp-object.c after RegExp, which causes a memory leak.",
        "git_url": "https://github.com/jerryscript-project/jerryscript/commit/baf01585b4a818b087a1ec77f99fe7ea6c653a10",
        "commit_title": "Fix leaking lastIndex values in RegExp built-ins",
        "commit_text": " Fixes #4781. This is a followup fix after #4166.  JerryScript-DCO-1.0-Signed-off-by: Csaba Osztrogonc csaba.osztrogonac@h-lab.eu",
        "func_before": "ecma_value_t\necma_regexp_match_helper (ecma_value_t this_arg, /**< this argument */\n                          ecma_value_t string_arg) /**< source string */\n{\n  if (!ecma_is_value_object (this_arg))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument 'this' is not an object\"));\n  }\n\n  ecma_string_t *str_p = ecma_op_to_string (string_arg);\n\n  if (JERRY_UNLIKELY (str_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);\n\n  ecma_value_t global_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_GLOBAL);\n\n  if (ECMA_IS_VALUE_ERROR (global_value))\n  {\n    ecma_deref_ecma_string (str_p);\n    return global_value;\n  }\n\n  bool global = ecma_op_to_boolean (global_value);\n\n  ecma_free_value (global_value);\n\n  if (!global)\n  {\n    ecma_value_t result = ecma_op_regexp_exec (this_arg, str_p);\n    ecma_deref_ecma_string (str_p);\n    return result;\n  }\n\n#if JERRY_ESNEXT\n  ecma_value_t full_unicode_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_UNICODE);\n\n  if (ECMA_IS_VALUE_ERROR (full_unicode_value))\n  {\n    ecma_deref_ecma_string (str_p);\n    return full_unicode_value;\n  }\n\n  bool full_unicode = ecma_op_to_boolean (full_unicode_value);\n\n  ecma_free_value (full_unicode_value);\n#endif /* JERRY_ESNEXT */\n\n  ecma_value_t set_status = ecma_op_object_put (obj_p,\n                                                ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),\n                                                ecma_make_uint32_value (0),\n                                                true);\n\n  if (ECMA_IS_VALUE_ERROR (set_status))\n  {\n    ecma_deref_ecma_string (str_p);\n    return set_status;\n  }\n\n  ecma_value_t ret_value = ECMA_VALUE_ERROR;\n  ecma_object_t *result_array_p = ecma_op_new_array_object (0);\n  uint32_t n = 0;\n\n  while (true)\n  {\n    ecma_value_t result_value = ecma_op_regexp_exec (this_arg, str_p);\n\n    if (ECMA_IS_VALUE_ERROR (result_value))\n    {\n      goto result_cleanup;\n    }\n\n    if (ecma_is_value_null (result_value))\n    {\n      if (n == 0)\n      {\n        ret_value = ECMA_VALUE_NULL;\n        goto result_cleanup;\n      }\n\n      ecma_deref_ecma_string (str_p);\n      return ecma_make_object_value (result_array_p);\n    }\n\n    ecma_object_t *result_value_p = ecma_get_object_from_value (result_value);\n    ecma_value_t match_value = ecma_op_object_get_by_index (result_value_p, 0);\n\n    ecma_deref_object (result_value_p);\n\n    if (ECMA_IS_VALUE_ERROR (match_value))\n    {\n      goto result_cleanup;\n    }\n\n    ecma_string_t *match_str_p = ecma_op_to_string (match_value);\n    ecma_free_value (match_value);\n\n    if (JERRY_UNLIKELY (match_str_p == NULL))\n    {\n      goto result_cleanup;\n    }\n\n    ecma_value_t new_prop = ecma_builtin_helper_def_prop_by_index (result_array_p,\n                                                                   n,\n                                                                   ecma_make_string_value (match_str_p),\n                                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);\n\n    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_prop));\n\n    const bool is_match_empty = ecma_string_is_empty (match_str_p);\n    ecma_deref_ecma_string (match_str_p);\n\n    if (is_match_empty)\n    {\n      ecma_value_t last_index = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);\n\n      if (ECMA_IS_VALUE_ERROR (last_index))\n      {\n        goto result_cleanup;\n      }\n\n#if JERRY_ESNEXT\n      ecma_length_t index;\n      ecma_value_t length_value = ecma_op_to_length (last_index, &index);\n\n      ecma_free_value (last_index);\n\n      if (ECMA_IS_VALUE_ERROR (length_value))\n      {\n        goto result_cleanup;\n      }\n\n      index = ecma_op_advance_string_index (str_p, index, full_unicode);\n\n      last_index = ecma_make_length_value (index);\n      ecma_value_t next_set_status = ecma_op_object_put (obj_p,\n                                                         ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),\n                                                         ecma_make_length_value (index),\n                                                         true);\n#else /* !JERRY_ESNEXT */\n      ecma_number_t index = ecma_get_number_from_value (last_index);\n      ecma_free_value (last_index);\n\n      last_index = ecma_make_number_value (index + 1);\n      ecma_value_t next_set_status = ecma_op_object_put (obj_p,\n                                                         ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),\n                                                         last_index,\n                                                         true);\n\n#endif /* JERRY_ESNEXT */\n      ecma_free_value (last_index);\n\n      if (ECMA_IS_VALUE_ERROR (next_set_status))\n      {\n        goto result_cleanup;\n      }\n    }\n\n    n++;\n  }\n\nresult_cleanup:\n  ecma_deref_ecma_string (str_p);\n  ecma_deref_object (result_array_p);\n  return ret_value;\n}",
        "func": "ecma_value_t\necma_regexp_match_helper (ecma_value_t this_arg, /**< this argument */\n                          ecma_value_t string_arg) /**< source string */\n{\n  if (!ecma_is_value_object (this_arg))\n  {\n    return ecma_raise_type_error (ECMA_ERR_MSG (\"Argument 'this' is not an object\"));\n  }\n\n  ecma_string_t *str_p = ecma_op_to_string (string_arg);\n\n  if (JERRY_UNLIKELY (str_p == NULL))\n  {\n    return ECMA_VALUE_ERROR;\n  }\n\n  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);\n\n  ecma_value_t global_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_GLOBAL);\n\n  if (ECMA_IS_VALUE_ERROR (global_value))\n  {\n    ecma_deref_ecma_string (str_p);\n    return global_value;\n  }\n\n  bool global = ecma_op_to_boolean (global_value);\n\n  ecma_free_value (global_value);\n\n  if (!global)\n  {\n    ecma_value_t result = ecma_op_regexp_exec (this_arg, str_p);\n    ecma_deref_ecma_string (str_p);\n    return result;\n  }\n\n#if JERRY_ESNEXT\n  ecma_value_t full_unicode_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_UNICODE);\n\n  if (ECMA_IS_VALUE_ERROR (full_unicode_value))\n  {\n    ecma_deref_ecma_string (str_p);\n    return full_unicode_value;\n  }\n\n  bool full_unicode = ecma_op_to_boolean (full_unicode_value);\n\n  ecma_free_value (full_unicode_value);\n#endif /* JERRY_ESNEXT */\n\n  ecma_value_t set_status = ecma_op_object_put (obj_p,\n                                                ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),\n                                                ecma_make_uint32_value (0),\n                                                true);\n\n  if (ECMA_IS_VALUE_ERROR (set_status))\n  {\n    ecma_deref_ecma_string (str_p);\n    return set_status;\n  }\n\n  ecma_value_t ret_value = ECMA_VALUE_ERROR;\n  ecma_object_t *result_array_p = ecma_op_new_array_object (0);\n  uint32_t n = 0;\n\n  while (true)\n  {\n    ecma_value_t result_value = ecma_op_regexp_exec (this_arg, str_p);\n\n    if (ECMA_IS_VALUE_ERROR (result_value))\n    {\n      goto result_cleanup;\n    }\n\n    if (ecma_is_value_null (result_value))\n    {\n      if (n == 0)\n      {\n        ret_value = ECMA_VALUE_NULL;\n        goto result_cleanup;\n      }\n\n      ecma_deref_ecma_string (str_p);\n      return ecma_make_object_value (result_array_p);\n    }\n\n    ecma_object_t *result_value_p = ecma_get_object_from_value (result_value);\n    ecma_value_t match_value = ecma_op_object_get_by_index (result_value_p, 0);\n\n    ecma_deref_object (result_value_p);\n\n    if (ECMA_IS_VALUE_ERROR (match_value))\n    {\n      goto result_cleanup;\n    }\n\n    ecma_string_t *match_str_p = ecma_op_to_string (match_value);\n    ecma_free_value (match_value);\n\n    if (JERRY_UNLIKELY (match_str_p == NULL))\n    {\n      goto result_cleanup;\n    }\n\n    ecma_value_t new_prop = ecma_builtin_helper_def_prop_by_index (result_array_p,\n                                                                   n,\n                                                                   ecma_make_string_value (match_str_p),\n                                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);\n\n    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_prop));\n\n    const bool is_match_empty = ecma_string_is_empty (match_str_p);\n    ecma_deref_ecma_string (match_str_p);\n\n    if (is_match_empty)\n    {\n      ecma_value_t last_index = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);\n\n      if (ECMA_IS_VALUE_ERROR (last_index))\n      {\n        goto result_cleanup;\n      }\n\n#if JERRY_ESNEXT\n      ecma_length_t index;\n      ecma_value_t length_value = ecma_op_to_length (last_index, &index);\n\n      ecma_free_value (last_index);\n\n      if (ECMA_IS_VALUE_ERROR (length_value))\n      {\n        goto result_cleanup;\n      }\n\n      index = ecma_op_advance_string_index (str_p, index, full_unicode);\n\n      last_index = ecma_make_length_value (index);\n      ecma_value_t next_set_status = ecma_op_object_put (obj_p,\n                                                         ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),\n                                                         last_index,\n                                                         true);\n#else /* !JERRY_ESNEXT */\n      ecma_number_t index = ecma_get_number_from_value (last_index);\n      ecma_free_value (last_index);\n\n      last_index = ecma_make_number_value (index + 1);\n      ecma_value_t next_set_status = ecma_op_object_put (obj_p,\n                                                         ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),\n                                                         last_index,\n                                                         true);\n\n#endif /* JERRY_ESNEXT */\n      ecma_free_value (last_index);\n\n      if (ECMA_IS_VALUE_ERROR (next_set_status))\n      {\n        goto result_cleanup;\n      }\n    }\n\n    n++;\n  }\n\nresult_cleanup:\n  ecma_deref_ecma_string (str_p);\n  ecma_deref_object (result_array_p);\n  return ret_value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -138,7 +138,7 @@\n       last_index = ecma_make_length_value (index);\n       ecma_value_t next_set_status = ecma_op_object_put (obj_p,\n                                                          ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),\n-                                                         ecma_make_length_value (index),\n+                                                         last_index,\n                                                          true);\n #else /* !JERRY_ESNEXT */\n       ecma_number_t index = ecma_get_number_from_value (last_index);",
        "diff_line_info": {
            "deleted_lines": [
                "                                                         ecma_make_length_value (index),"
            ],
            "added_lines": [
                "                                                         last_index,"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42218",
        "func_name": "ompl/ompl::geometric::VFRRT::extendTree",
        "description": "OMPL v1.5.2 contains a memory leak in VFRRT.cpp",
        "git_url": "https://github.com/ompl/ompl/commit/abb4fadcb4e4fe4c9cf41e5e7706143a66948eb7",
        "commit_title": "fix memory leak in VFRRT. closes #839",
        "commit_text": "",
        "func_before": "ompl::geometric::VFRRT::Motion *ompl::geometric::VFRRT::extendTree(Motion *m, base::State *rstate,\n                                                                   const Eigen::VectorXd &v)\n{\n    base::State *newState = si_->allocState();\n    si_->copyState(newState, m->state);\n\n    double d = si_->distance(m->state, rstate);\n    if (d > maxDistance_)\n        d = maxDistance_;\n\n    const base::StateSpacePtr &space = si_->getStateSpace();\n    for (unsigned int i = 0; i < vfdim_; i++)\n        *space->getValueAddressAtIndex(newState, i) += d * v[i];\n    if (!v.hasNaN() && si_->checkMotion(m->state, newState))\n    {\n        auto *motion = new Motion(si_);\n        motion->state = newState;\n        motion->parent = m;\n        updateExplorationEfficiency(motion);\n        nn_->add(motion);\n        return motion;\n    }\n    else\n    {\n        si_->freeState(newState);\n        inefficientCount_++;\n        return nullptr;\n    }\n}",
        "func": "ompl::geometric::VFRRT::Motion *ompl::geometric::VFRRT::extendTree(Motion *m, base::State *rstate,\n                                                                   const Eigen::VectorXd &v)\n{\n    base::State *newState = si_->allocState();\n    si_->copyState(newState, m->state);\n\n    double d = si_->distance(m->state, rstate);\n    if (d > maxDistance_)\n        d = maxDistance_;\n\n    const base::StateSpacePtr &space = si_->getStateSpace();\n    for (unsigned int i = 0; i < vfdim_; i++)\n        *space->getValueAddressAtIndex(newState, i) += d * v[i];\n    if (!v.hasNaN() && si_->checkMotion(m->state, newState))\n    {\n        auto *motion = new Motion();\n        motion->state = newState;\n        motion->parent = m;\n        updateExplorationEfficiency(motion);\n        nn_->add(motion);\n        return motion;\n    }\n    else\n    {\n        si_->freeState(newState);\n        inefficientCount_++;\n        return nullptr;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n         *space->getValueAddressAtIndex(newState, i) += d * v[i];\n     if (!v.hasNaN() && si_->checkMotion(m->state, newState))\n     {\n-        auto *motion = new Motion(si_);\n+        auto *motion = new Motion();\n         motion->state = newState;\n         motion->parent = m;\n         updateExplorationEfficiency(motion);",
        "diff_line_info": {
            "deleted_lines": [
                "        auto *motion = new Motion(si_);"
            ],
            "added_lines": [
                "        auto *motion = new Motion();"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-28487",
        "func_name": "appneta/tcpreplay/fix_ipv6_checksums",
        "description": "Tcpreplay version 4.4.1 contains a memory leakage flaw in fix_ipv6_checksums() function. The highest threat from this vulnerability is to data confidentiality.",
        "git_url": "https://github.com/appneta/tcpreplay/commit/da398bfc3443761effcd975b1179476bf662a960",
        "commit_title": "fixed format string in 'src/tcpedit/edit_packet.c' file",
        "commit_text": "",
        "func_before": "int\nfix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n                   ipv6_hdr_t *ip6_hdr, const size_t l2len)\n{\n    int ret = 0;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip6_hdr);\n\n    if (pkthdr->caplen < (sizeof(*ip6_hdr) + l2len)) {\n        tcpedit_setwarn(tcpedit, \"caplen too small to read IPv6 header: caplen=%u pkt=\" COUNTER_SPEC,\n                pkthdr->caplen, tcpedit->runtime.packetnum);\n        return TCPEDIT_WARN;\n    }\n\n    ipv4_hdr_t *ip_hdr = (ipv4_hdr_t*)ip6_hdr;\n    if (ip_hdr->ip_v != 6) {\n        tcpedit_seterr(tcpedit, \"Invalid packet: Expected IPv6 packet: got %u\", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len) {\n        int ip6_len = ipv6_header_length(ip6_hdr, pkthdr->len, l2len);\n        if (ip6_hdr->ip_len < ip6_len) {\n            tcpedit_setwarn(tcpedit, \"Unable to checksum IPv6 packet with invalid: pkt=\" COUNTER_SPEC \" IP length=%u caplen=\" COUNTER_SPEC,\n                           tcpedit->runtime.packetnum, ip6_hdr->ip_len);\n            return TCPEDIT_WARN;\n        }\n        ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,\n            htons(ip6_hdr->ip_len));\n        if (ret < 0)\n            return TCPEDIT_ERROR;\n    }\n\n    /* what do we return? */\n    if (ret == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n\n    return TCPEDIT_OK;\n}",
        "func": "int\nfix_ipv6_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr,\n                   ipv6_hdr_t *ip6_hdr, const size_t l2len)\n{\n    int ret = 0;\n    assert(tcpedit);\n    assert(pkthdr);\n    assert(ip6_hdr);\n\n    if (pkthdr->caplen < (sizeof(*ip6_hdr) + l2len)) {\n        tcpedit_setwarn(tcpedit, \"caplen too small to read IPv6 header: caplen=%u pkt=\" COUNTER_SPEC,\n                pkthdr->caplen, tcpedit->runtime.packetnum);\n        return TCPEDIT_WARN;\n    }\n\n    ipv4_hdr_t *ip_hdr = (ipv4_hdr_t*)ip6_hdr;\n    if (ip_hdr->ip_v != 6) {\n        tcpedit_seterr(tcpedit, \"Invalid packet: Expected IPv6 packet: got %u\", ip_hdr->ip_v);\n        return TCPEDIT_ERROR;\n    }\n\n    /* calc the L4 checksum if we have the whole packet && not a frag or first frag */\n    if (pkthdr->caplen == pkthdr->len) {\n        int ip6_len = ipv6_header_length(ip6_hdr, pkthdr->len, l2len);\n        if (ip6_hdr->ip_len < ip6_len) {\n            tcpedit_setwarn(tcpedit, \"Unable to checksum IPv6 packet with invalid: pkt=\" COUNTER_SPEC \" IP length=%u caplen=\" COUNTER_SPEC,\n                           tcpedit->runtime.packetnum, ip6_hdr->ip_len, pkthdr->caplen);\n            return TCPEDIT_WARN;\n        }\n        ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,\n            htons(ip6_hdr->ip_len));\n        if (ret < 0)\n            return TCPEDIT_ERROR;\n    }\n\n    /* what do we return? */\n    if (ret == TCPEDIT_WARN)\n        return TCPEDIT_WARN;\n\n    return TCPEDIT_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n         int ip6_len = ipv6_header_length(ip6_hdr, pkthdr->len, l2len);\n         if (ip6_hdr->ip_len < ip6_len) {\n             tcpedit_setwarn(tcpedit, \"Unable to checksum IPv6 packet with invalid: pkt=\" COUNTER_SPEC \" IP length=%u caplen=\" COUNTER_SPEC,\n-                           tcpedit->runtime.packetnum, ip6_hdr->ip_len);\n+                           tcpedit->runtime.packetnum, ip6_hdr->ip_len, pkthdr->caplen);\n             return TCPEDIT_WARN;\n         }\n         ret = do_checksum(tcpedit, (u_char *)ip6_hdr, ip6_hdr->ip_nh,",
        "diff_line_info": {
            "deleted_lines": [
                "                           tcpedit->runtime.packetnum, ip6_hdr->ip_len);"
            ],
            "added_lines": [
                "                           tcpedit->runtime.packetnum, ip6_hdr->ip_len, pkthdr->caplen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6304",
        "func_name": "openssl/ssl_parse_clienthello_tlsext",
        "description": "Multiple memory leaks in t1_lib.c in OpenSSL before 1.0.1u, 1.0.2 before 1.0.2i, and 1.1.0 before 1.1.0a allow remote attackers to cause a denial of service (memory consumption) via large OCSP Status Request extensions.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=2c0d295e26306e15a92eb23a84a1802005c1c137",
        "commit_title": "",
        "commit_text": "Fix OCSP Status Request extension unbounded memory growth  A malicious client can send an excessively large OCSP Status Request extension. If that client continually requests renegotiation, sending a large OCSP Status Request extension each time, then there will be unbounded memory growth on the server. This will eventually lead to a Denial Of Service attack through memory exhaustion. Servers with a default configuration are vulnerable even if they do not support OCSP. Builds using the \"no-ocsp\" build time option are not affected.  I have also checked other extensions to see if they suffer from a similar problem but I could not find any other issues.  CVE-2016-6304  Issue reported by Shi Lei.  ",
        "func_before": "int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,\n                                 unsigned char *limit, int *al)\n{\n    unsigned short type;\n    unsigned short size;\n    unsigned short len;\n    unsigned char *data = *p;\n    int renegotiate_seen = 0;\n    int sigalg_seen = 0;\n\n    s->servername_done = 0;\n    s->tlsext_status_type = -1;\n# ifndef OPENSSL_NO_NEXTPROTONEG\n    s->s3->next_proto_neg_seen = 0;\n# endif\n\n# ifndef OPENSSL_NO_HEARTBEATS\n    s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\n                             SSL_TLSEXT_HB_DONT_SEND_REQUESTS);\n# endif\n\n# ifndef OPENSSL_NO_EC\n    if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)\n        ssl_check_for_safari(s, data, limit);\n# endif                         /* !OPENSSL_NO_EC */\n\n# ifndef OPENSSL_NO_SRP\n    if (s->srp_ctx.login != NULL) {\n        OPENSSL_free(s->srp_ctx.login);\n        s->srp_ctx.login = NULL;\n    }\n# endif\n\n    s->srtp_profile = NULL;\n\n    if (data == limit)\n        goto ri_check;\n\n    if (limit - data < 2)\n        goto err;\n\n    n2s(data, len);\n\n    if (limit - data != len)\n        goto err;\n\n    while (limit - data >= 4) {\n        n2s(data, type);\n        n2s(data, size);\n\n        if (limit - data < size)\n            goto err;\n# if 0\n        fprintf(stderr, \"Received extension type %d size %d\\n\", type, size);\n# endif\n        if (s->tlsext_debug_cb)\n            s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);\n/*-\n * The servername extension is treated as follows:\n *\n * - Only the hostname type is supported with a maximum length of 255.\n * - The servername is rejected if too long or if it contains zeros,\n *   in which case an fatal alert is generated.\n * - The servername field is maintained together with the session cache.\n * - When a session is resumed, the servername call back invoked in order\n *   to allow the application to position itself to the right context.\n * - The servername is acknowledged if it is new for a session or when\n *   it is identical to a previously used for the same session.\n *   Applications can control the behaviour.  They can at any time\n *   set a 'desirable' servername for a new SSL object. This can be the\n *   case for example with HTTPS when a Host: header field is received and\n *   a renegotiation is requested. In this case, a possible servername\n *   presented in the new client hello is only acknowledged if it matches\n *   the value of the Host: field.\n * - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n *   if they provide for changing an explicit servername context for the\n *   session, i.e. when the session has been established with a servername\n *   extension.\n * - On session reconnect, the servername extension may be absent.\n *\n */\n\n        if (type == TLSEXT_TYPE_server_name) {\n            unsigned char *sdata;\n            int servname_type;\n            int dsize;\n\n            if (size < 2)\n                goto err;\n            n2s(data, dsize);\n            size -= 2;\n            if (dsize > size)\n                goto err;\n\n            sdata = data;\n            while (dsize > 3) {\n                servname_type = *(sdata++);\n                n2s(sdata, len);\n                dsize -= 3;\n\n                if (len > dsize)\n                    goto err;\n\n                if (s->servername_done == 0)\n                    switch (servname_type) {\n                    case TLSEXT_NAMETYPE_host_name:\n                        if (!s->hit) {\n                            if (s->session->tlsext_hostname)\n                                goto err;\n\n                            if (len > TLSEXT_MAXLEN_host_name) {\n                                *al = TLS1_AD_UNRECOGNIZED_NAME;\n                                return 0;\n                            }\n                            if ((s->session->tlsext_hostname =\n                                 OPENSSL_malloc(len + 1)) == NULL) {\n                                *al = TLS1_AD_INTERNAL_ERROR;\n                                return 0;\n                            }\n                            memcpy(s->session->tlsext_hostname, sdata, len);\n                            s->session->tlsext_hostname[len] = '\\0';\n                            if (strlen(s->session->tlsext_hostname) != len) {\n                                OPENSSL_free(s->session->tlsext_hostname);\n                                s->session->tlsext_hostname = NULL;\n                                *al = TLS1_AD_UNRECOGNIZED_NAME;\n                                return 0;\n                            }\n                            s->servername_done = 1;\n\n                        } else\n                            s->servername_done = s->session->tlsext_hostname\n                                && strlen(s->session->tlsext_hostname) == len\n                                && strncmp(s->session->tlsext_hostname,\n                                           (char *)sdata, len) == 0;\n\n                        break;\n\n                    default:\n                        break;\n                    }\n\n                dsize -= len;\n            }\n            if (dsize != 0)\n                goto err;\n\n        }\n# ifndef OPENSSL_NO_SRP\n        else if (type == TLSEXT_TYPE_srp) {\n            if (size == 0 || ((len = data[0])) != (size - 1))\n                goto err;\n            if (s->srp_ctx.login != NULL)\n                goto err;\n            if ((s->srp_ctx.login = OPENSSL_malloc(len + 1)) == NULL)\n                return -1;\n            memcpy(s->srp_ctx.login, &data[1], len);\n            s->srp_ctx.login[len] = '\\0';\n\n            if (strlen(s->srp_ctx.login) != len)\n                goto err;\n        }\n# endif\n\n# ifndef OPENSSL_NO_EC\n        else if (type == TLSEXT_TYPE_ec_point_formats) {\n            unsigned char *sdata = data;\n            int ecpointformatlist_length = *(sdata++);\n\n            if (ecpointformatlist_length != size - 1)\n                goto err;\n            if (!s->hit) {\n                if (s->session->tlsext_ecpointformatlist) {\n                    OPENSSL_free(s->session->tlsext_ecpointformatlist);\n                    s->session->tlsext_ecpointformatlist = NULL;\n                }\n                s->session->tlsext_ecpointformatlist_length = 0;\n                if ((s->session->tlsext_ecpointformatlist =\n                     OPENSSL_malloc(ecpointformatlist_length)) == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                s->session->tlsext_ecpointformatlist_length =\n                    ecpointformatlist_length;\n                memcpy(s->session->tlsext_ecpointformatlist, sdata,\n                       ecpointformatlist_length);\n            }\n#  if 0\n            fprintf(stderr,\n                    \"ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) \",\n                    s->session->tlsext_ecpointformatlist_length);\n            sdata = s->session->tlsext_ecpointformatlist;\n            for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)\n                fprintf(stderr, \"%i \", *(sdata++));\n            fprintf(stderr, \"\\n\");\n#  endif\n        } else if (type == TLSEXT_TYPE_elliptic_curves) {\n            unsigned char *sdata = data;\n            int ellipticcurvelist_length = (*(sdata++) << 8);\n            ellipticcurvelist_length += (*(sdata++));\n\n            if (ellipticcurvelist_length != size - 2 ||\n                ellipticcurvelist_length < 1 ||\n                /* Each NamedCurve is 2 bytes. */\n                ellipticcurvelist_length & 1)\n                    goto err;\n\n            if (!s->hit) {\n                if (s->session->tlsext_ellipticcurvelist)\n                    goto err;\n\n                s->session->tlsext_ellipticcurvelist_length = 0;\n                if ((s->session->tlsext_ellipticcurvelist =\n                     OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                s->session->tlsext_ellipticcurvelist_length =\n                    ellipticcurvelist_length;\n                memcpy(s->session->tlsext_ellipticcurvelist, sdata,\n                       ellipticcurvelist_length);\n            }\n#  if 0\n            fprintf(stderr,\n                    \"ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) \",\n                    s->session->tlsext_ellipticcurvelist_length);\n            sdata = s->session->tlsext_ellipticcurvelist;\n            for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++)\n                fprintf(stderr, \"%i \", *(sdata++));\n            fprintf(stderr, \"\\n\");\n#  endif\n        }\n# endif                         /* OPENSSL_NO_EC */\n# ifdef TLSEXT_TYPE_opaque_prf_input\n        else if (type == TLSEXT_TYPE_opaque_prf_input &&\n                 s->version != DTLS1_VERSION) {\n            unsigned char *sdata = data;\n\n            if (size < 2) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n            n2s(sdata, s->s3->client_opaque_prf_input_len);\n            if (s->s3->client_opaque_prf_input_len != size - 2) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n\n            if (s->s3->client_opaque_prf_input != NULL) {\n                /* shouldn't really happen */\n                OPENSSL_free(s->s3->client_opaque_prf_input);\n            }\n\n            /* dummy byte just to get non-NULL */\n            if (s->s3->client_opaque_prf_input_len == 0)\n                s->s3->client_opaque_prf_input = OPENSSL_malloc(1);\n            else\n                s->s3->client_opaque_prf_input =\n                    BUF_memdup(sdata, s->s3->client_opaque_prf_input_len);\n            if (s->s3->client_opaque_prf_input == NULL) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        }\n# endif\n        else if (type == TLSEXT_TYPE_session_ticket) {\n            if (s->tls_session_ticket_ext_cb &&\n                !s->tls_session_ticket_ext_cb(s, data, size,\n                                              s->tls_session_ticket_ext_cb_arg))\n            {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        } else if (type == TLSEXT_TYPE_renegotiate) {\n            if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))\n                return 0;\n            renegotiate_seen = 1;\n        } else if (type == TLSEXT_TYPE_signature_algorithms) {\n            int dsize;\n            if (sigalg_seen || size < 2)\n                goto err;\n            sigalg_seen = 1;\n            n2s(data, dsize);\n            size -= 2;\n            if (dsize != size || dsize & 1)\n                goto err;\n            if (!tls1_process_sigalgs(s, data, dsize))\n                goto err;\n        } else if (type == TLSEXT_TYPE_status_request &&\n                   s->version != DTLS1_VERSION) {\n\n            if (size < 5)\n                goto err;\n\n            s->tlsext_status_type = *data++;\n            size--;\n            if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {\n                const unsigned char *sdata;\n                int dsize;\n                /* Read in responder_id_list */\n                n2s(data, dsize);\n                size -= 2;\n                if (dsize > size)\n                    goto err;\n                while (dsize > 0) {\n                    OCSP_RESPID *id;\n                    int idsize;\n                    if (dsize < 4)\n                        goto err;\n                    n2s(data, idsize);\n                    dsize -= 2 + idsize;\n                    size -= 2 + idsize;\n                    if (dsize < 0)\n                        goto err;\n                    sdata = data;\n                    data += idsize;\n                    id = d2i_OCSP_RESPID(NULL, &sdata, idsize);\n                    if (!id)\n                        goto err;\n                    if (data != sdata) {\n                        OCSP_RESPID_free(id);\n                        goto err;\n                    }\n                    if (!s->tlsext_ocsp_ids\n                        && !(s->tlsext_ocsp_ids =\n                             sk_OCSP_RESPID_new_null())) {\n                        OCSP_RESPID_free(id);\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                    if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {\n                        OCSP_RESPID_free(id);\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                }\n\n                /* Read in request_extensions */\n                if (size < 2)\n                    goto err;\n                n2s(data, dsize);\n                size -= 2;\n                if (dsize != size)\n                    goto err;\n                sdata = data;\n                if (dsize > 0) {\n                    if (s->tlsext_ocsp_exts) {\n                        sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,\n                                                   X509_EXTENSION_free);\n                    }\n\n                    s->tlsext_ocsp_exts =\n                        d2i_X509_EXTENSIONS(NULL, &sdata, dsize);\n                    if (!s->tlsext_ocsp_exts || (data + dsize != sdata))\n                        goto err;\n                }\n            }\n            /*\n             * We don't know what to do with any other type * so ignore it.\n             */\n            else\n                s->tlsext_status_type = -1;\n        }\n# ifndef OPENSSL_NO_HEARTBEATS\n        else if (type == TLSEXT_TYPE_heartbeat) {\n            switch (data[0]) {\n            case 0x01:         /* Client allows us to send HB requests */\n                s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\n                break;\n            case 0x02:         /* Client doesn't accept HB requests */\n                s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\n                s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\n                break;\n            default:\n                *al = SSL_AD_ILLEGAL_PARAMETER;\n                return 0;\n            }\n        }\n# endif\n# ifndef OPENSSL_NO_NEXTPROTONEG\n        else if (type == TLSEXT_TYPE_next_proto_neg &&\n                 s->s3->tmp.finish_md_len == 0) {\n            /*-\n             * We shouldn't accept this extension on a\n             * renegotiation.\n             *\n             * s->new_session will be set on renegotiation, but we\n             * probably shouldn't rely that it couldn't be set on\n             * the initial renegotation too in certain cases (when\n             * there's some other reason to disallow resuming an\n             * earlier session -- the current code won't be doing\n             * anything like that, but this might change).\n             *\n             * A valid sign that there's been a previous handshake\n             * in this connection is if s->s3->tmp.finish_md_len >\n             * 0.  (We are talking about a check that will happen\n             * in the Hello protocol round, well before a new\n             * Finished message could have been computed.)\n             */\n            s->s3->next_proto_neg_seen = 1;\n        }\n# endif\n\n        /* session ticket processed earlier */\n# ifndef OPENSSL_NO_SRTP\n        else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)\n                 && type == TLSEXT_TYPE_use_srtp) {\n            if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))\n                return 0;\n        }\n# endif\n\n        data += size;\n    }\n\n    /* Spurious data on the end */\n    if (data != limit)\n        goto err;\n\n    *p = data;\n\n ri_check:\n\n    /* Need RI if renegotiating */\n\n    if (!renegotiate_seen && s->renegotiate &&\n        !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT,\n               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n        return 0;\n    }\n\n    return 1;\nerr:\n    *al = SSL_AD_DECODE_ERROR;\n    return 0;\n}",
        "func": "int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,\n                                 unsigned char *limit, int *al)\n{\n    unsigned short type;\n    unsigned short size;\n    unsigned short len;\n    unsigned char *data = *p;\n    int renegotiate_seen = 0;\n    int sigalg_seen = 0;\n\n    s->servername_done = 0;\n    s->tlsext_status_type = -1;\n# ifndef OPENSSL_NO_NEXTPROTONEG\n    s->s3->next_proto_neg_seen = 0;\n# endif\n\n# ifndef OPENSSL_NO_HEARTBEATS\n    s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\n                             SSL_TLSEXT_HB_DONT_SEND_REQUESTS);\n# endif\n\n# ifndef OPENSSL_NO_EC\n    if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)\n        ssl_check_for_safari(s, data, limit);\n# endif                         /* !OPENSSL_NO_EC */\n\n# ifndef OPENSSL_NO_SRP\n    if (s->srp_ctx.login != NULL) {\n        OPENSSL_free(s->srp_ctx.login);\n        s->srp_ctx.login = NULL;\n    }\n# endif\n\n    s->srtp_profile = NULL;\n\n    if (data == limit)\n        goto ri_check;\n\n    if (limit - data < 2)\n        goto err;\n\n    n2s(data, len);\n\n    if (limit - data != len)\n        goto err;\n\n    while (limit - data >= 4) {\n        n2s(data, type);\n        n2s(data, size);\n\n        if (limit - data < size)\n            goto err;\n# if 0\n        fprintf(stderr, \"Received extension type %d size %d\\n\", type, size);\n# endif\n        if (s->tlsext_debug_cb)\n            s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);\n/*-\n * The servername extension is treated as follows:\n *\n * - Only the hostname type is supported with a maximum length of 255.\n * - The servername is rejected if too long or if it contains zeros,\n *   in which case an fatal alert is generated.\n * - The servername field is maintained together with the session cache.\n * - When a session is resumed, the servername call back invoked in order\n *   to allow the application to position itself to the right context.\n * - The servername is acknowledged if it is new for a session or when\n *   it is identical to a previously used for the same session.\n *   Applications can control the behaviour.  They can at any time\n *   set a 'desirable' servername for a new SSL object. This can be the\n *   case for example with HTTPS when a Host: header field is received and\n *   a renegotiation is requested. In this case, a possible servername\n *   presented in the new client hello is only acknowledged if it matches\n *   the value of the Host: field.\n * - Applications must  use SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n *   if they provide for changing an explicit servername context for the\n *   session, i.e. when the session has been established with a servername\n *   extension.\n * - On session reconnect, the servername extension may be absent.\n *\n */\n\n        if (type == TLSEXT_TYPE_server_name) {\n            unsigned char *sdata;\n            int servname_type;\n            int dsize;\n\n            if (size < 2)\n                goto err;\n            n2s(data, dsize);\n            size -= 2;\n            if (dsize > size)\n                goto err;\n\n            sdata = data;\n            while (dsize > 3) {\n                servname_type = *(sdata++);\n                n2s(sdata, len);\n                dsize -= 3;\n\n                if (len > dsize)\n                    goto err;\n\n                if (s->servername_done == 0)\n                    switch (servname_type) {\n                    case TLSEXT_NAMETYPE_host_name:\n                        if (!s->hit) {\n                            if (s->session->tlsext_hostname)\n                                goto err;\n\n                            if (len > TLSEXT_MAXLEN_host_name) {\n                                *al = TLS1_AD_UNRECOGNIZED_NAME;\n                                return 0;\n                            }\n                            if ((s->session->tlsext_hostname =\n                                 OPENSSL_malloc(len + 1)) == NULL) {\n                                *al = TLS1_AD_INTERNAL_ERROR;\n                                return 0;\n                            }\n                            memcpy(s->session->tlsext_hostname, sdata, len);\n                            s->session->tlsext_hostname[len] = '\\0';\n                            if (strlen(s->session->tlsext_hostname) != len) {\n                                OPENSSL_free(s->session->tlsext_hostname);\n                                s->session->tlsext_hostname = NULL;\n                                *al = TLS1_AD_UNRECOGNIZED_NAME;\n                                return 0;\n                            }\n                            s->servername_done = 1;\n\n                        } else\n                            s->servername_done = s->session->tlsext_hostname\n                                && strlen(s->session->tlsext_hostname) == len\n                                && strncmp(s->session->tlsext_hostname,\n                                           (char *)sdata, len) == 0;\n\n                        break;\n\n                    default:\n                        break;\n                    }\n\n                dsize -= len;\n            }\n            if (dsize != 0)\n                goto err;\n\n        }\n# ifndef OPENSSL_NO_SRP\n        else if (type == TLSEXT_TYPE_srp) {\n            if (size == 0 || ((len = data[0])) != (size - 1))\n                goto err;\n            if (s->srp_ctx.login != NULL)\n                goto err;\n            if ((s->srp_ctx.login = OPENSSL_malloc(len + 1)) == NULL)\n                return -1;\n            memcpy(s->srp_ctx.login, &data[1], len);\n            s->srp_ctx.login[len] = '\\0';\n\n            if (strlen(s->srp_ctx.login) != len)\n                goto err;\n        }\n# endif\n\n# ifndef OPENSSL_NO_EC\n        else if (type == TLSEXT_TYPE_ec_point_formats) {\n            unsigned char *sdata = data;\n            int ecpointformatlist_length = *(sdata++);\n\n            if (ecpointformatlist_length != size - 1)\n                goto err;\n            if (!s->hit) {\n                if (s->session->tlsext_ecpointformatlist) {\n                    OPENSSL_free(s->session->tlsext_ecpointformatlist);\n                    s->session->tlsext_ecpointformatlist = NULL;\n                }\n                s->session->tlsext_ecpointformatlist_length = 0;\n                if ((s->session->tlsext_ecpointformatlist =\n                     OPENSSL_malloc(ecpointformatlist_length)) == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                s->session->tlsext_ecpointformatlist_length =\n                    ecpointformatlist_length;\n                memcpy(s->session->tlsext_ecpointformatlist, sdata,\n                       ecpointformatlist_length);\n            }\n#  if 0\n            fprintf(stderr,\n                    \"ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) \",\n                    s->session->tlsext_ecpointformatlist_length);\n            sdata = s->session->tlsext_ecpointformatlist;\n            for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)\n                fprintf(stderr, \"%i \", *(sdata++));\n            fprintf(stderr, \"\\n\");\n#  endif\n        } else if (type == TLSEXT_TYPE_elliptic_curves) {\n            unsigned char *sdata = data;\n            int ellipticcurvelist_length = (*(sdata++) << 8);\n            ellipticcurvelist_length += (*(sdata++));\n\n            if (ellipticcurvelist_length != size - 2 ||\n                ellipticcurvelist_length < 1 ||\n                /* Each NamedCurve is 2 bytes. */\n                ellipticcurvelist_length & 1)\n                    goto err;\n\n            if (!s->hit) {\n                if (s->session->tlsext_ellipticcurvelist)\n                    goto err;\n\n                s->session->tlsext_ellipticcurvelist_length = 0;\n                if ((s->session->tlsext_ellipticcurvelist =\n                     OPENSSL_malloc(ellipticcurvelist_length)) == NULL) {\n                    *al = TLS1_AD_INTERNAL_ERROR;\n                    return 0;\n                }\n                s->session->tlsext_ellipticcurvelist_length =\n                    ellipticcurvelist_length;\n                memcpy(s->session->tlsext_ellipticcurvelist, sdata,\n                       ellipticcurvelist_length);\n            }\n#  if 0\n            fprintf(stderr,\n                    \"ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) \",\n                    s->session->tlsext_ellipticcurvelist_length);\n            sdata = s->session->tlsext_ellipticcurvelist;\n            for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++)\n                fprintf(stderr, \"%i \", *(sdata++));\n            fprintf(stderr, \"\\n\");\n#  endif\n        }\n# endif                         /* OPENSSL_NO_EC */\n# ifdef TLSEXT_TYPE_opaque_prf_input\n        else if (type == TLSEXT_TYPE_opaque_prf_input &&\n                 s->version != DTLS1_VERSION) {\n            unsigned char *sdata = data;\n\n            if (size < 2) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n            n2s(sdata, s->s3->client_opaque_prf_input_len);\n            if (s->s3->client_opaque_prf_input_len != size - 2) {\n                *al = SSL_AD_DECODE_ERROR;\n                return 0;\n            }\n\n            if (s->s3->client_opaque_prf_input != NULL) {\n                /* shouldn't really happen */\n                OPENSSL_free(s->s3->client_opaque_prf_input);\n            }\n\n            /* dummy byte just to get non-NULL */\n            if (s->s3->client_opaque_prf_input_len == 0)\n                s->s3->client_opaque_prf_input = OPENSSL_malloc(1);\n            else\n                s->s3->client_opaque_prf_input =\n                    BUF_memdup(sdata, s->s3->client_opaque_prf_input_len);\n            if (s->s3->client_opaque_prf_input == NULL) {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        }\n# endif\n        else if (type == TLSEXT_TYPE_session_ticket) {\n            if (s->tls_session_ticket_ext_cb &&\n                !s->tls_session_ticket_ext_cb(s, data, size,\n                                              s->tls_session_ticket_ext_cb_arg))\n            {\n                *al = TLS1_AD_INTERNAL_ERROR;\n                return 0;\n            }\n        } else if (type == TLSEXT_TYPE_renegotiate) {\n            if (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))\n                return 0;\n            renegotiate_seen = 1;\n        } else if (type == TLSEXT_TYPE_signature_algorithms) {\n            int dsize;\n            if (sigalg_seen || size < 2)\n                goto err;\n            sigalg_seen = 1;\n            n2s(data, dsize);\n            size -= 2;\n            if (dsize != size || dsize & 1)\n                goto err;\n            if (!tls1_process_sigalgs(s, data, dsize))\n                goto err;\n        } else if (type == TLSEXT_TYPE_status_request &&\n                   s->version != DTLS1_VERSION) {\n\n            if (size < 5)\n                goto err;\n\n            s->tlsext_status_type = *data++;\n            size--;\n            if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {\n                const unsigned char *sdata;\n                int dsize;\n                /* Read in responder_id_list */\n                n2s(data, dsize);\n                size -= 2;\n                if (dsize > size)\n                    goto err;\n\n                /*\n                 * We remove any OCSP_RESPIDs from a previous handshake\n                 * to prevent unbounded memory growth - CVE-2016-6304\n                 */\n                sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids,\n                                        OCSP_RESPID_free);\n                if (dsize > 0) {\n                    s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null();\n                    if (s->tlsext_ocsp_ids == NULL) {\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                } else {\n                    s->tlsext_ocsp_ids = NULL;\n                }\n\n                while (dsize > 0) {\n                    OCSP_RESPID *id;\n                    int idsize;\n                    if (dsize < 4)\n                        goto err;\n                    n2s(data, idsize);\n                    dsize -= 2 + idsize;\n                    size -= 2 + idsize;\n                    if (dsize < 0)\n                        goto err;\n                    sdata = data;\n                    data += idsize;\n                    id = d2i_OCSP_RESPID(NULL, &sdata, idsize);\n                    if (!id)\n                        goto err;\n                    if (data != sdata) {\n                        OCSP_RESPID_free(id);\n                        goto err;\n                    }\n                    if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {\n                        OCSP_RESPID_free(id);\n                        *al = SSL_AD_INTERNAL_ERROR;\n                        return 0;\n                    }\n                }\n\n                /* Read in request_extensions */\n                if (size < 2)\n                    goto err;\n                n2s(data, dsize);\n                size -= 2;\n                if (dsize != size)\n                    goto err;\n                sdata = data;\n                if (dsize > 0) {\n                    if (s->tlsext_ocsp_exts) {\n                        sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,\n                                                   X509_EXTENSION_free);\n                    }\n\n                    s->tlsext_ocsp_exts =\n                        d2i_X509_EXTENSIONS(NULL, &sdata, dsize);\n                    if (!s->tlsext_ocsp_exts || (data + dsize != sdata))\n                        goto err;\n                }\n            }\n            /*\n             * We don't know what to do with any other type * so ignore it.\n             */\n            else\n                s->tlsext_status_type = -1;\n        }\n# ifndef OPENSSL_NO_HEARTBEATS\n        else if (type == TLSEXT_TYPE_heartbeat) {\n            switch (data[0]) {\n            case 0x01:         /* Client allows us to send HB requests */\n                s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\n                break;\n            case 0x02:         /* Client doesn't accept HB requests */\n                s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\n                s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\n                break;\n            default:\n                *al = SSL_AD_ILLEGAL_PARAMETER;\n                return 0;\n            }\n        }\n# endif\n# ifndef OPENSSL_NO_NEXTPROTONEG\n        else if (type == TLSEXT_TYPE_next_proto_neg &&\n                 s->s3->tmp.finish_md_len == 0) {\n            /*-\n             * We shouldn't accept this extension on a\n             * renegotiation.\n             *\n             * s->new_session will be set on renegotiation, but we\n             * probably shouldn't rely that it couldn't be set on\n             * the initial renegotation too in certain cases (when\n             * there's some other reason to disallow resuming an\n             * earlier session -- the current code won't be doing\n             * anything like that, but this might change).\n             *\n             * A valid sign that there's been a previous handshake\n             * in this connection is if s->s3->tmp.finish_md_len >\n             * 0.  (We are talking about a check that will happen\n             * in the Hello protocol round, well before a new\n             * Finished message could have been computed.)\n             */\n            s->s3->next_proto_neg_seen = 1;\n        }\n# endif\n\n        /* session ticket processed earlier */\n# ifndef OPENSSL_NO_SRTP\n        else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)\n                 && type == TLSEXT_TYPE_use_srtp) {\n            if (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))\n                return 0;\n        }\n# endif\n\n        data += size;\n    }\n\n    /* Spurious data on the end */\n    if (data != limit)\n        goto err;\n\n    *p = data;\n\n ri_check:\n\n    /* Need RI if renegotiating */\n\n    if (!renegotiate_seen && s->renegotiate &&\n        !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n        *al = SSL_AD_HANDSHAKE_FAILURE;\n        SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT,\n               SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n        return 0;\n    }\n\n    return 1;\nerr:\n    *al = SSL_AD_DECODE_ERROR;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -301,6 +301,23 @@\n                 size -= 2;\n                 if (dsize > size)\n                     goto err;\n+\n+                /*\n+                 * We remove any OCSP_RESPIDs from a previous handshake\n+                 * to prevent unbounded memory growth - CVE-2016-6304\n+                 */\n+                sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids,\n+                                        OCSP_RESPID_free);\n+                if (dsize > 0) {\n+                    s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null();\n+                    if (s->tlsext_ocsp_ids == NULL) {\n+                        *al = SSL_AD_INTERNAL_ERROR;\n+                        return 0;\n+                    }\n+                } else {\n+                    s->tlsext_ocsp_ids = NULL;\n+                }\n+\n                 while (dsize > 0) {\n                     OCSP_RESPID *id;\n                     int idsize;\n@@ -319,13 +336,6 @@\n                     if (data != sdata) {\n                         OCSP_RESPID_free(id);\n                         goto err;\n-                    }\n-                    if (!s->tlsext_ocsp_ids\n-                        && !(s->tlsext_ocsp_ids =\n-                             sk_OCSP_RESPID_new_null())) {\n-                        OCSP_RESPID_free(id);\n-                        *al = SSL_AD_INTERNAL_ERROR;\n-                        return 0;\n                     }\n                     if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {\n                         OCSP_RESPID_free(id);",
        "diff_line_info": {
            "deleted_lines": [
                "                    }",
                "                    if (!s->tlsext_ocsp_ids",
                "                        && !(s->tlsext_ocsp_ids =",
                "                             sk_OCSP_RESPID_new_null())) {",
                "                        OCSP_RESPID_free(id);",
                "                        *al = SSL_AD_INTERNAL_ERROR;",
                "                        return 0;"
            ],
            "added_lines": [
                "",
                "                /*",
                "                 * We remove any OCSP_RESPIDs from a previous handshake",
                "                 * to prevent unbounded memory growth - CVE-2016-6304",
                "                 */",
                "                sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids,",
                "                                        OCSP_RESPID_free);",
                "                if (dsize > 0) {",
                "                    s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null();",
                "                    if (s->tlsext_ocsp_ids == NULL) {",
                "                        *al = SSL_AD_INTERNAL_ERROR;",
                "                        return 0;",
                "                    }",
                "                } else {",
                "                    s->tlsext_ocsp_ids = NULL;",
                "                }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9913",
        "func_name": "qemu/v9fs_device_realize_common",
        "description": "Memory leak in the v9fs_device_unrealize_common function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) via vectors involving the order of resource cleanup.",
        "git_url": "https://github.com/qemu/qemu/commit/4774718e5c194026ba5ee7a28d9be49be3080e42",
        "commit_title": "9pfs: adjust the order of resource cleanup in device unrealize",
        "commit_text": " Unrealize should undo things that were set during realize in reverse order. So should do in the error path in realize. ",
        "func_before": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n{\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    int i, len;\n    struct stat stat;\n    FsDriverEntry *fse;\n    V9fsPath path;\n    int rc = 1;\n\n    /* initialize pdu allocator */\n    QLIST_INIT(&s->free_list);\n    QLIST_INIT(&s->active_list);\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);\n        v->pdus[i].s = s;\n        v->pdus[i].idx = i;\n    }\n\n    v9fs_path_init(&path);\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n    if (!fse) {\n        /* We don't have a fsdev identified by fsdev_id */\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n                   \"id = %s\",\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n        goto out;\n    }\n\n    if (!s->fsconf.tag) {\n        /* we haven't specified a mount_tag */\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n                   s->fsconf.fsdev_id);\n        goto out;\n    }\n\n    s->ctx.export_flags = fse->export_flags;\n    s->ctx.fs_root = g_strdup(fse->path);\n    s->ctx.exops.get_st_gen = NULL;\n    len = strlen(s->fsconf.tag);\n    if (len > MAX_TAG_LEN - 1) {\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n        goto out;\n    }\n\n    s->tag = g_strdup(s->fsconf.tag);\n    s->ctx.uid = -1;\n\n    s->ops = fse->ops;\n\n    s->fid_list = NULL;\n    qemu_co_rwlock_init(&s->rename_lock);\n\n    if (s->ops->init(&s->ctx) < 0) {\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n        goto out;\n    }\n\n    /*\n     * Check details of export path, We need to use fs driver\n     * call back to do that. Since we are in the init path, we don't\n     * use co-routines here.\n     */\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n        error_setg(errp,\n                   \"error in converting name to path %s\", strerror(errno));\n        goto out;\n    }\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n        goto out;\n    } else if (!S_ISDIR(stat.st_mode)) {\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n        goto out;\n    }\n    v9fs_path_free(&path);\n\n    rc = 0;\nout:\n    if (rc) {\n        g_free(s->ctx.fs_root);\n        g_free(s->tag);\n        v9fs_path_free(&path);\n    }\n    return rc;\n}",
        "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n{\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    int i, len;\n    struct stat stat;\n    FsDriverEntry *fse;\n    V9fsPath path;\n    int rc = 1;\n\n    /* initialize pdu allocator */\n    QLIST_INIT(&s->free_list);\n    QLIST_INIT(&s->active_list);\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);\n        v->pdus[i].s = s;\n        v->pdus[i].idx = i;\n    }\n\n    v9fs_path_init(&path);\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n    if (!fse) {\n        /* We don't have a fsdev identified by fsdev_id */\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n                   \"id = %s\",\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n        goto out;\n    }\n\n    if (!s->fsconf.tag) {\n        /* we haven't specified a mount_tag */\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n                   s->fsconf.fsdev_id);\n        goto out;\n    }\n\n    s->ctx.export_flags = fse->export_flags;\n    s->ctx.fs_root = g_strdup(fse->path);\n    s->ctx.exops.get_st_gen = NULL;\n    len = strlen(s->fsconf.tag);\n    if (len > MAX_TAG_LEN - 1) {\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n        goto out;\n    }\n\n    s->tag = g_strdup(s->fsconf.tag);\n    s->ctx.uid = -1;\n\n    s->ops = fse->ops;\n\n    s->fid_list = NULL;\n    qemu_co_rwlock_init(&s->rename_lock);\n\n    if (s->ops->init(&s->ctx) < 0) {\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n        goto out;\n    }\n\n    /*\n     * Check details of export path, We need to use fs driver\n     * call back to do that. Since we are in the init path, we don't\n     * use co-routines here.\n     */\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n        error_setg(errp,\n                   \"error in converting name to path %s\", strerror(errno));\n        goto out;\n    }\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n        goto out;\n    } else if (!S_ISDIR(stat.st_mode)) {\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n        goto out;\n    }\n    v9fs_path_free(&path);\n\n    rc = 0;\nout:\n    if (rc) {\n        g_free(s->tag);\n        g_free(s->ctx.fs_root);\n        v9fs_path_free(&path);\n    }\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -81,8 +81,8 @@\n     rc = 0;\n out:\n     if (rc) {\n+        g_free(s->tag);\n         g_free(s->ctx.fs_root);\n-        g_free(s->tag);\n         v9fs_path_free(&path);\n     }\n     return rc;",
        "diff_line_info": {
            "deleted_lines": [
                "        g_free(s->tag);"
            ],
            "added_lines": [
                "        g_free(s->tag);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9913",
        "func_name": "qemu/v9fs_device_unrealize_common",
        "description": "Memory leak in the v9fs_device_unrealize_common function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) via vectors involving the order of resource cleanup.",
        "git_url": "https://github.com/qemu/qemu/commit/4774718e5c194026ba5ee7a28d9be49be3080e42",
        "commit_title": "9pfs: adjust the order of resource cleanup in device unrealize",
        "commit_text": " Unrealize should undo things that were set during realize in reverse order. So should do in the error path in realize. ",
        "func_before": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n{\n    g_free(s->ctx.fs_root);\n    g_free(s->tag);\n}",
        "func": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n{\n    g_free(s->tag);\n    g_free(s->ctx.fs_root);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n {\n+    g_free(s->tag);\n     g_free(s->ctx.fs_root);\n-    g_free(s->tag);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    g_free(s->tag);"
            ],
            "added_lines": [
                "    g_free(s->tag);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9914",
        "func_name": "qemu/v9fs_device_realize_common",
        "description": "Memory leak in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) by leveraging a missing cleanup operation in FileOperations.",
        "git_url": "https://github.com/qemu/qemu/commit/702dbcc274e2ca43be20ba64c758c0ca57dab91d",
        "commit_title": "9pfs: add cleanup operation in FileOperations",
        "commit_text": " Currently, the backend of VirtFS doesn't have a cleanup function. This will lead resource leak issues if the backed driver allocates resources. This patch addresses this issue. ",
        "func_before": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n{\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    int i, len;\n    struct stat stat;\n    FsDriverEntry *fse;\n    V9fsPath path;\n    int rc = 1;\n\n    /* initialize pdu allocator */\n    QLIST_INIT(&s->free_list);\n    QLIST_INIT(&s->active_list);\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);\n        v->pdus[i].s = s;\n        v->pdus[i].idx = i;\n    }\n\n    v9fs_path_init(&path);\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n    if (!fse) {\n        /* We don't have a fsdev identified by fsdev_id */\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n                   \"id = %s\",\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n        goto out;\n    }\n\n    if (!s->fsconf.tag) {\n        /* we haven't specified a mount_tag */\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n                   s->fsconf.fsdev_id);\n        goto out;\n    }\n\n    s->ctx.export_flags = fse->export_flags;\n    s->ctx.fs_root = g_strdup(fse->path);\n    s->ctx.exops.get_st_gen = NULL;\n    len = strlen(s->fsconf.tag);\n    if (len > MAX_TAG_LEN - 1) {\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n        goto out;\n    }\n\n    s->tag = g_strdup(s->fsconf.tag);\n    s->ctx.uid = -1;\n\n    s->ops = fse->ops;\n\n    s->fid_list = NULL;\n    qemu_co_rwlock_init(&s->rename_lock);\n\n    if (s->ops->init(&s->ctx) < 0) {\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n        goto out;\n    }\n\n    /*\n     * Check details of export path, We need to use fs driver\n     * call back to do that. Since we are in the init path, we don't\n     * use co-routines here.\n     */\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n        error_setg(errp,\n                   \"error in converting name to path %s\", strerror(errno));\n        goto out;\n    }\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n        goto out;\n    } else if (!S_ISDIR(stat.st_mode)) {\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n        goto out;\n    }\n    v9fs_path_free(&path);\n\n    rc = 0;\nout:\n    if (rc) {\n        g_free(s->tag);\n        g_free(s->ctx.fs_root);\n        v9fs_path_free(&path);\n    }\n    return rc;\n}",
        "func": "int v9fs_device_realize_common(V9fsState *s, Error **errp)\n{\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n    int i, len;\n    struct stat stat;\n    FsDriverEntry *fse;\n    V9fsPath path;\n    int rc = 1;\n\n    /* initialize pdu allocator */\n    QLIST_INIT(&s->free_list);\n    QLIST_INIT(&s->active_list);\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);\n        v->pdus[i].s = s;\n        v->pdus[i].idx = i;\n    }\n\n    v9fs_path_init(&path);\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n    if (!fse) {\n        /* We don't have a fsdev identified by fsdev_id */\n        error_setg(errp, \"9pfs device couldn't find fsdev with the \"\n                   \"id = %s\",\n                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n        goto out;\n    }\n\n    if (!s->fsconf.tag) {\n        /* we haven't specified a mount_tag */\n        error_setg(errp, \"fsdev with id %s needs mount_tag arguments\",\n                   s->fsconf.fsdev_id);\n        goto out;\n    }\n\n    s->ctx.export_flags = fse->export_flags;\n    s->ctx.fs_root = g_strdup(fse->path);\n    s->ctx.exops.get_st_gen = NULL;\n    len = strlen(s->fsconf.tag);\n    if (len > MAX_TAG_LEN - 1) {\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n        goto out;\n    }\n\n    s->tag = g_strdup(s->fsconf.tag);\n    s->ctx.uid = -1;\n\n    s->ops = fse->ops;\n\n    s->fid_list = NULL;\n    qemu_co_rwlock_init(&s->rename_lock);\n\n    if (s->ops->init(&s->ctx) < 0) {\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n        goto out;\n    }\n\n    /*\n     * Check details of export path, We need to use fs driver\n     * call back to do that. Since we are in the init path, we don't\n     * use co-routines here.\n     */\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n        error_setg(errp,\n                   \"error in converting name to path %s\", strerror(errno));\n        goto out;\n    }\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n        goto out;\n    } else if (!S_ISDIR(stat.st_mode)) {\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n        goto out;\n    }\n    v9fs_path_free(&path);\n\n    rc = 0;\nout:\n    if (rc) {\n        if (s->ops->cleanup && s->ctx.private) {\n            s->ops->cleanup(&s->ctx);\n        }\n        g_free(s->tag);\n        g_free(s->ctx.fs_root);\n        v9fs_path_free(&path);\n    }\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -81,6 +81,9 @@\n     rc = 0;\n out:\n     if (rc) {\n+        if (s->ops->cleanup && s->ctx.private) {\n+            s->ops->cleanup(&s->ctx);\n+        }\n         g_free(s->tag);\n         g_free(s->ctx.fs_root);\n         v9fs_path_free(&path);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (s->ops->cleanup && s->ctx.private) {",
                "            s->ops->cleanup(&s->ctx);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9914",
        "func_name": "qemu/v9fs_device_unrealize_common",
        "description": "Memory leak in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) by leveraging a missing cleanup operation in FileOperations.",
        "git_url": "https://github.com/qemu/qemu/commit/702dbcc274e2ca43be20ba64c758c0ca57dab91d",
        "commit_title": "9pfs: add cleanup operation in FileOperations",
        "commit_text": " Currently, the backend of VirtFS doesn't have a cleanup function. This will lead resource leak issues if the backed driver allocates resources. This patch addresses this issue. ",
        "func_before": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n{\n    g_free(s->tag);\n    g_free(s->ctx.fs_root);\n}",
        "func": "void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n{\n    if (s->ops->cleanup) {\n        s->ops->cleanup(&s->ctx);\n    }\n    g_free(s->tag);\n    g_free(s->ctx.fs_root);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n {\n+    if (s->ops->cleanup) {\n+        s->ops->cleanup(&s->ctx);\n+    }\n     g_free(s->tag);\n     g_free(s->ctx.fs_root);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (s->ops->cleanup) {",
                "        s->ops->cleanup(&s->ctx);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2942",
        "func_name": "kernel/git/netdev/net/tcf_mirred_dump",
        "description": "The actions implementation in the network queueing functionality in the Linux kernel before 2.6.36-rc2 does not properly initialize certain structure members when performing dump operations, which allows local users to obtain potentially sensitive information from kernel memory via vectors related to (1) the tcf_gact_dump function in net/sched/act_gact.c, (2) the tcf_mirred_dump function in net/sched/act_mirred.c, (3) the tcf_nat_dump function in net/sched/act_nat.c, (4) the tcf_simp_dump function in net/sched/act_simple.c, and (5) the tcf_skbedit_dump function in net/sched/act_skbedit.c.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net.git;a=commit;h=1c40be12f7d8ca1d387510d39787b12e512a7ce8",
        "commit_title": "We leak at least 32bits of kernel memory to user land in tc dump,",
        "commit_text": "because we dont init all fields (capab ?) of the dumped structure.  Use C99 initializers so that holes and non explicit fields are zeroed.  ",
        "func_before": "static int tcf_mirred_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_mirred *m = a->priv;\n\tstruct tc_mirred opt;\n\tstruct tcf_t t;\n\n\topt.index = m->tcf_index;\n\topt.action = m->tcf_action;\n\topt.refcnt = m->tcf_refcnt - ref;\n\topt.bindcnt = m->tcf_bindcnt - bind;\n\topt.eaction = m->tcfm_eaction;\n\topt.ifindex = m->tcfm_ifindex;\n\tNLA_PUT(skb, TCA_MIRRED_PARMS, sizeof(opt), &opt);\n\tt.install = jiffies_to_clock_t(jiffies - m->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - m->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(m->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_MIRRED_TM, sizeof(t), &t);\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "func": "static int tcf_mirred_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_mirred *m = a->priv;\n\tstruct tc_mirred opt = {\n\t\t.index   = m->tcf_index,\n\t\t.action  = m->tcf_action,\n\t\t.refcnt  = m->tcf_refcnt - ref,\n\t\t.bindcnt = m->tcf_bindcnt - bind,\n\t\t.eaction = m->tcfm_eaction,\n\t\t.ifindex = m->tcfm_ifindex,\n\t};\n\tstruct tcf_t t;\n\n\tNLA_PUT(skb, TCA_MIRRED_PARMS, sizeof(opt), &opt);\n\tt.install = jiffies_to_clock_t(jiffies - m->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - m->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(m->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_MIRRED_TM, sizeof(t), &t);\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,15 +2,16 @@\n {\n \tunsigned char *b = skb_tail_pointer(skb);\n \tstruct tcf_mirred *m = a->priv;\n-\tstruct tc_mirred opt;\n+\tstruct tc_mirred opt = {\n+\t\t.index   = m->tcf_index,\n+\t\t.action  = m->tcf_action,\n+\t\t.refcnt  = m->tcf_refcnt - ref,\n+\t\t.bindcnt = m->tcf_bindcnt - bind,\n+\t\t.eaction = m->tcfm_eaction,\n+\t\t.ifindex = m->tcfm_ifindex,\n+\t};\n \tstruct tcf_t t;\n \n-\topt.index = m->tcf_index;\n-\topt.action = m->tcf_action;\n-\topt.refcnt = m->tcf_refcnt - ref;\n-\topt.bindcnt = m->tcf_bindcnt - bind;\n-\topt.eaction = m->tcfm_eaction;\n-\topt.ifindex = m->tcfm_ifindex;\n \tNLA_PUT(skb, TCA_MIRRED_PARMS, sizeof(opt), &opt);\n \tt.install = jiffies_to_clock_t(jiffies - m->tcf_tm.install);\n \tt.lastuse = jiffies_to_clock_t(jiffies - m->tcf_tm.lastuse);",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct tc_mirred opt;",
                "\topt.index = m->tcf_index;",
                "\topt.action = m->tcf_action;",
                "\topt.refcnt = m->tcf_refcnt - ref;",
                "\topt.bindcnt = m->tcf_bindcnt - bind;",
                "\topt.eaction = m->tcfm_eaction;",
                "\topt.ifindex = m->tcfm_ifindex;"
            ],
            "added_lines": [
                "\tstruct tc_mirred opt = {",
                "\t\t.index   = m->tcf_index,",
                "\t\t.action  = m->tcf_action,",
                "\t\t.refcnt  = m->tcf_refcnt - ref,",
                "\t\t.bindcnt = m->tcf_bindcnt - bind,",
                "\t\t.eaction = m->tcfm_eaction,",
                "\t\t.ifindex = m->tcfm_ifindex,",
                "\t};"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2942",
        "func_name": "kernel/git/netdev/net/tcf_skbedit_dump",
        "description": "The actions implementation in the network queueing functionality in the Linux kernel before 2.6.36-rc2 does not properly initialize certain structure members when performing dump operations, which allows local users to obtain potentially sensitive information from kernel memory via vectors related to (1) the tcf_gact_dump function in net/sched/act_gact.c, (2) the tcf_mirred_dump function in net/sched/act_mirred.c, (3) the tcf_nat_dump function in net/sched/act_nat.c, (4) the tcf_simp_dump function in net/sched/act_simple.c, and (5) the tcf_skbedit_dump function in net/sched/act_skbedit.c.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net.git;a=commit;h=1c40be12f7d8ca1d387510d39787b12e512a7ce8",
        "commit_title": "We leak at least 32bits of kernel memory to user land in tc dump,",
        "commit_text": "because we dont init all fields (capab ?) of the dumped structure.  Use C99 initializers so that holes and non explicit fields are zeroed.  ",
        "func_before": "static inline int tcf_skbedit_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t\tint bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbedit *d = a->priv;\n\tstruct tc_skbedit opt;\n\tstruct tcf_t t;\n\n\topt.index = d->tcf_index;\n\topt.refcnt = d->tcf_refcnt - ref;\n\topt.bindcnt = d->tcf_bindcnt - bind;\n\topt.action = d->tcf_action;\n\tNLA_PUT(skb, TCA_SKBEDIT_PARMS, sizeof(opt), &opt);\n\tif (d->flags & SKBEDIT_F_PRIORITY)\n\t\tNLA_PUT(skb, TCA_SKBEDIT_PRIORITY, sizeof(d->priority),\n\t\t\t&d->priority);\n\tif (d->flags & SKBEDIT_F_QUEUE_MAPPING)\n\t\tNLA_PUT(skb, TCA_SKBEDIT_QUEUE_MAPPING,\n\t\t\tsizeof(d->queue_mapping), &d->queue_mapping);\n\tif (d->flags & SKBEDIT_F_MARK)\n\t\tNLA_PUT(skb, TCA_SKBEDIT_MARK, sizeof(d->mark),\n\t\t\t&d->mark);\n\tt.install = jiffies_to_clock_t(jiffies - d->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - d->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(d->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_SKBEDIT_TM, sizeof(t), &t);\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "func": "static inline int tcf_skbedit_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t\tint bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_skbedit *d = a->priv;\n\tstruct tc_skbedit opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = d->tcf_refcnt - ref,\n\t\t.bindcnt = d->tcf_bindcnt - bind,\n\t\t.action  = d->tcf_action,\n\t};\n\tstruct tcf_t t;\n\n\tNLA_PUT(skb, TCA_SKBEDIT_PARMS, sizeof(opt), &opt);\n\tif (d->flags & SKBEDIT_F_PRIORITY)\n\t\tNLA_PUT(skb, TCA_SKBEDIT_PRIORITY, sizeof(d->priority),\n\t\t\t&d->priority);\n\tif (d->flags & SKBEDIT_F_QUEUE_MAPPING)\n\t\tNLA_PUT(skb, TCA_SKBEDIT_QUEUE_MAPPING,\n\t\t\tsizeof(d->queue_mapping), &d->queue_mapping);\n\tif (d->flags & SKBEDIT_F_MARK)\n\t\tNLA_PUT(skb, TCA_SKBEDIT_MARK, sizeof(d->mark),\n\t\t\t&d->mark);\n\tt.install = jiffies_to_clock_t(jiffies - d->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - d->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(d->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_SKBEDIT_TM, sizeof(t), &t);\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,13 +3,14 @@\n {\n \tunsigned char *b = skb_tail_pointer(skb);\n \tstruct tcf_skbedit *d = a->priv;\n-\tstruct tc_skbedit opt;\n+\tstruct tc_skbedit opt = {\n+\t\t.index   = d->tcf_index,\n+\t\t.refcnt  = d->tcf_refcnt - ref,\n+\t\t.bindcnt = d->tcf_bindcnt - bind,\n+\t\t.action  = d->tcf_action,\n+\t};\n \tstruct tcf_t t;\n \n-\topt.index = d->tcf_index;\n-\topt.refcnt = d->tcf_refcnt - ref;\n-\topt.bindcnt = d->tcf_bindcnt - bind;\n-\topt.action = d->tcf_action;\n \tNLA_PUT(skb, TCA_SKBEDIT_PARMS, sizeof(opt), &opt);\n \tif (d->flags & SKBEDIT_F_PRIORITY)\n \t\tNLA_PUT(skb, TCA_SKBEDIT_PRIORITY, sizeof(d->priority),",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct tc_skbedit opt;",
                "\topt.index = d->tcf_index;",
                "\topt.refcnt = d->tcf_refcnt - ref;",
                "\topt.bindcnt = d->tcf_bindcnt - bind;",
                "\topt.action = d->tcf_action;"
            ],
            "added_lines": [
                "\tstruct tc_skbedit opt = {",
                "\t\t.index   = d->tcf_index,",
                "\t\t.refcnt  = d->tcf_refcnt - ref,",
                "\t\t.bindcnt = d->tcf_bindcnt - bind,",
                "\t\t.action  = d->tcf_action,",
                "\t};"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2942",
        "func_name": "kernel/git/netdev/net/tcf_gact_dump",
        "description": "The actions implementation in the network queueing functionality in the Linux kernel before 2.6.36-rc2 does not properly initialize certain structure members when performing dump operations, which allows local users to obtain potentially sensitive information from kernel memory via vectors related to (1) the tcf_gact_dump function in net/sched/act_gact.c, (2) the tcf_mirred_dump function in net/sched/act_mirred.c, (3) the tcf_nat_dump function in net/sched/act_nat.c, (4) the tcf_simp_dump function in net/sched/act_simple.c, and (5) the tcf_skbedit_dump function in net/sched/act_skbedit.c.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net.git;a=commit;h=1c40be12f7d8ca1d387510d39787b12e512a7ce8",
        "commit_title": "We leak at least 32bits of kernel memory to user land in tc dump,",
        "commit_text": "because we dont init all fields (capab ?) of the dumped structure.  Use C99 initializers so that holes and non explicit fields are zeroed.  ",
        "func_before": "static int tcf_gact_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tc_gact opt;\n\tstruct tcf_gact *gact = a->priv;\n\tstruct tcf_t t;\n\n\topt.index = gact->tcf_index;\n\topt.refcnt = gact->tcf_refcnt - ref;\n\topt.bindcnt = gact->tcf_bindcnt - bind;\n\topt.action = gact->tcf_action;\n\tNLA_PUT(skb, TCA_GACT_PARMS, sizeof(opt), &opt);\n#ifdef CONFIG_GACT_PROB\n\tif (gact->tcfg_ptype) {\n\t\tstruct tc_gact_p p_opt;\n\t\tp_opt.paction = gact->tcfg_paction;\n\t\tp_opt.pval = gact->tcfg_pval;\n\t\tp_opt.ptype = gact->tcfg_ptype;\n\t\tNLA_PUT(skb, TCA_GACT_PROB, sizeof(p_opt), &p_opt);\n\t}\n#endif\n\tt.install = jiffies_to_clock_t(jiffies - gact->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - gact->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(gact->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_GACT_TM, sizeof(t), &t);\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "func": "static int tcf_gact_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_gact *gact = a->priv;\n\tstruct tc_gact opt = {\n\t\t.index   = gact->tcf_index,\n\t\t.refcnt  = gact->tcf_refcnt - ref,\n\t\t.bindcnt = gact->tcf_bindcnt - bind,\n\t\t.action  = gact->tcf_action,\n\t};\n\tstruct tcf_t t;\n\n\tNLA_PUT(skb, TCA_GACT_PARMS, sizeof(opt), &opt);\n#ifdef CONFIG_GACT_PROB\n\tif (gact->tcfg_ptype) {\n\t\tstruct tc_gact_p p_opt = {\n\t\t\t.paction = gact->tcfg_paction,\n\t\t\t.pval    = gact->tcfg_pval,\n\t\t\t.ptype   = gact->tcfg_ptype,\n\t\t};\n\n\t\tNLA_PUT(skb, TCA_GACT_PROB, sizeof(p_opt), &p_opt);\n\t}\n#endif\n\tt.install = jiffies_to_clock_t(jiffies - gact->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - gact->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(gact->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_GACT_TM, sizeof(t), &t);\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,21 +1,24 @@\n static int tcf_gact_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\n {\n \tunsigned char *b = skb_tail_pointer(skb);\n-\tstruct tc_gact opt;\n \tstruct tcf_gact *gact = a->priv;\n+\tstruct tc_gact opt = {\n+\t\t.index   = gact->tcf_index,\n+\t\t.refcnt  = gact->tcf_refcnt - ref,\n+\t\t.bindcnt = gact->tcf_bindcnt - bind,\n+\t\t.action  = gact->tcf_action,\n+\t};\n \tstruct tcf_t t;\n \n-\topt.index = gact->tcf_index;\n-\topt.refcnt = gact->tcf_refcnt - ref;\n-\topt.bindcnt = gact->tcf_bindcnt - bind;\n-\topt.action = gact->tcf_action;\n \tNLA_PUT(skb, TCA_GACT_PARMS, sizeof(opt), &opt);\n #ifdef CONFIG_GACT_PROB\n \tif (gact->tcfg_ptype) {\n-\t\tstruct tc_gact_p p_opt;\n-\t\tp_opt.paction = gact->tcfg_paction;\n-\t\tp_opt.pval = gact->tcfg_pval;\n-\t\tp_opt.ptype = gact->tcfg_ptype;\n+\t\tstruct tc_gact_p p_opt = {\n+\t\t\t.paction = gact->tcfg_paction,\n+\t\t\t.pval    = gact->tcfg_pval,\n+\t\t\t.ptype   = gact->tcfg_ptype,\n+\t\t};\n+\n \t\tNLA_PUT(skb, TCA_GACT_PROB, sizeof(p_opt), &p_opt);\n \t}\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct tc_gact opt;",
                "\topt.index = gact->tcf_index;",
                "\topt.refcnt = gact->tcf_refcnt - ref;",
                "\topt.bindcnt = gact->tcf_bindcnt - bind;",
                "\topt.action = gact->tcf_action;",
                "\t\tstruct tc_gact_p p_opt;",
                "\t\tp_opt.paction = gact->tcfg_paction;",
                "\t\tp_opt.pval = gact->tcfg_pval;",
                "\t\tp_opt.ptype = gact->tcfg_ptype;"
            ],
            "added_lines": [
                "\tstruct tc_gact opt = {",
                "\t\t.index   = gact->tcf_index,",
                "\t\t.refcnt  = gact->tcf_refcnt - ref,",
                "\t\t.bindcnt = gact->tcf_bindcnt - bind,",
                "\t\t.action  = gact->tcf_action,",
                "\t};",
                "\t\tstruct tc_gact_p p_opt = {",
                "\t\t\t.paction = gact->tcfg_paction,",
                "\t\t\t.pval    = gact->tcfg_pval,",
                "\t\t\t.ptype   = gact->tcfg_ptype,",
                "\t\t};",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2942",
        "func_name": "kernel/git/netdev/net/tcf_nat_dump",
        "description": "The actions implementation in the network queueing functionality in the Linux kernel before 2.6.36-rc2 does not properly initialize certain structure members when performing dump operations, which allows local users to obtain potentially sensitive information from kernel memory via vectors related to (1) the tcf_gact_dump function in net/sched/act_gact.c, (2) the tcf_mirred_dump function in net/sched/act_mirred.c, (3) the tcf_nat_dump function in net/sched/act_nat.c, (4) the tcf_simp_dump function in net/sched/act_simple.c, and (5) the tcf_skbedit_dump function in net/sched/act_skbedit.c.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net.git;a=commit;h=1c40be12f7d8ca1d387510d39787b12e512a7ce8",
        "commit_title": "We leak at least 32bits of kernel memory to user land in tc dump,",
        "commit_text": "because we dont init all fields (capab ?) of the dumped structure.  Use C99 initializers so that holes and non explicit fields are zeroed.  ",
        "func_before": "static int tcf_nat_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\tint bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_nat *p = a->priv;\n\tstruct tc_nat opt;\n\tstruct tcf_t t;\n\n\topt.old_addr = p->old_addr;\n\topt.new_addr = p->new_addr;\n\topt.mask = p->mask;\n\topt.flags = p->flags;\n\n\topt.index = p->tcf_index;\n\topt.action = p->tcf_action;\n\topt.refcnt = p->tcf_refcnt - ref;\n\topt.bindcnt = p->tcf_bindcnt - bind;\n\n\tNLA_PUT(skb, TCA_NAT_PARMS, sizeof(opt), &opt);\n\tt.install = jiffies_to_clock_t(jiffies - p->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - p->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(p->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_NAT_TM, sizeof(t), &t);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "func": "static int tcf_nat_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\tint bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_nat *p = a->priv;\n\tstruct tc_nat opt = {\n\t\t.old_addr = p->old_addr,\n\t\t.new_addr = p->new_addr,\n\t\t.mask     = p->mask,\n\t\t.flags    = p->flags,\n\n\t\t.index    = p->tcf_index,\n\t\t.action   = p->tcf_action,\n\t\t.refcnt   = p->tcf_refcnt - ref,\n\t\t.bindcnt  = p->tcf_bindcnt - bind,\n\t};\n\tstruct tcf_t t;\n\n\tNLA_PUT(skb, TCA_NAT_PARMS, sizeof(opt), &opt);\n\tt.install = jiffies_to_clock_t(jiffies - p->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - p->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(p->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_NAT_TM, sizeof(t), &t);\n\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,18 +3,18 @@\n {\n \tunsigned char *b = skb_tail_pointer(skb);\n \tstruct tcf_nat *p = a->priv;\n-\tstruct tc_nat opt;\n+\tstruct tc_nat opt = {\n+\t\t.old_addr = p->old_addr,\n+\t\t.new_addr = p->new_addr,\n+\t\t.mask     = p->mask,\n+\t\t.flags    = p->flags,\n+\n+\t\t.index    = p->tcf_index,\n+\t\t.action   = p->tcf_action,\n+\t\t.refcnt   = p->tcf_refcnt - ref,\n+\t\t.bindcnt  = p->tcf_bindcnt - bind,\n+\t};\n \tstruct tcf_t t;\n-\n-\topt.old_addr = p->old_addr;\n-\topt.new_addr = p->new_addr;\n-\topt.mask = p->mask;\n-\topt.flags = p->flags;\n-\n-\topt.index = p->tcf_index;\n-\topt.action = p->tcf_action;\n-\topt.refcnt = p->tcf_refcnt - ref;\n-\topt.bindcnt = p->tcf_bindcnt - bind;\n \n \tNLA_PUT(skb, TCA_NAT_PARMS, sizeof(opt), &opt);\n \tt.install = jiffies_to_clock_t(jiffies - p->tcf_tm.install);",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct tc_nat opt;",
                "",
                "\topt.old_addr = p->old_addr;",
                "\topt.new_addr = p->new_addr;",
                "\topt.mask = p->mask;",
                "\topt.flags = p->flags;",
                "",
                "\topt.index = p->tcf_index;",
                "\topt.action = p->tcf_action;",
                "\topt.refcnt = p->tcf_refcnt - ref;",
                "\topt.bindcnt = p->tcf_bindcnt - bind;"
            ],
            "added_lines": [
                "\tstruct tc_nat opt = {",
                "\t\t.old_addr = p->old_addr,",
                "\t\t.new_addr = p->new_addr,",
                "\t\t.mask     = p->mask,",
                "\t\t.flags    = p->flags,",
                "",
                "\t\t.index    = p->tcf_index,",
                "\t\t.action   = p->tcf_action,",
                "\t\t.refcnt   = p->tcf_refcnt - ref,",
                "\t\t.bindcnt  = p->tcf_bindcnt - bind,",
                "\t};"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2942",
        "func_name": "kernel/git/netdev/net/tcf_simp_dump",
        "description": "The actions implementation in the network queueing functionality in the Linux kernel before 2.6.36-rc2 does not properly initialize certain structure members when performing dump operations, which allows local users to obtain potentially sensitive information from kernel memory via vectors related to (1) the tcf_gact_dump function in net/sched/act_gact.c, (2) the tcf_mirred_dump function in net/sched/act_mirred.c, (3) the tcf_nat_dump function in net/sched/act_nat.c, (4) the tcf_simp_dump function in net/sched/act_simple.c, and (5) the tcf_skbedit_dump function in net/sched/act_skbedit.c.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net.git;a=commit;h=1c40be12f7d8ca1d387510d39787b12e512a7ce8",
        "commit_title": "We leak at least 32bits of kernel memory to user land in tc dump,",
        "commit_text": "because we dont init all fields (capab ?) of the dumped structure.  Use C99 initializers so that holes and non explicit fields are zeroed.  ",
        "func_before": "static inline int tcf_simp_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t\tint bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_defact *d = a->priv;\n\tstruct tc_defact opt;\n\tstruct tcf_t t;\n\n\topt.index = d->tcf_index;\n\topt.refcnt = d->tcf_refcnt - ref;\n\topt.bindcnt = d->tcf_bindcnt - bind;\n\topt.action = d->tcf_action;\n\tNLA_PUT(skb, TCA_DEF_PARMS, sizeof(opt), &opt);\n\tNLA_PUT_STRING(skb, TCA_DEF_DATA, d->tcfd_defdata);\n\tt.install = jiffies_to_clock_t(jiffies - d->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - d->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(d->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_DEF_TM, sizeof(t), &t);\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "func": "static inline int tcf_simp_dump(struct sk_buff *skb, struct tc_action *a,\n\t\t\t\tint bind, int ref)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct tcf_defact *d = a->priv;\n\tstruct tc_defact opt = {\n\t\t.index   = d->tcf_index,\n\t\t.refcnt  = d->tcf_refcnt - ref,\n\t\t.bindcnt = d->tcf_bindcnt - bind,\n\t\t.action  = d->tcf_action,\n\t};\n\tstruct tcf_t t;\n\n\tNLA_PUT(skb, TCA_DEF_PARMS, sizeof(opt), &opt);\n\tNLA_PUT_STRING(skb, TCA_DEF_DATA, d->tcfd_defdata);\n\tt.install = jiffies_to_clock_t(jiffies - d->tcf_tm.install);\n\tt.lastuse = jiffies_to_clock_t(jiffies - d->tcf_tm.lastuse);\n\tt.expires = jiffies_to_clock_t(d->tcf_tm.expires);\n\tNLA_PUT(skb, TCA_DEF_TM, sizeof(t), &t);\n\treturn skb->len;\n\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,13 +3,14 @@\n {\n \tunsigned char *b = skb_tail_pointer(skb);\n \tstruct tcf_defact *d = a->priv;\n-\tstruct tc_defact opt;\n+\tstruct tc_defact opt = {\n+\t\t.index   = d->tcf_index,\n+\t\t.refcnt  = d->tcf_refcnt - ref,\n+\t\t.bindcnt = d->tcf_bindcnt - bind,\n+\t\t.action  = d->tcf_action,\n+\t};\n \tstruct tcf_t t;\n \n-\topt.index = d->tcf_index;\n-\topt.refcnt = d->tcf_refcnt - ref;\n-\topt.bindcnt = d->tcf_bindcnt - bind;\n-\topt.action = d->tcf_action;\n \tNLA_PUT(skb, TCA_DEF_PARMS, sizeof(opt), &opt);\n \tNLA_PUT_STRING(skb, TCA_DEF_DATA, d->tcfd_defdata);\n \tt.install = jiffies_to_clock_t(jiffies - d->tcf_tm.install);",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct tc_defact opt;",
                "\topt.index = d->tcf_index;",
                "\topt.refcnt = d->tcf_refcnt - ref;",
                "\topt.bindcnt = d->tcf_bindcnt - bind;",
                "\topt.action = d->tcf_action;"
            ],
            "added_lines": [
                "\tstruct tc_defact opt = {",
                "\t\t.index   = d->tcf_index,",
                "\t\t.refcnt  = d->tcf_refcnt - ref,",
                "\t\t.bindcnt = d->tcf_bindcnt - bind,",
                "\t\t.action  = d->tcf_action,",
                "\t};"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10155",
        "func_name": "qemu/i6300esb_class_init",
        "description": "Memory leak in hw/watchdog/wdt_i6300esb.c in QEMU (aka Quick Emulator) allows local guest OS privileged users to cause a denial of service (host memory consumption and QEMU process crash) via a large number of device unplug operations.",
        "git_url": "https://github.com/qemu/qemu/commit/eb7a20a3616085d46aa6b4b4224e15587ec67e6e",
        "commit_title": "watchdog: 6300esb: add exit function",
        "commit_text": " When the Intel 6300ESB watchdog is hot unplug. The timer allocated in realize isn't freed thus leaking memory leak. This patch avoid this through adding the exit function.  Message-Id: <583cde9c.3223ed0a.7f0c2.886e@mx.google.com>",
        "func_before": "static void i6300esb_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->config_read = i6300esb_config_read;\n    k->config_write = i6300esb_config_write;\n    k->realize = i6300esb_realize;\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n    k->device_id = PCI_DEVICE_ID_INTEL_ESB_9;\n    k->class_id = PCI_CLASS_SYSTEM_OTHER;\n    dc->reset = i6300esb_reset;\n    dc->vmsd = &vmstate_i6300esb;\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n}",
        "func": "static void i6300esb_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    k->config_read = i6300esb_config_read;\n    k->config_write = i6300esb_config_write;\n    k->realize = i6300esb_realize;\n    k->exit = i6300esb_exit;\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n    k->device_id = PCI_DEVICE_ID_INTEL_ESB_9;\n    k->class_id = PCI_CLASS_SYSTEM_OTHER;\n    dc->reset = i6300esb_reset;\n    dc->vmsd = &vmstate_i6300esb;\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n     k->config_read = i6300esb_config_read;\n     k->config_write = i6300esb_config_write;\n     k->realize = i6300esb_realize;\n+    k->exit = i6300esb_exit;\n     k->vendor_id = PCI_VENDOR_ID_INTEL;\n     k->device_id = PCI_DEVICE_ID_INTEL_ESB_9;\n     k->class_id = PCI_CLASS_SYSTEM_OTHER;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    k->exit = i6300esb_exit;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-5552",
        "func_name": "qemu/virgl_resource_attach_backing",
        "description": "Memory leak in the virgl_resource_attach_backing function in hw/display/virtio-gpu-3d.c in QEMU (aka Quick Emulator) allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING commands.",
        "git_url": "https://github.com/qemu/qemu/commit/33243031dad02d161225ba99d782616da133f689",
        "commit_title": "virtio-gpu-3d: fix memory leak in resource attach backing",
        "commit_text": " If the virgl_renderer_resource_attach_iov function fails the 'res_iovs' will be leaked. Add check of the return value to free the 'res_iovs' when failing. ",
        "func_before": "static void virgl_resource_attach_backing(VirtIOGPU *g,\n                                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_attach_backing att_rb;\n    struct iovec *res_iovs;\n    int ret;\n\n    VIRTIO_GPU_FILL_CMD(att_rb);\n    trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);\n\n    ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    virgl_renderer_resource_attach_iov(att_rb.resource_id,\n                                       res_iovs, att_rb.nr_entries);\n}",
        "func": "static void virgl_resource_attach_backing(VirtIOGPU *g,\n                                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_attach_backing att_rb;\n    struct iovec *res_iovs;\n    int ret;\n\n    VIRTIO_GPU_FILL_CMD(att_rb);\n    trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);\n\n    ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    ret = virgl_renderer_resource_attach_iov(att_rb.resource_id,\n                                             res_iovs, att_rb.nr_entries);\n\n    if (ret != 0)\n        virtio_gpu_cleanup_mapping_iov(res_iovs, att_rb.nr_entries);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,9 @@\n         return;\n     }\n \n-    virgl_renderer_resource_attach_iov(att_rb.resource_id,\n-                                       res_iovs, att_rb.nr_entries);\n+    ret = virgl_renderer_resource_attach_iov(att_rb.resource_id,\n+                                             res_iovs, att_rb.nr_entries);\n+\n+    if (ret != 0)\n+        virtio_gpu_cleanup_mapping_iov(res_iovs, att_rb.nr_entries);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    virgl_renderer_resource_attach_iov(att_rb.resource_id,",
                "                                       res_iovs, att_rb.nr_entries);"
            ],
            "added_lines": [
                "    ret = virgl_renderer_resource_attach_iov(att_rb.resource_id,",
                "                                             res_iovs, att_rb.nr_entries);",
                "",
                "    if (ret != 0)",
                "        virtio_gpu_cleanup_mapping_iov(res_iovs, att_rb.nr_entries);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-5578",
        "func_name": "qemu/virtio_gpu_resource_attach_backing",
        "description": "Memory leak in the virtio_gpu_resource_attach_backing function in hw/display/virtio-gpu.c in QEMU (aka Quick Emulator) allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING commands.",
        "git_url": "https://github.com/qemu/qemu/commit/204f01b30975923c64006f8067f0937b91eea68b",
        "commit_title": "virtio-gpu: fix memory leak in resource attach backing",
        "commit_text": " In the resource attach backing function, everytime it will allocate 'res->iov' thus can leading a memory leak. This patch avoid this. ",
        "func_before": "static void\nvirtio_gpu_resource_attach_backing(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n\n    VIRTIO_GPU_FILL_CMD(ab);\n    trace_virtio_gpu_cmd_res_back_attach(ab.resource_id);\n\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n\n    ret = virtio_gpu_create_mapping_iov(&ab, cmd, &res->addrs, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    res->iov_cnt = ab.nr_entries;\n}",
        "func": "static void\nvirtio_gpu_resource_attach_backing(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n\n    VIRTIO_GPU_FILL_CMD(ab);\n    trace_virtio_gpu_cmd_res_back_attach(ab.resource_id);\n\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n\n    if (res->iov) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    ret = virtio_gpu_create_mapping_iov(&ab, cmd, &res->addrs, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    res->iov_cnt = ab.nr_entries;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,11 @@\n         return;\n     }\n \n+    if (res->iov) {\n+        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n+        return;\n+    }\n+\n     ret = virtio_gpu_create_mapping_iov(&ab, cmd, &res->addrs, &res->iov);\n     if (ret != 0) {\n         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (res->iov) {",
                "        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;",
                "        return;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9060",
        "func_name": "qemu/virtio_gpu_set_scanout",
        "description": "Memory leak in the virtio_gpu_set_scanout function in hw/display/virtio-gpu.c in QEMU (aka Quick Emulator) allows local guest OS users to cause a denial of service (memory consumption) via a large number of \"VIRTIO_GPU_CMD_SET_SCANOUT:\" commands.",
        "git_url": "https://github.com/qemu/qemu/commit/dd248ed7e204ee8a1873914e02b8b526e8f1b80d",
        "commit_title": "virtio-gpu: fix memory leak in set scanout",
        "commit_text": " In virtio_gpu_set_scanout function, when creating the 'rect' its refcount is set to 2, by pixman_image_create_bits and qemu_create_displaysurface_pixman function. This can lead a memory leak issues. This patch avoid this issue. ",
        "func_before": "static void virtio_gpu_set_scanout(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_scanout *scanout;\n    pixman_format_code_t format;\n    uint32_t offset;\n    int bpp;\n    struct virtio_gpu_set_scanout ss;\n\n    VIRTIO_GPU_FILL_CMD(ss);\n    trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,\n                                     ss.r.width, ss.r.height, ss.r.x, ss.r.y);\n\n    if (ss.scanout_id >= g->conf.max_outputs) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",\n                      __func__, ss.scanout_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\n        return;\n    }\n\n    g->enable = 1;\n    if (ss.resource_id == 0) {\n        scanout = &g->scanout[ss.scanout_id];\n        if (scanout->resource_id) {\n            res = virtio_gpu_find_resource(g, scanout->resource_id);\n            if (res) {\n                res->scanout_bitmask &= ~(1 << ss.scanout_id);\n            }\n        }\n        if (ss.scanout_id == 0) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"%s: illegal scanout id specified %d\",\n                          __func__, ss.scanout_id);\n            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\n            return;\n        }\n        dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, NULL);\n        scanout->ds = NULL;\n        scanout->width = 0;\n        scanout->height = 0;\n        return;\n    }\n\n    /* create a surface for this scanout */\n    res = virtio_gpu_find_resource(g, ss.resource_id);\n    if (!res) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, ss.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n\n    if (ss.r.x > res->width ||\n        ss.r.y > res->height ||\n        ss.r.width > res->width ||\n        ss.r.height > res->height ||\n        ss.r.x + ss.r.width > res->width ||\n        ss.r.y + ss.r.height > res->height) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout %d bounds for\"\n                      \" resource %d, (%d,%d)+%d,%d vs %d %d\\n\",\n                      __func__, ss.scanout_id, ss.resource_id, ss.r.x, ss.r.y,\n                      ss.r.width, ss.r.height, res->width, res->height);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;\n        return;\n    }\n\n    scanout = &g->scanout[ss.scanout_id];\n\n    format = pixman_image_get_format(res->image);\n    bpp = (PIXMAN_FORMAT_BPP(format) + 7) / 8;\n    offset = (ss.r.x * bpp) + ss.r.y * pixman_image_get_stride(res->image);\n    if (!scanout->ds || surface_data(scanout->ds)\n        != ((uint8_t *)pixman_image_get_data(res->image) + offset) ||\n        scanout->width != ss.r.width ||\n        scanout->height != ss.r.height) {\n        pixman_image_t *rect;\n        void *ptr = (uint8_t *)pixman_image_get_data(res->image) + offset;\n        rect = pixman_image_create_bits(format, ss.r.width, ss.r.height, ptr,\n                                        pixman_image_get_stride(res->image));\n        pixman_image_ref(res->image);\n        pixman_image_set_destroy_function(rect, virtio_unref_resource,\n                                          res->image);\n        /* realloc the surface ptr */\n        scanout->ds = qemu_create_displaysurface_pixman(rect);\n        if (!scanout->ds) {\n            cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n            return;\n        }\n        dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);\n    }\n\n    res->scanout_bitmask |= (1 << ss.scanout_id);\n    scanout->resource_id = ss.resource_id;\n    scanout->x = ss.r.x;\n    scanout->y = ss.r.y;\n    scanout->width = ss.r.width;\n    scanout->height = ss.r.height;\n}",
        "func": "static void virtio_gpu_set_scanout(VirtIOGPU *g,\n                                   struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_scanout *scanout;\n    pixman_format_code_t format;\n    uint32_t offset;\n    int bpp;\n    struct virtio_gpu_set_scanout ss;\n\n    VIRTIO_GPU_FILL_CMD(ss);\n    trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,\n                                     ss.r.width, ss.r.height, ss.r.x, ss.r.y);\n\n    if (ss.scanout_id >= g->conf.max_outputs) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",\n                      __func__, ss.scanout_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\n        return;\n    }\n\n    g->enable = 1;\n    if (ss.resource_id == 0) {\n        scanout = &g->scanout[ss.scanout_id];\n        if (scanout->resource_id) {\n            res = virtio_gpu_find_resource(g, scanout->resource_id);\n            if (res) {\n                res->scanout_bitmask &= ~(1 << ss.scanout_id);\n            }\n        }\n        if (ss.scanout_id == 0) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"%s: illegal scanout id specified %d\",\n                          __func__, ss.scanout_id);\n            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\n            return;\n        }\n        dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, NULL);\n        scanout->ds = NULL;\n        scanout->width = 0;\n        scanout->height = 0;\n        return;\n    }\n\n    /* create a surface for this scanout */\n    res = virtio_gpu_find_resource(g, ss.resource_id);\n    if (!res) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal resource specified %d\\n\",\n                      __func__, ss.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n\n    if (ss.r.x > res->width ||\n        ss.r.y > res->height ||\n        ss.r.width > res->width ||\n        ss.r.height > res->height ||\n        ss.r.x + ss.r.width > res->width ||\n        ss.r.y + ss.r.height > res->height) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout %d bounds for\"\n                      \" resource %d, (%d,%d)+%d,%d vs %d %d\\n\",\n                      __func__, ss.scanout_id, ss.resource_id, ss.r.x, ss.r.y,\n                      ss.r.width, ss.r.height, res->width, res->height);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;\n        return;\n    }\n\n    scanout = &g->scanout[ss.scanout_id];\n\n    format = pixman_image_get_format(res->image);\n    bpp = (PIXMAN_FORMAT_BPP(format) + 7) / 8;\n    offset = (ss.r.x * bpp) + ss.r.y * pixman_image_get_stride(res->image);\n    if (!scanout->ds || surface_data(scanout->ds)\n        != ((uint8_t *)pixman_image_get_data(res->image) + offset) ||\n        scanout->width != ss.r.width ||\n        scanout->height != ss.r.height) {\n        pixman_image_t *rect;\n        void *ptr = (uint8_t *)pixman_image_get_data(res->image) + offset;\n        rect = pixman_image_create_bits(format, ss.r.width, ss.r.height, ptr,\n                                        pixman_image_get_stride(res->image));\n        pixman_image_ref(res->image);\n        pixman_image_set_destroy_function(rect, virtio_unref_resource,\n                                          res->image);\n        /* realloc the surface ptr */\n        scanout->ds = qemu_create_displaysurface_pixman(rect);\n        if (!scanout->ds) {\n            cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n            return;\n        }\n        pixman_image_unref(rect);\n        dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);\n    }\n\n    res->scanout_bitmask |= (1 << ss.scanout_id);\n    scanout->resource_id = ss.resource_id;\n    scanout->x = ss.r.x;\n    scanout->y = ss.r.y;\n    scanout->width = ss.r.width;\n    scanout->height = ss.r.height;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -87,6 +87,7 @@\n             cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n             return;\n         }\n+        pixman_image_unref(rect);\n         dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        pixman_image_unref(rect);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9373",
        "func_name": "qemu/ahci_uninit",
        "description": "Memory leak in QEMU (aka Quick Emulator), when built with IDE AHCI Emulation support, allows local guest OS privileged users to cause a denial of service (memory consumption) by repeatedly hot-unplugging the AHCI device.",
        "git_url": "https://github.com/qemu/qemu/commit/d68f0f778e7f4fbd674627274267f269e40f0b04",
        "commit_title": "ide: ahci: call cleanup function in ahci unit",
        "commit_text": " This can avoid memory leak when hotunplug the ahci device. ",
        "func_before": "void ahci_uninit(AHCIState *s)\n{\n    g_free(s->dev);\n}",
        "func": "void ahci_uninit(AHCIState *s)\n{\n    int i, j;\n\n    for (i = 0; i < s->ports; i++) {\n        AHCIDevice *ad = &s->dev[i];\n\n        for (j = 0; j < 2; j++) {\n            IDEState *s = &ad->port.ifs[j];\n\n            ide_exit(s);\n        }\n    }\n\n    g_free(s->dev);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,16 @@\n void ahci_uninit(AHCIState *s)\n {\n+    int i, j;\n+\n+    for (i = 0; i < s->ports; i++) {\n+        AHCIDevice *ad = &s->dev[i];\n+\n+        for (j = 0; j < 2; j++) {\n+            IDEState *s = &ad->port.ifs[j];\n+\n+            ide_exit(s);\n+        }\n+    }\n+\n     g_free(s->dev);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    int i, j;",
                "",
                "    for (i = 0; i < s->ports; i++) {",
                "        AHCIDevice *ad = &s->dev[i];",
                "",
                "        for (j = 0; j < 2; j++) {",
                "            IDEState *s = &ad->port.ifs[j];",
                "",
                "            ide_exit(s);",
                "        }",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-9431",
        "func_name": "wireshark/dissect_lte_rrc_T_targetRAT_MessageContainer",
        "description": "In Wireshark 3.2.0 to 3.2.1, 3.0.0 to 3.0.8, and 2.6.0 to 2.6.14, the LTE RRC dissector could leak memory. This was addressed in epan/dissectors/packet-lte-rrc.c by adjusting certain append operations.",
        "git_url": "https://github.com/wireshark/wireshark/commit/086003c9d616906e08bbeeab9c17b3aa4c6ff850",
        "commit_title": "LTE RRC: fix a memory leak in composite TVB handling",
        "commit_text": " Bug: 16341 (cherry picked from commit adeeb7f2da801303768ce96e2cacf6a703a69c6f) Conflicts: \tepan/dissectors/packet-lte-rrc.c",
        "func_before": "static int\ndissect_lte_rrc_T_targetRAT_MessageContainer(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n  tvbuff_t *target_rat_msg_cont_tvb = NULL;\n  offset = dissect_per_octet_string(tvb, offset, actx, tree, hf_index,\n                                       NO_BOUND, NO_BOUND, FALSE, &target_rat_msg_cont_tvb);\n\n  if(target_rat_msg_cont_tvb){\n    guint8 byte;\n    proto_tree *subtree;\n    subtree = proto_item_add_subtree(actx->created_item, ett_lte_rrc_targetRAT_MessageContainer);\n    switch (private_data_get_rat_target_type(actx)){\n    case T_targetRAT_Type_utra:\n      /* utra */\n      if (rrc_irat_ho_to_utran_cmd_handle)\n        lte_rrc_call_dissector(rrc_irat_ho_to_utran_cmd_handle, target_rat_msg_cont_tvb, actx->pinfo, subtree);\n      break;\n    case T_targetRAT_Type_geran:\n      /* geran */\n      byte = tvb_get_guint8(target_rat_msg_cont_tvb, 0);\n      if (byte == 0x06) {\n        if (gsm_a_dtap_handle) {\n          lte_rrc_call_dissector(gsm_a_dtap_handle, target_rat_msg_cont_tvb, actx->pinfo, subtree);\n        }\n      } else {\n        if (gsm_rlcmac_dl_handle) {\n          tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();\n          guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);\n          pd[0] = 0x40;\n          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));\n          tvb_composite_append(gsm_rlcmac_dl_tvb, target_rat_msg_cont_tvb);\n          tvb_composite_finalize(gsm_rlcmac_dl_tvb);\n          add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, \"GPRS DL control block\");\n          lte_rrc_call_dissector(gsm_rlcmac_dl_handle, gsm_rlcmac_dl_tvb, actx->pinfo, subtree);\n        }\n      }\n      break;\n    case T_targetRAT_Type_cdma2000_1XRTT:\n      /* cdma2000-1XRTT */\n      break;\n    case T_targetRAT_Type_cdma2000_HRPD:\n      /* cdma2000-HRPD */\n      break;\n    default:\n      break;\n    }\n  }\n\n\n  return offset;\n}",
        "func": "static int\ndissect_lte_rrc_T_targetRAT_MessageContainer(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n  tvbuff_t *target_rat_msg_cont_tvb = NULL;\n  offset = dissect_per_octet_string(tvb, offset, actx, tree, hf_index,\n                                       NO_BOUND, NO_BOUND, FALSE, &target_rat_msg_cont_tvb);\n\n  if(target_rat_msg_cont_tvb){\n    guint8 byte;\n    proto_tree *subtree;\n    subtree = proto_item_add_subtree(actx->created_item, ett_lte_rrc_targetRAT_MessageContainer);\n    switch (private_data_get_rat_target_type(actx)){\n    case T_targetRAT_Type_utra:\n      /* utra */\n      if (rrc_irat_ho_to_utran_cmd_handle)\n        lte_rrc_call_dissector(rrc_irat_ho_to_utran_cmd_handle, target_rat_msg_cont_tvb, actx->pinfo, subtree);\n      break;\n    case T_targetRAT_Type_geran:\n      /* geran */\n      byte = tvb_get_guint8(target_rat_msg_cont_tvb, 0);\n      if (byte == 0x06) {\n        if (gsm_a_dtap_handle) {\n          lte_rrc_call_dissector(gsm_a_dtap_handle, target_rat_msg_cont_tvb, actx->pinfo, subtree);\n        }\n      } else {\n        if (gsm_rlcmac_dl_handle) {\n          tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();\n          guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);\n          pd[0] = 0x40;\n          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));\n          tvb_composite_append(gsm_rlcmac_dl_tvb, target_rat_msg_cont_tvb);\n          tvb_composite_finalize(gsm_rlcmac_dl_tvb);\n          add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, \"GPRS DL control block\");\n          lte_rrc_call_dissector(gsm_rlcmac_dl_handle, gsm_rlcmac_dl_tvb, actx->pinfo, subtree);\n        }\n      }\n      break;\n    case T_targetRAT_Type_cdma2000_1XRTT:\n      /* cdma2000-1XRTT */\n      break;\n    case T_targetRAT_Type_cdma2000_HRPD:\n      /* cdma2000-HRPD */\n      break;\n    default:\n      break;\n    }\n  }\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,7 @@\n           tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();\n           guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);\n           pd[0] = 0x40;\n-          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));\n+          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));\n           tvb_composite_append(gsm_rlcmac_dl_tvb, target_rat_msg_cont_tvb);\n           tvb_composite_finalize(gsm_rlcmac_dl_tvb);\n           add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, \"GPRS DL control block\");",
        "diff_line_info": {
            "deleted_lines": [
                "          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));"
            ],
            "added_lines": [
                "          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-9431",
        "func_name": "wireshark/dissect_lte_rrc_SystemInfoListGERAN_item",
        "description": "In Wireshark 3.2.0 to 3.2.1, 3.0.0 to 3.0.8, and 2.6.0 to 2.6.14, the LTE RRC dissector could leak memory. This was addressed in epan/dissectors/packet-lte-rrc.c by adjusting certain append operations.",
        "git_url": "https://github.com/wireshark/wireshark/commit/086003c9d616906e08bbeeab9c17b3aa4c6ff850",
        "commit_title": "LTE RRC: fix a memory leak in composite TVB handling",
        "commit_text": " Bug: 16341 (cherry picked from commit adeeb7f2da801303768ce96e2cacf6a703a69c6f) Conflicts: \tepan/dissectors/packet-lte-rrc.c",
        "func_before": "static int\ndissect_lte_rrc_SystemInfoListGERAN_item(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n  tvbuff_t *sys_info_list_tvb = NULL;\n  proto_tree *subtree;\n  offset = dissect_per_octet_string(tvb, offset, actx, tree, hf_index,\n                                       1, 23, FALSE, &sys_info_list_tvb);\n\n  if (sys_info_list_tvb) {\n    subtree = proto_item_add_subtree(actx->created_item, ett_lte_rrc_siPsiSibContainer);\n    switch (private_data_get_si_or_psi_geran(actx)) {\n    case SI_OrPSI_GERAN_si:\n      /* SI message */\n      if (gsm_a_dtap_handle) {\n        tvbuff_t *si_tvb = tvb_new_composite();\n        guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);\n        pd[0] = 0x06;\n        tvb_composite_append(si_tvb, tvb_new_real_data(pd, 1, 1));\n        tvb_composite_append(si_tvb, sys_info_list_tvb);\n        tvb_composite_finalize(si_tvb);\n        add_new_data_source(actx->pinfo, si_tvb, \"System Information\");\n        lte_rrc_call_dissector(gsm_a_dtap_handle, si_tvb, actx->pinfo, subtree);\n      }\n      break;\n    case SI_OrPSI_GERAN_psi:\n      /* PSI message */\n      if (gsm_rlcmac_dl_handle) {\n        tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();\n        guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);\n        pd[0] = 0x40;\n        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));\n        tvb_composite_append(gsm_rlcmac_dl_tvb, sys_info_list_tvb);\n        tvb_composite_finalize(gsm_rlcmac_dl_tvb);\n        add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, \"GPRS DL control block\");\n        lte_rrc_call_dissector(gsm_rlcmac_dl_handle, sys_info_list_tvb, actx->pinfo, subtree);\n      }\n      break;\n    default:\n      break;\n    }\n  }\n\n\n  return offset;\n}",
        "func": "static int\ndissect_lte_rrc_SystemInfoListGERAN_item(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {\n  tvbuff_t *sys_info_list_tvb = NULL;\n  proto_tree *subtree;\n  offset = dissect_per_octet_string(tvb, offset, actx, tree, hf_index,\n                                       1, 23, FALSE, &sys_info_list_tvb);\n\n  if (sys_info_list_tvb) {\n    subtree = proto_item_add_subtree(actx->created_item, ett_lte_rrc_siPsiSibContainer);\n    switch (private_data_get_si_or_psi_geran(actx)) {\n    case SI_OrPSI_GERAN_si:\n      /* SI message */\n      if (gsm_a_dtap_handle) {\n        tvbuff_t *si_tvb = tvb_new_composite();\n        guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);\n        pd[0] = 0x06;\n        tvb_composite_append(si_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));\n        tvb_composite_append(si_tvb, sys_info_list_tvb);\n        tvb_composite_finalize(si_tvb);\n        add_new_data_source(actx->pinfo, si_tvb, \"System Information\");\n        lte_rrc_call_dissector(gsm_a_dtap_handle, si_tvb, actx->pinfo, subtree);\n      }\n      break;\n    case SI_OrPSI_GERAN_psi:\n      /* PSI message */\n      if (gsm_rlcmac_dl_handle) {\n        tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();\n        guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);\n        pd[0] = 0x40;\n        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));\n        tvb_composite_append(gsm_rlcmac_dl_tvb, sys_info_list_tvb);\n        tvb_composite_finalize(gsm_rlcmac_dl_tvb);\n        add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, \"GPRS DL control block\");\n        lte_rrc_call_dissector(gsm_rlcmac_dl_handle, sys_info_list_tvb, actx->pinfo, subtree);\n      }\n      break;\n    default:\n      break;\n    }\n  }\n\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n         tvbuff_t *si_tvb = tvb_new_composite();\n         guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);\n         pd[0] = 0x06;\n-        tvb_composite_append(si_tvb, tvb_new_real_data(pd, 1, 1));\n+        tvb_composite_append(si_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));\n         tvb_composite_append(si_tvb, sys_info_list_tvb);\n         tvb_composite_finalize(si_tvb);\n         add_new_data_source(actx->pinfo, si_tvb, \"System Information\");\n@@ -27,7 +27,7 @@\n         tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();\n         guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);\n         pd[0] = 0x40;\n-        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));\n+        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));\n         tvb_composite_append(gsm_rlcmac_dl_tvb, sys_info_list_tvb);\n         tvb_composite_finalize(gsm_rlcmac_dl_tvb);\n         add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, \"GPRS DL control block\");",
        "diff_line_info": {
            "deleted_lines": [
                "        tvb_composite_append(si_tvb, tvb_new_real_data(pd, 1, 1));",
                "        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));"
            ],
            "added_lines": [
                "        tvb_composite_append(si_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));",
                "        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19577",
        "func_name": "xen-project/xen/amd_iommu_domain_init",
        "description": "An issue was discovered in Xen through 4.12.x allowing x86 AMD HVM guest OS users to cause a denial of service or possibly gain privileges by triggering data-structure access during pagetable-height updates. When running on AMD systems with an IOMMU, Xen attempted to dynamically adapt the number of levels of pagetables (the pagetable height) in the IOMMU according to the guest's address space size. The code to select and update the height had several bugs. Notably, the update was done without taking a lock which is necessary for safe operation. A malicious guest administrator can cause Xen to access data structures while they are being modified, causing Xen to crash. Privilege escalation is thought to be very difficult but cannot be ruled out. Additionally, there is a potential memory leak of 4kb per guest boot, under memory pressure. Only Xen on AMD CPUs is vulnerable. Xen running on Intel CPUs is not vulnerable. ARM systems are not vulnerable. Only systems where guests are given direct access to physical devices are vulnerable. Systems which do not use PCI pass-through are not vulnerable. Only HVM guests can exploit the vulnerability. PV and PVH guests cannot. All versions of Xen with IOMMU support are vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/b4f042236ae0bb6725b3e8dd40af5a2466a6f971",
        "commit_title": "AMD/IOMMU: Cease using a dynamic height for the IOMMU pagetables",
        "commit_text": " update_paging_mode() has multiple bugs:   1) Booting with iommu=debug will cause it to inform you that that it called     without the pdev_list lock held.  2) When growing by more than a single level, it leaks the newly allocated     table(s) in the case of a further error.  Furthermore, the choice of default level for a domain has issues:   1) All HVM guests grow from 2 to 3 levels during construction because of the     position of the VRAM just below the 4G boundary, so defaulting to 2 is a     waste of effort.  2) The limit for PV guests doesn't take memory hotplug into account, and     isn't dynamic at runtime like HVM guests.  This means that a PV guest may     get RAM which it can't map in the IOMMU.  The dynamic height is a property unique to AMD, and adds a substantial quantity of complexity for what is a marginal performance improvement.  Remove the complexity by removing the dynamic height.  PV guests now get 3 or 4 levels based on any hotplug regions in the host. This only makes a difference for hardware which previously had all RAM below the 512G boundary, and a hotplug region above.  HVM guests now get 4 levels (which will be sufficient until 256TB guests become a thing), because we don't currently have the information to know when 3 would be safe to use.  The overhead of this extra level is not expected to be noticeable.  It costs one page (4k) per domain, and one extra IO-TLB paging structure cache entry which is very hot and less likely to be evicted.  This is XSA-311. ",
        "func_before": "static int amd_iommu_domain_init(struct domain *d)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n\n    /* For pv and dom0, stick with get_paging_mode(max_page)\n     * For HVM dom0, use 2 level page table at first */\n    hd->arch.paging_mode = is_hvm_domain(d) ?\n        2 : amd_iommu_get_paging_mode(max_page);\n    return 0;\n}",
        "func": "static int amd_iommu_domain_init(struct domain *d)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n\n    /*\n     * Choose the number of levels for the IOMMU page tables.\n     * - PV needs 3 or 4, depending on whether there is RAM (including hotplug\n     *   RAM) above the 512G boundary.\n     * - HVM could in principle use 3 or 4 depending on how much guest\n     *   physical address space we give it, but this isn't known yet so use 4\n     *   unilaterally.\n     */\n    hd->arch.paging_mode = is_hvm_domain(d)\n        ? 4 : amd_iommu_get_paging_mode(get_upper_mfn_bound());\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,16 @@\n {\n     struct domain_iommu *hd = dom_iommu(d);\n \n-    /* For pv and dom0, stick with get_paging_mode(max_page)\n-     * For HVM dom0, use 2 level page table at first */\n-    hd->arch.paging_mode = is_hvm_domain(d) ?\n-        2 : amd_iommu_get_paging_mode(max_page);\n+    /*\n+     * Choose the number of levels for the IOMMU page tables.\n+     * - PV needs 3 or 4, depending on whether there is RAM (including hotplug\n+     *   RAM) above the 512G boundary.\n+     * - HVM could in principle use 3 or 4 depending on how much guest\n+     *   physical address space we give it, but this isn't known yet so use 4\n+     *   unilaterally.\n+     */\n+    hd->arch.paging_mode = is_hvm_domain(d)\n+        ? 4 : amd_iommu_get_paging_mode(get_upper_mfn_bound());\n+\n     return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    /* For pv and dom0, stick with get_paging_mode(max_page)",
                "     * For HVM dom0, use 2 level page table at first */",
                "    hd->arch.paging_mode = is_hvm_domain(d) ?",
                "        2 : amd_iommu_get_paging_mode(max_page);"
            ],
            "added_lines": [
                "    /*",
                "     * Choose the number of levels for the IOMMU page tables.",
                "     * - PV needs 3 or 4, depending on whether there is RAM (including hotplug",
                "     *   RAM) above the 512G boundary.",
                "     * - HVM could in principle use 3 or 4 depending on how much guest",
                "     *   physical address space we give it, but this isn't known yet so use 4",
                "     *   unilaterally.",
                "     */",
                "    hd->arch.paging_mode = is_hvm_domain(d)",
                "        ? 4 : amd_iommu_get_paging_mode(get_upper_mfn_bound());",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19577",
        "func_name": "xen-project/xen/amd_iommu_map_page",
        "description": "An issue was discovered in Xen through 4.12.x allowing x86 AMD HVM guest OS users to cause a denial of service or possibly gain privileges by triggering data-structure access during pagetable-height updates. When running on AMD systems with an IOMMU, Xen attempted to dynamically adapt the number of levels of pagetables (the pagetable height) in the IOMMU according to the guest's address space size. The code to select and update the height had several bugs. Notably, the update was done without taking a lock which is necessary for safe operation. A malicious guest administrator can cause Xen to access data structures while they are being modified, causing Xen to crash. Privilege escalation is thought to be very difficult but cannot be ruled out. Additionally, there is a potential memory leak of 4kb per guest boot, under memory pressure. Only Xen on AMD CPUs is vulnerable. Xen running on Intel CPUs is not vulnerable. ARM systems are not vulnerable. Only systems where guests are given direct access to physical devices are vulnerable. Systems which do not use PCI pass-through are not vulnerable. Only HVM guests can exploit the vulnerability. PV and PVH guests cannot. All versions of Xen with IOMMU support are vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/b4f042236ae0bb6725b3e8dd40af5a2466a6f971",
        "commit_title": "AMD/IOMMU: Cease using a dynamic height for the IOMMU pagetables",
        "commit_text": " update_paging_mode() has multiple bugs:   1) Booting with iommu=debug will cause it to inform you that that it called     without the pdev_list lock held.  2) When growing by more than a single level, it leaks the newly allocated     table(s) in the case of a further error.  Furthermore, the choice of default level for a domain has issues:   1) All HVM guests grow from 2 to 3 levels during construction because of the     position of the VRAM just below the 4G boundary, so defaulting to 2 is a     waste of effort.  2) The limit for PV guests doesn't take memory hotplug into account, and     isn't dynamic at runtime like HVM guests.  This means that a PV guest may     get RAM which it can't map in the IOMMU.  The dynamic height is a property unique to AMD, and adds a substantial quantity of complexity for what is a marginal performance improvement.  Remove the complexity by removing the dynamic height.  PV guests now get 3 or 4 levels based on any hotplug regions in the host. This only makes a difference for hardware which previously had all RAM below the 512G boundary, and a hotplug region above.  HVM guests now get 4 levels (which will be sufficient until 256TB guests become a thing), because we don't currently have the information to know when 3 would be safe to use.  The overhead of this extra level is not expected to be noticeable.  It costs one page (4k) per domain, and one extra IO-TLB paging structure cache entry which is very hot and less likely to be evicted.  This is XSA-311. ",
        "func_before": "int amd_iommu_map_page(struct domain *d, dfn_t dfn, mfn_t mfn,\n                       unsigned int flags, unsigned int *flush_flags)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int rc;\n    unsigned long pt_mfn[7];\n\n    memset(pt_mfn, 0, sizeof(pt_mfn));\n\n    spin_lock(&hd->arch.mapping_lock);\n\n    rc = amd_iommu_alloc_root(hd);\n    if ( rc )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\"Root table alloc failed, dfn = %\"PRI_dfn\"\\n\",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return rc;\n    }\n\n    /* Since HVM domain is initialized with 2 level IO page table,\n     * we might need a deeper page table for wider dfn now */\n    if ( is_hvm_domain(d) )\n    {\n        if ( update_paging_mode(d, dfn_x(dfn)) )\n        {\n            spin_unlock(&hd->arch.mapping_lock);\n            AMD_IOMMU_DEBUG(\"Update page mode failed dfn = %\"PRI_dfn\"\\n\",\n                            dfn_x(dfn));\n            domain_crash(d);\n            return -EFAULT;\n        }\n    }\n\n    if ( iommu_pde_from_dfn(d, dfn_x(dfn), pt_mfn, true) || (pt_mfn[1] == 0) )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\"Invalid IO pagetable entry dfn = %\"PRI_dfn\"\\n\",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return -EFAULT;\n    }\n\n    /* Install 4k mapping */\n    *flush_flags |= set_iommu_pte_present(pt_mfn[1], dfn_x(dfn), mfn_x(mfn),\n                                          1, (flags & IOMMUF_writable),\n                                          (flags & IOMMUF_readable));\n\n    spin_unlock(&hd->arch.mapping_lock);\n\n    return 0;\n}",
        "func": "int amd_iommu_map_page(struct domain *d, dfn_t dfn, mfn_t mfn,\n                       unsigned int flags, unsigned int *flush_flags)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int rc;\n    unsigned long pt_mfn[7];\n\n    memset(pt_mfn, 0, sizeof(pt_mfn));\n\n    spin_lock(&hd->arch.mapping_lock);\n\n    rc = amd_iommu_alloc_root(hd);\n    if ( rc )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\"Root table alloc failed, dfn = %\"PRI_dfn\"\\n\",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return rc;\n    }\n\n    if ( iommu_pde_from_dfn(d, dfn_x(dfn), pt_mfn, true) || (pt_mfn[1] == 0) )\n    {\n        spin_unlock(&hd->arch.mapping_lock);\n        AMD_IOMMU_DEBUG(\"Invalid IO pagetable entry dfn = %\"PRI_dfn\"\\n\",\n                        dfn_x(dfn));\n        domain_crash(d);\n        return -EFAULT;\n    }\n\n    /* Install 4k mapping */\n    *flush_flags |= set_iommu_pte_present(pt_mfn[1], dfn_x(dfn), mfn_x(mfn),\n                                          1, (flags & IOMMUF_writable),\n                                          (flags & IOMMUF_readable));\n\n    spin_unlock(&hd->arch.mapping_lock);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,20 +19,6 @@\n         return rc;\n     }\n \n-    /* Since HVM domain is initialized with 2 level IO page table,\n-     * we might need a deeper page table for wider dfn now */\n-    if ( is_hvm_domain(d) )\n-    {\n-        if ( update_paging_mode(d, dfn_x(dfn)) )\n-        {\n-            spin_unlock(&hd->arch.mapping_lock);\n-            AMD_IOMMU_DEBUG(\"Update page mode failed dfn = %\"PRI_dfn\"\\n\",\n-                            dfn_x(dfn));\n-            domain_crash(d);\n-            return -EFAULT;\n-        }\n-    }\n-\n     if ( iommu_pde_from_dfn(d, dfn_x(dfn), pt_mfn, true) || (pt_mfn[1] == 0) )\n     {\n         spin_unlock(&hd->arch.mapping_lock);",
        "diff_line_info": {
            "deleted_lines": [
                "    /* Since HVM domain is initialized with 2 level IO page table,",
                "     * we might need a deeper page table for wider dfn now */",
                "    if ( is_hvm_domain(d) )",
                "    {",
                "        if ( update_paging_mode(d, dfn_x(dfn)) )",
                "        {",
                "            spin_unlock(&hd->arch.mapping_lock);",
                "            AMD_IOMMU_DEBUG(\"Update page mode failed dfn = %\"PRI_dfn\"\\n\",",
                "                            dfn_x(dfn));",
                "            domain_crash(d);",
                "            return -EFAULT;",
                "        }",
                "    }",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2019-19956",
        "func_name": "GNOME/libxml2/xmlParseBalancedChunkMemoryRecover",
        "description": "xmlParseBalancedChunkMemoryRecover in parser.c in libxml2 before 2.9.10 has a memory leak related to newDoc->oldNs.",
        "git_url": "https://github.com/GNOME/libxml2/commit/5a02583c7e683896d84878bd90641d8d9b0d0549",
        "commit_title": "Fix memory leak in xmlParseBalancedChunkMemoryRecover",
        "commit_text": " When doc is NULL, namespace created in xmlTreeEnsureXMLDecl is bind to newDoc->oldNs, in this case, set newDoc->oldNs to NULL and free newDoc will cause a memory leak.  Found with libFuzzer.  Closes #82.",
        "func_before": "int\nxmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax,\n     void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst,\n     int recover) {\n    xmlParserCtxtPtr ctxt;\n    xmlDocPtr newDoc;\n    xmlSAXHandlerPtr oldsax = NULL;\n    xmlNodePtr content, newRoot;\n    int size;\n    int ret = 0;\n\n    if (depth > 40) {\n\treturn(XML_ERR_ENTITY_LOOP);\n    }\n\n\n    if (lst != NULL)\n        *lst = NULL;\n    if (string == NULL)\n        return(-1);\n\n    size = xmlStrlen(string);\n\n    ctxt = xmlCreateMemoryParserCtxt((char *) string, size);\n    if (ctxt == NULL) return(-1);\n    ctxt->userData = ctxt;\n    if (sax != NULL) {\n\toldsax = ctxt->sax;\n        ctxt->sax = sax;\n\tif (user_data != NULL)\n\t    ctxt->userData = user_data;\n    }\n    newDoc = xmlNewDoc(BAD_CAST \"1.0\");\n    if (newDoc == NULL) {\n\txmlFreeParserCtxt(ctxt);\n\treturn(-1);\n    }\n    newDoc->properties = XML_DOC_INTERNAL;\n    if ((doc != NULL) && (doc->dict != NULL)) {\n        xmlDictFree(ctxt->dict);\n\tctxt->dict = doc->dict;\n\txmlDictReference(ctxt->dict);\n\tctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST \"xml\", 3);\n\tctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST \"xmlns\", 5);\n\tctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);\n\tctxt->dictNames = 1;\n    } else {\n\txmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);\n    }\n    if (doc != NULL) {\n\tnewDoc->intSubset = doc->intSubset;\n\tnewDoc->extSubset = doc->extSubset;\n    }\n    newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST \"pseudoroot\", NULL);\n    if (newRoot == NULL) {\n\tif (sax != NULL)\n\t    ctxt->sax = oldsax;\n\txmlFreeParserCtxt(ctxt);\n\tnewDoc->intSubset = NULL;\n\tnewDoc->extSubset = NULL;\n        xmlFreeDoc(newDoc);\n\treturn(-1);\n    }\n    xmlAddChild((xmlNodePtr) newDoc, newRoot);\n    nodePush(ctxt, newRoot);\n    if (doc == NULL) {\n\tctxt->myDoc = newDoc;\n    } else {\n\tctxt->myDoc = newDoc;\n\tnewDoc->children->doc = doc;\n\t/* Ensure that doc has XML spec namespace */\n\txmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE);\n\tnewDoc->oldNs = doc->oldNs;\n    }\n    ctxt->instate = XML_PARSER_CONTENT;\n    ctxt->input_id = 2;\n    ctxt->depth = depth;\n\n    /*\n     * Doing validity checking on chunk doesn't make sense\n     */\n    ctxt->validate = 0;\n    ctxt->loadsubset = 0;\n    xmlDetectSAX2(ctxt);\n\n    if ( doc != NULL ){\n        content = doc->children;\n        doc->children = NULL;\n        xmlParseContent(ctxt);\n        doc->children = content;\n    }\n    else {\n        xmlParseContent(ctxt);\n    }\n    if ((RAW == '<') && (NXT(1) == '/')) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    } else if (RAW != 0) {\n\txmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n    }\n    if (ctxt->node != newDoc->children) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    }\n\n    if (!ctxt->wellFormed) {\n        if (ctxt->errNo == 0)\n\t    ret = 1;\n\telse\n\t    ret = ctxt->errNo;\n    } else {\n      ret = 0;\n    }\n\n    if ((lst != NULL) && ((ret == 0) || (recover == 1))) {\n\txmlNodePtr cur;\n\n\t/*\n\t * Return the newly created nodeset after unlinking it from\n\t * they pseudo parent.\n\t */\n\tcur = newDoc->children->children;\n\t*lst = cur;\n\twhile (cur != NULL) {\n\t    xmlSetTreeDoc(cur, doc);\n\t    cur->parent = NULL;\n\t    cur = cur->next;\n\t}\n\tnewDoc->children->children = NULL;\n    }\n\n    if (sax != NULL)\n\tctxt->sax = oldsax;\n    xmlFreeParserCtxt(ctxt);\n    newDoc->intSubset = NULL;\n    newDoc->extSubset = NULL;\n    newDoc->oldNs = NULL;\n    xmlFreeDoc(newDoc);\n\n    return(ret);\n}",
        "func": "int\nxmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax,\n     void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst,\n     int recover) {\n    xmlParserCtxtPtr ctxt;\n    xmlDocPtr newDoc;\n    xmlSAXHandlerPtr oldsax = NULL;\n    xmlNodePtr content, newRoot;\n    int size;\n    int ret = 0;\n\n    if (depth > 40) {\n\treturn(XML_ERR_ENTITY_LOOP);\n    }\n\n\n    if (lst != NULL)\n        *lst = NULL;\n    if (string == NULL)\n        return(-1);\n\n    size = xmlStrlen(string);\n\n    ctxt = xmlCreateMemoryParserCtxt((char *) string, size);\n    if (ctxt == NULL) return(-1);\n    ctxt->userData = ctxt;\n    if (sax != NULL) {\n\toldsax = ctxt->sax;\n        ctxt->sax = sax;\n\tif (user_data != NULL)\n\t    ctxt->userData = user_data;\n    }\n    newDoc = xmlNewDoc(BAD_CAST \"1.0\");\n    if (newDoc == NULL) {\n\txmlFreeParserCtxt(ctxt);\n\treturn(-1);\n    }\n    newDoc->properties = XML_DOC_INTERNAL;\n    if ((doc != NULL) && (doc->dict != NULL)) {\n        xmlDictFree(ctxt->dict);\n\tctxt->dict = doc->dict;\n\txmlDictReference(ctxt->dict);\n\tctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST \"xml\", 3);\n\tctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST \"xmlns\", 5);\n\tctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);\n\tctxt->dictNames = 1;\n    } else {\n\txmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);\n    }\n    if (doc != NULL) {\n\tnewDoc->intSubset = doc->intSubset;\n\tnewDoc->extSubset = doc->extSubset;\n    }\n    newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST \"pseudoroot\", NULL);\n    if (newRoot == NULL) {\n\tif (sax != NULL)\n\t    ctxt->sax = oldsax;\n\txmlFreeParserCtxt(ctxt);\n\tnewDoc->intSubset = NULL;\n\tnewDoc->extSubset = NULL;\n        xmlFreeDoc(newDoc);\n\treturn(-1);\n    }\n    xmlAddChild((xmlNodePtr) newDoc, newRoot);\n    nodePush(ctxt, newRoot);\n    if (doc == NULL) {\n\tctxt->myDoc = newDoc;\n    } else {\n\tctxt->myDoc = newDoc;\n\tnewDoc->children->doc = doc;\n\t/* Ensure that doc has XML spec namespace */\n\txmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE);\n\tnewDoc->oldNs = doc->oldNs;\n    }\n    ctxt->instate = XML_PARSER_CONTENT;\n    ctxt->input_id = 2;\n    ctxt->depth = depth;\n\n    /*\n     * Doing validity checking on chunk doesn't make sense\n     */\n    ctxt->validate = 0;\n    ctxt->loadsubset = 0;\n    xmlDetectSAX2(ctxt);\n\n    if ( doc != NULL ){\n        content = doc->children;\n        doc->children = NULL;\n        xmlParseContent(ctxt);\n        doc->children = content;\n    }\n    else {\n        xmlParseContent(ctxt);\n    }\n    if ((RAW == '<') && (NXT(1) == '/')) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    } else if (RAW != 0) {\n\txmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n    }\n    if (ctxt->node != newDoc->children) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    }\n\n    if (!ctxt->wellFormed) {\n        if (ctxt->errNo == 0)\n\t    ret = 1;\n\telse\n\t    ret = ctxt->errNo;\n    } else {\n      ret = 0;\n    }\n\n    if ((lst != NULL) && ((ret == 0) || (recover == 1))) {\n\txmlNodePtr cur;\n\n\t/*\n\t * Return the newly created nodeset after unlinking it from\n\t * they pseudo parent.\n\t */\n\tcur = newDoc->children->children;\n\t*lst = cur;\n\twhile (cur != NULL) {\n\t    xmlSetTreeDoc(cur, doc);\n\t    cur->parent = NULL;\n\t    cur = cur->next;\n\t}\n\tnewDoc->children->children = NULL;\n    }\n\n    if (sax != NULL)\n\tctxt->sax = oldsax;\n    xmlFreeParserCtxt(ctxt);\n    newDoc->intSubset = NULL;\n    newDoc->extSubset = NULL;\n    if(doc != NULL)\n\tnewDoc->oldNs = NULL;\n    xmlFreeDoc(newDoc);\n\n    return(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -132,7 +132,8 @@\n     xmlFreeParserCtxt(ctxt);\n     newDoc->intSubset = NULL;\n     newDoc->extSubset = NULL;\n-    newDoc->oldNs = NULL;\n+    if(doc != NULL)\n+\tnewDoc->oldNs = NULL;\n     xmlFreeDoc(newDoc);\n \n     return(ret);",
        "diff_line_info": {
            "deleted_lines": [
                "    newDoc->oldNs = NULL;"
            ],
            "added_lines": [
                "    if(doc != NULL)",
                "\tnewDoc->oldNs = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20023",
        "func_name": "saitoha/libsixel/sixel_decode_raw",
        "description": "A memory leak was discovered in image_buffer_resize in fromsixel.c in libsixel 1.8.4.",
        "git_url": "https://github.com/saitoha/libsixel/commit/b9a4175c803b50a863b0fbd8b8b49058ca725ea6",
        "commit_title": "Fix memory leak problem in fromsixel.c (#120)",
        "commit_text": "",
        "func_before": "SIXELAPI SIXELSTATUS\nsixel_decode_raw(\n    unsigned char       /* in */  *p,           /* sixel bytes */\n    int                 /* in */  len,          /* size of sixel bytes */\n    unsigned char       /* out */ **pixels,     /* decoded pixels */\n    int                 /* out */ *pwidth,      /* image width */\n    int                 /* out */ *pheight,     /* image height */\n    unsigned char       /* out */ **palette,    /* ARGB palette */\n    int                 /* out */ *ncolors,     /* palette size (<= 256) */\n    sixel_allocator_t   /* in */  *allocator)   /* allocator object or null */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    parser_context_t context;\n    image_buffer_t image;\n    int n;\n\n    if (allocator) {\n        sixel_allocator_ref(allocator);\n    } else {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            allocator = NULL;\n            goto end;\n        }\n    }\n\n    /* parser context initialization */\n    status = parser_context_init(&context);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    /* buffer initialization */\n    status = image_buffer_init(&image, 1, 1, context.bgindex, allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_decode_raw_impl(p, len, &image, &context, allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    *ncolors = image.ncolors + 1;\n    int alloc_size = *ncolors;\n    if (alloc_size < SIXEL_PALETTE_MAX) {\n        /* memory access range should be 0 <= 255 */\n        alloc_size = SIXEL_PALETTE_MAX;\n    }\n    *palette = (unsigned char *)sixel_allocator_malloc(allocator, (size_t)(alloc_size * 3));\n    if (palette == NULL) {\n        sixel_allocator_free(allocator, image.data);\n        sixel_helper_set_additional_message(\n            \"sixel_deocde_raw: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n    for (n = 0; n < *ncolors; ++n) {\n        (*palette)[n * 3 + 0] = image.palette[n] >> 16 & 0xff;\n        (*palette)[n * 3 + 1] = image.palette[n] >> 8 & 0xff;\n        (*palette)[n * 3 + 2] = image.palette[n] & 0xff;\n    }\n\n    *pwidth = image.width;\n    *pheight = image.height;\n    *pixels = image.data;\n\n    status = SIXEL_OK;\n\nend:\n    sixel_allocator_unref(allocator);\n    return status;\n}",
        "func": "SIXELAPI SIXELSTATUS\nsixel_decode_raw(\n    unsigned char       /* in */  *p,           /* sixel bytes */\n    int                 /* in */  len,          /* size of sixel bytes */\n    unsigned char       /* out */ **pixels,     /* decoded pixels */\n    int                 /* out */ *pwidth,      /* image width */\n    int                 /* out */ *pheight,     /* image height */\n    unsigned char       /* out */ **palette,    /* ARGB palette */\n    int                 /* out */ *ncolors,     /* palette size (<= 256) */\n    sixel_allocator_t   /* in */  *allocator)   /* allocator object or null */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    parser_context_t context;\n    image_buffer_t image;\n    int n;\n\n    image.data = NULL;\n\n    if (allocator) {\n        sixel_allocator_ref(allocator);\n    } else {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            allocator = NULL;\n            goto error;\n        }\n    }\n\n    /* parser context initialization */\n    status = parser_context_init(&context);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    /* buffer initialization */\n    status = image_buffer_init(&image, 1, 1, context.bgindex, allocator);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    status = sixel_decode_raw_impl(p, len, &image, &context, allocator);\n    if (SIXEL_FAILED(status)) {\n        goto error;\n    }\n\n    *ncolors = image.ncolors + 1;\n    int alloc_size = *ncolors;\n    if (alloc_size < SIXEL_PALETTE_MAX) {\n        /* memory access range should be 0 <= 255 */\n        alloc_size = SIXEL_PALETTE_MAX;\n    }\n    *palette = (unsigned char *)sixel_allocator_malloc(allocator, (size_t)(alloc_size * 3));\n    if (palette == NULL) {\n        sixel_allocator_free(allocator, image.data);\n        sixel_helper_set_additional_message(\n            \"sixel_deocde_raw: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto error;\n    }\n    for (n = 0; n < *ncolors; ++n) {\n        (*palette)[n * 3 + 0] = image.palette[n] >> 16 & 0xff;\n        (*palette)[n * 3 + 1] = image.palette[n] >> 8 & 0xff;\n        (*palette)[n * 3 + 2] = image.palette[n] & 0xff;\n    }\n\n    *pwidth = image.width;\n    *pheight = image.height;\n    *pixels = image.data;\n\n    status = SIXEL_OK;\n    goto end;\n\nerror:\n    free(image.data);\n    image.data = NULL;\n\nend:\n    sixel_allocator_unref(allocator);\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,31 +14,33 @@\n     image_buffer_t image;\n     int n;\n \n+    image.data = NULL;\n+\n     if (allocator) {\n         sixel_allocator_ref(allocator);\n     } else {\n         status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n         if (SIXEL_FAILED(status)) {\n             allocator = NULL;\n-            goto end;\n+            goto error;\n         }\n     }\n \n     /* parser context initialization */\n     status = parser_context_init(&context);\n     if (SIXEL_FAILED(status)) {\n-        goto end;\n+        goto error;\n     }\n \n     /* buffer initialization */\n     status = image_buffer_init(&image, 1, 1, context.bgindex, allocator);\n     if (SIXEL_FAILED(status)) {\n-        goto end;\n+        goto error;\n     }\n \n     status = sixel_decode_raw_impl(p, len, &image, &context, allocator);\n     if (SIXEL_FAILED(status)) {\n-        goto end;\n+        goto error;\n     }\n \n     *ncolors = image.ncolors + 1;\n@@ -53,7 +55,7 @@\n         sixel_helper_set_additional_message(\n             \"sixel_deocde_raw: sixel_allocator_malloc() failed.\");\n         status = SIXEL_BAD_ALLOCATION;\n-        goto end;\n+        goto error;\n     }\n     for (n = 0; n < *ncolors; ++n) {\n         (*palette)[n * 3 + 0] = image.palette[n] >> 16 & 0xff;\n@@ -66,6 +68,11 @@\n     *pixels = image.data;\n \n     status = SIXEL_OK;\n+    goto end;\n+\n+error:\n+    free(image.data);\n+    image.data = NULL;\n \n end:\n     sixel_allocator_unref(allocator);",
        "diff_line_info": {
            "deleted_lines": [
                "            goto end;",
                "        goto end;",
                "        goto end;",
                "        goto end;",
                "        goto end;"
            ],
            "added_lines": [
                "    image.data = NULL;",
                "",
                "            goto error;",
                "        goto error;",
                "        goto error;",
                "        goto error;",
                "        goto error;",
                "    goto end;",
                "",
                "error:",
                "    free(image.data);",
                "    image.data = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20052",
        "func_name": "tbeu/matio/SafeMulDims",
        "description": "A memory leak was discovered in Mat_VarCalloc in mat.c in matio 1.5.17 because SafeMulDims does not consider the rank==0 case.",
        "git_url": "https://github.com/tbeu/matio/commit/a47b7cd3aca70e9a0bddf8146eb4ab0cbd19c2c3",
        "commit_title": "Fix memory leak",
        "commit_text": " As reported by https://github.com/tbeu/matio/issues/131",
        "func_before": "int SafeMulDims(const matvar_t *matvar, size_t* nelems)\n{\n    int i;\n\n    for ( i = 0; i < matvar->rank; i++ ) {\n        if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {\n            *nelems = 0;\n            return 1;\n        }\n    }\n\n    return 0;\n}",
        "func": "int SafeMulDims(const matvar_t *matvar, size_t* nelems)\n{\n    int i;\n\n    if ( matvar->rank == 0 ) {\n        *nelems = 0;\n        return 0;\n    }\n\n    for ( i = 0; i < matvar->rank; i++ ) {\n        if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {\n            *nelems = 0;\n            return 1;\n        }\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,11 @@\n int SafeMulDims(const matvar_t *matvar, size_t* nelems)\n {\n     int i;\n+\n+    if ( matvar->rank == 0 ) {\n+        *nelems = 0;\n+        return 0;\n+    }\n \n     for ( i = 0; i < matvar->rank; i++ ) {\n         if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if ( matvar->rank == 0 ) {",
                "        *nelems = 0;",
                "        return 0;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20052",
        "func_name": "tbeu/matio/Mat_VarFree",
        "description": "A memory leak was discovered in Mat_VarCalloc in mat.c in matio 1.5.17 because SafeMulDims does not consider the rank==0 case.",
        "git_url": "https://github.com/tbeu/matio/commit/a47b7cd3aca70e9a0bddf8146eb4ab0cbd19c2c3",
        "commit_title": "Fix memory leak",
        "commit_text": " As reported by https://github.com/tbeu/matio/issues/131",
        "func_before": "void\nMat_VarFree(matvar_t *matvar)\n{\n    size_t nelems = 0;\n\n    if ( NULL == matvar )\n        return;\n    if ( NULL != matvar->dims ) {\n        nelems = 1;\n        SafeMulDims(matvar, &nelems);\n        free(matvar->dims);\n    }\n    if ( NULL != matvar->data ) {\n        switch (matvar->class_type ) {\n            case MAT_C_STRUCT:\n                if ( !matvar->mem_conserve ) {\n                    matvar_t **fields = (matvar_t**)matvar->data;\n                    size_t nelems_x_nfields, i;\n                    SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);\n                    for ( i = 0; i < nelems_x_nfields; i++ )\n                        Mat_VarFree(fields[i]);\n\n                    free(matvar->data);\n                }\n                break;\n            case MAT_C_CELL:\n                if ( !matvar->mem_conserve ) {\n                    matvar_t **cells = (matvar_t**)matvar->data;\n                    size_t i;\n                    for ( i = 0; i < nelems; i++ )\n                        Mat_VarFree(cells[i]);\n\n                    free(matvar->data);\n                }\n                break;\n            case MAT_C_SPARSE:\n                if ( !matvar->mem_conserve ) {\n                    mat_sparse_t *sparse;\n                    sparse = (mat_sparse_t*)matvar->data;\n                    if ( sparse->ir != NULL )\n                        free(sparse->ir);\n                    if ( sparse->jc != NULL )\n                        free(sparse->jc);\n                    if ( matvar->isComplex && NULL != sparse->data ) {\n                        ComplexFree((mat_complex_split_t*)sparse->data);\n                    } else if ( sparse->data != NULL ) {\n                        free(sparse->data);\n                    }\n                    free(sparse);\n                }\n                break;\n            case MAT_C_DOUBLE:\n            case MAT_C_SINGLE:\n            case MAT_C_INT64:\n            case MAT_C_UINT64:\n            case MAT_C_INT32:\n            case MAT_C_UINT32:\n            case MAT_C_INT16:\n            case MAT_C_UINT16:\n            case MAT_C_INT8:\n            case MAT_C_UINT8:\n            case MAT_C_CHAR:\n                if ( !matvar->mem_conserve ) {\n                    if ( matvar->isComplex ) {\n                        ComplexFree((mat_complex_split_t*)matvar->data);\n                    } else {\n                        free(matvar->data);\n                    }\n                }\n                break;\n            case MAT_C_FUNCTION:\n                if ( !matvar->mem_conserve ) {\n                    free(matvar->data);\n                }\n                break;\n            case MAT_C_EMPTY:\n            case MAT_C_OBJECT:\n            case MAT_C_OPAQUE:\n                break;\n        }\n    }\n\n    if ( NULL != matvar->internal ) {\n#if HAVE_ZLIB\n        if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n            inflateEnd(matvar->internal->z);\n            free(matvar->internal->z);\n            if ( matvar->class_type == MAT_C_SPARSE && NULL != matvar->internal->data ) {\n                mat_sparse_t *sparse;\n                sparse = (mat_sparse_t*)matvar->internal->data;\n                if ( sparse->ir != NULL )\n                    free(sparse->ir);\n                if ( sparse->jc != NULL )\n                    free(sparse->jc);\n                if ( matvar->isComplex && NULL != sparse->data ) {\n                    ComplexFree((mat_complex_split_t*)sparse->data);\n                } else if ( sparse->data != NULL ) {\n                    free(sparse->data);\n                }\n                free(sparse);\n            }\n            else if ( matvar->isComplex && NULL != matvar->internal->data ) {\n                ComplexFree((mat_complex_split_t*)matvar->internal->data);\n            } else if ( NULL != matvar->internal->data ) {\n                free(matvar->internal->data);\n            }\n        }\n#endif\n#if defined(MAT73) && MAT73\n        if ( -1 < matvar->internal->id ) {\n            switch ( H5Iget_type(matvar->internal->id) ) {\n                case H5I_GROUP:\n                    H5Gclose(matvar->internal->id);\n                    matvar->internal->id = -1;\n                    break;\n                case H5I_DATASET:\n                    H5Dclose(matvar->internal->id);\n                    matvar->internal->id = -1;\n                    break;\n                default:\n                    break;\n            }\n        }\n        if ( 0 < matvar->internal->hdf5_ref ) {\n            switch ( H5Iget_type(matvar->internal->id) ) {\n                case H5I_GROUP:\n                    H5Gclose(matvar->internal->id);\n                    matvar->internal->hdf5_ref = -1;\n                    break;\n                case H5I_DATASET:\n                    H5Dclose(matvar->internal->id);\n                    matvar->internal->hdf5_ref = -1;\n                    break;\n                default:\n                    break;\n            }\n        }\n        if ( NULL != matvar->internal->hdf5_name ) {\n            free(matvar->internal->hdf5_name);\n            matvar->internal->hdf5_name = NULL;\n        }\n#endif\n        if ( NULL != matvar->internal->fieldnames &&\n             matvar->internal->num_fields > 0 ) {\n            size_t i;\n            for ( i = 0; i < matvar->internal->num_fields; i++ ) {\n                if ( NULL != matvar->internal->fieldnames[i] )\n                    free(matvar->internal->fieldnames[i]);\n            }\n            free(matvar->internal->fieldnames);\n        }\n        free(matvar->internal);\n        matvar->internal = NULL;\n    }\n    if ( NULL != matvar->name )\n        free(matvar->name);\n    free(matvar);\n}",
        "func": "void\nMat_VarFree(matvar_t *matvar)\n{\n    size_t nelems = 0;\n\n    if ( NULL == matvar )\n        return;\n    if ( NULL != matvar->dims ) {\n        nelems = 1;\n        SafeMulDims(matvar, &nelems);\n        free(matvar->dims);\n    }\n    if ( NULL != matvar->data ) {\n        switch (matvar->class_type ) {\n            case MAT_C_STRUCT:\n                if ( !matvar->mem_conserve ) {\n                    matvar_t **fields = (matvar_t**)matvar->data;\n                    size_t nelems_x_nfields, i;\n                    SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);\n                    for ( i = 0; i < nelems_x_nfields; i++ )\n                        Mat_VarFree(fields[i]);\n\n                    free(matvar->data);\n                }\n                break;\n            case MAT_C_CELL:\n                if ( !matvar->mem_conserve ) {\n                    matvar_t **cells = (matvar_t**)matvar->data;\n                    size_t i;\n                    for ( i = 0; i < nelems; i++ )\n                        Mat_VarFree(cells[i]);\n\n                    free(matvar->data);\n                }\n                break;\n            case MAT_C_SPARSE:\n                if ( !matvar->mem_conserve ) {\n                    mat_sparse_t *sparse;\n                    sparse = (mat_sparse_t*)matvar->data;\n                    if ( sparse->ir != NULL )\n                        free(sparse->ir);\n                    if ( sparse->jc != NULL )\n                        free(sparse->jc);\n                    if ( matvar->isComplex && NULL != sparse->data ) {\n                        ComplexFree((mat_complex_split_t*)sparse->data);\n                    } else if ( sparse->data != NULL ) {\n                        free(sparse->data);\n                    }\n                    free(sparse);\n                }\n                break;\n            case MAT_C_DOUBLE:\n            case MAT_C_SINGLE:\n            case MAT_C_INT64:\n            case MAT_C_UINT64:\n            case MAT_C_INT32:\n            case MAT_C_UINT32:\n            case MAT_C_INT16:\n            case MAT_C_UINT16:\n            case MAT_C_INT8:\n            case MAT_C_UINT8:\n            case MAT_C_CHAR:\n                if ( !matvar->mem_conserve ) {\n                    if ( matvar->isComplex ) {\n                        ComplexFree((mat_complex_split_t*)matvar->data);\n                    } else {\n                        free(matvar->data);\n                    }\n                }\n                break;\n            case MAT_C_FUNCTION:\n                if ( !matvar->mem_conserve ) {\n                    free(matvar->data);\n                }\n                break;\n            case MAT_C_EMPTY:\n            case MAT_C_OBJECT:\n            case MAT_C_OPAQUE:\n                break;\n        }\n    }\n\n    if ( NULL != matvar->internal ) {\n#if HAVE_ZLIB\n        if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {\n            inflateEnd(matvar->internal->z);\n            free(matvar->internal->z);\n            if ( matvar->class_type == MAT_C_SPARSE && NULL != matvar->internal->data ) {\n                mat_sparse_t *sparse;\n                sparse = (mat_sparse_t*)matvar->internal->data;\n                if ( sparse->ir != NULL )\n                    free(sparse->ir);\n                if ( sparse->jc != NULL )\n                    free(sparse->jc);\n                if ( matvar->isComplex && NULL != sparse->data ) {\n                    ComplexFree((mat_complex_split_t*)sparse->data);\n                } else if ( sparse->data != NULL ) {\n                    free(sparse->data);\n                }\n                free(sparse);\n            }\n            else if ( matvar->isComplex && NULL != matvar->internal->data ) {\n                ComplexFree((mat_complex_split_t*)matvar->internal->data);\n            } else if ( NULL != matvar->internal->data ) {\n                free(matvar->internal->data);\n            }\n        }\n#endif\n#if defined(MAT73) && MAT73\n        if ( -1 < matvar->internal->id ) {\n            switch ( H5Iget_type(matvar->internal->id) ) {\n                case H5I_GROUP:\n                    H5Gclose(matvar->internal->id);\n                    matvar->internal->id = -1;\n                    break;\n                case H5I_DATASET:\n                    H5Dclose(matvar->internal->id);\n                    matvar->internal->id = -1;\n                    break;\n                default:\n                    break;\n            }\n        }\n        if ( 0 < matvar->internal->hdf5_ref ) {\n            switch ( H5Iget_type(matvar->internal->id) ) {\n                case H5I_GROUP:\n                    H5Gclose(matvar->internal->id);\n                    matvar->internal->hdf5_ref = -1;\n                    break;\n                case H5I_DATASET:\n                    H5Dclose(matvar->internal->id);\n                    matvar->internal->hdf5_ref = -1;\n                    break;\n                default:\n                    break;\n            }\n        }\n        if ( NULL != matvar->internal->hdf5_name ) {\n            free(matvar->internal->hdf5_name);\n            matvar->internal->hdf5_name = NULL;\n        }\n#endif\n        if ( NULL != matvar->internal->fieldnames &&\n            matvar->internal->num_fields > 0 ) {\n            size_t i;\n            for ( i = 0; i < matvar->internal->num_fields; i++ ) {\n                if ( NULL != matvar->internal->fieldnames[i] )\n                    free(matvar->internal->fieldnames[i]);\n            }\n            free(matvar->internal->fieldnames);\n        }\n        free(matvar->internal);\n        matvar->internal = NULL;\n    }\n    if ( NULL != matvar->name )\n        free(matvar->name);\n    free(matvar);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -141,7 +141,7 @@\n         }\n #endif\n         if ( NULL != matvar->internal->fieldnames &&\n-             matvar->internal->num_fields > 0 ) {\n+            matvar->internal->num_fields > 0 ) {\n             size_t i;\n             for ( i = 0; i < matvar->internal->num_fields; i++ ) {\n                 if ( NULL != matvar->internal->fieldnames[i] )",
        "diff_line_info": {
            "deleted_lines": [
                "             matvar->internal->num_fields > 0 ) {"
            ],
            "added_lines": [
                "            matvar->internal->num_fields > 0 ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20095",
        "func_name": "torvalds/linux/mwifiex_tm_cmd",
        "description": "mwifiex_tm_cmd in drivers/net/wireless/marvell/mwifiex/cfg80211.c in the Linux kernel before 5.1.6 has some error-handling cases that did not free allocated hostcmd memory, aka CID-003b686ace82. This will cause a memory leak and denial of service.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=003b686ace820ce2d635a83f10f2d7f9c147dabc",
        "commit_title": "'hostcmd' is alloced by kzalloc, should be freed before",
        "commit_text": "leaving from the error handling cases, otherwise it will cause mem leak.  ",
        "func_before": "static int mwifiex_tm_cmd(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t  void *data, int len)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tstruct mwifiex_ds_misc_cmd *hostcmd;\n\tstruct nlattr *tb[MWIFIEX_TM_ATTR_MAX + 1];\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\terr = nla_parse(tb, MWIFIEX_TM_ATTR_MAX, data, len, mwifiex_tm_policy,\n\t\t\tNULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[MWIFIEX_TM_ATTR_CMD])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[MWIFIEX_TM_ATTR_CMD])) {\n\tcase MWIFIEX_TM_CMD_HOSTCMD:\n\t\tif (!tb[MWIFIEX_TM_ATTR_DATA])\n\t\t\treturn -EINVAL;\n\n\t\thostcmd = kzalloc(sizeof(*hostcmd), GFP_KERNEL);\n\t\tif (!hostcmd)\n\t\t\treturn -ENOMEM;\n\n\t\thostcmd->len = nla_len(tb[MWIFIEX_TM_ATTR_DATA]);\n\t\tmemcpy(hostcmd->cmd, nla_data(tb[MWIFIEX_TM_ATTR_DATA]),\n\t\t       hostcmd->len);\n\n\t\tif (mwifiex_send_cmd(priv, 0, 0, 0, hostcmd, true)) {\n\t\t\tdev_err(priv->adapter->dev, \"Failed to process hostcmd\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/* process hostcmd response*/\n\t\tskb = cfg80211_testmode_alloc_reply_skb(wiphy, hostcmd->len);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\terr = nla_put(skb, MWIFIEX_TM_ATTR_DATA,\n\t\t\t      hostcmd->len, hostcmd->cmd);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\terr = cfg80211_testmode_reply(skb);\n\t\tkfree(hostcmd);\n\t\treturn err;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}",
        "func": "static int mwifiex_tm_cmd(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t  void *data, int len)\n{\n\tstruct mwifiex_private *priv = mwifiex_netdev_get_priv(wdev->netdev);\n\tstruct mwifiex_ds_misc_cmd *hostcmd;\n\tstruct nlattr *tb[MWIFIEX_TM_ATTR_MAX + 1];\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (!priv)\n\t\treturn -EINVAL;\n\n\terr = nla_parse(tb, MWIFIEX_TM_ATTR_MAX, data, len, mwifiex_tm_policy,\n\t\t\tNULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[MWIFIEX_TM_ATTR_CMD])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[MWIFIEX_TM_ATTR_CMD])) {\n\tcase MWIFIEX_TM_CMD_HOSTCMD:\n\t\tif (!tb[MWIFIEX_TM_ATTR_DATA])\n\t\t\treturn -EINVAL;\n\n\t\thostcmd = kzalloc(sizeof(*hostcmd), GFP_KERNEL);\n\t\tif (!hostcmd)\n\t\t\treturn -ENOMEM;\n\n\t\thostcmd->len = nla_len(tb[MWIFIEX_TM_ATTR_DATA]);\n\t\tmemcpy(hostcmd->cmd, nla_data(tb[MWIFIEX_TM_ATTR_DATA]),\n\t\t       hostcmd->len);\n\n\t\tif (mwifiex_send_cmd(priv, 0, 0, 0, hostcmd, true)) {\n\t\t\tdev_err(priv->adapter->dev, \"Failed to process hostcmd\\n\");\n\t\t\tkfree(hostcmd);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/* process hostcmd response*/\n\t\tskb = cfg80211_testmode_alloc_reply_skb(wiphy, hostcmd->len);\n\t\tif (!skb) {\n\t\t\tkfree(hostcmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\terr = nla_put(skb, MWIFIEX_TM_ATTR_DATA,\n\t\t\t      hostcmd->len, hostcmd->cmd);\n\t\tif (err) {\n\t\t\tkfree(hostcmd);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\terr = cfg80211_testmode_reply(skb);\n\t\tkfree(hostcmd);\n\t\treturn err;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,16 +33,20 @@\n \n \t\tif (mwifiex_send_cmd(priv, 0, 0, 0, hostcmd, true)) {\n \t\t\tdev_err(priv->adapter->dev, \"Failed to process hostcmd\\n\");\n+\t\t\tkfree(hostcmd);\n \t\t\treturn -EFAULT;\n \t\t}\n \n \t\t/* process hostcmd response*/\n \t\tskb = cfg80211_testmode_alloc_reply_skb(wiphy, hostcmd->len);\n-\t\tif (!skb)\n+\t\tif (!skb) {\n+\t\t\tkfree(hostcmd);\n \t\t\treturn -ENOMEM;\n+\t\t}\n \t\terr = nla_put(skb, MWIFIEX_TM_ATTR_DATA,\n \t\t\t      hostcmd->len, hostcmd->cmd);\n \t\tif (err) {\n+\t\t\tkfree(hostcmd);\n \t\t\tkfree_skb(skb);\n \t\t\treturn -EMSGSIZE;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (!skb)"
            ],
            "added_lines": [
                "\t\t\tkfree(hostcmd);",
                "\t\tif (!skb) {",
                "\t\t\tkfree(hostcmd);",
                "\t\t}",
                "\t\t\tkfree(hostcmd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20096",
        "func_name": "torvalds/linux/__feat_register_sp",
        "description": "In the Linux kernel before 5.1, there is a memory leak in __feat_register_sp() in net/dccp/feat.c, which may cause denial of service, aka CID-1d3ff0950e2b.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=1d3ff0950e2b40dc861b1739029649d03f591820",
        "commit_title": "If dccp_feat_push_change fails, we forget free the mem",
        "commit_text": "which is alloced by kmemdup in dccp_feat_clone_sp_val.  ",
        "func_before": "static int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\n\t/* Avoid negotiating alien CCIDs by only advertising supported ones */\n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\n\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\n}",
        "func": "static int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\n\t/* Avoid negotiating alien CCIDs by only advertising supported ones */\n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\n\tif (dccp_feat_push_change(fn, feat, is_local, mandatory, &fval)) {\n\t\tkfree(fval.sp.vec);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,5 +14,10 @@\n \tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n \t\treturn -ENOMEM;\n \n-\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\n+\tif (dccp_feat_push_change(fn, feat, is_local, mandatory, &fval)) {\n+\t\tkfree(fval.sp.vec);\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);"
            ],
            "added_lines": [
                "\tif (dccp_feat_push_change(fn, feat, is_local, mandatory, &fval)) {",
                "\t\tkfree(fval.sp.vec);",
                "\t\treturn -ENOMEM;",
                "\t}",
                "",
                "\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20159",
        "func_name": "gpac/minf_Read",
        "description": "An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There is a memory leak in dinf_New() in isomedia/box_code_base.c.",
        "git_url": "https://github.com/gpac/gpac/commit/e4c1f09ab9618b6af3bec6b94b8b349f2d01dbf8",
        "commit_title": "fix dinf memleak (#1321)",
        "commit_text": "",
        "func_before": "GF_Err minf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\te = gf_isom_box_array_read(s, bs, minf_AddBox);\n\tif (! ptr->dataInformation) {\n\t\tGF_Box *dinf, *dref, *url;\n\t\tBool dump_mode = GF_FALSE;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tdinf = gf_isom_box_new(GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!dinf) return GF_OUT_OF_MEM;\n\t\tif (ptr->InfoHeader && gf_list_find(ptr->other_boxes, ptr->InfoHeader)>=0) dump_mode = GF_TRUE;\n\t\tif (ptr->sampleTable && gf_list_find(ptr->other_boxes, ptr->sampleTable)>=0) dump_mode = GF_TRUE;\n\n\t\tptr->dataInformation = (GF_DataInformationBox *)dinf;\n\n\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!dref) return GF_OUT_OF_MEM;\n\t\te = dinf_AddBox(dinf, dref);\n\n\t\turl = gf_isom_box_new(GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t\te = gf_isom_box_add_default(dref, url);\n\n\t\tif (dump_mode) {\n\t\t\tgf_list_add(ptr->other_boxes, ptr->dataInformation);\n\t\t\tif (!dinf->other_boxes) dinf->other_boxes = gf_list_new();\n\t\t\tgf_list_add(dinf->other_boxes, dref);\n\t\t}\n\t}\n\treturn e;\n}",
        "func": "GF_Err minf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MediaInformationBox *ptr = (GF_MediaInformationBox *)s;\n\tGF_Err e;\n\te = gf_isom_box_array_read(s, bs, minf_AddBox);\n\tif (! ptr->dataInformation) {\n\t\tGF_Box *dinf, *dref, *url;\n\t\textern Bool use_dump_mode;\n\t\tBool dump_mode = use_dump_mode;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n\t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n//\t\te = GF_ISOM_INVALID_FILE;\n\n\t\t//add a dinf box to avoid any access to a null dinf\n\t\tdinf = gf_isom_box_new(GF_ISOM_BOX_TYPE_DINF);\n\t\tif (!dinf) return GF_OUT_OF_MEM;\n\t\tif (ptr->InfoHeader && gf_list_find(ptr->other_boxes, ptr->InfoHeader)>=0) dump_mode = GF_TRUE;\n\t\tif (ptr->sampleTable && gf_list_find(ptr->other_boxes, ptr->sampleTable)>=0) dump_mode = GF_TRUE;\n\n\t\tptr->dataInformation = (GF_DataInformationBox *)dinf;\n\n\t\tdref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t\tif (!dref) return GF_OUT_OF_MEM;\n\t\te = dinf_AddBox(dinf, dref);\n\n\t\turl = gf_isom_box_new(GF_ISOM_BOX_TYPE_URL);\n\t\tif (!url) return GF_OUT_OF_MEM;\n\t\t((GF_FullBox*)url)->flags = 1;\n\t\te = gf_isom_box_add_default(dref, url);\n\n\t\tif (dump_mode) {\n\t\t\tgf_list_add(ptr->other_boxes, ptr->dataInformation);\n\t\t\tif (!dinf->other_boxes) dinf->other_boxes = gf_list_new();\n\t\t\tgf_list_add(dinf->other_boxes, dref);\n\t\t}\n\t}\n\treturn e;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,8 @@\n \te = gf_isom_box_array_read(s, bs, minf_AddBox);\n \tif (! ptr->dataInformation) {\n \t\tGF_Box *dinf, *dref, *url;\n-\t\tBool dump_mode = GF_FALSE;\n+\t\textern Bool use_dump_mode;\n+\t\tBool dump_mode = use_dump_mode;\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing DataInformationBox\\n\"));\n \t\t//commented on purpose, we are still able to handle the file, we only throw an error but keep processing\n //\t\te = GF_ISOM_INVALID_FILE;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tBool dump_mode = GF_FALSE;"
            ],
            "added_lines": [
                "\t\textern Bool use_dump_mode;",
                "\t\tBool dump_mode = use_dump_mode;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20171",
        "func_name": "gpac/abst_Read",
        "description": "An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There are memory leaks in metx_New in isomedia/box_code_base.c and abst_Read in isomedia/box_code_adobe.c.",
        "git_url": "https://github.com/gpac/gpac/commit/72cdc5048dead86bb1df7d21e0b9975e49cf2d97",
        "commit_title": "fix memleak in abst_Read (#1337)",
        "commit_text": "",
        "func_before": "GF_Err abst_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize=(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) return e;\n\t\tgf_list_insert(ptr->segment_run_table_entries, asrt, i);\n\t}\n\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) return e;\n\t\tgf_list_insert(ptr->fragment_run_table_entries, afrt, i);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}",
        "func": "GF_Err abst_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize=(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_insert(ptr->segment_run_table_entries, asrt, i);\n\t}\n\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_table_entries, afrt, i);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -84,17 +84,25 @@\n \n \tptr->segment_run_table_count = gf_bs_read_u8(bs);\n \tfor (i=0; i<ptr->segment_run_table_count; i++) {\n-\t\tGF_AdobeSegmentRunTableBox *asrt;\n+\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n \t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n-\t\tif (e) return e;\n+\t\tif (e) {\n+\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n+\t\t\tgf_free(tmp_str);\n+\t\t\treturn e;\n+\t\t}\n \t\tgf_list_insert(ptr->segment_run_table_entries, asrt, i);\n \t}\n \n \tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n \tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n-\t\tGF_AdobeFragmentRunTableBox *afrt;\n+\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n \t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n-\t\tif (e) return e;\n+\t\tif (e) {\n+\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n+\t\t\tgf_free(tmp_str);\n+\t\t\treturn e;\n+\t\t}\n \t\tgf_list_insert(ptr->fragment_run_table_entries, afrt, i);\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tGF_AdobeSegmentRunTableBox *asrt;",
                "\t\tif (e) return e;",
                "\t\tGF_AdobeFragmentRunTableBox *afrt;",
                "\t\tif (e) return e;"
            ],
            "added_lines": [
                "\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;",
                "\t\tif (e) {",
                "\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);",
                "\t\t\tgf_free(tmp_str);",
                "\t\t\treturn e;",
                "\t\t}",
                "\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;",
                "\t\tif (e) {",
                "\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);",
                "\t\t\tgf_free(tmp_str);",
                "\t\t\treturn e;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20171",
        "func_name": "gpac/abst_Read",
        "description": "An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There are memory leaks in metx_New in isomedia/box_code_base.c and abst_Read in isomedia/box_code_adobe.c.",
        "git_url": "https://github.com/gpac/gpac/commit/2bcca3f1d4605100bb27d3ed7be25b53cddbc75c",
        "commit_title": "abst_Read: force last char of string to 0 for strdup (#1337)",
        "commit_text": "",
        "func_before": "GF_Err abst_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize=(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i)\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_insert(ptr->segment_run_table_entries, asrt, i);\n\t}\n\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_table_entries, afrt, i);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}",
        "func": "GF_Err abst_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize, strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\tstrsize = tmp_strsize=(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\ttmp_str[strsize-1] = 0;\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\ttmp_str[strsize-1] = 0;\n\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size-8;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\ttmp_str[strsize-1] = 0;\n\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\ttmp_str[strsize-1] = 0;\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size-8;\n\twhile (tmp_strsize) {\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\ttmp_str[strsize-1] = 0;\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_insert(ptr->segment_run_table_entries, asrt, i);\n\t}\n\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_table_entries, afrt, i);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n \tint i;\n-\tu32 tmp_strsize;\n+\tu32 tmp_strsize, strsize;\n \tchar *tmp_str;\n \tGF_Err e;\n \n@@ -17,7 +17,7 @@\n \n \ti=0;\n \tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n-\ttmp_strsize=(u32)ptr->size-8;\n+\tstrsize = tmp_strsize=(u32)ptr->size-8;\n \ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n \n \twhile (tmp_strsize) {\n@@ -27,8 +27,10 @@\n \t\t\tbreak;\n \t\ti++;\n \t}\n-\tif (i)\n+\tif (i) {\n+\t\ttmp_str[strsize-1] = 0;\n \t\tptr->movie_identifier = gf_strdup(tmp_str);\n+\t}\n \n \tptr->server_entry_count = gf_bs_read_u8(bs);\n \tfor (i=0; i<ptr->server_entry_count; i++) {\n@@ -41,6 +43,7 @@\n \t\t\t\tbreak;\n \t\t\tj++;\n \t\t}\n+\t\ttmp_str[strsize-1] = 0;\n \t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n \t}\n \n@@ -55,6 +58,7 @@\n \t\t\t\tbreak;\n \t\t\tj++;\n \t\t}\n+\t\ttmp_str[strsize-1] = 0;\n \t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n \t}\n \n@@ -67,8 +71,10 @@\n \t\t\tbreak;\n \t\ti++;\n \t}\n-\tif (i)\n+\tif (i) {\n+\t\ttmp_str[strsize-1] = 0;\n \t\tptr->drm_data = gf_strdup(tmp_str);\n+\t}\n \n \ti=0;\n \ttmp_strsize=(u32)ptr->size-8;\n@@ -79,8 +85,10 @@\n \t\t\tbreak;\n \t\ti++;\n \t}\n-\tif (i)\n+\tif (i) {\n+\t\ttmp_str[strsize-1] = 0;\n \t\tptr->meta_data = gf_strdup(tmp_str);\n+\t}\n \n \tptr->segment_run_table_count = gf_bs_read_u8(bs);\n \tfor (i=0; i<ptr->segment_run_table_count; i++) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tu32 tmp_strsize;",
                "\ttmp_strsize=(u32)ptr->size-8;",
                "\tif (i)",
                "\tif (i)",
                "\tif (i)"
            ],
            "added_lines": [
                "\tu32 tmp_strsize, strsize;",
                "\tstrsize = tmp_strsize=(u32)ptr->size-8;",
                "\tif (i) {",
                "\t\ttmp_str[strsize-1] = 0;",
                "\t}",
                "\t\ttmp_str[strsize-1] = 0;",
                "\t\ttmp_str[strsize-1] = 0;",
                "\tif (i) {",
                "\t\ttmp_str[strsize-1] = 0;",
                "\t}",
                "\tif (i) {",
                "\t\ttmp_str[strsize-1] = 0;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-13843",
        "func_name": "samtools/htslib/sam_parse1",
        "description": "An issue has been found in HTSlib 1.8. It is a memory leak in bgzf_getline in bgzf.c. NOTE: the software maintainer's position is that the \"failure to free memory\" can be fixed in applications that use the HTSlib library (such as test/test_bgzf.c in the original report) and is not a library issue",
        "git_url": "https://github.com/samtools/htslib/commit/99acb64270f43a015672b4cd9e72c3b02c334c4d",
        "commit_title": "Fix memory leak in `test_realn`.",
        "commit_text": "Fix buffer overflow in `sam_parse1`. Fixes #731.",
        "func_before": "int sam_parse1(kstring_t *s, bam_hdr_t *h, bam1_t *b)\n{\n#define _read_token(_p) (_p); for (; *(_p) && *(_p) != '\\t'; ++(_p)); if (*(_p) != '\\t') goto err_ret; *(_p)++ = 0\n#define _read_token_aux(_p) (_p); for (; *(_p) && *(_p) != '\\t'; ++(_p)); *(_p)++ = 0 // this is different in that it does not test *(_p)=='\\t'\n#define _get_mem(type_t, _x, _s, _l) ks_resize((_s), (_s)->l + (_l)); *(_x) = (type_t*)((_s)->s + (_s)->l); (_s)->l += (_l)\n#define _parse_err(cond, msg) do { if (cond) { hts_log_error(msg); goto err_ret; } } while (0)\n#define _parse_err_param(cond, msg, param) do { if (cond) { hts_log_error(msg, param); goto err_ret; } } while (0)\n#define _parse_warn(cond, msg) do { if (cond) { hts_log_warning(msg); } } while (0)\n\n    uint8_t *t;\n    char *p = s->s, *q;\n    int i;\n    kstring_t str;\n    bam1_core_t *c = &b->core;\n\n    str.l = b->l_data = 0;\n    str.s = (char*)b->data; str.m = b->m_data;\n    memset(c, 0, 32);\n    if (h->cigar_tab == 0) {\n        h->cigar_tab = (int8_t*) malloc(128);\n        for (i = 0; i < 128; ++i)\n            h->cigar_tab[i] = -1;\n        for (i = 0; BAM_CIGAR_STR[i]; ++i)\n            h->cigar_tab[(int)BAM_CIGAR_STR[i]] = i;\n    }\n    // qname\n    q = _read_token(p);\n    _parse_warn(p - q <= 1, \"empty query name\");\n    _parse_err(p - q > 252, \"query name too long\");\n    kputsn_(q, p - q, &str);\n    for (c->l_extranul = 0; str.l % 4 != 0; c->l_extranul++)\n        kputc_('\\0', &str);\n    c->l_qname = p - q + c->l_extranul;\n    // flag\n    c->flag = strtol(p, &p, 0);\n    if (*p++ != '\\t') goto err_ret; // malformated flag\n    // chr\n    q = _read_token(p);\n    if (strcmp(q, \"*\")) {\n        _parse_err(h->n_targets == 0, \"missing SAM header\");\n        c->tid = bam_name2id(h, q);\n        _parse_warn(c->tid < 0, \"urecognized reference name; treated as unmapped\");\n    } else c->tid = -1;\n    // pos\n    c->pos = strtol(p, &p, 10) - 1;\n    if (*p++ != '\\t') goto err_ret;\n    if (c->pos < 0 && c->tid >= 0) {\n        _parse_warn(1, \"mapped query cannot have zero coordinate; treated as unmapped\");\n        c->tid = -1;\n    }\n    if (c->tid < 0) c->flag |= BAM_FUNMAP;\n    // mapq\n    c->qual = strtol(p, &p, 10);\n    if (*p++ != '\\t') goto err_ret;\n    // cigar\n    if (*p != '*') {\n        uint32_t *cigar;\n        size_t n_cigar = 0;\n        for (q = p; *p && *p != '\\t'; ++p)\n            if (!isdigit_c(*p)) ++n_cigar;\n        if (*p++ != '\\t') goto err_ret;\n        _parse_err(n_cigar == 0, \"no CIGAR operations\");\n        _parse_err(n_cigar >= 2147483647, \"too many CIGAR operations\");\n        c->n_cigar = n_cigar;\n        _get_mem(uint32_t, &cigar, &str, c->n_cigar * sizeof(uint32_t));\n        for (i = 0; i < c->n_cigar; ++i, ++q) {\n            int op;\n            cigar[i] = strtol(q, &q, 10)<<BAM_CIGAR_SHIFT;\n            op = (uint8_t)*q >= 128? -1 : h->cigar_tab[(int)*q];\n            _parse_err(op < 0, \"unrecognized CIGAR operator\");\n            cigar[i] |= op;\n        }\n        // can't use bam_endpos() directly as some fields not yet set up\n        i = (!(c->flag&BAM_FUNMAP))? bam_cigar2rlen(c->n_cigar, cigar) : 1;\n    } else {\n        _parse_warn(!(c->flag&BAM_FUNMAP), \"mapped query must have a CIGAR; treated as unmapped\");\n        c->flag |= BAM_FUNMAP;\n        q = _read_token(p);\n        i = 1;\n    }\n    c->bin = hts_reg2bin(c->pos, c->pos + i, 14, 5);\n    // mate chr\n    q = _read_token(p);\n    if (strcmp(q, \"=\") == 0) {\n        c->mtid = c->tid;\n    } else if (strcmp(q, \"*\") == 0) {\n        c->mtid = -1;\n    } else {\n        c->mtid = bam_name2id(h, q);\n        _parse_warn(c->mtid < 0, \"urecognized mate reference name; treated as unmapped\");\n    }\n    // mpos\n    c->mpos = strtol(p, &p, 10) - 1;\n    if (*p++ != '\\t') goto err_ret;\n    if (c->mpos < 0 && c->mtid >= 0) {\n        _parse_warn(1, \"mapped mate cannot have zero coordinate; treated as unmapped\");\n        c->mtid = -1;\n    }\n    // tlen\n    c->isize = strtol(p, &p, 10);\n    if (*p++ != '\\t') goto err_ret;\n    // seq\n    q = _read_token(p);\n    if (strcmp(q, \"*\")) {\n        c->l_qseq = p - q - 1;\n        i = bam_cigar2qlen(c->n_cigar, (uint32_t*)(str.s + c->l_qname));\n        _parse_err(c->n_cigar && i != c->l_qseq, \"CIGAR and query sequence are of different length\");\n        i = (c->l_qseq + 1) >> 1;\n        _get_mem(uint8_t, &t, &str, i);\n        memset(t, 0, i);\n        for (i = 0; i < c->l_qseq; ++i)\n            t[i>>1] |= seq_nt16_table[(int)q[i]] << ((~i&1)<<2);\n    } else c->l_qseq = 0;\n    // qual\n    q = _read_token_aux(p);\n    _get_mem(uint8_t, &t, &str, c->l_qseq);\n    if (strcmp(q, \"*\")) {\n        _parse_err(p - q - 1 != c->l_qseq, \"SEQ and QUAL are of different length\");\n        for (i = 0; i < c->l_qseq; ++i) t[i] = q[i] - 33;\n    } else memset(t, 0xff, c->l_qseq);\n    // aux\n    while (p < s->s + s->l) {\n        uint8_t type;\n        q = _read_token_aux(p); // FIXME: can be accelerated for long 'B' arrays\n        _parse_err(p - q - 1 < 5, \"incomplete aux field\");\n        kputsn_(q, 2, &str);\n        q += 3; type = *q++; ++q; // q points to value\n        if (type != 'Z' && type != 'H') // the only zero length acceptable fields\n            _parse_err(p - q - 1 < 1, \"incomplete aux field\");\n\n        // Ensure str has enough space for a double + type allocated.\n        // This is so we can stuff bigger integers and floats directly into\n        // the kstring.  Sorry.\n        _parse_err(ks_resize(&str, str.l + 16), \"out of memory\");\n\n        if (type == 'A' || type == 'a' || type == 'c' || type == 'C') {\n            kputc_('A', &str);\n            kputc_(*q, &str);\n        } else if (type == 'i' || type == 'I') {\n            if (*q == '-') {\n                long x = strtol(q, &q, 10);\n                if (x >= INT8_MIN) {\n                    kputc_('c', &str); kputc_(x, &str);\n                } else if (x >= INT16_MIN) {\n                    str.s[str.l++] = 's';\n                    i16_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 2;\n                } else {\n                    str.s[str.l++] = 'i';\n                    i32_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 4;\n                }\n            } else {\n                unsigned long x = strtoul(q, &q, 10);\n                if (x <= UINT8_MAX) {\n                    kputc_('C', &str); kputc_(x, &str);\n                } else if (x <= UINT16_MAX) {\n                    str.s[str.l++] = 'S';\n                    u16_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 2;\n                } else {\n                    str.s[str.l++] = 'I';\n                    u32_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 4;\n                }\n            }\n        } else if (type == 'f') {\n            str.s[str.l++] = 'f';\n            float_to_le(strtod(q, &q), (uint8_t *) str.s + str.l);\n            str.l += sizeof(float);\n        } else if (type == 'd') {\n            str.s[str.l++] = 'd';\n            double_to_le(strtod(q, &q), (uint8_t *) str.s + str.l);\n            str.l += sizeof(double);\n        } else if (type == 'Z' || type == 'H') {\n            _parse_err(type == 'H' && !((p-q)&1),\n                       \"hex field does not have an even number of digits\");\n            kputc_(type, &str);kputsn_(q, p - q, &str); // note that this include the trailing NULL\n        } else if (type == 'B') {\n            int32_t n, size;\n            size_t bytes;\n            char *r;\n            _parse_err(p - q - 1 < 3, \"incomplete B-typed aux field\");\n            type = *q++; // q points to the first ',' following the typing byte\n\n            size = aux_type2size(type);\n            _parse_err_param(size <= 0 || size > 4,\n                             \"unrecognized type B:%c\", type);\n            _parse_err(*q && *q != ',', \"B aux field type not followed by ','\");\n\n            for (r = q, n = 0; *r; ++r)\n                if (*r == ',') ++n;\n\n            // Ensure space for type + values\n            bytes = (size_t) n * (size_t) size;\n            _parse_err(bytes / size != n\n                       || ks_resize(&str, str.l + bytes + 2 + sizeof(uint32_t)),\n                       \"out of memory\");\n            str.s[str.l++] = 'B';\n            str.s[str.l++] = type;\n            i32_to_le(n, (uint8_t *) str.s + str.l);\n            str.l += sizeof(uint32_t);\n\n            // This ensures that q always ends up at the next comma after\n            // reading a number even if it's followed by junk.  It\n            // prevents the possibility of trying to read more than n items.\n#define _skip_to_comma(q, p) do { while ((q) < (p) && *(q) != ',') (q)++; } while (0)\n\n            if (type == 'c')      while (q + 1 < p) { int8_t   x = strtol(q + 1, &q, 0); kputc_(x, &str); }\n            else if (type == 'C') while (q + 1 < p) { uint8_t  x = strtoul(q + 1, &q, 0); kputc_(x, &str); }\n            else if (type == 's') while (q + 1 < p) { i16_to_le(strtol(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 2; _skip_to_comma(q, p); }\n            else if (type == 'S') while (q + 1 < p) { u16_to_le(strtoul(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 2; _skip_to_comma(q, p); }\n            else if (type == 'i') while (q + 1 < p) { i32_to_le(strtol(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else if (type == 'I') while (q + 1 < p) { u32_to_le(strtoul(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else if (type == 'f') while (q + 1 < p) { float_to_le(strtod(q + 1, &q), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else _parse_err_param(1, \"unrecognized type B:%c\", type);\n\n#undef _skip_to_comma\n\n        } else _parse_err_param(1, \"unrecognized type %c\", type);\n    }\n    b->data = (uint8_t*)str.s; b->l_data = str.l; b->m_data = str.m;\n    if (bam_tag2cigar(b, 1, 1) < 0)\n        return -2;\n    return 0;\n\n#undef _parse_warn\n#undef _parse_err\n#undef _parse_err_param\n#undef _get_mem\n#undef _read_token_aux\n#undef _read_token\nerr_ret:\n    b->data = (uint8_t*)str.s; b->l_data = str.l; b->m_data = str.m;\n    return -2;\n}",
        "func": "int sam_parse1(kstring_t *s, bam_hdr_t *h, bam1_t *b)\n{\n#define _read_token(_p) (_p); for (; *(_p) && *(_p) != '\\t'; ++(_p)); if (*(_p) != '\\t') goto err_ret; *(_p)++ = 0\n#define _read_token_aux(_p) (_p); for (; *(_p) && *(_p) != '\\t'; ++(_p)); *(_p)++ = 0 // this is different in that it does not test *(_p)=='\\t'\n#define _get_mem(type_t, _x, _s, _l) ks_resize((_s), (_s)->l + (_l)); *(_x) = (type_t*)((_s)->s + (_s)->l); (_s)->l += (_l)\n#define _parse_err(cond, msg) do { if (cond) { hts_log_error(msg); goto err_ret; } } while (0)\n#define _parse_err_param(cond, msg, param) do { if (cond) { hts_log_error(msg, param); goto err_ret; } } while (0)\n#define _parse_warn(cond, msg) do { if (cond) { hts_log_warning(msg); } } while (0)\n\n    uint8_t *t;\n    char *p = s->s, *q;\n    int i;\n    kstring_t str;\n    bam1_core_t *c = &b->core;\n\n    str.l = b->l_data = 0;\n    str.s = (char*)b->data; str.m = b->m_data;\n    memset(c, 0, 32);\n    if (h->cigar_tab == 0) {\n        h->cigar_tab = (int8_t*) malloc(128);\n        for (i = 0; i < 128; ++i)\n            h->cigar_tab[i] = -1;\n        for (i = 0; BAM_CIGAR_STR[i]; ++i)\n            h->cigar_tab[(int)BAM_CIGAR_STR[i]] = i;\n    }\n    // qname\n    q = _read_token(p);\n    _parse_warn(p - q <= 1, \"empty query name\");\n    _parse_err(p - q > 252, \"query name too long\");\n    kputsn_(q, p - q, &str);\n    for (c->l_extranul = 0; str.l % 4 != 0; c->l_extranul++)\n        kputc_('\\0', &str);\n    c->l_qname = p - q + c->l_extranul;\n    // flag\n    c->flag = strtol(p, &p, 0);\n    if (*p++ != '\\t') goto err_ret; // malformated flag\n    // chr\n    q = _read_token(p);\n    if (strcmp(q, \"*\")) {\n        _parse_err(h->n_targets == 0, \"missing SAM header\");\n        c->tid = bam_name2id(h, q);\n        _parse_warn(c->tid < 0, \"urecognized reference name; treated as unmapped\");\n    } else c->tid = -1;\n    // pos\n    c->pos = strtol(p, &p, 10) - 1;\n    if (*p++ != '\\t') goto err_ret;\n    if (c->pos < 0 && c->tid >= 0) {\n        _parse_warn(1, \"mapped query cannot have zero coordinate; treated as unmapped\");\n        c->tid = -1;\n    }\n    if (c->tid < 0) c->flag |= BAM_FUNMAP;\n    // mapq\n    c->qual = strtol(p, &p, 10);\n    if (*p++ != '\\t') goto err_ret;\n    // cigar\n    if (*p != '*') {\n        uint32_t *cigar;\n        size_t n_cigar = 0;\n        for (q = p; *p && *p != '\\t'; ++p)\n            if (!isdigit_c(*p)) ++n_cigar;\n        if (*p++ != '\\t') goto err_ret;\n        _parse_err(n_cigar == 0, \"no CIGAR operations\");\n        _parse_err(n_cigar >= 2147483647, \"too many CIGAR operations\");\n        c->n_cigar = n_cigar;\n        _get_mem(uint32_t, &cigar, &str, c->n_cigar * sizeof(uint32_t));\n        for (i = 0; i < c->n_cigar; ++i, ++q) {\n            int op;\n            cigar[i] = strtol(q, &q, 10)<<BAM_CIGAR_SHIFT;\n            op = (uint8_t)*q >= 128? -1 : h->cigar_tab[(int)*q];\n            _parse_err(op < 0, \"unrecognized CIGAR operator\");\n            cigar[i] |= op;\n        }\n        // can't use bam_endpos() directly as some fields not yet set up\n        i = (!(c->flag&BAM_FUNMAP))? bam_cigar2rlen(c->n_cigar, cigar) : 1;\n    } else {\n        _parse_warn(!(c->flag&BAM_FUNMAP), \"mapped query must have a CIGAR; treated as unmapped\");\n        c->flag |= BAM_FUNMAP;\n        q = _read_token(p);\n        i = 1;\n    }\n    c->bin = hts_reg2bin(c->pos, c->pos + i, 14, 5);\n    // mate chr\n    q = _read_token(p);\n    if (strcmp(q, \"=\") == 0) {\n        c->mtid = c->tid;\n    } else if (strcmp(q, \"*\") == 0) {\n        c->mtid = -1;\n    } else {\n        c->mtid = bam_name2id(h, q);\n        _parse_warn(c->mtid < 0, \"urecognized mate reference name; treated as unmapped\");\n    }\n    // mpos\n    c->mpos = strtol(p, &p, 10) - 1;\n    if (*p++ != '\\t') goto err_ret;\n    if (c->mpos < 0 && c->mtid >= 0) {\n        _parse_warn(1, \"mapped mate cannot have zero coordinate; treated as unmapped\");\n        c->mtid = -1;\n    }\n    // tlen\n    c->isize = strtol(p, &p, 10);\n    if (*p++ != '\\t') goto err_ret;\n    // seq\n    q = _read_token(p);\n    if (strcmp(q, \"*\")) {\n        c->l_qseq = p - q - 1;\n        i = bam_cigar2qlen(c->n_cigar, (uint32_t*)(str.s + c->l_qname));\n        _parse_err(c->n_cigar && i != c->l_qseq, \"CIGAR and query sequence are of different length\");\n        i = (c->l_qseq + 1) >> 1;\n        _get_mem(uint8_t, &t, &str, i);\n        memset(t, 0, i);\n        for (i = 0; i < c->l_qseq; ++i)\n            t[i>>1] |= seq_nt16_table[(unsigned char)q[i]] << ((~i&1)<<2);\n    } else c->l_qseq = 0;\n    // qual\n    q = _read_token_aux(p);\n    _get_mem(uint8_t, &t, &str, c->l_qseq);\n    if (strcmp(q, \"*\")) {\n        _parse_err(p - q - 1 != c->l_qseq, \"SEQ and QUAL are of different length\");\n        for (i = 0; i < c->l_qseq; ++i) t[i] = q[i] - 33;\n    } else memset(t, 0xff, c->l_qseq);\n    // aux\n    while (p < s->s + s->l) {\n        uint8_t type;\n        q = _read_token_aux(p); // FIXME: can be accelerated for long 'B' arrays\n        _parse_err(p - q - 1 < 5, \"incomplete aux field\");\n        kputsn_(q, 2, &str);\n        q += 3; type = *q++; ++q; // q points to value\n        if (type != 'Z' && type != 'H') // the only zero length acceptable fields\n            _parse_err(p - q - 1 < 1, \"incomplete aux field\");\n\n        // Ensure str has enough space for a double + type allocated.\n        // This is so we can stuff bigger integers and floats directly into\n        // the kstring.  Sorry.\n        _parse_err(ks_resize(&str, str.l + 16), \"out of memory\");\n\n        if (type == 'A' || type == 'a' || type == 'c' || type == 'C') {\n            kputc_('A', &str);\n            kputc_(*q, &str);\n        } else if (type == 'i' || type == 'I') {\n            if (*q == '-') {\n                long x = strtol(q, &q, 10);\n                if (x >= INT8_MIN) {\n                    kputc_('c', &str); kputc_(x, &str);\n                } else if (x >= INT16_MIN) {\n                    str.s[str.l++] = 's';\n                    i16_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 2;\n                } else {\n                    str.s[str.l++] = 'i';\n                    i32_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 4;\n                }\n            } else {\n                unsigned long x = strtoul(q, &q, 10);\n                if (x <= UINT8_MAX) {\n                    kputc_('C', &str); kputc_(x, &str);\n                } else if (x <= UINT16_MAX) {\n                    str.s[str.l++] = 'S';\n                    u16_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 2;\n                } else {\n                    str.s[str.l++] = 'I';\n                    u32_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 4;\n                }\n            }\n        } else if (type == 'f') {\n            str.s[str.l++] = 'f';\n            float_to_le(strtod(q, &q), (uint8_t *) str.s + str.l);\n            str.l += sizeof(float);\n        } else if (type == 'd') {\n            str.s[str.l++] = 'd';\n            double_to_le(strtod(q, &q), (uint8_t *) str.s + str.l);\n            str.l += sizeof(double);\n        } else if (type == 'Z' || type == 'H') {\n            _parse_err(type == 'H' && !((p-q)&1),\n                       \"hex field does not have an even number of digits\");\n            kputc_(type, &str);kputsn_(q, p - q, &str); // note that this include the trailing NULL\n        } else if (type == 'B') {\n            int32_t n, size;\n            size_t bytes;\n            char *r;\n            _parse_err(p - q - 1 < 3, \"incomplete B-typed aux field\");\n            type = *q++; // q points to the first ',' following the typing byte\n\n            size = aux_type2size(type);\n            _parse_err_param(size <= 0 || size > 4,\n                             \"unrecognized type B:%c\", type);\n            _parse_err(*q && *q != ',', \"B aux field type not followed by ','\");\n\n            for (r = q, n = 0; *r; ++r)\n                if (*r == ',') ++n;\n\n            // Ensure space for type + values\n            bytes = (size_t) n * (size_t) size;\n            _parse_err(bytes / size != n\n                       || ks_resize(&str, str.l + bytes + 2 + sizeof(uint32_t)),\n                       \"out of memory\");\n            str.s[str.l++] = 'B';\n            str.s[str.l++] = type;\n            i32_to_le(n, (uint8_t *) str.s + str.l);\n            str.l += sizeof(uint32_t);\n\n            // This ensures that q always ends up at the next comma after\n            // reading a number even if it's followed by junk.  It\n            // prevents the possibility of trying to read more than n items.\n#define _skip_to_comma(q, p) do { while ((q) < (p) && *(q) != ',') (q)++; } while (0)\n\n            if (type == 'c')      while (q + 1 < p) { int8_t   x = strtol(q + 1, &q, 0); kputc_(x, &str); }\n            else if (type == 'C') while (q + 1 < p) { uint8_t  x = strtoul(q + 1, &q, 0); kputc_(x, &str); }\n            else if (type == 's') while (q + 1 < p) { i16_to_le(strtol(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 2; _skip_to_comma(q, p); }\n            else if (type == 'S') while (q + 1 < p) { u16_to_le(strtoul(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 2; _skip_to_comma(q, p); }\n            else if (type == 'i') while (q + 1 < p) { i32_to_le(strtol(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else if (type == 'I') while (q + 1 < p) { u32_to_le(strtoul(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else if (type == 'f') while (q + 1 < p) { float_to_le(strtod(q + 1, &q), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else _parse_err_param(1, \"unrecognized type B:%c\", type);\n\n#undef _skip_to_comma\n\n        } else _parse_err_param(1, \"unrecognized type %c\", type);\n    }\n    b->data = (uint8_t*)str.s; b->l_data = str.l; b->m_data = str.m;\n    if (bam_tag2cigar(b, 1, 1) < 0)\n        return -2;\n    return 0;\n\n#undef _parse_warn\n#undef _parse_err\n#undef _parse_err_param\n#undef _get_mem\n#undef _read_token_aux\n#undef _read_token\nerr_ret:\n    b->data = (uint8_t*)str.s; b->l_data = str.l; b->m_data = str.m;\n    return -2;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -109,7 +109,7 @@\n         _get_mem(uint8_t, &t, &str, i);\n         memset(t, 0, i);\n         for (i = 0; i < c->l_qseq; ++i)\n-            t[i>>1] |= seq_nt16_table[(int)q[i]] << ((~i&1)<<2);\n+            t[i>>1] |= seq_nt16_table[(unsigned char)q[i]] << ((~i&1)<<2);\n     } else c->l_qseq = 0;\n     // qual\n     q = _read_token_aux(p);",
        "diff_line_info": {
            "deleted_lines": [
                "            t[i>>1] |= seq_nt16_table[(int)q[i]] << ((~i&1)<<2);"
            ],
            "added_lines": [
                "            t[i>>1] |= seq_nt16_table[(unsigned char)q[i]] << ((~i&1)<<2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-45511",
        "func_name": "justdan96/tsMuxer/IOContextDemuxer::skip_bytes",
        "description": "A memory leak in tsMuxer version git-2539d07 allows attackers to cause a Denial of Service (DoS) via a crafted MP4 file.",
        "git_url": "https://github.com/justdan96/tsMuxer/commit/bb607142cb1b621c2287dfee9da24ecb144c24b1",
        "commit_title": "Regression on Mov File Seek",
        "commit_text": " Until unforeseen issues are solved (with some mp4, fail to complete muxing see issue #780).",
        "func_before": "void IOContextDemuxer::skip_bytes(const int64_t size)\n{\n    if (size == 0)\n        return;\n    uint32_t readedBytes = 0;\n    int readRez = 0;\n    int64_t skipLeft = size;\n\n    if (m_curPos < m_bufEnd)\n    {\n        const int64_t copyLen = min(m_bufEnd - m_curPos, skipLeft);\n        skipLeft -= copyLen;\n        m_curPos += copyLen;\n        m_processedBytes += copyLen;\n    }\n    \n    while (skipLeft > 4LL * m_fileBlockSize)\n    {\n        m_bufferedReader->seek(m_readerID, m_fileBlockSize);\n        m_processedBytes += m_fileBlockSize;\n        skipLeft -= m_fileBlockSize;\n    }\n    \n    while (skipLeft > 0)\n    {\n        uint8_t* data = m_bufferedReader->readBlock(m_readerID, readedBytes, readRez);\n        if (readedBytes > 0 && readRez == 0)\n            m_bufferedReader->notify(m_readerID, readedBytes);\n        m_curPos = data + 188;\n        m_bufEnd = m_curPos + readedBytes;\n        if (readedBytes == 0)\n            break;\n        const int64_t copyLen = min(readedBytes, skipLeft);\n        m_curPos += copyLen;\n        m_processedBytes += copyLen;\n        skipLeft -= copyLen;\n    }\n}",
        "func": "void IOContextDemuxer::skip_bytes(const int64_t size)\n{\n    if (size == 0)\n        return;\n    uint32_t readedBytes = 0;\n    int readRez = 0;\n    int64_t skipLeft = size;\n\n    if (m_curPos < m_bufEnd)\n    {\n        const int64_t copyLen = min(m_bufEnd - m_curPos, skipLeft);\n        skipLeft -= copyLen;\n        m_curPos += copyLen;\n        m_processedBytes += copyLen;\n    }\n    /*\n    while (skipLeft > 4LL * m_fileBlockSize)\n    {\n        m_bufferedReader->seek(m_readerID, m_fileBlockSize);\n        m_processedBytes += m_fileBlockSize;\n        skipLeft -= m_fileBlockSize;\n    }\n    */\n    while (skipLeft > 0)\n    {\n        uint8_t* data = m_bufferedReader->readBlock(m_readerID, readedBytes, readRez);\n        if (readedBytes > 0 && readRez == 0)\n            m_bufferedReader->notify(m_readerID, readedBytes);\n        m_curPos = data + 188;\n        m_bufEnd = m_curPos + readedBytes;\n        if (readedBytes == 0)\n            break;\n        const int64_t copyLen = min(readedBytes, skipLeft);\n        m_curPos += copyLen;\n        m_processedBytes += copyLen;\n        skipLeft -= copyLen;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,14 +13,14 @@\n         m_curPos += copyLen;\n         m_processedBytes += copyLen;\n     }\n-    \n+    /*\n     while (skipLeft > 4LL * m_fileBlockSize)\n     {\n         m_bufferedReader->seek(m_readerID, m_fileBlockSize);\n         m_processedBytes += m_fileBlockSize;\n         skipLeft -= m_fileBlockSize;\n     }\n-    \n+    */\n     while (skipLeft > 0)\n     {\n         uint8_t* data = m_bufferedReader->readBlock(m_readerID, readedBytes, readRez);",
        "diff_line_info": {
            "deleted_lines": [
                "    ",
                "    "
            ],
            "added_lines": [
                "    /*",
                "    */"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-45511",
        "func_name": "justdan96/tsMuxer/H264StreamReader::checkStream",
        "description": "A memory leak in tsMuxer version git-2539d07 allows attackers to cause a Denial of Service (DoS) via a crafted MP4 file.",
        "git_url": "https://github.com/justdan96/tsMuxer/commit/78dd8fe480cdeb764f3ddc7c877f7528170661d8",
        "commit_title": "Partial fix for issue #780.",
        "commit_text": "",
        "func_before": "CheckStreamRez H264StreamReader::checkStream(uint8_t *buffer, int len)\n{\n    SEIUnit lastSEI;\n    SliceUnit slice;\n    CheckStreamRez rez;\n    uint8_t *end = buffer + len;\n    std::string tmpDescr;\n    bool pulldownInserted = false;\n    bool offsetsInserted = false;\n\n    for (uint8_t *nal = NALUnit::findNextNAL(buffer, end); nal < end - 4; nal = NALUnit::findNextNAL(nal, end))\n    {\n        if (*nal & 0x80)\n            return rez;\n        auto nalType = static_cast<NALUnit::NALType>(*nal & 0x1f);\n        const uint8_t *nextNal = NALUnit::findNALWithStartCode(nal, end, true);\n        if (!m_eof && nextNal == end)\n            break;\n\n        switch (nalType)\n        {\n        case NALUnit::NALType::nuSubSPS:\n            m_mvcSubStream = true;\n            [[fallthrough]];\n        case NALUnit::NALType::nuSPS:\n        {\n            if (nalType == NALUnit::NALType::nuSPS)\n                m_mvcPrimaryStream = true;\n            auto sps = new SPSUnit();\n            sps->decodeBuffer(nal, nextNal);\n            if (sps->deserialize() != 0)\n            {\n                delete sps;\n                return rez;\n            }\n            m_spsMap.insert(make_pair(sps->seq_parameter_set_id, sps));\n            if (tmpDescr.empty())\n                tmpDescr = sps->getStreamDescr();\n            break;\n        }\n        case NALUnit::NALType::nuPPS:\n        {\n            auto pps = new PPSUnit();\n            pps->decodeBuffer(nal, nextNal);\n            if (pps->deserialize() != 0)\n            {\n                delete pps;\n                return rez;\n            }\n            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end())\n            {\n                delete pps;\n                break;\n            }\n            m_ppsMap.insert(make_pair(pps->pic_parameter_set_id, pps));\n            break;\n        }\n        case NALUnit::NALType::nuSEI:\n            if (!m_spsMap.empty())\n            {\n                SPSUnit *sps = m_spsMap.begin()->second;\n                lastSEI.decodeBuffer(nal, nextNal);\n                lastSEI.deserialize(*sps, sps->nalHrdParams.isPresent || sps->vclHrdParams.isPresent);\n                if (lastSEI.pic_struct == 5 || lastSEI.pic_struct == 6 || lastSEI.pic_struct == 7 ||\n                    lastSEI.pic_struct == 8)\n                {\n                    if (!pulldownInserted)\n                    {\n                        pulldownInserted = true;\n                        tmpDescr = sps->getStreamDescr();\n                        tmpDescr += \" (pulldown)\";\n                    }\n                }\n                if (!offsetsInserted && lastSEI.number_of_offset_sequences >= 0)\n                {\n                    offsetsInserted = true;\n                    tmpDescr += \"  3d-pg-planes: \" + int32ToStr(lastSEI.number_of_offset_sequences);\n                }\n            }\n            break;\n\n        case NALUnit::NALType::nuSliceIDR:\n            // m_openGOP = false;\n        case NALUnit::NALType::nuSliceNonIDR:\n        case NALUnit::NALType::nuSliceA:\n        case NALUnit::NALType::nuSliceB:\n        case NALUnit::NALType::nuSliceC:\n        case NALUnit::NALType::nuSliceExt:\n            if (m_ppsMap.empty() || m_spsMap.empty())\n                break;\n            try\n            {\n                uint8_t tmpBuffer[512];\n                int toDecode = static_cast<int>(FFMIN(sizeof(tmpBuffer) - 8, nextNal - nal));\n                int decodedLen = SliceUnit::decodeNAL(nal, nal + toDecode, tmpBuffer, sizeof(tmpBuffer));\n                int nalRez = slice.deserialize(tmpBuffer, tmpBuffer + decodedLen, m_spsMap, m_ppsMap);\n                if (nalRez != 0)\n                    return rez;\n\n                if (m_mvcSubStream)\n                    rez.codecInfo = h264DepCodecInfo;\n                else\n                    rez.codecInfo = h264CodecInfo;\n                rez.streamDescr = tmpDescr;\n            }\n            catch (BitStreamException &e)\n            {\n                (void)e;\n                return rez;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n    if (m_mvcSubStream && m_mvcPrimaryStream)\n        rez.multiSubStream = true;\n\n    return rez;\n}",
        "func": "CheckStreamRez H264StreamReader::checkStream(uint8_t *buffer, int len)\n{\n    SEIUnit lastSEI;\n    SliceUnit slice;\n    CheckStreamRez rez;\n    uint8_t *end = buffer + len;\n    std::string tmpDescr;\n    bool pulldownInserted = false;\n    bool offsetsInserted = false;\n\n    for (uint8_t *nal = NALUnit::findNextNAL(buffer, end); nal < end - 4; nal = NALUnit::findNextNAL(nal, end))\n    {\n        if (*nal & 0x80)\n            return rez;\n        auto nalType = static_cast<NALUnit::NALType>(*nal & 0x1f);\n        const uint8_t *nextNal = NALUnit::findNALWithStartCode(nal, end, true);\n        if (!m_eof && nextNal == end)\n            break;\n\n        switch (nalType)\n        {\n        case NALUnit::NALType::nuSubSPS:\n            m_mvcSubStream = true;\n            [[fallthrough]];\n        case NALUnit::NALType::nuSPS:\n        {\n            if (nalType == NALUnit::NALType::nuSPS)\n                m_mvcPrimaryStream = true;\n            auto sps = new SPSUnit();\n            sps->decodeBuffer(nal, nextNal);\n            if (sps->deserialize() != 0)\n            {\n                delete sps;\n                return rez;\n            }\n            if (m_spsMap.find(sps->seq_parameter_set_id) != m_spsMap.end())\n            {\n                delete sps;\n                break;\n            }\n            m_spsMap.insert(make_pair(sps->seq_parameter_set_id, sps));\n            if (tmpDescr.empty())\n                tmpDescr = sps->getStreamDescr();\n            break;\n        }\n        case NALUnit::NALType::nuPPS:\n        {\n            auto pps = new PPSUnit();\n            pps->decodeBuffer(nal, nextNal);\n            if (pps->deserialize() != 0)\n            {\n                delete pps;\n                return rez;\n            }\n            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end() ||\n                m_ppsMap.find(pps->pic_parameter_set_id) != m_ppsMap.end())\n            {\n                delete pps;\n                break;\n            }\n            m_ppsMap.insert(make_pair(pps->pic_parameter_set_id, pps));\n            break;\n        }\n        case NALUnit::NALType::nuSEI:\n            if (!m_spsMap.empty())\n            {\n                SPSUnit *sps = m_spsMap.begin()->second;\n                lastSEI.decodeBuffer(nal, nextNal);\n                lastSEI.deserialize(*sps, sps->nalHrdParams.isPresent || sps->vclHrdParams.isPresent);\n                if (lastSEI.pic_struct == 5 || lastSEI.pic_struct == 6 || lastSEI.pic_struct == 7 ||\n                    lastSEI.pic_struct == 8)\n                {\n                    if (!pulldownInserted)\n                    {\n                        pulldownInserted = true;\n                        tmpDescr = sps->getStreamDescr();\n                        tmpDescr += \" (pulldown)\";\n                    }\n                }\n                if (!offsetsInserted && lastSEI.number_of_offset_sequences >= 0)\n                {\n                    offsetsInserted = true;\n                    tmpDescr += \"  3d-pg-planes: \" + int32ToStr(lastSEI.number_of_offset_sequences);\n                }\n            }\n            break;\n\n        case NALUnit::NALType::nuSliceIDR:\n            // m_openGOP = false;\n        case NALUnit::NALType::nuSliceNonIDR:\n        case NALUnit::NALType::nuSliceA:\n        case NALUnit::NALType::nuSliceB:\n        case NALUnit::NALType::nuSliceC:\n        case NALUnit::NALType::nuSliceExt:\n            if (m_ppsMap.empty() || m_spsMap.empty())\n                break;\n            try\n            {\n                uint8_t tmpBuffer[512];\n                int toDecode = static_cast<int>(FFMIN(sizeof(tmpBuffer) - 8, nextNal - nal));\n                int decodedLen = SliceUnit::decodeNAL(nal, nal + toDecode, tmpBuffer, sizeof(tmpBuffer));\n                int nalRez = slice.deserialize(tmpBuffer, tmpBuffer + decodedLen, m_spsMap, m_ppsMap);\n                if (nalRez != 0)\n                    return rez;\n\n                if (m_mvcSubStream)\n                    rez.codecInfo = h264DepCodecInfo;\n                else\n                    rez.codecInfo = h264CodecInfo;\n                rez.streamDescr = tmpDescr;\n            }\n            catch (BitStreamException &e)\n            {\n                (void)e;\n                return rez;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n    if (m_mvcSubStream && m_mvcPrimaryStream)\n        rez.multiSubStream = true;\n\n    return rez;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,6 +33,11 @@\n                 delete sps;\n                 return rez;\n             }\n+            if (m_spsMap.find(sps->seq_parameter_set_id) != m_spsMap.end())\n+            {\n+                delete sps;\n+                break;\n+            }\n             m_spsMap.insert(make_pair(sps->seq_parameter_set_id, sps));\n             if (tmpDescr.empty())\n                 tmpDescr = sps->getStreamDescr();\n@@ -47,7 +52,8 @@\n                 delete pps;\n                 return rez;\n             }\n-            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end())\n+            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end() ||\n+                m_ppsMap.find(pps->pic_parameter_set_id) != m_ppsMap.end())\n             {\n                 delete pps;\n                 break;",
        "diff_line_info": {
            "deleted_lines": [
                "            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end())"
            ],
            "added_lines": [
                "            if (m_spsMap.find(sps->seq_parameter_set_id) != m_spsMap.end())",
                "            {",
                "                delete sps;",
                "                break;",
                "            }",
                "            if (m_spsMap.find(pps->seq_parameter_set_id) == m_spsMap.end() ||",
                "                m_ppsMap.find(pps->pic_parameter_set_id) != m_ppsMap.end())"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-5349",
        "func_name": "rmagick/DrawOptions_initialize",
        "description": "A memory leak flaw was found in ruby-magick, an interface between Ruby and ImageMagick. This issue can lead to a denial of service (DOS) by memory exhaustion.",
        "git_url": "https://github.com/rmagick/rmagick/commit/da823515a13130010f74678dc48f8b08a70cbd14",
        "commit_title": "Fix memory leak in `Magick::Draw` for recentry ImageMagick 6 by removing unnecessary `GetDrawInfo()` calling",
        "commit_text": "",
        "func_before": "VALUE\nDrawOptions_initialize(VALUE self)\n{\n    Draw *draw_options;\n\n    TypedData_Get_Struct(self, Draw, &rm_draw_data_type, draw_options);\n    draw_options->info = AcquireDrawInfo();\n    if (!draw_options->info)\n    {\n        rb_raise(rb_eNoMemError, \"not enough memory to continue\");\n    }\n\n    GetDrawInfo(NULL, draw_options->info);\n\n    if (rb_block_given_p())\n    {\n        rb_yield(self);\n    }\n\n    return self;\n}",
        "func": "VALUE\nDrawOptions_initialize(VALUE self)\n{\n    Draw *draw_options;\n\n    TypedData_Get_Struct(self, Draw, &rm_draw_data_type, draw_options);\n    draw_options->info = AcquireDrawInfo();\n    if (!draw_options->info)\n    {\n        rb_raise(rb_eNoMemError, \"not enough memory to continue\");\n    }\n\n    if (rb_block_given_p())\n    {\n        rb_yield(self);\n    }\n\n    return self;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,6 @@\n         rb_raise(rb_eNoMemError, \"not enough memory to continue\");\n     }\n \n-    GetDrawInfo(NULL, draw_options->info);\n-\n     if (rb_block_given_p())\n     {\n         rb_yield(self);",
        "diff_line_info": {
            "deleted_lines": [
                "    GetDrawInfo(NULL, draw_options->info);",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2023-47384",
        "func_name": "gpac/isor_get_chapters",
        "description": "MP4Box GPAC v2.3-DEV-rev617-g671976fcc-master was discovered to contain a memory leak in the function gf_isom_add_chapter at /isomedia/isom_write.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted MP4 file.",
        "git_url": "https://github.com/gpac/gpac/commit/75b293cebbaa60cd97cf114121a2c3ff585d24fd",
        "commit_title": "fixed #2672",
        "commit_text": "",
        "func_before": "static void isor_get_chapters(GF_ISOFile *file, GF_FilterPid *opid)\n{\n\tu32 i, count;\n\tGF_PropertyValue p;\n\tGF_PropUIntList times;\n\tGF_PropStringList names;\n\tcount = gf_isom_get_chapter_count(file, 0);\n\tif (count) {\n\t\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\t\tnames.vals = gf_malloc(sizeof(char *)*count);\n\t\ttimes.nb_items = names.nb_items = count;\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tconst char *name;\n\t\t\tu64 start;\n\t\t\tgf_isom_get_chapter(file, 0, i+1, &start, &name);\n\t\t\ttimes.vals[i] = (u32) start;\n\t\t\tnames.vals[i] = gf_strdup(name);\n\t\t}\n\t\tp.type = GF_PROP_UINT_LIST;\n\t\tp.value.uint_list = times;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\t\tgf_free(times.vals);\n\n\t\tp.type = GF_PROP_STRING_LIST;\n\t\tp.value.string_list = names;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\t\t//no free for string lists\n\t\treturn;\n\t}\n\n\tu32 chap_tk=0;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nb_ref = gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_CHAP);\n\t\tif (nb_ref) {\n\t\t\tgf_isom_get_reference(file, i+1, GF_ISOM_REF_CHAP, 1, &chap_tk);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (chap_tk) {\n\t\tcount = gf_isom_get_sample_count(file, chap_tk);\n\t\tif (!count) chap_tk=0;\n\t}\n\tif (!chap_tk) return;\n\n\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\tnames.vals = gf_malloc(sizeof(char *)*count);\n\ttimes.nb_items = names.nb_items = count;\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 di;\n\t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text ? txt->text : \"\");\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tp.type = GF_PROP_UINT_LIST;\n\tp.value.uint_list = times;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\tgf_free(times.vals);\n\n\tp.type = GF_PROP_STRING_LIST;\n\tp.value.string_list = names;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\n}",
        "func": "static void isor_get_chapters(GF_ISOFile *file, GF_FilterPid *opid)\n{\n\tu32 i, count;\n\tGF_PropertyValue p;\n\tGF_PropUIntList times;\n\tGF_PropStringList names;\n\tcount = gf_isom_get_chapter_count(file, 0);\n\tif (count) {\n\t\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\t\tif (!times.vals) return;\n\t\tnames.vals = gf_malloc(sizeof(char *)*count);\n\t\tif (!names.vals) {\n\t\t\tgf_free(times.vals);\n\t\t\treturn;\n\t\t}\n\t\ttimes.nb_items = names.nb_items = count;\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tconst char *name;\n\t\t\tu64 start;\n\t\t\tgf_isom_get_chapter(file, 0, i+1, &start, &name);\n\t\t\ttimes.vals[i] = (u32) start;\n\t\t\tnames.vals[i] = gf_strdup(name ? name : \"\");\n\t\t}\n\t\tp.type = GF_PROP_UINT_LIST;\n\t\tp.value.uint_list = times;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\t\tgf_free(times.vals);\n\n\t\tp.type = GF_PROP_STRING_LIST;\n\t\tp.value.string_list = names;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\t\t//no free for string lists\n\t\treturn;\n\t}\n\n\tu32 chap_tk=0;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nb_ref = gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_CHAP);\n\t\tif (nb_ref) {\n\t\t\tgf_isom_get_reference(file, i+1, GF_ISOM_REF_CHAP, 1, &chap_tk);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (chap_tk) {\n\t\tcount = gf_isom_get_sample_count(file, chap_tk);\n\t\tif (!count) chap_tk=0;\n\t}\n\tif (!chap_tk) return;\n\n\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\tif (!times.vals) return;\n\tnames.vals = gf_malloc(sizeof(char *)*count);\n\tif (!names.vals) {\n\t\tgf_free(times.vals);\n\t\treturn;\n\t}\n\ttimes.nb_items = names.nb_items = count;\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 di;\n\t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n\t\tif (!s) {\n\t\t\ttimes.vals[i] = 0;\n\t\t\tnames.vals[i] = gf_strdup(\"\");\n\t\t\tcontinue;\n\t\t}\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text ? txt->text : \"\");\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tp.type = GF_PROP_UINT_LIST;\n\tp.value.uint_list = times;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\tgf_free(times.vals);\n\n\tp.type = GF_PROP_STRING_LIST;\n\tp.value.string_list = names;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,12 @@\n \tcount = gf_isom_get_chapter_count(file, 0);\n \tif (count) {\n \t\ttimes.vals = gf_malloc(sizeof(u32)*count);\n+\t\tif (!times.vals) return;\n \t\tnames.vals = gf_malloc(sizeof(char *)*count);\n+\t\tif (!names.vals) {\n+\t\t\tgf_free(times.vals);\n+\t\t\treturn;\n+\t\t}\n \t\ttimes.nb_items = names.nb_items = count;\n \n \t\tfor (i=0; i<count; i++) {\n@@ -15,7 +20,7 @@\n \t\t\tu64 start;\n \t\t\tgf_isom_get_chapter(file, 0, i+1, &start, &name);\n \t\t\ttimes.vals[i] = (u32) start;\n-\t\t\tnames.vals[i] = gf_strdup(name);\n+\t\t\tnames.vals[i] = gf_strdup(name ? name : \"\");\n \t\t}\n \t\tp.type = GF_PROP_UINT_LIST;\n \t\tp.value.uint_list = times;\n@@ -45,13 +50,22 @@\n \tif (!chap_tk) return;\n \n \ttimes.vals = gf_malloc(sizeof(u32)*count);\n+\tif (!times.vals) return;\n \tnames.vals = gf_malloc(sizeof(char *)*count);\n+\tif (!names.vals) {\n+\t\tgf_free(times.vals);\n+\t\treturn;\n+\t}\n \ttimes.nb_items = names.nb_items = count;\n \n \tfor (i=0; i<count; i++) {\n \t\tu32 di;\n \t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n-\t\tif (!s) continue;\n+\t\tif (!s) {\n+\t\t\ttimes.vals[i] = 0;\n+\t\t\tnames.vals[i] = gf_strdup(\"\");\n+\t\t\tcontinue;\n+\t\t}\n \t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n \t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n \t\tif (txt) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tnames.vals[i] = gf_strdup(name);",
                "\t\tif (!s) continue;"
            ],
            "added_lines": [
                "\t\tif (!times.vals) return;",
                "\t\tif (!names.vals) {",
                "\t\t\tgf_free(times.vals);",
                "\t\t\treturn;",
                "\t\t}",
                "\t\t\tnames.vals[i] = gf_strdup(name ? name : \"\");",
                "\tif (!times.vals) return;",
                "\tif (!names.vals) {",
                "\t\tgf_free(times.vals);",
                "\t\treturn;",
                "\t}",
                "\t\tif (!s) {",
                "\t\t\ttimes.vals[i] = 0;",
                "\t\t\tnames.vals[i] = gf_strdup(\"\");",
                "\t\t\tcontinue;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-41102",
        "func_name": "openNDS/redirect_to_splashpage",
        "description": "An issue was discovered in the captive portal in OpenNDS before version 10.1.3. It has multiple memory leaks due to not freeing up allocated memory. This may lead to a Denial-of-Service condition due to the consumption of all available memory.",
        "git_url": "https://github.com/openNDS/openNDS/commit/31dbf4aa069c5bb39a7926d86036ce3b04312b51",
        "commit_title": "Fix - memory leak when deleting client from client list",
        "commit_text": "",
        "func_before": "static int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\tchar *originurl_raw;\n\tchar *originurl;\n\tchar *query;\n\tint ret = 0;\n\tconst char *separator = \"&\";\n\tchar *querystr;\n\n\tquery = safe_calloc(QUERYMAXLEN);\n\n\tif (!query) {\n\t\tret = send_error(connection, 503);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\n\tquerystr = safe_calloc(QUERYMAXLEN);\n\n\tif (!querystr) {\n\t\tret = send_error(connection, 503);\n\t\tfree(querystr);\n\t\treturn ret;\n\t}\n\n\toriginurl_raw = safe_calloc(MID_BUF);\n\n\tif (!originurl_raw) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl_raw);\n\t\treturn ret;\n\t}\n\n\toriginurl = safe_calloc(CUSTOM_ENC);\n\n\tif (!originurl) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl);\n\t\treturn ret;\n\t}\n\n\tget_query(connection, &query, separator);\n\n\tif (!query) {\n\t\tdebug(LOG_DEBUG, \"Unable to get query string - error 503\");\n\t\tfree(query);\n\t\t// probably no mem\n\t\treturn send_error(connection, 503);\n\t}\n\n\tdebug(LOG_DEBUG, \"Query string is [ %s ]\", query);\n\n\tsafe_asprintf(&originurl_raw, \"http://%s%s%s\", host, url, query);\n\tuh_urlencode(originurl, CUSTOM_ENC, originurl_raw, strlen(originurl_raw));\n\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tclient->cpi_query = safe_strdup(originurl);\n\t\tdebug(LOG_DEBUG, \"RFC8910 request: %s\", client->cpi_query);\n\t} else {\n\t\tclient->cpi_query = \"none\";\n\t}\n\n\tdebug(LOG_DEBUG, \"originurl_raw: %s\", originurl_raw);\n\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\n\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\tfree(originurl_raw);\n\tfree(originurl);\n\tfree(query);\n\tfree(querystr);\n\treturn ret;\n}",
        "func": "static int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\tchar *originurl_raw;\n\tchar *originurl;\n\tchar *query;\n\tint ret = 0;\n\tconst char *separator = \"&\";\n\tchar *querystr;\n\n\tquery = safe_calloc(QUERYMAXLEN);\n\n\tif (!query) {\n\t\tret = send_error(connection, 503);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\n\tquerystr = safe_calloc(QUERYMAXLEN);\n\n\tif (!querystr) {\n\t\tret = send_error(connection, 503);\n\t\tfree(querystr);\n\t\treturn ret;\n\t}\n\n\toriginurl_raw = safe_calloc(MID_BUF);\n\n\tif (!originurl_raw) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl_raw);\n\t\treturn ret;\n\t}\n\n\toriginurl = safe_calloc(CUSTOM_ENC);\n\n\tif (!originurl) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl);\n\t\treturn ret;\n\t}\n\n\tget_query(connection, &query, separator);\n\n\tif (!query) {\n\t\tdebug(LOG_DEBUG, \"Unable to get query string - error 503\");\n\t\tfree(query);\n\t\t// probably no mem\n\t\treturn send_error(connection, 503);\n\t}\n\n\tdebug(LOG_DEBUG, \"Query string is [ %s ]\", query);\n\n\tsafe_asprintf(&originurl_raw, \"http://%s%s%s\", host, url, query);\n\tuh_urlencode(originurl, CUSTOM_ENC, originurl_raw, strlen(originurl_raw));\n\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tclient->cpi_query = safe_strdup(originurl);\n\t\tdebug(LOG_DEBUG, \"RFC8910 request: %s\", client->cpi_query);\n\t}\n\n\tdebug(LOG_DEBUG, \"originurl_raw: %s\", originurl_raw);\n\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\n\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\tfree(originurl_raw);\n\tfree(originurl);\n\tfree(query);\n\tfree(querystr);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,8 +56,6 @@\n \tif (strcmp(url, \"/login\") == 0) {\n \t\tclient->cpi_query = safe_strdup(originurl);\n \t\tdebug(LOG_DEBUG, \"RFC8910 request: %s\", client->cpi_query);\n-\t} else {\n-\t\tclient->cpi_query = \"none\";\n \t}\n \n \tdebug(LOG_DEBUG, \"originurl_raw: %s\", originurl_raw);",
        "diff_line_info": {
            "deleted_lines": [
                "\t} else {",
                "\t\tclient->cpi_query = \"none\";"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2023-41102",
        "func_name": "openNDS/client_reset",
        "description": "An issue was discovered in the captive portal in OpenNDS before version 10.1.3. It has multiple memory leaks due to not freeing up allocated memory. This may lead to a Denial-of-Service condition due to the consumption of all available memory.",
        "git_url": "https://github.com/openNDS/openNDS/commit/31dbf4aa069c5bb39a7926d86036ce3b04312b51",
        "commit_title": "Fix - memory leak when deleting client from client list",
        "commit_text": "",
        "func_before": "void client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\t// Reset traffic counters\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\n\t// Reset session time\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\n\t// Reset token and hid\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\n\t// Reset custom and client_type\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\n\t//Reset cid and remove cidfile using rmcid\n\tif (client->cid) {\n\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\n\t\tclient->cid = safe_calloc(SMALL_BUF);\n\t}\n\n}",
        "func": "void client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\t// Reset traffic counters\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\n\t// Reset session time\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\n\t// Reset token and hid\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\n\t// Reset custom, client_type and cpi_query\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\n\tif (!client->cpi_query) {\n\t\tclient->cpi_query = safe_calloc(STATUS_BUF);\n\t}\n\n\t//Reset cid and remove cidfile using rmcid\n\tif (client->cid) {\n\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\n\tclient->cid = safe_calloc(SMALL_BUF);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,9 +22,13 @@\n \tclient->hid = safe_strdup(hash);\n \tfree(hash);\n \n-\t// Reset custom and client_type\n+\t// Reset custom, client_type and cpi_query\n \tclient->custom = safe_calloc(MID_BUF);\n \tclient->client_type = safe_calloc(STATUS_BUF);\n+\n+\tif (!client->cpi_query) {\n+\t\tclient->cpi_query = safe_calloc(STATUS_BUF);\n+\t}\n \n \t//Reset cid and remove cidfile using rmcid\n \tif (client->cid) {\n@@ -37,8 +41,8 @@\n \t\t\tfree(msg);\n \t\t\tfree(cidinfo);\n \t\t}\n-\n-\t\tclient->cid = safe_calloc(SMALL_BUF);\n \t}\n \n+\tclient->cid = safe_calloc(SMALL_BUF);\n+\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t// Reset custom and client_type",
                "",
                "\t\tclient->cid = safe_calloc(SMALL_BUF);"
            ],
            "added_lines": [
                "\t// Reset custom, client_type and cpi_query",
                "",
                "\tif (!client->cpi_query) {",
                "\t\tclient->cpi_query = safe_calloc(STATUS_BUF);",
                "\t}",
                "\tclient->cid = safe_calloc(SMALL_BUF);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-41102",
        "func_name": "openNDS/_client_list_free_node",
        "description": "An issue was discovered in the captive portal in OpenNDS before version 10.1.3. It has multiple memory leaks due to not freeing up allocated memory. This may lead to a Denial-of-Service condition due to the consumption of all available memory.",
        "git_url": "https://github.com/openNDS/openNDS/commit/31dbf4aa069c5bb39a7926d86036ce3b04312b51",
        "commit_title": "Fix - memory leak when deleting client from client list",
        "commit_text": "",
        "func_before": "static void\n_client_list_free_node(t_client *client)\n{\n\n\tchar *msg;\n\tchar *cidinfo;\n\n\tif (client->cid) {\n\n\t\t// Remove any existing cidfile:\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\n\tfree(client);\n}",
        "func": "static void\n_client_list_free_node(t_client *client)\n{\n\n\tchar *msg;\n\tchar *cidinfo;\n\n\tif (client->cid) {\n\n\t\t// Remove any existing cidfile:\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\n\tfree(client->token);\n\tfree(client->hid);\n\tfree(client->custom);\n\tfree(client->client_type);\n\tfree(client->cid);\n\n\tif (strcmp(client->cpi_query, \"\") == 0) {\n\t\tfree(client->cpi_query);\n\t}\n\n\tfree(client);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,5 +18,15 @@\n \t\t}\n \t}\n \n+\tfree(client->token);\n+\tfree(client->hid);\n+\tfree(client->custom);\n+\tfree(client->client_type);\n+\tfree(client->cid);\n+\n+\tif (strcmp(client->cpi_query, \"\") == 0) {\n+\t\tfree(client->cpi_query);\n+\t}\n+\n \tfree(client);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tfree(client->token);",
                "\tfree(client->hid);",
                "\tfree(client->custom);",
                "\tfree(client->client_type);",
                "\tfree(client->cid);",
                "",
                "\tif (strcmp(client->cpi_query, \"\") == 0) {",
                "\t\tfree(client->cpi_query);",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48090",
        "func_name": "gpac/parse_attributes",
        "description": "GPAC 2.3-DEV-rev617-g671976fcc-master is vulnerable to memory leaks in extract_attributes media_tools/m3u8.c:329.",
        "git_url": "https://github.com/gpac/gpac/commit/545567420e34f1340aecc719a8be54c9758e89de",
        "commit_title": "fixed #2680",
        "commit_text": "",
        "func_before": "static char** parse_attributes(const char *line, s_accumulated_attributes *attributes) {\n\tint int_value, i;\n\tchar **ret;\n\tchar *end_ptr;\n\tif (line == NULL)\n\t\treturn NULL;\n\tif (!safe_start_equals(\"#EXT\", line))\n\t\treturn NULL;\n\tif (safe_start_equals(\"#EXT-X-ENDLIST\", line)) {\n\t\tattributes->is_playlist_ended = GF_TRUE;\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn NULL;\n\t}\n\t/* reset not accumated attributes */\n\tattributes->type = MEDIA_TYPE_UNKNOWN;\n\n\tret = extract_attributes(\"#EXT-X-TARGETDURATION:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-TARGETDURATION:<seconds> */\n\t\tif (ret[0]) {\n\t\t\tint_value = (s32) strtol(ret[0], &end_ptr, 10);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->target_duration_in_seconds = int_value;\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-MEDIA-SEQUENCE:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-MEDIA-SEQUENCE:<number> */\n\t\tif (ret[0]) {\n\t\t\tint_value = (s32)strtol(ret[0], &end_ptr, 10);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->min_media_sequence = int_value;\n\t\t\t\tattributes->current_media_seq = int_value;\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-VERSION:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-VERSION:<number> */\n\t\tif (ret[0]) {\n\t\t\tint_value = (s32)strtol(ret[0], &end_ptr, 10);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->version = int_value;\n\t\t\t}\n\t\t\t//although technically it is mandated for v2 or more, don't complain if set for v1\n\t\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\t}\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXTINF:\", line, 2);\n\tif (ret) {\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\t/* #EXTINF:<duration>,<title> */\n\t\tattributes->is_media_segment = GF_TRUE;\n\t\tif (ret[0]) {\n\t\t\tdouble double_value = strtod(ret[0], &end_ptr);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->duration_in_seconds = double_value;\n\t\t\t}\n\t\t\tif (strstr(ret[0], \".\") || (double_value > (int)double_value)) {\n\t\t\t\tM3U8_COMPATIBILITY_VERSION(3);\n\t\t\t}\n\t\t}\n\t\tif (ret[1]) {\n\t\t\tif (attributes->title) gf_free(attributes->title);\n\t\t\tattributes->title = gf_strdup(ret[1]);\n\t\t}\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-KEY:\", line, 4);\n\tif (ret) {\n\t\t/* #EXT-X-KEY:METHOD=<method>[,URI=\"<URI>\"] */\n\t\tconst char *method = \"METHOD=\";\n\t\tconst size_t method_len = strlen(method);\n\t\tif (safe_start_equals(method, ret[0])) {\n\t\t\tif (!strncmp(ret[0]+method_len, \"NONE\", 4)) {\n\t\t\t\tattributes->key_method = DRM_NONE;\n\t\t\t\tif (attributes->key_url) {\n\t\t\t\t\tgf_free(attributes->key_url);\n\t\t\t\t\tattributes->key_url = NULL;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(ret[0]+method_len, \"AES-128\", 7)) {\n\t\t\t\tattributes->key_method = DRM_AES_128;\n\t\t\t} else if (!strncmp(ret[0]+method_len, \"SAMPLE-AES\", 10)) {\n\t\t\t\tattributes->key_method = DRM_CENC;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] EXT-X-KEY method not recognized.\\n\"));\n\t\t\t}\n\t\t\tif (ret[1] != NULL && safe_start_equals(\"URI=\\\"\", ret[1])) {\n\t\t\t\tint_value = (u32) strlen(ret[1]);\n\t\t\t\tif (ret[1][int_value-1] == '\"') {\n\t\t\t\t\tif (attributes->key_url) gf_free(attributes->key_url);\n\t\t\t\t\tattributes->key_url = gf_strdup(&(ret[1][5]));\n\t\t\t\t\tif (attributes->key_url) {\n\t\t\t\t\t\tu32 klen = (u32) strlen(attributes->key_url);\n\t\t\t\t\t\tattributes->key_url[klen-1] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tattributes->has_iv = GF_FALSE;\n\t\t\tif (ret[2] != NULL && safe_start_equals(\"IV=\", ret[2])) {\n\t\t\t\tchar *IV = ret[2] + 3;\n\t\t\t\tif (!strncmp(IV, \"0x\", 2)) IV+=2;\n\t\t\t\tif (strlen(IV) != 32) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] EXT-X-KEY wrong IV len\\n\"));\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=0; i<16; i++) {\n\t\t\t\t\t\tchar szV[3];\n\t\t\t\t\t\tu32 v;\n\t\t\t\t\t\tszV[0] = IV[2*i];\n\t\t\t\t\t\tszV[1] = IV[2*i + 1];\n\t\t\t\t\t\tszV[2] = 0;\n\t\t\t\t\t\tsscanf(szV, \"%X\", &v);\n\t\t\t\t\t\tattributes->key_iv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tattributes->has_iv = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-PROGRAM-DATE-TIME:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-PROGRAM-DATE-TIME:<YYYY-MM-DDThh:mm:ssZ> */\n\t\tif (ret[0]) attributes->playlist_utc_timestamp = gf_net_parse_date(ret[0]);\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-ALLOW-CACHE:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-ALLOW-CACHE:<YES|NO> */\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH,(\"[M3U8] EXT-X-ALLOW-CACHE not supported.\\n\", line));\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-PLAYLIST-TYPE\", line, 1);\n\tif (ret) {\n\t\tif (ret[0] && !strcmp(ret[0], \"VOD\")) attributes->is_playlist_ended = GF_TRUE;\n\t\tM3U8_COMPATIBILITY_VERSION(3);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-MAP\", line, 4);\n\tif (ret) {\n\t\t/* #EXT-X-MAP:URI=\"<URI>\"] */\n\t\ti=0;\n\t\twhile (ret[i] != NULL) {\n\t\t\tchar *val = ret[i];\n\t\t\tif (val[0]==':') val++;\n\t\t\tif (safe_start_equals(\"URI=\\\"\", val)) {\n\t\t\t\tchar *uri = val + 5;\n\t\t\t\tint_value = (u32) strlen(uri);\n\t\t\t\tif (int_value > 0 && uri[int_value-1] == '\"') {\n\t\t\t\t\tif (attributes->init_url) gf_free(attributes->init_url);\n\t\t\t\t\tattributes->init_url = gf_strdup(uri);\n\t\t\t\t\tattributes->init_url[int_value-1]=0;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] Invalid URI (%s) in EXT-X-MAP\\n\", val));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (safe_start_equals(\"BYTERANGE=\\\"\", val)) {\n\t\t\t\tu64 begin, size;\n\t\t\t\tval+=10;\n\t\t\t\tif (sscanf(val, \"\\\"\"LLU\"@\"LLU\"\\\"\", &size, &begin) == 2) {\n\t\t\t\t\tif (size) {\n\t\t\t\t\t\tattributes->init_byte_range_start = begin;\n\t\t\t\t\t\tattributes->init_byte_range_end = begin + size - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] Invalid byte range %s\\n\", val));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(3);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-STREAM-INF:\", line, 10);\n\tif (ret) {\n\t\t/* #EXT-X-STREAM-INF:[attribute=value][,attribute=value]* */\n\t\ti = 0;\n\t\tattributes->is_master_playlist = GF_TRUE;\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\twhile (ret[i] != NULL) {\n\t\t\tchar *utility;\n\t\t\tif (safe_start_equals(\"BANDWIDTH=\", ret[i])) {\n\t\t\t\tutility = &(ret[i][10]);\n\t\t\t\tint_value = (s32) strtol(utility, &end_ptr, 10);\n\t\t\t\tif (end_ptr != utility)\n\t\t\t\t\tattributes->bandwidth = int_value;\n\t\t\t} else if (safe_start_equals(\"PROGRAM-ID=\", ret[i])) {\n\t\t\t\tutility = &(ret[i][11]);\n\t\t\t\tint_value = (s32) strtol(utility, &end_ptr, 10);\n\t\t\t\tif (end_ptr != utility)\n\t\t\t\t\tattributes->stream_id = int_value;\n\t\t\t} else if (safe_start_equals(\"CODECS=\\\"\", ret[i])) {\n\t\t\t\tint_value = (u32) strlen(ret[i]);\n\t\t\t\tif (ret[i][int_value-1] == '\"') {\n\t\t\t\t\tif (attributes->codecs) gf_free(attributes->codecs);\n\t\t\t\t\tattributes->codecs = gf_strdup(&(ret[i][7]));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"RESOLUTION=\", ret[i])) {\n\t\t\t\tu32 w, h;\n\t\t\t\tutility = &(ret[i][11]);\n\t\t\t\tif ((sscanf(utility, \"%dx%d\", &w, &h)==2) || (sscanf(utility, \"%dx%d,\", &w, &h)==2)) {\n\t\t\t\t\tattributes->width = w;\n\t\t\t\t\tattributes->height = h;\n\t\t\t\t}\n\t\t\t\tM3U8_COMPATIBILITY_VERSION(2);\n\t\t\t} else if (safe_start_equals(\"AUDIO=\", ret[i])) {\n\t\t\t\tassert(attributes->type == MEDIA_TYPE_UNKNOWN);\n\t\t\t\tattributes->type = MEDIA_TYPE_AUDIO;\n\t\t\t\tif (attributes->group.audio) gf_free(attributes->group.audio);\n\t\t\t\tattributes->group.audio = gf_strdup(ret[i] + 6);\n\t\t\t\tM3U8_COMPATIBILITY_VERSION(4);\n\t\t\t} else if (safe_start_equals(\"VIDEO=\", ret[i])) {\n\t\t\t\tassert(attributes->type == MEDIA_TYPE_UNKNOWN);\n\t\t\t\tattributes->type = MEDIA_TYPE_VIDEO;\n\t\t\t\tif (attributes->group.video) gf_free(attributes->group.video);\n\t\t\t\tattributes->group.video = gf_strdup(ret[i] + 6);\n\t\t\t\tM3U8_COMPATIBILITY_VERSION(4);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (!attributes->bandwidth) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-STREAM-INF: no BANDWIDTH found. Ignoring the line.\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-DISCONTINUITY\", line, 0);\n\tif (ret) {\n\t\tattributes->discontinuity = 1;\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-DISCONTINUITY-SEQUENCE\", line, 0);\n\tif (ret) {\n\t\tif (ret[0]) {\n\t\t\tint_value = (s32)strtol(ret[0], &end_ptr, 10);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->discontinuity = int_value;\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-BYTERANGE:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-BYTERANGE:<begin@end> */\n\t\tif (ret[0]) {\n\t\t\tu64 begin, size;\n\t\t\tif (sscanf(ret[0], LLU\"@\"LLU, &size, &begin) == 2) {\n\t\t\t\tif (size) {\n\t\t\t\t\tattributes->byte_range_start = begin;\n\t\t\t\t\tattributes->byte_range_end = begin + size - 1;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] Invalid byte range %s\\n\", ret[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(4);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-MEDIA:\", line, 14);\n\tif (ret) {\n\t\t/* #EXT-X-MEDIA:[TYPE={AUDIO,VIDEO}],[URI],[GROUP-ID],[LANGUAGE],[NAME],[DEFAULT={YES,NO}],[AUTOSELECT={YES,NO}] */\n\t\tM3U8_COMPATIBILITY_VERSION(4);\n\t\tattributes->is_master_playlist = GF_TRUE;\n\t\ti = 0;\n\t\twhile (ret[i] != NULL) {\n\t\t\tif (safe_start_equals(\"TYPE=\", ret[i])) {\n\t\t\t\tif (!strncmp(ret[i]+5, \"AUDIO\", 5)) {\n\t\t\t\t\tattributes->type = MEDIA_TYPE_AUDIO;\n\t\t\t\t} else if (!strncmp(ret[i]+5, \"VIDEO\", 5)) {\n\t\t\t\t\tattributes->type = MEDIA_TYPE_VIDEO;\n\t\t\t\t} else if (!strncmp(ret[i]+5, \"SUBTITLES\", 9)) {\n\t\t\t\t\tattributes->type = MEDIA_TYPE_SUBTITLES;\n\t\t\t\t} else if (!strncmp(ret[i]+5, \"CLOSED-CAPTIONS\", 15)) {\n\t\t\t\t\tattributes->type = MEDIA_TYPE_CLOSED_CAPTIONS;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Unsupported #EXT-X-MEDIA:TYPE=%s\\n\", ret[i]+5));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"URI=\\\"\", ret[i])) {\n\t\t\t\tsize_t len;\n\t\t\t\tif (attributes->mediaURL) gf_free(attributes->mediaURL);\n\t\t\t\tattributes->mediaURL = gf_strdup(ret[i]+5);\n\t\t\t\tlen = strlen(attributes->mediaURL);\n\t\t\t\tif (len && (attributes->mediaURL[len-1] == '\"')) {\n\t\t\t\t\tattributes->mediaURL[len-1] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Misformed #EXT-X-MEDIA:URI=%s. Quotes are incorrect.\\n\", ret[i]+5));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"GROUP-ID=\", ret[i])) {\n\t\t\t\tif (attributes->type == MEDIA_TYPE_AUDIO) {\n\t\t\t\t\tif (attributes->group.audio) gf_free(attributes->group.audio);\n\t\t\t\t\tattributes->group.audio = gf_strdup(ret[i]+9);\n\t\t\t\t\tattributes->stream_id = GROUP_ID_TO_PROGRAM_ID(AUDIO, attributes->group.audio);\n\t\t\t\t} else if (attributes->type == MEDIA_TYPE_VIDEO) {\n\t\t\t\t\tif (attributes->group.video) gf_free(attributes->group.video);\n\t\t\t\t\tattributes->group.video = gf_strdup(ret[i]+9);\n\t\t\t\t\tattributes->stream_id = GROUP_ID_TO_PROGRAM_ID(VIDEO, attributes->group.video);\n\t\t\t\t} else if (attributes->type == MEDIA_TYPE_SUBTITLES) {\n\t\t\t\t\tif (attributes->group.subtitle) gf_free(attributes->group.subtitle);\n\t\t\t\t\tattributes->group.subtitle = gf_strdup(ret[i]+9);\n\t\t\t\t\tattributes->stream_id = GROUP_ID_TO_PROGRAM_ID(SUBTITLES, attributes->group.subtitle);\n\t\t\t\t} else if (attributes->type == MEDIA_TYPE_CLOSED_CAPTIONS) {\n\t\t\t\t\tif (attributes->group.closed_captions) gf_free(attributes->group.closed_captions);\n\t\t\t\t\tattributes->group.closed_captions = gf_strdup(ret[i]+9);\n\t\t\t\t\tattributes->stream_id = GROUP_ID_TO_PROGRAM_ID(CLOSED_CAPTIONS, attributes->group.closed_captions);\n\t\t\t\t} else if (attributes->type == MEDIA_TYPE_UNKNOWN) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA:GROUP-ID=%s. Ignoring the line.\\n\", ret[i]+9));\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"LANGUAGE=\\\"\", ret[i])) {\n\t\t\t\tsize_t len;\n\t\t\t\tif (attributes->language) gf_free(attributes->language);\n\t\t\t\tattributes->language = gf_strdup(ret[i]+9);\n\t\t\t\tlen = strlen(attributes->language);\n\t\t\t\tif (len && (attributes->language[len-1] == '\"')) {\n\t\t\t\t\tattributes->language[len-1] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Misformed #EXT-X-MEDIA:LANGUAGE=%s. Quotes are incorrect.\\n\", ret[i]+5));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"NAME=\", ret[i])) {\n\t\t\t\tif (attributes->name) gf_free(attributes->name);\n\t\t\t\tattributes->name = gf_strdup(ret[i]+5+1);\n\t\t\t\tu32 len = (u32) strlen(attributes->name);\n\t\t\t\tif (len) attributes->name[len-1]=0;\n\t\t\t} else if (safe_start_equals(\"DEFAULT=\", ret[i])) {\n\t\t\t\tif (!strncmp(ret[i]+8, \"YES\", 3)) {\n\t\t\t\t\tattributes->is_default = GF_TRUE;\n\t\t\t\t} else if (!strncmp(ret[i]+8, \"NO\", 2)) {\n\t\t\t\t\tattributes->is_default = GF_FALSE;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA:DEFAULT=%s\\n\", ret[i]+8));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"AUTOSELECT=\", ret[i])) {\n\t\t\t\tif (!strncmp(ret[i]+11, \"YES\", 3)) {\n\t\t\t\t\tattributes->is_autoselect = GF_TRUE;\n\t\t\t\t} else if (!strncmp(ret[i]+11, \"NO\", 2)) {\n\t\t\t\t\tattributes->is_autoselect = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA:AUTOSELECT=%s\\n\", ret[i]+11));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"CHANNELS=\", ret[i])) {\n\t\t\t\tsscanf(ret[i] + 9, \"\\\"%u\\\"\", &attributes->channels);\n\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Attribute %s not supported\\n\", ret[i]));\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tif (attributes->type == MEDIA_TYPE_UNKNOWN) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: TYPE is missing. Ignoring the line.\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (attributes->type == MEDIA_TYPE_CLOSED_CAPTIONS && attributes->mediaURL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: TYPE is CLOSED-CAPTIONS but URI is present. Ignoring the URI.\\n\"));\n\t\t\tgf_free(attributes->mediaURL);\n\t\t\tattributes->mediaURL = NULL;\n\t\t}\n\t\tif ((attributes->type == MEDIA_TYPE_AUDIO && !attributes->group.audio)\n\t\t        || (attributes->type == MEDIA_TYPE_VIDEO && !attributes->group.video)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: missing GROUP-ID attribute. Ignoring the line.\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!attributes->stream_id) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: no ID was computed. Check previous errors. Ignoring the line.\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn ret;\n\t}\n\tif (!strncmp(line, \"#EXT-X-INDEPENDENT-SEGMENTS\", strlen(\"#EXT-X-INDEPENDENT-SEGMENTS\") )) {\n\t\tattributes->independent_segments = GF_TRUE;\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn NULL;\n\t}\n\tif (!strncmp(line, \"#EXT-X-I-FRAME-STREAM-INF\", strlen(\"#EXT-X-I-FRAME-STREAM-INF\") )) {\n\t\t//todo extract I/intra rate for speed adaptation\n\t\treturn NULL;\n\t}\n\tif (!strncmp(line, \"#EXT-X-PART-INF\", strlen(\"#EXT-X-PART-INF\") )) {\n\t\tattributes->low_latency = GF_TRUE;\n\t\treturn NULL;\n\t}\n\t//TODO for now we don't use preload hint\n\tif (!strncmp(line, \"#EXT-X-SERVER-CONTROL\", strlen(\"#EXT-X-SERVER-CONTROL\") )) {\n\t\treturn NULL;\n\t}\n\t//TODO for now we don't use preload hint\n\tif (!strncmp(line, \"#EXT-X-PRELOAD-HINT\", strlen(\"#EXT-X-PRELOAD-HINT\") )) {\n\t\treturn NULL;\n\t}\n\t//TODO for now we don't use preload hint\n\tif (!strncmp(line, \"#EXT-X-RENDITION-REPORT\", strlen(\"#EXT-X-RENDITION-REPORT\") )) {\n\t\treturn NULL;\n\t}\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Unsupported directive %s\\n\", line));\n\treturn NULL;\n}",
        "func": "static char** parse_attributes(const char *line, s_accumulated_attributes *attributes) {\n\tint int_value, i;\n\tchar **ret;\n\tchar *end_ptr;\n\tif (line == NULL)\n\t\treturn NULL;\n\tif (!safe_start_equals(\"#EXT\", line))\n\t\treturn NULL;\n\tif (safe_start_equals(\"#EXT-X-ENDLIST\", line)) {\n\t\tattributes->is_playlist_ended = GF_TRUE;\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn NULL;\n\t}\n\t/* reset not accumated attributes */\n\tattributes->type = MEDIA_TYPE_UNKNOWN;\n\n\tret = extract_attributes(\"#EXT-X-TARGETDURATION:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-TARGETDURATION:<seconds> */\n\t\tif (ret[0]) {\n\t\t\tint_value = (s32) strtol(ret[0], &end_ptr, 10);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->target_duration_in_seconds = int_value;\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-MEDIA-SEQUENCE:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-MEDIA-SEQUENCE:<number> */\n\t\tif (ret[0]) {\n\t\t\tint_value = (s32)strtol(ret[0], &end_ptr, 10);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->min_media_sequence = int_value;\n\t\t\t\tattributes->current_media_seq = int_value;\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-VERSION:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-VERSION:<number> */\n\t\tif (ret[0]) {\n\t\t\tint_value = (s32)strtol(ret[0], &end_ptr, 10);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->version = int_value;\n\t\t\t}\n\t\t\t//although technically it is mandated for v2 or more, don't complain if set for v1\n\t\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\t}\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXTINF:\", line, 2);\n\tif (ret) {\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\t/* #EXTINF:<duration>,<title> */\n\t\tattributes->is_media_segment = GF_TRUE;\n\t\tif (ret[0]) {\n\t\t\tdouble double_value = strtod(ret[0], &end_ptr);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->duration_in_seconds = double_value;\n\t\t\t}\n\t\t\tif (strstr(ret[0], \".\") || (double_value > (int)double_value)) {\n\t\t\t\tM3U8_COMPATIBILITY_VERSION(3);\n\t\t\t}\n\t\t}\n\t\tif (ret[1]) {\n\t\t\tif (attributes->title) gf_free(attributes->title);\n\t\t\tattributes->title = gf_strdup(ret[1]);\n\t\t}\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-KEY:\", line, 4);\n\tif (ret) {\n\t\t/* #EXT-X-KEY:METHOD=<method>[,URI=\"<URI>\"] */\n\t\tconst char *method = \"METHOD=\";\n\t\tconst size_t method_len = strlen(method);\n\t\tif (safe_start_equals(method, ret[0])) {\n\t\t\tif (!strncmp(ret[0]+method_len, \"NONE\", 4)) {\n\t\t\t\tattributes->key_method = DRM_NONE;\n\t\t\t\tif (attributes->key_url) {\n\t\t\t\t\tgf_free(attributes->key_url);\n\t\t\t\t\tattributes->key_url = NULL;\n\t\t\t\t}\n\t\t\t} else if (!strncmp(ret[0]+method_len, \"AES-128\", 7)) {\n\t\t\t\tattributes->key_method = DRM_AES_128;\n\t\t\t} else if (!strncmp(ret[0]+method_len, \"SAMPLE-AES\", 10)) {\n\t\t\t\tattributes->key_method = DRM_CENC;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] EXT-X-KEY method not recognized.\\n\"));\n\t\t\t}\n\t\t\tif (ret[1] != NULL && safe_start_equals(\"URI=\\\"\", ret[1])) {\n\t\t\t\tint_value = (u32) strlen(ret[1]);\n\t\t\t\tif (ret[1][int_value-1] == '\"') {\n\t\t\t\t\tif (attributes->key_url) gf_free(attributes->key_url);\n\t\t\t\t\tattributes->key_url = gf_strdup(&(ret[1][5]));\n\t\t\t\t\tif (attributes->key_url) {\n\t\t\t\t\t\tu32 klen = (u32) strlen(attributes->key_url);\n\t\t\t\t\t\tattributes->key_url[klen-1] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tattributes->has_iv = GF_FALSE;\n\t\t\tif (ret[2] != NULL && safe_start_equals(\"IV=\", ret[2])) {\n\t\t\t\tchar *IV = ret[2] + 3;\n\t\t\t\tif (!strncmp(IV, \"0x\", 2)) IV+=2;\n\t\t\t\tif (strlen(IV) != 32) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] EXT-X-KEY wrong IV len\\n\"));\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=0; i<16; i++) {\n\t\t\t\t\t\tchar szV[3];\n\t\t\t\t\t\tu32 v;\n\t\t\t\t\t\tszV[0] = IV[2*i];\n\t\t\t\t\t\tszV[1] = IV[2*i + 1];\n\t\t\t\t\t\tszV[2] = 0;\n\t\t\t\t\t\tsscanf(szV, \"%X\", &v);\n\t\t\t\t\t\tattributes->key_iv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tattributes->has_iv = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-PROGRAM-DATE-TIME:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-PROGRAM-DATE-TIME:<YYYY-MM-DDThh:mm:ssZ> */\n\t\tif (ret[0]) attributes->playlist_utc_timestamp = gf_net_parse_date(ret[0]);\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-ALLOW-CACHE:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-ALLOW-CACHE:<YES|NO> */\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH,(\"[M3U8] EXT-X-ALLOW-CACHE not supported.\\n\", line));\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-PLAYLIST-TYPE\", line, 1);\n\tif (ret) {\n\t\tif (ret[0] && !strcmp(ret[0], \"VOD\")) attributes->is_playlist_ended = GF_TRUE;\n\t\tM3U8_COMPATIBILITY_VERSION(3);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-MAP\", line, 4);\n\tif (ret) {\n\t\t/* #EXT-X-MAP:URI=\"<URI>\"] */\n\t\ti=0;\n\t\twhile (ret[i] != NULL) {\n\t\t\tchar *val = ret[i];\n\t\t\tif (val[0]==':') val++;\n\t\t\tif (safe_start_equals(\"URI=\\\"\", val)) {\n\t\t\t\tchar *uri = val + 5;\n\t\t\t\tint_value = (u32) strlen(uri);\n\t\t\t\tif (int_value > 0 && uri[int_value-1] == '\"') {\n\t\t\t\t\tif (attributes->init_url) gf_free(attributes->init_url);\n\t\t\t\t\tattributes->init_url = gf_strdup(uri);\n\t\t\t\t\tattributes->init_url[int_value-1]=0;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] Invalid URI (%s) in EXT-X-MAP\\n\", val));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (safe_start_equals(\"BYTERANGE=\\\"\", val)) {\n\t\t\t\tu64 begin, size;\n\t\t\t\tval+=10;\n\t\t\t\tif (sscanf(val, \"\\\"\"LLU\"@\"LLU\"\\\"\", &size, &begin) == 2) {\n\t\t\t\t\tif (size) {\n\t\t\t\t\t\tattributes->init_byte_range_start = begin;\n\t\t\t\t\t\tattributes->init_byte_range_end = begin + size - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] Invalid byte range %s\\n\", val));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(3);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-STREAM-INF:\", line, 10);\n\tif (ret) {\n\t\t/* #EXT-X-STREAM-INF:[attribute=value][,attribute=value]* */\n\t\ti = 0;\n\t\tattributes->is_master_playlist = GF_TRUE;\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\twhile (ret[i] != NULL) {\n\t\t\tchar *utility;\n\t\t\tif (safe_start_equals(\"BANDWIDTH=\", ret[i])) {\n\t\t\t\tutility = &(ret[i][10]);\n\t\t\t\tint_value = (s32) strtol(utility, &end_ptr, 10);\n\t\t\t\tif (end_ptr != utility)\n\t\t\t\t\tattributes->bandwidth = int_value;\n\t\t\t} else if (safe_start_equals(\"PROGRAM-ID=\", ret[i])) {\n\t\t\t\tutility = &(ret[i][11]);\n\t\t\t\tint_value = (s32) strtol(utility, &end_ptr, 10);\n\t\t\t\tif (end_ptr != utility)\n\t\t\t\t\tattributes->stream_id = int_value;\n\t\t\t} else if (safe_start_equals(\"CODECS=\\\"\", ret[i])) {\n\t\t\t\tint_value = (u32) strlen(ret[i]);\n\t\t\t\tif (ret[i][int_value-1] == '\"') {\n\t\t\t\t\tif (attributes->codecs) gf_free(attributes->codecs);\n\t\t\t\t\tattributes->codecs = gf_strdup(&(ret[i][7]));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"RESOLUTION=\", ret[i])) {\n\t\t\t\tu32 w, h;\n\t\t\t\tutility = &(ret[i][11]);\n\t\t\t\tif ((sscanf(utility, \"%dx%d\", &w, &h)==2) || (sscanf(utility, \"%dx%d,\", &w, &h)==2)) {\n\t\t\t\t\tattributes->width = w;\n\t\t\t\t\tattributes->height = h;\n\t\t\t\t}\n\t\t\t\tM3U8_COMPATIBILITY_VERSION(2);\n\t\t\t} else if (safe_start_equals(\"AUDIO=\", ret[i])) {\n\t\t\t\tassert(attributes->type == MEDIA_TYPE_UNKNOWN);\n\t\t\t\tattributes->type = MEDIA_TYPE_AUDIO;\n\t\t\t\tif (attributes->group.audio) gf_free(attributes->group.audio);\n\t\t\t\tattributes->group.audio = gf_strdup(ret[i] + 6);\n\t\t\t\tM3U8_COMPATIBILITY_VERSION(4);\n\t\t\t} else if (safe_start_equals(\"VIDEO=\", ret[i])) {\n\t\t\t\tassert(attributes->type == MEDIA_TYPE_UNKNOWN);\n\t\t\t\tattributes->type = MEDIA_TYPE_VIDEO;\n\t\t\t\tif (attributes->group.video) gf_free(attributes->group.video);\n\t\t\t\tattributes->group.video = gf_strdup(ret[i] + 6);\n\t\t\t\tM3U8_COMPATIBILITY_VERSION(4);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (!attributes->bandwidth) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-STREAM-INF: no BANDWIDTH found. Ignoring the line.\\n\"));\n\t\t\tfree_attrs(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-DISCONTINUITY\", line, 0);\n\tif (ret) {\n\t\tattributes->discontinuity = 1;\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-DISCONTINUITY-SEQUENCE\", line, 0);\n\tif (ret) {\n\t\tif (ret[0]) {\n\t\t\tint_value = (s32)strtol(ret[0], &end_ptr, 10);\n\t\t\tif (end_ptr != ret[0]) {\n\t\t\t\tattributes->discontinuity = int_value;\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-BYTERANGE:\", line, 1);\n\tif (ret) {\n\t\t/* #EXT-X-BYTERANGE:<begin@end> */\n\t\tif (ret[0]) {\n\t\t\tu64 begin, size;\n\t\t\tif (sscanf(ret[0], LLU\"@\"LLU, &size, &begin) == 2) {\n\t\t\t\tif (size) {\n\t\t\t\t\tattributes->byte_range_start = begin;\n\t\t\t\t\tattributes->byte_range_end = begin + size - 1;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] Invalid byte range %s\\n\", ret[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM3U8_COMPATIBILITY_VERSION(4);\n\t\treturn ret;\n\t}\n\tret = extract_attributes(\"#EXT-X-MEDIA:\", line, 14);\n\tif (ret) {\n\t\t/* #EXT-X-MEDIA:[TYPE={AUDIO,VIDEO}],[URI],[GROUP-ID],[LANGUAGE],[NAME],[DEFAULT={YES,NO}],[AUTOSELECT={YES,NO}] */\n\t\tM3U8_COMPATIBILITY_VERSION(4);\n\t\tattributes->is_master_playlist = GF_TRUE;\n\t\ti = 0;\n\t\twhile (ret[i] != NULL) {\n\t\t\tif (safe_start_equals(\"TYPE=\", ret[i])) {\n\t\t\t\tif (!strncmp(ret[i]+5, \"AUDIO\", 5)) {\n\t\t\t\t\tattributes->type = MEDIA_TYPE_AUDIO;\n\t\t\t\t} else if (!strncmp(ret[i]+5, \"VIDEO\", 5)) {\n\t\t\t\t\tattributes->type = MEDIA_TYPE_VIDEO;\n\t\t\t\t} else if (!strncmp(ret[i]+5, \"SUBTITLES\", 9)) {\n\t\t\t\t\tattributes->type = MEDIA_TYPE_SUBTITLES;\n\t\t\t\t} else if (!strncmp(ret[i]+5, \"CLOSED-CAPTIONS\", 15)) {\n\t\t\t\t\tattributes->type = MEDIA_TYPE_CLOSED_CAPTIONS;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Unsupported #EXT-X-MEDIA:TYPE=%s\\n\", ret[i]+5));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"URI=\\\"\", ret[i])) {\n\t\t\t\tsize_t len;\n\t\t\t\tif (attributes->mediaURL) gf_free(attributes->mediaURL);\n\t\t\t\tattributes->mediaURL = gf_strdup(ret[i]+5);\n\t\t\t\tlen = strlen(attributes->mediaURL);\n\t\t\t\tif (len && (attributes->mediaURL[len-1] == '\"')) {\n\t\t\t\t\tattributes->mediaURL[len-1] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Misformed #EXT-X-MEDIA:URI=%s. Quotes are incorrect.\\n\", ret[i]+5));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"GROUP-ID=\", ret[i])) {\n\t\t\t\tif (attributes->type == MEDIA_TYPE_AUDIO) {\n\t\t\t\t\tif (attributes->group.audio) gf_free(attributes->group.audio);\n\t\t\t\t\tattributes->group.audio = gf_strdup(ret[i]+9);\n\t\t\t\t\tattributes->stream_id = GROUP_ID_TO_PROGRAM_ID(AUDIO, attributes->group.audio);\n\t\t\t\t} else if (attributes->type == MEDIA_TYPE_VIDEO) {\n\t\t\t\t\tif (attributes->group.video) gf_free(attributes->group.video);\n\t\t\t\t\tattributes->group.video = gf_strdup(ret[i]+9);\n\t\t\t\t\tattributes->stream_id = GROUP_ID_TO_PROGRAM_ID(VIDEO, attributes->group.video);\n\t\t\t\t} else if (attributes->type == MEDIA_TYPE_SUBTITLES) {\n\t\t\t\t\tif (attributes->group.subtitle) gf_free(attributes->group.subtitle);\n\t\t\t\t\tattributes->group.subtitle = gf_strdup(ret[i]+9);\n\t\t\t\t\tattributes->stream_id = GROUP_ID_TO_PROGRAM_ID(SUBTITLES, attributes->group.subtitle);\n\t\t\t\t} else if (attributes->type == MEDIA_TYPE_CLOSED_CAPTIONS) {\n\t\t\t\t\tif (attributes->group.closed_captions) gf_free(attributes->group.closed_captions);\n\t\t\t\t\tattributes->group.closed_captions = gf_strdup(ret[i]+9);\n\t\t\t\t\tattributes->stream_id = GROUP_ID_TO_PROGRAM_ID(CLOSED_CAPTIONS, attributes->group.closed_captions);\n\t\t\t\t} else if (attributes->type == MEDIA_TYPE_UNKNOWN) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA:GROUP-ID=%s. Ignoring the line.\\n\", ret[i]+9));\n\t\t\t\t\tfree_attrs(ret);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"LANGUAGE=\\\"\", ret[i])) {\n\t\t\t\tsize_t len;\n\t\t\t\tif (attributes->language) gf_free(attributes->language);\n\t\t\t\tattributes->language = gf_strdup(ret[i]+9);\n\t\t\t\tlen = strlen(attributes->language);\n\t\t\t\tif (len && (attributes->language[len-1] == '\"')) {\n\t\t\t\t\tattributes->language[len-1] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Misformed #EXT-X-MEDIA:LANGUAGE=%s. Quotes are incorrect.\\n\", ret[i]+5));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"NAME=\", ret[i])) {\n\t\t\t\tif (attributes->name) gf_free(attributes->name);\n\t\t\t\tattributes->name = gf_strdup(ret[i]+5+1);\n\t\t\t\tu32 len = (u32) strlen(attributes->name);\n\t\t\t\tif (len) attributes->name[len-1]=0;\n\t\t\t} else if (safe_start_equals(\"DEFAULT=\", ret[i])) {\n\t\t\t\tif (!strncmp(ret[i]+8, \"YES\", 3)) {\n\t\t\t\t\tattributes->is_default = GF_TRUE;\n\t\t\t\t} else if (!strncmp(ret[i]+8, \"NO\", 2)) {\n\t\t\t\t\tattributes->is_default = GF_FALSE;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA:DEFAULT=%s\\n\", ret[i]+8));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"AUTOSELECT=\", ret[i])) {\n\t\t\t\tif (!strncmp(ret[i]+11, \"YES\", 3)) {\n\t\t\t\t\tattributes->is_autoselect = GF_TRUE;\n\t\t\t\t} else if (!strncmp(ret[i]+11, \"NO\", 2)) {\n\t\t\t\t\tattributes->is_autoselect = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA:AUTOSELECT=%s\\n\", ret[i]+11));\n\t\t\t\t}\n\t\t\t} else if (safe_start_equals(\"CHANNELS=\", ret[i])) {\n\t\t\t\tsscanf(ret[i] + 9, \"\\\"%u\\\"\", &attributes->channels);\n\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Attribute %s not supported\\n\", ret[i]));\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tif (attributes->type == MEDIA_TYPE_UNKNOWN) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: TYPE is missing. Ignoring the line.\\n\"));\n\t\t\tfree_attrs(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (attributes->type == MEDIA_TYPE_CLOSED_CAPTIONS && attributes->mediaURL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: TYPE is CLOSED-CAPTIONS but URI is present. Ignoring the URI.\\n\"));\n\t\t\tgf_free(attributes->mediaURL);\n\t\t\tattributes->mediaURL = NULL;\n\t\t}\n\t\tif ((attributes->type == MEDIA_TYPE_AUDIO && !attributes->group.audio)\n\t\t        || (attributes->type == MEDIA_TYPE_VIDEO && !attributes->group.video)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: missing GROUP-ID attribute. Ignoring the line.\\n\"));\n\t\t\tfree_attrs(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!attributes->stream_id) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: no ID was computed. Check previous errors. Ignoring the line.\\n\"));\n\t\t\tfree_attrs(ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn ret;\n\t}\n\tif (!strncmp(line, \"#EXT-X-INDEPENDENT-SEGMENTS\", strlen(\"#EXT-X-INDEPENDENT-SEGMENTS\") )) {\n\t\tattributes->independent_segments = GF_TRUE;\n\t\tM3U8_COMPATIBILITY_VERSION(1);\n\t\treturn NULL;\n\t}\n\tif (!strncmp(line, \"#EXT-X-I-FRAME-STREAM-INF\", strlen(\"#EXT-X-I-FRAME-STREAM-INF\") )) {\n\t\t//todo extract I/intra rate for speed adaptation\n\t\treturn NULL;\n\t}\n\tif (!strncmp(line, \"#EXT-X-PART-INF\", strlen(\"#EXT-X-PART-INF\") )) {\n\t\tattributes->low_latency = GF_TRUE;\n\t\treturn NULL;\n\t}\n\t//TODO for now we don't use preload hint\n\tif (!strncmp(line, \"#EXT-X-SERVER-CONTROL\", strlen(\"#EXT-X-SERVER-CONTROL\") )) {\n\t\treturn NULL;\n\t}\n\t//TODO for now we don't use preload hint\n\tif (!strncmp(line, \"#EXT-X-PRELOAD-HINT\", strlen(\"#EXT-X-PRELOAD-HINT\") )) {\n\t\treturn NULL;\n\t}\n\t//TODO for now we don't use preload hint\n\tif (!strncmp(line, \"#EXT-X-RENDITION-REPORT\", strlen(\"#EXT-X-RENDITION-REPORT\") )) {\n\t\treturn NULL;\n\t}\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Unsupported directive %s\\n\", line));\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -229,6 +229,7 @@\n \t\t}\n \t\tif (!attributes->bandwidth) {\n \t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-STREAM-INF: no BANDWIDTH found. Ignoring the line.\\n\"));\n+\t\t\tfree_attrs(ret);\n \t\t\treturn NULL;\n \t\t}\n \t\treturn ret;\n@@ -315,6 +316,7 @@\n \t\t\t\t\tattributes->stream_id = GROUP_ID_TO_PROGRAM_ID(CLOSED_CAPTIONS, attributes->group.closed_captions);\n \t\t\t\t} else if (attributes->type == MEDIA_TYPE_UNKNOWN) {\n \t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA:GROUP-ID=%s. Ignoring the line.\\n\", ret[i]+9));\n+\t\t\t\t\tfree_attrs(ret);\n \t\t\t\t\treturn NULL;\n \t\t\t\t}\n \t\t\t} else if (safe_start_equals(\"LANGUAGE=\\\"\", ret[i])) {\n@@ -360,6 +362,7 @@\n \n \t\tif (attributes->type == MEDIA_TYPE_UNKNOWN) {\n \t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: TYPE is missing. Ignoring the line.\\n\"));\n+\t\t\tfree_attrs(ret);\n \t\t\treturn NULL;\n \t\t}\n \t\tif (attributes->type == MEDIA_TYPE_CLOSED_CAPTIONS && attributes->mediaURL) {\n@@ -370,10 +373,12 @@\n \t\tif ((attributes->type == MEDIA_TYPE_AUDIO && !attributes->group.audio)\n \t\t        || (attributes->type == MEDIA_TYPE_VIDEO && !attributes->group.video)) {\n \t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: missing GROUP-ID attribute. Ignoring the line.\\n\"));\n+\t\t\tfree_attrs(ret);\n \t\t\treturn NULL;\n \t\t}\n \t\tif (!attributes->stream_id) {\n \t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(\"[M3U8] Invalid #EXT-X-MEDIA: no ID was computed. Check previous errors. Ignoring the line.\\n\"));\n+\t\t\tfree_attrs(ret);\n \t\t\treturn NULL;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tfree_attrs(ret);",
                "\t\t\t\t\tfree_attrs(ret);",
                "\t\t\tfree_attrs(ret);",
                "\t\t\tfree_attrs(ret);",
                "\t\t\tfree_attrs(ret);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-22049",
        "func_name": "ffmpeg/read_header",
        "description": "A Denial of Service vulnerability exists in FFmpeg 4.2 due to a memory leak in the wtvfile_open_sector function in wtvdec.c.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=373c1c9b691fd4c6831b3a114a006b639304c2af",
        "commit_title": "",
        "commit_text": "avformat/wtvdec: Fix memleak when reading header fails  Fixes #8314.  ",
        "func_before": "static int read_header(AVFormatContext *s)\n{\n    WtvContext *wtv = s->priv_data;\n    unsigned root_sector;\n    int root_size;\n    uint8_t root[WTV_SECTOR_SIZE];\n    AVIOContext *pb;\n    int64_t timeline_pos;\n    int64_t ret;\n\n    wtv->epoch          =\n    wtv->pts            =\n    wtv->last_valid_pts = AV_NOPTS_VALUE;\n\n    /* read root directory sector */\n    avio_skip(s->pb, 0x30);\n    root_size = avio_rl32(s->pb);\n    if (root_size > sizeof(root)) {\n        av_log(s, AV_LOG_ERROR, \"root directory size exceeds sector size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_skip(s->pb, 4);\n    root_sector = avio_rl32(s->pb);\n\n    ret = seek_by_sector(s->pb, root_sector, 0);\n    if (ret < 0)\n        return ret;\n    root_size = avio_read(s->pb, root, root_size);\n    if (root_size < 0)\n        return AVERROR_INVALIDDATA;\n\n    /* parse chunks up until first data chunk */\n    wtv->pb = wtvfile_open(s, root, root_size, ff_timeline_le16);\n    if (!wtv->pb) {\n        av_log(s, AV_LOG_ERROR, \"timeline data missing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ret = parse_chunks(s, SEEK_TO_DATA, 0, 0);\n    if (ret < 0)\n        return ret;\n    avio_seek(wtv->pb, -32, SEEK_CUR);\n\n    timeline_pos = avio_tell(s->pb); // save before opening another file\n\n    /* read metadata */\n    pb = wtvfile_open(s, root, root_size, ff_table_0_entries_legacy_attrib_le16);\n    if (pb) {\n        parse_legacy_attrib(s, pb);\n        wtvfile_close(pb);\n    }\n\n    s->ctx_flags |= AVFMTCTX_NOHEADER; // Needed for noStreams.wtv\n\n    /* read seek index */\n    if (s->nb_streams) {\n        AVStream *st = s->streams[0];\n        pb = wtvfile_open(s, root, root_size, ff_table_0_entries_time_le16);\n        if (pb) {\n            while(1) {\n                uint64_t timestamp = avio_rl64(pb);\n                uint64_t frame_nb  = avio_rl64(pb);\n                if (avio_feof(pb))\n                    break;\n                ff_add_index_entry(&wtv->index_entries, &wtv->nb_index_entries, &wtv->index_entries_allocated_size,\n                                   0, timestamp, frame_nb, 0, AVINDEX_KEYFRAME);\n            }\n            wtvfile_close(pb);\n\n            if (wtv->nb_index_entries) {\n                pb = wtvfile_open(s, root, root_size, ff_timeline_table_0_entries_Events_le16);\n                if (pb) {\n                    AVIndexEntry *e = wtv->index_entries;\n                    AVIndexEntry *e_end = wtv->index_entries + wtv->nb_index_entries - 1;\n                    uint64_t last_position = 0;\n                    while (1) {\n                        uint64_t frame_nb = avio_rl64(pb);\n                        uint64_t position = avio_rl64(pb);\n                        while (e <= e_end && frame_nb > e->size) {\n                            e->pos = last_position;\n                            e++;\n                        }\n                        if (avio_feof(pb))\n                            break;\n                        last_position = position;\n                    }\n                    e_end->pos = last_position;\n                    wtvfile_close(pb);\n                    st->duration = e_end->timestamp;\n                }\n            }\n        }\n    }\n\n    avio_seek(s->pb, timeline_pos, SEEK_SET);\n    return 0;\n}",
        "func": "static int read_header(AVFormatContext *s)\n{\n    WtvContext *wtv = s->priv_data;\n    unsigned root_sector;\n    int root_size;\n    uint8_t root[WTV_SECTOR_SIZE];\n    AVIOContext *pb;\n    int64_t timeline_pos;\n    int64_t ret;\n\n    wtv->epoch          =\n    wtv->pts            =\n    wtv->last_valid_pts = AV_NOPTS_VALUE;\n\n    /* read root directory sector */\n    avio_skip(s->pb, 0x30);\n    root_size = avio_rl32(s->pb);\n    if (root_size > sizeof(root)) {\n        av_log(s, AV_LOG_ERROR, \"root directory size exceeds sector size\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_skip(s->pb, 4);\n    root_sector = avio_rl32(s->pb);\n\n    ret = seek_by_sector(s->pb, root_sector, 0);\n    if (ret < 0)\n        return ret;\n    root_size = avio_read(s->pb, root, root_size);\n    if (root_size < 0)\n        return AVERROR_INVALIDDATA;\n\n    /* parse chunks up until first data chunk */\n    wtv->pb = wtvfile_open(s, root, root_size, ff_timeline_le16);\n    if (!wtv->pb) {\n        av_log(s, AV_LOG_ERROR, \"timeline data missing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ret = parse_chunks(s, SEEK_TO_DATA, 0, 0);\n    if (ret < 0) {\n        wtvfile_close(wtv->pb);\n        return ret;\n    }\n    avio_seek(wtv->pb, -32, SEEK_CUR);\n\n    timeline_pos = avio_tell(s->pb); // save before opening another file\n\n    /* read metadata */\n    pb = wtvfile_open(s, root, root_size, ff_table_0_entries_legacy_attrib_le16);\n    if (pb) {\n        parse_legacy_attrib(s, pb);\n        wtvfile_close(pb);\n    }\n\n    s->ctx_flags |= AVFMTCTX_NOHEADER; // Needed for noStreams.wtv\n\n    /* read seek index */\n    if (s->nb_streams) {\n        AVStream *st = s->streams[0];\n        pb = wtvfile_open(s, root, root_size, ff_table_0_entries_time_le16);\n        if (pb) {\n            while(1) {\n                uint64_t timestamp = avio_rl64(pb);\n                uint64_t frame_nb  = avio_rl64(pb);\n                if (avio_feof(pb))\n                    break;\n                ff_add_index_entry(&wtv->index_entries, &wtv->nb_index_entries, &wtv->index_entries_allocated_size,\n                                   0, timestamp, frame_nb, 0, AVINDEX_KEYFRAME);\n            }\n            wtvfile_close(pb);\n\n            if (wtv->nb_index_entries) {\n                pb = wtvfile_open(s, root, root_size, ff_timeline_table_0_entries_Events_le16);\n                if (pb) {\n                    AVIndexEntry *e = wtv->index_entries;\n                    AVIndexEntry *e_end = wtv->index_entries + wtv->nb_index_entries - 1;\n                    uint64_t last_position = 0;\n                    while (1) {\n                        uint64_t frame_nb = avio_rl64(pb);\n                        uint64_t position = avio_rl64(pb);\n                        while (e <= e_end && frame_nb > e->size) {\n                            e->pos = last_position;\n                            e++;\n                        }\n                        if (avio_feof(pb))\n                            break;\n                        last_position = position;\n                    }\n                    e_end->pos = last_position;\n                    wtvfile_close(pb);\n                    st->duration = e_end->timestamp;\n                }\n            }\n        }\n    }\n\n    avio_seek(s->pb, timeline_pos, SEEK_SET);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,8 +37,10 @@\n     }\n \n     ret = parse_chunks(s, SEEK_TO_DATA, 0, 0);\n-    if (ret < 0)\n+    if (ret < 0) {\n+        wtvfile_close(wtv->pb);\n         return ret;\n+    }\n     avio_seek(wtv->pb, -32, SEEK_CUR);\n \n     timeline_pos = avio_tell(s->pb); // save before opening another file",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ret < 0)"
            ],
            "added_lines": [
                "    if (ret < 0) {",
                "        wtvfile_close(wtv->pb);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-22051",
        "func_name": "ffmpeg/uninit",
        "description": "A Denial of Service vulnerability exists in FFmpeg 4.2 due to a memory leak in the filter_frame function in vf_tile.c.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=673fce6d40d9a594fb7a0ea17d296b7d3d9ea856",
        "commit_title": "",
        "commit_text": "avfilter/vf_tile: fix memory leak  Fixes #8313 ",
        "func_before": "static av_cold void uninit(AVFilterContext *ctx)\n{\n    TileContext *tile = ctx->priv;\n\n    av_frame_free(&tile->prev_out_ref);\n}",
        "func": "static av_cold void uninit(AVFilterContext *ctx)\n{\n    TileContext *tile = ctx->priv;\n\n    av_frame_free(&tile->out_ref);\n    av_frame_free(&tile->prev_out_ref);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,6 @@\n {\n     TileContext *tile = ctx->priv;\n \n+    av_frame_free(&tile->out_ref);\n     av_frame_free(&tile->prev_out_ref);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    av_frame_free(&tile->out_ref);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-22054",
        "func_name": "ffmpeg/ffmpeg_cleanup",
        "description": "A Denial of Service vulnerability exists in FFmpeg 4.2 due to a memory leak in the av_dict_set function in dict.c.",
        "git_url": "http://git.videolan.org/?p=ffmpeg.git;a=commit;h=6f2a3958cfac135c60b509a61a4fd39432d8f9a9",
        "commit_title": "",
        "commit_text": "fftools/ffmpeg: Free swresample dictionary during cleanup  Freeing this was forgotten in ad899522.  Fixes #8315 and #8316.  ",
        "func_before": "static void ffmpeg_cleanup(int ret)\n{\n    int i, j;\n\n    if (do_benchmark) {\n        int maxrss = getmaxrss() / 1024;\n        av_log(NULL, AV_LOG_INFO, \"bench: maxrss=%ikB\\n\", maxrss);\n    }\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n        FilterGraph *fg = filtergraphs[i];\n        avfilter_graph_free(&fg->graph);\n        for (j = 0; j < fg->nb_inputs; j++) {\n            while (av_fifo_size(fg->inputs[j]->frame_queue)) {\n                AVFrame *frame;\n                av_fifo_generic_read(fg->inputs[j]->frame_queue, &frame,\n                                     sizeof(frame), NULL);\n                av_frame_free(&frame);\n            }\n            av_fifo_freep(&fg->inputs[j]->frame_queue);\n            if (fg->inputs[j]->ist->sub2video.sub_queue) {\n                while (av_fifo_size(fg->inputs[j]->ist->sub2video.sub_queue)) {\n                    AVSubtitle sub;\n                    av_fifo_generic_read(fg->inputs[j]->ist->sub2video.sub_queue,\n                                         &sub, sizeof(sub), NULL);\n                    avsubtitle_free(&sub);\n                }\n                av_fifo_freep(&fg->inputs[j]->ist->sub2video.sub_queue);\n            }\n            av_buffer_unref(&fg->inputs[j]->hw_frames_ctx);\n            av_freep(&fg->inputs[j]->name);\n            av_freep(&fg->inputs[j]);\n        }\n        av_freep(&fg->inputs);\n        for (j = 0; j < fg->nb_outputs; j++) {\n            av_freep(&fg->outputs[j]->name);\n            av_freep(&fg->outputs[j]->formats);\n            av_freep(&fg->outputs[j]->channel_layouts);\n            av_freep(&fg->outputs[j]->sample_rates);\n            av_freep(&fg->outputs[j]);\n        }\n        av_freep(&fg->outputs);\n        av_freep(&fg->graph_desc);\n\n        av_freep(&filtergraphs[i]);\n    }\n    av_freep(&filtergraphs);\n\n    av_freep(&subtitle_out);\n\n    /* close files */\n    for (i = 0; i < nb_output_files; i++) {\n        OutputFile *of = output_files[i];\n        AVFormatContext *s;\n        if (!of)\n            continue;\n        s = of->ctx;\n        if (s && s->oformat && !(s->oformat->flags & AVFMT_NOFILE))\n            avio_closep(&s->pb);\n        avformat_free_context(s);\n        av_dict_free(&of->opts);\n\n        av_freep(&output_files[i]);\n    }\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n\n        if (!ost)\n            continue;\n\n        for (j = 0; j < ost->nb_bitstream_filters; j++)\n            av_bsf_free(&ost->bsf_ctx[j]);\n        av_freep(&ost->bsf_ctx);\n\n        av_frame_free(&ost->filtered_frame);\n        av_frame_free(&ost->last_frame);\n        av_dict_free(&ost->encoder_opts);\n\n        av_freep(&ost->forced_keyframes);\n        av_expr_free(ost->forced_keyframes_pexpr);\n        av_freep(&ost->avfilter);\n        av_freep(&ost->logfile_prefix);\n\n        av_freep(&ost->audio_channels_map);\n        ost->audio_channels_mapped = 0;\n\n        av_dict_free(&ost->sws_dict);\n\n        avcodec_free_context(&ost->enc_ctx);\n        avcodec_parameters_free(&ost->ref_par);\n\n        if (ost->muxing_queue) {\n            while (av_fifo_size(ost->muxing_queue)) {\n                AVPacket pkt;\n                av_fifo_generic_read(ost->muxing_queue, &pkt, sizeof(pkt), NULL);\n                av_packet_unref(&pkt);\n            }\n            av_fifo_freep(&ost->muxing_queue);\n        }\n\n        av_freep(&output_streams[i]);\n    }\n#if HAVE_THREADS\n    free_input_threads();\n#endif\n    for (i = 0; i < nb_input_files; i++) {\n        avformat_close_input(&input_files[i]->ctx);\n        av_freep(&input_files[i]);\n    }\n    for (i = 0; i < nb_input_streams; i++) {\n        InputStream *ist = input_streams[i];\n\n        av_frame_free(&ist->decoded_frame);\n        av_frame_free(&ist->filter_frame);\n        av_dict_free(&ist->decoder_opts);\n        avsubtitle_free(&ist->prev_sub.subtitle);\n        av_frame_free(&ist->sub2video.frame);\n        av_freep(&ist->filters);\n        av_freep(&ist->hwaccel_device);\n        av_freep(&ist->dts_buffer);\n\n        avcodec_free_context(&ist->dec_ctx);\n\n        av_freep(&input_streams[i]);\n    }\n\n    if (vstats_file) {\n        if (fclose(vstats_file))\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Error closing vstats file, loss of information possible: %s\\n\",\n                   av_err2str(AVERROR(errno)));\n    }\n    av_freep(&vstats_filename);\n\n    av_freep(&input_streams);\n    av_freep(&input_files);\n    av_freep(&output_streams);\n    av_freep(&output_files);\n\n    uninit_opts();\n\n    avformat_network_deinit();\n\n    if (received_sigterm) {\n        av_log(NULL, AV_LOG_INFO, \"Exiting normally, received signal %d.\\n\",\n               (int) received_sigterm);\n    } else if (ret && atomic_load(&transcode_init_done)) {\n        av_log(NULL, AV_LOG_INFO, \"Conversion failed!\\n\");\n    }\n    term_exit();\n    ffmpeg_exited = 1;\n}",
        "func": "static void ffmpeg_cleanup(int ret)\n{\n    int i, j;\n\n    if (do_benchmark) {\n        int maxrss = getmaxrss() / 1024;\n        av_log(NULL, AV_LOG_INFO, \"bench: maxrss=%ikB\\n\", maxrss);\n    }\n\n    for (i = 0; i < nb_filtergraphs; i++) {\n        FilterGraph *fg = filtergraphs[i];\n        avfilter_graph_free(&fg->graph);\n        for (j = 0; j < fg->nb_inputs; j++) {\n            while (av_fifo_size(fg->inputs[j]->frame_queue)) {\n                AVFrame *frame;\n                av_fifo_generic_read(fg->inputs[j]->frame_queue, &frame,\n                                     sizeof(frame), NULL);\n                av_frame_free(&frame);\n            }\n            av_fifo_freep(&fg->inputs[j]->frame_queue);\n            if (fg->inputs[j]->ist->sub2video.sub_queue) {\n                while (av_fifo_size(fg->inputs[j]->ist->sub2video.sub_queue)) {\n                    AVSubtitle sub;\n                    av_fifo_generic_read(fg->inputs[j]->ist->sub2video.sub_queue,\n                                         &sub, sizeof(sub), NULL);\n                    avsubtitle_free(&sub);\n                }\n                av_fifo_freep(&fg->inputs[j]->ist->sub2video.sub_queue);\n            }\n            av_buffer_unref(&fg->inputs[j]->hw_frames_ctx);\n            av_freep(&fg->inputs[j]->name);\n            av_freep(&fg->inputs[j]);\n        }\n        av_freep(&fg->inputs);\n        for (j = 0; j < fg->nb_outputs; j++) {\n            av_freep(&fg->outputs[j]->name);\n            av_freep(&fg->outputs[j]->formats);\n            av_freep(&fg->outputs[j]->channel_layouts);\n            av_freep(&fg->outputs[j]->sample_rates);\n            av_freep(&fg->outputs[j]);\n        }\n        av_freep(&fg->outputs);\n        av_freep(&fg->graph_desc);\n\n        av_freep(&filtergraphs[i]);\n    }\n    av_freep(&filtergraphs);\n\n    av_freep(&subtitle_out);\n\n    /* close files */\n    for (i = 0; i < nb_output_files; i++) {\n        OutputFile *of = output_files[i];\n        AVFormatContext *s;\n        if (!of)\n            continue;\n        s = of->ctx;\n        if (s && s->oformat && !(s->oformat->flags & AVFMT_NOFILE))\n            avio_closep(&s->pb);\n        avformat_free_context(s);\n        av_dict_free(&of->opts);\n\n        av_freep(&output_files[i]);\n    }\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n\n        if (!ost)\n            continue;\n\n        for (j = 0; j < ost->nb_bitstream_filters; j++)\n            av_bsf_free(&ost->bsf_ctx[j]);\n        av_freep(&ost->bsf_ctx);\n\n        av_frame_free(&ost->filtered_frame);\n        av_frame_free(&ost->last_frame);\n        av_dict_free(&ost->encoder_opts);\n\n        av_freep(&ost->forced_keyframes);\n        av_expr_free(ost->forced_keyframes_pexpr);\n        av_freep(&ost->avfilter);\n        av_freep(&ost->logfile_prefix);\n\n        av_freep(&ost->audio_channels_map);\n        ost->audio_channels_mapped = 0;\n\n        av_dict_free(&ost->sws_dict);\n        av_dict_free(&ost->swr_opts);\n\n        avcodec_free_context(&ost->enc_ctx);\n        avcodec_parameters_free(&ost->ref_par);\n\n        if (ost->muxing_queue) {\n            while (av_fifo_size(ost->muxing_queue)) {\n                AVPacket pkt;\n                av_fifo_generic_read(ost->muxing_queue, &pkt, sizeof(pkt), NULL);\n                av_packet_unref(&pkt);\n            }\n            av_fifo_freep(&ost->muxing_queue);\n        }\n\n        av_freep(&output_streams[i]);\n    }\n#if HAVE_THREADS\n    free_input_threads();\n#endif\n    for (i = 0; i < nb_input_files; i++) {\n        avformat_close_input(&input_files[i]->ctx);\n        av_freep(&input_files[i]);\n    }\n    for (i = 0; i < nb_input_streams; i++) {\n        InputStream *ist = input_streams[i];\n\n        av_frame_free(&ist->decoded_frame);\n        av_frame_free(&ist->filter_frame);\n        av_dict_free(&ist->decoder_opts);\n        avsubtitle_free(&ist->prev_sub.subtitle);\n        av_frame_free(&ist->sub2video.frame);\n        av_freep(&ist->filters);\n        av_freep(&ist->hwaccel_device);\n        av_freep(&ist->dts_buffer);\n\n        avcodec_free_context(&ist->dec_ctx);\n\n        av_freep(&input_streams[i]);\n    }\n\n    if (vstats_file) {\n        if (fclose(vstats_file))\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Error closing vstats file, loss of information possible: %s\\n\",\n                   av_err2str(AVERROR(errno)));\n    }\n    av_freep(&vstats_filename);\n\n    av_freep(&input_streams);\n    av_freep(&input_files);\n    av_freep(&output_streams);\n    av_freep(&output_files);\n\n    uninit_opts();\n\n    avformat_network_deinit();\n\n    if (received_sigterm) {\n        av_log(NULL, AV_LOG_INFO, \"Exiting normally, received signal %d.\\n\",\n               (int) received_sigterm);\n    } else if (ret && atomic_load(&transcode_init_done)) {\n        av_log(NULL, AV_LOG_INFO, \"Conversion failed!\\n\");\n    }\n    term_exit();\n    ffmpeg_exited = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,6 +85,7 @@\n         ost->audio_channels_mapped = 0;\n \n         av_dict_free(&ost->sws_dict);\n+        av_dict_free(&ost->swr_opts);\n \n         avcodec_free_context(&ost->enc_ctx);\n         avcodec_parameters_free(&ost->ref_par);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        av_dict_free(&ost->swr_opts);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41490",
        "func_name": "ompl/ompl::geometric::LazyPRM::~LazyPRM",
        "description": "Memory leaks in LazyPRM.cpp of OMPL v1.5.0 can cause unexpected behavior.",
        "git_url": "https://github.com/ompl/ompl/commit/5587c98a594e0452c06742d9c62134c2a5ecfbba",
        "commit_title": "Addresses #833",
        "commit_text": "",
        "func_before": "ompl::geometric::LazyPRM::~LazyPRM() = default;",
        "func": "ompl::geometric::LazyPRM::~LazyPRM()\n{\n    clear();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1 +1,4 @@\n-ompl::geometric::LazyPRM::~LazyPRM() = default;\n+ompl::geometric::LazyPRM::~LazyPRM()\n+{\n+    clear();\n+}",
        "diff_line_info": {
            "deleted_lines": [
                "ompl::geometric::LazyPRM::~LazyPRM() = default;"
            ],
            "added_lines": [
                "ompl::geometric::LazyPRM::~LazyPRM()",
                "{",
                "    clear();",
                "}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28096",
        "func_name": "OpenSIPS/opensips/parse_object",
        "description": "OpenSIPS, a Session Initiation Protocol (SIP) server implementation, has a memory leak starting in the 2.3 branch and priot to versions 3.1.8 and 3.2.5. The memory leak was detected in the function `parse_mi_request` while performing coverage-guided fuzzing. This issue can be reproduced by sending multiple requests of the form `{\"jsonrpc\": \"2.0\",\"method\": \"log_le`. This malformed message was tested against an instance of OpenSIPS via FIFO transport layer and was found to increase the memory consumption over time.\n\nTo abuse this memory leak, attackers need to reach the management interface (MI) which typically should only be exposed on trusted interfaces. In cases where the MI is exposed to the internet without authentication, abuse of this issue will lead to memory exhaustion which may affect the underlying systems availability. No authentication is typically required to reproduce this issue. On the other hand, memory leaks may occur in other areas of OpenSIPS where the cJSON library is used for parsing JSON objects.\n\nThe issue has been fixed in versions 3.1.8 and 3.2.5.",
        "git_url": "https://github.com/OpenSIPS/opensips/commit/417568707520af25ec5c5dd91da18e6db3649dcb",
        "commit_title": "cJSON: fix memory leak on object parsing error",
        "commit_text": " Issue discovered during OpenSIPS Security Audit 2021/2022, by Alfred Farrugia & Sandro Gauci (Enable Security)  https://github.com/OpenSIPS/opensips/security/advisories/GHSA-2mg2-g46r-j4qr",
        "func_before": "static const unsigned char *parse_object(cJSON *item, const unsigned char *value, const unsigned char **ep)\n{\n    cJSON *child = NULL;\n    if (*value != '{')\n    {\n        /* not an object! */\n        *ep = value;\n        goto fail;\n    }\n\n    item->type = cJSON_Object;\n    value = skip(value + 1);\n    if (*value == '}')\n    {\n        /* empty object. */\n        return value + 1;\n    }\n\n    child = cJSON_New_Item();\n    item->child = child;\n    if (!item->child)\n    {\n        goto fail;\n    }\n    /* parse first key */\n    value = skip(parse_string(child, skip(value), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    /* use string as key, not value */\n    child->string = child->valuestring;\n    child->valuestring = NULL;\n\n    if (*value != ':')\n    {\n        /* invalid object. */\n        *ep = value;\n        goto fail;\n    }\n    /* skip any spacing, get the value. */\n    value = skip(parse_value(child, skip(value + 1), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n\n    while (*value == ',')\n    {\n        cJSON *new_item = NULL;\n        if (!(new_item = cJSON_New_Item()))\n        {\n            /* memory fail */\n            goto fail;\n        }\n        /* add to linked list */\n        child->next = new_item;\n        new_item->prev = child;\n\n        child = new_item;\n        value = skip(parse_string(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n\n        /* use string as key, not value */\n        child->string = child->valuestring;\n        child->valuestring = NULL;\n\n        if (*value != ':')\n        {\n            /* invalid object. */\n            *ep = value;\n            goto fail;\n        }\n        /* skip any spacing, get the value. */\n        value = skip(parse_value(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n    }\n    /* end of object */\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n\n    /* malformed */\n    *ep = value;\n\nfail:\n    if (item->child != NULL)\n    {\n        cJSON_Delete(child);\n        item->child = NULL;\n    }\n\n    return NULL;\n}",
        "func": "static const unsigned char *parse_object(cJSON *item, const unsigned char *value, const unsigned char **ep)\n{\n    cJSON *child = NULL;\n    if (*value != '{')\n    {\n        /* not an object! */\n        *ep = value;\n        goto fail;\n    }\n\n    item->type = cJSON_Object;\n    value = skip(value + 1);\n    if (*value == '}')\n    {\n        /* empty object. */\n        return value + 1;\n    }\n\n    child = cJSON_New_Item();\n    item->child = child;\n    if (!item->child)\n    {\n        goto fail;\n    }\n    /* parse first key */\n    value = skip(parse_string(child, skip(value), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    /* use string as key, not value */\n    child->string = child->valuestring;\n    child->valuestring = NULL;\n\n    if (*value != ':')\n    {\n        /* invalid object. */\n        *ep = value;\n        goto fail;\n    }\n    /* skip any spacing, get the value. */\n    value = skip(parse_value(child, skip(value + 1), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n\n    while (*value == ',')\n    {\n        cJSON *new_item = NULL;\n        if (!(new_item = cJSON_New_Item()))\n        {\n            /* memory fail */\n            goto fail;\n        }\n        /* add to linked list */\n        child->next = new_item;\n        new_item->prev = child;\n\n        child = new_item;\n        value = skip(parse_string(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n\n        /* use string as key, not value */\n        child->string = child->valuestring;\n        child->valuestring = NULL;\n\n        if (*value != ':')\n        {\n            /* invalid object. */\n            *ep = value;\n            goto fail;\n        }\n        /* skip any spacing, get the value. */\n        value = skip(parse_value(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n    }\n    /* end of object */\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n\n    /* malformed */\n    *ep = value;\n\nfail:\n    if (item->child != NULL)\n    {\n        cJSON_Delete(item->child);\n        item->child = NULL;\n    }\n\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -93,7 +93,7 @@\n fail:\n     if (item->child != NULL)\n     {\n-        cJSON_Delete(child);\n+        cJSON_Delete(item->child);\n         item->child = NULL;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        cJSON_Delete(child);"
            ],
            "added_lines": [
                "        cJSON_Delete(item->child);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1074",
        "func_name": "torvalds/linux/sctp_bind_addr_copy",
        "description": "A memory leak flaw was found in the Linux kernel's Stream Control Transmission Protocol. This issue may occur when a user starts a malicious networking service and someone connects to this service. This could allow a local user to starve resources, causing a denial of service.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?h=458e279f861d3f61796894cd158b780765a1569f",
        "commit_title": "Currently, if you bind the socket to something like:",
        "commit_text": "        servaddr.sin6_family = AF_INET6;         servaddr.sin6_port = htons(0);         servaddr.sin6_scope_id = 0;         inet_pton(AF_INET6, \"::1\", &servaddr.sin6_addr);  And then request a connect to:         connaddr.sin6_family = AF_INET6;         connaddr.sin6_port = htons(20000);         connaddr.sin6_scope_id = if_nametoindex(\"lo\");         inet_pton(AF_INET6, \"fe88::1\", &connaddr.sin6_addr);  What the stack does is:  - bind the socket  - create a new asoc  - to handle the connect    - copy the addresses that can be used for the given scope    - try to connect  But the copy returns 0 addresses, and the effect is that it ends up trying to connect as if the socket wasn't bound, which is not the desired behavior. This unexpected behavior also allows KASLR leaks through SCTP diag interface.  The fix here then is, if when trying to copy the addresses that can be used for the scope used in connect() it returns 0 addresses, bail out. This is what TCP does with a similar reproducer.  Link: https://lore.kernel.org/r/9fcd182f1099f86c6661f3717f63712ddd1c676c.1674496737.git.marcelo.leitner@gmail.com ",
        "func_before": "int sctp_bind_addr_copy(struct net *net, struct sctp_bind_addr *dest,\n\t\t\tconst struct sctp_bind_addr *src,\n\t\t\tenum sctp_scope scope, gfp_t gfp,\n\t\t\tint flags)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tint error = 0;\n\n\t/* All addresses share the same port.  */\n\tdest->port = src->port;\n\n\t/* Extract the addresses which are relevant for this scope.  */\n\tlist_for_each_entry(addr, &src->address_list, list) {\n\t\terror = sctp_copy_one_addr(net, dest, &addr->a, scope,\n\t\t\t\t\t   gfp, flags);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* If there are no addresses matching the scope and\n\t * this is global scope, try to get a link scope address, with\n\t * the assumption that we must be sitting behind a NAT.\n\t */\n\tif (list_empty(&dest->address_list) && (SCTP_SCOPE_GLOBAL == scope)) {\n\t\tlist_for_each_entry(addr, &src->address_list, list) {\n\t\t\terror = sctp_copy_one_addr(net, dest, &addr->a,\n\t\t\t\t\t\t   SCTP_SCOPE_LINK, gfp,\n\t\t\t\t\t\t   flags);\n\t\t\tif (error < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (error)\n\t\tsctp_bind_addr_clean(dest);\n\n\treturn error;\n}",
        "func": "int sctp_bind_addr_copy(struct net *net, struct sctp_bind_addr *dest,\n\t\t\tconst struct sctp_bind_addr *src,\n\t\t\tenum sctp_scope scope, gfp_t gfp,\n\t\t\tint flags)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tint error = 0;\n\n\t/* All addresses share the same port.  */\n\tdest->port = src->port;\n\n\t/* Extract the addresses which are relevant for this scope.  */\n\tlist_for_each_entry(addr, &src->address_list, list) {\n\t\terror = sctp_copy_one_addr(net, dest, &addr->a, scope,\n\t\t\t\t\t   gfp, flags);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* If there are no addresses matching the scope and\n\t * this is global scope, try to get a link scope address, with\n\t * the assumption that we must be sitting behind a NAT.\n\t */\n\tif (list_empty(&dest->address_list) && (SCTP_SCOPE_GLOBAL == scope)) {\n\t\tlist_for_each_entry(addr, &src->address_list, list) {\n\t\t\terror = sctp_copy_one_addr(net, dest, &addr->a,\n\t\t\t\t\t\t   SCTP_SCOPE_LINK, gfp,\n\t\t\t\t\t\t   flags);\n\t\t\tif (error < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If somehow no addresses were found that can be used with this\n\t * scope, it's an error.\n\t */\n\tif (list_empty(&dest->address_list))\n\t\terror = -ENETUNREACH;\n\nout:\n\tif (error)\n\t\tsctp_bind_addr_clean(dest);\n\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,12 @@\n \t\t}\n \t}\n \n+\t/* If somehow no addresses were found that can be used with this\n+\t * scope, it's an error.\n+\t */\n+\tif (list_empty(&dest->address_list))\n+\t\terror = -ENETUNREACH;\n+\n out:\n \tif (error)\n \t\tsctp_bind_addr_clean(dest);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/* If somehow no addresses were found that can be used with this",
                "\t * scope, it's an error.",
                "\t */",
                "\tif (list_empty(&dest->address_list))",
                "\t\terror = -ENETUNREACH;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31975",
        "func_name": "yasm/bin_section_data_destroy",
        "description": "yasm v1.3.0 was discovered to contain a memory leak via the function yasm_intnum_copy at /libyasm/intnum.c.",
        "git_url": "https://github.com/yasm/yasm/commit/168febbc155c832439be9500452ebe39994d2309",
        "commit_title": "fix issue #210",
        "commit_text": "",
        "func_before": "static void\nbin_section_data_destroy(void *data)\n{\n    bin_section_data *bsd = (bin_section_data *)data;\n    if (bsd->start)\n        yasm_expr_destroy(bsd->start);\n    if (bsd->vstart)\n        yasm_expr_destroy(bsd->vstart);\n    if (bsd->follows)\n        yasm_xfree(bsd->follows);\n    if (bsd->vfollows)\n        yasm_xfree(bsd->vfollows);\n    if (bsd->istart)\n        yasm_intnum_destroy(bsd->istart);\n    if (bsd->ivstart)\n        yasm_intnum_destroy(bsd->ivstart);\n    if (bsd->length)\n        yasm_intnum_destroy(bsd->length);\n    yasm_xfree(data);\n}",
        "func": "static void\nbin_section_data_destroy(void *data)\n{\n    bin_section_data *bsd = (bin_section_data *)data;\n    if (bsd->align)\n        yasm_xfree(bsd->align);\n    if (bsd->valign)\n        yasm_xfree(bsd->valign);\n    if (bsd->start)\n        yasm_expr_destroy(bsd->start);\n    if (bsd->vstart)\n        yasm_expr_destroy(bsd->vstart);\n    if (bsd->follows)\n        yasm_xfree(bsd->follows);\n    if (bsd->vfollows)\n        yasm_xfree(bsd->vfollows);\n    if (bsd->istart)\n        yasm_intnum_destroy(bsd->istart);\n    if (bsd->ivstart)\n        yasm_intnum_destroy(bsd->ivstart);\n    if (bsd->length)\n        yasm_intnum_destroy(bsd->length);\n    yasm_xfree(data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,10 @@\n bin_section_data_destroy(void *data)\n {\n     bin_section_data *bsd = (bin_section_data *)data;\n+    if (bsd->align)\n+        yasm_xfree(bsd->align);\n+    if (bsd->valign)\n+        yasm_xfree(bsd->valign);\n     if (bsd->start)\n         yasm_expr_destroy(bsd->start);\n     if (bsd->vstart)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (bsd->align)",
                "        yasm_xfree(bsd->align);",
                "    if (bsd->valign)",
                "        yasm_xfree(bsd->valign);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2618",
        "func_name": "opencv/opencv_contrib/DecodedBitStreamParser::decodeHanziSegment",
        "description": "A vulnerability, which was classified as problematic, has been found in OpenCV wechat_qrcode Module up to 4.7.0. Affected by this issue is the function DecodedBitStreamParser::decodeHanziSegment of the file qrcode/decoder/decoded_bit_stream_parser.cpp. The manipulation leads to memory leak. The attack may be launched remotely. The name of the patch is 2b62ff6181163eea029ed1cab11363b4996e9cd6. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-228548.",
        "git_url": "https://github.com/opencv/opencv_contrib/commit/2b62ff6181163eea029ed1cab11363b4996e9cd6",
        "commit_title": "fix(wechat_qrcode): fixed memory leaks",
        "commit_text": "",
        "func_before": "void DecodedBitStreamParser::decodeHanziSegment(Ref<BitSource> bits_, string& result, int count,\n                                                ErrorHandler& err_handler) {\n    BitSource& bits(*bits_);\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n        err_handler = zxing::FormatErrorHandler(\"decodeKanjiSegment\");\n        return;\n    }\n\n    // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as GB2312 afterwards\n    size_t nBytes = 2 * count;\n    char* buffer = new char[nBytes];\n    int offset = 0;\n    while (count > 0) {\n        // Each 13 bits encodes a 2-byte character\n        int twoBytes = bits.readBits(13, err_handler);\n        if (err_handler.ErrCode()) return;\n        int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);\n        if (assembledTwoBytes < 0x003BF) {\n            // In the 0xA1A1 to 0xAAFE range\n            assembledTwoBytes += 0x0A1A1;\n        } else {\n            // In the 0xB0A1 to 0xFAFE range\n            assembledTwoBytes += 0x0A6A1;\n        }\n        buffer[offset] = (char)((assembledTwoBytes >> 8) & 0xFF);\n        buffer[offset + 1] = (char)(assembledTwoBytes & 0xFF);\n        offset += 2;\n        count--;\n    }\n    // for(int i=0;i<nBytes;i++)\n    // cout<<buffer[i]<<endl;\n    append(result, buffer, nBytes, err_handler);\n    if (err_handler.ErrCode()) {\n        delete[] buffer;\n        return;\n    }\n\n    delete[] buffer;\n}",
        "func": "void DecodedBitStreamParser::decodeHanziSegment(Ref<BitSource> bits_, string& result, int count,\n                                                ErrorHandler& err_handler) {\n    BitSource& bits(*bits_);\n    // Don't crash trying to read more bits than we have available.\n    if (count * 13 > bits.available()) {\n        err_handler = zxing::FormatErrorHandler(\"decodeKanjiSegment\");\n        return;\n    }\n\n    // Each character will require 2 bytes. Read the characters as 2-byte pairs\n    // and decode as GB2312 afterwards\n    size_t nBytes = 2 * count;\n    char* buffer = new char[nBytes];\n    int offset = 0;\n    while (count > 0) {\n        // Each 13 bits encodes a 2-byte character\n        int twoBytes = bits.readBits(13, err_handler);\n        if (err_handler.ErrCode()) {\n            delete[] buffer;\n            return;\n        }\n        int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);\n        if (assembledTwoBytes < 0x003BF) {\n            // In the 0xA1A1 to 0xAAFE range\n            assembledTwoBytes += 0x0A1A1;\n        } else {\n            // In the 0xB0A1 to 0xFAFE range\n            assembledTwoBytes += 0x0A6A1;\n        }\n        buffer[offset] = (char)((assembledTwoBytes >> 8) & 0xFF);\n        buffer[offset + 1] = (char)(assembledTwoBytes & 0xFF);\n        offset += 2;\n        count--;\n    }\n    // for(int i=0;i<nBytes;i++)\n    // cout<<buffer[i]<<endl;\n    append(result, buffer, nBytes, err_handler);\n    if (err_handler.ErrCode()) {\n        delete[] buffer;\n        return;\n    }\n\n    delete[] buffer;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,10 @@\n     while (count > 0) {\n         // Each 13 bits encodes a 2-byte character\n         int twoBytes = bits.readBits(13, err_handler);\n-        if (err_handler.ErrCode()) return;\n+        if (err_handler.ErrCode()) {\n+            delete[] buffer;\n+            return;\n+        }\n         int assembledTwoBytes = ((twoBytes / 0x060) << 8) | (twoBytes % 0x060);\n         if (assembledTwoBytes < 0x003BF) {\n             // In the 0xA1A1 to 0xAAFE range",
        "diff_line_info": {
            "deleted_lines": [
                "        if (err_handler.ErrCode()) return;"
            ],
            "added_lines": [
                "        if (err_handler.ErrCode()) {",
                "            delete[] buffer;",
                "            return;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2700",
        "func_name": "libvirt/virPCIVirtualFunctionListFree",
        "description": "A vulnerability was found in libvirt. This security flaw ouccers due to repeatedly querying an SR-IOV PCI device's capabilities that exposes a memory leak caused by a failure to free the virPCIVirtualFunction array within the parent struct's g_autoptr cleanup.",
        "git_url": "https://gitlab.com/libvirt/libvirt/-/commit/6425a311b8ad19d6f9c0b315bf1d722551ea3585",
        "commit_title": "virpci: Resolve leak in virPCIVirtualFunctionList cleanup",
        "commit_text": " Repeatedly querying an SR-IOV PCI device's capabilities exposes a memory leak caused by a failure to free the virPCIVirtualFunction array within the parent struct's g_autoptr cleanup.  Valgrind output after getting a single interface's XML description 1000 times:  ==325982== 256,000 bytes in 1,000 blocks are definitely lost in loss record 2,634 of 2,635 ==325982==    at 0x4C3C096: realloc (vg_replace_malloc.c:1437) ==325982==    by 0x59D952D: g_realloc (in /usr/lib64/libglib-2.0.so.0.5600.4) ==325982==    by 0x4EE1F52: virReallocN (viralloc.c:52) ==325982==    by 0x4EE1FB7: virExpandN (viralloc.c:78) ==325982==    by 0x4EE219A: virInsertElementInternal (viralloc.c:183) ==325982==    by 0x4EE23B2: virAppendElement (viralloc.c:288) ==325982==    by 0x4F65D85: virPCIGetVirtualFunctionsFull (virpci.c:2389) ==325982==    by 0x4F65753: virPCIGetVirtualFunctions (virpci.c:2256) ==325982==    by 0x505CB75: virNodeDeviceGetPCISRIOVCaps (node_device_conf.c:2969) ==325982==    by 0x505D181: virNodeDeviceGetPCIDynamicCaps (node_device_conf.c:3099) ==325982==    by 0x505BC4E: virNodeDeviceUpdateCaps (node_device_conf.c:2677) ==325982==    by 0x260FCBB2: nodeDeviceGetXMLDesc (node_device_driver.c:355)  ",
        "func_before": "void\nvirPCIVirtualFunctionListFree(virPCIVirtualFunctionList *list)\n{\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nfunctions; i++) {\n        g_free(list->functions[i].addr);\n        g_free(list->functions[i].ifname);\n    }\n\n    g_free(list);\n}",
        "func": "void\nvirPCIVirtualFunctionListFree(virPCIVirtualFunctionList *list)\n{\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < list->nfunctions; i++) {\n        g_free(list->functions[i].addr);\n        g_free(list->functions[i].ifname);\n    }\n\n    g_free(list->functions);\n    g_free(list);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,5 +11,6 @@\n         g_free(list->functions[i].ifname);\n     }\n \n+    g_free(list->functions);\n     g_free(list);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    g_free(list->functions);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18806",
        "func_name": "torvalds/linux/ql_alloc_large_buffers",
        "description": "A memory leak in the ql_alloc_large_buffers() function in drivers/net/ethernet/qlogic/qla3xxx.c in the Linux kernel before 5.3.5 allows local users to cause a denial of service (memory consumption) by triggering pci_dma_mapping_error() failures, aka CID-1acb8f2a7a9f.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=1acb8f2a7a9f10543868ddd737e37424d5c36cf4",
        "commit_title": "In ql_alloc_large_buffers, a new skb is allocated via netdev_alloc_skb.",
        "commit_text": "This skb should be released if pci_dma_mapping_error fails.  ",
        "func_before": "static int ql_alloc_large_buffers(struct ql3_adapter *qdev)\n{\n\tint i;\n\tstruct ql_rcv_buf_cb *lrg_buf_cb;\n\tstruct sk_buff *skb;\n\tdma_addr_t map;\n\tint err;\n\n\tfor (i = 0; i < qdev->num_large_buffers; i++) {\n\t\tskb = netdev_alloc_skb(qdev->ndev,\n\t\t\t\t       qdev->lrg_buffer_len);\n\t\tif (unlikely(!skb)) {\n\t\t\t/* Better luck next round */\n\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t   \"large buff alloc failed for %d bytes at index %d\\n\",\n\t\t\t\t   qdev->lrg_buffer_len * 2, i);\n\t\t\tql_free_large_buffers(qdev);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\n\t\t\tlrg_buf_cb = &qdev->lrg_buf[i];\n\t\t\tmemset(lrg_buf_cb, 0, sizeof(struct ql_rcv_buf_cb));\n\t\t\tlrg_buf_cb->index = i;\n\t\t\tlrg_buf_cb->skb = skb;\n\t\t\t/*\n\t\t\t * We save some space to copy the ethhdr from first\n\t\t\t * buffer\n\t\t\t */\n\t\t\tskb_reserve(skb, QL_HEADER_SPACE);\n\t\t\tmap = pci_map_single(qdev->pdev,\n\t\t\t\t\t     skb->data,\n\t\t\t\t\t     qdev->lrg_buffer_len -\n\t\t\t\t\t     QL_HEADER_SPACE,\n\t\t\t\t\t     PCI_DMA_FROMDEVICE);\n\n\t\t\terr = pci_dma_mapping_error(qdev->pdev, map);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t\t   \"PCI mapping failed with error: %d\\n\",\n\t\t\t\t\t   err);\n\t\t\t\tql_free_large_buffers(qdev);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tdma_unmap_addr_set(lrg_buf_cb, mapaddr, map);\n\t\t\tdma_unmap_len_set(lrg_buf_cb, maplen,\n\t\t\t\t\t  qdev->lrg_buffer_len -\n\t\t\t\t\t  QL_HEADER_SPACE);\n\t\t\tlrg_buf_cb->buf_phy_addr_low =\n\t\t\t    cpu_to_le32(LS_64BITS(map));\n\t\t\tlrg_buf_cb->buf_phy_addr_high =\n\t\t\t    cpu_to_le32(MS_64BITS(map));\n\t\t}\n\t}\n\treturn 0;\n}",
        "func": "static int ql_alloc_large_buffers(struct ql3_adapter *qdev)\n{\n\tint i;\n\tstruct ql_rcv_buf_cb *lrg_buf_cb;\n\tstruct sk_buff *skb;\n\tdma_addr_t map;\n\tint err;\n\n\tfor (i = 0; i < qdev->num_large_buffers; i++) {\n\t\tskb = netdev_alloc_skb(qdev->ndev,\n\t\t\t\t       qdev->lrg_buffer_len);\n\t\tif (unlikely(!skb)) {\n\t\t\t/* Better luck next round */\n\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t   \"large buff alloc failed for %d bytes at index %d\\n\",\n\t\t\t\t   qdev->lrg_buffer_len * 2, i);\n\t\t\tql_free_large_buffers(qdev);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\n\t\t\tlrg_buf_cb = &qdev->lrg_buf[i];\n\t\t\tmemset(lrg_buf_cb, 0, sizeof(struct ql_rcv_buf_cb));\n\t\t\tlrg_buf_cb->index = i;\n\t\t\tlrg_buf_cb->skb = skb;\n\t\t\t/*\n\t\t\t * We save some space to copy the ethhdr from first\n\t\t\t * buffer\n\t\t\t */\n\t\t\tskb_reserve(skb, QL_HEADER_SPACE);\n\t\t\tmap = pci_map_single(qdev->pdev,\n\t\t\t\t\t     skb->data,\n\t\t\t\t\t     qdev->lrg_buffer_len -\n\t\t\t\t\t     QL_HEADER_SPACE,\n\t\t\t\t\t     PCI_DMA_FROMDEVICE);\n\n\t\t\terr = pci_dma_mapping_error(qdev->pdev, map);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(qdev->ndev,\n\t\t\t\t\t   \"PCI mapping failed with error: %d\\n\",\n\t\t\t\t\t   err);\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\tql_free_large_buffers(qdev);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tdma_unmap_addr_set(lrg_buf_cb, mapaddr, map);\n\t\t\tdma_unmap_len_set(lrg_buf_cb, maplen,\n\t\t\t\t\t  qdev->lrg_buffer_len -\n\t\t\t\t\t  QL_HEADER_SPACE);\n\t\t\tlrg_buf_cb->buf_phy_addr_low =\n\t\t\t    cpu_to_le32(LS_64BITS(map));\n\t\t\tlrg_buf_cb->buf_phy_addr_high =\n\t\t\t    cpu_to_le32(MS_64BITS(map));\n\t\t}\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,7 @@\n \t\t\t\tnetdev_err(qdev->ndev,\n \t\t\t\t\t   \"PCI mapping failed with error: %d\\n\",\n \t\t\t\t\t   err);\n+\t\t\t\tdev_kfree_skb_irq(skb);\n \t\t\t\tql_free_large_buffers(qdev);\n \t\t\t\treturn -ENOMEM;\n \t\t\t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tdev_kfree_skb_irq(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18807",
        "func_name": "torvalds/linux/sja1105_static_config_upload",
        "description": "Two memory leaks in the sja1105_static_config_upload() function in drivers/net/dsa/sja1105/sja1105_spi.c in the Linux kernel before 5.3.5 allow attackers to cause a denial of service (memory consumption) by triggering static_config_buf_prepare_for_upload() or sja1105_inhibit_tx() failures, aka CID-68501df92d11.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=68501df92d116b760777a2cfda314789f926476f",
        "commit_title": "In sja1105_static_config_upload, in two cases memory is leaked: when",
        "commit_text": "static_config_buf_prepare_for_upload fails and when sja1105_inhibit_tx fails. In both cases config_buf should be released.  ",
        "func_before": "int sja1105_static_config_upload(struct sja1105_private *priv)\n{\n\tunsigned long port_bitmap = GENMASK_ULL(SJA1105_NUM_PORTS - 1, 0);\n\tstruct sja1105_static_config *config = &priv->static_config;\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct device *dev = &priv->spidev->dev;\n\tstruct sja1105_status status;\n\tint rc, retries = RETRIES;\n\tu8 *config_buf;\n\tint buf_len;\n\n\tbuf_len = sja1105_static_config_get_length(config);\n\tconfig_buf = kcalloc(buf_len, sizeof(char), GFP_KERNEL);\n\tif (!config_buf)\n\t\treturn -ENOMEM;\n\n\trc = static_config_buf_prepare_for_upload(priv, config_buf, buf_len);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Invalid config, cannot upload\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* Prevent PHY jabbering during switch reset by inhibiting\n\t * Tx on all ports and waiting for current packet to drain.\n\t * Otherwise, the PHY will see an unterminated Ethernet packet.\n\t */\n\trc = sja1105_inhibit_tx(priv, port_bitmap, true);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to inhibit Tx on ports\\n\");\n\t\treturn -ENXIO;\n\t}\n\t/* Wait for an eventual egress packet to finish transmission\n\t * (reach IFG). It is guaranteed that a second one will not\n\t * follow, and that switch cold reset is thus safe\n\t */\n\tusleep_range(500, 1000);\n\tdo {\n\t\t/* Put the SJA1105 in programming mode */\n\t\trc = sja1105_cold_reset(priv);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"Failed to reset switch, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* Wait for the switch to come out of reset */\n\t\tusleep_range(1000, 5000);\n\t\t/* Upload the static config to the device */\n\t\trc = sja1105_spi_send_long_packed_buf(priv, SPI_WRITE,\n\t\t\t\t\t\t      regs->config,\n\t\t\t\t\t\t      config_buf, buf_len);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"Failed to upload config, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check that SJA1105 responded well to the config upload */\n\t\trc = sja1105_status_get(priv, &status);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\n\t\tif (status.ids == 1) {\n\t\t\tdev_err(dev, \"Mismatch between hardware and static config \"\n\t\t\t\t\"device id. Wrote 0x%llx, wants 0x%llx\\n\",\n\t\t\t\tconfig->device_id, priv->info->device_id);\n\t\t\tcontinue;\n\t\t}\n\t\tif (status.crcchkl == 1) {\n\t\t\tdev_err(dev, \"Switch reported invalid local CRC on \"\n\t\t\t\t\"the uploaded config, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status.crcchkg == 1) {\n\t\t\tdev_err(dev, \"Switch reported invalid global CRC on \"\n\t\t\t\t\"the uploaded config, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status.configs == 0) {\n\t\t\tdev_err(dev, \"Switch reported that configuration is \"\n\t\t\t\t\"invalid, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* Success! */\n\t\tbreak;\n\t} while (--retries);\n\n\tif (!retries) {\n\t\trc = -EIO;\n\t\tdev_err(dev, \"Failed to upload config to device, giving up\\n\");\n\t\tgoto out;\n\t} else if (retries != RETRIES) {\n\t\tdev_info(dev, \"Succeeded after %d tried\\n\", RETRIES - retries);\n\t}\n\n\trc = sja1105_ptp_reset(priv);\n\tif (rc < 0)\n\t\tdev_err(dev, \"Failed to reset PTP clock: %d\\n\", rc);\n\n\tdev_info(dev, \"Reset switch and programmed static config\\n\");\n\nout:\n\tkfree(config_buf);\n\treturn rc;\n}",
        "func": "int sja1105_static_config_upload(struct sja1105_private *priv)\n{\n\tunsigned long port_bitmap = GENMASK_ULL(SJA1105_NUM_PORTS - 1, 0);\n\tstruct sja1105_static_config *config = &priv->static_config;\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct device *dev = &priv->spidev->dev;\n\tstruct sja1105_status status;\n\tint rc, retries = RETRIES;\n\tu8 *config_buf;\n\tint buf_len;\n\n\tbuf_len = sja1105_static_config_get_length(config);\n\tconfig_buf = kcalloc(buf_len, sizeof(char), GFP_KERNEL);\n\tif (!config_buf)\n\t\treturn -ENOMEM;\n\n\trc = static_config_buf_prepare_for_upload(priv, config_buf, buf_len);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Invalid config, cannot upload\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Prevent PHY jabbering during switch reset by inhibiting\n\t * Tx on all ports and waiting for current packet to drain.\n\t * Otherwise, the PHY will see an unterminated Ethernet packet.\n\t */\n\trc = sja1105_inhibit_tx(priv, port_bitmap, true);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to inhibit Tx on ports\\n\");\n\t\trc = -ENXIO;\n\t\tgoto out;\n\t}\n\t/* Wait for an eventual egress packet to finish transmission\n\t * (reach IFG). It is guaranteed that a second one will not\n\t * follow, and that switch cold reset is thus safe\n\t */\n\tusleep_range(500, 1000);\n\tdo {\n\t\t/* Put the SJA1105 in programming mode */\n\t\trc = sja1105_cold_reset(priv);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"Failed to reset switch, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* Wait for the switch to come out of reset */\n\t\tusleep_range(1000, 5000);\n\t\t/* Upload the static config to the device */\n\t\trc = sja1105_spi_send_long_packed_buf(priv, SPI_WRITE,\n\t\t\t\t\t\t      regs->config,\n\t\t\t\t\t\t      config_buf, buf_len);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"Failed to upload config, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check that SJA1105 responded well to the config upload */\n\t\trc = sja1105_status_get(priv, &status);\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\n\t\tif (status.ids == 1) {\n\t\t\tdev_err(dev, \"Mismatch between hardware and static config \"\n\t\t\t\t\"device id. Wrote 0x%llx, wants 0x%llx\\n\",\n\t\t\t\tconfig->device_id, priv->info->device_id);\n\t\t\tcontinue;\n\t\t}\n\t\tif (status.crcchkl == 1) {\n\t\t\tdev_err(dev, \"Switch reported invalid local CRC on \"\n\t\t\t\t\"the uploaded config, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status.crcchkg == 1) {\n\t\t\tdev_err(dev, \"Switch reported invalid global CRC on \"\n\t\t\t\t\"the uploaded config, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (status.configs == 0) {\n\t\t\tdev_err(dev, \"Switch reported that configuration is \"\n\t\t\t\t\"invalid, retrying...\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* Success! */\n\t\tbreak;\n\t} while (--retries);\n\n\tif (!retries) {\n\t\trc = -EIO;\n\t\tdev_err(dev, \"Failed to upload config to device, giving up\\n\");\n\t\tgoto out;\n\t} else if (retries != RETRIES) {\n\t\tdev_info(dev, \"Succeeded after %d tried\\n\", RETRIES - retries);\n\t}\n\n\trc = sja1105_ptp_reset(priv);\n\tif (rc < 0)\n\t\tdev_err(dev, \"Failed to reset PTP clock: %d\\n\", rc);\n\n\tdev_info(dev, \"Reset switch and programmed static config\\n\");\n\nout:\n\tkfree(config_buf);\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,8 @@\n \trc = static_config_buf_prepare_for_upload(priv, config_buf, buf_len);\n \tif (rc < 0) {\n \t\tdev_err(dev, \"Invalid config, cannot upload\\n\");\n-\t\treturn -EINVAL;\n+\t\trc = -EINVAL;\n+\t\tgoto out;\n \t}\n \t/* Prevent PHY jabbering during switch reset by inhibiting\n \t * Tx on all ports and waiting for current packet to drain.\n@@ -26,7 +27,8 @@\n \trc = sja1105_inhibit_tx(priv, port_bitmap, true);\n \tif (rc < 0) {\n \t\tdev_err(dev, \"Failed to inhibit Tx on ports\\n\");\n-\t\treturn -ENXIO;\n+\t\trc = -ENXIO;\n+\t\tgoto out;\n \t}\n \t/* Wait for an eventual egress packet to finish transmission\n \t * (reach IFG). It is guaranteed that a second one will not",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn -EINVAL;",
                "\t\treturn -ENXIO;"
            ],
            "added_lines": [
                "\t\trc = -EINVAL;",
                "\t\tgoto out;",
                "\t\trc = -ENXIO;",
                "\t\tgoto out;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18808",
        "func_name": "torvalds/linux/ccp_run_sha_cmd",
        "description": "A memory leak in the ccp_run_sha_cmd() function in drivers/crypto/ccp/ccp-ops.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-128c66429247.",
        "git_url": "https://github.com/torvalds/linux/commit/128c66429247add5128c03dc1e144ca56f05a4e2",
        "commit_title": "crypto: ccp - Release all allocated memory if sha type is invalid",
        "commit_text": " Release all allocated memory if sha type is invalid: In ccp_run_sha_cmd, if the type of sha is invalid, the allocated hmac_buf should be released.  v2: fix the goto. ",
        "func_before": "static noinline_for_stack int\nccp_run_sha_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\n{\n\tstruct ccp_sha_engine *sha = &cmd->u.sha;\n\tstruct ccp_dm_workarea ctx;\n\tstruct ccp_data src;\n\tstruct ccp_op op;\n\tunsigned int ioffset, ooffset;\n\tunsigned int digest_size;\n\tint sb_count;\n\tconst void *init;\n\tu64 block_size;\n\tint ctx_size;\n\tint ret;\n\n\tswitch (sha->type) {\n\tcase CCP_SHA_TYPE_1:\n\t\tif (sha->ctx_len < SHA1_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA1_BLOCK_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_224:\n\t\tif (sha->ctx_len < SHA224_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA224_BLOCK_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_256:\n\t\tif (sha->ctx_len < SHA256_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA256_BLOCK_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_384:\n\t\tif (cmd_q->ccp->vdata->version < CCP_VERSION(4, 0)\n\t\t    || sha->ctx_len < SHA384_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA384_BLOCK_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_512:\n\t\tif (cmd_q->ccp->vdata->version < CCP_VERSION(4, 0)\n\t\t    || sha->ctx_len < SHA512_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA512_BLOCK_SIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sha->ctx)\n\t\treturn -EINVAL;\n\n\tif (!sha->final && (sha->src_len & (block_size - 1)))\n\t\treturn -EINVAL;\n\n\t/* The version 3 device can't handle zero-length input */\n\tif (cmd_q->ccp->vdata->version == CCP_VERSION(3, 0)) {\n\n\t\tif (!sha->src_len) {\n\t\t\tunsigned int digest_len;\n\t\t\tconst u8 *sha_zero;\n\n\t\t\t/* Not final, just return */\n\t\t\tif (!sha->final)\n\t\t\t\treturn 0;\n\n\t\t\t/* CCP can't do a zero length sha operation so the\n\t\t\t * caller must buffer the data.\n\t\t\t */\n\t\t\tif (sha->msg_bits)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The CCP cannot perform zero-length sha operations\n\t\t\t * so the caller is required to buffer data for the\n\t\t\t * final operation. However, a sha operation for a\n\t\t\t * message with a total length of zero is valid so\n\t\t\t * known values are required to supply the result.\n\t\t\t */\n\t\t\tswitch (sha->type) {\n\t\t\tcase CCP_SHA_TYPE_1:\n\t\t\t\tsha_zero = sha1_zero_message_hash;\n\t\t\t\tdigest_len = SHA1_DIGEST_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase CCP_SHA_TYPE_224:\n\t\t\t\tsha_zero = sha224_zero_message_hash;\n\t\t\t\tdigest_len = SHA224_DIGEST_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase CCP_SHA_TYPE_256:\n\t\t\t\tsha_zero = sha256_zero_message_hash;\n\t\t\t\tdigest_len = SHA256_DIGEST_SIZE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tscatterwalk_map_and_copy((void *)sha_zero, sha->ctx, 0,\n\t\t\t\t\t\t digest_len, 1);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Set variables used throughout */\n\tswitch (sha->type) {\n\tcase CCP_SHA_TYPE_1:\n\t\tdigest_size = SHA1_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha1_init;\n\t\tctx_size = SHA1_DIGEST_SIZE;\n\t\tsb_count = 1;\n\t\tif (cmd_q->ccp->vdata->version != CCP_VERSION(3, 0))\n\t\t\tooffset = ioffset = CCP_SB_BYTES - SHA1_DIGEST_SIZE;\n\t\telse\n\t\t\tooffset = ioffset = 0;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_224:\n\t\tdigest_size = SHA224_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha224_init;\n\t\tctx_size = SHA256_DIGEST_SIZE;\n\t\tsb_count = 1;\n\t\tioffset = 0;\n\t\tif (cmd_q->ccp->vdata->version != CCP_VERSION(3, 0))\n\t\t\tooffset = CCP_SB_BYTES - SHA224_DIGEST_SIZE;\n\t\telse\n\t\t\tooffset = 0;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_256:\n\t\tdigest_size = SHA256_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha256_init;\n\t\tctx_size = SHA256_DIGEST_SIZE;\n\t\tsb_count = 1;\n\t\tooffset = ioffset = 0;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_384:\n\t\tdigest_size = SHA384_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha384_init;\n\t\tctx_size = SHA512_DIGEST_SIZE;\n\t\tsb_count = 2;\n\t\tioffset = 0;\n\t\tooffset = 2 * CCP_SB_BYTES - SHA384_DIGEST_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_512:\n\t\tdigest_size = SHA512_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha512_init;\n\t\tctx_size = SHA512_DIGEST_SIZE;\n\t\tsb_count = 2;\n\t\tooffset = ioffset = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto e_data;\n\t}\n\n\t/* For zero-length plaintext the src pointer is ignored;\n\t * otherwise both parts must be valid\n\t */\n\tif (sha->src_len && !sha->src)\n\t\treturn -EINVAL;\n\n\tmemset(&op, 0, sizeof(op));\n\top.cmd_q = cmd_q;\n\top.jobid = CCP_NEW_JOBID(cmd_q->ccp);\n\top.sb_ctx = cmd_q->sb_ctx; /* Pre-allocated */\n\top.u.sha.type = sha->type;\n\top.u.sha.msg_bits = sha->msg_bits;\n\n\t/* For SHA1/224/256 the context fits in a single (32-byte) SB entry;\n\t * SHA384/512 require 2 adjacent SB slots, with the right half in the\n\t * first slot, and the left half in the second. Each portion must then\n\t * be in little endian format: use the 256-bit byte swap option.\n\t */\n\tret = ccp_init_dm_workarea(&ctx, cmd_q, sb_count * CCP_SB_BYTES,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\tif (ret)\n\t\treturn ret;\n\tif (sha->first) {\n\t\tswitch (sha->type) {\n\t\tcase CCP_SHA_TYPE_1:\n\t\tcase CCP_SHA_TYPE_224:\n\t\tcase CCP_SHA_TYPE_256:\n\t\t\tmemcpy(ctx.address + ioffset, init, ctx_size);\n\t\t\tbreak;\n\t\tcase CCP_SHA_TYPE_384:\n\t\tcase CCP_SHA_TYPE_512:\n\t\t\tmemcpy(ctx.address + ctx_size / 2, init,\n\t\t\t       ctx_size / 2);\n\t\t\tmemcpy(ctx.address, init + ctx_size / 2,\n\t\t\t       ctx_size / 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_ctx;\n\t\t}\n\t} else {\n\t\t/* Restore the context */\n\t\tret = ccp_set_dm_area(&ctx, 0, sha->ctx, 0,\n\t\t\t\t      sb_count * CCP_SB_BYTES);\n\t\tif (ret)\n\t\t\tgoto e_ctx;\n\t}\n\n\tret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_ctx;\n\t}\n\n\tif (sha->src) {\n\t\t/* Send data to the CCP SHA engine; block_size is set above */\n\t\tret = ccp_init_data(&src, cmd_q, sha->src, sha->src_len,\n\t\t\t\t    block_size, DMA_TO_DEVICE);\n\t\tif (ret)\n\t\t\tgoto e_ctx;\n\n\t\twhile (src.sg_wa.bytes_left) {\n\t\t\tccp_prepare_data(&src, NULL, &op, block_size, false);\n\t\t\tif (sha->final && !src.sg_wa.bytes_left)\n\t\t\t\top.eom = 1;\n\n\t\t\tret = cmd_q->ccp->vdata->perform->sha(&op);\n\t\t\tif (ret) {\n\t\t\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\t\t\tgoto e_data;\n\t\t\t}\n\n\t\t\tccp_process_data(&src, NULL, &op);\n\t\t}\n\t} else {\n\t\top.eom = 1;\n\t\tret = cmd_q->ccp->vdata->perform->sha(&op);\n\t\tif (ret) {\n\t\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\t\tgoto e_data;\n\t\t}\n\t}\n\n\t/* Retrieve the SHA context - convert from LE to BE using\n\t * 32-byte (256-bit) byteswapping to BE\n\t */\n\tret = ccp_copy_from_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t       CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_data;\n\t}\n\n\tif (sha->final) {\n\t\t/* Finishing up, so get the digest */\n\t\tswitch (sha->type) {\n\t\tcase CCP_SHA_TYPE_1:\n\t\tcase CCP_SHA_TYPE_224:\n\t\tcase CCP_SHA_TYPE_256:\n\t\t\tccp_get_dm_area(&ctx, ooffset,\n\t\t\t\t\tsha->ctx, 0,\n\t\t\t\t\tdigest_size);\n\t\t\tbreak;\n\t\tcase CCP_SHA_TYPE_384:\n\t\tcase CCP_SHA_TYPE_512:\n\t\t\tccp_get_dm_area(&ctx, 0,\n\t\t\t\t\tsha->ctx, LSB_ITEM_SIZE - ooffset,\n\t\t\t\t\tLSB_ITEM_SIZE);\n\t\t\tccp_get_dm_area(&ctx, LSB_ITEM_SIZE + ooffset,\n\t\t\t\t\tsha->ctx, 0,\n\t\t\t\t\tLSB_ITEM_SIZE - ooffset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_ctx;\n\t\t}\n\t} else {\n\t\t/* Stash the context */\n\t\tccp_get_dm_area(&ctx, 0, sha->ctx, 0,\n\t\t\t\tsb_count * CCP_SB_BYTES);\n\t}\n\n\tif (sha->final && sha->opad) {\n\t\t/* HMAC operation, recursively perform final SHA */\n\t\tstruct ccp_cmd hmac_cmd;\n\t\tstruct scatterlist sg;\n\t\tu8 *hmac_buf;\n\n\t\tif (sha->opad_len != block_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_data;\n\t\t}\n\n\t\thmac_buf = kmalloc(block_size + digest_size, GFP_KERNEL);\n\t\tif (!hmac_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto e_data;\n\t\t}\n\t\tsg_init_one(&sg, hmac_buf, block_size + digest_size);\n\n\t\tscatterwalk_map_and_copy(hmac_buf, sha->opad, 0, block_size, 0);\n\t\tswitch (sha->type) {\n\t\tcase CCP_SHA_TYPE_1:\n\t\tcase CCP_SHA_TYPE_224:\n\t\tcase CCP_SHA_TYPE_256:\n\t\t\tmemcpy(hmac_buf + block_size,\n\t\t\t       ctx.address + ooffset,\n\t\t\t       digest_size);\n\t\t\tbreak;\n\t\tcase CCP_SHA_TYPE_384:\n\t\tcase CCP_SHA_TYPE_512:\n\t\t\tmemcpy(hmac_buf + block_size,\n\t\t\t       ctx.address + LSB_ITEM_SIZE + ooffset,\n\t\t\t       LSB_ITEM_SIZE);\n\t\t\tmemcpy(hmac_buf + block_size +\n\t\t\t       (LSB_ITEM_SIZE - ooffset),\n\t\t\t       ctx.address,\n\t\t\t       LSB_ITEM_SIZE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_ctx;\n\t\t}\n\n\t\tmemset(&hmac_cmd, 0, sizeof(hmac_cmd));\n\t\thmac_cmd.engine = CCP_ENGINE_SHA;\n\t\thmac_cmd.u.sha.type = sha->type;\n\t\thmac_cmd.u.sha.ctx = sha->ctx;\n\t\thmac_cmd.u.sha.ctx_len = sha->ctx_len;\n\t\thmac_cmd.u.sha.src = &sg;\n\t\thmac_cmd.u.sha.src_len = block_size + digest_size;\n\t\thmac_cmd.u.sha.opad = NULL;\n\t\thmac_cmd.u.sha.opad_len = 0;\n\t\thmac_cmd.u.sha.first = 1;\n\t\thmac_cmd.u.sha.final = 1;\n\t\thmac_cmd.u.sha.msg_bits = (block_size + digest_size) << 3;\n\n\t\tret = ccp_run_sha_cmd(cmd_q, &hmac_cmd);\n\t\tif (ret)\n\t\t\tcmd->engine_error = hmac_cmd.engine_error;\n\n\t\tkfree(hmac_buf);\n\t}\n\ne_data:\n\tif (sha->src)\n\t\tccp_free_data(&src, cmd_q);\n\ne_ctx:\n\tccp_dm_free(&ctx);\n\n\treturn ret;\n}",
        "func": "static noinline_for_stack int\nccp_run_sha_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)\n{\n\tstruct ccp_sha_engine *sha = &cmd->u.sha;\n\tstruct ccp_dm_workarea ctx;\n\tstruct ccp_data src;\n\tstruct ccp_op op;\n\tunsigned int ioffset, ooffset;\n\tunsigned int digest_size;\n\tint sb_count;\n\tconst void *init;\n\tu64 block_size;\n\tint ctx_size;\n\tint ret;\n\n\tswitch (sha->type) {\n\tcase CCP_SHA_TYPE_1:\n\t\tif (sha->ctx_len < SHA1_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA1_BLOCK_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_224:\n\t\tif (sha->ctx_len < SHA224_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA224_BLOCK_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_256:\n\t\tif (sha->ctx_len < SHA256_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA256_BLOCK_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_384:\n\t\tif (cmd_q->ccp->vdata->version < CCP_VERSION(4, 0)\n\t\t    || sha->ctx_len < SHA384_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA384_BLOCK_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_512:\n\t\tif (cmd_q->ccp->vdata->version < CCP_VERSION(4, 0)\n\t\t    || sha->ctx_len < SHA512_DIGEST_SIZE)\n\t\t\treturn -EINVAL;\n\t\tblock_size = SHA512_BLOCK_SIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sha->ctx)\n\t\treturn -EINVAL;\n\n\tif (!sha->final && (sha->src_len & (block_size - 1)))\n\t\treturn -EINVAL;\n\n\t/* The version 3 device can't handle zero-length input */\n\tif (cmd_q->ccp->vdata->version == CCP_VERSION(3, 0)) {\n\n\t\tif (!sha->src_len) {\n\t\t\tunsigned int digest_len;\n\t\t\tconst u8 *sha_zero;\n\n\t\t\t/* Not final, just return */\n\t\t\tif (!sha->final)\n\t\t\t\treturn 0;\n\n\t\t\t/* CCP can't do a zero length sha operation so the\n\t\t\t * caller must buffer the data.\n\t\t\t */\n\t\t\tif (sha->msg_bits)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The CCP cannot perform zero-length sha operations\n\t\t\t * so the caller is required to buffer data for the\n\t\t\t * final operation. However, a sha operation for a\n\t\t\t * message with a total length of zero is valid so\n\t\t\t * known values are required to supply the result.\n\t\t\t */\n\t\t\tswitch (sha->type) {\n\t\t\tcase CCP_SHA_TYPE_1:\n\t\t\t\tsha_zero = sha1_zero_message_hash;\n\t\t\t\tdigest_len = SHA1_DIGEST_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase CCP_SHA_TYPE_224:\n\t\t\t\tsha_zero = sha224_zero_message_hash;\n\t\t\t\tdigest_len = SHA224_DIGEST_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase CCP_SHA_TYPE_256:\n\t\t\t\tsha_zero = sha256_zero_message_hash;\n\t\t\t\tdigest_len = SHA256_DIGEST_SIZE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tscatterwalk_map_and_copy((void *)sha_zero, sha->ctx, 0,\n\t\t\t\t\t\t digest_len, 1);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Set variables used throughout */\n\tswitch (sha->type) {\n\tcase CCP_SHA_TYPE_1:\n\t\tdigest_size = SHA1_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha1_init;\n\t\tctx_size = SHA1_DIGEST_SIZE;\n\t\tsb_count = 1;\n\t\tif (cmd_q->ccp->vdata->version != CCP_VERSION(3, 0))\n\t\t\tooffset = ioffset = CCP_SB_BYTES - SHA1_DIGEST_SIZE;\n\t\telse\n\t\t\tooffset = ioffset = 0;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_224:\n\t\tdigest_size = SHA224_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha224_init;\n\t\tctx_size = SHA256_DIGEST_SIZE;\n\t\tsb_count = 1;\n\t\tioffset = 0;\n\t\tif (cmd_q->ccp->vdata->version != CCP_VERSION(3, 0))\n\t\t\tooffset = CCP_SB_BYTES - SHA224_DIGEST_SIZE;\n\t\telse\n\t\t\tooffset = 0;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_256:\n\t\tdigest_size = SHA256_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha256_init;\n\t\tctx_size = SHA256_DIGEST_SIZE;\n\t\tsb_count = 1;\n\t\tooffset = ioffset = 0;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_384:\n\t\tdigest_size = SHA384_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha384_init;\n\t\tctx_size = SHA512_DIGEST_SIZE;\n\t\tsb_count = 2;\n\t\tioffset = 0;\n\t\tooffset = 2 * CCP_SB_BYTES - SHA384_DIGEST_SIZE;\n\t\tbreak;\n\tcase CCP_SHA_TYPE_512:\n\t\tdigest_size = SHA512_DIGEST_SIZE;\n\t\tinit = (void *) ccp_sha512_init;\n\t\tctx_size = SHA512_DIGEST_SIZE;\n\t\tsb_count = 2;\n\t\tooffset = ioffset = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto e_data;\n\t}\n\n\t/* For zero-length plaintext the src pointer is ignored;\n\t * otherwise both parts must be valid\n\t */\n\tif (sha->src_len && !sha->src)\n\t\treturn -EINVAL;\n\n\tmemset(&op, 0, sizeof(op));\n\top.cmd_q = cmd_q;\n\top.jobid = CCP_NEW_JOBID(cmd_q->ccp);\n\top.sb_ctx = cmd_q->sb_ctx; /* Pre-allocated */\n\top.u.sha.type = sha->type;\n\top.u.sha.msg_bits = sha->msg_bits;\n\n\t/* For SHA1/224/256 the context fits in a single (32-byte) SB entry;\n\t * SHA384/512 require 2 adjacent SB slots, with the right half in the\n\t * first slot, and the left half in the second. Each portion must then\n\t * be in little endian format: use the 256-bit byte swap option.\n\t */\n\tret = ccp_init_dm_workarea(&ctx, cmd_q, sb_count * CCP_SB_BYTES,\n\t\t\t\t   DMA_BIDIRECTIONAL);\n\tif (ret)\n\t\treturn ret;\n\tif (sha->first) {\n\t\tswitch (sha->type) {\n\t\tcase CCP_SHA_TYPE_1:\n\t\tcase CCP_SHA_TYPE_224:\n\t\tcase CCP_SHA_TYPE_256:\n\t\t\tmemcpy(ctx.address + ioffset, init, ctx_size);\n\t\t\tbreak;\n\t\tcase CCP_SHA_TYPE_384:\n\t\tcase CCP_SHA_TYPE_512:\n\t\t\tmemcpy(ctx.address + ctx_size / 2, init,\n\t\t\t       ctx_size / 2);\n\t\t\tmemcpy(ctx.address, init + ctx_size / 2,\n\t\t\t       ctx_size / 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_ctx;\n\t\t}\n\t} else {\n\t\t/* Restore the context */\n\t\tret = ccp_set_dm_area(&ctx, 0, sha->ctx, 0,\n\t\t\t\t      sb_count * CCP_SB_BYTES);\n\t\tif (ret)\n\t\t\tgoto e_ctx;\n\t}\n\n\tret = ccp_copy_to_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t     CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_ctx;\n\t}\n\n\tif (sha->src) {\n\t\t/* Send data to the CCP SHA engine; block_size is set above */\n\t\tret = ccp_init_data(&src, cmd_q, sha->src, sha->src_len,\n\t\t\t\t    block_size, DMA_TO_DEVICE);\n\t\tif (ret)\n\t\t\tgoto e_ctx;\n\n\t\twhile (src.sg_wa.bytes_left) {\n\t\t\tccp_prepare_data(&src, NULL, &op, block_size, false);\n\t\t\tif (sha->final && !src.sg_wa.bytes_left)\n\t\t\t\top.eom = 1;\n\n\t\t\tret = cmd_q->ccp->vdata->perform->sha(&op);\n\t\t\tif (ret) {\n\t\t\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\t\t\tgoto e_data;\n\t\t\t}\n\n\t\t\tccp_process_data(&src, NULL, &op);\n\t\t}\n\t} else {\n\t\top.eom = 1;\n\t\tret = cmd_q->ccp->vdata->perform->sha(&op);\n\t\tif (ret) {\n\t\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\t\tgoto e_data;\n\t\t}\n\t}\n\n\t/* Retrieve the SHA context - convert from LE to BE using\n\t * 32-byte (256-bit) byteswapping to BE\n\t */\n\tret = ccp_copy_from_sb(cmd_q, &ctx, op.jobid, op.sb_ctx,\n\t\t\t       CCP_PASSTHRU_BYTESWAP_256BIT);\n\tif (ret) {\n\t\tcmd->engine_error = cmd_q->cmd_error;\n\t\tgoto e_data;\n\t}\n\n\tif (sha->final) {\n\t\t/* Finishing up, so get the digest */\n\t\tswitch (sha->type) {\n\t\tcase CCP_SHA_TYPE_1:\n\t\tcase CCP_SHA_TYPE_224:\n\t\tcase CCP_SHA_TYPE_256:\n\t\t\tccp_get_dm_area(&ctx, ooffset,\n\t\t\t\t\tsha->ctx, 0,\n\t\t\t\t\tdigest_size);\n\t\t\tbreak;\n\t\tcase CCP_SHA_TYPE_384:\n\t\tcase CCP_SHA_TYPE_512:\n\t\t\tccp_get_dm_area(&ctx, 0,\n\t\t\t\t\tsha->ctx, LSB_ITEM_SIZE - ooffset,\n\t\t\t\t\tLSB_ITEM_SIZE);\n\t\t\tccp_get_dm_area(&ctx, LSB_ITEM_SIZE + ooffset,\n\t\t\t\t\tsha->ctx, 0,\n\t\t\t\t\tLSB_ITEM_SIZE - ooffset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_ctx;\n\t\t}\n\t} else {\n\t\t/* Stash the context */\n\t\tccp_get_dm_area(&ctx, 0, sha->ctx, 0,\n\t\t\t\tsb_count * CCP_SB_BYTES);\n\t}\n\n\tif (sha->final && sha->opad) {\n\t\t/* HMAC operation, recursively perform final SHA */\n\t\tstruct ccp_cmd hmac_cmd;\n\t\tstruct scatterlist sg;\n\t\tu8 *hmac_buf;\n\n\t\tif (sha->opad_len != block_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_data;\n\t\t}\n\n\t\thmac_buf = kmalloc(block_size + digest_size, GFP_KERNEL);\n\t\tif (!hmac_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto e_data;\n\t\t}\n\t\tsg_init_one(&sg, hmac_buf, block_size + digest_size);\n\n\t\tscatterwalk_map_and_copy(hmac_buf, sha->opad, 0, block_size, 0);\n\t\tswitch (sha->type) {\n\t\tcase CCP_SHA_TYPE_1:\n\t\tcase CCP_SHA_TYPE_224:\n\t\tcase CCP_SHA_TYPE_256:\n\t\t\tmemcpy(hmac_buf + block_size,\n\t\t\t       ctx.address + ooffset,\n\t\t\t       digest_size);\n\t\t\tbreak;\n\t\tcase CCP_SHA_TYPE_384:\n\t\tcase CCP_SHA_TYPE_512:\n\t\t\tmemcpy(hmac_buf + block_size,\n\t\t\t       ctx.address + LSB_ITEM_SIZE + ooffset,\n\t\t\t       LSB_ITEM_SIZE);\n\t\t\tmemcpy(hmac_buf + block_size +\n\t\t\t       (LSB_ITEM_SIZE - ooffset),\n\t\t\t       ctx.address,\n\t\t\t       LSB_ITEM_SIZE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkfree(hmac_buf);\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_data;\n\t\t}\n\n\t\tmemset(&hmac_cmd, 0, sizeof(hmac_cmd));\n\t\thmac_cmd.engine = CCP_ENGINE_SHA;\n\t\thmac_cmd.u.sha.type = sha->type;\n\t\thmac_cmd.u.sha.ctx = sha->ctx;\n\t\thmac_cmd.u.sha.ctx_len = sha->ctx_len;\n\t\thmac_cmd.u.sha.src = &sg;\n\t\thmac_cmd.u.sha.src_len = block_size + digest_size;\n\t\thmac_cmd.u.sha.opad = NULL;\n\t\thmac_cmd.u.sha.opad_len = 0;\n\t\thmac_cmd.u.sha.first = 1;\n\t\thmac_cmd.u.sha.final = 1;\n\t\thmac_cmd.u.sha.msg_bits = (block_size + digest_size) << 3;\n\n\t\tret = ccp_run_sha_cmd(cmd_q, &hmac_cmd);\n\t\tif (ret)\n\t\t\tcmd->engine_error = hmac_cmd.engine_error;\n\n\t\tkfree(hmac_buf);\n\t}\n\ne_data:\n\tif (sha->src)\n\t\tccp_free_data(&src, cmd_q);\n\ne_ctx:\n\tccp_dm_free(&ctx);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -309,8 +309,9 @@\n \t\t\t       LSB_ITEM_SIZE);\n \t\t\tbreak;\n \t\tdefault:\n+\t\t\tkfree(hmac_buf);\n \t\t\tret = -EINVAL;\n-\t\t\tgoto e_ctx;\n+\t\t\tgoto e_data;\n \t\t}\n \n \t\tmemset(&hmac_cmd, 0, sizeof(hmac_cmd));",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tgoto e_ctx;"
            ],
            "added_lines": [
                "\t\t\tkfree(hmac_buf);",
                "\t\t\tgoto e_data;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18809",
        "func_name": "torvalds/linux/af9005_identify_state",
        "description": "A memory leak in the af9005_identify_state() function in drivers/media/usb/dvb-usb/af9005.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-2289adbfa559.",
        "git_url": "https://github.com/torvalds/linux/commit/2289adbfa559050d2a38bcd9caac1c18b800e928",
        "commit_title": "media: usb: fix memory leak in af9005_identify_state",
        "commit_text": " In af9005_identify_state when returning -EIO the allocated buffer should be released. Replace the \"return -EIO\" with assignment into ret and move deb_info() under a check. ",
        "func_before": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\n\nerr:\n\tkfree(buf);\n\treturn ret;\n}",
        "func": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\tret = -EIO;\n\tif (!ret)\n\t\tdeb_info(\"Identify state cold = %d\\n\", *cold);\n\nerr:\n\tkfree(buf);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,8 +20,9 @@\n \telse if (reply == 0x02)\n \t\t*cold = 0;\n \telse\n-\t\treturn -EIO;\n-\tdeb_info(\"Identify state cold = %d\\n\", *cold);\n+\t\tret = -EIO;\n+\tif (!ret)\n+\t\tdeb_info(\"Identify state cold = %d\\n\", *cold);\n \n err:\n \tkfree(buf);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn -EIO;",
                "\tdeb_info(\"Identify state cold = %d\\n\", *cold);"
            ],
            "added_lines": [
                "\t\tret = -EIO;",
                "\tif (!ret)",
                "\t\tdeb_info(\"Identify state cold = %d\\n\", *cold);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18810",
        "func_name": "torvalds/linux/komeda_wb_connector_add",
        "description": "A memory leak in the komeda_wb_connector_add() function in drivers/gpu/drm/arm/display/komeda/komeda_wb_connector.c in the Linux kernel before 5.3.8 allows attackers to cause a denial of service (memory consumption) by triggering drm_writeback_connector_init() failures, aka CID-a0ecd6fdbf5d.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=a0ecd6fdbf5d648123a7315c695fb6850d702835",
        "commit_title": "In komeda_wb_connector_add if drm_writeback_connector_init fails the",
        "commit_text": "allocated memory for kwb_conn should be released.  Link: https://patchwork.freedesktop.org/patch/msgid/20190925043031.32308-1-navid.emamdoost@gmail.com ",
        "func_before": "static int komeda_wb_connector_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kms->base.dev_private;\n\tstruct komeda_wb_connector *kwb_conn;\n\tstruct drm_writeback_connector *wb_conn;\n\tu32 *formats, n_formats = 0;\n\tint err;\n\n\tif (!kcrtc->master->wb_layer)\n\t\treturn 0;\n\n\tkwb_conn = kzalloc(sizeof(*kwb_conn), GFP_KERNEL);\n\tif (!kwb_conn)\n\t\treturn -ENOMEM;\n\n\tkwb_conn->wb_layer = kcrtc->master->wb_layer;\n\n\twb_conn = &kwb_conn->base;\n\twb_conn->encoder.possible_crtcs = BIT(drm_crtc_index(&kcrtc->base));\n\n\tformats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,\n\t\t\t\t\t       kwb_conn->wb_layer->layer_type,\n\t\t\t\t\t       &n_formats);\n\n\terr = drm_writeback_connector_init(&kms->base, wb_conn,\n\t\t\t\t\t   &komeda_wb_connector_funcs,\n\t\t\t\t\t   &komeda_wb_encoder_helper_funcs,\n\t\t\t\t\t   formats, n_formats);\n\tkomeda_put_fourcc_list(formats);\n\tif (err)\n\t\treturn err;\n\n\tdrm_connector_helper_add(&wb_conn->base, &komeda_wb_conn_helper_funcs);\n\n\tkcrtc->wb_conn = kwb_conn;\n\n\treturn 0;\n}",
        "func": "static int komeda_wb_connector_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kms->base.dev_private;\n\tstruct komeda_wb_connector *kwb_conn;\n\tstruct drm_writeback_connector *wb_conn;\n\tu32 *formats, n_formats = 0;\n\tint err;\n\n\tif (!kcrtc->master->wb_layer)\n\t\treturn 0;\n\n\tkwb_conn = kzalloc(sizeof(*kwb_conn), GFP_KERNEL);\n\tif (!kwb_conn)\n\t\treturn -ENOMEM;\n\n\tkwb_conn->wb_layer = kcrtc->master->wb_layer;\n\n\twb_conn = &kwb_conn->base;\n\twb_conn->encoder.possible_crtcs = BIT(drm_crtc_index(&kcrtc->base));\n\n\tformats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,\n\t\t\t\t\t       kwb_conn->wb_layer->layer_type,\n\t\t\t\t\t       &n_formats);\n\n\terr = drm_writeback_connector_init(&kms->base, wb_conn,\n\t\t\t\t\t   &komeda_wb_connector_funcs,\n\t\t\t\t\t   &komeda_wb_encoder_helper_funcs,\n\t\t\t\t\t   formats, n_formats);\n\tkomeda_put_fourcc_list(formats);\n\tif (err) {\n\t\tkfree(kwb_conn);\n\t\treturn err;\n\t}\n\n\tdrm_connector_helper_add(&wb_conn->base, &komeda_wb_conn_helper_funcs);\n\n\tkcrtc->wb_conn = kwb_conn;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,8 +28,10 @@\n \t\t\t\t\t   &komeda_wb_encoder_helper_funcs,\n \t\t\t\t\t   formats, n_formats);\n \tkomeda_put_fourcc_list(formats);\n-\tif (err)\n+\tif (err) {\n+\t\tkfree(kwb_conn);\n \t\treturn err;\n+\t}\n \n \tdrm_connector_helper_add(&wb_conn->base, &komeda_wb_conn_helper_funcs);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (err)"
            ],
            "added_lines": [
                "\tif (err) {",
                "\t\tkfree(kwb_conn);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18811",
        "func_name": "torvalds/linux/sof_set_get_large_ctrl_data",
        "description": "A memory leak in the sof_set_get_large_ctrl_data() function in sound/soc/sof/ipc.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering sof_get_ctrl_copy_params() failures, aka CID-45c1380358b1.",
        "git_url": "https://github.com/torvalds/linux/commit/45c1380358b12bf2d1db20a5874e9544f56b34ab",
        "commit_title": "ASoC: SOF: ipc: Fix memory leak in sof_set_get_large_ctrl_data",
        "commit_text": " In the implementation of sof_set_get_large_ctrl_data() there is a memory leak in case an error. Release partdata if sof_get_ctrl_copy_params() fails.  Link: https://lore.kernel.org/r/20191027215330.12729-1-navid.emamdoost@gmail.com",
        "func_before": "static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\n\t/* allocate max ipc size because we have at least one */\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\n\t/* copy the header data */\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\n\t/* Serialise IPC TX */\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\n\t/* copy the payload data in a loop */\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\n\t\toffset += pl_size;\n\t}\n\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\n\tkfree(partdata);\n\treturn err;\n}",
        "func": "static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\n\t/* allocate max ipc size because we have at least one */\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0) {\n\t\tkfree(partdata);\n\t\treturn err;\n\t}\n\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\n\t/* copy the header data */\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\n\t/* Serialise IPC TX */\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\n\t/* copy the payload data in a loop */\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\n\t\toffset += pl_size;\n\t}\n\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\n\tkfree(partdata);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,8 +22,10 @@\n \telse\n \t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n \t\t\t\t\t       sparams);\n-\tif (err < 0)\n+\tif (err < 0) {\n+\t\tkfree(partdata);\n \t\treturn err;\n+\t}\n \n \tmsg_bytes = sparams->msg_bytes;\n \tpl_size = sparams->pl_size;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (err < 0)"
            ],
            "added_lines": [
                "\tif (err < 0) {",
                "\t\tkfree(partdata);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18812",
        "func_name": "torvalds/linux/sof_dfsentry_write",
        "description": "A memory leak in the sof_dfsentry_write() function in sound/soc/sof/debug.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-c0a333d842ef.",
        "git_url": "https://github.com/torvalds/linux/commit/c0a333d842ef67ac04adc72ff79dc1ccc3dca4ed",
        "commit_title": "ASoC: SOF: Fix memory leak in sof_dfsentry_write",
        "commit_text": " In the implementation of sof_dfsentry_write() memory allocated for string is leaked in case of an error. Go to error handling path if the d_name.name is not valid.  Link: https://lore.kernel.org/r/20191027194856.4056-1-navid.emamdoost@gmail.com",
        "func_before": "static ssize_t sof_dfsentry_write(struct file *file, const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tunsigned long ipc_duration_ms = 0;\n\tbool flood_duration_test = false;\n\tunsigned long ipc_count = 0;\n\tstruct dentry *dentry;\n\tint err;\n#endif\n\tsize_t size;\n\tchar *string;\n\tint ret;\n\n\tstring = kzalloc(count, GFP_KERNEL);\n\tif (!string)\n\t\treturn -ENOMEM;\n\n\tsize = simple_write_to_buffer(string, count, ppos, buffer, count);\n\tret = size;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/*\n\t * write op is only supported for ipc_flood_count or\n\t * ipc_flood_duration_ms debugfs entries atm.\n\t * ipc_flood_count floods the DSP with the number of IPC's specified.\n\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t */\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\treturn -EINVAL;\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t/* test completion criterion */\n\tif (flood_duration_test)\n\t\tret = kstrtoul(string, 0, &ipc_duration_ms);\n\telse\n\t\tret = kstrtoul(string, 0, &ipc_count);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* limit max duration/ipc count for flood test */\n\tif (flood_duration_test) {\n\t\tif (!ipc_duration_ms) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* find the minimum. min() is not used to avoid warnings */\n\t\tif (ipc_duration_ms > MAX_IPC_FLOOD_DURATION_MS)\n\t\t\tipc_duration_ms = MAX_IPC_FLOOD_DURATION_MS;\n\t} else {\n\t\tif (!ipc_count) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* find the minimum. min() is not used to avoid warnings */\n\t\tif (ipc_count > MAX_IPC_FLOOD_COUNT)\n\t\t\tipc_count = MAX_IPC_FLOOD_COUNT;\n\t}\n\n\tret = pm_runtime_get_sync(sdev->dev);\n\tif (ret < 0) {\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: debugfs write failed to resume %d\\n\",\n\t\t\t\t    ret);\n\t\tpm_runtime_put_noidle(sdev->dev);\n\t\tgoto out;\n\t}\n\n\t/* flood test */\n\tret = sof_debug_ipc_flood_test(sdev, dfse, flood_duration_test,\n\t\t\t\t       ipc_duration_ms, ipc_count);\n\n\tpm_runtime_mark_last_busy(sdev->dev);\n\terr = pm_runtime_put_autosuspend(sdev->dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: debugfs write failed to idle %d\\n\",\n\t\t\t\t    err);\n\n\t/* return size if test is successful */\n\tif (ret >= 0)\n\t\tret = size;\nout:\n#endif\n\tkfree(string);\n\treturn ret;\n}",
        "func": "static ssize_t sof_dfsentry_write(struct file *file, const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tunsigned long ipc_duration_ms = 0;\n\tbool flood_duration_test = false;\n\tunsigned long ipc_count = 0;\n\tstruct dentry *dentry;\n\tint err;\n#endif\n\tsize_t size;\n\tchar *string;\n\tint ret;\n\n\tstring = kzalloc(count, GFP_KERNEL);\n\tif (!string)\n\t\treturn -ENOMEM;\n\n\tsize = simple_write_to_buffer(string, count, ppos, buffer, count);\n\tret = size;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/*\n\t * write op is only supported for ipc_flood_count or\n\t * ipc_flood_duration_ms debugfs entries atm.\n\t * ipc_flood_count floods the DSP with the number of IPC's specified.\n\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t */\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\")) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t/* test completion criterion */\n\tif (flood_duration_test)\n\t\tret = kstrtoul(string, 0, &ipc_duration_ms);\n\telse\n\t\tret = kstrtoul(string, 0, &ipc_count);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* limit max duration/ipc count for flood test */\n\tif (flood_duration_test) {\n\t\tif (!ipc_duration_ms) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* find the minimum. min() is not used to avoid warnings */\n\t\tif (ipc_duration_ms > MAX_IPC_FLOOD_DURATION_MS)\n\t\t\tipc_duration_ms = MAX_IPC_FLOOD_DURATION_MS;\n\t} else {\n\t\tif (!ipc_count) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* find the minimum. min() is not used to avoid warnings */\n\t\tif (ipc_count > MAX_IPC_FLOOD_COUNT)\n\t\t\tipc_count = MAX_IPC_FLOOD_COUNT;\n\t}\n\n\tret = pm_runtime_get_sync(sdev->dev);\n\tif (ret < 0) {\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: debugfs write failed to resume %d\\n\",\n\t\t\t\t    ret);\n\t\tpm_runtime_put_noidle(sdev->dev);\n\t\tgoto out;\n\t}\n\n\t/* flood test */\n\tret = sof_debug_ipc_flood_test(sdev, dfse, flood_duration_test,\n\t\t\t\t       ipc_duration_ms, ipc_count);\n\n\tpm_runtime_mark_last_busy(sdev->dev);\n\terr = pm_runtime_put_autosuspend(sdev->dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: debugfs write failed to idle %d\\n\",\n\t\t\t\t    err);\n\n\t/* return size if test is successful */\n\tif (ret >= 0)\n\t\tret = size;\nout:\n#endif\n\tkfree(string);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,8 +31,10 @@\n \t */\n \tdentry = file->f_path.dentry;\n \tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n-\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n-\t\treturn -EINVAL;\n+\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\")) {\n+\t\tret = -EINVAL;\n+\t\tgoto out;\n+\t}\n \n \tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n \t\tflood_duration_test = true;",
        "diff_line_info": {
            "deleted_lines": [
                "\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))",
                "\t\treturn -EINVAL;"
            ],
            "added_lines": [
                "\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\")) {",
                "\t\tret = -EINVAL;",
                "\t\tgoto out;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18813",
        "func_name": "torvalds/linux/dwc3_pci_probe",
        "description": "A memory leak in the dwc3_pci_probe() function in drivers/usb/dwc3/dwc3-pci.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering platform_device_add_properties() failures, aka CID-9bbfceea12a8.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=9bbfceea12a8f145097a27d7c7267af25893c060",
        "commit_title": "In dwc3_pci_probe a call to platform_device_alloc allocates a device",
        "commit_text": "which is correctly put in case of error except one case: when the call to platform_device_add_properties fails it directly returns instead of going to error handling. This commit replaces return with the goto.  ",
        "func_before": "static int dwc3_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct property_entry *p = (struct property_entry *)id->driver_data;\n\tstruct dwc3_pci\t\t*dwc;\n\tstruct resource\t\tres[2];\n\tint\t\t\tret;\n\tstruct device\t\t*dev = &pci->dev;\n\n\tret = pcim_enable_device(pci);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable pci device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_master(pci);\n\n\tdwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);\n\tif (!dwc)\n\t\treturn -ENOMEM;\n\n\tdwc->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!dwc->dwc3)\n\t\treturn -ENOMEM;\n\n\tmemset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));\n\n\tres[0].start\t= pci_resource_start(pci, 0);\n\tres[0].end\t= pci_resource_end(pci, 0);\n\tres[0].name\t= \"dwc_usb3\";\n\tres[0].flags\t= IORESOURCE_MEM;\n\n\tres[1].start\t= pci->irq;\n\tres[1].name\t= \"dwc_usb3\";\n\tres[1].flags\t= IORESOURCE_IRQ;\n\n\tret = platform_device_add_resources(dwc->dwc3, res, ARRAY_SIZE(res));\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't add resources to dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\n\tdwc->pci = pci;\n\tdwc->dwc3->dev.parent = dev;\n\tACPI_COMPANION_SET(&dwc->dwc3->dev, ACPI_COMPANION(dev));\n\n\tret = platform_device_add_properties(dwc->dwc3, p);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dwc3_pci_quirks(dwc);\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add(dwc->dwc3);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\n\tdevice_init_wakeup(dev, true);\n\tpci_set_drvdata(pci, dwc);\n\tpm_runtime_put(dev);\n#ifdef CONFIG_PM\n\tINIT_WORK(&dwc->wakeup_work, dwc3_pci_resume_work);\n#endif\n\n\treturn 0;\nerr:\n\tplatform_device_put(dwc->dwc3);\n\treturn ret;\n}",
        "func": "static int dwc3_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct property_entry *p = (struct property_entry *)id->driver_data;\n\tstruct dwc3_pci\t\t*dwc;\n\tstruct resource\t\tres[2];\n\tint\t\t\tret;\n\tstruct device\t\t*dev = &pci->dev;\n\n\tret = pcim_enable_device(pci);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable pci device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_master(pci);\n\n\tdwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);\n\tif (!dwc)\n\t\treturn -ENOMEM;\n\n\tdwc->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!dwc->dwc3)\n\t\treturn -ENOMEM;\n\n\tmemset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));\n\n\tres[0].start\t= pci_resource_start(pci, 0);\n\tres[0].end\t= pci_resource_end(pci, 0);\n\tres[0].name\t= \"dwc_usb3\";\n\tres[0].flags\t= IORESOURCE_MEM;\n\n\tres[1].start\t= pci->irq;\n\tres[1].name\t= \"dwc_usb3\";\n\tres[1].flags\t= IORESOURCE_IRQ;\n\n\tret = platform_device_add_resources(dwc->dwc3, res, ARRAY_SIZE(res));\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't add resources to dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\n\tdwc->pci = pci;\n\tdwc->dwc3->dev.parent = dev;\n\tACPI_COMPANION_SET(&dwc->dwc3->dev, ACPI_COMPANION(dev));\n\n\tret = platform_device_add_properties(dwc->dwc3, p);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = dwc3_pci_quirks(dwc);\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add(dwc->dwc3);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\n\tdevice_init_wakeup(dev, true);\n\tpci_set_drvdata(pci, dwc);\n\tpm_runtime_put(dev);\n#ifdef CONFIG_PM\n\tINIT_WORK(&dwc->wakeup_work, dwc3_pci_resume_work);\n#endif\n\n\treturn 0;\nerr:\n\tplatform_device_put(dwc->dwc3);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n \n \tret = platform_device_add_properties(dwc->dwc3, p);\n \tif (ret < 0)\n-\t\treturn ret;\n+\t\tgoto err;\n \n \tret = dwc3_pci_quirks(dwc);\n \tif (ret)",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn ret;"
            ],
            "added_lines": [
                "\t\tgoto err;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19043",
        "func_name": "torvalds/linux/i40e_setup_macvlans",
        "description": "A memory leak in the i40e_setup_macvlans() function in drivers/net/ethernet/intel/i40e/i40e_main.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering i40e_setup_channel() failures, aka CID-27d461333459.",
        "git_url": "https://github.com/torvalds/linux/commit/27d461333459d282ffa4a2bdb6b215a59d493a8f",
        "commit_title": "i40e: prevent memory leak in i40e_setup_macvlans",
        "commit_text": " In i40e_setup_macvlans if i40e_setup_channel fails the allocated memory for ch should be released. ",
        "func_before": "static int i40e_setup_macvlans(struct i40e_vsi *vsi, u16 macvlan_cnt, u16 qcnt,\n\t\t\t       struct net_device *vdev)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vsi_context ctxt;\n\tu16 sections, qmap, num_qps;\n\tstruct i40e_channel *ch;\n\tint i, pow, ret = 0;\n\tu8 offset = 0;\n\n\tif (vsi->type != I40E_VSI_MAIN || !macvlan_cnt)\n\t\treturn -EINVAL;\n\n\tnum_qps = vsi->num_queue_pairs - (macvlan_cnt * qcnt);\n\n\t/* find the next higher power-of-2 of num queue pairs */\n\tpow = fls(roundup_pow_of_two(num_qps) - 1);\n\n\tqmap = (offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) |\n\t\t(pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT);\n\n\t/* Setup context bits for the main VSI */\n\tsections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID;\n\tsections |= I40E_AQ_VSI_PROP_SCHED_VALID;\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tctxt.seid = vsi->seid;\n\tctxt.pf_num = vsi->back->hw.pf_id;\n\tctxt.vf_num = 0;\n\tctxt.uplink_seid = vsi->uplink_seid;\n\tctxt.info = vsi->info;\n\tctxt.info.tc_mapping[0] = cpu_to_le16(qmap);\n\tctxt.info.mapping_flags |= cpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);\n\tctxt.info.queue_mapping[0] = cpu_to_le16(vsi->base_queue);\n\tctxt.info.valid_sections |= cpu_to_le16(sections);\n\n\t/* Reconfigure RSS for main VSI with new max queue count */\n\tvsi->rss_size = max_t(u16, num_qps, qcnt);\n\tret = i40e_vsi_config_rss(vsi);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed to reconfig RSS for num_queues (%u)\\n\",\n\t\t\t vsi->rss_size);\n\t\treturn ret;\n\t}\n\tvsi->reconfig_rss = true;\n\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\"Reconfigured RSS with num_queues (%u)\\n\", vsi->rss_size);\n\tvsi->next_base_queue = num_qps;\n\tvsi->cnt_q_avail = vsi->num_queue_pairs - num_qps;\n\n\t/* Update the VSI after updating the VSI queue-mapping\n\t * information\n\t */\n\tret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Update vsi tc config failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(hw, ret),\n\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\treturn ret;\n\t}\n\t/* update the local VSI info with updated queue map */\n\ti40e_vsi_update_queue_map(vsi, &ctxt);\n\tvsi->info.valid_sections = 0;\n\n\t/* Create channels for macvlans */\n\tINIT_LIST_HEAD(&vsi->macvlan_list);\n\tfor (i = 0; i < macvlan_cnt; i++) {\n\t\tch = kzalloc(sizeof(*ch), GFP_KERNEL);\n\t\tif (!ch) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\t\tINIT_LIST_HEAD(&ch->list);\n\t\tch->num_queue_pairs = qcnt;\n\t\tif (!i40e_setup_channel(pf, vsi, ch)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t\tch->parent_vsi = vsi;\n\t\tvsi->cnt_q_avail -= ch->num_queue_pairs;\n\t\tvsi->macvlan_cnt++;\n\t\tlist_add_tail(&ch->list, &vsi->macvlan_list);\n\t}\n\n\treturn ret;\n\nerr_free:\n\tdev_info(&pf->pdev->dev, \"Failed to setup macvlans\\n\");\n\ti40e_free_macvlan_channels(vsi);\n\n\treturn ret;\n}",
        "func": "static int i40e_setup_macvlans(struct i40e_vsi *vsi, u16 macvlan_cnt, u16 qcnt,\n\t\t\t       struct net_device *vdev)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vsi_context ctxt;\n\tu16 sections, qmap, num_qps;\n\tstruct i40e_channel *ch;\n\tint i, pow, ret = 0;\n\tu8 offset = 0;\n\n\tif (vsi->type != I40E_VSI_MAIN || !macvlan_cnt)\n\t\treturn -EINVAL;\n\n\tnum_qps = vsi->num_queue_pairs - (macvlan_cnt * qcnt);\n\n\t/* find the next higher power-of-2 of num queue pairs */\n\tpow = fls(roundup_pow_of_two(num_qps) - 1);\n\n\tqmap = (offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) |\n\t\t(pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT);\n\n\t/* Setup context bits for the main VSI */\n\tsections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID;\n\tsections |= I40E_AQ_VSI_PROP_SCHED_VALID;\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tctxt.seid = vsi->seid;\n\tctxt.pf_num = vsi->back->hw.pf_id;\n\tctxt.vf_num = 0;\n\tctxt.uplink_seid = vsi->uplink_seid;\n\tctxt.info = vsi->info;\n\tctxt.info.tc_mapping[0] = cpu_to_le16(qmap);\n\tctxt.info.mapping_flags |= cpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);\n\tctxt.info.queue_mapping[0] = cpu_to_le16(vsi->base_queue);\n\tctxt.info.valid_sections |= cpu_to_le16(sections);\n\n\t/* Reconfigure RSS for main VSI with new max queue count */\n\tvsi->rss_size = max_t(u16, num_qps, qcnt);\n\tret = i40e_vsi_config_rss(vsi);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed to reconfig RSS for num_queues (%u)\\n\",\n\t\t\t vsi->rss_size);\n\t\treturn ret;\n\t}\n\tvsi->reconfig_rss = true;\n\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\"Reconfigured RSS with num_queues (%u)\\n\", vsi->rss_size);\n\tvsi->next_base_queue = num_qps;\n\tvsi->cnt_q_avail = vsi->num_queue_pairs - num_qps;\n\n\t/* Update the VSI after updating the VSI queue-mapping\n\t * information\n\t */\n\tret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Update vsi tc config failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(hw, ret),\n\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\treturn ret;\n\t}\n\t/* update the local VSI info with updated queue map */\n\ti40e_vsi_update_queue_map(vsi, &ctxt);\n\tvsi->info.valid_sections = 0;\n\n\t/* Create channels for macvlans */\n\tINIT_LIST_HEAD(&vsi->macvlan_list);\n\tfor (i = 0; i < macvlan_cnt; i++) {\n\t\tch = kzalloc(sizeof(*ch), GFP_KERNEL);\n\t\tif (!ch) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\t\tINIT_LIST_HEAD(&ch->list);\n\t\tch->num_queue_pairs = qcnt;\n\t\tif (!i40e_setup_channel(pf, vsi, ch)) {\n\t\t\tret = -EINVAL;\n\t\t\tkfree(ch);\n\t\t\tgoto err_free;\n\t\t}\n\t\tch->parent_vsi = vsi;\n\t\tvsi->cnt_q_avail -= ch->num_queue_pairs;\n\t\tvsi->macvlan_cnt++;\n\t\tlist_add_tail(&ch->list, &vsi->macvlan_list);\n\t}\n\n\treturn ret;\n\nerr_free:\n\tdev_info(&pf->pdev->dev, \"Failed to setup macvlans\\n\");\n\ti40e_free_macvlan_channels(vsi);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,6 +76,7 @@\n \t\tch->num_queue_pairs = qcnt;\n \t\tif (!i40e_setup_channel(pf, vsi, ch)) {\n \t\t\tret = -EINVAL;\n+\t\t\tkfree(ch);\n \t\t\tgoto err_free;\n \t\t}\n \t\tch->parent_vsi = vsi;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tkfree(ch);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19044",
        "func_name": "torvalds/linux/v3d_submit_cl_ioctl",
        "description": "Two memory leaks in the v3d_submit_cl_ioctl() function in drivers/gpu/drm/v3d/v3d_gem.c in the Linux kernel before 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering kcalloc() or v3d_job_init() failures, aka CID-29cd13cfd762.",
        "git_url": "https://github.com/torvalds/linux/commit/29cd13cfd7624726d9e6becbae9aa419ef35af7f",
        "commit_title": "drm/v3d: Fix memory leak in v3d_submit_cl_ioctl",
        "commit_text": " In the impelementation of v3d_submit_cl_ioctl() there are two memory leaks. One is when allocation for bin fails, and the other is when bin initialization fails. If kcalloc fails to allocate memory for bin then render->base should be put. Also, if v3d_job_init() fails to initialize bin->base then allocated memory for bin should be released.  Link: https://patchwork.freedesktop.org/patch/msgid/20191021185250.26130-1-navid.emamdoost@gmail.com",
        "func_before": "int\nv3d_submit_cl_ioctl(struct drm_device *dev, void *data,\n\t\t    struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_cl *args = data;\n\tstruct v3d_bin_job *bin = NULL;\n\tstruct v3d_render_job *render;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret = 0;\n\n\ttrace_v3d_submit_cl_ioctl(&v3d->drm, args->rcl_start, args->rcl_end);\n\n\tif (args->pad != 0) {\n\t\tDRM_INFO(\"pad must be zero: %d\\n\", args->pad);\n\t\treturn -EINVAL;\n\t}\n\n\trender = kcalloc(1, sizeof(*render), GFP_KERNEL);\n\tif (!render)\n\t\treturn -ENOMEM;\n\n\trender->start = args->rcl_start;\n\trender->end = args->rcl_end;\n\tINIT_LIST_HEAD(&render->unref_list);\n\n\tret = v3d_job_init(v3d, file_priv, &render->base,\n\t\t\t   v3d_render_job_free, args->in_sync_rcl);\n\tif (ret) {\n\t\tkfree(render);\n\t\treturn ret;\n\t}\n\n\tif (args->bcl_start != args->bcl_end) {\n\t\tbin = kcalloc(1, sizeof(*bin), GFP_KERNEL);\n\t\tif (!bin)\n\t\t\treturn -ENOMEM;\n\n\t\tret = v3d_job_init(v3d, file_priv, &bin->base,\n\t\t\t\t   v3d_job_free, args->in_sync_bcl);\n\t\tif (ret) {\n\t\t\tv3d_job_put(&render->base);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbin->start = args->bcl_start;\n\t\tbin->end = args->bcl_end;\n\t\tbin->qma = args->qma;\n\t\tbin->qms = args->qms;\n\t\tbin->qts = args->qts;\n\t\tbin->render = render;\n\t}\n\n\tret = v3d_lookup_bos(dev, file_priv, &render->base,\n\t\t\t     args->bo_handles, args->bo_handle_count);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = v3d_lock_bo_reservations(&render->base, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&v3d->sched_lock);\n\tif (bin) {\n\t\tret = v3d_push_job(v3d_priv, &bin->base, V3D_BIN);\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\n\t\tret = drm_gem_fence_array_add(&render->base.deps,\n\t\t\t\t\t      dma_fence_get(bin->base.done_fence));\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\t}\n\n\tret = v3d_push_job(v3d_priv, &render->base, V3D_RENDER);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t &render->base,\n\t\t\t\t\t\t &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t render->base.done_fence);\n\n\tif (bin)\n\t\tv3d_job_put(&bin->base);\n\tv3d_job_put(&render->base);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\n\tdrm_gem_unlock_reservations(render->base.bo,\n\t\t\t\t    render->base.bo_count, &acquire_ctx);\nfail:\n\tif (bin)\n\t\tv3d_job_put(&bin->base);\n\tv3d_job_put(&render->base);\n\n\treturn ret;\n}",
        "func": "int\nv3d_submit_cl_ioctl(struct drm_device *dev, void *data,\n\t\t    struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_cl *args = data;\n\tstruct v3d_bin_job *bin = NULL;\n\tstruct v3d_render_job *render;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret = 0;\n\n\ttrace_v3d_submit_cl_ioctl(&v3d->drm, args->rcl_start, args->rcl_end);\n\n\tif (args->pad != 0) {\n\t\tDRM_INFO(\"pad must be zero: %d\\n\", args->pad);\n\t\treturn -EINVAL;\n\t}\n\n\trender = kcalloc(1, sizeof(*render), GFP_KERNEL);\n\tif (!render)\n\t\treturn -ENOMEM;\n\n\trender->start = args->rcl_start;\n\trender->end = args->rcl_end;\n\tINIT_LIST_HEAD(&render->unref_list);\n\n\tret = v3d_job_init(v3d, file_priv, &render->base,\n\t\t\t   v3d_render_job_free, args->in_sync_rcl);\n\tif (ret) {\n\t\tkfree(render);\n\t\treturn ret;\n\t}\n\n\tif (args->bcl_start != args->bcl_end) {\n\t\tbin = kcalloc(1, sizeof(*bin), GFP_KERNEL);\n\t\tif (!bin) {\n\t\t\tv3d_job_put(&render->base);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = v3d_job_init(v3d, file_priv, &bin->base,\n\t\t\t\t   v3d_job_free, args->in_sync_bcl);\n\t\tif (ret) {\n\t\t\tv3d_job_put(&render->base);\n\t\t\tkfree(bin);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbin->start = args->bcl_start;\n\t\tbin->end = args->bcl_end;\n\t\tbin->qma = args->qma;\n\t\tbin->qms = args->qms;\n\t\tbin->qts = args->qts;\n\t\tbin->render = render;\n\t}\n\n\tret = v3d_lookup_bos(dev, file_priv, &render->base,\n\t\t\t     args->bo_handles, args->bo_handle_count);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = v3d_lock_bo_reservations(&render->base, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&v3d->sched_lock);\n\tif (bin) {\n\t\tret = v3d_push_job(v3d_priv, &bin->base, V3D_BIN);\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\n\t\tret = drm_gem_fence_array_add(&render->base.deps,\n\t\t\t\t\t      dma_fence_get(bin->base.done_fence));\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\t}\n\n\tret = v3d_push_job(v3d_priv, &render->base, V3D_RENDER);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t &render->base,\n\t\t\t\t\t\t &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t render->base.done_fence);\n\n\tif (bin)\n\t\tv3d_job_put(&bin->base);\n\tv3d_job_put(&render->base);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\n\tdrm_gem_unlock_reservations(render->base.bo,\n\t\t\t\t    render->base.bo_count, &acquire_ctx);\nfail:\n\tif (bin)\n\t\tv3d_job_put(&bin->base);\n\tv3d_job_put(&render->base);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,13 +34,16 @@\n \n \tif (args->bcl_start != args->bcl_end) {\n \t\tbin = kcalloc(1, sizeof(*bin), GFP_KERNEL);\n-\t\tif (!bin)\n+\t\tif (!bin) {\n+\t\t\tv3d_job_put(&render->base);\n \t\t\treturn -ENOMEM;\n+\t\t}\n \n \t\tret = v3d_job_init(v3d, file_priv, &bin->base,\n \t\t\t\t   v3d_job_free, args->in_sync_bcl);\n \t\tif (ret) {\n \t\t\tv3d_job_put(&render->base);\n+\t\t\tkfree(bin);\n \t\t\treturn ret;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (!bin)"
            ],
            "added_lines": [
                "\t\tif (!bin) {",
                "\t\t\tv3d_job_put(&render->base);",
                "\t\t}",
                "\t\t\tkfree(bin);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19045",
        "func_name": "torvalds/linux/mlx5_fpga_conn_create_cq",
        "description": "A memory leak in the mlx5_fpga_conn_create_cq() function in drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_vector2eqn() failures, aka CID-c8c2a057fdc7.",
        "git_url": "https://github.com/torvalds/linux/commit/c8c2a057fdc7de1cd16f4baa51425b932a42eb39",
        "commit_title": "net/mlx5: prevent memory leak in mlx5_fpga_conn_create_cq",
        "commit_text": " In mlx5_fpga_conn_create_cq if mlx5_vector2eqn fails the allocated memory should be released. ",
        "func_before": "static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}",
        "func": "static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size)\n{\n\tstruct mlx5_fpga_device *fdev = conn->fdev;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\tu32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0};\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tstruct mlx5_wq_param wqp;\n\tstruct mlx5_cqe64 *cqe;\n\tint inlen, err, eqn;\n\tunsigned int irqn;\n\tvoid *cqc, *in;\n\t__be64 *pas;\n\tu32 i;\n\n\tcq_size = roundup_pow_of_two(cq_size);\n\tMLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size));\n\n\twqp.buf_numa_node = mdev->priv.numa_node;\n\twqp.db_numa_node  = mdev->priv.numa_node;\n\n\terr = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq,\n\t\t\t       &conn->cq.wq_ctrl);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) {\n\t\tcqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i);\n\t\tcqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\tsizeof(u64) * conn->cq.wq_ctrl.buf.npages;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_cqwq;\n\t}\n\n\terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n\tif (err) {\n\t\tkvfree(in);\n\t\tgoto err_cqwq;\n\t}\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));\n\tMLX5_SET(cqc, cqc, c_eqn, eqn);\n\tMLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index);\n\tMLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift -\n\t\t\t   MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas);\n\tmlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas);\n\n\terr = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_cqwq;\n\n\tconn->cq.mcq.cqe_sz     = 64;\n\tconn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db;\n\tconn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1;\n\t*conn->cq.mcq.set_ci_db = 0;\n\t*conn->cq.mcq.arm_db    = 0;\n\tconn->cq.mcq.vector     = 0;\n\tconn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete;\n\tconn->cq.mcq.event      = mlx5_fpga_conn_cq_event;\n\tconn->cq.mcq.irqn       = irqn;\n\tconn->cq.mcq.uar        = fdev->conn_res.uar;\n\ttasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet,\n\t\t     (unsigned long)conn);\n\n\tmlx5_fpga_dbg(fdev, \"Created CQ #0x%x\\n\", conn->cq.mcq.cqn);\n\n\tgoto out;\n\nerr_cqwq:\n\tmlx5_wq_destroy(&conn->cq.wq_ctrl);\nout:\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,8 +37,10 @@\n \t}\n \n \terr = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn);\n-\tif (err)\n+\tif (err) {\n+\t\tkvfree(in);\n \t\tgoto err_cqwq;\n+\t}\n \n \tcqc = MLX5_ADDR_OF(create_cq_in, in, cq_context);\n \tMLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size));",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (err)"
            ],
            "added_lines": [
                "\tif (err) {",
                "\t\tkvfree(in);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19046",
        "func_name": "torvalds/linux/__ipmi_bmc_register",
        "description": "A memory leak in the __ipmi_bmc_register() function in drivers/char/ipmi/ipmi_msghandler.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering ida_simple_get() failure, aka CID-4aa7afb0ee20. NOTE: third parties dispute the relevance of this because an attacker cannot realistically control this failure at probe time",
        "git_url": "https://github.com/torvalds/linux/commit/4aa7afb0ee20a97fbf0c5bab3df028d5fb85fdab",
        "commit_title": "ipmi: Fix memory leak in __ipmi_bmc_register",
        "commit_text": " In the impelementation of __ipmi_bmc_register() the allocated memory for bmc should be released in case ida_simple_get() fails.  Message-Id: <20191021200649.1511-1-navid.emamdoost@gmail.com>",
        "func_before": "static int __ipmi_bmc_register(struct ipmi_smi *intf,\n\t\t\t       struct ipmi_device_id *id,\n\t\t\t       bool guid_set, guid_t *guid, int intf_num)\n{\n\tint               rv;\n\tstruct bmc_device *bmc;\n\tstruct bmc_device *old_bmc;\n\n\t/*\n\t * platform_device_register() can cause bmc_reg_mutex to\n\t * be claimed because of the is_visible functions of\n\t * the attributes.  Eliminate possible recursion and\n\t * release the lock.\n\t */\n\tintf->in_bmc_register = true;\n\tmutex_unlock(&intf->bmc_reg_mutex);\n\n\t/*\n\t * Try to find if there is an bmc_device struct\n\t * representing the interfaced BMC already\n\t */\n\tmutex_lock(&ipmidriver_mutex);\n\tif (guid_set)\n\t\told_bmc = ipmi_find_bmc_guid(&ipmidriver.driver, guid);\n\telse\n\t\told_bmc = ipmi_find_bmc_prod_dev_id(&ipmidriver.driver,\n\t\t\t\t\t\t    id->product_id,\n\t\t\t\t\t\t    id->device_id);\n\n\t/*\n\t * If there is already an bmc_device, free the new one,\n\t * otherwise register the new BMC device\n\t */\n\tif (old_bmc) {\n\t\tbmc = old_bmc;\n\t\t/*\n\t\t * Note: old_bmc already has usecount incremented by\n\t\t * the BMC find functions.\n\t\t */\n\t\tintf->bmc = old_bmc;\n\t\tmutex_lock(&bmc->dyn_mutex);\n\t\tlist_add_tail(&intf->bmc_link, &bmc->intfs);\n\t\tmutex_unlock(&bmc->dyn_mutex);\n\n\t\tdev_info(intf->si_dev,\n\t\t\t \"interfacing existing BMC (man_id: 0x%6.6x, prod_id: 0x%4.4x, dev_id: 0x%2.2x)\\n\",\n\t\t\t bmc->id.manufacturer_id,\n\t\t\t bmc->id.product_id,\n\t\t\t bmc->id.device_id);\n\t} else {\n\t\tbmc = kzalloc(sizeof(*bmc), GFP_KERNEL);\n\t\tif (!bmc) {\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tINIT_LIST_HEAD(&bmc->intfs);\n\t\tmutex_init(&bmc->dyn_mutex);\n\t\tINIT_WORK(&bmc->remove_work, cleanup_bmc_work);\n\n\t\tbmc->id = *id;\n\t\tbmc->dyn_id_set = 1;\n\t\tbmc->dyn_guid_set = guid_set;\n\t\tbmc->guid = *guid;\n\t\tbmc->dyn_id_expiry = jiffies + IPMI_DYN_DEV_ID_EXPIRY;\n\n\t\tbmc->pdev.name = \"ipmi_bmc\";\n\n\t\trv = ida_simple_get(&ipmi_bmc_ida, 0, 0, GFP_KERNEL);\n\t\tif (rv < 0)\n\t\t\tgoto out;\n\t\tbmc->pdev.dev.driver = &ipmidriver.driver;\n\t\tbmc->pdev.id = rv;\n\t\tbmc->pdev.dev.release = release_bmc_device;\n\t\tbmc->pdev.dev.type = &bmc_device_type;\n\t\tkref_init(&bmc->usecount);\n\n\t\tintf->bmc = bmc;\n\t\tmutex_lock(&bmc->dyn_mutex);\n\t\tlist_add_tail(&intf->bmc_link, &bmc->intfs);\n\t\tmutex_unlock(&bmc->dyn_mutex);\n\n\t\trv = platform_device_register(&bmc->pdev);\n\t\tif (rv) {\n\t\t\tdev_err(intf->si_dev,\n\t\t\t\t\"Unable to register bmc device: %d\\n\",\n\t\t\t\trv);\n\t\t\tgoto out_list_del;\n\t\t}\n\n\t\tdev_info(intf->si_dev,\n\t\t\t \"Found new BMC (man_id: 0x%6.6x, prod_id: 0x%4.4x, dev_id: 0x%2.2x)\\n\",\n\t\t\t bmc->id.manufacturer_id,\n\t\t\t bmc->id.product_id,\n\t\t\t bmc->id.device_id);\n\t}\n\n\t/*\n\t * create symlink from system interface device to bmc device\n\t * and back.\n\t */\n\trv = sysfs_create_link(&intf->si_dev->kobj, &bmc->pdev.dev.kobj, \"bmc\");\n\tif (rv) {\n\t\tdev_err(intf->si_dev, \"Unable to create bmc symlink: %d\\n\", rv);\n\t\tgoto out_put_bmc;\n\t}\n\n\tif (intf_num == -1)\n\t\tintf_num = intf->intf_num;\n\tintf->my_dev_name = kasprintf(GFP_KERNEL, \"ipmi%d\", intf_num);\n\tif (!intf->my_dev_name) {\n\t\trv = -ENOMEM;\n\t\tdev_err(intf->si_dev, \"Unable to allocate link from BMC: %d\\n\",\n\t\t\trv);\n\t\tgoto out_unlink1;\n\t}\n\n\trv = sysfs_create_link(&bmc->pdev.dev.kobj, &intf->si_dev->kobj,\n\t\t\t       intf->my_dev_name);\n\tif (rv) {\n\t\tkfree(intf->my_dev_name);\n\t\tintf->my_dev_name = NULL;\n\t\tdev_err(intf->si_dev, \"Unable to create symlink to bmc: %d\\n\",\n\t\t\trv);\n\t\tgoto out_free_my_dev_name;\n\t}\n\n\tintf->bmc_registered = true;\n\nout:\n\tmutex_unlock(&ipmidriver_mutex);\n\tmutex_lock(&intf->bmc_reg_mutex);\n\tintf->in_bmc_register = false;\n\treturn rv;\n\n\nout_free_my_dev_name:\n\tkfree(intf->my_dev_name);\n\tintf->my_dev_name = NULL;\n\nout_unlink1:\n\tsysfs_remove_link(&intf->si_dev->kobj, \"bmc\");\n\nout_put_bmc:\n\tmutex_lock(&bmc->dyn_mutex);\n\tlist_del(&intf->bmc_link);\n\tmutex_unlock(&bmc->dyn_mutex);\n\tintf->bmc = &intf->tmp_bmc;\n\tkref_put(&bmc->usecount, cleanup_bmc_device);\n\tgoto out;\n\nout_list_del:\n\tmutex_lock(&bmc->dyn_mutex);\n\tlist_del(&intf->bmc_link);\n\tmutex_unlock(&bmc->dyn_mutex);\n\tintf->bmc = &intf->tmp_bmc;\n\tput_device(&bmc->pdev.dev);\n\tgoto out;\n}",
        "func": "static int __ipmi_bmc_register(struct ipmi_smi *intf,\n\t\t\t       struct ipmi_device_id *id,\n\t\t\t       bool guid_set, guid_t *guid, int intf_num)\n{\n\tint               rv;\n\tstruct bmc_device *bmc;\n\tstruct bmc_device *old_bmc;\n\n\t/*\n\t * platform_device_register() can cause bmc_reg_mutex to\n\t * be claimed because of the is_visible functions of\n\t * the attributes.  Eliminate possible recursion and\n\t * release the lock.\n\t */\n\tintf->in_bmc_register = true;\n\tmutex_unlock(&intf->bmc_reg_mutex);\n\n\t/*\n\t * Try to find if there is an bmc_device struct\n\t * representing the interfaced BMC already\n\t */\n\tmutex_lock(&ipmidriver_mutex);\n\tif (guid_set)\n\t\told_bmc = ipmi_find_bmc_guid(&ipmidriver.driver, guid);\n\telse\n\t\told_bmc = ipmi_find_bmc_prod_dev_id(&ipmidriver.driver,\n\t\t\t\t\t\t    id->product_id,\n\t\t\t\t\t\t    id->device_id);\n\n\t/*\n\t * If there is already an bmc_device, free the new one,\n\t * otherwise register the new BMC device\n\t */\n\tif (old_bmc) {\n\t\tbmc = old_bmc;\n\t\t/*\n\t\t * Note: old_bmc already has usecount incremented by\n\t\t * the BMC find functions.\n\t\t */\n\t\tintf->bmc = old_bmc;\n\t\tmutex_lock(&bmc->dyn_mutex);\n\t\tlist_add_tail(&intf->bmc_link, &bmc->intfs);\n\t\tmutex_unlock(&bmc->dyn_mutex);\n\n\t\tdev_info(intf->si_dev,\n\t\t\t \"interfacing existing BMC (man_id: 0x%6.6x, prod_id: 0x%4.4x, dev_id: 0x%2.2x)\\n\",\n\t\t\t bmc->id.manufacturer_id,\n\t\t\t bmc->id.product_id,\n\t\t\t bmc->id.device_id);\n\t} else {\n\t\tbmc = kzalloc(sizeof(*bmc), GFP_KERNEL);\n\t\tif (!bmc) {\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tINIT_LIST_HEAD(&bmc->intfs);\n\t\tmutex_init(&bmc->dyn_mutex);\n\t\tINIT_WORK(&bmc->remove_work, cleanup_bmc_work);\n\n\t\tbmc->id = *id;\n\t\tbmc->dyn_id_set = 1;\n\t\tbmc->dyn_guid_set = guid_set;\n\t\tbmc->guid = *guid;\n\t\tbmc->dyn_id_expiry = jiffies + IPMI_DYN_DEV_ID_EXPIRY;\n\n\t\tbmc->pdev.name = \"ipmi_bmc\";\n\n\t\trv = ida_simple_get(&ipmi_bmc_ida, 0, 0, GFP_KERNEL);\n\t\tif (rv < 0) {\n\t\t\tkfree(bmc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbmc->pdev.dev.driver = &ipmidriver.driver;\n\t\tbmc->pdev.id = rv;\n\t\tbmc->pdev.dev.release = release_bmc_device;\n\t\tbmc->pdev.dev.type = &bmc_device_type;\n\t\tkref_init(&bmc->usecount);\n\n\t\tintf->bmc = bmc;\n\t\tmutex_lock(&bmc->dyn_mutex);\n\t\tlist_add_tail(&intf->bmc_link, &bmc->intfs);\n\t\tmutex_unlock(&bmc->dyn_mutex);\n\n\t\trv = platform_device_register(&bmc->pdev);\n\t\tif (rv) {\n\t\t\tdev_err(intf->si_dev,\n\t\t\t\t\"Unable to register bmc device: %d\\n\",\n\t\t\t\trv);\n\t\t\tgoto out_list_del;\n\t\t}\n\n\t\tdev_info(intf->si_dev,\n\t\t\t \"Found new BMC (man_id: 0x%6.6x, prod_id: 0x%4.4x, dev_id: 0x%2.2x)\\n\",\n\t\t\t bmc->id.manufacturer_id,\n\t\t\t bmc->id.product_id,\n\t\t\t bmc->id.device_id);\n\t}\n\n\t/*\n\t * create symlink from system interface device to bmc device\n\t * and back.\n\t */\n\trv = sysfs_create_link(&intf->si_dev->kobj, &bmc->pdev.dev.kobj, \"bmc\");\n\tif (rv) {\n\t\tdev_err(intf->si_dev, \"Unable to create bmc symlink: %d\\n\", rv);\n\t\tgoto out_put_bmc;\n\t}\n\n\tif (intf_num == -1)\n\t\tintf_num = intf->intf_num;\n\tintf->my_dev_name = kasprintf(GFP_KERNEL, \"ipmi%d\", intf_num);\n\tif (!intf->my_dev_name) {\n\t\trv = -ENOMEM;\n\t\tdev_err(intf->si_dev, \"Unable to allocate link from BMC: %d\\n\",\n\t\t\trv);\n\t\tgoto out_unlink1;\n\t}\n\n\trv = sysfs_create_link(&bmc->pdev.dev.kobj, &intf->si_dev->kobj,\n\t\t\t       intf->my_dev_name);\n\tif (rv) {\n\t\tkfree(intf->my_dev_name);\n\t\tintf->my_dev_name = NULL;\n\t\tdev_err(intf->si_dev, \"Unable to create symlink to bmc: %d\\n\",\n\t\t\trv);\n\t\tgoto out_free_my_dev_name;\n\t}\n\n\tintf->bmc_registered = true;\n\nout:\n\tmutex_unlock(&ipmidriver_mutex);\n\tmutex_lock(&intf->bmc_reg_mutex);\n\tintf->in_bmc_register = false;\n\treturn rv;\n\n\nout_free_my_dev_name:\n\tkfree(intf->my_dev_name);\n\tintf->my_dev_name = NULL;\n\nout_unlink1:\n\tsysfs_remove_link(&intf->si_dev->kobj, \"bmc\");\n\nout_put_bmc:\n\tmutex_lock(&bmc->dyn_mutex);\n\tlist_del(&intf->bmc_link);\n\tmutex_unlock(&bmc->dyn_mutex);\n\tintf->bmc = &intf->tmp_bmc;\n\tkref_put(&bmc->usecount, cleanup_bmc_device);\n\tgoto out;\n\nout_list_del:\n\tmutex_lock(&bmc->dyn_mutex);\n\tlist_del(&intf->bmc_link);\n\tmutex_unlock(&bmc->dyn_mutex);\n\tintf->bmc = &intf->tmp_bmc;\n\tput_device(&bmc->pdev.dev);\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,8 +66,11 @@\n \t\tbmc->pdev.name = \"ipmi_bmc\";\n \n \t\trv = ida_simple_get(&ipmi_bmc_ida, 0, 0, GFP_KERNEL);\n-\t\tif (rv < 0)\n+\t\tif (rv < 0) {\n+\t\t\tkfree(bmc);\n \t\t\tgoto out;\n+\t\t}\n+\n \t\tbmc->pdev.dev.driver = &ipmidriver.driver;\n \t\tbmc->pdev.id = rv;\n \t\tbmc->pdev.dev.release = release_bmc_device;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (rv < 0)"
            ],
            "added_lines": [
                "\t\tif (rv < 0) {",
                "\t\t\tkfree(bmc);",
                "\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19047",
        "func_name": "torvalds/linux/mlx5_fw_fatal_reporter_dump",
        "description": "A memory leak in the mlx5_fw_fatal_reporter_dump() function in drivers/net/ethernet/mellanox/mlx5/core/health.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_crdump_collect() failures, aka CID-c7ed6d0183d5.",
        "git_url": "https://github.com/torvalds/linux/commit/c7ed6d0183d5ea9bc31bcaeeba4070bd62546471",
        "commit_title": "net/mlx5: fix memory leak in mlx5_fw_fatal_reporter_dump",
        "commit_text": " In mlx5_fw_fatal_reporter_dump if mlx5_crdump_collect fails the allocated memory for cr_data must be released otherwise there will be memory leak. To fix this, this commit changes the return instruction into goto error handling. ",
        "func_before": "static int\nmlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\treturn err;\n\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}",
        "func": "static int\nmlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\tgoto free_data;\n\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t\treturn -ENOMEM;\n \terr = mlx5_crdump_collect(dev, cr_data);\n \tif (err)\n-\t\treturn err;\n+\t\tgoto free_data;\n \n \tif (priv_ctx) {\n \t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn err;"
            ],
            "added_lines": [
                "\t\tgoto free_data;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19048",
        "func_name": "torvalds/linux/hgcm_call_preprocess_linaddr",
        "description": "A memory leak in the crypto_reportstat() function in drivers/virt/vboxguest/vboxguest_utils.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering copy_form_user() failures, aka CID-e0b0cb938864.",
        "git_url": "https://github.com/torvalds/linux/commit/e0b0cb9388642c104838fac100a4af32745621e2",
        "commit_title": "virt: vbox: fix memory leak in hgcm_call_preprocess_linaddr",
        "commit_text": " In hgcm_call_preprocess_linaddr memory is allocated for bounce_buf but is not released if copy_form_user fails. In order to prevent memory leak in case of failure, the assignment to bounce_buf_ret is moved before the error check. This way the allocated bounce_buf will be released by the caller.  Link: https://lore.kernel.org/r/20190930204223.3660-1-navid.emamdoost@gmail.com",
        "func_before": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}",
        "func": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\n\t*bounce_buf_ret = bounce_buf;\n\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,8 @@\n \tif (!bounce_buf)\n \t\treturn -ENOMEM;\n \n+\t*bounce_buf_ret = bounce_buf;\n+\n \tif (copy_in) {\n \t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n \t\tif (ret)\n@@ -26,7 +28,6 @@\n \t\tmemset(bounce_buf, 0, len);\n \t}\n \n-\t*bounce_buf_ret = bounce_buf;\n \thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t*bounce_buf_ret = bounce_buf;"
            ],
            "added_lines": [
                "\t*bounce_buf_ret = bounce_buf;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19050",
        "func_name": "torvalds/linux/crypto_reportstat",
        "description": "A memory leak in the crypto_reportstat() function in crypto/crypto_user_stat.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering crypto_reportstat_alg() failures, aka CID-c03b04dcdba1.",
        "git_url": "https://github.com/torvalds/linux/commit/c03b04dcdba1da39903e23cc4d072abf8f68f2dd",
        "commit_title": "crypto: user - fix memory leak in crypto_reportstat",
        "commit_text": " In crypto_reportstat, a new skb is created by nlmsg_new(). This skb is leaked if crypto_reportstat_alg() fails. Required release for skb is added.  Cc: <stable@vger.kernel.org>",
        "func_before": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_reportstat_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}",
        "func": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_reportstat_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,8 +30,10 @@\n drop_alg:\n \tcrypto_mod_put(alg);\n \n-\tif (err)\n+\tif (err) {\n+\t\tkfree_skb(skb);\n \t\treturn err;\n+\t}\n \n \treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (err)"
            ],
            "added_lines": [
                "\tif (err) {",
                "\t\tkfree_skb(skb);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19051",
        "func_name": "torvalds/linux/i2400m_op_rfkill_sw_toggle",
        "description": "A memory leak in the i2400m_op_rfkill_sw_toggle() function in drivers/net/wimax/i2400m/op-rfkill.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-6f3ef5c25cc7.",
        "git_url": "https://github.com/torvalds/linux/commit/6f3ef5c25cc762687a7341c18cbea5af54461407",
        "commit_title": "wimax: i2400: Fix memory leak in i2400m_op_rfkill_sw_toggle",
        "commit_text": " In the implementation of i2400m_op_rfkill_sw_toggle() the allocated buffer for cmd should be released before returning. The documentation for i2400m_msg_to_dev() says when it returns the buffer can be reused. Meaning cmd should be released in either case. Move kfree(cmd) before return to be reached by all execution paths. ",
        "func_before": "int i2400m_op_rfkill_sw_toggle(struct wimax_dev *wimax_dev,\n\t\t\t       enum wimax_rf_state state)\n{\n\tint result;\n\tstruct i2400m *i2400m = wimax_dev_to_i2400m(wimax_dev);\n\tstruct device *dev = i2400m_dev(i2400m);\n\tstruct sk_buff *ack_skb;\n\tstruct {\n\t\tstruct i2400m_l3l4_hdr hdr;\n\t\tstruct i2400m_tlv_rf_operation sw_rf;\n\t} __packed *cmd;\n\tchar strerr[32];\n\n\td_fnstart(4, dev, \"(wimax_dev %p state %d)\\n\", wimax_dev, state);\n\n\tresult = -ENOMEM;\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\tgoto error_alloc;\n\tcmd->hdr.type = cpu_to_le16(I2400M_MT_CMD_RF_CONTROL);\n\tcmd->hdr.length = sizeof(cmd->sw_rf);\n\tcmd->hdr.version = cpu_to_le16(I2400M_L3L4_VERSION);\n\tcmd->sw_rf.hdr.type = cpu_to_le16(I2400M_TLV_RF_OPERATION);\n\tcmd->sw_rf.hdr.length = cpu_to_le16(sizeof(cmd->sw_rf.status));\n\tswitch (state) {\n\tcase WIMAX_RF_OFF:\t/* RFKILL ON, radio OFF */\n\t\tcmd->sw_rf.status = cpu_to_le32(2);\n\t\tbreak;\n\tcase WIMAX_RF_ON:\t/* RFKILL OFF, radio ON */\n\t\tcmd->sw_rf.status = cpu_to_le32(1);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tack_skb = i2400m_msg_to_dev(i2400m, cmd, sizeof(*cmd));\n\tresult = PTR_ERR(ack_skb);\n\tif (IS_ERR(ack_skb)) {\n\t\tdev_err(dev, \"Failed to issue 'RF Control' command: %d\\n\",\n\t\t\tresult);\n\t\tgoto error_msg_to_dev;\n\t}\n\tresult = i2400m_msg_check_status(wimax_msg_data(ack_skb),\n\t\t\t\t\t strerr, sizeof(strerr));\n\tif (result < 0) {\n\t\tdev_err(dev, \"'RF Control' (0x%04x) command failed: %d - %s\\n\",\n\t\t\tI2400M_MT_CMD_RF_CONTROL, result, strerr);\n\t\tgoto error_cmd;\n\t}\n\n\t/* Now we wait for the state to change to RADIO_OFF or RADIO_ON */\n\tresult = wait_event_timeout(\n\t\ti2400m->state_wq, i2400m_radio_is(i2400m, state),\n\t\t5 * HZ);\n\tif (result == 0)\n\t\tresult = -ETIMEDOUT;\n\tif (result < 0)\n\t\tdev_err(dev, \"Error waiting for device to toggle RF state: \"\n\t\t\t\"%d\\n\", result);\n\tresult = 0;\nerror_cmd:\n\tkfree(cmd);\n\tkfree_skb(ack_skb);\nerror_msg_to_dev:\nerror_alloc:\n\td_fnend(4, dev, \"(wimax_dev %p state %d) = %d\\n\",\n\t\twimax_dev, state, result);\n\treturn result;\n}",
        "func": "int i2400m_op_rfkill_sw_toggle(struct wimax_dev *wimax_dev,\n\t\t\t       enum wimax_rf_state state)\n{\n\tint result;\n\tstruct i2400m *i2400m = wimax_dev_to_i2400m(wimax_dev);\n\tstruct device *dev = i2400m_dev(i2400m);\n\tstruct sk_buff *ack_skb;\n\tstruct {\n\t\tstruct i2400m_l3l4_hdr hdr;\n\t\tstruct i2400m_tlv_rf_operation sw_rf;\n\t} __packed *cmd;\n\tchar strerr[32];\n\n\td_fnstart(4, dev, \"(wimax_dev %p state %d)\\n\", wimax_dev, state);\n\n\tresult = -ENOMEM;\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\tgoto error_alloc;\n\tcmd->hdr.type = cpu_to_le16(I2400M_MT_CMD_RF_CONTROL);\n\tcmd->hdr.length = sizeof(cmd->sw_rf);\n\tcmd->hdr.version = cpu_to_le16(I2400M_L3L4_VERSION);\n\tcmd->sw_rf.hdr.type = cpu_to_le16(I2400M_TLV_RF_OPERATION);\n\tcmd->sw_rf.hdr.length = cpu_to_le16(sizeof(cmd->sw_rf.status));\n\tswitch (state) {\n\tcase WIMAX_RF_OFF:\t/* RFKILL ON, radio OFF */\n\t\tcmd->sw_rf.status = cpu_to_le32(2);\n\t\tbreak;\n\tcase WIMAX_RF_ON:\t/* RFKILL OFF, radio ON */\n\t\tcmd->sw_rf.status = cpu_to_le32(1);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tack_skb = i2400m_msg_to_dev(i2400m, cmd, sizeof(*cmd));\n\tresult = PTR_ERR(ack_skb);\n\tif (IS_ERR(ack_skb)) {\n\t\tdev_err(dev, \"Failed to issue 'RF Control' command: %d\\n\",\n\t\t\tresult);\n\t\tgoto error_msg_to_dev;\n\t}\n\tresult = i2400m_msg_check_status(wimax_msg_data(ack_skb),\n\t\t\t\t\t strerr, sizeof(strerr));\n\tif (result < 0) {\n\t\tdev_err(dev, \"'RF Control' (0x%04x) command failed: %d - %s\\n\",\n\t\t\tI2400M_MT_CMD_RF_CONTROL, result, strerr);\n\t\tgoto error_cmd;\n\t}\n\n\t/* Now we wait for the state to change to RADIO_OFF or RADIO_ON */\n\tresult = wait_event_timeout(\n\t\ti2400m->state_wq, i2400m_radio_is(i2400m, state),\n\t\t5 * HZ);\n\tif (result == 0)\n\t\tresult = -ETIMEDOUT;\n\tif (result < 0)\n\t\tdev_err(dev, \"Error waiting for device to toggle RF state: \"\n\t\t\t\"%d\\n\", result);\n\tresult = 0;\nerror_cmd:\n\tkfree_skb(ack_skb);\nerror_msg_to_dev:\nerror_alloc:\n\td_fnend(4, dev, \"(wimax_dev %p state %d) = %d\\n\",\n\t\twimax_dev, state, result);\n\tkfree(cmd);\n\treturn result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -59,11 +59,11 @@\n \t\t\t\"%d\\n\", result);\n \tresult = 0;\n error_cmd:\n-\tkfree(cmd);\n \tkfree_skb(ack_skb);\n error_msg_to_dev:\n error_alloc:\n \td_fnend(4, dev, \"(wimax_dev %p state %d) = %d\\n\",\n \t\twimax_dev, state, result);\n+\tkfree(cmd);\n \treturn result;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tkfree(cmd);"
            ],
            "added_lines": [
                "\tkfree(cmd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19052",
        "func_name": "torvalds/linux/gs_can_open",
        "description": "A memory leak in the gs_can_open() function in drivers/net/can/usb/gs_usb.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-fb5be6a7b486.",
        "git_url": "https://github.com/torvalds/linux/commit/fb5be6a7b4863ecc44963bb80ca614584b6c7817",
        "commit_title": "can: gs_usb: gs_can_open(): prevent memory leak",
        "commit_text": " In gs_can_open() if usb_submit_urb() fails the allocated urb should be released.  Cc: linux-stable <stable@vger.kernel.org>",
        "func_before": "static int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"No memory left for USB buffer\\n\");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tkfree(dm);\n\t\treturn rc;\n\t}\n\n\tkfree(dm);\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n}",
        "func": "static int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"No memory left for USB buffer\\n\");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tkfree(dm);\n\t\treturn rc;\n\t}\n\n\tkfree(dm);\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,6 +55,7 @@\n \t\t\t\t\t   rc);\n \n \t\t\t\tusb_unanchor_urb(urb);\n+\t\t\t\tusb_free_urb(urb);\n \t\t\t\tbreak;\n \t\t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tusb_free_urb(urb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19053",
        "func_name": "torvalds/linux/rpmsg_eptdev_write_iter",
        "description": "A memory leak in the rpmsg_eptdev_write_iter() function in drivers/rpmsg/rpmsg_char.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering copy_from_iter_full() failures, aka CID-bbe692e349e2.",
        "git_url": "https://github.com/torvalds/linux/commit/bbe692e349e2a1edf3fe0a29a0e05899c9c94d51",
        "commit_title": "rpmsg: char: release allocated memory",
        "commit_text": " In rpmsg_eptdev_write_iter, if copy_from_iter_full fails the allocated buffer needs to be released. ",
        "func_before": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\n\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\n\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}",
        "func": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tret = -EFAULT;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\n\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\n\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,8 +11,10 @@\n \tif (!kbuf)\n \t\treturn -ENOMEM;\n \n-\tif (!copy_from_iter_full(kbuf, len, from))\n-\t\treturn -EFAULT;\n+\tif (!copy_from_iter_full(kbuf, len, from)) {\n+\t\tret = -EFAULT;\n+\t\tgoto free_kbuf;\n+\t}\n \n \tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n \t\tret = -ERESTARTSYS;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!copy_from_iter_full(kbuf, len, from))",
                "\t\treturn -EFAULT;"
            ],
            "added_lines": [
                "\tif (!copy_from_iter_full(kbuf, len, from)) {",
                "\t\tret = -EFAULT;",
                "\t\tgoto free_kbuf;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19054",
        "func_name": "torvalds/linux/cx23888_ir_probe",
        "description": "A memory leak in the cx23888_ir_probe() function in drivers/media/pci/cx23885/cx23888-ir.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering kfifo_alloc() failures, aka CID-a7b2df76b42b.",
        "git_url": "https://github.com/torvalds/linux/commit/a7b2df76b42bdd026e3106cf2ba97db41345a177",
        "commit_title": "media: rc: prevent memory leak in cx23888_ir_probe",
        "commit_text": " In cx23888_ir_probe if kfifo_alloc fails the allocated memory for state should be released. ",
        "func_before": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tstate->dev = dev;\n\tsd = &state->sd;\n\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\t/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\t/*\n\t\t * Ensure no interrupts arrive from '888 specific conditions,\n\t\t * since we ignore them in this driver to have commonality with\n\t\t * similar IR controller cores.\n\t\t */\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}",
        "func": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE,\n\t\t\tGFP_KERNEL)) {\n\t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\n\tstate->dev = dev;\n\tsd = &state->sd;\n\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\t/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\t/*\n\t\t * Ensure no interrupts arrive from '888 specific conditions,\n\t\t * since we ignore them in this driver to have commonality with\n\t\t * similar IR controller cores.\n\t\t */\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,11 @@\n \t\treturn -ENOMEM;\n \n \tspin_lock_init(&state->rx_kfifo_lock);\n-\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n+\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE,\n+\t\t\tGFP_KERNEL)) {\n+\t\tkfree(state);\n \t\treturn -ENOMEM;\n+\t}\n \n \tstate->dev = dev;\n \tsd = &state->sd;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))"
            ],
            "added_lines": [
                "\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE,",
                "\t\t\tGFP_KERNEL)) {",
                "\t\tkfree(state);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19055",
        "func_name": "torvalds/linux/nl80211_get_ftm_responder_stats",
        "description": "A memory leak in the nl80211_get_ftm_responder_stats() function in net/wireless/nl80211.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering nl80211hdr_put() failures, aka CID-1399c59fa929. NOTE: third parties dispute the relevance of this because it occurs on a code path where a successful allocation has already occurred",
        "git_url": "https://github.com/torvalds/linux/commit/1399c59fa92984836db90538cf92397fe7caaa57",
        "commit_title": "nl80211: fix memory leak in nl80211_get_ftm_responder_stats",
        "commit_text": " In nl80211_get_ftm_responder_stats, a new skb is created via nlmsg_new named msg. If nl80211hdr_put() fails, then msg should be released. The return statement should be replace by goto to error handling code.  Link: https://lore.kernel.org/r/20191004194220.19412-1-navid.emamdoost@gmail.com",
        "func_before": "static int nl80211_get_ftm_responder_stats(struct sk_buff *skb,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ftm_responder_stats ftm_stats = {};\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *ftm_stats_attr;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);\n\tif (err)\n\t\treturn err;\n\n\tif (!ftm_stats.filled)\n\t\treturn -ENODATA;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tftm_stats_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_ATTR_FTM_RESPONDER_STATS);\n\tif (!ftm_stats_attr)\n\t\tgoto nla_put_failure;\n\n#define SET_FTM(field, name, type)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t     ftm_stats.field))\t\t\t\t \\\n\t\tgoto nla_put_failure; } while (0)\n#define SET_FTM_U64(field, name)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t      ftm_stats.field, NL80211_FTM_STATS_PAD))\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tSET_FTM(success_num, SUCCESS_NUM, u32);\n\tSET_FTM(partial_num, PARTIAL_NUM, u32);\n\tSET_FTM(failed_num, FAILED_NUM, u32);\n\tSET_FTM(asap_num, ASAP_NUM, u32);\n\tSET_FTM(non_asap_num, NON_ASAP_NUM, u32);\n\tSET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);\n\tSET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);\n\tSET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);\n\tSET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);\n#undef SET_FTM\n\n\tnla_nest_end(msg, ftm_stats_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}",
        "func": "static int nl80211_get_ftm_responder_stats(struct sk_buff *skb,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ftm_responder_stats ftm_stats = {};\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *ftm_stats_attr;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);\n\tif (err)\n\t\treturn err;\n\n\tif (!ftm_stats.filled)\n\t\treturn -ENODATA;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tftm_stats_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_ATTR_FTM_RESPONDER_STATS);\n\tif (!ftm_stats_attr)\n\t\tgoto nla_put_failure;\n\n#define SET_FTM(field, name, type)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t     ftm_stats.field))\t\t\t\t \\\n\t\tgoto nla_put_failure; } while (0)\n#define SET_FTM_U64(field, name)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t      ftm_stats.field, NL80211_FTM_STATS_PAD))\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tSET_FTM(success_num, SUCCESS_NUM, u32);\n\tSET_FTM(partial_num, PARTIAL_NUM, u32);\n\tSET_FTM(failed_num, FAILED_NUM, u32);\n\tSET_FTM(asap_num, ASAP_NUM, u32);\n\tSET_FTM(non_asap_num, NON_ASAP_NUM, u32);\n\tSET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);\n\tSET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);\n\tSET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);\n\tSET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);\n#undef SET_FTM\n\n\tnla_nest_end(msg, ftm_stats_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n \thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n \t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n \tif (!hdr)\n-\t\treturn -ENOBUFS;\n+\t\tgoto nla_put_failure;\n \n \tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n \t\tgoto nla_put_failure;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn -ENOBUFS;"
            ],
            "added_lines": [
                "\t\tgoto nla_put_failure;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19056",
        "func_name": "torvalds/linux/mwifiex_pcie_alloc_cmdrsp_buf",
        "description": "A memory leak in the mwifiex_pcie_alloc_cmdrsp_buf() function in drivers/net/wireless/marvell/mwifiex/pcie.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mwifiex_map_pci_memory() failures, aka CID-db8fd2cde932.",
        "git_url": "https://github.com/torvalds/linux/commit/db8fd2cde93227e566a412cf53173ffa227998bc",
        "commit_title": "mwifiex: pcie: Fix memory leak in mwifiex_pcie_alloc_cmdrsp_buf",
        "commit_text": " In mwifiex_pcie_alloc_cmdrsp_buf, a new skb is allocated which should be released if mwifiex_map_pci_memory() fails. The release is added. ",
        "func_before": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\n\t/* Allocate memory for receiving command response data */\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\n\tcard->cmdrsp_buf = skb;\n\n\treturn 0;\n}",
        "func": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\n\t/* Allocate memory for receiving command response data */\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE)) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tcard->cmdrsp_buf = skb;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,10 @@\n \t}\n \tskb_put(skb, MWIFIEX_UPLD_SIZE);\n \tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n-\t\t\t\t   PCI_DMA_FROMDEVICE))\n+\t\t\t\t   PCI_DMA_FROMDEVICE)) {\n+\t\tkfree_skb(skb);\n \t\treturn -1;\n+\t}\n \n \tcard->cmdrsp_buf = skb;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t   PCI_DMA_FROMDEVICE))"
            ],
            "added_lines": [
                "\t\t\t\t   PCI_DMA_FROMDEVICE)) {",
                "\t\tkfree_skb(skb);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19057",
        "func_name": "torvalds/linux/mwifiex_pcie_init_evt_ring",
        "description": "Two memory leaks in the mwifiex_pcie_init_evt_ring() function in drivers/net/wireless/marvell/mwifiex/pcie.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering mwifiex_map_pci_memory() failures, aka CID-d10dcb615c8e.",
        "git_url": "https://github.com/torvalds/linux/commit/d10dcb615c8e29d403a24d35f8310a7a53e3050c",
        "commit_title": "mwifiex: pcie: Fix memory leak in mwifiex_pcie_init_evt_ring",
        "commit_text": " In mwifiex_pcie_init_evt_ring, a new skb is allocated which should be released if mwifiex_map_pci_memory() fails. The release for skb and card->evtbd_ring_vbase is added. ",
        "func_before": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\n\treturn 0;\n}",
        "func": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\t/* Allocate skb here so that firmware can DMA data from it */\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE)) {\n\t\t\tkfree_skb(skb);\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,8 +18,11 @@\n \t\tskb_put(skb, MAX_EVENT_SIZE);\n \n \t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n-\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n+\t\t\t\t\t   PCI_DMA_FROMDEVICE)) {\n+\t\t\tkfree_skb(skb);\n+\t\t\tkfree(card->evtbd_ring_vbase);\n \t\t\treturn -1;\n+\t\t}\n \n \t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t   PCI_DMA_FROMDEVICE))"
            ],
            "added_lines": [
                "\t\t\t\t\t   PCI_DMA_FROMDEVICE)) {",
                "\t\t\tkfree_skb(skb);",
                "\t\t\tkfree(card->evtbd_ring_vbase);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19058",
        "func_name": "torvalds/linux/alloc_sgtable",
        "description": "A memory leak in the alloc_sgtable() function in drivers/net/wireless/intel/iwlwifi/fw/dbg.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering alloc_page() failures, aka CID-b4b814fec1a5.",
        "git_url": "https://github.com/torvalds/linux/commit/b4b814fec1a5a849383f7b3886b654a13abbda7d",
        "commit_title": "iwlwifi: dbg_ini: fix memory leak in alloc_sgtable",
        "commit_text": " In alloc_sgtable if alloc_page fails, the alocated table should be released. ",
        "func_before": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\t/* release all previous allocated pages in the table */\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}",
        "func": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\t/* release all previous allocated pages in the table */\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\tkfree(table);\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,7 @@\n \t\t\t\tif (new_page)\n \t\t\t\t\t__free_page(new_page);\n \t\t\t}\n+\t\t\tkfree(table);\n \t\t\treturn NULL;\n \t\t}\n \t\talloc_size = min_t(int, size, PAGE_SIZE);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tkfree(table);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19059",
        "func_name": "torvalds/linux/iwl_pcie_ctxt_info_gen3_init",
        "description": "Multiple memory leaks in the iwl_pcie_ctxt_info_gen3_init() function in drivers/net/wireless/intel/iwlwifi/pcie/ctxt-info-gen3.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering iwl_pcie_init_fw_sec() or dma_alloc_coherent() failures, aka CID-0f4f199443fa.",
        "git_url": "https://github.com/torvalds/linux/commit/0f4f199443faca715523b0659aa536251d8b978f",
        "commit_title": "iwlwifi: pcie: fix memory leaks in iwl_pcie_ctxt_info_gen3_init",
        "commit_text": " In iwl_pcie_ctxt_info_gen3_init there are cases that the allocated dma memory is leaked in case of error.  DMA memories prph_scratch, prph_info, and ctxt_info_gen3 are allocated and initialized to be later assigned to trans_pcie. But in any error case before such assignment the allocated memories should be released.  First of such error cases happens when iwl_pcie_init_fw_sec fails. Current implementation correctly releases prph_scratch. But in two sunsequent error cases where dma_alloc_coherent may fail, such releases are missing.  This commit adds release for prph_scratch when allocation for prph_info fails, and adds releases for prph_scratch and prph_info when allocation for ctxt_info_gen3 fails. ",
        "func_before": "int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *trans,\n\t\t\t\t const struct fw_img *fw)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tstruct iwl_context_info_gen3 *ctxt_info_gen3;\n\tstruct iwl_prph_scratch *prph_scratch;\n\tstruct iwl_prph_scratch_ctrl_cfg *prph_sc_ctrl;\n\tstruct iwl_prph_info *prph_info;\n\tvoid *iml_img;\n\tu32 control_flags = 0;\n\tint ret;\n\tint cmdq_size = max_t(u32, IWL_CMD_QUEUE_SIZE,\n\t\t\t      trans->cfg->min_txq_size);\n\n\t/* Allocate prph scratch */\n\tprph_scratch = dma_alloc_coherent(trans->dev, sizeof(*prph_scratch),\n\t\t\t\t\t  &trans_pcie->prph_scratch_dma_addr,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!prph_scratch)\n\t\treturn -ENOMEM;\n\n\tprph_sc_ctrl = &prph_scratch->ctrl_cfg;\n\n\tprph_sc_ctrl->version.version = 0;\n\tprph_sc_ctrl->version.mac_id =\n\t\tcpu_to_le16((u16)iwl_read32(trans, CSR_HW_REV));\n\tprph_sc_ctrl->version.size = cpu_to_le16(sizeof(*prph_scratch) / 4);\n\n\tcontrol_flags = IWL_PRPH_SCRATCH_RB_SIZE_4K |\n\t\t\tIWL_PRPH_SCRATCH_MTR_MODE |\n\t\t\t(IWL_PRPH_MTR_FORMAT_256B &\n\t\t\t IWL_PRPH_SCRATCH_MTR_FORMAT) |\n\t\t\tIWL_PRPH_SCRATCH_EARLY_DEBUG_EN |\n\t\t\tIWL_PRPH_SCRATCH_EDBG_DEST_DRAM;\n\tprph_sc_ctrl->control.control_flags = cpu_to_le32(control_flags);\n\n\t/* initialize RX default queue */\n\tprph_sc_ctrl->rbd_cfg.free_rbd_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->bd_dma);\n\n\t/* Configure debug, for integration */\n\tif (!iwl_trans_dbg_ini_valid(trans))\n\t\tiwl_pcie_alloc_fw_monitor(trans, 0);\n\tif (trans->dbg.num_blocks) {\n\t\tprph_sc_ctrl->hwm_cfg.hwm_base_addr =\n\t\t\tcpu_to_le64(trans->dbg.fw_mon[0].physical);\n\t\tprph_sc_ctrl->hwm_cfg.hwm_size =\n\t\t\tcpu_to_le32(trans->dbg.fw_mon[0].size);\n\t}\n\n\t/* allocate ucode sections in dram and set addresses */\n\tret = iwl_pcie_init_fw_sec(trans, fw, &prph_scratch->dram);\n\tif (ret) {\n\t\tdma_free_coherent(trans->dev,\n\t\t\t\t  sizeof(*prph_scratch),\n\t\t\t\t  prph_scratch,\n\t\t\t\t  trans_pcie->prph_scratch_dma_addr);\n\t\treturn ret;\n\t}\n\n\t/* Allocate prph information\n\t * currently we don't assign to the prph info anything, but it would get\n\t * assigned later */\n\tprph_info = dma_alloc_coherent(trans->dev, sizeof(*prph_info),\n\t\t\t\t       &trans_pcie->prph_info_dma_addr,\n\t\t\t\t       GFP_KERNEL);\n\tif (!prph_info)\n\t\treturn -ENOMEM;\n\n\t/* Allocate context info */\n\tctxt_info_gen3 = dma_alloc_coherent(trans->dev,\n\t\t\t\t\t    sizeof(*ctxt_info_gen3),\n\t\t\t\t\t    &trans_pcie->ctxt_info_dma_addr,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!ctxt_info_gen3)\n\t\treturn -ENOMEM;\n\n\tctxt_info_gen3->prph_info_base_addr =\n\t\tcpu_to_le64(trans_pcie->prph_info_dma_addr);\n\tctxt_info_gen3->prph_scratch_base_addr =\n\t\tcpu_to_le64(trans_pcie->prph_scratch_dma_addr);\n\tctxt_info_gen3->prph_scratch_size =\n\t\tcpu_to_le32(sizeof(*prph_scratch));\n\tctxt_info_gen3->cr_head_idx_arr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->rb_stts_dma);\n\tctxt_info_gen3->tr_tail_idx_arr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->tr_tail_dma);\n\tctxt_info_gen3->cr_tail_idx_arr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->cr_tail_dma);\n\tctxt_info_gen3->cr_idx_arr_size =\n\t\tcpu_to_le16(IWL_NUM_OF_COMPLETION_RINGS);\n\tctxt_info_gen3->tr_idx_arr_size =\n\t\tcpu_to_le16(IWL_NUM_OF_TRANSFER_RINGS);\n\tctxt_info_gen3->mtr_base_addr =\n\t\tcpu_to_le64(trans_pcie->txq[trans_pcie->cmd_queue]->dma_addr);\n\tctxt_info_gen3->mcr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->used_bd_dma);\n\tctxt_info_gen3->mtr_size =\n\t\tcpu_to_le16(TFD_QUEUE_CB_SIZE(cmdq_size));\n\tctxt_info_gen3->mcr_size =\n\t\tcpu_to_le16(RX_QUEUE_CB_SIZE(MQ_RX_TABLE_SIZE));\n\n\ttrans_pcie->ctxt_info_gen3 = ctxt_info_gen3;\n\ttrans_pcie->prph_info = prph_info;\n\ttrans_pcie->prph_scratch = prph_scratch;\n\n\t/* Allocate IML */\n\timl_img = dma_alloc_coherent(trans->dev, trans->iml_len,\n\t\t\t\t     &trans_pcie->iml_dma_addr, GFP_KERNEL);\n\tif (!iml_img)\n\t\treturn -ENOMEM;\n\n\tmemcpy(iml_img, trans->iml, trans->iml_len);\n\n\tiwl_enable_fw_load_int_ctx_info(trans);\n\n\t/* kick FW self load */\n\tiwl_write64(trans, CSR_CTXT_INFO_ADDR,\n\t\t    trans_pcie->ctxt_info_dma_addr);\n\tiwl_write64(trans, CSR_IML_DATA_ADDR,\n\t\t    trans_pcie->iml_dma_addr);\n\tiwl_write32(trans, CSR_IML_SIZE_ADDR, trans->iml_len);\n\n\tiwl_set_bit(trans, CSR_CTXT_INFO_BOOT_CTRL,\n\t\t    CSR_AUTO_FUNC_BOOT_ENA);\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\tiwl_write_umac_prph(trans, UREG_CPU_INIT_RUN, 1);\n\telse\n\t\tiwl_set_bit(trans, CSR_GP_CNTRL, CSR_AUTO_FUNC_INIT);\n\n\treturn 0;\n}",
        "func": "int iwl_pcie_ctxt_info_gen3_init(struct iwl_trans *trans,\n\t\t\t\t const struct fw_img *fw)\n{\n\tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\tstruct iwl_context_info_gen3 *ctxt_info_gen3;\n\tstruct iwl_prph_scratch *prph_scratch;\n\tstruct iwl_prph_scratch_ctrl_cfg *prph_sc_ctrl;\n\tstruct iwl_prph_info *prph_info;\n\tvoid *iml_img;\n\tu32 control_flags = 0;\n\tint ret;\n\tint cmdq_size = max_t(u32, IWL_CMD_QUEUE_SIZE,\n\t\t\t      trans->cfg->min_txq_size);\n\n\t/* Allocate prph scratch */\n\tprph_scratch = dma_alloc_coherent(trans->dev, sizeof(*prph_scratch),\n\t\t\t\t\t  &trans_pcie->prph_scratch_dma_addr,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!prph_scratch)\n\t\treturn -ENOMEM;\n\n\tprph_sc_ctrl = &prph_scratch->ctrl_cfg;\n\n\tprph_sc_ctrl->version.version = 0;\n\tprph_sc_ctrl->version.mac_id =\n\t\tcpu_to_le16((u16)iwl_read32(trans, CSR_HW_REV));\n\tprph_sc_ctrl->version.size = cpu_to_le16(sizeof(*prph_scratch) / 4);\n\n\tcontrol_flags = IWL_PRPH_SCRATCH_RB_SIZE_4K |\n\t\t\tIWL_PRPH_SCRATCH_MTR_MODE |\n\t\t\t(IWL_PRPH_MTR_FORMAT_256B &\n\t\t\t IWL_PRPH_SCRATCH_MTR_FORMAT) |\n\t\t\tIWL_PRPH_SCRATCH_EARLY_DEBUG_EN |\n\t\t\tIWL_PRPH_SCRATCH_EDBG_DEST_DRAM;\n\tprph_sc_ctrl->control.control_flags = cpu_to_le32(control_flags);\n\n\t/* initialize RX default queue */\n\tprph_sc_ctrl->rbd_cfg.free_rbd_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->bd_dma);\n\n\t/* Configure debug, for integration */\n\tif (!iwl_trans_dbg_ini_valid(trans))\n\t\tiwl_pcie_alloc_fw_monitor(trans, 0);\n\tif (trans->dbg.num_blocks) {\n\t\tprph_sc_ctrl->hwm_cfg.hwm_base_addr =\n\t\t\tcpu_to_le64(trans->dbg.fw_mon[0].physical);\n\t\tprph_sc_ctrl->hwm_cfg.hwm_size =\n\t\t\tcpu_to_le32(trans->dbg.fw_mon[0].size);\n\t}\n\n\t/* allocate ucode sections in dram and set addresses */\n\tret = iwl_pcie_init_fw_sec(trans, fw, &prph_scratch->dram);\n\tif (ret)\n\t\tgoto err_free_prph_scratch;\n\n\n\t/* Allocate prph information\n\t * currently we don't assign to the prph info anything, but it would get\n\t * assigned later */\n\tprph_info = dma_alloc_coherent(trans->dev, sizeof(*prph_info),\n\t\t\t\t       &trans_pcie->prph_info_dma_addr,\n\t\t\t\t       GFP_KERNEL);\n\tif (!prph_info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_prph_scratch;\n\t}\n\n\t/* Allocate context info */\n\tctxt_info_gen3 = dma_alloc_coherent(trans->dev,\n\t\t\t\t\t    sizeof(*ctxt_info_gen3),\n\t\t\t\t\t    &trans_pcie->ctxt_info_dma_addr,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!ctxt_info_gen3) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_prph_info;\n\t}\n\n\tctxt_info_gen3->prph_info_base_addr =\n\t\tcpu_to_le64(trans_pcie->prph_info_dma_addr);\n\tctxt_info_gen3->prph_scratch_base_addr =\n\t\tcpu_to_le64(trans_pcie->prph_scratch_dma_addr);\n\tctxt_info_gen3->prph_scratch_size =\n\t\tcpu_to_le32(sizeof(*prph_scratch));\n\tctxt_info_gen3->cr_head_idx_arr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->rb_stts_dma);\n\tctxt_info_gen3->tr_tail_idx_arr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->tr_tail_dma);\n\tctxt_info_gen3->cr_tail_idx_arr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->cr_tail_dma);\n\tctxt_info_gen3->cr_idx_arr_size =\n\t\tcpu_to_le16(IWL_NUM_OF_COMPLETION_RINGS);\n\tctxt_info_gen3->tr_idx_arr_size =\n\t\tcpu_to_le16(IWL_NUM_OF_TRANSFER_RINGS);\n\tctxt_info_gen3->mtr_base_addr =\n\t\tcpu_to_le64(trans_pcie->txq[trans_pcie->cmd_queue]->dma_addr);\n\tctxt_info_gen3->mcr_base_addr =\n\t\tcpu_to_le64(trans_pcie->rxq->used_bd_dma);\n\tctxt_info_gen3->mtr_size =\n\t\tcpu_to_le16(TFD_QUEUE_CB_SIZE(cmdq_size));\n\tctxt_info_gen3->mcr_size =\n\t\tcpu_to_le16(RX_QUEUE_CB_SIZE(MQ_RX_TABLE_SIZE));\n\n\ttrans_pcie->ctxt_info_gen3 = ctxt_info_gen3;\n\ttrans_pcie->prph_info = prph_info;\n\ttrans_pcie->prph_scratch = prph_scratch;\n\n\t/* Allocate IML */\n\timl_img = dma_alloc_coherent(trans->dev, trans->iml_len,\n\t\t\t\t     &trans_pcie->iml_dma_addr, GFP_KERNEL);\n\tif (!iml_img)\n\t\treturn -ENOMEM;\n\n\tmemcpy(iml_img, trans->iml, trans->iml_len);\n\n\tiwl_enable_fw_load_int_ctx_info(trans);\n\n\t/* kick FW self load */\n\tiwl_write64(trans, CSR_CTXT_INFO_ADDR,\n\t\t    trans_pcie->ctxt_info_dma_addr);\n\tiwl_write64(trans, CSR_IML_DATA_ADDR,\n\t\t    trans_pcie->iml_dma_addr);\n\tiwl_write32(trans, CSR_IML_SIZE_ADDR, trans->iml_len);\n\n\tiwl_set_bit(trans, CSR_CTXT_INFO_BOOT_CTRL,\n\t\t    CSR_AUTO_FUNC_BOOT_ENA);\n\tif (trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_AX210)\n\t\tiwl_write_umac_prph(trans, UREG_CPU_INIT_RUN, 1);\n\telse\n\t\tiwl_set_bit(trans, CSR_GP_CNTRL, CSR_AUTO_FUNC_INIT);\n\n\treturn 0;\n\nerr_free_prph_info:\n\tdma_free_coherent(trans->dev,\n\t\t\t  sizeof(*prph_info),\n\t\t\tprph_info,\n\t\t\ttrans_pcie->prph_info_dma_addr);\n\nerr_free_prph_scratch:\n\tdma_free_coherent(trans->dev,\n\t\t\t  sizeof(*prph_scratch),\n\t\t\tprph_scratch,\n\t\t\ttrans_pcie->prph_scratch_dma_addr);\n\treturn ret;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,13 +50,9 @@\n \n \t/* allocate ucode sections in dram and set addresses */\n \tret = iwl_pcie_init_fw_sec(trans, fw, &prph_scratch->dram);\n-\tif (ret) {\n-\t\tdma_free_coherent(trans->dev,\n-\t\t\t\t  sizeof(*prph_scratch),\n-\t\t\t\t  prph_scratch,\n-\t\t\t\t  trans_pcie->prph_scratch_dma_addr);\n-\t\treturn ret;\n-\t}\n+\tif (ret)\n+\t\tgoto err_free_prph_scratch;\n+\n \n \t/* Allocate prph information\n \t * currently we don't assign to the prph info anything, but it would get\n@@ -64,16 +60,20 @@\n \tprph_info = dma_alloc_coherent(trans->dev, sizeof(*prph_info),\n \t\t\t\t       &trans_pcie->prph_info_dma_addr,\n \t\t\t\t       GFP_KERNEL);\n-\tif (!prph_info)\n-\t\treturn -ENOMEM;\n+\tif (!prph_info) {\n+\t\tret = -ENOMEM;\n+\t\tgoto err_free_prph_scratch;\n+\t}\n \n \t/* Allocate context info */\n \tctxt_info_gen3 = dma_alloc_coherent(trans->dev,\n \t\t\t\t\t    sizeof(*ctxt_info_gen3),\n \t\t\t\t\t    &trans_pcie->ctxt_info_dma_addr,\n \t\t\t\t\t    GFP_KERNEL);\n-\tif (!ctxt_info_gen3)\n-\t\treturn -ENOMEM;\n+\tif (!ctxt_info_gen3) {\n+\t\tret = -ENOMEM;\n+\t\tgoto err_free_prph_info;\n+\t}\n \n \tctxt_info_gen3->prph_info_base_addr =\n \t\tcpu_to_le64(trans_pcie->prph_info_dma_addr);\n@@ -129,4 +129,18 @@\n \t\tiwl_set_bit(trans, CSR_GP_CNTRL, CSR_AUTO_FUNC_INIT);\n \n \treturn 0;\n+\n+err_free_prph_info:\n+\tdma_free_coherent(trans->dev,\n+\t\t\t  sizeof(*prph_info),\n+\t\t\tprph_info,\n+\t\t\ttrans_pcie->prph_info_dma_addr);\n+\n+err_free_prph_scratch:\n+\tdma_free_coherent(trans->dev,\n+\t\t\t  sizeof(*prph_scratch),\n+\t\t\tprph_scratch,\n+\t\t\ttrans_pcie->prph_scratch_dma_addr);\n+\treturn ret;\n+\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (ret) {",
                "\t\tdma_free_coherent(trans->dev,",
                "\t\t\t\t  sizeof(*prph_scratch),",
                "\t\t\t\t  prph_scratch,",
                "\t\t\t\t  trans_pcie->prph_scratch_dma_addr);",
                "\t\treturn ret;",
                "\t}",
                "\tif (!prph_info)",
                "\t\treturn -ENOMEM;",
                "\tif (!ctxt_info_gen3)",
                "\t\treturn -ENOMEM;"
            ],
            "added_lines": [
                "\tif (ret)",
                "\t\tgoto err_free_prph_scratch;",
                "",
                "\tif (!prph_info) {",
                "\t\tret = -ENOMEM;",
                "\t\tgoto err_free_prph_scratch;",
                "\t}",
                "\tif (!ctxt_info_gen3) {",
                "\t\tret = -ENOMEM;",
                "\t\tgoto err_free_prph_info;",
                "\t}",
                "",
                "err_free_prph_info:",
                "\tdma_free_coherent(trans->dev,",
                "\t\t\t  sizeof(*prph_info),",
                "\t\t\tprph_info,",
                "\t\t\ttrans_pcie->prph_info_dma_addr);",
                "",
                "err_free_prph_scratch:",
                "\tdma_free_coherent(trans->dev,",
                "\t\t\t  sizeof(*prph_scratch),",
                "\t\t\tprph_scratch,",
                "\t\t\ttrans_pcie->prph_scratch_dma_addr);",
                "\treturn ret;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19060",
        "func_name": "torvalds/linux/adis_update_scan_mode",
        "description": "A memory leak in the adis_update_scan_mode() function in drivers/iio/imu/adis_buffer.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-ab612b1daf41.",
        "git_url": "https://github.com/torvalds/linux/commit/ab612b1daf415b62c58e130cb3d0f30b255a14d0",
        "commit_title": "iio: imu: adis16400: release allocated memory on failure",
        "commit_text": " In adis_update_scan_mode, if allocation for adis->buffer fails, previously allocated adis->xfer needs to be released. ",
        "func_before": "int adis_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tunsigned int scan_count;\n\tunsigned int i, j;\n\t__be16 *tx, *rx;\n\n\tkfree(adis->xfer);\n\tkfree(adis->buffer);\n\n\tif (adis->burst && adis->burst->en)\n\t\treturn adis_update_scan_mode_burst(indio_dev, scan_mask);\n\n\tscan_count = indio_dev->scan_bytes / 2;\n\n\tadis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\n\tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\n\trx = adis->buffer;\n\ttx = rx + scan_count;\n\n\tspi_message_init(&adis->msg);\n\n\tfor (j = 0; j <= scan_count; j++) {\n\t\tadis->xfer[j].bits_per_word = 8;\n\t\tif (j != scan_count)\n\t\t\tadis->xfer[j].cs_change = 1;\n\t\tadis->xfer[j].len = 2;\n\t\tadis->xfer[j].delay_usecs = adis->data->read_delay;\n\t\tif (j < scan_count)\n\t\t\tadis->xfer[j].tx_buf = &tx[j];\n\t\tif (j >= 1)\n\t\t\tadis->xfer[j].rx_buf = &rx[j - 1];\n\t\tspi_message_add_tail(&adis->xfer[j], &adis->msg);\n\t}\n\n\tchan = indio_dev->channels;\n\tfor (i = 0; i < indio_dev->num_channels; i++, chan++) {\n\t\tif (!test_bit(chan->scan_index, scan_mask))\n\t\t\tcontinue;\n\t\tif (chan->scan_type.storagebits == 32)\n\t\t\t*tx++ = cpu_to_be16((chan->address + 2) << 8);\n\t\t*tx++ = cpu_to_be16(chan->address << 8);\n\t}\n\n\treturn 0;\n}",
        "func": "int adis_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tunsigned int scan_count;\n\tunsigned int i, j;\n\t__be16 *tx, *rx;\n\n\tkfree(adis->xfer);\n\tkfree(adis->buffer);\n\n\tif (adis->burst && adis->burst->en)\n\t\treturn adis_update_scan_mode_burst(indio_dev, scan_mask);\n\n\tscan_count = indio_dev->scan_bytes / 2;\n\n\tadis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\n\tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n\tif (!adis->buffer) {\n\t\tkfree(adis->xfer);\n\t\tadis->xfer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\trx = adis->buffer;\n\ttx = rx + scan_count;\n\n\tspi_message_init(&adis->msg);\n\n\tfor (j = 0; j <= scan_count; j++) {\n\t\tadis->xfer[j].bits_per_word = 8;\n\t\tif (j != scan_count)\n\t\t\tadis->xfer[j].cs_change = 1;\n\t\tadis->xfer[j].len = 2;\n\t\tadis->xfer[j].delay_usecs = adis->data->read_delay;\n\t\tif (j < scan_count)\n\t\t\tadis->xfer[j].tx_buf = &tx[j];\n\t\tif (j >= 1)\n\t\t\tadis->xfer[j].rx_buf = &rx[j - 1];\n\t\tspi_message_add_tail(&adis->xfer[j], &adis->msg);\n\t}\n\n\tchan = indio_dev->channels;\n\tfor (i = 0; i < indio_dev->num_channels; i++, chan++) {\n\t\tif (!test_bit(chan->scan_index, scan_mask))\n\t\t\tcontinue;\n\t\tif (chan->scan_type.storagebits == 32)\n\t\t\t*tx++ = cpu_to_be16((chan->address + 2) << 8);\n\t\t*tx++ = cpu_to_be16(chan->address << 8);\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,8 +20,11 @@\n \t\treturn -ENOMEM;\n \n \tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n-\tif (!adis->buffer)\n+\tif (!adis->buffer) {\n+\t\tkfree(adis->xfer);\n+\t\tadis->xfer = NULL;\n \t\treturn -ENOMEM;\n+\t}\n \n \trx = adis->buffer;\n \ttx = rx + scan_count;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!adis->buffer)"
            ],
            "added_lines": [
                "\tif (!adis->buffer) {",
                "\t\tkfree(adis->xfer);",
                "\t\tadis->xfer = NULL;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19061",
        "func_name": "torvalds/linux/adis_update_scan_mode_burst",
        "description": "A memory leak in the adis_update_scan_mode_burst() function in drivers/iio/imu/adis_buffer.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-9c0530e898f3.",
        "git_url": "https://github.com/torvalds/linux/commit/9c0530e898f384c5d279bfcebd8bb17af1105873",
        "commit_title": "iio: imu: adis16400: fix memory leak",
        "commit_text": " In adis_update_scan_mode_burst, if adis->buffer allocation fails release the adis->xfer. ",
        "func_before": "static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length;\n\tu8 *tx;\n\n\t/* All but the timestamp channel */\n\tburst_length = (indio_dev->num_channels - 1) * sizeof(u16);\n\tburst_length += adis->burst->extra_len;\n\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\n\tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\n\ttx = adis->buffer + burst_length;\n\ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);\n\ttx[1] = 0;\n\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\n\treturn 0;\n}",
        "func": "static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length;\n\tu8 *tx;\n\n\t/* All but the timestamp channel */\n\tburst_length = (indio_dev->num_channels - 1) * sizeof(u16);\n\tburst_length += adis->burst->extra_len;\n\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\n\tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer) {\n\t\tkfree(adis->xfer);\n\t\tadis->xfer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\ttx = adis->buffer + burst_length;\n\ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);\n\ttx[1] = 0;\n\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,8 +14,11 @@\n \t\treturn -ENOMEM;\n \n \tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n-\tif (!adis->buffer)\n+\tif (!adis->buffer) {\n+\t\tkfree(adis->xfer);\n+\t\tadis->xfer = NULL;\n \t\treturn -ENOMEM;\n+\t}\n \n \ttx = adis->buffer + burst_length;\n \ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!adis->buffer)"
            ],
            "added_lines": [
                "\tif (!adis->buffer) {",
                "\t\tkfree(adis->xfer);",
                "\t\tadis->xfer = NULL;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19062",
        "func_name": "torvalds/linux/crypto_report",
        "description": "A memory leak in the crypto_report() function in crypto/crypto_user_base.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering crypto_report_alg() failures, aka CID-ffdde5932042.",
        "git_url": "https://github.com/torvalds/linux/commit/ffdde5932042600c6807d46c1550b28b0db6a3bc",
        "commit_title": "crypto: user - fix memory leak in crypto_report",
        "commit_text": " In crypto_report, a new skb is created via nlmsg_new(). This skb should be released if crypto_report_alg() fails.  Cc: <stable@vger.kernel.org>",
        "func_before": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}",
        "func": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,8 +30,10 @@\n drop_alg:\n \tcrypto_mod_put(alg);\n \n-\tif (err)\n+\tif (err) {\n+\t\tkfree_skb(skb);\n \t\treturn err;\n+\t}\n \n \treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (err)"
            ],
            "added_lines": [
                "\tif (err) {",
                "\t\tkfree_skb(skb);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19063",
        "func_name": "torvalds/linux/rtl_usb_probe",
        "description": "Two memory leaks in the rtl_usb_probe() function in drivers/net/wireless/realtek/rtlwifi/usb.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption), aka CID-3f9361695113.",
        "git_url": "https://github.com/torvalds/linux/commit/3f93616951138a598d930dcaec40f2bfd9ce43bb",
        "commit_title": "rtlwifi: prevent memory leak in rtl_usb_probe",
        "commit_text": " In rtl_usb_probe if allocation for usb_data fails the allocated hw should be released. In addition the allocated rtlpriv->usb_data should be released on error handling path. ",
        "func_before": "int rtl_usb_probe(struct usb_interface *intf,\n\t\t  const struct usb_device_id *id,\n\t\t  struct rtl_hal_cfg *rtl_hal_cfg)\n{\n\tint err;\n\tstruct ieee80211_hw *hw = NULL;\n\tstruct rtl_priv *rtlpriv = NULL;\n\tstruct usb_device\t*udev;\n\tstruct rtl_usb_priv *usb_priv;\n\n\thw = ieee80211_alloc_hw(sizeof(struct rtl_priv) +\n\t\t\t\tsizeof(struct rtl_usb_priv), &rtl_ops);\n\tif (!hw) {\n\t\tWARN_ONCE(true, \"rtl_usb: ieee80211 alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trtlpriv = hw->priv;\n\trtlpriv->hw = hw;\n\trtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (!rtlpriv->usb_data)\n\t\treturn -ENOMEM;\n\n\t/* this spin lock must be initialized early */\n\tspin_lock_init(&rtlpriv->locks.usb_lock);\n\tINIT_WORK(&rtlpriv->works.fill_h2c_cmd,\n\t\t  rtl_fill_h2c_cmd_work_callback);\n\tINIT_WORK(&rtlpriv->works.lps_change_work,\n\t\t  rtl_lps_change_work_callback);\n\n\trtlpriv->usb_data_index = 0;\n\tinit_completion(&rtlpriv->firmware_loading_complete);\n\tSET_IEEE80211_DEV(hw, &intf->dev);\n\tudev = interface_to_usbdev(intf);\n\tusb_get_dev(udev);\n\tusb_priv = rtl_usbpriv(hw);\n\tmemset(usb_priv, 0, sizeof(*usb_priv));\n\tusb_priv->dev.intf = intf;\n\tusb_priv->dev.udev = udev;\n\tusb_set_intfdata(intf, hw);\n\t/* init cfg & intf_ops */\n\trtlpriv->rtlhal.interface = INTF_USB;\n\trtlpriv->cfg = rtl_hal_cfg;\n\trtlpriv->intf_ops = &rtl_usb_ops;\n\t/* Init IO handler */\n\t_rtl_usb_io_handler_init(&udev->dev, hw);\n\trtlpriv->cfg->ops->read_chip_version(hw);\n\t/*like read eeprom and so on */\n\trtlpriv->cfg->ops->read_eeprom_info(hw);\n\terr = _rtl_usb_init(hw);\n\tif (err)\n\t\tgoto error_out2;\n\trtl_usb_init_sw(hw);\n\t/* Init mac80211 sw */\n\terr = rtl_init_core(hw);\n\tif (err) {\n\t\tpr_err(\"Can't allocate sw for mac80211\\n\");\n\t\tgoto error_out2;\n\t}\n\tif (rtlpriv->cfg->ops->init_sw_vars(hw)) {\n\t\tpr_err(\"Can't init_sw_vars\\n\");\n\t\tgoto error_out;\n\t}\n\trtlpriv->cfg->ops->init_sw_leds(hw);\n\n\terr = ieee80211_register_hw(hw);\n\tif (err) {\n\t\tpr_err(\"Can't register mac80211 hw.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto error_out;\n\t}\n\trtlpriv->mac80211.mac80211_registered = 1;\n\n\tset_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\treturn 0;\n\nerror_out:\n\trtl_deinit_core(hw);\nerror_out2:\n\t_rtl_usb_io_handler_release(hw);\n\tusb_put_dev(udev);\n\tcomplete(&rtlpriv->firmware_loading_complete);\n\treturn -ENODEV;\n}",
        "func": "int rtl_usb_probe(struct usb_interface *intf,\n\t\t  const struct usb_device_id *id,\n\t\t  struct rtl_hal_cfg *rtl_hal_cfg)\n{\n\tint err;\n\tstruct ieee80211_hw *hw = NULL;\n\tstruct rtl_priv *rtlpriv = NULL;\n\tstruct usb_device\t*udev;\n\tstruct rtl_usb_priv *usb_priv;\n\n\thw = ieee80211_alloc_hw(sizeof(struct rtl_priv) +\n\t\t\t\tsizeof(struct rtl_usb_priv), &rtl_ops);\n\tif (!hw) {\n\t\tWARN_ONCE(true, \"rtl_usb: ieee80211 alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trtlpriv = hw->priv;\n\trtlpriv->hw = hw;\n\trtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (!rtlpriv->usb_data) {\n\t\tieee80211_free_hw(hw);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* this spin lock must be initialized early */\n\tspin_lock_init(&rtlpriv->locks.usb_lock);\n\tINIT_WORK(&rtlpriv->works.fill_h2c_cmd,\n\t\t  rtl_fill_h2c_cmd_work_callback);\n\tINIT_WORK(&rtlpriv->works.lps_change_work,\n\t\t  rtl_lps_change_work_callback);\n\n\trtlpriv->usb_data_index = 0;\n\tinit_completion(&rtlpriv->firmware_loading_complete);\n\tSET_IEEE80211_DEV(hw, &intf->dev);\n\tudev = interface_to_usbdev(intf);\n\tusb_get_dev(udev);\n\tusb_priv = rtl_usbpriv(hw);\n\tmemset(usb_priv, 0, sizeof(*usb_priv));\n\tusb_priv->dev.intf = intf;\n\tusb_priv->dev.udev = udev;\n\tusb_set_intfdata(intf, hw);\n\t/* init cfg & intf_ops */\n\trtlpriv->rtlhal.interface = INTF_USB;\n\trtlpriv->cfg = rtl_hal_cfg;\n\trtlpriv->intf_ops = &rtl_usb_ops;\n\t/* Init IO handler */\n\t_rtl_usb_io_handler_init(&udev->dev, hw);\n\trtlpriv->cfg->ops->read_chip_version(hw);\n\t/*like read eeprom and so on */\n\trtlpriv->cfg->ops->read_eeprom_info(hw);\n\terr = _rtl_usb_init(hw);\n\tif (err)\n\t\tgoto error_out2;\n\trtl_usb_init_sw(hw);\n\t/* Init mac80211 sw */\n\terr = rtl_init_core(hw);\n\tif (err) {\n\t\tpr_err(\"Can't allocate sw for mac80211\\n\");\n\t\tgoto error_out2;\n\t}\n\tif (rtlpriv->cfg->ops->init_sw_vars(hw)) {\n\t\tpr_err(\"Can't init_sw_vars\\n\");\n\t\tgoto error_out;\n\t}\n\trtlpriv->cfg->ops->init_sw_leds(hw);\n\n\terr = ieee80211_register_hw(hw);\n\tif (err) {\n\t\tpr_err(\"Can't register mac80211 hw.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto error_out;\n\t}\n\trtlpriv->mac80211.mac80211_registered = 1;\n\n\tset_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\treturn 0;\n\nerror_out:\n\trtl_deinit_core(hw);\nerror_out2:\n\t_rtl_usb_io_handler_release(hw);\n\tusb_put_dev(udev);\n\tcomplete(&rtlpriv->firmware_loading_complete);\n\tkfree(rtlpriv->usb_data);\n\treturn -ENODEV;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,8 +18,10 @@\n \trtlpriv->hw = hw;\n \trtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),\n \t\t\t\t    GFP_KERNEL);\n-\tif (!rtlpriv->usb_data)\n+\tif (!rtlpriv->usb_data) {\n+\t\tieee80211_free_hw(hw);\n \t\treturn -ENOMEM;\n+\t}\n \n \t/* this spin lock must be initialized early */\n \tspin_lock_init(&rtlpriv->locks.usb_lock);\n@@ -80,5 +82,6 @@\n \t_rtl_usb_io_handler_release(hw);\n \tusb_put_dev(udev);\n \tcomplete(&rtlpriv->firmware_loading_complete);\n+\tkfree(rtlpriv->usb_data);\n \treturn -ENODEV;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!rtlpriv->usb_data)"
            ],
            "added_lines": [
                "\tif (!rtlpriv->usb_data) {",
                "\t\tieee80211_free_hw(hw);",
                "\t}",
                "\tkfree(rtlpriv->usb_data);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19064",
        "func_name": "torvalds/linux/fsl_lpspi_probe",
        "description": "A memory leak in the fsl_lpspi_probe() function in drivers/spi/spi-fsl-lpspi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering pm_runtime_get_sync() failures, aka CID-057b8945f78f. NOTE: third parties dispute the relevance of this because an attacker cannot realistically control these failures at probe time",
        "git_url": "https://github.com/torvalds/linux/commit/057b8945f78f76d0b04eeb5c27cd9225e5e7ad86",
        "commit_title": "spi: lpspi: fix memory leak in fsl_lpspi_probe",
        "commit_text": " In fsl_lpspi_probe an SPI controller is allocated either via spi_alloc_slave or spi_alloc_master. In all but one error cases this controller is put by going to error handling code. This commit fixes the case when pm_runtime_get_sync fails and it should go to the error handling path.  Link: https://lore.kernel.org/r/20190930034602.1467-1-navid.emamdoost@gmail.com",
        "func_before": "static int fsl_lpspi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tstruct spi_controller *controller;\n\tstruct spi_imx_master *lpspi_platform_info =\n\t\tdev_get_platdata(&pdev->dev);\n\tstruct resource *res;\n\tint i, ret, irq;\n\tu32 temp;\n\tbool is_slave;\n\n\tis_slave = of_property_read_bool((&pdev->dev)->of_node, \"spi-slave\");\n\tif (is_slave)\n\t\tcontroller = spi_alloc_slave(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\telse\n\t\tcontroller = spi_alloc_master(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, controller);\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\tfsl_lpspi->dev = &pdev->dev;\n\tfsl_lpspi->is_slave = is_slave;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\tfor (i = 0; i < controller->num_chipselect; i++) {\n\t\t\tint cs_gpio = of_get_named_gpio(np, \"cs-gpios\", i);\n\n\t\t\tif (!gpio_is_valid(cs_gpio) && lpspi_platform_info)\n\t\t\t\tcs_gpio = lpspi_platform_info->chipselect[i];\n\n\t\t\tfsl_lpspi->chipselect[i] = cs_gpio;\n\t\t\tif (!gpio_is_valid(cs_gpio))\n\t\t\t\tcontinue;\n\n\t\t\tret = devm_gpio_request(&pdev->dev,\n\t\t\t\t\t\tfsl_lpspi->chipselect[i],\n\t\t\t\t\t\tDRIVER_NAME);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev, \"can't get cs gpios\\n\");\n\t\t\t\tgoto out_controller_put;\n\t\t\t}\n\t\t}\n\t\tcontroller->cs_gpios = fsl_lpspi->chipselect;\n\t\tcontroller->prepare_message = fsl_lpspi_prepare_message;\n\t}\n\n\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);\n\tcontroller->transfer_one = fsl_lpspi_transfer_one;\n\tcontroller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;\n\tcontroller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tcontroller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;\n\tcontroller->dev.of_node = pdev->dev.of_node;\n\tcontroller->bus_num = pdev->id;\n\tcontroller->slave_abort = fsl_lpspi_slave_abort;\n\n\tinit_completion(&fsl_lpspi->xfer_done);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(fsl_lpspi->base)) {\n\t\tret = PTR_ERR(fsl_lpspi->base);\n\t\tgoto out_controller_put;\n\t}\n\tfsl_lpspi->base_phys = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_controller_put;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,\n\t\t\t       dev_name(&pdev->dev), fsl_lpspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq%d: %d\\n\", irq, ret);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(fsl_lpspi->clk_per)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_per);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(fsl_lpspi->clk_ipg)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_ipg);\n\t\tgoto out_controller_put;\n\t}\n\n\t/* enable the clock */\n\tret = fsl_lpspi_init_rpm(fsl_lpspi);\n\tif (ret)\n\t\tgoto out_controller_put;\n\n\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_PARAM);\n\tfsl_lpspi->txfifosize = 1 << (temp & 0x0f);\n\tfsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);\n\n\tret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto out_controller_put;\n\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"dma setup error %d, use pio\\n\", ret);\n\n\tret = devm_spi_register_controller(&pdev->dev, controller);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller error.\\n\");\n\t\tgoto out_controller_put;\n\t}\n\n\treturn 0;\n\nout_controller_put:\n\tspi_controller_put(controller);\n\n\treturn ret;\n}",
        "func": "static int fsl_lpspi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_lpspi_data *fsl_lpspi;\n\tstruct spi_controller *controller;\n\tstruct spi_imx_master *lpspi_platform_info =\n\t\tdev_get_platdata(&pdev->dev);\n\tstruct resource *res;\n\tint i, ret, irq;\n\tu32 temp;\n\tbool is_slave;\n\n\tis_slave = of_property_read_bool((&pdev->dev)->of_node, \"spi-slave\");\n\tif (is_slave)\n\t\tcontroller = spi_alloc_slave(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\telse\n\t\tcontroller = spi_alloc_master(&pdev->dev,\n\t\t\t\t\tsizeof(struct fsl_lpspi_data));\n\n\tif (!controller)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, controller);\n\n\tfsl_lpspi = spi_controller_get_devdata(controller);\n\tfsl_lpspi->dev = &pdev->dev;\n\tfsl_lpspi->is_slave = is_slave;\n\n\tif (!fsl_lpspi->is_slave) {\n\t\tfor (i = 0; i < controller->num_chipselect; i++) {\n\t\t\tint cs_gpio = of_get_named_gpio(np, \"cs-gpios\", i);\n\n\t\t\tif (!gpio_is_valid(cs_gpio) && lpspi_platform_info)\n\t\t\t\tcs_gpio = lpspi_platform_info->chipselect[i];\n\n\t\t\tfsl_lpspi->chipselect[i] = cs_gpio;\n\t\t\tif (!gpio_is_valid(cs_gpio))\n\t\t\t\tcontinue;\n\n\t\t\tret = devm_gpio_request(&pdev->dev,\n\t\t\t\t\t\tfsl_lpspi->chipselect[i],\n\t\t\t\t\t\tDRIVER_NAME);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev, \"can't get cs gpios\\n\");\n\t\t\t\tgoto out_controller_put;\n\t\t\t}\n\t\t}\n\t\tcontroller->cs_gpios = fsl_lpspi->chipselect;\n\t\tcontroller->prepare_message = fsl_lpspi_prepare_message;\n\t}\n\n\tcontroller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);\n\tcontroller->transfer_one = fsl_lpspi_transfer_one;\n\tcontroller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;\n\tcontroller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;\n\tcontroller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n\tcontroller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;\n\tcontroller->dev.of_node = pdev->dev.of_node;\n\tcontroller->bus_num = pdev->id;\n\tcontroller->slave_abort = fsl_lpspi_slave_abort;\n\n\tinit_completion(&fsl_lpspi->xfer_done);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(fsl_lpspi->base)) {\n\t\tret = PTR_ERR(fsl_lpspi->base);\n\t\tgoto out_controller_put;\n\t}\n\tfsl_lpspi->base_phys = res->start;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out_controller_put;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,\n\t\t\t       dev_name(&pdev->dev), fsl_lpspi);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't get irq%d: %d\\n\", irq, ret);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(fsl_lpspi->clk_per)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_per);\n\t\tgoto out_controller_put;\n\t}\n\n\tfsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(fsl_lpspi->clk_ipg)) {\n\t\tret = PTR_ERR(fsl_lpspi->clk_ipg);\n\t\tgoto out_controller_put;\n\t}\n\n\t/* enable the clock */\n\tret = fsl_lpspi_init_rpm(fsl_lpspi);\n\tif (ret)\n\t\tgoto out_controller_put;\n\n\tret = pm_runtime_get_sync(fsl_lpspi->dev);\n\tif (ret < 0) {\n\t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n\t\tgoto out_controller_put;\n\t}\n\n\ttemp = readl(fsl_lpspi->base + IMX7ULP_PARAM);\n\tfsl_lpspi->txfifosize = 1 << (temp & 0x0f);\n\tfsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);\n\n\tret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto out_controller_put;\n\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"dma setup error %d, use pio\\n\", ret);\n\n\tret = devm_spi_register_controller(&pdev->dev, controller);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"spi_register_controller error.\\n\");\n\t\tgoto out_controller_put;\n\t}\n\n\treturn 0;\n\nout_controller_put:\n\tspi_controller_put(controller);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -103,7 +103,7 @@\n \tret = pm_runtime_get_sync(fsl_lpspi->dev);\n \tif (ret < 0) {\n \t\tdev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");\n-\t\treturn ret;\n+\t\tgoto out_controller_put;\n \t}\n \n \ttemp = readl(fsl_lpspi->base + IMX7ULP_PARAM);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn ret;"
            ],
            "added_lines": [
                "\t\tgoto out_controller_put;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19065",
        "func_name": "torvalds/linux/sdma_init",
        "description": "A memory leak in the sdma_init() function in drivers/infiniband/hw/hfi1/sdma.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering rhashtable_init() failures, aka CID-34b3be18a04e. NOTE: This has been disputed as not a vulnerability because \"rhashtable_init() can only fail if it is passed invalid values in the second parameter's struct, but when invoked from sdma_init() that is a pointer to a static const struct, so an attacker could only trigger failure if they could corrupt kernel memory (in which case a small memory leak is not a significant problem).",
        "git_url": "https://github.com/torvalds/linux/commit/34b3be18a04ecdc610aae4c48e5d1b799d8689f6",
        "commit_title": "RDMA/hfi1: Prevent memory leak in sdma_init",
        "commit_text": " In sdma_init if rhashtable_init fails the allocated memory for tmp_sdma_rht should be released.  Link: https://lore.kernel.org/r/20190925144543.10141-1-navid.emamdoost@gmail.com",
        "func_before": "int sdma_init(struct hfi1_devdata *dd, u8 port)\n{\n\tunsigned this_idx;\n\tstruct sdma_engine *sde;\n\tstruct rhashtable *tmp_sdma_rht;\n\tu16 descq_cnt;\n\tvoid *curr_head;\n\tstruct hfi1_pportdata *ppd = dd->pport + port;\n\tu32 per_sdma_credits;\n\tuint idle_cnt = sdma_idle_cnt;\n\tsize_t num_engines = chip_sdma_engines(dd);\n\tint ret = -ENOMEM;\n\n\tif (!HFI1_CAP_IS_KSET(SDMA)) {\n\t\tHFI1_CAP_CLEAR(SDMA_AHG);\n\t\treturn 0;\n\t}\n\tif (mod_num_sdma &&\n\t    /* can't exceed chip support */\n\t    mod_num_sdma <= chip_sdma_engines(dd) &&\n\t    /* count must be >= vls */\n\t    mod_num_sdma >= num_vls)\n\t\tnum_engines = mod_num_sdma;\n\n\tdd_dev_info(dd, \"SDMA mod_num_sdma: %u\\n\", mod_num_sdma);\n\tdd_dev_info(dd, \"SDMA chip_sdma_engines: %u\\n\", chip_sdma_engines(dd));\n\tdd_dev_info(dd, \"SDMA chip_sdma_mem_size: %u\\n\",\n\t\t    chip_sdma_mem_size(dd));\n\n\tper_sdma_credits =\n\t\tchip_sdma_mem_size(dd) / (num_engines * SDMA_BLOCK_SIZE);\n\n\t/* set up freeze waitqueue */\n\tinit_waitqueue_head(&dd->sdma_unfreeze_wq);\n\tatomic_set(&dd->sdma_unfreeze_count, 0);\n\n\tdescq_cnt = sdma_get_descq_cnt();\n\tdd_dev_info(dd, \"SDMA engines %zu descq_cnt %u\\n\",\n\t\t    num_engines, descq_cnt);\n\n\t/* alloc memory for array of send engines */\n\tdd->per_sdma = kcalloc_node(num_engines, sizeof(*dd->per_sdma),\n\t\t\t\t    GFP_KERNEL, dd->node);\n\tif (!dd->per_sdma)\n\t\treturn ret;\n\n\tidle_cnt = ns_to_cclock(dd, idle_cnt);\n\tif (idle_cnt)\n\t\tdd->default_desc1 =\n\t\t\tSDMA_DESC1_HEAD_TO_HOST_FLAG;\n\telse\n\t\tdd->default_desc1 =\n\t\t\tSDMA_DESC1_INT_REQ_FLAG;\n\n\tif (!sdma_desct_intr)\n\t\tsdma_desct_intr = SDMA_DESC_INTR;\n\n\t/* Allocate memory for SendDMA descriptor FIFOs */\n\tfor (this_idx = 0; this_idx < num_engines; ++this_idx) {\n\t\tsde = &dd->per_sdma[this_idx];\n\t\tsde->dd = dd;\n\t\tsde->ppd = ppd;\n\t\tsde->this_idx = this_idx;\n\t\tsde->descq_cnt = descq_cnt;\n\t\tsde->desc_avail = sdma_descq_freecnt(sde);\n\t\tsde->sdma_shift = ilog2(descq_cnt);\n\t\tsde->sdma_mask = (1 << sde->sdma_shift) - 1;\n\n\t\t/* Create a mask specifically for each interrupt source */\n\t\tsde->int_mask = (u64)1 << (0 * TXE_NUM_SDMA_ENGINES +\n\t\t\t\t\t   this_idx);\n\t\tsde->progress_mask = (u64)1 << (1 * TXE_NUM_SDMA_ENGINES +\n\t\t\t\t\t\tthis_idx);\n\t\tsde->idle_mask = (u64)1 << (2 * TXE_NUM_SDMA_ENGINES +\n\t\t\t\t\t    this_idx);\n\t\t/* Create a combined mask to cover all 3 interrupt sources */\n\t\tsde->imask = sde->int_mask | sde->progress_mask |\n\t\t\t     sde->idle_mask;\n\n\t\tspin_lock_init(&sde->tail_lock);\n\t\tseqlock_init(&sde->head_lock);\n\t\tspin_lock_init(&sde->senddmactrl_lock);\n\t\tspin_lock_init(&sde->flushlist_lock);\n\t\tseqlock_init(&sde->waitlock);\n\t\t/* insure there is always a zero bit */\n\t\tsde->ahg_bits = 0xfffffffe00000000ULL;\n\n\t\tsdma_set_state(sde, sdma_state_s00_hw_down);\n\n\t\t/* set up reference counting */\n\t\tkref_init(&sde->state.kref);\n\t\tinit_completion(&sde->state.comp);\n\n\t\tINIT_LIST_HEAD(&sde->flushlist);\n\t\tINIT_LIST_HEAD(&sde->dmawait);\n\n\t\tsde->tail_csr =\n\t\t\tget_kctxt_csr_addr(dd, this_idx, SD(TAIL));\n\n\t\ttasklet_init(&sde->sdma_hw_clean_up_task, sdma_hw_clean_up_task,\n\t\t\t     (unsigned long)sde);\n\n\t\ttasklet_init(&sde->sdma_sw_clean_up_task, sdma_sw_clean_up_task,\n\t\t\t     (unsigned long)sde);\n\t\tINIT_WORK(&sde->err_halt_worker, sdma_err_halt_wait);\n\t\tINIT_WORK(&sde->flush_worker, sdma_field_flush);\n\n\t\tsde->progress_check_head = 0;\n\n\t\ttimer_setup(&sde->err_progress_check_timer,\n\t\t\t    sdma_err_progress_check, 0);\n\n\t\tsde->descq = dma_alloc_coherent(&dd->pcidev->dev,\n\t\t\t\t\t\tdescq_cnt * sizeof(u64[2]),\n\t\t\t\t\t\t&sde->descq_phys, GFP_KERNEL);\n\t\tif (!sde->descq)\n\t\t\tgoto bail;\n\t\tsde->tx_ring =\n\t\t\tkvzalloc_node(array_size(descq_cnt,\n\t\t\t\t\t\t sizeof(struct sdma_txreq *)),\n\t\t\t\t      GFP_KERNEL, dd->node);\n\t\tif (!sde->tx_ring)\n\t\t\tgoto bail;\n\t}\n\n\tdd->sdma_heads_size = L1_CACHE_BYTES * num_engines;\n\t/* Allocate memory for DMA of head registers to memory */\n\tdd->sdma_heads_dma = dma_alloc_coherent(&dd->pcidev->dev,\n\t\t\t\t\t\tdd->sdma_heads_size,\n\t\t\t\t\t\t&dd->sdma_heads_phys,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!dd->sdma_heads_dma) {\n\t\tdd_dev_err(dd, \"failed to allocate SendDMA head memory\\n\");\n\t\tgoto bail;\n\t}\n\n\t/* Allocate memory for pad */\n\tdd->sdma_pad_dma = dma_alloc_coherent(&dd->pcidev->dev, sizeof(u32),\n\t\t\t\t\t      &dd->sdma_pad_phys, GFP_KERNEL);\n\tif (!dd->sdma_pad_dma) {\n\t\tdd_dev_err(dd, \"failed to allocate SendDMA pad memory\\n\");\n\t\tgoto bail;\n\t}\n\n\t/* assign each engine to different cacheline and init registers */\n\tcurr_head = (void *)dd->sdma_heads_dma;\n\tfor (this_idx = 0; this_idx < num_engines; ++this_idx) {\n\t\tunsigned long phys_offset;\n\n\t\tsde = &dd->per_sdma[this_idx];\n\n\t\tsde->head_dma = curr_head;\n\t\tcurr_head += L1_CACHE_BYTES;\n\t\tphys_offset = (unsigned long)sde->head_dma -\n\t\t\t      (unsigned long)dd->sdma_heads_dma;\n\t\tsde->head_phys = dd->sdma_heads_phys + phys_offset;\n\t\tinit_sdma_regs(sde, per_sdma_credits, idle_cnt);\n\t}\n\tdd->flags |= HFI1_HAS_SEND_DMA;\n\tdd->flags |= idle_cnt ? HFI1_HAS_SDMA_TIMEOUT : 0;\n\tdd->num_sdma = num_engines;\n\tret = sdma_map_init(dd, port, ppd->vls_operational, NULL);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\ttmp_sdma_rht = kzalloc(sizeof(*tmp_sdma_rht), GFP_KERNEL);\n\tif (!tmp_sdma_rht) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tret = rhashtable_init(tmp_sdma_rht, &sdma_rht_params);\n\tif (ret < 0)\n\t\tgoto bail;\n\tdd->sdma_rht = tmp_sdma_rht;\n\n\tdd_dev_info(dd, \"SDMA num_sdma: %u\\n\", dd->num_sdma);\n\treturn 0;\n\nbail:\n\tsdma_clean(dd, num_engines);\n\treturn ret;\n}",
        "func": "int sdma_init(struct hfi1_devdata *dd, u8 port)\n{\n\tunsigned this_idx;\n\tstruct sdma_engine *sde;\n\tstruct rhashtable *tmp_sdma_rht;\n\tu16 descq_cnt;\n\tvoid *curr_head;\n\tstruct hfi1_pportdata *ppd = dd->pport + port;\n\tu32 per_sdma_credits;\n\tuint idle_cnt = sdma_idle_cnt;\n\tsize_t num_engines = chip_sdma_engines(dd);\n\tint ret = -ENOMEM;\n\n\tif (!HFI1_CAP_IS_KSET(SDMA)) {\n\t\tHFI1_CAP_CLEAR(SDMA_AHG);\n\t\treturn 0;\n\t}\n\tif (mod_num_sdma &&\n\t    /* can't exceed chip support */\n\t    mod_num_sdma <= chip_sdma_engines(dd) &&\n\t    /* count must be >= vls */\n\t    mod_num_sdma >= num_vls)\n\t\tnum_engines = mod_num_sdma;\n\n\tdd_dev_info(dd, \"SDMA mod_num_sdma: %u\\n\", mod_num_sdma);\n\tdd_dev_info(dd, \"SDMA chip_sdma_engines: %u\\n\", chip_sdma_engines(dd));\n\tdd_dev_info(dd, \"SDMA chip_sdma_mem_size: %u\\n\",\n\t\t    chip_sdma_mem_size(dd));\n\n\tper_sdma_credits =\n\t\tchip_sdma_mem_size(dd) / (num_engines * SDMA_BLOCK_SIZE);\n\n\t/* set up freeze waitqueue */\n\tinit_waitqueue_head(&dd->sdma_unfreeze_wq);\n\tatomic_set(&dd->sdma_unfreeze_count, 0);\n\n\tdescq_cnt = sdma_get_descq_cnt();\n\tdd_dev_info(dd, \"SDMA engines %zu descq_cnt %u\\n\",\n\t\t    num_engines, descq_cnt);\n\n\t/* alloc memory for array of send engines */\n\tdd->per_sdma = kcalloc_node(num_engines, sizeof(*dd->per_sdma),\n\t\t\t\t    GFP_KERNEL, dd->node);\n\tif (!dd->per_sdma)\n\t\treturn ret;\n\n\tidle_cnt = ns_to_cclock(dd, idle_cnt);\n\tif (idle_cnt)\n\t\tdd->default_desc1 =\n\t\t\tSDMA_DESC1_HEAD_TO_HOST_FLAG;\n\telse\n\t\tdd->default_desc1 =\n\t\t\tSDMA_DESC1_INT_REQ_FLAG;\n\n\tif (!sdma_desct_intr)\n\t\tsdma_desct_intr = SDMA_DESC_INTR;\n\n\t/* Allocate memory for SendDMA descriptor FIFOs */\n\tfor (this_idx = 0; this_idx < num_engines; ++this_idx) {\n\t\tsde = &dd->per_sdma[this_idx];\n\t\tsde->dd = dd;\n\t\tsde->ppd = ppd;\n\t\tsde->this_idx = this_idx;\n\t\tsde->descq_cnt = descq_cnt;\n\t\tsde->desc_avail = sdma_descq_freecnt(sde);\n\t\tsde->sdma_shift = ilog2(descq_cnt);\n\t\tsde->sdma_mask = (1 << sde->sdma_shift) - 1;\n\n\t\t/* Create a mask specifically for each interrupt source */\n\t\tsde->int_mask = (u64)1 << (0 * TXE_NUM_SDMA_ENGINES +\n\t\t\t\t\t   this_idx);\n\t\tsde->progress_mask = (u64)1 << (1 * TXE_NUM_SDMA_ENGINES +\n\t\t\t\t\t\tthis_idx);\n\t\tsde->idle_mask = (u64)1 << (2 * TXE_NUM_SDMA_ENGINES +\n\t\t\t\t\t    this_idx);\n\t\t/* Create a combined mask to cover all 3 interrupt sources */\n\t\tsde->imask = sde->int_mask | sde->progress_mask |\n\t\t\t     sde->idle_mask;\n\n\t\tspin_lock_init(&sde->tail_lock);\n\t\tseqlock_init(&sde->head_lock);\n\t\tspin_lock_init(&sde->senddmactrl_lock);\n\t\tspin_lock_init(&sde->flushlist_lock);\n\t\tseqlock_init(&sde->waitlock);\n\t\t/* insure there is always a zero bit */\n\t\tsde->ahg_bits = 0xfffffffe00000000ULL;\n\n\t\tsdma_set_state(sde, sdma_state_s00_hw_down);\n\n\t\t/* set up reference counting */\n\t\tkref_init(&sde->state.kref);\n\t\tinit_completion(&sde->state.comp);\n\n\t\tINIT_LIST_HEAD(&sde->flushlist);\n\t\tINIT_LIST_HEAD(&sde->dmawait);\n\n\t\tsde->tail_csr =\n\t\t\tget_kctxt_csr_addr(dd, this_idx, SD(TAIL));\n\n\t\ttasklet_init(&sde->sdma_hw_clean_up_task, sdma_hw_clean_up_task,\n\t\t\t     (unsigned long)sde);\n\n\t\ttasklet_init(&sde->sdma_sw_clean_up_task, sdma_sw_clean_up_task,\n\t\t\t     (unsigned long)sde);\n\t\tINIT_WORK(&sde->err_halt_worker, sdma_err_halt_wait);\n\t\tINIT_WORK(&sde->flush_worker, sdma_field_flush);\n\n\t\tsde->progress_check_head = 0;\n\n\t\ttimer_setup(&sde->err_progress_check_timer,\n\t\t\t    sdma_err_progress_check, 0);\n\n\t\tsde->descq = dma_alloc_coherent(&dd->pcidev->dev,\n\t\t\t\t\t\tdescq_cnt * sizeof(u64[2]),\n\t\t\t\t\t\t&sde->descq_phys, GFP_KERNEL);\n\t\tif (!sde->descq)\n\t\t\tgoto bail;\n\t\tsde->tx_ring =\n\t\t\tkvzalloc_node(array_size(descq_cnt,\n\t\t\t\t\t\t sizeof(struct sdma_txreq *)),\n\t\t\t\t      GFP_KERNEL, dd->node);\n\t\tif (!sde->tx_ring)\n\t\t\tgoto bail;\n\t}\n\n\tdd->sdma_heads_size = L1_CACHE_BYTES * num_engines;\n\t/* Allocate memory for DMA of head registers to memory */\n\tdd->sdma_heads_dma = dma_alloc_coherent(&dd->pcidev->dev,\n\t\t\t\t\t\tdd->sdma_heads_size,\n\t\t\t\t\t\t&dd->sdma_heads_phys,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!dd->sdma_heads_dma) {\n\t\tdd_dev_err(dd, \"failed to allocate SendDMA head memory\\n\");\n\t\tgoto bail;\n\t}\n\n\t/* Allocate memory for pad */\n\tdd->sdma_pad_dma = dma_alloc_coherent(&dd->pcidev->dev, sizeof(u32),\n\t\t\t\t\t      &dd->sdma_pad_phys, GFP_KERNEL);\n\tif (!dd->sdma_pad_dma) {\n\t\tdd_dev_err(dd, \"failed to allocate SendDMA pad memory\\n\");\n\t\tgoto bail;\n\t}\n\n\t/* assign each engine to different cacheline and init registers */\n\tcurr_head = (void *)dd->sdma_heads_dma;\n\tfor (this_idx = 0; this_idx < num_engines; ++this_idx) {\n\t\tunsigned long phys_offset;\n\n\t\tsde = &dd->per_sdma[this_idx];\n\n\t\tsde->head_dma = curr_head;\n\t\tcurr_head += L1_CACHE_BYTES;\n\t\tphys_offset = (unsigned long)sde->head_dma -\n\t\t\t      (unsigned long)dd->sdma_heads_dma;\n\t\tsde->head_phys = dd->sdma_heads_phys + phys_offset;\n\t\tinit_sdma_regs(sde, per_sdma_credits, idle_cnt);\n\t}\n\tdd->flags |= HFI1_HAS_SEND_DMA;\n\tdd->flags |= idle_cnt ? HFI1_HAS_SDMA_TIMEOUT : 0;\n\tdd->num_sdma = num_engines;\n\tret = sdma_map_init(dd, port, ppd->vls_operational, NULL);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\ttmp_sdma_rht = kzalloc(sizeof(*tmp_sdma_rht), GFP_KERNEL);\n\tif (!tmp_sdma_rht) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tret = rhashtable_init(tmp_sdma_rht, &sdma_rht_params);\n\tif (ret < 0) {\n\t\tkfree(tmp_sdma_rht);\n\t\tgoto bail;\n\t}\n\n\tdd->sdma_rht = tmp_sdma_rht;\n\n\tdd_dev_info(dd, \"SDMA num_sdma: %u\\n\", dd->num_sdma);\n\treturn 0;\n\nbail:\n\tsdma_clean(dd, num_engines);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -170,8 +170,11 @@\n \t}\n \n \tret = rhashtable_init(tmp_sdma_rht, &sdma_rht_params);\n-\tif (ret < 0)\n+\tif (ret < 0) {\n+\t\tkfree(tmp_sdma_rht);\n \t\tgoto bail;\n+\t}\n+\n \tdd->sdma_rht = tmp_sdma_rht;\n \n \tdd_dev_info(dd, \"SDMA num_sdma: %u\\n\", dd->num_sdma);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (ret < 0)"
            ],
            "added_lines": [
                "\tif (ret < 0) {",
                "\t\tkfree(tmp_sdma_rht);",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19066",
        "func_name": "torvalds/linux/bfad_im_get_stats",
        "description": "A memory leak in the bfad_im_get_stats() function in drivers/scsi/bfa/bfad_attr.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering bfa_port_get_stats() failures, aka CID-0e62395da2bd.",
        "git_url": "https://github.com/torvalds/linux/commit/0e62395da2bd5166d7c9e14cbc7503b256a34cb0",
        "commit_title": "scsi: bfa: release allocated memory in case of error",
        "commit_text": " In bfad_im_get_stats if bfa_port_get_stats fails, allocated memory needs to be released.  Link: https://lore.kernel.org/r/20190910234417.22151-1-navid.emamdoost@gmail.com",
        "func_before": "static struct fc_host_statistics *\nbfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\n\twait_for_completion(&fcomp.comp);\n\n\t/* Fill the fc_host_statistics structure */\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\n\tkfree(fcstats);\n\treturn hstats;\n}",
        "func": "static struct fc_host_statistics *\nbfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK) {\n\t\tkfree(fcstats);\n\t\treturn NULL;\n\t}\n\n\twait_for_completion(&fcomp.comp);\n\n\t/* Fill the fc_host_statistics structure */\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\n\tkfree(fcstats);\n\treturn hstats;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,8 +21,10 @@\n \trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n \t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n \tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n-\tif (rc != BFA_STATUS_OK)\n+\tif (rc != BFA_STATUS_OK) {\n+\t\tkfree(fcstats);\n \t\treturn NULL;\n+\t}\n \n \twait_for_completion(&fcomp.comp);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (rc != BFA_STATUS_OK)"
            ],
            "added_lines": [
                "\tif (rc != BFA_STATUS_OK) {",
                "\t\tkfree(fcstats);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19067",
        "func_name": "torvalds/linux/acp_hw_init",
        "description": "Four memory leaks in the acp_hw_init() function in drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption) by triggering mfd_add_hotplug_devices() or pm_genpd_add_device() failures, aka CID-57be09c6e874. NOTE: third parties dispute the relevance of this because the attacker must already have privileges for module loading",
        "git_url": "https://github.com/torvalds/linux/commit/57be09c6e8747bf48704136d9e3f92bfb93f5725",
        "commit_title": "drm/amdgpu: fix multiple memory leaks in acp_hw_init",
        "commit_text": " In acp_hw_init there are some allocations that needs to be released in case of failure:  1- adev->acp.acp_genpd should be released if any allocation attemp for adev->acp.acp_cell, adev->acp.acp_res or i2s_pdata fails. 2- all of those allocations should be released if mfd_add_hotplug_devices or pm_genpd_add_device fail. 3- Release is needed in case of time out values expire. ",
        "func_before": "static int acp_hw_init(void *handle)\n{\n\tint r, i;\n\tuint64_t acp_base;\n\tu32 val = 0;\n\tu32 count = 0;\n\tstruct device *dev;\n\tstruct i2s_platform_data *i2s_pdata;\n\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tconst struct amdgpu_ip_block *ip_block =\n\t\tamdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);\n\n\tif (!ip_block)\n\t\treturn -EINVAL;\n\n\tr = amd_acp_hw_init(adev->acp.cgs_device,\n\t\t\t    ip_block->version->major, ip_block->version->minor);\n\t/* -ENODEV means board uses AZ rather than ACP */\n\tif (r == -ENODEV) {\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\t\treturn 0;\n\t} else if (r) {\n\t\treturn r;\n\t}\n\n\tif (adev->rmmio_size == 0 || adev->rmmio_size < 0x5289)\n\t\treturn -EINVAL;\n\n\tacp_base = adev->rmmio_base;\n\n\n\tadev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL);\n\tif (adev->acp.acp_genpd == NULL)\n\t\treturn -ENOMEM;\n\n\tadev->acp.acp_genpd->gpd.name = \"ACP_AUDIO\";\n\tadev->acp.acp_genpd->gpd.power_off = acp_poweroff;\n\tadev->acp.acp_genpd->gpd.power_on = acp_poweron;\n\n\n\tadev->acp.acp_genpd->adev = adev;\n\n\tpm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);\n\n\tadev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (adev->acp.acp_cell == NULL)\n\t\treturn -ENOMEM;\n\n\tadev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL);\n\tif (adev->acp.acp_res == NULL) {\n\t\tkfree(adev->acp.acp_cell);\n\t\treturn -ENOMEM;\n\t}\n\n\ti2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL);\n\tif (i2s_pdata == NULL) {\n\t\tkfree(adev->acp.acp_res);\n\t\tkfree(adev->acp.acp_cell);\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\t}\n\ti2s_pdata[0].cap = DWC_I2S_PLAY;\n\ti2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET;\n\ti2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET;\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_COMP_PARAM1 |\n\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_COMP_PARAM1;\n\t}\n\n\ti2s_pdata[1].cap = DWC_I2S_RECORD;\n\ti2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;\n\ti2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;\n\n\ti2s_pdata[2].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[2].quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ti2s_pdata[2].cap = DWC_I2S_PLAY | DWC_I2S_RECORD;\n\ti2s_pdata[2].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[2].i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET;\n\ti2s_pdata[2].i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET;\n\n\tadev->acp.acp_res[0].name = \"acp2x_dma\";\n\tadev->acp.acp_res[0].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[0].start = acp_base;\n\tadev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;\n\n\tadev->acp.acp_res[1].name = \"acp2x_dw_i2s_play\";\n\tadev->acp.acp_res[1].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START;\n\tadev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END;\n\n\tadev->acp.acp_res[2].name = \"acp2x_dw_i2s_cap\";\n\tadev->acp.acp_res[2].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START;\n\tadev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END;\n\n\tadev->acp.acp_res[3].name = \"acp2x_dw_bt_i2s_play_cap\";\n\tadev->acp.acp_res[3].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[3].start = acp_base + ACP_BT_PLAY_REGS_START;\n\tadev->acp.acp_res[3].end = acp_base + ACP_BT_PLAY_REGS_END;\n\n\tadev->acp.acp_res[4].name = \"acp2x_dma_irq\";\n\tadev->acp.acp_res[4].flags = IORESOURCE_IRQ;\n\tadev->acp.acp_res[4].start = amdgpu_irq_create_mapping(adev, 162);\n\tadev->acp.acp_res[4].end = adev->acp.acp_res[4].start;\n\n\tadev->acp.acp_cell[0].name = \"acp_audio_dma\";\n\tadev->acp.acp_cell[0].num_resources = 5;\n\tadev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];\n\tadev->acp.acp_cell[0].platform_data = &adev->asic_type;\n\tadev->acp.acp_cell[0].pdata_size = sizeof(adev->asic_type);\n\n\tadev->acp.acp_cell[1].name = \"designware-i2s\";\n\tadev->acp.acp_cell[1].num_resources = 1;\n\tadev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];\n\tadev->acp.acp_cell[1].platform_data = &i2s_pdata[0];\n\tadev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);\n\n\tadev->acp.acp_cell[2].name = \"designware-i2s\";\n\tadev->acp.acp_cell[2].num_resources = 1;\n\tadev->acp.acp_cell[2].resources = &adev->acp.acp_res[2];\n\tadev->acp.acp_cell[2].platform_data = &i2s_pdata[1];\n\tadev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);\n\n\tadev->acp.acp_cell[3].name = \"designware-i2s\";\n\tadev->acp.acp_cell[3].num_resources = 1;\n\tadev->acp.acp_cell[3].resources = &adev->acp.acp_res[3];\n\tadev->acp.acp_cell[3].platform_data = &i2s_pdata[2];\n\tadev->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data);\n\n\tr = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,\n\t\t\t\t\t\t\t\tACP_DEVS);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < ACP_DEVS ; i++) {\n\t\tdev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);\n\t\tr = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);\n\t\tif (r) {\n\t\t\tdev_err(dev, \"Failed to add dev to genpd\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\n\t/* Assert Soft reset of ACP */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Enable clock to ACP and wait until the clock is enabled */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);\n\tval = val | ACP_CONTROL__ClkEn_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);\n\t\tif (val & (u32) 0x1)\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Deassert the SOFT RESET flags */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\tval &= ~ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\treturn 0;\n}",
        "func": "static int acp_hw_init(void *handle)\n{\n\tint r, i;\n\tuint64_t acp_base;\n\tu32 val = 0;\n\tu32 count = 0;\n\tstruct device *dev;\n\tstruct i2s_platform_data *i2s_pdata = NULL;\n\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tconst struct amdgpu_ip_block *ip_block =\n\t\tamdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);\n\n\tif (!ip_block)\n\t\treturn -EINVAL;\n\n\tr = amd_acp_hw_init(adev->acp.cgs_device,\n\t\t\t    ip_block->version->major, ip_block->version->minor);\n\t/* -ENODEV means board uses AZ rather than ACP */\n\tif (r == -ENODEV) {\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\t\treturn 0;\n\t} else if (r) {\n\t\treturn r;\n\t}\n\n\tif (adev->rmmio_size == 0 || adev->rmmio_size < 0x5289)\n\t\treturn -EINVAL;\n\n\tacp_base = adev->rmmio_base;\n\n\n\tadev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL);\n\tif (adev->acp.acp_genpd == NULL)\n\t\treturn -ENOMEM;\n\n\tadev->acp.acp_genpd->gpd.name = \"ACP_AUDIO\";\n\tadev->acp.acp_genpd->gpd.power_off = acp_poweroff;\n\tadev->acp.acp_genpd->gpd.power_on = acp_poweron;\n\n\n\tadev->acp.acp_genpd->adev = adev;\n\n\tpm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);\n\n\tadev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (adev->acp.acp_cell == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\tadev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL);\n\tif (adev->acp.acp_res == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\ti2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL);\n\tif (i2s_pdata == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\t}\n\ti2s_pdata[0].cap = DWC_I2S_PLAY;\n\ti2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET;\n\ti2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET;\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_COMP_PARAM1 |\n\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_COMP_PARAM1;\n\t}\n\n\ti2s_pdata[1].cap = DWC_I2S_RECORD;\n\ti2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;\n\ti2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;\n\n\ti2s_pdata[2].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[2].quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ti2s_pdata[2].cap = DWC_I2S_PLAY | DWC_I2S_RECORD;\n\ti2s_pdata[2].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[2].i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET;\n\ti2s_pdata[2].i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET;\n\n\tadev->acp.acp_res[0].name = \"acp2x_dma\";\n\tadev->acp.acp_res[0].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[0].start = acp_base;\n\tadev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;\n\n\tadev->acp.acp_res[1].name = \"acp2x_dw_i2s_play\";\n\tadev->acp.acp_res[1].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START;\n\tadev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END;\n\n\tadev->acp.acp_res[2].name = \"acp2x_dw_i2s_cap\";\n\tadev->acp.acp_res[2].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START;\n\tadev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END;\n\n\tadev->acp.acp_res[3].name = \"acp2x_dw_bt_i2s_play_cap\";\n\tadev->acp.acp_res[3].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[3].start = acp_base + ACP_BT_PLAY_REGS_START;\n\tadev->acp.acp_res[3].end = acp_base + ACP_BT_PLAY_REGS_END;\n\n\tadev->acp.acp_res[4].name = \"acp2x_dma_irq\";\n\tadev->acp.acp_res[4].flags = IORESOURCE_IRQ;\n\tadev->acp.acp_res[4].start = amdgpu_irq_create_mapping(adev, 162);\n\tadev->acp.acp_res[4].end = adev->acp.acp_res[4].start;\n\n\tadev->acp.acp_cell[0].name = \"acp_audio_dma\";\n\tadev->acp.acp_cell[0].num_resources = 5;\n\tadev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];\n\tadev->acp.acp_cell[0].platform_data = &adev->asic_type;\n\tadev->acp.acp_cell[0].pdata_size = sizeof(adev->asic_type);\n\n\tadev->acp.acp_cell[1].name = \"designware-i2s\";\n\tadev->acp.acp_cell[1].num_resources = 1;\n\tadev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];\n\tadev->acp.acp_cell[1].platform_data = &i2s_pdata[0];\n\tadev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);\n\n\tadev->acp.acp_cell[2].name = \"designware-i2s\";\n\tadev->acp.acp_cell[2].num_resources = 1;\n\tadev->acp.acp_cell[2].resources = &adev->acp.acp_res[2];\n\tadev->acp.acp_cell[2].platform_data = &i2s_pdata[1];\n\tadev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);\n\n\tadev->acp.acp_cell[3].name = \"designware-i2s\";\n\tadev->acp.acp_cell[3].num_resources = 1;\n\tadev->acp.acp_cell[3].resources = &adev->acp.acp_res[3];\n\tadev->acp.acp_cell[3].platform_data = &i2s_pdata[2];\n\tadev->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data);\n\n\tr = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,\n\t\t\t\t\t\t\t\tACP_DEVS);\n\tif (r)\n\t\tgoto failure;\n\n\tfor (i = 0; i < ACP_DEVS ; i++) {\n\t\tdev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);\n\t\tr = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);\n\t\tif (r) {\n\t\t\tdev_err(dev, \"Failed to add dev to genpd\\n\");\n\t\t\tgoto failure;\n\t\t}\n\t}\n\n\n\t/* Assert Soft reset of ACP */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\tr = -ETIMEDOUT;\n\t\t\tgoto failure;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Enable clock to ACP and wait until the clock is enabled */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);\n\tval = val | ACP_CONTROL__ClkEn_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);\n\t\tif (val & (u32) 0x1)\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\tr = -ETIMEDOUT;\n\t\t\tgoto failure;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Deassert the SOFT RESET flags */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\tval &= ~ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\treturn 0;\n\nfailure:\n\tkfree(i2s_pdata);\n\tkfree(adev->acp.acp_res);\n\tkfree(adev->acp.acp_cell);\n\tkfree(adev->acp.acp_genpd);\n\treturn r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tu32 val = 0;\n \tu32 count = 0;\n \tstruct device *dev;\n-\tstruct i2s_platform_data *i2s_pdata;\n+\tstruct i2s_platform_data *i2s_pdata = NULL;\n \n \tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n \n@@ -47,20 +47,21 @@\n \tadev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),\n \t\t\t\t\t\t\tGFP_KERNEL);\n \n-\tif (adev->acp.acp_cell == NULL)\n-\t\treturn -ENOMEM;\n+\tif (adev->acp.acp_cell == NULL) {\n+\t\tr = -ENOMEM;\n+\t\tgoto failure;\n+\t}\n \n \tadev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL);\n \tif (adev->acp.acp_res == NULL) {\n-\t\tkfree(adev->acp.acp_cell);\n-\t\treturn -ENOMEM;\n+\t\tr = -ENOMEM;\n+\t\tgoto failure;\n \t}\n \n \ti2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL);\n \tif (i2s_pdata == NULL) {\n-\t\tkfree(adev->acp.acp_res);\n-\t\tkfree(adev->acp.acp_cell);\n-\t\treturn -ENOMEM;\n+\t\tr = -ENOMEM;\n+\t\tgoto failure;\n \t}\n \n \tswitch (adev->asic_type) {\n@@ -157,14 +158,14 @@\n \tr = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,\n \t\t\t\t\t\t\t\tACP_DEVS);\n \tif (r)\n-\t\treturn r;\n+\t\tgoto failure;\n \n \tfor (i = 0; i < ACP_DEVS ; i++) {\n \t\tdev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);\n \t\tr = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);\n \t\tif (r) {\n \t\t\tdev_err(dev, \"Failed to add dev to genpd\\n\");\n-\t\t\treturn r;\n+\t\t\tgoto failure;\n \t\t}\n \t}\n \n@@ -183,7 +184,8 @@\n \t\t\tbreak;\n \t\tif (--count == 0) {\n \t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n-\t\t\treturn -ETIMEDOUT;\n+\t\t\tr = -ETIMEDOUT;\n+\t\t\tgoto failure;\n \t\t}\n \t\tudelay(100);\n \t}\n@@ -200,7 +202,8 @@\n \t\t\tbreak;\n \t\tif (--count == 0) {\n \t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n-\t\t\treturn -ETIMEDOUT;\n+\t\t\tr = -ETIMEDOUT;\n+\t\t\tgoto failure;\n \t\t}\n \t\tudelay(100);\n \t}\n@@ -209,4 +212,11 @@\n \tval &= ~ACP_SOFT_RESET__SoftResetAud_MASK;\n \tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n \treturn 0;\n+\n+failure:\n+\tkfree(i2s_pdata);\n+\tkfree(adev->acp.acp_res);\n+\tkfree(adev->acp.acp_cell);\n+\tkfree(adev->acp.acp_genpd);\n+\treturn r;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct i2s_platform_data *i2s_pdata;",
                "\tif (adev->acp.acp_cell == NULL)",
                "\t\treturn -ENOMEM;",
                "\t\tkfree(adev->acp.acp_cell);",
                "\t\treturn -ENOMEM;",
                "\t\tkfree(adev->acp.acp_res);",
                "\t\tkfree(adev->acp.acp_cell);",
                "\t\treturn -ENOMEM;",
                "\t\treturn r;",
                "\t\t\treturn r;",
                "\t\t\treturn -ETIMEDOUT;",
                "\t\t\treturn -ETIMEDOUT;"
            ],
            "added_lines": [
                "\tstruct i2s_platform_data *i2s_pdata = NULL;",
                "\tif (adev->acp.acp_cell == NULL) {",
                "\t\tr = -ENOMEM;",
                "\t\tgoto failure;",
                "\t}",
                "\t\tr = -ENOMEM;",
                "\t\tgoto failure;",
                "\t\tr = -ENOMEM;",
                "\t\tgoto failure;",
                "\t\tgoto failure;",
                "\t\t\tgoto failure;",
                "\t\t\tr = -ETIMEDOUT;",
                "\t\t\tgoto failure;",
                "\t\t\tr = -ETIMEDOUT;",
                "\t\t\tgoto failure;",
                "",
                "failure:",
                "\tkfree(i2s_pdata);",
                "\tkfree(adev->acp.acp_res);",
                "\tkfree(adev->acp.acp_cell);",
                "\tkfree(adev->acp.acp_genpd);",
                "\treturn r;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19068",
        "func_name": "torvalds/linux/rtl8xxxu_submit_int_urb",
        "description": "A memory leak in the rtl8xxxu_submit_int_urb() function in drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-a2cdd07488e6.",
        "git_url": "https://github.com/torvalds/linux/commit/a2cdd07488e666aa93a49a3fc9c9b1299e27ef3c",
        "commit_title": "rtl8xxxu: prevent leaking urb",
        "commit_text": " In rtl8xxxu_submit_int_urb if usb_submit_urb fails the allocated urb should be released. ",
        "func_before": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto error;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\n\nerror:\n\treturn ret;\n}",
        "func": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_urb(urb);\n\t\tgoto error;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\n\nerror:\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,7 @@\n \tret = usb_submit_urb(urb, GFP_KERNEL);\n \tif (ret) {\n \t\tusb_unanchor_urb(urb);\n+\t\tusb_free_urb(urb);\n \t\tgoto error;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tusb_free_urb(urb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19069",
        "func_name": "torvalds/linux/fastrpc_dma_buf_attach",
        "description": "A memory leak in the fastrpc_dma_buf_attach() function in drivers/misc/fastrpc.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering dma_get_sgtable() failures, aka CID-fc739a058d99.",
        "git_url": "https://github.com/torvalds/linux/commit/fc739a058d99c9297ef6bfd923b809d85855b9a9",
        "commit_title": "misc: fastrpc: prevent memory leak in fastrpc_dma_buf_attach",
        "commit_text": " In fastrpc_dma_buf_attach if dma_get_sgtable fails the allocated memory for a should be released.  Link: https://lore.kernel.org/r/20190925152742.16258-1-navid.emamdoost@gmail.com",
        "func_before": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\n\treturn 0;\n}",
        "func": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\tkfree(a);\n\t\treturn -EINVAL;\n\t}\n\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n \t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n \tif (ret < 0) {\n \t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n+\t\tkfree(a);\n \t\treturn -EINVAL;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tkfree(a);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19070",
        "func_name": "torvalds/linux/spi_gpio_probe",
        "description": "A memory leak in the spi_gpio_probe() function in drivers/spi/spi-gpio.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering devm_add_action_or_reset() failures, aka CID-d3b0ffa1d75d. NOTE: third parties dispute the relevance of this because the system must have already been out of memory before the probe began",
        "git_url": "https://github.com/torvalds/linux/commit/d3b0ffa1d75d5305ebe34735598993afbb8a869d",
        "commit_title": "spi: gpio: prevent memory leak in spi_gpio_probe",
        "commit_text": " In spi_gpio_probe an SPI master is allocated via spi_alloc_master, but this controller should be released if devm_add_action_or_reset fails, otherwise memory leaks. In order to avoid leak spi_contriller_put must be called in case of failure for devm_add_action_or_reset.  Link: https://lore.kernel.org/r/20190930205241.5483-1-navid.emamdoost@gmail.com",
        "func_before": "static int spi_gpio_probe(struct platform_device *pdev)\n{\n\tint\t\t\t\tstatus;\n\tstruct spi_master\t\t*master;\n\tstruct spi_gpio\t\t\t*spi_gpio;\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tstruct spi_bitbang\t\t*bb;\n\tconst struct of_device_id\t*of_id;\n\n\tof_id = of_match_device(spi_gpio_dt_ids, &pdev->dev);\n\n\tmaster = spi_alloc_master(dev, sizeof(*spi_gpio));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tstatus = devm_add_action_or_reset(&pdev->dev, spi_gpio_put, master);\n\tif (status)\n\t\treturn status;\n\n\tif (of_id)\n\t\tstatus = spi_gpio_probe_dt(pdev, master);\n\telse\n\t\tstatus = spi_gpio_probe_pdata(pdev, master);\n\n\tif (status)\n\t\treturn status;\n\n\tspi_gpio = spi_master_get_devdata(master);\n\n\tstatus = spi_gpio_request(dev, spi_gpio);\n\tif (status)\n\t\treturn status;\n\n\tmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\n\tmaster->mode_bits = SPI_3WIRE | SPI_3WIRE_HIZ | SPI_CPHA | SPI_CPOL |\n\t\t\t    SPI_CS_HIGH;\n\tif (!spi_gpio->mosi) {\n\t\t/* HW configuration without MOSI pin\n\t\t *\n\t\t * No setting SPI_MASTER_NO_RX here - if there is only\n\t\t * a MOSI pin connected the host can still do RX by\n\t\t * changing the direction of the line.\n\t\t */\n\t\tmaster->flags = SPI_MASTER_NO_TX;\n\t}\n\n\tmaster->bus_num = pdev->id;\n\tmaster->setup = spi_gpio_setup;\n\tmaster->cleanup = spi_gpio_cleanup;\n\n\tbb = &spi_gpio->bitbang;\n\tbb->master = master;\n\t/*\n\t * There is some additional business, apart from driving the CS GPIO\n\t * line, that we need to do on selection. This makes the local\n\t * callback for chipselect always get called.\n\t */\n\tmaster->flags |= SPI_MASTER_GPIO_SS;\n\tbb->chipselect = spi_gpio_chipselect;\n\tbb->set_line_direction = spi_gpio_set_direction;\n\n\tif (master->flags & SPI_MASTER_NO_TX) {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_spec_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_spec_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_spec_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_spec_txrx_word_mode3;\n\t} else {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_txrx_word_mode3;\n\t}\n\tbb->setup_transfer = spi_bitbang_setup_transfer;\n\n\tstatus = spi_bitbang_init(&spi_gpio->bitbang);\n\tif (status)\n\t\treturn status;\n\n\treturn devm_spi_register_master(&pdev->dev, spi_master_get(master));\n}",
        "func": "static int spi_gpio_probe(struct platform_device *pdev)\n{\n\tint\t\t\t\tstatus;\n\tstruct spi_master\t\t*master;\n\tstruct spi_gpio\t\t\t*spi_gpio;\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tstruct spi_bitbang\t\t*bb;\n\tconst struct of_device_id\t*of_id;\n\n\tof_id = of_match_device(spi_gpio_dt_ids, &pdev->dev);\n\n\tmaster = spi_alloc_master(dev, sizeof(*spi_gpio));\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tstatus = devm_add_action_or_reset(&pdev->dev, spi_gpio_put, master);\n\tif (status) {\n\t\tspi_master_put(master);\n\t\treturn status;\n\t}\n\n\tif (of_id)\n\t\tstatus = spi_gpio_probe_dt(pdev, master);\n\telse\n\t\tstatus = spi_gpio_probe_pdata(pdev, master);\n\n\tif (status)\n\t\treturn status;\n\n\tspi_gpio = spi_master_get_devdata(master);\n\n\tstatus = spi_gpio_request(dev, spi_gpio);\n\tif (status)\n\t\treturn status;\n\n\tmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);\n\tmaster->mode_bits = SPI_3WIRE | SPI_3WIRE_HIZ | SPI_CPHA | SPI_CPOL |\n\t\t\t    SPI_CS_HIGH;\n\tif (!spi_gpio->mosi) {\n\t\t/* HW configuration without MOSI pin\n\t\t *\n\t\t * No setting SPI_MASTER_NO_RX here - if there is only\n\t\t * a MOSI pin connected the host can still do RX by\n\t\t * changing the direction of the line.\n\t\t */\n\t\tmaster->flags = SPI_MASTER_NO_TX;\n\t}\n\n\tmaster->bus_num = pdev->id;\n\tmaster->setup = spi_gpio_setup;\n\tmaster->cleanup = spi_gpio_cleanup;\n\n\tbb = &spi_gpio->bitbang;\n\tbb->master = master;\n\t/*\n\t * There is some additional business, apart from driving the CS GPIO\n\t * line, that we need to do on selection. This makes the local\n\t * callback for chipselect always get called.\n\t */\n\tmaster->flags |= SPI_MASTER_GPIO_SS;\n\tbb->chipselect = spi_gpio_chipselect;\n\tbb->set_line_direction = spi_gpio_set_direction;\n\n\tif (master->flags & SPI_MASTER_NO_TX) {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_spec_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_spec_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_spec_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_spec_txrx_word_mode3;\n\t} else {\n\t\tbb->txrx_word[SPI_MODE_0] = spi_gpio_txrx_word_mode0;\n\t\tbb->txrx_word[SPI_MODE_1] = spi_gpio_txrx_word_mode1;\n\t\tbb->txrx_word[SPI_MODE_2] = spi_gpio_txrx_word_mode2;\n\t\tbb->txrx_word[SPI_MODE_3] = spi_gpio_txrx_word_mode3;\n\t}\n\tbb->setup_transfer = spi_bitbang_setup_transfer;\n\n\tstatus = spi_bitbang_init(&spi_gpio->bitbang);\n\tif (status)\n\t\treturn status;\n\n\treturn devm_spi_register_master(&pdev->dev, spi_master_get(master));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,8 +14,10 @@\n \t\treturn -ENOMEM;\n \n \tstatus = devm_add_action_or_reset(&pdev->dev, spi_gpio_put, master);\n-\tif (status)\n+\tif (status) {\n+\t\tspi_master_put(master);\n \t\treturn status;\n+\t}\n \n \tif (of_id)\n \t\tstatus = spi_gpio_probe_dt(pdev, master);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (status)"
            ],
            "added_lines": [
                "\tif (status) {",
                "\t\tspi_master_put(master);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19071",
        "func_name": "torvalds/linux/rsi_send_beacon",
        "description": "A memory leak in the rsi_send_beacon() function in drivers/net/wireless/rsi/rsi_91x_mgmt.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering rsi_prepare_beacon() failures, aka CID-d563131ef23c.",
        "git_url": "https://github.com/torvalds/linux/commit/d563131ef23cbc756026f839a82598c8445bc45f",
        "commit_title": "rsi: release skb if rsi_prepare_beacon fails",
        "commit_text": " In rsi_send_beacon, if rsi_prepare_beacon fails the allocated skb should be released. ",
        "func_before": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}",
        "func": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n \t\tskb_pull(skb, (64 - dword_align_bytes));\n \tif (rsi_prepare_beacon(common, skb)) {\n \t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n+\t\tdev_kfree_skb(skb);\n \t\treturn -EINVAL;\n \t}\n \tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tdev_kfree_skb(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19072",
        "func_name": "torvalds/linux/predicate_parse",
        "description": "A memory leak in the predicate_parse() function in kernel/trace/trace_events_filter.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-96c5c6e6a5b6.",
        "git_url": "https://github.com/torvalds/linux/commit/96c5c6e6a5b6db592acae039fed54b5c8844cd35",
        "commit_title": "tracing: Have error path in predicate_parse() free its allocated memory",
        "commit_text": " In predicate_parse, there is an error path that is not going to out_free instead it returns directly which leads to a memory leak.  Link: http://lkml.kernel.org/r/20190920225800.3870-1-navid.emamdoost@gmail.com ",
        "func_before": "static struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\t/* accepting only \"&&\" or \"||\" */\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tkfree(op_stack);\n\tkfree(inverts);\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(inverts);\n\tif (prog_stack) {\n\t\tfor (i = 0; prog_stack[i].pred; i++)\n\t\t\tkfree(prog_stack[i].pred);\n\t\tkfree(prog_stack);\n\t}\n\treturn ERR_PTR(ret);\n}",
        "func": "static struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\t/* accepting only \"&&\" or \"||\" */\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tkfree(op_stack);\n\tkfree(inverts);\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(inverts);\n\tif (prog_stack) {\n\t\tfor (i = 0; prog_stack[i].pred; i++)\n\t\t\tkfree(prog_stack[i].pred);\n\t\tkfree(prog_stack);\n\t}\n\treturn ERR_PTR(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,8 +44,10 @@\n \n \t\tswitch (*next) {\n \t\tcase '(':\t\t\t\t\t/* #2 */\n-\t\t\tif (top - op_stack > nr_parens)\n-\t\t\t\treturn ERR_PTR(-EINVAL);\n+\t\t\tif (top - op_stack > nr_parens) {\n+\t\t\t\tret = -EINVAL;\n+\t\t\t\tgoto out_free;\n+\t\t\t}\n \t\t\t*(++top) = invert;\n \t\t\tcontinue;\n \t\tcase '!':\t\t\t\t\t/* #3 */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (top - op_stack > nr_parens)",
                "\t\t\t\treturn ERR_PTR(-EINVAL);"
            ],
            "added_lines": [
                "\t\t\tif (top - op_stack > nr_parens) {",
                "\t\t\t\tret = -EINVAL;",
                "\t\t\t\tgoto out_free;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19073",
        "func_name": "torvalds/linux/htc_config_pipe_credits",
        "description": "Memory leaks in drivers/net/wireless/ath/ath9k/htc_hst.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering wait_for_completion_timeout() failures. This affects the htc_config_pipe_credits() function, the htc_setup_complete() function, and the htc_connect_service() function, aka CID-853acf7caf10.",
        "git_url": "https://github.com/torvalds/linux/commit/853acf7caf10b828102d92d05b5c101666a6142b",
        "commit_title": "ath9k_htc: release allocated buffer if timed out",
        "commit_text": " In htc_config_pipe_credits, htc_setup_complete, and htc_connect_service if time out happens, the allocated buffer needs to be released. Otherwise there will be memory leak. ",
        "func_before": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}",
        "func": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,7 @@\n \ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n \tif (!time_left) {\n \t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n+\t\tkfree_skb(skb);\n \t\treturn -ETIMEDOUT;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tkfree_skb(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19073",
        "func_name": "torvalds/linux/htc_connect_service",
        "description": "Memory leaks in drivers/net/wireless/ath/ath9k/htc_hst.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering wait_for_completion_timeout() failures. This affects the htc_config_pipe_credits() function, the htc_setup_complete() function, and the htc_connect_service() function, aka CID-853acf7caf10.",
        "git_url": "https://github.com/torvalds/linux/commit/853acf7caf10b828102d92d05b5c101666a6142b",
        "commit_title": "ath9k_htc: release allocated buffer if timed out",
        "commit_text": " In htc_config_pipe_credits, htc_setup_complete, and htc_connect_service if time out happens, the allocated buffer needs to be released. Otherwise there will be memory leak. ",
        "func_before": "int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\t/* Find an available endpoint */\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}",
        "func": "int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\t/* Find an available endpoint */\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,6 +47,7 @@\n \tif (!time_left) {\n \t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n \t\t\tservice_connreq->service_id);\n+\t\tkfree_skb(skb);\n \t\treturn -ETIMEDOUT;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tkfree_skb(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19073",
        "func_name": "torvalds/linux/htc_setup_complete",
        "description": "Memory leaks in drivers/net/wireless/ath/ath9k/htc_hst.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering wait_for_completion_timeout() failures. This affects the htc_config_pipe_credits() function, the htc_setup_complete() function, and the htc_connect_service() function, aka CID-853acf7caf10.",
        "git_url": "https://github.com/torvalds/linux/commit/853acf7caf10b828102d92d05b5c101666a6142b",
        "commit_title": "ath9k_htc: release allocated buffer if timed out",
        "commit_text": " In htc_config_pipe_credits, htc_setup_complete, and htc_connect_service if time out happens, the allocated buffer needs to be released. Otherwise there will be memory leak. ",
        "func_before": "static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}",
        "func": "static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,7 @@\n \ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n \tif (!time_left) {\n \t\tdev_err(target->dev, \"HTC start timeout\\n\");\n+\t\tkfree_skb(skb);\n \t\treturn -ETIMEDOUT;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tkfree_skb(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19074",
        "func_name": "torvalds/linux/ath9k_wmi_cmd",
        "description": "A memory leak in the ath9k_wmi_cmd() function in drivers/net/wireless/ath/ath9k/wmi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-728c1e2a05e4.",
        "git_url": "https://github.com/torvalds/linux/commit/728c1e2a05e4b5fc52fab3421dce772a806612a2",
        "commit_title": "ath9k: release allocated buffer if timed out",
        "commit_text": " In ath9k_wmi_cmd, the allocated network buffer needs to be released if timeout happens. Otherwise memory will be leaked. ",
        "func_before": "int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, headroom);\n\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\n\tmutex_lock(&wmi->op_mutex);\n\n\t/* check if wmi stopped flag is set */\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\n\t/* record the rsp buffer and length */\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmutex_unlock(&wmi->op_mutex);\n\n\treturn 0;\n\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\n\treturn ret;\n}",
        "func": "int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, headroom);\n\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\n\tmutex_lock(&wmi->op_mutex);\n\n\t/* check if wmi stopped flag is set */\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\n\t/* record the rsp buffer and length */\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmutex_unlock(&wmi->op_mutex);\n\n\treturn 0;\n\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,6 +45,7 @@\n \t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n \t\t\twmi_cmd_to_name(cmd_id));\n \t\tmutex_unlock(&wmi->op_mutex);\n+\t\tkfree_skb(skb);\n \t\treturn -ETIMEDOUT;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tkfree_skb(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19075",
        "func_name": "torvalds/linux/ca8210_probe",
        "description": "A memory leak in the ca8210_probe() function in drivers/net/ieee802154/ca8210.c in the Linux kernel before 5.3.8 allows attackers to cause a denial of service (memory consumption) by triggering ca8210_get_platform_data() failures, aka CID-6402939ec86e.",
        "git_url": "https://github.com/torvalds/linux/commit/6402939ec86eaf226c8b8ae00ed983936b164908",
        "commit_title": "ieee802154: ca8210: prevent memory leak",
        "commit_text": " In ca8210_probe the allocated pdata needs to be assigned to spi_device->dev.platform_data before calling ca8210_get_platform_data. Othrwise when ca8210_get_platform_data fails pdata cannot be released.  Link: https://lore.kernel.org/r/20190917224713.26371-1-navid.emamdoost@gmail.com",
        "func_before": "static int ca8210_probe(struct spi_device *spi_device)\n{\n\tstruct ca8210_priv *priv;\n\tstruct ieee802154_hw *hw;\n\tstruct ca8210_platform_data *pdata;\n\tint ret;\n\n\tdev_info(&spi_device->dev, \"Inserting ca8210\\n\");\n\n\t/* allocate ieee802154_hw and private data */\n\thw = ieee802154_alloc_hw(sizeof(struct ca8210_priv), &ca8210_phy_ops);\n\tif (!hw) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_alloc_hw failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->spi = spi_device;\n\thw->parent = &spi_device->dev;\n\tspin_lock_init(&priv->lock);\n\tpriv->async_tx_pending = false;\n\tpriv->hw_registered = false;\n\tpriv->sync_up = 0;\n\tpriv->sync_down = 0;\n\tpriv->promiscuous = false;\n\tpriv->retries = 0;\n\tinit_completion(&priv->ca8210_is_awake);\n\tinit_completion(&priv->spi_transfer_complete);\n\tinit_completion(&priv->sync_exchange_complete);\n\tspi_set_drvdata(priv->spi, priv);\n\tif (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS)) {\n\t\tcascoda_api_upstream = ca8210_test_int_driver_write;\n\t\tca8210_test_interface_init(priv);\n\t} else {\n\t\tcascoda_api_upstream = NULL;\n\t}\n\tca8210_hw_setup(hw);\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\n\tpdata = kmalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = ca8210_get_platform_data(priv->spi, pdata);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_get_platform_data failed\\n\");\n\t\tgoto error;\n\t}\n\tpriv->spi->dev.platform_data = pdata;\n\n\tret = ca8210_dev_com_init(priv);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_dev_com_init failed\\n\");\n\t\tgoto error;\n\t}\n\tret = ca8210_reset_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_reset_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tret = ca8210_interrupt_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_interrupt_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tmsleep(100);\n\n\tca8210_reset_send(priv->spi, 1);\n\n\tret = tdme_chipinit(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"tdme_chipinit failed\\n\");\n\t\tgoto error;\n\t}\n\n\tif (pdata->extclockenable) {\n\t\tret = ca8210_config_extern_clk(pdata, priv->spi, 1);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_config_extern_clk failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t\tret = ca8210_register_ext_clock(priv->spi);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_register_ext_clock failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_register_hw failed\\n\");\n\t\tgoto error;\n\t}\n\tpriv->hw_registered = true;\n\n\treturn 0;\nerror:\n\tmsleep(100); /* wait for pending spi transfers to complete */\n\tca8210_remove(spi_device);\n\treturn link_to_linux_err(ret);\n}",
        "func": "static int ca8210_probe(struct spi_device *spi_device)\n{\n\tstruct ca8210_priv *priv;\n\tstruct ieee802154_hw *hw;\n\tstruct ca8210_platform_data *pdata;\n\tint ret;\n\n\tdev_info(&spi_device->dev, \"Inserting ca8210\\n\");\n\n\t/* allocate ieee802154_hw and private data */\n\thw = ieee802154_alloc_hw(sizeof(struct ca8210_priv), &ca8210_phy_ops);\n\tif (!hw) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_alloc_hw failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->spi = spi_device;\n\thw->parent = &spi_device->dev;\n\tspin_lock_init(&priv->lock);\n\tpriv->async_tx_pending = false;\n\tpriv->hw_registered = false;\n\tpriv->sync_up = 0;\n\tpriv->sync_down = 0;\n\tpriv->promiscuous = false;\n\tpriv->retries = 0;\n\tinit_completion(&priv->ca8210_is_awake);\n\tinit_completion(&priv->spi_transfer_complete);\n\tinit_completion(&priv->sync_exchange_complete);\n\tspi_set_drvdata(priv->spi, priv);\n\tif (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS)) {\n\t\tcascoda_api_upstream = ca8210_test_int_driver_write;\n\t\tca8210_test_interface_init(priv);\n\t} else {\n\t\tcascoda_api_upstream = NULL;\n\t}\n\tca8210_hw_setup(hw);\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\n\tpdata = kmalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpriv->spi->dev.platform_data = pdata;\n\tret = ca8210_get_platform_data(priv->spi, pdata);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_get_platform_data failed\\n\");\n\t\tgoto error;\n\t}\n\n\tret = ca8210_dev_com_init(priv);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_dev_com_init failed\\n\");\n\t\tgoto error;\n\t}\n\tret = ca8210_reset_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_reset_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tret = ca8210_interrupt_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_interrupt_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tmsleep(100);\n\n\tca8210_reset_send(priv->spi, 1);\n\n\tret = tdme_chipinit(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"tdme_chipinit failed\\n\");\n\t\tgoto error;\n\t}\n\n\tif (pdata->extclockenable) {\n\t\tret = ca8210_config_extern_clk(pdata, priv->spi, 1);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_config_extern_clk failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t\tret = ca8210_register_ext_clock(priv->spi);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_register_ext_clock failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_register_hw failed\\n\");\n\t\tgoto error;\n\t}\n\tpriv->hw_registered = true;\n\n\treturn 0;\nerror:\n\tmsleep(100); /* wait for pending spi transfers to complete */\n\tca8210_remove(spi_device);\n\treturn link_to_linux_err(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,12 +45,12 @@\n \t\tgoto error;\n \t}\n \n+\tpriv->spi->dev.platform_data = pdata;\n \tret = ca8210_get_platform_data(priv->spi, pdata);\n \tif (ret) {\n \t\tdev_crit(&spi_device->dev, \"ca8210_get_platform_data failed\\n\");\n \t\tgoto error;\n \t}\n-\tpriv->spi->dev.platform_data = pdata;\n \n \tret = ca8210_dev_com_init(priv);\n \tif (ret) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpriv->spi->dev.platform_data = pdata;"
            ],
            "added_lines": [
                "\tpriv->spi->dev.platform_data = pdata;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19076",
        "func_name": "torvalds/linux/nfp_abm_u32_knode_replace",
        "description": "A memory leak in the nfp_abm_u32_knode_replace() function in drivers/net/ethernet/netronome/nfp/abm/cls.c in the Linux kernel before 5.3.6 allows attackers to cause a denial of service (memory consumption), aka CID-78beef629fd9. NOTE: This has been argued as not a valid vulnerability. The upstream commit 78beef629fd9 was reverted",
        "git_url": "https://github.com/torvalds/linux/commit/78beef629fd95be4ed853b2d37b832f766bd96ca",
        "commit_title": "nfp: abm: fix memory leak in nfp_abm_u32_knode_replace",
        "commit_text": " In nfp_abm_u32_knode_replace if the allocation for match fails it should go to the error handling instead of returning. Updated other gotos to have correct errno returned, too. ",
        "func_before": "static int\nnfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\n\t/* Extract the DSCP Class Selector bits */\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\n\t/* Check if there is no conflicting mapping and find match by handle */\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\n\treturn 0;\n\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}",
        "func": "static int\nnfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_delete;\n\t}\n\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\n\t/* Extract the DSCP Class Selector bits */\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\n\t/* Check if there is no conflicting mapping and find match by handle */\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_delete;\n\t\t}\n\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\n\treturn 0;\n\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,10 @@\n \tu8 mask, val;\n \tint err;\n \n-\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n+\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) {\n+\t\terr = -EOPNOTSUPP;\n \t\tgoto err_delete;\n+\t}\n \n \ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n \n@@ -30,14 +32,18 @@\n \t\tif ((iter->val & cmask) == (val & cmask) &&\n \t\t    iter->band != knode->res->classid) {\n \t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n+\t\t\terr = -EOPNOTSUPP;\n \t\t\tgoto err_delete;\n \t\t}\n \t}\n \n \tif (!match) {\n \t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n-\t\tif (!match)\n-\t\t\treturn -ENOMEM;\n+\t\tif (!match) {\n+\t\t\terr = -ENOMEM;\n+\t\t\tgoto err_delete;\n+\t\t}\n+\n \t\tlist_add(&match->list, &alink->dscp_map);\n \t}\n \tmatch->handle = knode->handle;\n@@ -53,5 +59,5 @@\n \n err_delete:\n \tnfp_abm_u32_knode_delete(alink, knode);\n-\treturn -EOPNOTSUPP;\n+\treturn err;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))",
                "\t\tif (!match)",
                "\t\t\treturn -ENOMEM;",
                "\treturn -EOPNOTSUPP;"
            ],
            "added_lines": [
                "\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) {",
                "\t\terr = -EOPNOTSUPP;",
                "\t}",
                "\t\t\terr = -EOPNOTSUPP;",
                "\t\tif (!match) {",
                "\t\t\terr = -ENOMEM;",
                "\t\t\tgoto err_delete;",
                "\t\t}",
                "",
                "\treturn err;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19076",
        "func_name": "torvalds/linux/nfp_abm_u32_knode_replace",
        "description": "A memory leak in the nfp_abm_u32_knode_replace() function in drivers/net/ethernet/netronome/nfp/abm/cls.c in the Linux kernel before 5.3.6 allows attackers to cause a denial of service (memory consumption), aka CID-78beef629fd9. NOTE: This has been argued as not a valid vulnerability. The upstream commit 78beef629fd9 was reverted",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=1d1997db870f4058676439ef7014390ba9e24eb2",
        "commit_title": "This reverts commit 78beef629fd9 (\"nfp: abm: fix memory leak in",
        "commit_text": "nfp_abm_u32_knode_replace\").  The quoted commit does not fix anything and resulted in a bogus CVE-2019-19076.  If match is NULL then it is known there is no matching entry in list, hence, calling nfp_abm_u32_knode_delete() is pointless.  ",
        "func_before": "static int\nnfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_delete;\n\t}\n\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\n\t/* Extract the DSCP Class Selector bits */\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\n\t/* Check if there is no conflicting mapping and find match by handle */\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_delete;\n\t\t}\n\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\n\treturn 0;\n\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn err;\n}",
        "func": "static int\nnfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\n\t/* Extract the DSCP Class Selector bits */\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\n\t/* Check if there is no conflicting mapping and find match by handle */\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\n\treturn 0;\n\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,10 +8,8 @@\n \tu8 mask, val;\n \tint err;\n \n-\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) {\n-\t\terr = -EOPNOTSUPP;\n+\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n \t\tgoto err_delete;\n-\t}\n \n \ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n \n@@ -32,18 +30,14 @@\n \t\tif ((iter->val & cmask) == (val & cmask) &&\n \t\t    iter->band != knode->res->classid) {\n \t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n-\t\t\terr = -EOPNOTSUPP;\n \t\t\tgoto err_delete;\n \t\t}\n \t}\n \n \tif (!match) {\n \t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n-\t\tif (!match) {\n-\t\t\terr = -ENOMEM;\n-\t\t\tgoto err_delete;\n-\t\t}\n-\n+\t\tif (!match)\n+\t\t\treturn -ENOMEM;\n \t\tlist_add(&match->list, &alink->dscp_map);\n \t}\n \tmatch->handle = knode->handle;\n@@ -59,5 +53,5 @@\n \n err_delete:\n \tnfp_abm_u32_knode_delete(alink, knode);\n-\treturn err;\n+\treturn -EOPNOTSUPP;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) {",
                "\t\terr = -EOPNOTSUPP;",
                "\t}",
                "\t\t\terr = -EOPNOTSUPP;",
                "\t\tif (!match) {",
                "\t\t\terr = -ENOMEM;",
                "\t\t\tgoto err_delete;",
                "\t\t}",
                "",
                "\treturn err;"
            ],
            "added_lines": [
                "\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))",
                "\t\tif (!match)",
                "\t\t\treturn -ENOMEM;",
                "\treturn -EOPNOTSUPP;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19077",
        "func_name": "torvalds/linux/bnxt_re_create_srq",
        "description": "A memory leak in the bnxt_re_create_srq() function in drivers/infiniband/hw/bnxt_re/ib_verbs.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering copy to udata failures, aka CID-4a9d46a9fe14.",
        "git_url": "https://github.com/torvalds/linux/commit/4a9d46a9fe14401f21df69cea97c62396d5fb053",
        "commit_title": "RDMA: Fix goto target to release the allocated memory",
        "commit_text": " In bnxt_re_create_srq(), when ib_copy_to_udata() fails allocated memory should be released by goto fail.  Link: https://lore.kernel.org/r/20190910222120.16517-1-navid.emamdoost@gmail.com",
        "func_before": "int bnxt_re_create_srq(struct ib_srq *ib_srq,\n\t\t       struct ib_srq_init_attr *srq_init_attr,\n\t\t       struct ib_udata *udata)\n{\n\tstruct ib_pd *ib_pd = ib_srq->pd;\n\tstruct bnxt_re_pd *pd = container_of(ib_pd, struct bnxt_re_pd, ib_pd);\n\tstruct bnxt_re_dev *rdev = pd->rdev;\n\tstruct bnxt_qplib_dev_attr *dev_attr = &rdev->dev_attr;\n\tstruct bnxt_re_srq *srq =\n\t\tcontainer_of(ib_srq, struct bnxt_re_srq, ib_srq);\n\tstruct bnxt_qplib_nq *nq = NULL;\n\tint rc, entries;\n\n\tif (srq_init_attr->attr.max_wr >= dev_attr->max_srq_wqes) {\n\t\tdev_err(rdev_to_dev(rdev), \"Create CQ failed - max exceeded\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (srq_init_attr->srq_type != IB_SRQT_BASIC) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto exit;\n\t}\n\n\tsrq->rdev = rdev;\n\tsrq->qplib_srq.pd = &pd->qplib_pd;\n\tsrq->qplib_srq.dpi = &rdev->dpi_privileged;\n\t/* Allocate 1 more than what's provided so posting max doesn't\n\t * mean empty\n\t */\n\tentries = roundup_pow_of_two(srq_init_attr->attr.max_wr + 1);\n\tif (entries > dev_attr->max_srq_wqes + 1)\n\t\tentries = dev_attr->max_srq_wqes + 1;\n\n\tsrq->qplib_srq.max_wqe = entries;\n\tsrq->qplib_srq.max_sge = srq_init_attr->attr.max_sge;\n\tsrq->qplib_srq.threshold = srq_init_attr->attr.srq_limit;\n\tsrq->srq_limit = srq_init_attr->attr.srq_limit;\n\tsrq->qplib_srq.eventq_hw_ring_id = rdev->nq[0].ring_id;\n\tnq = &rdev->nq[0];\n\n\tif (udata) {\n\t\trc = bnxt_re_init_user_srq(rdev, pd, srq, udata);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\trc = bnxt_qplib_create_srq(&rdev->qplib_res, &srq->qplib_srq);\n\tif (rc) {\n\t\tdev_err(rdev_to_dev(rdev), \"Create HW SRQ failed!\");\n\t\tgoto fail;\n\t}\n\n\tif (udata) {\n\t\tstruct bnxt_re_srq_resp resp;\n\n\t\tresp.srqid = srq->qplib_srq.id;\n\t\trc = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\t\tif (rc) {\n\t\t\tdev_err(rdev_to_dev(rdev), \"SRQ copy to udata failed!\");\n\t\t\tbnxt_qplib_destroy_srq(&rdev->qplib_res,\n\t\t\t\t\t       &srq->qplib_srq);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tif (nq)\n\t\tnq->budget++;\n\tatomic_inc(&rdev->srq_count);\n\n\treturn 0;\n\nfail:\n\tib_umem_release(srq->umem);\nexit:\n\treturn rc;\n}",
        "func": "int bnxt_re_create_srq(struct ib_srq *ib_srq,\n\t\t       struct ib_srq_init_attr *srq_init_attr,\n\t\t       struct ib_udata *udata)\n{\n\tstruct ib_pd *ib_pd = ib_srq->pd;\n\tstruct bnxt_re_pd *pd = container_of(ib_pd, struct bnxt_re_pd, ib_pd);\n\tstruct bnxt_re_dev *rdev = pd->rdev;\n\tstruct bnxt_qplib_dev_attr *dev_attr = &rdev->dev_attr;\n\tstruct bnxt_re_srq *srq =\n\t\tcontainer_of(ib_srq, struct bnxt_re_srq, ib_srq);\n\tstruct bnxt_qplib_nq *nq = NULL;\n\tint rc, entries;\n\n\tif (srq_init_attr->attr.max_wr >= dev_attr->max_srq_wqes) {\n\t\tdev_err(rdev_to_dev(rdev), \"Create CQ failed - max exceeded\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (srq_init_attr->srq_type != IB_SRQT_BASIC) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto exit;\n\t}\n\n\tsrq->rdev = rdev;\n\tsrq->qplib_srq.pd = &pd->qplib_pd;\n\tsrq->qplib_srq.dpi = &rdev->dpi_privileged;\n\t/* Allocate 1 more than what's provided so posting max doesn't\n\t * mean empty\n\t */\n\tentries = roundup_pow_of_two(srq_init_attr->attr.max_wr + 1);\n\tif (entries > dev_attr->max_srq_wqes + 1)\n\t\tentries = dev_attr->max_srq_wqes + 1;\n\n\tsrq->qplib_srq.max_wqe = entries;\n\tsrq->qplib_srq.max_sge = srq_init_attr->attr.max_sge;\n\tsrq->qplib_srq.threshold = srq_init_attr->attr.srq_limit;\n\tsrq->srq_limit = srq_init_attr->attr.srq_limit;\n\tsrq->qplib_srq.eventq_hw_ring_id = rdev->nq[0].ring_id;\n\tnq = &rdev->nq[0];\n\n\tif (udata) {\n\t\trc = bnxt_re_init_user_srq(rdev, pd, srq, udata);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\trc = bnxt_qplib_create_srq(&rdev->qplib_res, &srq->qplib_srq);\n\tif (rc) {\n\t\tdev_err(rdev_to_dev(rdev), \"Create HW SRQ failed!\");\n\t\tgoto fail;\n\t}\n\n\tif (udata) {\n\t\tstruct bnxt_re_srq_resp resp;\n\n\t\tresp.srqid = srq->qplib_srq.id;\n\t\trc = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\t\tif (rc) {\n\t\t\tdev_err(rdev_to_dev(rdev), \"SRQ copy to udata failed!\");\n\t\t\tbnxt_qplib_destroy_srq(&rdev->qplib_res,\n\t\t\t\t\t       &srq->qplib_srq);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (nq)\n\t\tnq->budget++;\n\tatomic_inc(&rdev->srq_count);\n\n\treturn 0;\n\nfail:\n\tib_umem_release(srq->umem);\nexit:\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,7 +60,7 @@\n \t\t\tdev_err(rdev_to_dev(rdev), \"SRQ copy to udata failed!\");\n \t\t\tbnxt_qplib_destroy_srq(&rdev->qplib_res,\n \t\t\t\t\t       &srq->qplib_srq);\n-\t\t\tgoto exit;\n+\t\t\tgoto fail;\n \t\t}\n \t}\n \tif (nq)",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tgoto exit;"
            ],
            "added_lines": [
                "\t\t\tgoto fail;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19078",
        "func_name": "torvalds/linux/ath10k_usb_hif_tx_sg",
        "description": "A memory leak in the ath10k_usb_hif_tx_sg() function in drivers/net/wireless/ath/ath10k/usb.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-b8d17e7d93d2.",
        "git_url": "https://github.com/torvalds/linux/commit/b8d17e7d93d2beb89e4f34c59996376b8b544792",
        "commit_title": "ath10k: fix memory leak",
        "commit_text": " In ath10k_usb_hif_tx_sg the allocated urb should be released if usb_submit_urb fails. ",
        "func_before": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\t/* hit a max packet boundary on this pipe */\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn 0;\n\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}",
        "func": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\t/* hit a max packet boundary on this pipe */\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn 0;\n\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,6 +42,7 @@\n \t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n \t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n \t\t\tusb_unanchor_urb(urb);\n+\t\t\tusb_free_urb(urb);\n \t\t\tret = -EINVAL;\n \t\t\tgoto err_free_urb_to_pipe;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tusb_free_urb(urb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19079",
        "func_name": "torvalds/linux/qrtr_tun_write_iter",
        "description": "A memory leak in the qrtr_tun_write_iter() function in net/qrtr/tun.c in the Linux kernel before 5.3 allows attackers to cause a denial of service (memory consumption), aka CID-a21b7f0cff19.",
        "git_url": "https://github.com/torvalds/linux/commit/a21b7f0cff1906a93a0130b74713b15a0b36481d",
        "commit_title": "net: qrtr: fix memort leak in qrtr_tun_write_iter",
        "commit_text": " In qrtr_tun_write_iter the allocated kbuf should be release in case of error or success return.  v2 Update: Thanks to David Miller for pointing out the release on success path as well. ",
        "func_before": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\n\treturn ret < 0 ? ret : len;\n}",
        "func": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tkfree(kbuf);\n\t\treturn -EFAULT;\n\t}\n\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,10 +10,13 @@\n \tif (!kbuf)\n \t\treturn -ENOMEM;\n \n-\tif (!copy_from_iter_full(kbuf, len, from))\n+\tif (!copy_from_iter_full(kbuf, len, from)) {\n+\t\tkfree(kbuf);\n \t\treturn -EFAULT;\n+\t}\n \n \tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n \n+\tkfree(kbuf);\n \treturn ret < 0 ? ret : len;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!copy_from_iter_full(kbuf, len, from))"
            ],
            "added_lines": [
                "\tif (!copy_from_iter_full(kbuf, len, from)) {",
                "\t\tkfree(kbuf);",
                "\t}",
                "\tkfree(kbuf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19080",
        "func_name": "torvalds/linux/nfp_flower_spawn_phy_reprs",
        "description": "Four memory leaks in the nfp_flower_spawn_phy_reprs() function in drivers/net/ethernet/netronome/nfp/flower/main.c in the Linux kernel before 5.3.4 allow attackers to cause a denial of service (memory consumption), aka CID-8572cea1461a.",
        "git_url": "https://github.com/torvalds/linux/commit/8572cea1461a006bce1d06c0c4b0575869125fa4",
        "commit_title": "nfp: flower: prevent memory leak in nfp_flower_spawn_phy_reprs",
        "commit_text": " In nfp_flower_spawn_phy_reprs, in the for loop over eth_tbl if any of intermediate allocations or initializations fail memory is leaked. requiered releases are added. ",
        "func_before": "static int\nnfp_flower_spawn_phy_reprs(struct nfp_app *app, struct nfp_flower_priv *priv)\n{\n\tstruct nfp_eth_table *eth_tbl = app->pf->eth_tbl;\n\tatomic_t *replies = &priv->reify_replies;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tstruct nfp_repr *nfp_repr;\n\tstruct sk_buff *ctrl_skb;\n\tstruct nfp_reprs *reprs;\n\tint err, reify_cnt;\n\tunsigned int i;\n\n\tctrl_skb = nfp_flower_cmsg_mac_repr_start(app, eth_tbl->count);\n\tif (!ctrl_skb)\n\t\treturn -ENOMEM;\n\n\treprs = nfp_reprs_alloc(eth_tbl->max_index + 1);\n\tif (!reprs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_ctrl_skb;\n\t}\n\n\tfor (i = 0; i < eth_tbl->count; i++) {\n\t\tunsigned int phys_port = eth_tbl->ports[i].index;\n\t\tstruct net_device *repr;\n\t\tstruct nfp_port *port;\n\t\tu32 cmsg_port_id;\n\n\t\trepr = nfp_repr_alloc(app);\n\t\tif (!repr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\trepr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);\n\t\tif (!repr_priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_repr = netdev_priv(repr);\n\t\tnfp_repr->app_priv = repr_priv;\n\t\trepr_priv->nfp_repr = nfp_repr;\n\n\t\tport = nfp_port_alloc(app, NFP_PORT_PHYS_PORT, repr);\n\t\tif (IS_ERR(port)) {\n\t\t\terr = PTR_ERR(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\t\terr = nfp_port_init_phy_port(app->pf, app, port, i);\n\t\tif (err) {\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tSET_NETDEV_DEV(repr, &priv->nn->pdev->dev);\n\t\tnfp_net_get_mac_addr(app->pf, repr, port);\n\n\t\tcmsg_port_id = nfp_flower_cmsg_phys_port(phys_port);\n\t\terr = nfp_repr_init(app, repr,\n\t\t\t\t    cmsg_port_id, port, priv->nn->dp.netdev);\n\t\tif (err) {\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_flower_cmsg_mac_repr_add(ctrl_skb, i,\n\t\t\t\t\t     eth_tbl->ports[i].nbi,\n\t\t\t\t\t     eth_tbl->ports[i].base,\n\t\t\t\t\t     phys_port);\n\n\t\tRCU_INIT_POINTER(reprs->reprs[phys_port], repr);\n\t\tnfp_info(app->cpp, \"Phys Port %d Representor(%s) created\\n\",\n\t\t\t phys_port, repr->name);\n\t}\n\n\tnfp_app_reprs_set(app, NFP_REPR_TYPE_PHYS_PORT, reprs);\n\n\t/* The REIFY/MAC_REPR control messages should be sent after the MAC\n\t * representors are registered using nfp_app_reprs_set().  This is\n\t * because the firmware may respond with control messages for the\n\t * MAC representors, f.e. to provide the driver with information\n\t * about their state, and without registration the driver will drop\n\t * any such messages.\n\t */\n\tatomic_set(replies, 0);\n\treify_cnt = nfp_flower_reprs_reify(app, NFP_REPR_TYPE_PHYS_PORT, true);\n\tif (reify_cnt < 0) {\n\t\terr = reify_cnt;\n\t\tnfp_warn(app->cpp, \"Failed to notify firmware about repr creation\\n\");\n\t\tgoto err_reprs_remove;\n\t}\n\n\terr = nfp_flower_wait_repr_reify(app, replies, reify_cnt);\n\tif (err)\n\t\tgoto err_reprs_remove;\n\n\tnfp_ctrl_tx(app->ctrl, ctrl_skb);\n\n\treturn 0;\nerr_reprs_remove:\n\treprs = nfp_app_reprs_set(app, NFP_REPR_TYPE_PHYS_PORT, NULL);\nerr_reprs_clean:\n\tnfp_reprs_clean_and_free(app, reprs);\nerr_free_ctrl_skb:\n\tkfree_skb(ctrl_skb);\n\treturn err;\n}",
        "func": "static int\nnfp_flower_spawn_phy_reprs(struct nfp_app *app, struct nfp_flower_priv *priv)\n{\n\tstruct nfp_eth_table *eth_tbl = app->pf->eth_tbl;\n\tatomic_t *replies = &priv->reify_replies;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tstruct nfp_repr *nfp_repr;\n\tstruct sk_buff *ctrl_skb;\n\tstruct nfp_reprs *reprs;\n\tint err, reify_cnt;\n\tunsigned int i;\n\n\tctrl_skb = nfp_flower_cmsg_mac_repr_start(app, eth_tbl->count);\n\tif (!ctrl_skb)\n\t\treturn -ENOMEM;\n\n\treprs = nfp_reprs_alloc(eth_tbl->max_index + 1);\n\tif (!reprs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_ctrl_skb;\n\t}\n\n\tfor (i = 0; i < eth_tbl->count; i++) {\n\t\tunsigned int phys_port = eth_tbl->ports[i].index;\n\t\tstruct net_device *repr;\n\t\tstruct nfp_port *port;\n\t\tu32 cmsg_port_id;\n\n\t\trepr = nfp_repr_alloc(app);\n\t\tif (!repr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\trepr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);\n\t\tif (!repr_priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_repr = netdev_priv(repr);\n\t\tnfp_repr->app_priv = repr_priv;\n\t\trepr_priv->nfp_repr = nfp_repr;\n\n\t\tport = nfp_port_alloc(app, NFP_PORT_PHYS_PORT, repr);\n\t\tif (IS_ERR(port)) {\n\t\t\terr = PTR_ERR(port);\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\t\terr = nfp_port_init_phy_port(app->pf, app, port, i);\n\t\tif (err) {\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tSET_NETDEV_DEV(repr, &priv->nn->pdev->dev);\n\t\tnfp_net_get_mac_addr(app->pf, repr, port);\n\n\t\tcmsg_port_id = nfp_flower_cmsg_phys_port(phys_port);\n\t\terr = nfp_repr_init(app, repr,\n\t\t\t\t    cmsg_port_id, port, priv->nn->dp.netdev);\n\t\tif (err) {\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_flower_cmsg_mac_repr_add(ctrl_skb, i,\n\t\t\t\t\t     eth_tbl->ports[i].nbi,\n\t\t\t\t\t     eth_tbl->ports[i].base,\n\t\t\t\t\t     phys_port);\n\n\t\tRCU_INIT_POINTER(reprs->reprs[phys_port], repr);\n\t\tnfp_info(app->cpp, \"Phys Port %d Representor(%s) created\\n\",\n\t\t\t phys_port, repr->name);\n\t}\n\n\tnfp_app_reprs_set(app, NFP_REPR_TYPE_PHYS_PORT, reprs);\n\n\t/* The REIFY/MAC_REPR control messages should be sent after the MAC\n\t * representors are registered using nfp_app_reprs_set().  This is\n\t * because the firmware may respond with control messages for the\n\t * MAC representors, f.e. to provide the driver with information\n\t * about their state, and without registration the driver will drop\n\t * any such messages.\n\t */\n\tatomic_set(replies, 0);\n\treify_cnt = nfp_flower_reprs_reify(app, NFP_REPR_TYPE_PHYS_PORT, true);\n\tif (reify_cnt < 0) {\n\t\terr = reify_cnt;\n\t\tnfp_warn(app->cpp, \"Failed to notify firmware about repr creation\\n\");\n\t\tgoto err_reprs_remove;\n\t}\n\n\terr = nfp_flower_wait_repr_reify(app, replies, reify_cnt);\n\tif (err)\n\t\tgoto err_reprs_remove;\n\n\tnfp_ctrl_tx(app->ctrl, ctrl_skb);\n\n\treturn 0;\nerr_reprs_remove:\n\treprs = nfp_app_reprs_set(app, NFP_REPR_TYPE_PHYS_PORT, NULL);\nerr_reprs_clean:\n\tnfp_reprs_clean_and_free(app, reprs);\nerr_free_ctrl_skb:\n\tkfree_skb(ctrl_skb);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,7 @@\n \t\trepr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);\n \t\tif (!repr_priv) {\n \t\t\terr = -ENOMEM;\n+\t\t\tnfp_repr_free(repr);\n \t\t\tgoto err_reprs_clean;\n \t\t}\n \n@@ -45,11 +46,13 @@\n \t\tport = nfp_port_alloc(app, NFP_PORT_PHYS_PORT, repr);\n \t\tif (IS_ERR(port)) {\n \t\t\terr = PTR_ERR(port);\n+\t\t\tkfree(repr_priv);\n \t\t\tnfp_repr_free(repr);\n \t\t\tgoto err_reprs_clean;\n \t\t}\n \t\terr = nfp_port_init_phy_port(app->pf, app, port, i);\n \t\tif (err) {\n+\t\t\tkfree(repr_priv);\n \t\t\tnfp_port_free(port);\n \t\t\tnfp_repr_free(repr);\n \t\t\tgoto err_reprs_clean;\n@@ -62,6 +65,7 @@\n \t\terr = nfp_repr_init(app, repr,\n \t\t\t\t    cmsg_port_id, port, priv->nn->dp.netdev);\n \t\tif (err) {\n+\t\t\tkfree(repr_priv);\n \t\t\tnfp_port_free(port);\n \t\t\tnfp_repr_free(repr);\n \t\t\tgoto err_reprs_clean;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tnfp_repr_free(repr);",
                "\t\t\tkfree(repr_priv);",
                "\t\t\tkfree(repr_priv);",
                "\t\t\tkfree(repr_priv);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19081",
        "func_name": "torvalds/linux/nfp_flower_spawn_vnic_reprs",
        "description": "A memory leak in the nfp_flower_spawn_vnic_reprs() function in drivers/net/ethernet/netronome/nfp/flower/main.c in the Linux kernel before 5.3.4 allows attackers to cause a denial of service (memory consumption), aka CID-8ce39eb5a67a.",
        "git_url": "https://github.com/torvalds/linux/commit/8ce39eb5a67aee25d9f05b40b673c95b23502e3e",
        "commit_title": "nfp: flower: fix memory leak in nfp_flower_spawn_vnic_reprs",
        "commit_text": " In nfp_flower_spawn_vnic_reprs in the loop if initialization or the allocations fail memory is leaked. Appropriate releases are added. ",
        "func_before": "static int\nnfp_flower_spawn_vnic_reprs(struct nfp_app *app,\n\t\t\t    enum nfp_flower_cmsg_port_vnic_type vnic_type,\n\t\t\t    enum nfp_repr_type repr_type, unsigned int cnt)\n{\n\tu8 nfp_pcie = nfp_cppcore_pcie_unit(app->pf->cpp);\n\tstruct nfp_flower_priv *priv = app->priv;\n\tatomic_t *replies = &priv->reify_replies;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tenum nfp_port_type port_type;\n\tstruct nfp_repr *nfp_repr;\n\tstruct nfp_reprs *reprs;\n\tint i, err, reify_cnt;\n\tconst u8 queue = 0;\n\n\tport_type = repr_type == NFP_REPR_TYPE_PF ? NFP_PORT_PF_PORT :\n\t\t\t\t\t\t    NFP_PORT_VF_PORT;\n\n\treprs = nfp_reprs_alloc(cnt);\n\tif (!reprs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct net_device *repr;\n\t\tstruct nfp_port *port;\n\t\tu32 port_id;\n\n\t\trepr = nfp_repr_alloc(app);\n\t\tif (!repr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\trepr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);\n\t\tif (!repr_priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_repr = netdev_priv(repr);\n\t\tnfp_repr->app_priv = repr_priv;\n\t\trepr_priv->nfp_repr = nfp_repr;\n\n\t\t/* For now we only support 1 PF */\n\t\tWARN_ON(repr_type == NFP_REPR_TYPE_PF && i);\n\n\t\tport = nfp_port_alloc(app, port_type, repr);\n\t\tif (IS_ERR(port)) {\n\t\t\terr = PTR_ERR(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\t\tif (repr_type == NFP_REPR_TYPE_PF) {\n\t\t\tport->pf_id = i;\n\t\t\tport->vnic = priv->nn->dp.ctrl_bar;\n\t\t} else {\n\t\t\tport->pf_id = 0;\n\t\t\tport->vf_id = i;\n\t\t\tport->vnic =\n\t\t\t\tapp->pf->vf_cfg_mem + i * NFP_NET_CFG_BAR_SZ;\n\t\t}\n\n\t\teth_hw_addr_random(repr);\n\n\t\tport_id = nfp_flower_cmsg_pcie_port(nfp_pcie, vnic_type,\n\t\t\t\t\t\t    i, queue);\n\t\terr = nfp_repr_init(app, repr,\n\t\t\t\t    port_id, port, priv->nn->dp.netdev);\n\t\tif (err) {\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tRCU_INIT_POINTER(reprs->reprs[i], repr);\n\t\tnfp_info(app->cpp, \"%s%d Representor(%s) created\\n\",\n\t\t\t repr_type == NFP_REPR_TYPE_PF ? \"PF\" : \"VF\", i,\n\t\t\t repr->name);\n\t}\n\n\tnfp_app_reprs_set(app, repr_type, reprs);\n\n\tatomic_set(replies, 0);\n\treify_cnt = nfp_flower_reprs_reify(app, repr_type, true);\n\tif (reify_cnt < 0) {\n\t\terr = reify_cnt;\n\t\tnfp_warn(app->cpp, \"Failed to notify firmware about repr creation\\n\");\n\t\tgoto err_reprs_remove;\n\t}\n\n\terr = nfp_flower_wait_repr_reify(app, replies, reify_cnt);\n\tif (err)\n\t\tgoto err_reprs_remove;\n\n\treturn 0;\nerr_reprs_remove:\n\treprs = nfp_app_reprs_set(app, repr_type, NULL);\nerr_reprs_clean:\n\tnfp_reprs_clean_and_free(app, reprs);\n\treturn err;\n}",
        "func": "static int\nnfp_flower_spawn_vnic_reprs(struct nfp_app *app,\n\t\t\t    enum nfp_flower_cmsg_port_vnic_type vnic_type,\n\t\t\t    enum nfp_repr_type repr_type, unsigned int cnt)\n{\n\tu8 nfp_pcie = nfp_cppcore_pcie_unit(app->pf->cpp);\n\tstruct nfp_flower_priv *priv = app->priv;\n\tatomic_t *replies = &priv->reify_replies;\n\tstruct nfp_flower_repr_priv *repr_priv;\n\tenum nfp_port_type port_type;\n\tstruct nfp_repr *nfp_repr;\n\tstruct nfp_reprs *reprs;\n\tint i, err, reify_cnt;\n\tconst u8 queue = 0;\n\n\tport_type = repr_type == NFP_REPR_TYPE_PF ? NFP_PORT_PF_PORT :\n\t\t\t\t\t\t    NFP_PORT_VF_PORT;\n\n\treprs = nfp_reprs_alloc(cnt);\n\tif (!reprs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct net_device *repr;\n\t\tstruct nfp_port *port;\n\t\tu32 port_id;\n\n\t\trepr = nfp_repr_alloc(app);\n\t\tif (!repr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\trepr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);\n\t\tif (!repr_priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tnfp_repr = netdev_priv(repr);\n\t\tnfp_repr->app_priv = repr_priv;\n\t\trepr_priv->nfp_repr = nfp_repr;\n\n\t\t/* For now we only support 1 PF */\n\t\tWARN_ON(repr_type == NFP_REPR_TYPE_PF && i);\n\n\t\tport = nfp_port_alloc(app, port_type, repr);\n\t\tif (IS_ERR(port)) {\n\t\t\terr = PTR_ERR(port);\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\t\tif (repr_type == NFP_REPR_TYPE_PF) {\n\t\t\tport->pf_id = i;\n\t\t\tport->vnic = priv->nn->dp.ctrl_bar;\n\t\t} else {\n\t\t\tport->pf_id = 0;\n\t\t\tport->vf_id = i;\n\t\t\tport->vnic =\n\t\t\t\tapp->pf->vf_cfg_mem + i * NFP_NET_CFG_BAR_SZ;\n\t\t}\n\n\t\teth_hw_addr_random(repr);\n\n\t\tport_id = nfp_flower_cmsg_pcie_port(nfp_pcie, vnic_type,\n\t\t\t\t\t\t    i, queue);\n\t\terr = nfp_repr_init(app, repr,\n\t\t\t\t    port_id, port, priv->nn->dp.netdev);\n\t\tif (err) {\n\t\t\tkfree(repr_priv);\n\t\t\tnfp_port_free(port);\n\t\t\tnfp_repr_free(repr);\n\t\t\tgoto err_reprs_clean;\n\t\t}\n\n\t\tRCU_INIT_POINTER(reprs->reprs[i], repr);\n\t\tnfp_info(app->cpp, \"%s%d Representor(%s) created\\n\",\n\t\t\t repr_type == NFP_REPR_TYPE_PF ? \"PF\" : \"VF\", i,\n\t\t\t repr->name);\n\t}\n\n\tnfp_app_reprs_set(app, repr_type, reprs);\n\n\tatomic_set(replies, 0);\n\treify_cnt = nfp_flower_reprs_reify(app, repr_type, true);\n\tif (reify_cnt < 0) {\n\t\terr = reify_cnt;\n\t\tnfp_warn(app->cpp, \"Failed to notify firmware about repr creation\\n\");\n\t\tgoto err_reprs_remove;\n\t}\n\n\terr = nfp_flower_wait_repr_reify(app, replies, reify_cnt);\n\tif (err)\n\t\tgoto err_reprs_remove;\n\n\treturn 0;\nerr_reprs_remove:\n\treprs = nfp_app_reprs_set(app, repr_type, NULL);\nerr_reprs_clean:\n\tnfp_reprs_clean_and_free(app, reprs);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,6 +34,7 @@\n \t\trepr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);\n \t\tif (!repr_priv) {\n \t\t\terr = -ENOMEM;\n+\t\t\tnfp_repr_free(repr);\n \t\t\tgoto err_reprs_clean;\n \t\t}\n \n@@ -47,6 +48,7 @@\n \t\tport = nfp_port_alloc(app, port_type, repr);\n \t\tif (IS_ERR(port)) {\n \t\t\terr = PTR_ERR(port);\n+\t\t\tkfree(repr_priv);\n \t\t\tnfp_repr_free(repr);\n \t\t\tgoto err_reprs_clean;\n \t\t}\n@@ -67,6 +69,7 @@\n \t\terr = nfp_repr_init(app, repr,\n \t\t\t\t    port_id, port, priv->nn->dp.netdev);\n \t\tif (err) {\n+\t\t\tkfree(repr_priv);\n \t\t\tnfp_port_free(port);\n \t\t\tnfp_repr_free(repr);\n \t\t\tgoto err_reprs_clean;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tnfp_repr_free(repr);",
                "\t\t\tkfree(repr_priv);",
                "\t\t\tkfree(repr_priv);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19082",
        "func_name": "torvalds/linux/dcn10_create_resource_pool",
        "description": "Memory leaks in *create_resource_pool() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption). This affects the dce120_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, the dce100_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, and the dce112_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, aka CID-104c307147ad.",
        "git_url": "https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d",
        "commit_title": "drm/amd/display: prevent memory leak",
        "commit_text": " In dcn*_create_resource_pool the allocated memory should be released if construct pool fails. ",
        "func_before": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,7 @@\n \tif (construct(init_data->num_virtual_links, dc, pool))\n \t\treturn &pool->base;\n \n+\tkfree(pool);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(pool);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19082",
        "func_name": "torvalds/linux/dce120_create_resource_pool",
        "description": "Memory leaks in *create_resource_pool() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption). This affects the dce120_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, the dce100_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, and the dce112_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, aka CID-104c307147ad.",
        "git_url": "https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d",
        "commit_title": "drm/amd/display: prevent memory leak",
        "commit_text": " In dcn*_create_resource_pool the allocated memory should be released if construct pool fails. ",
        "func_before": "struct resource_pool *dce120_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct resource_pool *dce120_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,7 @@\n \tif (construct(num_virtual_links, dc, pool))\n \t\treturn &pool->base;\n \n+\tkfree(pool);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(pool);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19082",
        "func_name": "torvalds/linux/dce110_create_resource_pool",
        "description": "Memory leaks in *create_resource_pool() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption). This affects the dce120_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, the dce100_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, and the dce112_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, aka CID-104c307147ad.",
        "git_url": "https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d",
        "commit_title": "drm/amd/display: prevent memory leak",
        "commit_text": " In dcn*_create_resource_pool the allocated memory should be released if construct pool fails. ",
        "func_before": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n \tif (construct(num_virtual_links, dc, pool, asic_id))\n \t\treturn &pool->base;\n \n+\tkfree(pool);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(pool);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19082",
        "func_name": "torvalds/linux/dce100_create_resource_pool",
        "description": "Memory leaks in *create_resource_pool() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption). This affects the dce120_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, the dce100_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, and the dce112_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, aka CID-104c307147ad.",
        "git_url": "https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d",
        "commit_title": "drm/amd/display: prevent memory leak",
        "commit_text": " In dcn*_create_resource_pool the allocated memory should be released if construct pool fails. ",
        "func_before": "struct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,7 @@\n \tif (construct(num_virtual_links, dc, pool))\n \t\treturn &pool->base;\n \n+\tkfree(pool);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(pool);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19082",
        "func_name": "torvalds/linux/dce112_create_resource_pool",
        "description": "Memory leaks in *create_resource_pool() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption). This affects the dce120_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, the dce100_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, and the dce112_create_resource_pool() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, aka CID-104c307147ad.",
        "git_url": "https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d",
        "commit_title": "drm/amd/display: prevent memory leak",
        "commit_text": " In dcn*_create_resource_pool the allocated memory should be released if construct pool fails. ",
        "func_before": "struct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,7 @@\n \tif (construct(num_virtual_links, dc, pool))\n \t\treturn &pool->base;\n \n+\tkfree(pool);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(pool);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19083",
        "func_name": "torvalds/linux/dce80_clock_source_create",
        "description": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.",
        "git_url": "https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12",
        "commit_title": "drm/amd/display: memory leak",
        "commit_text": " In dcn*_clock_source_create when dcn20_clk_src_construct fails allocated clk_src needs release. ",
        "func_before": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \t\treturn &clk_src->base;\n \t}\n \n+\tkfree(clk_src);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(clk_src);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19083",
        "func_name": "torvalds/linux/dcn10_clock_source_create",
        "description": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.",
        "git_url": "https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12",
        "commit_title": "drm/amd/display: memory leak",
        "commit_text": " In dcn*_clock_source_create when dcn20_clk_src_construct fails allocated clk_src needs release. ",
        "func_before": "struct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \t\treturn &clk_src->base;\n \t}\n \n+\tkfree(clk_src);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(clk_src);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19083",
        "func_name": "torvalds/linux/dcn20_clock_source_create",
        "description": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.",
        "git_url": "https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12",
        "commit_title": "drm/amd/display: memory leak",
        "commit_text": " In dcn*_clock_source_create when dcn20_clk_src_construct fails allocated clk_src needs release. ",
        "func_before": "struct clock_source *dcn20_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct clock_source *dcn20_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \t\treturn &clk_src->base;\n \t}\n \n+\tkfree(clk_src);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(clk_src);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19083",
        "func_name": "torvalds/linux/dce120_clock_source_create",
        "description": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.",
        "git_url": "https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12",
        "commit_title": "drm/amd/display: memory leak",
        "commit_text": " In dcn*_clock_source_create when dcn20_clk_src_construct fails allocated clk_src needs release. ",
        "func_before": "static struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "static struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \t\treturn &clk_src->base;\n \t}\n \n+\tkfree(clk_src);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(clk_src);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19083",
        "func_name": "torvalds/linux/dce110_clock_source_create",
        "description": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.",
        "git_url": "https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12",
        "commit_title": "drm/amd/display: memory leak",
        "commit_text": " In dcn*_clock_source_create when dcn20_clk_src_construct fails allocated clk_src needs release. ",
        "func_before": "struct clock_source *dce110_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct clock_source *dce110_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \t\treturn &clk_src->base;\n \t}\n \n+\tkfree(clk_src);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(clk_src);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19083",
        "func_name": "torvalds/linux/dce100_clock_source_create",
        "description": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.",
        "git_url": "https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12",
        "commit_title": "drm/amd/display: memory leak",
        "commit_text": " In dcn*_clock_source_create when dcn20_clk_src_construct fails allocated clk_src needs release. ",
        "func_before": "struct clock_source *dce100_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct clock_source *dce100_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \t\treturn &clk_src->base;\n \t}\n \n+\tkfree(clk_src);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(clk_src);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19083",
        "func_name": "torvalds/linux/dce112_clock_source_create",
        "description": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.",
        "git_url": "https://github.com/torvalds/linux/commit/055e547478a11a6360c7ce05e2afc3e366968a12",
        "commit_title": "drm/amd/display: memory leak",
        "commit_text": " In dcn*_clock_source_create when dcn20_clk_src_construct fails allocated clk_src needs release. ",
        "func_before": "struct clock_source *dce112_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "func": "struct clock_source *dce112_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \t\treturn &clk_src->base;\n \t}\n \n+\tkfree(clk_src);\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(clk_src);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46854",
        "func_name": "proftpd/radius_add_passwd",
        "description": "mod_radius in ProFTPD before 1.3.7c allows memory disclosure to RADIUS servers because it copies blocks of 16 characters.",
        "git_url": "https://github.com/proftpd/proftpd/commit/10a227b4d50e0a2cd2faf87926f58d865da44e43",
        "commit_title": "mod_radius: copy _only_ the password",
        "commit_text": "",
        "func_before": "static void radius_add_passwd(radius_packet_t *packet, unsigned char type,\n    const unsigned char *passwd, unsigned char *secret, size_t secret_len) {\n  MD5_CTX ctx, secret_ctx;\n  radius_attrib_t *attrib = NULL;\n  unsigned char calculated[RADIUS_VECTOR_LEN];\n  unsigned char pwhash[PR_TUNABLE_BUFFER_SIZE];\n  unsigned char *digest = NULL;\n  register unsigned int i = 0;\n  size_t pwlen;\n\n  pwlen = strlen((const char *) passwd);\n\n  if (pwlen == 0) {\n    pwlen = RADIUS_PASSWD_LEN;\n\n  } if ((pwlen & (RADIUS_PASSWD_LEN - 1)) != 0) {\n\n    /* Round up the length. */\n    pwlen += (RADIUS_PASSWD_LEN - 1);\n\n    /* Truncate the length, as necessary. */\n    pwlen &= ~(RADIUS_PASSWD_LEN - 1);\n  }\n\n  /* Clear the buffers. */\n  memset(pwhash, '\\0', sizeof(pwhash));\n  memcpy(pwhash, passwd, pwlen);\n\n  /* Find the password attribute. */\n  attrib = radius_get_attrib(packet, RADIUS_PASSWORD);\n\n  if (type == RADIUS_PASSWORD) {\n    digest = packet->digest;\n\n  } else {\n    digest = attrib->data;\n  }\n\n  /* Encrypt the password.  Password: c[0] = p[0] ^ MD5(secret + digest) */\n  MD5_Init(&secret_ctx);\n  MD5_Update(&secret_ctx, secret, secret_len);\n\n  /* Save this hash for later. */\n  ctx = secret_ctx;\n\n  MD5_Update(&ctx, digest, RADIUS_VECTOR_LEN);\n\n  /* Set the calculated digest. */\n  MD5_Final(calculated, &ctx);\n\n  /* XOR the results. */\n  radius_xor(pwhash, calculated, RADIUS_PASSWD_LEN);\n  \n  /* For each step through: e[i] = p[i] ^ MD5(secret + e[i-1]) */\n  for (i = 1; i < (pwlen >> 4); i++) {\n\n    /* Start with the old value of the MD5 sum. */\n    ctx = secret_ctx;\n\n    MD5_Update(&ctx, &pwhash[(i-1) * RADIUS_PASSWD_LEN], RADIUS_PASSWD_LEN);\n\n    /* Set the calculated digest. */\n    MD5_Final(calculated, &ctx);\n\n    /* XOR the results. */\n    radius_xor(&pwhash[i * RADIUS_PASSWD_LEN], calculated, RADIUS_PASSWD_LEN);\n  }\n\n  if (type == RADIUS_OLD_PASSWORD) {\n    attrib = radius_get_attrib(packet, RADIUS_OLD_PASSWORD);\n  }\n \n  if (attrib == NULL) {\n    radius_add_attrib(packet, type, pwhash, pwlen);\n\n  } else {\n    /* Overwrite the packet data. */\n    memcpy(attrib->data, pwhash, pwlen);\n  }\n\n  pr_memscrub(pwhash, sizeof(pwhash));\n}",
        "func": "static void radius_add_passwd(radius_packet_t *packet, unsigned char type,\n    const unsigned char *passwd, unsigned char *secret, size_t secret_len) {\n  MD5_CTX ctx, secret_ctx;\n  radius_attrib_t *attrib = NULL;\n  unsigned char calculated[RADIUS_VECTOR_LEN];\n  unsigned char pwhash[PR_TUNABLE_BUFFER_SIZE];\n  unsigned char *digest = NULL;\n  register unsigned int i = 0;\n  size_t pwlen;\n\n  pwlen = strlen((const char *) passwd);\n\n  /* Clear the buffers. */\n  memset(pwhash, '\\0', sizeof(pwhash));\n\n  if (pwlen == 0) {\n    pwlen = RADIUS_PASSWD_LEN;\n\n  } if ((pwlen & (RADIUS_PASSWD_LEN - 1)) != 0) {\n    /* pwlen is not a multiple of RADIUS_PASSWD_LEN, need to prepare a proper buffer */\n    memcpy(pwhash, passwd, pwlen);\n\n    /* Round up the length. */\n    pwlen += (RADIUS_PASSWD_LEN - 1);\n\n    /* Truncate the length, as necessary. */\n    pwlen &= ~(RADIUS_PASSWD_LEN - 1);\n  } else {\n    /* pwlen is a multiple of RADIUS_PASSWD_LEN, we can just use it. */\n    memcpy(pwhash, passwd, pwlen);\n  }\n\n\n  /* Find the password attribute. */\n  attrib = radius_get_attrib(packet, RADIUS_PASSWORD);\n\n  if (type == RADIUS_PASSWORD) {\n    digest = packet->digest;\n\n  } else {\n    digest = attrib->data;\n  }\n\n  /* Encrypt the password.  Password: c[0] = p[0] ^ MD5(secret + digest) */\n  MD5_Init(&secret_ctx);\n  MD5_Update(&secret_ctx, secret, secret_len);\n\n  /* Save this hash for later. */\n  ctx = secret_ctx;\n\n  MD5_Update(&ctx, digest, RADIUS_VECTOR_LEN);\n\n  /* Set the calculated digest. */\n  MD5_Final(calculated, &ctx);\n\n  /* XOR the results. */\n  radius_xor(pwhash, calculated, RADIUS_PASSWD_LEN);\n  \n  /* For each step through: e[i] = p[i] ^ MD5(secret + e[i-1]) */\n  for (i = 1; i < (pwlen >> 4); i++) {\n\n    /* Start with the old value of the MD5 sum. */\n    ctx = secret_ctx;\n\n    MD5_Update(&ctx, &pwhash[(i-1) * RADIUS_PASSWD_LEN], RADIUS_PASSWD_LEN);\n\n    /* Set the calculated digest. */\n    MD5_Final(calculated, &ctx);\n\n    /* XOR the results. */\n    radius_xor(&pwhash[i * RADIUS_PASSWD_LEN], calculated, RADIUS_PASSWD_LEN);\n  }\n\n  if (type == RADIUS_OLD_PASSWORD) {\n    attrib = radius_get_attrib(packet, RADIUS_OLD_PASSWORD);\n  }\n \n  if (attrib == NULL) {\n    radius_add_attrib(packet, type, pwhash, pwlen);\n\n  } else {\n    /* Overwrite the packet data. */\n    memcpy(attrib->data, pwhash, pwlen);\n  }\n\n  pr_memscrub(pwhash, sizeof(pwhash));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,21 +10,26 @@\n \n   pwlen = strlen((const char *) passwd);\n \n+  /* Clear the buffers. */\n+  memset(pwhash, '\\0', sizeof(pwhash));\n+\n   if (pwlen == 0) {\n     pwlen = RADIUS_PASSWD_LEN;\n \n   } if ((pwlen & (RADIUS_PASSWD_LEN - 1)) != 0) {\n+    /* pwlen is not a multiple of RADIUS_PASSWD_LEN, need to prepare a proper buffer */\n+    memcpy(pwhash, passwd, pwlen);\n \n     /* Round up the length. */\n     pwlen += (RADIUS_PASSWD_LEN - 1);\n \n     /* Truncate the length, as necessary. */\n     pwlen &= ~(RADIUS_PASSWD_LEN - 1);\n+  } else {\n+    /* pwlen is a multiple of RADIUS_PASSWD_LEN, we can just use it. */\n+    memcpy(pwhash, passwd, pwlen);\n   }\n \n-  /* Clear the buffers. */\n-  memset(pwhash, '\\0', sizeof(pwhash));\n-  memcpy(pwhash, passwd, pwlen);\n \n   /* Find the password attribute. */\n   attrib = radius_get_attrib(packet, RADIUS_PASSWORD);",
        "diff_line_info": {
            "deleted_lines": [
                "  /* Clear the buffers. */",
                "  memset(pwhash, '\\0', sizeof(pwhash));",
                "  memcpy(pwhash, passwd, pwlen);"
            ],
            "added_lines": [
                "  /* Clear the buffers. */",
                "  memset(pwhash, '\\0', sizeof(pwhash));",
                "",
                "    /* pwlen is not a multiple of RADIUS_PASSWD_LEN, need to prepare a proper buffer */",
                "    memcpy(pwhash, passwd, pwlen);",
                "  } else {",
                "    /* pwlen is a multiple of RADIUS_PASSWD_LEN, we can just use it. */",
                "    memcpy(pwhash, passwd, pwlen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-22673",
        "func_name": "gpac/senc_Parse",
        "description": "Memory leak in the senc_Parse function in MP4Box in gpac 0.8.0 allows attackers to cause a denial of service (DoS) via a crafted input.",
        "git_url": "https://github.com/gpac/gpac/commit/a0e6aa849002863a63e6f9e9daecca47042954c4",
        "commit_title": "add IV_size check on senc_Parse (#1341, #1342)",
        "commit_text": "",
        "func_before": "GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count, sample_number;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tsample_number = 1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (trak) sample_number += trak->sample_count_at_seg_start;\n#endif\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, sample_number, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", sample_number, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\tsample_number++;\n\n\t\t//subsample info is only signaled for encrypted samples\n\t\tif (is_encrypted) {\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tif (gf_bs_get_size(bs) - gf_bs_get_position(bs) < 6) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\tif (trak && trak->moov && trak->moov->mov && trak->moov->mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] Failed to parse SENC box, invalid SAI size\\n\" ));\n\t\t\t\t\t\t\treturn GF_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}",
        "func": "GF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tu32 i, j, count, sample_number;\n\tu64 pos = gf_bs_get_position(bs);\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tsample_number = 1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (trak) sample_number += trak->sample_count_at_seg_start;\n#endif\n\tcount = gf_bs_read_u32(bs);\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tu32 is_encrypted;\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));\n\t\tmemset(sai, 0, sizeof(GF_CENCSampleAuxInfo));\n\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_ex(trak, traf, senc, sample_number, &is_encrypted, &sai->IV_size, NULL, NULL, NULL, NULL, NULL);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", sample_number, gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size 16\\n\" ));\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tsai->IV_size = 16;\n\t\t}\n\t\tsample_number++;\n\n\t\t//subsample info is only signaled for encrypted samples\n\t\tif (is_encrypted) {\n\n\t\t\tif (sai->IV_size > ARRAY_LENGTH(sai->IV)) {\n\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] Failed to parse SENC box, invalid SAI size\\n\" ));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif (sai->IV_size)\n\t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tsai->subsample_count = gf_bs_read_u16(bs);\n\t\t\t\tsai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));\n\t\t\t\tfor (j = 0; j < sai->subsample_count; j++) {\n\t\t\t\t\tif (gf_bs_get_size(bs) - gf_bs_get_position(bs) < 6) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\tif (trak && trak->moov && trak->moov->mov && trak->moov->mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] Failed to parse SENC box, invalid SAI size\\n\" ));\n\t\t\t\t\t\t\treturn GF_OK;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tsai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);\n\t\t\t\t\tsai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,6 +42,12 @@\n \n \t\t//subsample info is only signaled for encrypted samples\n \t\tif (is_encrypted) {\n+\n+\t\t\tif (sai->IV_size > ARRAY_LENGTH(sai->IV)) {\n+\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n+\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] Failed to parse SENC box, invalid SAI size\\n\" ));\n+\t\t\t\treturn GF_ISOM_INVALID_FILE;\n+\t\t\t}\n \t\t\tif (sai->IV_size)\n \t\t\t\tgf_bs_read_data(bs, (char *)sai->IV, sai->IV_size);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\tif (sai->IV_size > ARRAY_LENGTH(sai->IV)) {",
                "\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);",
                "\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] Failed to parse SENC box, invalid SAI size\\n\" ));",
                "\t\t\t\treturn GF_ISOM_INVALID_FILE;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-22679",
        "func_name": "gpac/sgpd_parse_entry",
        "description": "Memory leak in the sgpd_parse_entry function in MP4Box in gpac 0.8.0 allows attackers to cause a denial of service (DoS) via a crafted input.",
        "git_url": "https://github.com/gpac/gpac/commit/6c1e7ddfae2ad4daeda7f7e544da34cb765d36c9",
        "commit_title": "add sgpd constant_iv_size check (#1345)",
        "commit_text": "",
        "func_before": "static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\n\tGF_DefaultSampleGroupDescriptionEntry *ptr;\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_u8(bs); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tptr->Per_Sample_IV_size = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *)ptr->KID, 16);\n\t\t*total_bytes = 20;\n\t\tif ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) {\n\t\t\tptr->constant_IV_size = gf_bs_read_u8(bs);\n\t\t\tassert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16));\n\t\t\tgf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size);\n\t\t\t*total_bytes += 1 + ptr->constant_IV_size;\n\t\t}\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + large_size ? 2 : 1;\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!ptr) return NULL;\n\tif (entry_size) {\n\t\tptr->length = entry_size;\n\t\tptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);\n\t\tgf_bs_read_data(bs, (char *) ptr->data, ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn ptr;\n}",
        "func": "static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, u32 entry_size, u32 *total_bytes)\n{\n\tBool null_size_ok = GF_FALSE;\n\n\tGF_DefaultSampleGroupDescriptionEntry *ptr;\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t{\n\t\tGF_RollRecoveryEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_RollRecoveryEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->roll_distance = gf_bs_read_int(bs, 16);\n\t\t*total_bytes = 2;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t{\n\t\tGF_VisualRandomAccessEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->num_leading_samples_known = gf_bs_read_int(bs, 1);\n\t\tptr->num_leading_samples = gf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SAP:\n\t{\n\t\tGF_SAPEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SAPEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->dependent_flag = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 3);\n\t\tptr->SAP_type = gf_bs_read_int(bs, 4);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t{\n\t\tGF_SYNCEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_SYNCEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_int(bs, 2);\n\t\tptr->NALU_type = gf_bs_read_int(bs, 6);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_TELE:\n\t{\n\t\tGF_TemporalLevelEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_TemporalLevelEntry);\n\t\tif (!ptr) return NULL;\n\t\tptr->level_independently_decodable = gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 7);\n\t\t*total_bytes = 1;\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\t{\n\t\tGF_CENCSampleEncryptionGroupEntry *ptr;\n\t\tGF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);\n\t\tif (!ptr) return NULL;\n\t\tgf_bs_read_u8(bs); //reserved\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->IsProtected = gf_bs_read_u8(bs);\n\t\tptr->Per_Sample_IV_size = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *)ptr->KID, 16);\n\t\t*total_bytes = 20;\n\t\tif ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) {\n\t\t\tptr->constant_IV_size = gf_bs_read_u8(bs);\n\t\t\tif ((ptr->constant_IV_size != 8) && (ptr->constant_IV_size != 16)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n\t\t\t\tgf_free(ptr);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size);\n\t\t\t*total_bytes += 1 + ptr->constant_IV_size;\n\t\t}\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\t{\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_oinf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] oinf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t{\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tu32 s = (u32) gf_bs_get_position(bs);\n\t\tgf_isom_linf_read_entry(ptr, bs);\n\t\t*total_bytes = (u32) gf_bs_get_position(bs) - s;\n\t\tif (!entry_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] linf sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\treturn ptr;\n\t}\n\n\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n\t\tif (! entry_size) {\n\t\t\tu32 flags = gf_bs_peek_bits(bs, 24, 0);\n\t\t\tif (flags & 0x10000) entry_size=3;\n\t\t\telse {\n\t\t\t\tif (flags & 0x80000) entry_size=7;\n\t\t\t\telse entry_size=11;\n\t\t\t\t//have dependency list\n\t\t\t\tif (flags & 0x200000) {\n\t\t\t\t\tu32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size);\n\t\t\t\t\tentry_size += 2 + 2*nb_entries;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] trif sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n\t\tif (! entry_size) {\n\t\t\tu64 start = gf_bs_get_position(bs);\n\t\t\tBool rle, large_size;\n\t\t\tu32 entry_count;\n\t\t\tgf_bs_read_int(bs, 6);\n\t\t\tlarge_size = gf_bs_read_int(bs, 1);\n\t\t\trle = gf_bs_read_int(bs, 1);\n\t\t\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tgf_bs_seek(bs, start);\n\t\t\tentry_size = 1 + large_size ? 2 : 1;\n\t\t\tentry_size += entry_count * 2;\n\t\t\tif (rle) entry_size += entry_count * (large_size ? 2 : 1);\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] nalm sample group does not indicate entry size, deprecated in spec\\n\"));\n\t\t}\n\t\tbreak;\n\n\tcase GF_ISOM_SAMPLE_GROUP_TSAS:\n\tcase GF_ISOM_SAMPLE_GROUP_STSA:\n\t\tnull_size_ok = GF_TRUE;\n\t\tbreak;\n\t//TODO, add support for these ones ?\n\tcase GF_ISOM_SAMPLE_GROUP_TSCL:\n\t\tentry_size = 20;\n\t\tbreak;\n\tcase GF_ISOM_SAMPLE_GROUP_LBLI:\n\t\tentry_size = 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!entry_size && !null_size_ok) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\\n\", gf_4cc_to_str( grouping_type) ));\n\t\treturn NULL;\n\t}\n\tGF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);\n\tif (!ptr) return NULL;\n\tif (entry_size) {\n\t\tptr->length = entry_size;\n\t\tptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);\n\t\tgf_bs_read_data(bs, (char *) ptr->data, ptr->length);\n\t\t*total_bytes = entry_size;\n\t}\n\treturn ptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,7 +69,11 @@\n \t\t*total_bytes = 20;\n \t\tif ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) {\n \t\t\tptr->constant_IV_size = gf_bs_read_u8(bs);\n-\t\t\tassert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16));\n+\t\t\tif ((ptr->constant_IV_size != 8) && (ptr->constant_IV_size != 16)) {\n+\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));\n+\t\t\t\tgf_free(ptr);\n+\t\t\t\treturn NULL;\n+\t\t\t}\n \t\t\tgf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size);\n \t\t\t*total_bytes += 1 + ptr->constant_IV_size;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tassert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16));"
            ],
            "added_lines": [
                "\t\t\tif ((ptr->constant_IV_size != 8) && (ptr->constant_IV_size != 16)) {",
                "\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] seig sample group have invalid constant_IV size\\n\"));",
                "\t\t\t\tgf_free(ptr);",
                "\t\t\t\treturn NULL;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45480",
        "func_name": "torvalds/linux/__rds_conn_create",
        "description": "An issue was discovered in the Linux kernel before 5.15.11. There is a memory leak in the __rds_conn_create() function in net/rds/connection.c in a certain combination of circumstances.",
        "git_url": "https://github.com/torvalds/linux/commit/5f9562ebe710c307adc5f666bf1a2162ee7977c0",
        "commit_title": "rds: memory leak in __rds_conn_create()",
        "commit_text": " __rds_conn_create() did not release conn->c_path when loop_trans != 0 and trans->t_prefer_loopback != 0 and is_outgoing == 0. ",
        "func_before": "static struct rds_connection *__rds_conn_create(struct net *net,\n\t\t\t\t\t\tconst struct in6_addr *laddr,\n\t\t\t\t\t\tconst struct in6_addr *faddr,\n\t\t\t\t\t\tstruct rds_transport *trans,\n\t\t\t\t\t\tgfp_t gfp, u8 tos,\n\t\t\t\t\t\tint is_outgoing,\n\t\t\t\t\t\tint dev_if)\n{\n\tstruct rds_connection *conn, *parent = NULL;\n\tstruct hlist_head *head = rds_conn_bucket(laddr, faddr);\n\tstruct rds_transport *loop_trans;\n\tunsigned long flags;\n\tint ret, i;\n\tint npaths = (trans->t_mp_capable ? RDS_MPATH_WORKERS : 1);\n\n\trcu_read_lock();\n\tconn = rds_conn_lookup(net, head, laddr, faddr, trans, tos, dev_if);\n\tif (conn &&\n\t    conn->c_loopback &&\n\t    conn->c_trans != &rds_loop_transport &&\n\t    ipv6_addr_equal(laddr, faddr) &&\n\t    !is_outgoing) {\n\t\t/* This is a looped back IB connection, and we're\n\t\t * called by the code handling the incoming connect.\n\t\t * We need a second connection object into which we\n\t\t * can stick the other QP. */\n\t\tparent = conn;\n\t\tconn = parent->c_passive;\n\t}\n\trcu_read_unlock();\n\tif (conn)\n\t\tgoto out;\n\n\tconn = kmem_cache_zalloc(rds_conn_slab, gfp);\n\tif (!conn) {\n\t\tconn = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tconn->c_path = kcalloc(npaths, sizeof(struct rds_conn_path), gfp);\n\tif (!conn->c_path) {\n\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\tconn = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tINIT_HLIST_NODE(&conn->c_hash_node);\n\tconn->c_laddr = *laddr;\n\tconn->c_isv6 = !ipv6_addr_v4mapped(laddr);\n\tconn->c_faddr = *faddr;\n\tconn->c_dev_if = dev_if;\n\tconn->c_tos = tos;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t/* If the local address is link local, set c_bound_if to be the\n\t * index used for this connection.  Otherwise, set it to 0 as\n\t * the socket is not bound to an interface.  c_bound_if is used\n\t * to look up a socket when a packet is received\n\t */\n\tif (ipv6_addr_type(laddr) & IPV6_ADDR_LINKLOCAL)\n\t\tconn->c_bound_if = dev_if;\n\telse\n#endif\n\t\tconn->c_bound_if = 0;\n\n\trds_conn_net_set(conn, net);\n\n\tret = rds_cong_get_maps(conn);\n\tif (ret) {\n\t\tkfree(conn->c_path);\n\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\tconn = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This is where a connection becomes loopback.  If *any* RDS sockets\n\t * can bind to the destination address then we'd rather the messages\n\t * flow through loopback rather than either transport.\n\t */\n\tloop_trans = rds_trans_get_preferred(net, faddr, conn->c_dev_if);\n\tif (loop_trans) {\n\t\trds_trans_put(loop_trans);\n\t\tconn->c_loopback = 1;\n\t\tif (trans->t_prefer_loopback) {\n\t\t\tif (likely(is_outgoing)) {\n\t\t\t\t/* \"outgoing\" connection to local address.\n\t\t\t\t * Protocol says it wants the connection\n\t\t\t\t * handled by the loopback transport.\n\t\t\t\t * This is what TCP does.\n\t\t\t\t */\n\t\t\t\ttrans = &rds_loop_transport;\n\t\t\t} else {\n\t\t\t\t/* No transport currently in use\n\t\t\t\t * should end up here, but if it\n\t\t\t\t * does, reset/destroy the connection.\n\t\t\t\t */\n\t\t\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\t\t\tconn = ERR_PTR(-EOPNOTSUPP);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tconn->c_trans = trans;\n\n\tinit_waitqueue_head(&conn->c_hs_waitq);\n\tfor (i = 0; i < npaths; i++) {\n\t\t__rds_conn_path_init(conn, &conn->c_path[i],\n\t\t\t\t     is_outgoing);\n\t\tconn->c_path[i].cp_index = i;\n\t}\n\trcu_read_lock();\n\tif (rds_destroy_pending(conn))\n\t\tret = -ENETDOWN;\n\telse\n\t\tret = trans->conn_alloc(conn, GFP_ATOMIC);\n\tif (ret) {\n\t\trcu_read_unlock();\n\t\tkfree(conn->c_path);\n\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\tconn = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"allocated conn %p for %pI6c -> %pI6c over %s %s\\n\",\n\t\t conn, laddr, faddr,\n\t\t strnlen(trans->t_name, sizeof(trans->t_name)) ?\n\t\t trans->t_name : \"[unknown]\", is_outgoing ? \"(outgoing)\" : \"\");\n\n\t/*\n\t * Since we ran without holding the conn lock, someone could\n\t * have created the same conn (either normal or passive) in the\n\t * interim. We check while holding the lock. If we won, we complete\n\t * init and return our conn. If we lost, we rollback and return the\n\t * other one.\n\t */\n\tspin_lock_irqsave(&rds_conn_lock, flags);\n\tif (parent) {\n\t\t/* Creating passive conn */\n\t\tif (parent->c_passive) {\n\t\t\ttrans->conn_free(conn->c_path[0].cp_transport_data);\n\t\t\tkfree(conn->c_path);\n\t\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\t\tconn = parent->c_passive;\n\t\t} else {\n\t\t\tparent->c_passive = conn;\n\t\t\trds_cong_add_conn(conn);\n\t\t\trds_conn_count++;\n\t\t}\n\t} else {\n\t\t/* Creating normal conn */\n\t\tstruct rds_connection *found;\n\n\t\tfound = rds_conn_lookup(net, head, laddr, faddr, trans,\n\t\t\t\t\ttos, dev_if);\n\t\tif (found) {\n\t\t\tstruct rds_conn_path *cp;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < npaths; i++) {\n\t\t\t\tcp = &conn->c_path[i];\n\t\t\t\t/* The ->conn_alloc invocation may have\n\t\t\t\t * allocated resource for all paths, so all\n\t\t\t\t * of them may have to be freed here.\n\t\t\t\t */\n\t\t\t\tif (cp->cp_transport_data)\n\t\t\t\t\ttrans->conn_free(cp->cp_transport_data);\n\t\t\t}\n\t\t\tkfree(conn->c_path);\n\t\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\t\tconn = found;\n\t\t} else {\n\t\t\tconn->c_my_gen_num = rds_gen_num;\n\t\t\tconn->c_peer_gen_num = 0;\n\t\t\thlist_add_head_rcu(&conn->c_hash_node, head);\n\t\t\trds_cong_add_conn(conn);\n\t\t\trds_conn_count++;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&rds_conn_lock, flags);\n\trcu_read_unlock();\n\nout:\n\treturn conn;\n}",
        "func": "static struct rds_connection *__rds_conn_create(struct net *net,\n\t\t\t\t\t\tconst struct in6_addr *laddr,\n\t\t\t\t\t\tconst struct in6_addr *faddr,\n\t\t\t\t\t\tstruct rds_transport *trans,\n\t\t\t\t\t\tgfp_t gfp, u8 tos,\n\t\t\t\t\t\tint is_outgoing,\n\t\t\t\t\t\tint dev_if)\n{\n\tstruct rds_connection *conn, *parent = NULL;\n\tstruct hlist_head *head = rds_conn_bucket(laddr, faddr);\n\tstruct rds_transport *loop_trans;\n\tunsigned long flags;\n\tint ret, i;\n\tint npaths = (trans->t_mp_capable ? RDS_MPATH_WORKERS : 1);\n\n\trcu_read_lock();\n\tconn = rds_conn_lookup(net, head, laddr, faddr, trans, tos, dev_if);\n\tif (conn &&\n\t    conn->c_loopback &&\n\t    conn->c_trans != &rds_loop_transport &&\n\t    ipv6_addr_equal(laddr, faddr) &&\n\t    !is_outgoing) {\n\t\t/* This is a looped back IB connection, and we're\n\t\t * called by the code handling the incoming connect.\n\t\t * We need a second connection object into which we\n\t\t * can stick the other QP. */\n\t\tparent = conn;\n\t\tconn = parent->c_passive;\n\t}\n\trcu_read_unlock();\n\tif (conn)\n\t\tgoto out;\n\n\tconn = kmem_cache_zalloc(rds_conn_slab, gfp);\n\tif (!conn) {\n\t\tconn = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tconn->c_path = kcalloc(npaths, sizeof(struct rds_conn_path), gfp);\n\tif (!conn->c_path) {\n\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\tconn = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tINIT_HLIST_NODE(&conn->c_hash_node);\n\tconn->c_laddr = *laddr;\n\tconn->c_isv6 = !ipv6_addr_v4mapped(laddr);\n\tconn->c_faddr = *faddr;\n\tconn->c_dev_if = dev_if;\n\tconn->c_tos = tos;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t/* If the local address is link local, set c_bound_if to be the\n\t * index used for this connection.  Otherwise, set it to 0 as\n\t * the socket is not bound to an interface.  c_bound_if is used\n\t * to look up a socket when a packet is received\n\t */\n\tif (ipv6_addr_type(laddr) & IPV6_ADDR_LINKLOCAL)\n\t\tconn->c_bound_if = dev_if;\n\telse\n#endif\n\t\tconn->c_bound_if = 0;\n\n\trds_conn_net_set(conn, net);\n\n\tret = rds_cong_get_maps(conn);\n\tif (ret) {\n\t\tkfree(conn->c_path);\n\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\tconn = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This is where a connection becomes loopback.  If *any* RDS sockets\n\t * can bind to the destination address then we'd rather the messages\n\t * flow through loopback rather than either transport.\n\t */\n\tloop_trans = rds_trans_get_preferred(net, faddr, conn->c_dev_if);\n\tif (loop_trans) {\n\t\trds_trans_put(loop_trans);\n\t\tconn->c_loopback = 1;\n\t\tif (trans->t_prefer_loopback) {\n\t\t\tif (likely(is_outgoing)) {\n\t\t\t\t/* \"outgoing\" connection to local address.\n\t\t\t\t * Protocol says it wants the connection\n\t\t\t\t * handled by the loopback transport.\n\t\t\t\t * This is what TCP does.\n\t\t\t\t */\n\t\t\t\ttrans = &rds_loop_transport;\n\t\t\t} else {\n\t\t\t\t/* No transport currently in use\n\t\t\t\t * should end up here, but if it\n\t\t\t\t * does, reset/destroy the connection.\n\t\t\t\t */\n\t\t\t\tkfree(conn->c_path);\n\t\t\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\t\t\tconn = ERR_PTR(-EOPNOTSUPP);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tconn->c_trans = trans;\n\n\tinit_waitqueue_head(&conn->c_hs_waitq);\n\tfor (i = 0; i < npaths; i++) {\n\t\t__rds_conn_path_init(conn, &conn->c_path[i],\n\t\t\t\t     is_outgoing);\n\t\tconn->c_path[i].cp_index = i;\n\t}\n\trcu_read_lock();\n\tif (rds_destroy_pending(conn))\n\t\tret = -ENETDOWN;\n\telse\n\t\tret = trans->conn_alloc(conn, GFP_ATOMIC);\n\tif (ret) {\n\t\trcu_read_unlock();\n\t\tkfree(conn->c_path);\n\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\tconn = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"allocated conn %p for %pI6c -> %pI6c over %s %s\\n\",\n\t\t conn, laddr, faddr,\n\t\t strnlen(trans->t_name, sizeof(trans->t_name)) ?\n\t\t trans->t_name : \"[unknown]\", is_outgoing ? \"(outgoing)\" : \"\");\n\n\t/*\n\t * Since we ran without holding the conn lock, someone could\n\t * have created the same conn (either normal or passive) in the\n\t * interim. We check while holding the lock. If we won, we complete\n\t * init and return our conn. If we lost, we rollback and return the\n\t * other one.\n\t */\n\tspin_lock_irqsave(&rds_conn_lock, flags);\n\tif (parent) {\n\t\t/* Creating passive conn */\n\t\tif (parent->c_passive) {\n\t\t\ttrans->conn_free(conn->c_path[0].cp_transport_data);\n\t\t\tkfree(conn->c_path);\n\t\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\t\tconn = parent->c_passive;\n\t\t} else {\n\t\t\tparent->c_passive = conn;\n\t\t\trds_cong_add_conn(conn);\n\t\t\trds_conn_count++;\n\t\t}\n\t} else {\n\t\t/* Creating normal conn */\n\t\tstruct rds_connection *found;\n\n\t\tfound = rds_conn_lookup(net, head, laddr, faddr, trans,\n\t\t\t\t\ttos, dev_if);\n\t\tif (found) {\n\t\t\tstruct rds_conn_path *cp;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < npaths; i++) {\n\t\t\t\tcp = &conn->c_path[i];\n\t\t\t\t/* The ->conn_alloc invocation may have\n\t\t\t\t * allocated resource for all paths, so all\n\t\t\t\t * of them may have to be freed here.\n\t\t\t\t */\n\t\t\t\tif (cp->cp_transport_data)\n\t\t\t\t\ttrans->conn_free(cp->cp_transport_data);\n\t\t\t}\n\t\t\tkfree(conn->c_path);\n\t\t\tkmem_cache_free(rds_conn_slab, conn);\n\t\t\tconn = found;\n\t\t} else {\n\t\t\tconn->c_my_gen_num = rds_gen_num;\n\t\t\tconn->c_peer_gen_num = 0;\n\t\t\thlist_add_head_rcu(&conn->c_hash_node, head);\n\t\t\trds_cong_add_conn(conn);\n\t\t\trds_conn_count++;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&rds_conn_lock, flags);\n\trcu_read_unlock();\n\nout:\n\treturn conn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -94,6 +94,7 @@\n \t\t\t\t * should end up here, but if it\n \t\t\t\t * does, reset/destroy the connection.\n \t\t\t\t */\n+\t\t\t\tkfree(conn->c_path);\n \t\t\t\tkmem_cache_free(rds_conn_slab, conn);\n \t\t\t\tconn = ERR_PTR(-EOPNOTSUPP);\n \t\t\t\tgoto out;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tkfree(conn->c_path);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46481",
        "func_name": "pcmacdon/jsish/consoleInputCmd",
        "description": "Jsish v3.5.0 was discovered to contain a memory leak via linenoise at src/linenoise.c.",
        "git_url": "https://github.com/pcmacdon/jsish/commit/852f75d792cc9b15ca2e5d39e4724f8a656398eb",
        "commit_title": "Fixes #55",
        "commit_text": " FossilOrigin-Name: d88eb42f5654b30a6cfd46e17dc4f7f574eace7e45b71fbc50ed9912a7606736",
        "func_before": "static Jsi_RC consoleInputCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[1024];\n    char *cp, *p = buf;\n    buf[0] = 0;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v) {\n        if (interp->isSafe)\n            return Jsi_LogError(\"line edit not available in safe mode\");\n        if (Jsi_ValueIsNull(interp, v)) {\n            jsi_RlGetLine(interp, NULL);\n            return JSI_OK;\n        }\n        cp = Jsi_ValueString(interp, v, NULL);\n        if (cp) {\n            p  = jsi_RlGetLine(interp, cp);\n            if (p)\n                Jsi_ValueMakeString(interp, ret, p);\n            return JSI_OK;\n        }\n    }\n    if (!interp->stdinStr)\n        p=fgets(buf, sizeof(buf), stdin);\n    else {\n        int ilen;\n        cp = Jsi_ValueString(interp, interp->stdinStr, &ilen);\n        if (!cp || ilen<=0)\n            p = NULL;\n        else {\n            Jsi_Strncpy(buf, cp, sizeof(buf));\n            buf[sizeof(buf)-1] = 0;\n            p = Jsi_Strchr(buf, '\\n');\n            if (p) { *p = 0;}\n            ilen = Jsi_Strlen(buf);\n            p = (cp + ilen + (p?1:0));\n            Jsi_ValueMakeStringDup(interp, &interp->stdinStr, p);\n            p = buf;\n        }\n    }\n    \n    if (p == NULL) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    if ((p = Jsi_Strchr(buf, '\\r'))) *p = 0;\n    if ((p = Jsi_Strchr(buf, '\\n'))) *p = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}",
        "func": "static Jsi_RC consoleInputCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[1024];\n    char *cp, *p = buf;\n    buf[0] = 0;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v) {\n        if (interp->isSafe)\n            return Jsi_LogError(\"line edit not available in safe mode\");\n        if (Jsi_ValueIsNull(interp, v)) {\n            cp = jsi_RlGetLine(interp, NULL);\n            if (cp)\n              Jsi_Free(cp);\n            return JSI_OK;\n        }\n        cp = Jsi_ValueString(interp, v, NULL);\n        if (cp) {\n            p  = jsi_RlGetLine(interp, cp);\n            if (p) {\n                Jsi_ValueMakeString(interp, ret, p);\n                Jsi_Free(p);\n            }\n            return JSI_OK;\n        }\n    }\n    if (!interp->stdinStr)\n        p=fgets(buf, sizeof(buf), stdin);\n    else {\n        int ilen;\n        cp = Jsi_ValueString(interp, interp->stdinStr, &ilen);\n        if (!cp || ilen<=0)\n            p = NULL;\n        else {\n            Jsi_Strncpy(buf, cp, sizeof(buf));\n            buf[sizeof(buf)-1] = 0;\n            p = Jsi_Strchr(buf, '\\n');\n            if (p) { *p = 0;}\n            ilen = Jsi_Strlen(buf);\n            p = (cp + ilen + (p?1:0));\n            Jsi_ValueMakeStringDup(interp, &interp->stdinStr, p);\n            p = buf;\n        }\n    }\n    \n    if (p == NULL) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    if ((p = Jsi_Strchr(buf, '\\r'))) *p = 0;\n    if ((p = Jsi_Strchr(buf, '\\n'))) *p = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,14 +9,18 @@\n         if (interp->isSafe)\n             return Jsi_LogError(\"line edit not available in safe mode\");\n         if (Jsi_ValueIsNull(interp, v)) {\n-            jsi_RlGetLine(interp, NULL);\n+            cp = jsi_RlGetLine(interp, NULL);\n+            if (cp)\n+              Jsi_Free(cp);\n             return JSI_OK;\n         }\n         cp = Jsi_ValueString(interp, v, NULL);\n         if (cp) {\n             p  = jsi_RlGetLine(interp, cp);\n-            if (p)\n+            if (p) {\n                 Jsi_ValueMakeString(interp, ret, p);\n+                Jsi_Free(p);\n+            }\n             return JSI_OK;\n         }\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "            jsi_RlGetLine(interp, NULL);",
                "            if (p)"
            ],
            "added_lines": [
                "            cp = jsi_RlGetLine(interp, NULL);",
                "            if (cp)",
                "              Jsi_Free(cp);",
                "            if (p) {",
                "                Jsi_Free(p);",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-46871",
        "func_name": "gpac/gf_sg_vrml_field_pointer_del",
        "description": "GPAC version 2.3-DEV-rev602-ged8424300-master in MP4Box contains a memory leak in NewSFDouble scenegraph/vrml_tools.c:300. This vulnerability may lead to a denial of service.",
        "git_url": "https://github.com/gpac/gpac/commit/03760e34d32e502a0078b20d15ea83ecaf453a5c",
        "commit_title": "fix del of node type GF_SG_VRML_SFSCRIPT (fixes #2658)",
        "commit_text": "",
        "func_before": "GF_EXPORT\nvoid gf_sg_vrml_field_pointer_del(void *field, u32 FieldType)\n{\n\tGF_Node *node;\n\n\tswitch (FieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\tcase GF_SG_VRML_SFFLOAT:\n\tcase GF_SG_VRML_SFDOUBLE:\n\tcase GF_SG_VRML_SFTIME:\n\tcase GF_SG_VRML_SFINT32:\n\tcase GF_SG_VRML_SFVEC3F:\n\tcase GF_SG_VRML_SFVEC3D:\n\tcase GF_SG_VRML_SFVEC2F:\n\tcase GF_SG_VRML_SFVEC2D:\n\tcase GF_SG_VRML_SFCOLOR:\n\tcase GF_SG_VRML_SFCOLORRGBA:\n\tcase GF_SG_VRML_SFROTATION:\n\tcase GF_SG_VRML_SFATTRREF:\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tif ( ((SFString *)field)->buffer) gf_free(((SFString *)field)->buffer);\n\t\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t\tgf_sg_sfimage_del(* ((SFImage *)field));\n\t\tbreak;\n\n\tcase GF_SG_VRML_SFNODE:\n\t\tnode = *(GF_Node **) field;\n\t\tif (node) gf_node_del(node);\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\tgf_sg_sfcommand_del(*(SFCommandBuffer *)field);\n\t\tbreak;\n\n\tcase GF_SG_VRML_MFBOOL:\n\t\tgf_sg_mfbool_del( * ((MFBool *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFFLOAT:\n\t\tgf_sg_mffloat_del( * ((MFFloat *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFDOUBLE:\n\t\tgf_sg_mfdouble_del( * ((MFDouble *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFTIME:\n\t\tgf_sg_mftime_del( * ((MFTime *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFINT32:\n\t\tgf_sg_mfint32_del( * ((MFInt32 *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFSTRING:\n\t\tgf_sg_mfstring_del( *((MFString *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFVEC3F:\n\t\tgf_sg_mfvec3f_del( * ((MFVec3f *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFVEC2F:\n\t\tgf_sg_mfvec2f_del( * ((MFVec2f *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFVEC3D:\n\t\tgf_sg_mfvec3d_del( * ((MFVec3d *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFVEC2D:\n\t\tgf_sg_mfvec2d_del( * ((MFVec2d *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFCOLOR:\n\t\tgf_sg_mfcolor_del( * ((MFColor *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFCOLORRGBA:\n\t\tgf_sg_mfcolorrgba_del( * ((MFColorRGBA *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFROTATION:\n\tcase GF_SG_VRML_MFVEC4F:\n\t\tgf_sg_mfrotation_del( * ((MFRotation *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t\tgf_sg_sfurl_del( * ((SFURL *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFURL:\n\t\tgf_sg_mfurl_del( * ((MFURL *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFATTRREF:\n\t\tgf_sg_mfattrref_del( * ((MFAttrRef *) field));\n\t\tbreak;\n\t//used only in proto since this field is created by default for regular nodes\n\tcase GF_SG_VRML_MFNODE:\n\t\tassert(0);\n\t\treturn;\n\tcase GF_SG_VRML_MFSCRIPT:\n\t\tgf_sg_mfscript_del( * ((MFScript *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n\t\treturn;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn;\n\t}\n\t//free pointer\n\tgf_free(field);\n}",
        "func": "GF_EXPORT\nvoid gf_sg_vrml_field_pointer_del(void *field, u32 FieldType)\n{\n\tGF_Node *node;\n\n\tswitch (FieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\tcase GF_SG_VRML_SFFLOAT:\n\tcase GF_SG_VRML_SFDOUBLE:\n\tcase GF_SG_VRML_SFTIME:\n\tcase GF_SG_VRML_SFINT32:\n\tcase GF_SG_VRML_SFVEC3F:\n\tcase GF_SG_VRML_SFVEC3D:\n\tcase GF_SG_VRML_SFVEC2F:\n\tcase GF_SG_VRML_SFVEC2D:\n\tcase GF_SG_VRML_SFCOLOR:\n\tcase GF_SG_VRML_SFCOLORRGBA:\n\tcase GF_SG_VRML_SFROTATION:\n\tcase GF_SG_VRML_SFATTRREF:\n\t\tbreak;\n\tcase GF_SG_VRML_SFSTRING:\n\t\tif ( ((SFString *)field)->buffer) gf_free(((SFString *)field)->buffer);\n\t\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t\tgf_sg_sfimage_del(* ((SFImage *)field));\n\t\tbreak;\n\n\tcase GF_SG_VRML_SFNODE:\n\t\tnode = *(GF_Node **) field;\n\t\tif (node) gf_node_del(node);\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\tgf_sg_sfcommand_del(*(SFCommandBuffer *)field);\n\t\tbreak;\n\n\tcase GF_SG_VRML_MFBOOL:\n\t\tgf_sg_mfbool_del( * ((MFBool *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFFLOAT:\n\t\tgf_sg_mffloat_del( * ((MFFloat *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFDOUBLE:\n\t\tgf_sg_mfdouble_del( * ((MFDouble *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFTIME:\n\t\tgf_sg_mftime_del( * ((MFTime *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFINT32:\n\t\tgf_sg_mfint32_del( * ((MFInt32 *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFSTRING:\n\t\tgf_sg_mfstring_del( *((MFString *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFVEC3F:\n\t\tgf_sg_mfvec3f_del( * ((MFVec3f *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFVEC2F:\n\t\tgf_sg_mfvec2f_del( * ((MFVec2f *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFVEC3D:\n\t\tgf_sg_mfvec3d_del( * ((MFVec3d *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFVEC2D:\n\t\tgf_sg_mfvec2d_del( * ((MFVec2d *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFCOLOR:\n\t\tgf_sg_mfcolor_del( * ((MFColor *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFCOLORRGBA:\n\t\tgf_sg_mfcolorrgba_del( * ((MFColorRGBA *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFROTATION:\n\tcase GF_SG_VRML_MFVEC4F:\n\t\tgf_sg_mfrotation_del( * ((MFRotation *)field));\n\t\tbreak;\n\tcase GF_SG_VRML_SFURL:\n\t\tgf_sg_sfurl_del( * ((SFURL *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFURL:\n\t\tgf_sg_mfurl_del( * ((MFURL *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_MFATTRREF:\n\t\tgf_sg_mfattrref_del( * ((MFAttrRef *) field));\n\t\tbreak;\n\t//used only in proto since this field is created by default for regular nodes\n\tcase GF_SG_VRML_MFNODE:\n\t\tassert(0);\n\t\treturn;\n\tcase GF_SG_VRML_MFSCRIPT:\n\t\tgf_sg_mfscript_del( * ((MFScript *) field));\n\t\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n\t\tbreak;\n\n\tdefault:\n\t\tassert(0);\n\t\treturn;\n\t}\n\t//free pointer\n\tgf_free(field);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,7 +90,7 @@\n \t\tgf_sg_mfscript_del( * ((MFScript *) field));\n \t\tbreak;\n \tcase GF_SG_VRML_SFSCRIPT:\n-\t\treturn;\n+\t\tbreak;\n \n \tdefault:\n \t\tassert(0);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn;"
            ],
            "added_lines": [
                "\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-46871",
        "func_name": "gpac/gf_sg_vrml_mf_reset",
        "description": "GPAC version 2.3-DEV-rev602-ged8424300-master in MP4Box contains a memory leak in NewSFDouble scenegraph/vrml_tools.c:300. This vulnerability may lead to a denial of service.",
        "git_url": "https://github.com/gpac/gpac/commit/03760e34d32e502a0078b20d15ea83ecaf453a5c",
        "commit_title": "fix del of node type GF_SG_VRML_SFSCRIPT (fixes #2658)",
        "commit_text": "",
        "func_before": "GF_EXPORT\nGF_Err gf_sg_vrml_mf_reset(void *mf, u32 FieldType)\n{\n\tGenMFField *mffield = (GenMFField *)mf;\n\tif (!mffield || !mffield->array) return GF_OK;\n\n\t//field we can't copy\n\tif (gf_sg_vrml_is_sf_field(FieldType)) return GF_BAD_PARAM;\n\tif (!gf_sg_vrml_get_sf_size(FieldType)) return GF_BAD_PARAM;\n\n\tswitch (FieldType) {\n\tcase GF_SG_VRML_MFSTRING:\n\t\tgf_sg_mfstring_del( * ((MFString *) mf));\n\t\tbreak;\n\tcase GF_SG_VRML_MFURL:\n\t\tgf_sg_mfurl_del( * ((MFURL *) mf));\n\t\tbreak;\n\tcase GF_SG_VRML_MFSCRIPT:\n\t\tgf_sg_mfscript_del( * ((MFScript *) mf));\t\n\t\tbreak;\n\tdefault:\n\t\tif (mffield->array) gf_free(mffield->array);\n\t\tbreak;\n\t}\n\n\tmffield->array = NULL;\n\tmffield->count = 0;\n\treturn GF_OK;\n}",
        "func": "GF_EXPORT\nGF_Err gf_sg_vrml_mf_reset(void *mf, u32 FieldType)\n{\n\tGenMFField *mffield = (GenMFField *)mf;\n\tif (!mffield || !mffield->array) return GF_OK;\n\n\t//field we can't copy\n\tif (gf_sg_vrml_is_sf_field(FieldType)) return GF_BAD_PARAM;\n\tif (!gf_sg_vrml_get_sf_size(FieldType)) return GF_BAD_PARAM;\n\n\tswitch (FieldType) {\n\tcase GF_SG_VRML_MFSTRING:\n\t\tgf_sg_mfstring_del( * ((MFString *) mf));\n\t\tbreak;\n\tcase GF_SG_VRML_MFURL:\n\t\tgf_sg_mfurl_del( * ((MFURL *) mf));\n\t\tbreak;\n\tcase GF_SG_VRML_MFSCRIPT:\n\t\tgf_sg_mfscript_del( * ((MFScript *) mf));\n\t\tbreak;\n\tdefault:\n\t\tif (mffield->array) gf_free(mffield->array);\n\t\tbreak;\n\t}\n\n\tmffield->array = NULL;\n\tmffield->count = 0;\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \t\tgf_sg_mfurl_del( * ((MFURL *) mf));\n \t\tbreak;\n \tcase GF_SG_VRML_MFSCRIPT:\n-\t\tgf_sg_mfscript_del( * ((MFScript *) mf));\t\n+\t\tgf_sg_mfscript_del( * ((MFScript *) mf));\n \t\tbreak;\n \tdefault:\n \t\tif (mffield->array) gf_free(mffield->array);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tgf_sg_mfscript_del( * ((MFScript *) mf));\t"
            ],
            "added_lines": [
                "\t\tgf_sg_mfscript_del( * ((MFScript *) mf));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-7192",
        "func_name": "kernel/git/netdev/net/ctnetlink_create_conntrack",
        "description": "A memory leak problem was found in ctnetlink_create_conntrack in net/netfilter/nf_conntrack_netlink.c in the Linux Kernel. This issue may allow a local attacker with CAP_NET_ADMIN privileges to cause a denial of service (DoS) attack due to a refcount overflow.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?h=ac4893980bbe79ce383daf9a0885666a30fe4c83",
        "commit_title": "nf_ct_put() needs to be called to put the refcount got by",
        "commit_text": "nf_conntrack_find_get() to avoid refcount leak when nf_conntrack_hash_check_insert() fails.  ",
        "func_before": "static struct nf_conn *\nctnetlink_create_conntrack(struct net *net,\n\t\t\t   const struct nf_conntrack_zone *zone,\n\t\t\t   const struct nlattr * const cda[],\n\t\t\t   struct nf_conntrack_tuple *otuple,\n\t\t\t   struct nf_conntrack_tuple *rtuple,\n\t\t\t   u8 u3)\n{\n\tstruct nf_conn *ct;\n\tint err = -EINVAL;\n\tstruct nf_conntrack_helper *helper;\n\tstruct nf_conn_tstamp *tstamp;\n\tu64 timeout;\n\n\tct = nf_conntrack_alloc(net, zone, otuple, rtuple, GFP_ATOMIC);\n\tif (IS_ERR(ct))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!cda[CTA_TIMEOUT])\n\t\tgoto err1;\n\n\ttimeout = (u64)ntohl(nla_get_be32(cda[CTA_TIMEOUT])) * HZ;\n\t__nf_ct_set_timeout(ct, timeout);\n\n\trcu_read_lock();\n \tif (cda[CTA_HELP]) {\n\t\tchar *helpname = NULL;\n\t\tstruct nlattr *helpinfo = NULL;\n\n\t\terr = ctnetlink_parse_help(cda[CTA_HELP], &helpname, &helpinfo);\n \t\tif (err < 0)\n\t\t\tgoto err2;\n\n\t\thelper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),\n\t\t\t\t\t\t    nf_ct_protonum(ct));\n\t\tif (helper == NULL) {\n\t\t\trcu_read_unlock();\n#ifdef CONFIG_MODULES\n\t\t\tif (request_module(\"nfct-helper-%s\", helpname) < 0) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err1;\n\t\t\t}\n\n\t\t\trcu_read_lock();\n\t\t\thelper = __nf_conntrack_helper_find(helpname,\n\t\t\t\t\t\t\t    nf_ct_l3num(ct),\n\t\t\t\t\t\t\t    nf_ct_protonum(ct));\n\t\t\tif (helper) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t\trcu_read_unlock();\n#endif\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err1;\n\t\t} else {\n\t\t\tstruct nf_conn_help *help;\n\n\t\t\thelp = nf_ct_helper_ext_add(ct, GFP_ATOMIC);\n\t\t\tif (help == NULL) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t\t/* set private helper data if allowed. */\n\t\t\tif (helper->from_nlattr)\n\t\t\t\thelper->from_nlattr(helpinfo, ct);\n\n\t\t\t/* disable helper auto-assignment for this entry */\n\t\t\tct->status |= IPS_HELPER;\n\t\t\tRCU_INIT_POINTER(help->helper, helper);\n\t\t}\n\t}\n\n\terr = ctnetlink_setup_nat(ct, cda);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tnf_ct_acct_ext_add(ct, GFP_ATOMIC);\n\tnf_ct_tstamp_ext_add(ct, GFP_ATOMIC);\n\tnf_ct_ecache_ext_add(ct, 0, 0, GFP_ATOMIC);\n\tnf_ct_labels_ext_add(ct);\n\tnfct_seqadj_ext_add(ct);\n\tnfct_synproxy_ext_add(ct);\n\n\t/* we must add conntrack extensions before confirmation. */\n\tct->status |= IPS_CONFIRMED;\n\n\tif (cda[CTA_STATUS]) {\n\t\terr = ctnetlink_change_status(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n\tif (cda[CTA_SEQ_ADJ_ORIG] || cda[CTA_SEQ_ADJ_REPLY]) {\n\t\terr = ctnetlink_change_seq_adj(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n\tmemset(&ct->proto, 0, sizeof(ct->proto));\n\tif (cda[CTA_PROTOINFO]) {\n\t\terr = ctnetlink_change_protoinfo(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n\tif (cda[CTA_SYNPROXY]) {\n\t\terr = ctnetlink_change_synproxy(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n#if defined(CONFIG_NF_CONNTRACK_MARK)\n\tif (cda[CTA_MARK])\n\t\tctnetlink_change_mark(ct, cda);\n#endif\n\n\t/* setup master conntrack: this is a confirmed expectation */\n\tif (cda[CTA_TUPLE_MASTER]) {\n\t\tstruct nf_conntrack_tuple master;\n\t\tstruct nf_conntrack_tuple_hash *master_h;\n\t\tstruct nf_conn *master_ct;\n\n\t\terr = ctnetlink_parse_tuple(cda, &master, CTA_TUPLE_MASTER,\n\t\t\t\t\t    u3, NULL);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\n\t\tmaster_h = nf_conntrack_find_get(net, zone, &master);\n\t\tif (master_h == NULL) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err2;\n\t\t}\n\t\tmaster_ct = nf_ct_tuplehash_to_ctrack(master_h);\n\t\t__set_bit(IPS_EXPECTED_BIT, &ct->status);\n\t\tct->master = master_ct;\n\t}\n\ttstamp = nf_conn_tstamp_find(ct);\n\tif (tstamp)\n\t\ttstamp->start = ktime_get_real_ns();\n\n\terr = nf_conntrack_hash_check_insert(ct);\n\tif (err < 0)\n\t\tgoto err2;\n\n\trcu_read_unlock();\n\n\treturn ct;\n\nerr2:\n\trcu_read_unlock();\nerr1:\n\tnf_conntrack_free(ct);\n\treturn ERR_PTR(err);\n}",
        "func": "static struct nf_conn *\nctnetlink_create_conntrack(struct net *net,\n\t\t\t   const struct nf_conntrack_zone *zone,\n\t\t\t   const struct nlattr * const cda[],\n\t\t\t   struct nf_conntrack_tuple *otuple,\n\t\t\t   struct nf_conntrack_tuple *rtuple,\n\t\t\t   u8 u3)\n{\n\tstruct nf_conn *ct;\n\tint err = -EINVAL;\n\tstruct nf_conntrack_helper *helper;\n\tstruct nf_conn_tstamp *tstamp;\n\tu64 timeout;\n\n\tct = nf_conntrack_alloc(net, zone, otuple, rtuple, GFP_ATOMIC);\n\tif (IS_ERR(ct))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!cda[CTA_TIMEOUT])\n\t\tgoto err1;\n\n\ttimeout = (u64)ntohl(nla_get_be32(cda[CTA_TIMEOUT])) * HZ;\n\t__nf_ct_set_timeout(ct, timeout);\n\n\trcu_read_lock();\n \tif (cda[CTA_HELP]) {\n\t\tchar *helpname = NULL;\n\t\tstruct nlattr *helpinfo = NULL;\n\n\t\terr = ctnetlink_parse_help(cda[CTA_HELP], &helpname, &helpinfo);\n \t\tif (err < 0)\n\t\t\tgoto err2;\n\n\t\thelper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),\n\t\t\t\t\t\t    nf_ct_protonum(ct));\n\t\tif (helper == NULL) {\n\t\t\trcu_read_unlock();\n#ifdef CONFIG_MODULES\n\t\t\tif (request_module(\"nfct-helper-%s\", helpname) < 0) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err1;\n\t\t\t}\n\n\t\t\trcu_read_lock();\n\t\t\thelper = __nf_conntrack_helper_find(helpname,\n\t\t\t\t\t\t\t    nf_ct_l3num(ct),\n\t\t\t\t\t\t\t    nf_ct_protonum(ct));\n\t\t\tif (helper) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t\trcu_read_unlock();\n#endif\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err1;\n\t\t} else {\n\t\t\tstruct nf_conn_help *help;\n\n\t\t\thelp = nf_ct_helper_ext_add(ct, GFP_ATOMIC);\n\t\t\tif (help == NULL) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t\t/* set private helper data if allowed. */\n\t\t\tif (helper->from_nlattr)\n\t\t\t\thelper->from_nlattr(helpinfo, ct);\n\n\t\t\t/* disable helper auto-assignment for this entry */\n\t\t\tct->status |= IPS_HELPER;\n\t\t\tRCU_INIT_POINTER(help->helper, helper);\n\t\t}\n\t}\n\n\terr = ctnetlink_setup_nat(ct, cda);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tnf_ct_acct_ext_add(ct, GFP_ATOMIC);\n\tnf_ct_tstamp_ext_add(ct, GFP_ATOMIC);\n\tnf_ct_ecache_ext_add(ct, 0, 0, GFP_ATOMIC);\n\tnf_ct_labels_ext_add(ct);\n\tnfct_seqadj_ext_add(ct);\n\tnfct_synproxy_ext_add(ct);\n\n\t/* we must add conntrack extensions before confirmation. */\n\tct->status |= IPS_CONFIRMED;\n\n\tif (cda[CTA_STATUS]) {\n\t\terr = ctnetlink_change_status(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n\tif (cda[CTA_SEQ_ADJ_ORIG] || cda[CTA_SEQ_ADJ_REPLY]) {\n\t\terr = ctnetlink_change_seq_adj(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n\tmemset(&ct->proto, 0, sizeof(ct->proto));\n\tif (cda[CTA_PROTOINFO]) {\n\t\terr = ctnetlink_change_protoinfo(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n\tif (cda[CTA_SYNPROXY]) {\n\t\terr = ctnetlink_change_synproxy(ct, cda);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\t}\n\n#if defined(CONFIG_NF_CONNTRACK_MARK)\n\tif (cda[CTA_MARK])\n\t\tctnetlink_change_mark(ct, cda);\n#endif\n\n\t/* setup master conntrack: this is a confirmed expectation */\n\tif (cda[CTA_TUPLE_MASTER]) {\n\t\tstruct nf_conntrack_tuple master;\n\t\tstruct nf_conntrack_tuple_hash *master_h;\n\t\tstruct nf_conn *master_ct;\n\n\t\terr = ctnetlink_parse_tuple(cda, &master, CTA_TUPLE_MASTER,\n\t\t\t\t\t    u3, NULL);\n\t\tif (err < 0)\n\t\t\tgoto err2;\n\n\t\tmaster_h = nf_conntrack_find_get(net, zone, &master);\n\t\tif (master_h == NULL) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err2;\n\t\t}\n\t\tmaster_ct = nf_ct_tuplehash_to_ctrack(master_h);\n\t\t__set_bit(IPS_EXPECTED_BIT, &ct->status);\n\t\tct->master = master_ct;\n\t}\n\ttstamp = nf_conn_tstamp_find(ct);\n\tif (tstamp)\n\t\ttstamp->start = ktime_get_real_ns();\n\n\terr = nf_conntrack_hash_check_insert(ct);\n\tif (err < 0)\n\t\tgoto err3;\n\n\trcu_read_unlock();\n\n\treturn ct;\n\nerr3:\n\tif (ct->master)\n\t\tnf_ct_put(ct->master);\nerr2:\n\trcu_read_unlock();\nerr1:\n\tnf_conntrack_free(ct);\n\treturn ERR_PTR(err);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -141,12 +141,15 @@\n \n \terr = nf_conntrack_hash_check_insert(ct);\n \tif (err < 0)\n-\t\tgoto err2;\n+\t\tgoto err3;\n \n \trcu_read_unlock();\n \n \treturn ct;\n \n+err3:\n+\tif (ct->master)\n+\t\tnf_ct_put(ct->master);\n err2:\n \trcu_read_unlock();\n err1:",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tgoto err2;"
            ],
            "added_lines": [
                "\t\tgoto err3;",
                "err3:",
                "\tif (ct->master)",
                "\t\tnf_ct_put(ct->master);"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-24258",
        "func_name": "freeglut/glutAddMenuEntry",
        "description": "freeglut 3.4.0 was discovered to contain a memory leak via the menuEntry variable in the glutAddSubMenu function.",
        "git_url": "https://github.com/freeglut/freeglut/commit/a3810f4e9540286e2d4b8cc97c82ec484de45b9e",
        "commit_title": "Plug memory leak that happens upon error.",
        "commit_text": " If fgStructure.CurrentMenu is set when glutAddMenuEntry() or glutAddSubMenu() is called the allocated menuEntry variable will leak. This commit postpones allocating menuEntry until after the error checks, thereby plugging the memory leak.  This fixes CVE-2024-24258 and CVE-2024-24259.",
        "func_before": "void FGAPIENTRY glutAddMenuEntry( const char* label, int value )\n{\n    SFG_MenuEntry* menuEntry;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutAddMenuEntry\" );\n    menuEntry = (SFG_MenuEntry *)calloc( sizeof(SFG_MenuEntry), 1 );\n\n    freeglut_return_if_fail( fgStructure.CurrentMenu );\n    if (fgState.ActiveMenus)\n        fgError(\"Menu manipulation not allowed while menus in use.\");\n\n    menuEntry->Text = strdup( label );\n    menuEntry->ID   = value;\n\n    /* Have the new menu entry attached to the current menu */\n    fgListAppend( &fgStructure.CurrentMenu->Entries, &menuEntry->Node );\n\n    fghCalculateMenuBoxSize( );\n}",
        "func": "void FGAPIENTRY glutAddMenuEntry( const char* label, int value )\n{\n    SFG_MenuEntry* menuEntry;\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutAddMenuEntry\" );\n\n    freeglut_return_if_fail( fgStructure.CurrentMenu );\n    if (fgState.ActiveMenus)\n        fgError(\"Menu manipulation not allowed while menus in use.\");\n\n    menuEntry = (SFG_MenuEntry *)calloc( sizeof(SFG_MenuEntry), 1 );\n    menuEntry->Text = strdup( label );\n    menuEntry->ID   = value;\n\n    /* Have the new menu entry attached to the current menu */\n    fgListAppend( &fgStructure.CurrentMenu->Entries, &menuEntry->Node );\n\n    fghCalculateMenuBoxSize( );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,12 @@\n {\n     SFG_MenuEntry* menuEntry;\n     FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutAddMenuEntry\" );\n-    menuEntry = (SFG_MenuEntry *)calloc( sizeof(SFG_MenuEntry), 1 );\n \n     freeglut_return_if_fail( fgStructure.CurrentMenu );\n     if (fgState.ActiveMenus)\n         fgError(\"Menu manipulation not allowed while menus in use.\");\n \n+    menuEntry = (SFG_MenuEntry *)calloc( sizeof(SFG_MenuEntry), 1 );\n     menuEntry->Text = strdup( label );\n     menuEntry->ID   = value;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    menuEntry = (SFG_MenuEntry *)calloc( sizeof(SFG_MenuEntry), 1 );"
            ],
            "added_lines": [
                "    menuEntry = (SFG_MenuEntry *)calloc( sizeof(SFG_MenuEntry), 1 );"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-24258",
        "func_name": "freeglut/glutAddSubMenu",
        "description": "freeglut 3.4.0 was discovered to contain a memory leak via the menuEntry variable in the glutAddSubMenu function.",
        "git_url": "https://github.com/freeglut/freeglut/commit/a3810f4e9540286e2d4b8cc97c82ec484de45b9e",
        "commit_title": "Plug memory leak that happens upon error.",
        "commit_text": " If fgStructure.CurrentMenu is set when glutAddMenuEntry() or glutAddSubMenu() is called the allocated menuEntry variable will leak. This commit postpones allocating menuEntry until after the error checks, thereby plugging the memory leak.  This fixes CVE-2024-24258 and CVE-2024-24259.",
        "func_before": "void FGAPIENTRY glutAddSubMenu( const char *label, int subMenuID )\n{\n    SFG_MenuEntry *menuEntry;\n    SFG_Menu *subMenu;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutAddSubMenu\" );\n    menuEntry = ( SFG_MenuEntry * )calloc( sizeof( SFG_MenuEntry ), 1 );\n    subMenu = fgMenuByID( subMenuID );\n\n    freeglut_return_if_fail( fgStructure.CurrentMenu );\n    if (fgState.ActiveMenus)\n        fgError(\"Menu manipulation not allowed while menus in use.\");\n\n    freeglut_return_if_fail( subMenu );\n\n    menuEntry->Text    = strdup( label );\n    menuEntry->SubMenu = subMenu;\n    menuEntry->ID      = -1;\n\n    fgListAppend( &fgStructure.CurrentMenu->Entries, &menuEntry->Node );\n    fghCalculateMenuBoxSize( );\n}",
        "func": "void FGAPIENTRY glutAddSubMenu( const char *label, int subMenuID )\n{\n    SFG_MenuEntry *menuEntry;\n    SFG_Menu *subMenu;\n\n    FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutAddSubMenu\" );\n    subMenu = fgMenuByID( subMenuID );\n\n    freeglut_return_if_fail( fgStructure.CurrentMenu );\n    if (fgState.ActiveMenus)\n        fgError(\"Menu manipulation not allowed while menus in use.\");\n\n    freeglut_return_if_fail( subMenu );\n\n    menuEntry = ( SFG_MenuEntry * )calloc( sizeof( SFG_MenuEntry ), 1 );\n    menuEntry->Text    = strdup( label );\n    menuEntry->SubMenu = subMenu;\n    menuEntry->ID      = -1;\n\n    fgListAppend( &fgStructure.CurrentMenu->Entries, &menuEntry->Node );\n    fghCalculateMenuBoxSize( );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,6 @@\n     SFG_Menu *subMenu;\n \n     FREEGLUT_EXIT_IF_NOT_INITIALISED ( \"glutAddSubMenu\" );\n-    menuEntry = ( SFG_MenuEntry * )calloc( sizeof( SFG_MenuEntry ), 1 );\n     subMenu = fgMenuByID( subMenuID );\n \n     freeglut_return_if_fail( fgStructure.CurrentMenu );\n@@ -13,6 +12,7 @@\n \n     freeglut_return_if_fail( subMenu );\n \n+    menuEntry = ( SFG_MenuEntry * )calloc( sizeof( SFG_MenuEntry ), 1 );\n     menuEntry->Text    = strdup( label );\n     menuEntry->SubMenu = subMenu;\n     menuEntry->ID      = -1;",
        "diff_line_info": {
            "deleted_lines": [
                "    menuEntry = ( SFG_MenuEntry * )calloc( sizeof( SFG_MenuEntry ), 1 );"
            ],
            "added_lines": [
                "    menuEntry = ( SFG_MenuEntry * )calloc( sizeof( SFG_MenuEntry ), 1 );"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20386",
        "func_name": "systemd/button_open",
        "description": "An issue was discovered in button_open in login/logind-button.c in systemd before 243. When executing the udevadm trigger command, a memory leak may occur.",
        "git_url": "https://github.com/systemd/systemd/commit/b2774a3ae692113e1f47a336a6c09bac9cfb49ad",
        "commit_title": "bus_open leak sd_event_source when udevadm trigger",
        "commit_text": " On my host, when executing the udevadm trigger, I only receive the change event, which causes memleak",
        "func_before": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n\n        assert(b);\n\n        b->fd = safe_close(b->fd);\n\n        p = strjoina(\"/dev/input/\", b->name);\n\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n\n        return 0;\n\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}",
        "func": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n\n        assert(b);\n\n        b->fd = safe_close(b->fd);\n\n        p = strjoina(\"/dev/input/\", b->name);\n\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n        \n        b->io_event_source = sd_event_source_unref(b->io_event_source);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n\n        return 0;\n\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,8 @@\n         }\n \n         (void) button_set_mask(b);\n-\n+        \n+        b->io_event_source = sd_event_source_unref(b->io_event_source);\n         r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n         if (r < 0) {\n                 log_error_errno(r, \"Failed to add button event: %m\");",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "        ",
                "        b->io_event_source = sd_event_source_unref(b->io_event_source);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20388",
        "func_name": "GNOME/libxml2/xmlSchemaPreRun",
        "description": "xmlSchemaPreRun in xmlschemas.c in libxml2 2.9.10 allows an xmlSchemaValidateStream memory leak.",
        "git_url": "https://github.com/GNOME/libxml2/commit/6088a74bcf7d0c42e24cff4594d804e1d3c9fbca",
        "commit_title": "Fix memory leak in xmlSchemaValidateStream",
        "commit_text": " When ctxt->schema is NULL, xmlSchemaSAXPlug->xmlSchemaPreRun alloc a new schema for ctxt->schema and set vctxt->xsiAssemble to 1. Then xmlSchemaVStart->xmlSchemaPreRun initialize vctxt->xsiAssemble to 0 again which cause the alloced schema can not be freed anymore.  Found with libFuzzer. ",
        "func_before": "static int\nxmlSchemaPreRun(xmlSchemaValidCtxtPtr vctxt) {\n    /*\n    * Some initialization.\n    */\n    vctxt->err = 0;\n    vctxt->nberrors = 0;\n    vctxt->depth = -1;\n    vctxt->skipDepth = -1;\n    vctxt->xsiAssemble = 0;\n    vctxt->hasKeyrefs = 0;\n#ifdef ENABLE_IDC_NODE_TABLES_TEST\n    vctxt->createIDCNodeTables = 1;\n#else\n    vctxt->createIDCNodeTables = 0;\n#endif\n    /*\n    * Create a schema + parser if necessary.\n    */\n    if (vctxt->schema == NULL) {\n\txmlSchemaParserCtxtPtr pctxt;\n\n\tvctxt->xsiAssemble = 1;\n\t/*\n\t* If not schema was given then we will create a schema\n\t* dynamically using XSI schema locations.\n\t*\n\t* Create the schema parser context.\n\t*/\n\tif ((vctxt->pctxt == NULL) &&\n\t   (xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -1))\n\t   return (-1);\n\tpctxt = vctxt->pctxt;\n\tpctxt->xsiAssemble = 1;\n\t/*\n\t* Create the schema.\n\t*/\n\tvctxt->schema = xmlSchemaNewSchema(pctxt);\n\tif (vctxt->schema == NULL)\n\t    return (-1);\n\t/*\n\t* Create the schema construction context.\n\t*/\n\tpctxt->constructor = xmlSchemaConstructionCtxtCreate(pctxt->dict);\n\tif (pctxt->constructor == NULL)\n\t    return(-1);\n\tpctxt->constructor->mainSchema = vctxt->schema;\n\t/*\n\t* Take ownership of the constructor to be able to free it.\n\t*/\n\tpctxt->ownsConstructor = 1;\n    }\n    /*\n    * Augment the IDC definitions for the main schema and all imported ones\n    * NOTE: main schema if the first in the imported list\n    */\n    xmlHashScan(vctxt->schema->schemasImports, xmlSchemaAugmentImportedIDC,\n                vctxt);\n\n    return(0);\n}",
        "func": "static int\nxmlSchemaPreRun(xmlSchemaValidCtxtPtr vctxt) {\n    /*\n    * Some initialization.\n    */\n    vctxt->err = 0;\n    vctxt->nberrors = 0;\n    vctxt->depth = -1;\n    vctxt->skipDepth = -1;\n    vctxt->hasKeyrefs = 0;\n#ifdef ENABLE_IDC_NODE_TABLES_TEST\n    vctxt->createIDCNodeTables = 1;\n#else\n    vctxt->createIDCNodeTables = 0;\n#endif\n    /*\n    * Create a schema + parser if necessary.\n    */\n    if (vctxt->schema == NULL) {\n\txmlSchemaParserCtxtPtr pctxt;\n\n\tvctxt->xsiAssemble = 1;\n\t/*\n\t* If not schema was given then we will create a schema\n\t* dynamically using XSI schema locations.\n\t*\n\t* Create the schema parser context.\n\t*/\n\tif ((vctxt->pctxt == NULL) &&\n\t   (xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -1))\n\t   return (-1);\n\tpctxt = vctxt->pctxt;\n\tpctxt->xsiAssemble = 1;\n\t/*\n\t* Create the schema.\n\t*/\n\tvctxt->schema = xmlSchemaNewSchema(pctxt);\n\tif (vctxt->schema == NULL)\n\t    return (-1);\n\t/*\n\t* Create the schema construction context.\n\t*/\n\tpctxt->constructor = xmlSchemaConstructionCtxtCreate(pctxt->dict);\n\tif (pctxt->constructor == NULL)\n\t    return(-1);\n\tpctxt->constructor->mainSchema = vctxt->schema;\n\t/*\n\t* Take ownership of the constructor to be able to free it.\n\t*/\n\tpctxt->ownsConstructor = 1;\n    }\n    /*\n    * Augment the IDC definitions for the main schema and all imported ones\n    * NOTE: main schema if the first in the imported list\n    */\n    xmlHashScan(vctxt->schema->schemasImports, xmlSchemaAugmentImportedIDC,\n                vctxt);\n\n    return(0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,6 @@\n     vctxt->nberrors = 0;\n     vctxt->depth = -1;\n     vctxt->skipDepth = -1;\n-    vctxt->xsiAssemble = 0;\n     vctxt->hasKeyrefs = 0;\n #ifdef ENABLE_IDC_NODE_TABLES_TEST\n     vctxt->createIDCNodeTables = 1;",
        "diff_line_info": {
            "deleted_lines": [
                "    vctxt->xsiAssemble = 0;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-8991",
        "func_name": "lvm2/vg_lookup",
        "description": "vg_lookup in daemons/lvmetad/lvmetad-core.c in LVM2 2.02 mismanages memory, leading to an lvmetad memory leak, as demonstrated by running pvs. NOTE: RedHat disputes CVE-2020-8991 as not being a vulnerability since theres no apparent route to either privilege escalation or to denial of service through the bug",
        "git_url": "https://sourceware.org/git/?p=lvm2.git;a=commit;h=bcf9556b8fcd16ad8997f80cc92785f295c66701",
        "commit_title": "",
        "commit_text": "lvmetad: fix heap memory leak  error could be reproduced by calling pvs periodically:     #!/bin/bash     while :     do         pvs         sleep 1     done  use top command to watch RES memory of lvmetad. After a few minutes, its RES memory will grow for a few KB. Then stop calling pvs, while its RES will not decrease.  This is because, when lvmetad make reponse for clent request, it will malloc new chunk for s->vgid_to_metadata, while actually the new chunk should be added to the reponse dm_config_tree, or it will make the chunk list of s->vgid_to_metadata keep growing.  ",
        "func_before": "static response vg_lookup(lvmetad_state *s, request r)\n{\n\tstruct dm_config_tree *cft;\n\tstruct dm_config_node *metadata, *n;\n\tstruct vg_info *info;\n\tresponse res = { 0 };\n\tconst char *uuid = daemon_request_str(r, \"uuid\", NULL);\n\tconst char *name = daemon_request_str(r, \"name\", NULL);\n\tint count = 0;\n\n\tbuffer_init( &res.buffer );\n\n\tif (!uuid && !name) {\n\t\tERROR(s, \"vg_lookup with no uuid or name\");\n\t\treturn reply_unknown(\"VG not found\");\n\n\t} else if (!uuid || !name) {\n\t\tDEBUGLOG(s, \"vg_lookup vgid %s name %s needs lookup\",\n\t\t\t uuid ?: \"none\", name ?: \"none\");\n\n\t\tif (name && !uuid)\n\t\t\tuuid = dm_hash_lookup_with_count(s->vgname_to_vgid, name, &count);\n\t\telse if (uuid && !name)\n\t\t\tname = dm_hash_lookup(s->vgid_to_vgname, uuid);\n\n\t\tif (name && uuid && (count > 1)) {\n\t\t\tDEBUGLOG(s, \"vg_lookup name %s vgid %s found %d vgids\",\n\t\t\t\t name, uuid, count);\n\t\t\treturn daemon_reply_simple(\"multiple\", \"reason = %s\", \"Multiple VGs found with same name\", NULL);\n\t\t}\n\n\t\tif (!uuid || !name)\n\t\t\treturn reply_unknown(\"VG not found\");\n\n\t} else {\n\t\tchar *name_lookup = dm_hash_lookup(s->vgid_to_vgname, uuid);\n\t\tchar *uuid_lookup = dm_hash_lookup_with_val(s->vgname_to_vgid, name, uuid, strlen(uuid) + 1);\n\n\t\t/* FIXME: comment out these sanity checks when not testing */\n\n\t\tif (!name_lookup || !uuid_lookup) {\n\t\t\tERROR(s, \"vg_lookup vgid %s name %s found incomplete mapping uuid %s name %s\",\n\t\t\t      uuid, name, uuid_lookup ?: \"none\", name_lookup ?: \"none\");\n\t\t\treturn reply_unknown(\"VG mapping incomplete\");\n\t\t} else if (strcmp(name_lookup, name) || strcmp(uuid_lookup, uuid)) {\n\t\t\tERROR(s, \"vg_lookup vgid %s name %s found inconsistent mapping uuid %s name %s\",\n\t\t\t      uuid, name, uuid_lookup, name_lookup);\n\t\t\treturn reply_unknown(\"VG mapping inconsistent\");\n\t\t}\n\t}\n\n\tDEBUGLOG(s, \"vg_lookup vgid %s name %s\", uuid ?: \"none\", name ?: \"none\");\n\n\tcft = dm_hash_lookup(s->vgid_to_metadata, uuid);\n\tif (!cft || !cft->root) {\n\t\treturn reply_unknown(\"UUID not found\");\n\t}\n\n\tmetadata = cft->root;\n\tif (!(res.cft = dm_config_create()))\n\t\tgoto nomem_un;\n\n\t/* The response field */\n\tif (!(res.cft->root = n = dm_config_create_node(res.cft, \"response\")))\n\t\tgoto nomem_un;\n\n\tif (!(n->v = dm_config_create_value(cft)))\n\t\tgoto nomem_un;\n\n\tn->parent = res.cft->root;\n\tn->v->type = DM_CFG_STRING;\n\tn->v->v.str = \"OK\";\n\n\tif (!(n = n->sib = dm_config_create_node(res.cft, \"name\")))\n\t\tgoto nomem_un;\n\n\tif (!(n->v = dm_config_create_value(res.cft)))\n\t\tgoto nomem_un;\n\n\tn->parent = res.cft->root;\n\tn->v->type = DM_CFG_STRING;\n\tn->v->v.str = name;\n\n\t/* The metadata section */\n\tif (!(n = n->sib = dm_config_clone_node(res.cft, metadata, 1)))\n\t\tgoto nomem_un;\n\tn->parent = res.cft->root;\n\n\tif (!update_pv_status(s, res.cft, n))\n\t\tgoto nomem;\n\tchain_outdated_pvs(s, uuid, res.cft, n);\n\n\tif (s->flags & GLFL_INVALID)\n\t\tadd_last_node(res.cft, \"global_invalid\");\n\n\tinfo = dm_hash_lookup(s->vgid_to_info, uuid);\n\tif (info && (info->flags & VGFL_INVALID)) {\n\t\tif (!add_last_node(res.cft, \"vg_invalid\"))\n\t\t\tgoto nomem;\n\t}\n\n\treturn res;\n\nnomem_un:\nnomem:\n\treply_fail(\"out of memory\");\n\tERROR(s, \"vg_lookup vgid %s name %s out of memory.\", uuid ?: \"none\", name ?: \"none\");\n\tERROR(s, \"lvmetad could not be updated and is aborting.\");\n\texit(EXIT_FAILURE);\n}",
        "func": "static response vg_lookup(lvmetad_state *s, request r)\n{\n\tstruct dm_config_tree *cft;\n\tstruct dm_config_node *metadata, *n;\n\tstruct vg_info *info;\n\tresponse res = { 0 };\n\tconst char *uuid = daemon_request_str(r, \"uuid\", NULL);\n\tconst char *name = daemon_request_str(r, \"name\", NULL);\n\tint count = 0;\n\n\tbuffer_init( &res.buffer );\n\n\tif (!uuid && !name) {\n\t\tERROR(s, \"vg_lookup with no uuid or name\");\n\t\treturn reply_unknown(\"VG not found\");\n\n\t} else if (!uuid || !name) {\n\t\tDEBUGLOG(s, \"vg_lookup vgid %s name %s needs lookup\",\n\t\t\t uuid ?: \"none\", name ?: \"none\");\n\n\t\tif (name && !uuid)\n\t\t\tuuid = dm_hash_lookup_with_count(s->vgname_to_vgid, name, &count);\n\t\telse if (uuid && !name)\n\t\t\tname = dm_hash_lookup(s->vgid_to_vgname, uuid);\n\n\t\tif (name && uuid && (count > 1)) {\n\t\t\tDEBUGLOG(s, \"vg_lookup name %s vgid %s found %d vgids\",\n\t\t\t\t name, uuid, count);\n\t\t\treturn daemon_reply_simple(\"multiple\", \"reason = %s\", \"Multiple VGs found with same name\", NULL);\n\t\t}\n\n\t\tif (!uuid || !name)\n\t\t\treturn reply_unknown(\"VG not found\");\n\n\t} else {\n\t\tchar *name_lookup = dm_hash_lookup(s->vgid_to_vgname, uuid);\n\t\tchar *uuid_lookup = dm_hash_lookup_with_val(s->vgname_to_vgid, name, uuid, strlen(uuid) + 1);\n\n\t\t/* FIXME: comment out these sanity checks when not testing */\n\n\t\tif (!name_lookup || !uuid_lookup) {\n\t\t\tERROR(s, \"vg_lookup vgid %s name %s found incomplete mapping uuid %s name %s\",\n\t\t\t      uuid, name, uuid_lookup ?: \"none\", name_lookup ?: \"none\");\n\t\t\treturn reply_unknown(\"VG mapping incomplete\");\n\t\t} else if (strcmp(name_lookup, name) || strcmp(uuid_lookup, uuid)) {\n\t\t\tERROR(s, \"vg_lookup vgid %s name %s found inconsistent mapping uuid %s name %s\",\n\t\t\t      uuid, name, uuid_lookup, name_lookup);\n\t\t\treturn reply_unknown(\"VG mapping inconsistent\");\n\t\t}\n\t}\n\n\tDEBUGLOG(s, \"vg_lookup vgid %s name %s\", uuid ?: \"none\", name ?: \"none\");\n\n\tcft = dm_hash_lookup(s->vgid_to_metadata, uuid);\n\tif (!cft || !cft->root) {\n\t\treturn reply_unknown(\"UUID not found\");\n\t}\n\n\tmetadata = cft->root;\n\tif (!(res.cft = dm_config_create()))\n\t\tgoto nomem_un;\n\n\t/* The response field */\n\tif (!(res.cft->root = n = dm_config_create_node(res.cft, \"response\")))\n\t\tgoto nomem_un;\n\n\tif (!(n->v = dm_config_create_value(res.cft)))\n\t\tgoto nomem_un;\n\n\tn->parent = res.cft->root;\n\tn->v->type = DM_CFG_STRING;\n\tn->v->v.str = \"OK\";\n\n\tif (!(n = n->sib = dm_config_create_node(res.cft, \"name\")))\n\t\tgoto nomem_un;\n\n\tif (!(n->v = dm_config_create_value(res.cft)))\n\t\tgoto nomem_un;\n\n\tn->parent = res.cft->root;\n\tn->v->type = DM_CFG_STRING;\n\tn->v->v.str = name;\n\n\t/* The metadata section */\n\tif (!(n = n->sib = dm_config_clone_node(res.cft, metadata, 1)))\n\t\tgoto nomem_un;\n\tn->parent = res.cft->root;\n\n\tif (!update_pv_status(s, res.cft, n))\n\t\tgoto nomem;\n\tchain_outdated_pvs(s, uuid, res.cft, n);\n\n\tif (s->flags & GLFL_INVALID)\n\t\tadd_last_node(res.cft, \"global_invalid\");\n\n\tinfo = dm_hash_lookup(s->vgid_to_info, uuid);\n\tif (info && (info->flags & VGFL_INVALID)) {\n\t\tif (!add_last_node(res.cft, \"vg_invalid\"))\n\t\t\tgoto nomem;\n\t}\n\n\treturn res;\n\nnomem_un:\nnomem:\n\treply_fail(\"out of memory\");\n\tERROR(s, \"vg_lookup vgid %s name %s out of memory.\", uuid ?: \"none\", name ?: \"none\");\n\tERROR(s, \"lvmetad could not be updated and is aborting.\");\n\texit(EXIT_FAILURE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -64,7 +64,7 @@\n \tif (!(res.cft->root = n = dm_config_create_node(res.cft, \"response\")))\n \t\tgoto nomem_un;\n \n-\tif (!(n->v = dm_config_create_value(cft)))\n+\tif (!(n->v = dm_config_create_value(res.cft)))\n \t\tgoto nomem_un;\n \n \tn->parent = res.cft->root;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!(n->v = dm_config_create_value(cft)))"
            ],
            "added_lines": [
                "\tif (!(n->v = dm_config_create_value(res.cft)))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45204",
        "func_name": "gpac/dimC_box_read",
        "description": "GPAC v2.1-DEV-rev428-gcb8ae46c8-master was discovered to contain a memory leak via the function dimC_box_read at isomedia/box_code_3gpp.c.",
        "git_url": "https://github.com/gpac/gpac/commit/f045be5809808d64ebf8ce5ab628fa55786bea4f",
        "commit_title": "fixed #2307",
        "commit_text": "",
        "func_before": "GF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, msize;\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 3);\n\tp->profile = gf_bs_read_u8(bs);\n\tp->level = gf_bs_read_u8(bs);\n\tp->pathComponents = gf_bs_read_int(bs, 4);\n\tp->fullRequestHost = gf_bs_read_int(bs, 1);\n\tp->streamType = gf_bs_read_int(bs, 1);\n\tp->containsRedundant = gf_bs_read_int(bs, 2);\n\n\tchar *str = gf_malloc(sizeof(char)*(p->size+1));\n\tif (!str) return GF_OUT_OF_MEM;\n\tmsize = (u32) p->size;\n\tstr[msize] = 0;\n\ti=0;\n\tstr[0]=0;\n\twhile (i < msize) {\n\t\tISOM_DECREASE_SIZE(p, 1);\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tif (i == msize) {\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tp->textEncoding = gf_strdup(str);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < msize) {\n\t\tISOM_DECREASE_SIZE(p, 1);\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tif (i == msize) {\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tp->contentEncoding = gf_strdup(str);\n\tgf_free(str);\n\tif (!p->textEncoding || !p->contentEncoding)\n\t\treturn GF_OUT_OF_MEM;\n\treturn GF_OK;\n}",
        "func": "GF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = GF_OK;\n\tu32 i, msize;\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 3);\n\tp->profile = gf_bs_read_u8(bs);\n\tp->level = gf_bs_read_u8(bs);\n\tp->pathComponents = gf_bs_read_int(bs, 4);\n\tp->fullRequestHost = gf_bs_read_int(bs, 1);\n\tp->streamType = gf_bs_read_int(bs, 1);\n\tp->containsRedundant = gf_bs_read_int(bs, 2);\n\n\tchar *str = gf_malloc(sizeof(char)*(p->size+1));\n\tif (!str) return GF_OUT_OF_MEM;\n\tmsize = (u32) p->size;\n\tstr[msize] = 0;\n\ti=0;\n\tstr[0]=0;\n\twhile (i < msize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tif (i == msize) {\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tp->textEncoding = gf_strdup(str);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < msize) {\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tif (i == msize) {\n\t\tgf_free(str);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tp->contentEncoding = gf_strdup(str);\n\tgf_free(str);\n\tif (!p->textEncoding || !p->contentEncoding)\n\t\treturn GF_OUT_OF_MEM;\n\treturn GF_OK;\n\nexit:\n\tgf_free(str);\n\treturn e;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n GF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)\n {\n+\tGF_Err e = GF_OK;\n \tu32 i, msize;\n \tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n \n@@ -18,7 +19,7 @@\n \ti=0;\n \tstr[0]=0;\n \twhile (i < msize) {\n-\t\tISOM_DECREASE_SIZE(p, 1);\n+\t\tISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);\n \t\tstr[i] = gf_bs_read_u8(bs);\n \t\tif (!str[i]) break;\n \t\ti++;\n@@ -33,7 +34,7 @@\n \ti=0;\n \tstr[0]=0;\n \twhile (i < msize) {\n-\t\tISOM_DECREASE_SIZE(p, 1);\n+\t\tISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);\n \t\tstr[i] = gf_bs_read_u8(bs);\n \t\tif (!str[i]) break;\n \t\ti++;\n@@ -48,4 +49,8 @@\n \tif (!p->textEncoding || !p->contentEncoding)\n \t\treturn GF_OUT_OF_MEM;\n \treturn GF_OK;\n+\n+exit:\n+\tgf_free(str);\n+\treturn e;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tISOM_DECREASE_SIZE(p, 1);",
                "\t\tISOM_DECREASE_SIZE(p, 1);"
            ],
            "added_lines": [
                "\tGF_Err e = GF_OK;",
                "\t\tISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);",
                "\t\tISOM_DECREASE_SIZE_GOTO_EXIT(p, 1);",
                "",
                "exit:",
                "\tgf_free(str);",
                "\treturn e;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-25644",
        "func_name": "wildfly-security/wildfly-openssl-natives/remove_session_cb",
        "description": "A memory leak flaw was found in WildFly OpenSSL in versions prior to 1.1.3.Final, where it removes an HTTP session. It may allow the attacker to cause OOM leading to a denial of service. The highest threat from this vulnerability is to system availability.",
        "git_url": "https://github.com/wildfly-security/wildfly-openssl-natives/commit/7c26514676f3fb0dee0bcaa7d4680f982372950f",
        "commit_title": "WFSSL-51 sessions not removed correctly",
        "commit_text": "",
        "func_before": "void remove_session_cb(SSL_CTX *ctx, SSL_SESSION * session) {\n     tcn_ssl_ctxt_t  *c = SSL_CTX_get_app_data1(ctx);\n    JavaVM *javavm = tcn_get_java_vm();\n    jbyteArray sessionId;\n    JNIEnv *e;\n    (*javavm)->AttachCurrentThread(javavm, (void **)&e, NULL);\n    sessionId = getSessionId(e, session);\n\n    (*e)->CallVoidMethod(e, c->session_context, sessionRemove, sessionId);\n\n    (*javavm)->DetachCurrentThread(javavm);\n}",
        "func": "void remove_session_cb(SSL_CTX *ctx, SSL_SESSION * session) {\n     tcn_ssl_ctxt_t  *c = SSL_CTX_get_app_data1(ctx);\n    JavaVM *javavm = tcn_get_java_vm();\n    jbyteArray sessionId;\n    JNIEnv *e;\n    (*javavm)->AttachCurrentThread(javavm, (void **)&e, NULL);\n    sessionId = getSessionId(e, session);\n\n    (*e)->CallVoidMethod(e, c->session_context, sessionRemove, sessionId);\n\n    (*javavm)->DetachCurrentThread(javavm);\n    ssl_methods.SSL_SESSION_free(session);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,4 +9,5 @@\n     (*e)->CallVoidMethod(e, c->session_context, sessionRemove, sessionId);\n \n     (*javavm)->DetachCurrentThread(javavm);\n+    ssl_methods.SSL_SESSION_free(session);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    ssl_methods.SSL_SESSION_free(session);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-25704",
        "func_name": "torvalds/linux/perf_event_parse_addr_filter",
        "description": "A flaw memory leak in the Linux kernel performance monitoring subsystem was found in the way if using PERF_EVENT_IOC_SET_FILTER. A local user could use this flaw to starve the resources causing denial of service.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=7bdb157cdebbf95a1cd94ed2e01b338714075d00",
        "commit_title": "As shown through runtime testing, the \"filename\" allocation is not",
        "commit_text": "always freed in perf_event_parse_addr_filter().  There are three possible ways that this could happen:   - It could be allocated twice on subsequent iterations through the loop,  - or leaked on the success path,  - or on the failure path.  Clean up the code flow to make it obvious that 'filename' is always freed in the reallocation path and in the two return paths as well.  We rely on the fact that kfree(NULL) is NOP and filename is initialized with NULL.  This fixes the leak. No other side effects expected.  [ Dan Carpenter: cleaned up the code flow & added a changelog. ] [ Ingo Molnar: updated the changelog some more. ]  Cc: \"Srivatsa S. Bhat\" <srivatsa@csail.mit.edu> Cc: Anthony Liguori <aliguori@amazon.com> --  kernel/events/core.c | 12 +++++-------  1 file changed, 5 insertions(+), 7 deletions(-) ",
        "func_before": "static int\nperf_event_parse_addr_filter(struct perf_event *event, char *fstr,\n\t\t\t     struct list_head *filters)\n{\n\tstruct perf_addr_filter *filter = NULL;\n\tchar *start, *orig, *filename = NULL;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint state = IF_STATE_ACTION, token;\n\tunsigned int kernel = 0;\n\tint ret = -EINVAL;\n\n\torig = fstr = kstrdup(fstr, GFP_KERNEL);\n\tif (!fstr)\n\t\treturn -ENOMEM;\n\n\twhile ((start = strsep(&fstr, \" ,\\n\")) != NULL) {\n\t\tstatic const enum perf_addr_filter_action_t actions[] = {\n\t\t\t[IF_ACT_FILTER]\t= PERF_ADDR_FILTER_ACTION_FILTER,\n\t\t\t[IF_ACT_START]\t= PERF_ADDR_FILTER_ACTION_START,\n\t\t\t[IF_ACT_STOP]\t= PERF_ADDR_FILTER_ACTION_STOP,\n\t\t};\n\t\tret = -EINVAL;\n\n\t\tif (!*start)\n\t\t\tcontinue;\n\n\t\t/* filter definition begins */\n\t\tif (state == IF_STATE_ACTION) {\n\t\t\tfilter = perf_addr_filter_new(event, filters);\n\t\t\tif (!filter)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\ttoken = match_token(start, if_tokens, args);\n\t\tswitch (token) {\n\t\tcase IF_ACT_FILTER:\n\t\tcase IF_ACT_START:\n\t\tcase IF_ACT_STOP:\n\t\t\tif (state != IF_STATE_ACTION)\n\t\t\t\tgoto fail;\n\n\t\t\tfilter->action = actions[token];\n\t\t\tstate = IF_STATE_SOURCE;\n\t\t\tbreak;\n\n\t\tcase IF_SRC_KERNELADDR:\n\t\tcase IF_SRC_KERNEL:\n\t\t\tkernel = 1;\n\t\t\tfallthrough;\n\n\t\tcase IF_SRC_FILEADDR:\n\t\tcase IF_SRC_FILE:\n\t\t\tif (state != IF_STATE_SOURCE)\n\t\t\t\tgoto fail;\n\n\t\t\t*args[0].to = 0;\n\t\t\tret = kstrtoul(args[0].from, 0, &filter->offset);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\n\t\t\tif (token == IF_SRC_KERNEL || token == IF_SRC_FILE) {\n\t\t\t\t*args[1].to = 0;\n\t\t\t\tret = kstrtoul(args[1].from, 0, &filter->size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (token == IF_SRC_FILE || token == IF_SRC_FILEADDR) {\n\t\t\t\tint fpos = token == IF_SRC_FILE ? 2 : 1;\n\n\t\t\t\tfilename = match_strdup(&args[fpos]);\n\t\t\t\tif (!filename) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate = IF_STATE_END;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Filter definition is fully parsed, validate and install it.\n\t\t * Make sure that it doesn't contradict itself or the event's\n\t\t * attribute.\n\t\t */\n\t\tif (state == IF_STATE_END) {\n\t\t\tret = -EINVAL;\n\t\t\tif (kernel && event->attr.exclude_kernel)\n\t\t\t\tgoto fail;\n\n\t\t\t/*\n\t\t\t * ACTION \"filter\" must have a non-zero length region\n\t\t\t * specified.\n\t\t\t */\n\t\t\tif (filter->action == PERF_ADDR_FILTER_ACTION_FILTER &&\n\t\t\t    !filter->size)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!kernel) {\n\t\t\t\tif (!filename)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\t/*\n\t\t\t\t * For now, we only support file-based filters\n\t\t\t\t * in per-task events; doing so for CPU-wide\n\t\t\t\t * events requires additional context switching\n\t\t\t\t * trickery, since same object code will be\n\t\t\t\t * mapped at different virtual addresses in\n\t\t\t\t * different processes.\n\t\t\t\t */\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tif (!event->ctx->task)\n\t\t\t\t\tgoto fail_free_name;\n\n\t\t\t\t/* look up the path and grab its inode */\n\t\t\t\tret = kern_path(filename, LOOKUP_FOLLOW,\n\t\t\t\t\t\t&filter->path);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail_free_name;\n\n\t\t\t\tkfree(filename);\n\t\t\t\tfilename = NULL;\n\n\t\t\t\tret = -EINVAL;\n\t\t\t\tif (!filter->path.dentry ||\n\t\t\t\t    !S_ISREG(d_inode(filter->path.dentry)\n\t\t\t\t\t     ->i_mode))\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tevent->addr_filters.nr_file_filters++;\n\t\t\t}\n\n\t\t\t/* ready to consume more filters */\n\t\t\tstate = IF_STATE_ACTION;\n\t\t\tfilter = NULL;\n\t\t}\n\t}\n\n\tif (state != IF_STATE_ACTION)\n\t\tgoto fail;\n\n\tkfree(orig);\n\n\treturn 0;\n\nfail_free_name:\n\tkfree(filename);\nfail:\n\tfree_filters_list(filters);\n\tkfree(orig);\n\n\treturn ret;\n}",
        "func": "static int\nperf_event_parse_addr_filter(struct perf_event *event, char *fstr,\n\t\t\t     struct list_head *filters)\n{\n\tstruct perf_addr_filter *filter = NULL;\n\tchar *start, *orig, *filename = NULL;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint state = IF_STATE_ACTION, token;\n\tunsigned int kernel = 0;\n\tint ret = -EINVAL;\n\n\torig = fstr = kstrdup(fstr, GFP_KERNEL);\n\tif (!fstr)\n\t\treturn -ENOMEM;\n\n\twhile ((start = strsep(&fstr, \" ,\\n\")) != NULL) {\n\t\tstatic const enum perf_addr_filter_action_t actions[] = {\n\t\t\t[IF_ACT_FILTER]\t= PERF_ADDR_FILTER_ACTION_FILTER,\n\t\t\t[IF_ACT_START]\t= PERF_ADDR_FILTER_ACTION_START,\n\t\t\t[IF_ACT_STOP]\t= PERF_ADDR_FILTER_ACTION_STOP,\n\t\t};\n\t\tret = -EINVAL;\n\n\t\tif (!*start)\n\t\t\tcontinue;\n\n\t\t/* filter definition begins */\n\t\tif (state == IF_STATE_ACTION) {\n\t\t\tfilter = perf_addr_filter_new(event, filters);\n\t\t\tif (!filter)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\ttoken = match_token(start, if_tokens, args);\n\t\tswitch (token) {\n\t\tcase IF_ACT_FILTER:\n\t\tcase IF_ACT_START:\n\t\tcase IF_ACT_STOP:\n\t\t\tif (state != IF_STATE_ACTION)\n\t\t\t\tgoto fail;\n\n\t\t\tfilter->action = actions[token];\n\t\t\tstate = IF_STATE_SOURCE;\n\t\t\tbreak;\n\n\t\tcase IF_SRC_KERNELADDR:\n\t\tcase IF_SRC_KERNEL:\n\t\t\tkernel = 1;\n\t\t\tfallthrough;\n\n\t\tcase IF_SRC_FILEADDR:\n\t\tcase IF_SRC_FILE:\n\t\t\tif (state != IF_STATE_SOURCE)\n\t\t\t\tgoto fail;\n\n\t\t\t*args[0].to = 0;\n\t\t\tret = kstrtoul(args[0].from, 0, &filter->offset);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\n\t\t\tif (token == IF_SRC_KERNEL || token == IF_SRC_FILE) {\n\t\t\t\t*args[1].to = 0;\n\t\t\t\tret = kstrtoul(args[1].from, 0, &filter->size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (token == IF_SRC_FILE || token == IF_SRC_FILEADDR) {\n\t\t\t\tint fpos = token == IF_SRC_FILE ? 2 : 1;\n\n\t\t\t\tkfree(filename);\n\t\t\t\tfilename = match_strdup(&args[fpos]);\n\t\t\t\tif (!filename) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate = IF_STATE_END;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Filter definition is fully parsed, validate and install it.\n\t\t * Make sure that it doesn't contradict itself or the event's\n\t\t * attribute.\n\t\t */\n\t\tif (state == IF_STATE_END) {\n\t\t\tret = -EINVAL;\n\t\t\tif (kernel && event->attr.exclude_kernel)\n\t\t\t\tgoto fail;\n\n\t\t\t/*\n\t\t\t * ACTION \"filter\" must have a non-zero length region\n\t\t\t * specified.\n\t\t\t */\n\t\t\tif (filter->action == PERF_ADDR_FILTER_ACTION_FILTER &&\n\t\t\t    !filter->size)\n\t\t\t\tgoto fail;\n\n\t\t\tif (!kernel) {\n\t\t\t\tif (!filename)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\t/*\n\t\t\t\t * For now, we only support file-based filters\n\t\t\t\t * in per-task events; doing so for CPU-wide\n\t\t\t\t * events requires additional context switching\n\t\t\t\t * trickery, since same object code will be\n\t\t\t\t * mapped at different virtual addresses in\n\t\t\t\t * different processes.\n\t\t\t\t */\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tif (!event->ctx->task)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\t/* look up the path and grab its inode */\n\t\t\t\tret = kern_path(filename, LOOKUP_FOLLOW,\n\t\t\t\t\t\t&filter->path);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tret = -EINVAL;\n\t\t\t\tif (!filter->path.dentry ||\n\t\t\t\t    !S_ISREG(d_inode(filter->path.dentry)\n\t\t\t\t\t     ->i_mode))\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tevent->addr_filters.nr_file_filters++;\n\t\t\t}\n\n\t\t\t/* ready to consume more filters */\n\t\t\tstate = IF_STATE_ACTION;\n\t\t\tfilter = NULL;\n\t\t}\n\t}\n\n\tif (state != IF_STATE_ACTION)\n\t\tgoto fail;\n\n\tkfree(filename);\n\tkfree(orig);\n\n\treturn 0;\n\nfail:\n\tkfree(filename);\n\tfree_filters_list(filters);\n\tkfree(orig);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -68,6 +68,7 @@\n \t\t\tif (token == IF_SRC_FILE || token == IF_SRC_FILEADDR) {\n \t\t\t\tint fpos = token == IF_SRC_FILE ? 2 : 1;\n \n+\t\t\t\tkfree(filename);\n \t\t\t\tfilename = match_strdup(&args[fpos]);\n \t\t\t\tif (!filename) {\n \t\t\t\t\tret = -ENOMEM;\n@@ -114,16 +115,13 @@\n \t\t\t\t */\n \t\t\t\tret = -EOPNOTSUPP;\n \t\t\t\tif (!event->ctx->task)\n-\t\t\t\t\tgoto fail_free_name;\n+\t\t\t\t\tgoto fail;\n \n \t\t\t\t/* look up the path and grab its inode */\n \t\t\t\tret = kern_path(filename, LOOKUP_FOLLOW,\n \t\t\t\t\t\t&filter->path);\n \t\t\t\tif (ret)\n-\t\t\t\t\tgoto fail_free_name;\n-\n-\t\t\t\tkfree(filename);\n-\t\t\t\tfilename = NULL;\n+\t\t\t\t\tgoto fail;\n \n \t\t\t\tret = -EINVAL;\n \t\t\t\tif (!filter->path.dentry ||\n@@ -143,13 +141,13 @@\n \tif (state != IF_STATE_ACTION)\n \t\tgoto fail;\n \n+\tkfree(filename);\n \tkfree(orig);\n \n \treturn 0;\n \n-fail_free_name:\n+fail:\n \tkfree(filename);\n-fail:\n \tfree_filters_list(filters);\n \tkfree(orig);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tgoto fail_free_name;",
                "\t\t\t\t\tgoto fail_free_name;",
                "",
                "\t\t\t\tkfree(filename);",
                "\t\t\t\tfilename = NULL;",
                "fail_free_name:",
                "fail:"
            ],
            "added_lines": [
                "\t\t\t\tkfree(filename);",
                "\t\t\t\t\tgoto fail;",
                "\t\t\t\t\tgoto fail;",
                "\tkfree(filename);",
                "fail:"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26418",
        "func_name": "wireshark/decompress_none",
        "description": "Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e",
        "commit_title": "Kafka: Limit our decompression size.",
        "commit_text": " Don't assume that the Internet has our best interests at heart when it gives us the size of our decompression buffer. Assign an arbitrary limit of 50 MB.  This fixes #16739 in that it takes care of  ** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion \"end >= fi->start\"  which is different from the original error output. It looks like *that* might have taken care of in one of the other recent Kafka bug fixes.  The decompression routines return a success or failure status. Use gbooleans instead of ints for that. ",
        "func_before": "static int\ndecompress_none(tvbuff_t *tvb, packet_info *pinfo _U_, int offset, guint32 length _U_, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    *decompressed_tvb = tvb;\n    *decompressed_offset = offset;\n    return 1;\n}",
        "func": "static gboolean\ndecompress_none(tvbuff_t *tvb, packet_info *pinfo _U_, int offset, guint32 length _U_, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    *decompressed_tvb = tvb;\n    *decompressed_offset = offset;\n    return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n-static int\n+static gboolean\n decompress_none(tvbuff_t *tvb, packet_info *pinfo _U_, int offset, guint32 length _U_, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n {\n     *decompressed_tvb = tvb;\n     *decompressed_offset = offset;\n-    return 1;\n+    return TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int",
                "    return 1;"
            ],
            "added_lines": [
                "static gboolean",
                "    return TRUE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26418",
        "func_name": "wireshark/decompress_gzip",
        "description": "Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e",
        "commit_title": "Kafka: Limit our decompression size.",
        "commit_text": " Don't assume that the Internet has our best interests at heart when it gives us the size of our decompression buffer. Assign an arbitrary limit of 50 MB.  This fixes #16739 in that it takes care of  ** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion \"end >= fi->start\"  which is different from the original error output. It looks like *that* might have taken care of in one of the other recent Kafka bug fixes.  The decompression routines return a success or failure status. Use gbooleans instead of ints for that. ",
        "func_before": "static int\ndecompress_gzip(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    *decompressed_tvb = tvb_child_uncompress(tvb, tvb, offset, length);\n    *decompressed_offset = 0;\n    if (*decompressed_tvb) {\n        return 1;\n    } else {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [gzip decompression failed] \");\n        return 0;\n    }\n}",
        "func": "static gboolean\ndecompress_gzip(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    *decompressed_tvb = tvb_child_uncompress(tvb, tvb, offset, length);\n    *decompressed_offset = 0;\n    if (*decompressed_tvb) {\n        return TRUE;\n    } else {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [gzip decompression failed] \");\n        return FALSE;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,12 @@\n-static int\n+static gboolean\n decompress_gzip(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n {\n     *decompressed_tvb = tvb_child_uncompress(tvb, tvb, offset, length);\n     *decompressed_offset = 0;\n     if (*decompressed_tvb) {\n-        return 1;\n+        return TRUE;\n     } else {\n         col_append_str(pinfo->cinfo, COL_INFO, \" [gzip decompression failed] \");\n-        return 0;\n+        return FALSE;\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int",
                "        return 1;",
                "        return 0;"
            ],
            "added_lines": [
                "static gboolean",
                "        return TRUE;",
                "        return FALSE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26418",
        "func_name": "wireshark/decompress_lz4",
        "description": "Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e",
        "commit_title": "Kafka: Limit our decompression size.",
        "commit_text": " Don't assume that the Internet has our best interests at heart when it gives us the size of our decompression buffer. Assign an arbitrary limit of 50 MB.  This fixes #16739 in that it takes care of  ** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion \"end >= fi->start\"  which is different from the original error output. It looks like *that* might have taken care of in one of the other recent Kafka bug fixes.  The decompression routines return a success or failure status. Use gbooleans instead of ints for that. ",
        "func_before": "static int\ndecompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    LZ4F_decompressionContext_t lz4_ctxt = NULL;\n    LZ4F_frameInfo_t lz4_info;\n    LZ4F_errorCode_t rc = 0;\n    size_t src_offset = 0, src_size = 0, dst_size = 0;\n    guchar *decompressed_buffer = NULL;\n    tvbuff_t *composite_tvb = NULL;\n\n    int ret = 0;\n\n    /* Prepare compressed data buffer */\n    guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);\n    /* Override header checksum to workaround buggy Kafka implementations */\n    if (length > 7) {\n        guint32 hdr_end = 6;\n        if (data[4] & 0x08) {\n            hdr_end += 8;\n        }\n        if (hdr_end < length) {\n            data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff;\n        }\n    }\n\n    /* Allocate output buffer */\n    rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    src_offset = length;\n    rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    switch (lz4_info.blockSizeID) {\n        case LZ4F_max64KB:\n            dst_size = 1 << 16;\n            break;\n        case LZ4F_max256KB:\n            dst_size = 1 << 18;\n            break;\n        case LZ4F_max1MB:\n            dst_size = 1 << 20;\n            break;\n        case LZ4F_max4MB:\n            dst_size = 1 << 22;\n            break;\n        default:\n            goto end;\n    }\n\n    if (lz4_info.contentSize && lz4_info.contentSize < dst_size) {\n        dst_size = (size_t)lz4_info.contentSize;\n    }\n\n    do {\n        src_size = length - src_offset; // set the number of available octets\n        if (src_size == 0) {\n            goto end;\n        }\n        decompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, dst_size);\n        rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &dst_size,\n                              &data[src_offset], &src_size, NULL);\n        if (LZ4F_isError(rc)) {\n            goto end;\n        }\n        if (dst_size == 0) {\n            goto end;\n        }\n        if (!composite_tvb) {\n            composite_tvb = tvb_new_composite();\n        }\n        tvb_composite_append(composite_tvb,\n                             tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)dst_size, (gint)dst_size));\n        src_offset += src_size; // bump up the offset for the next iteration\n    } while (rc > 0);\n\n    ret = 1;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n    }\n    LZ4F_freeDecompressionContext(lz4_ctxt);\n    if (ret == 1) {\n        *decompressed_tvb = composite_tvb;\n        *decompressed_offset = 0;\n    }\n    else {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [lz4 decompression failed]\");\n    }\n    return ret;\n}",
        "func": "static gboolean\ndecompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    LZ4F_decompressionContext_t lz4_ctxt = NULL;\n    LZ4F_frameInfo_t lz4_info;\n    LZ4F_errorCode_t rc = 0;\n    size_t src_offset = 0, src_size = 0, dst_size = 0;\n    guchar *decompressed_buffer = NULL;\n    tvbuff_t *composite_tvb = NULL;\n\n    gboolean ret = FALSE;\n\n    /* Prepare compressed data buffer */\n    guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);\n    /* Override header checksum to workaround buggy Kafka implementations */\n    if (length > 7) {\n        guint32 hdr_end = 6;\n        if (data[4] & 0x08) {\n            hdr_end += 8;\n        }\n        if (hdr_end < length) {\n            data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff;\n        }\n    }\n\n    /* Allocate output buffer */\n    rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    src_offset = length;\n    rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    switch (lz4_info.blockSizeID) {\n        case LZ4F_max64KB:\n            dst_size = 1 << 16;\n            break;\n        case LZ4F_max256KB:\n            dst_size = 1 << 18;\n            break;\n        case LZ4F_max1MB:\n            dst_size = 1 << 20;\n            break;\n        case LZ4F_max4MB:\n            dst_size = 1 << 22;\n            break;\n        default:\n            goto end;\n    }\n\n    if (lz4_info.contentSize && lz4_info.contentSize < dst_size) {\n        dst_size = (size_t)lz4_info.contentSize;\n    }\n\n    do {\n        src_size = length - src_offset; // set the number of available octets\n        if (src_size == 0) {\n            goto end;\n        }\n        decompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, dst_size);\n        rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &dst_size,\n                              &data[src_offset], &src_size, NULL);\n        if (LZ4F_isError(rc)) {\n            goto end;\n        }\n        if (dst_size == 0) {\n            goto end;\n        }\n        if (!composite_tvb) {\n            composite_tvb = tvb_new_composite();\n        }\n        tvb_composite_append(composite_tvb,\n                             tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)dst_size, (gint)dst_size));\n        src_offset += src_size; // bump up the offset for the next iteration\n    } while (rc > 0);\n\n    ret = TRUE;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n    }\n    LZ4F_freeDecompressionContext(lz4_ctxt);\n    if (ret == 1) {\n        *decompressed_tvb = composite_tvb;\n        *decompressed_offset = 0;\n    }\n    else {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [lz4 decompression failed]\");\n    }\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int\n+static gboolean\n decompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n {\n     LZ4F_decompressionContext_t lz4_ctxt = NULL;\n@@ -8,7 +8,7 @@\n     guchar *decompressed_buffer = NULL;\n     tvbuff_t *composite_tvb = NULL;\n \n-    int ret = 0;\n+    gboolean ret = FALSE;\n \n     /* Prepare compressed data buffer */\n     guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);\n@@ -78,7 +78,7 @@\n         src_offset += src_size; // bump up the offset for the next iteration\n     } while (rc > 0);\n \n-    ret = 1;\n+    ret = TRUE;\n end:\n     if (composite_tvb) {\n         tvb_composite_finalize(composite_tvb);",
        "diff_line_info": {
            "deleted_lines": [
                "static int",
                "    int ret = 0;",
                "    ret = 1;"
            ],
            "added_lines": [
                "static gboolean",
                "    gboolean ret = FALSE;",
                "    ret = TRUE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26418",
        "func_name": "wireshark/decompress_snappy",
        "description": "Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e",
        "commit_title": "Kafka: Limit our decompression size.",
        "commit_text": " Don't assume that the Internet has our best interests at heart when it gives us the size of our decompression buffer. Assign an arbitrary limit of 50 MB.  This fixes #16739 in that it takes care of  ** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion \"end >= fi->start\"  which is different from the original error output. It looks like *that* might have taken care of in one of the other recent Kafka bug fixes.  The decompression routines return a success or failure status. Use gbooleans instead of ints for that. ",
        "func_before": "static int\ndecompress_snappy(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);\n    size_t uncompressed_size;\n    snappy_status rc = SNAPPY_OK;\n    tvbuff_t *composite_tvb = NULL;\n    int ret = 0;\n\n    if (tvb_memeql(tvb, offset, kafka_xerial_header, sizeof(kafka_xerial_header)) == 0) {\n\n        /* xerial framing format */\n        guint32 chunk_size, pos = 16;\n\n        while (pos < length) {\n            if (pos > length-4) {\n                // XXX - this is presumably an error, as the chunk size\n                // doesn't fully fit in the data, so an error should be\n                // reported.\n                goto end;\n            }\n            chunk_size = tvb_get_ntohl(tvb, offset+pos);\n            pos += 4;\n            if (chunk_size > length) {\n                // XXX - this is presumably an error, as the chunk to be\n                // decompressed doesn't fully fit in the data, so an error\n                // should be reported.\n                goto end;\n            }\n            if (pos > length-chunk_size) {\n                // XXX - this is presumably an error, as the chunk to be\n                // decompressed doesn't fully fit in the data, so an error\n                // should be reported.\n                goto end;\n            }\n            rc = snappy_uncompressed_length(&data[pos], chunk_size, &uncompressed_size);\n            if (rc != SNAPPY_OK) {\n                goto end;\n            }\n            guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n            rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &uncompressed_size);\n            if (rc != SNAPPY_OK) {\n                goto end;\n            }\n\n            if (!composite_tvb) {\n                composite_tvb = tvb_new_composite();\n            }\n            tvb_composite_append(composite_tvb,\n                      tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size));\n            pos += chunk_size;\n        }\n\n    } else {\n\n        /* unframed format */\n        rc = snappy_uncompressed_length(data, length, &uncompressed_size);\n        if (rc != SNAPPY_OK) {\n            goto end;\n        }\n\n        guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n\n        rc = snappy_uncompress(data, length, decompressed_buffer, &uncompressed_size);\n        if (rc != SNAPPY_OK) {\n            goto end;\n        }\n\n        *decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size);\n        *decompressed_offset = 0;\n\n    }\n    ret = 1;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n        if (ret == 1) {\n            *decompressed_tvb = composite_tvb;\n            *decompressed_offset = 0;\n        }\n    }\n    if (ret == 0) {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [snappy decompression failed]\");\n    }\n    return ret;\n}",
        "func": "static gboolean\ndecompress_snappy(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);\n    size_t uncompressed_size;\n    snappy_status rc = SNAPPY_OK;\n    tvbuff_t *composite_tvb = NULL;\n    gboolean ret = FALSE;\n\n    if (tvb_memeql(tvb, offset, kafka_xerial_header, sizeof(kafka_xerial_header)) == 0) {\n\n        /* xerial framing format */\n        guint32 chunk_size, pos = 16;\n\n        while (pos < length) {\n            if (pos > length-4) {\n                // XXX - this is presumably an error, as the chunk size\n                // doesn't fully fit in the data, so an error should be\n                // reported.\n                goto end;\n            }\n            chunk_size = tvb_get_ntohl(tvb, offset+pos);\n            pos += 4;\n            if (chunk_size > length) {\n                // XXX - this is presumably an error, as the chunk to be\n                // decompressed doesn't fully fit in the data, so an error\n                // should be reported.\n                goto end;\n            }\n            if (pos > length-chunk_size) {\n                // XXX - this is presumably an error, as the chunk to be\n                // decompressed doesn't fully fit in the data, so an error\n                // should be reported.\n                goto end;\n            }\n            rc = snappy_uncompressed_length(&data[pos], chunk_size, &uncompressed_size);\n            if (rc != SNAPPY_OK) {\n                goto end;\n            }\n            guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n            rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &uncompressed_size);\n            if (rc != SNAPPY_OK) {\n                goto end;\n            }\n\n            if (!composite_tvb) {\n                composite_tvb = tvb_new_composite();\n            }\n            tvb_composite_append(composite_tvb,\n                      tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size));\n            pos += chunk_size;\n        }\n\n    } else {\n\n        /* unframed format */\n        rc = snappy_uncompressed_length(data, length, &uncompressed_size);\n        if (rc != SNAPPY_OK) {\n            goto end;\n        }\n\n        guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n\n        rc = snappy_uncompress(data, length, decompressed_buffer, &uncompressed_size);\n        if (rc != SNAPPY_OK) {\n            goto end;\n        }\n\n        *decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size);\n        *decompressed_offset = 0;\n\n    }\n    ret = TRUE;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n        if (ret == 1) {\n            *decompressed_tvb = composite_tvb;\n            *decompressed_offset = 0;\n        }\n    }\n    if (ret == FALSE) {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [snappy decompression failed]\");\n    }\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,11 @@\n-static int\n+static gboolean\n decompress_snappy(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n {\n     guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);\n     size_t uncompressed_size;\n     snappy_status rc = SNAPPY_OK;\n     tvbuff_t *composite_tvb = NULL;\n-    int ret = 0;\n+    gboolean ret = FALSE;\n \n     if (tvb_memeql(tvb, offset, kafka_xerial_header, sizeof(kafka_xerial_header)) == 0) {\n \n@@ -70,7 +70,7 @@\n         *decompressed_offset = 0;\n \n     }\n-    ret = 1;\n+    ret = TRUE;\n end:\n     if (composite_tvb) {\n         tvb_composite_finalize(composite_tvb);\n@@ -79,7 +79,7 @@\n             *decompressed_offset = 0;\n         }\n     }\n-    if (ret == 0) {\n+    if (ret == FALSE) {\n         col_append_str(pinfo->cinfo, COL_INFO, \" [snappy decompression failed]\");\n     }\n     return ret;",
        "diff_line_info": {
            "deleted_lines": [
                "static int",
                "    int ret = 0;",
                "    ret = 1;",
                "    if (ret == 0) {"
            ],
            "added_lines": [
                "static gboolean",
                "    gboolean ret = FALSE;",
                "    ret = TRUE;",
                "    if (ret == FALSE) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26418",
        "func_name": "wireshark/dissect_kafka_message_old",
        "description": "Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e",
        "commit_title": "Kafka: Limit our decompression size.",
        "commit_text": " Don't assume that the Internet has our best interests at heart when it gives us the size of our decompression buffer. Assign an arbitrary limit of 50 MB.  This fixes #16739 in that it takes care of  ** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion \"end >= fi->start\"  which is different from the original error output. It looks like *that* might have taken care of in one of the other recent Kafka bug fixes.  The decompression routines return a success or failure status. Use gbooleans instead of ints for that. ",
        "func_before": "static int\ndissect_kafka_message_old(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int end_offset _U_)\n{\n    proto_item  *message_ti;\n    proto_tree  *subtree;\n    tvbuff_t    *decompressed_tvb;\n    int         decompressed_offset;\n    int         start_offset = offset;\n    int         bytes_offset;\n    gint8       magic_byte;\n    guint8      codec;\n    guint32     message_size;\n    guint32     length;\n\n    message_size = tvb_get_guint32(tvb, start_offset + 8, ENC_BIG_ENDIAN);\n\n    subtree = proto_tree_add_subtree(tree, tvb, start_offset, message_size + 12, ett_kafka_message, &message_ti, \"Message\");\n\n    offset = dissect_kafka_int64(subtree, hf_kafka_offset, tvb, pinfo, offset, NULL);\n\n    offset = dissect_kafka_int32(subtree, hf_kafka_message_size, tvb, pinfo, offset, NULL);\n\n    offset = dissect_kafka_int32(subtree, hf_kafka_message_crc, tvb, pinfo, offset, NULL);\n\n    offset = dissect_kafka_int8(subtree, hf_kafka_message_magic, tvb, pinfo, offset, &magic_byte);\n\n    offset = dissect_kafka_int8(subtree, hf_kafka_message_codec, tvb, pinfo, offset, &codec);\n    codec &= KAFKA_MESSAGE_CODEC_MASK;\n\n    offset = dissect_kafka_int8(subtree, hf_kafka_message_timestamp_type, tvb, pinfo, offset, NULL);\n\n    if (magic_byte == 1) {\n        proto_tree_add_item(subtree, hf_kafka_message_timestamp, tvb, offset, 8, ENC_TIME_MSECS|ENC_BIG_ENDIAN);\n        offset += 8;\n    }\n\n    bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_key, tvb, pinfo, offset, NULL, NULL);\n    if (bytes_offset > offset) {\n        offset = bytes_offset;\n    } else {\n        expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length);\n        return offset;\n    }\n\n    /*\n     * depending on the compression codec, the payload is the actual message payload (codes=none)\n     * or compressed set of messages (otherwise). In the new format (since Kafka 1.0) there\n     * is no such duality.\n     */\n    if (codec == 0) {\n        bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_value, tvb, pinfo, offset, NULL, &length);\n        if (bytes_offset > offset) {\n            offset = bytes_offset;\n        } else {\n            expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length);\n            return offset;\n        }\n    } else {\n        length = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (decompress(tvb, pinfo, offset, length, codec, &decompressed_tvb, &decompressed_offset)==1) {\n            add_new_data_source(pinfo, decompressed_tvb, \"Decompressed content\");\n            show_compression_reduction(tvb, subtree, length, tvb_captured_length(decompressed_tvb));\n            dissect_kafka_message_set(decompressed_tvb, pinfo, subtree, decompressed_offset,\n                tvb_reported_length_remaining(decompressed_tvb, decompressed_offset), codec);\n        } else {\n            proto_item_append_text(subtree, \" [Cannot decompress records]\");\n        }\n        offset += length;\n    }\n\n    proto_item_set_end(message_ti, tvb, offset);\n\n    return offset;\n}",
        "func": "static int\ndissect_kafka_message_old(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int end_offset _U_)\n{\n    proto_item  *message_ti;\n    proto_tree  *subtree;\n    tvbuff_t    *decompressed_tvb;\n    int         decompressed_offset;\n    int         start_offset = offset;\n    int         bytes_offset;\n    gint8       magic_byte;\n    guint8      codec;\n    guint32     message_size;\n    guint32     length;\n\n    message_size = tvb_get_guint32(tvb, start_offset + 8, ENC_BIG_ENDIAN);\n\n    subtree = proto_tree_add_subtree(tree, tvb, start_offset, message_size + 12, ett_kafka_message, &message_ti, \"Message\");\n\n    offset = dissect_kafka_int64(subtree, hf_kafka_offset, tvb, pinfo, offset, NULL);\n\n    offset = dissect_kafka_int32(subtree, hf_kafka_message_size, tvb, pinfo, offset, NULL);\n\n    offset = dissect_kafka_int32(subtree, hf_kafka_message_crc, tvb, pinfo, offset, NULL);\n\n    offset = dissect_kafka_int8(subtree, hf_kafka_message_magic, tvb, pinfo, offset, &magic_byte);\n\n    offset = dissect_kafka_int8(subtree, hf_kafka_message_codec, tvb, pinfo, offset, &codec);\n    codec &= KAFKA_MESSAGE_CODEC_MASK;\n\n    offset = dissect_kafka_int8(subtree, hf_kafka_message_timestamp_type, tvb, pinfo, offset, NULL);\n\n    if (magic_byte == 1) {\n        proto_tree_add_item(subtree, hf_kafka_message_timestamp, tvb, offset, 8, ENC_TIME_MSECS|ENC_BIG_ENDIAN);\n        offset += 8;\n    }\n\n    bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_key, tvb, pinfo, offset, NULL, NULL);\n    if (bytes_offset > offset) {\n        offset = bytes_offset;\n    } else {\n        expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length);\n        return offset;\n    }\n\n    /*\n     * depending on the compression codec, the payload is the actual message payload (codes=none)\n     * or compressed set of messages (otherwise). In the new format (since Kafka 1.0) there\n     * is no such duality.\n     */\n    if (codec == 0) {\n        bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_value, tvb, pinfo, offset, NULL, &length);\n        if (bytes_offset > offset) {\n            offset = bytes_offset;\n        } else {\n            expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length);\n            return offset;\n        }\n    } else {\n        length = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (decompress(tvb, pinfo, offset, length, codec, &decompressed_tvb, &decompressed_offset)==1) {\n            add_new_data_source(pinfo, decompressed_tvb, \"Decompressed content\");\n            show_compression_reduction(tvb, subtree, length, tvb_captured_length(decompressed_tvb));\n            dissect_kafka_message_set(decompressed_tvb, pinfo, subtree, decompressed_offset,\n                tvb_reported_length_remaining(decompressed_tvb, decompressed_offset), codec);\n            offset += length;\n        } else {\n            proto_item_append_text(subtree, \" [Cannot decompress records]\");\n        }\n    }\n\n    proto_item_set_end(message_ti, tvb, offset);\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -63,10 +63,10 @@\n             show_compression_reduction(tvb, subtree, length, tvb_captured_length(decompressed_tvb));\n             dissect_kafka_message_set(decompressed_tvb, pinfo, subtree, decompressed_offset,\n                 tvb_reported_length_remaining(decompressed_tvb, decompressed_offset), codec);\n+            offset += length;\n         } else {\n             proto_item_append_text(subtree, \" [Cannot decompress records]\");\n         }\n-        offset += length;\n     }\n \n     proto_item_set_end(message_ti, tvb, offset);",
        "diff_line_info": {
            "deleted_lines": [
                "        offset += length;"
            ],
            "added_lines": [
                "            offset += length;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26418",
        "func_name": "wireshark/decompress",
        "description": "Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e",
        "commit_title": "Kafka: Limit our decompression size.",
        "commit_text": " Don't assume that the Internet has our best interests at heart when it gives us the size of our decompression buffer. Assign an arbitrary limit of 50 MB.  This fixes #16739 in that it takes care of  ** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion \"end >= fi->start\"  which is different from the original error output. It looks like *that* might have taken care of in one of the other recent Kafka bug fixes.  The decompression routines return a success or failure status. Use gbooleans instead of ints for that. ",
        "func_before": "static int\ndecompress(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, int codec, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    switch (codec) {\n        case KAFKA_MESSAGE_CODEC_SNAPPY:\n            return decompress_snappy(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        case KAFKA_MESSAGE_CODEC_LZ4:\n            return decompress_lz4(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        case KAFKA_MESSAGE_CODEC_ZSTD:\n            return decompress_zstd(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        case KAFKA_MESSAGE_CODEC_GZIP:\n            return decompress_gzip(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        case KAFKA_MESSAGE_CODEC_NONE:\n            return decompress_none(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        default:\n            col_append_str(pinfo->cinfo, COL_INFO, \" [unsupported compression type]\");\n            return 0;\n    }\n}",
        "func": "static gboolean\ndecompress(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, int codec, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    if (length > MAX_DECOMPRESSION_SIZE) {\n        expert_add_info(pinfo, NULL, &ei_kafka_bad_decompression_length);\n        return FALSE;\n    }\n    switch (codec) {\n        case KAFKA_MESSAGE_CODEC_SNAPPY:\n            return decompress_snappy(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        case KAFKA_MESSAGE_CODEC_LZ4:\n            return decompress_lz4(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        case KAFKA_MESSAGE_CODEC_ZSTD:\n            return decompress_zstd(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        case KAFKA_MESSAGE_CODEC_GZIP:\n            return decompress_gzip(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        case KAFKA_MESSAGE_CODEC_NONE:\n            return decompress_none(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n        default:\n            col_append_str(pinfo->cinfo, COL_INFO, \" [unsupported compression type]\");\n            return FALSE;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,10 @@\n-static int\n+static gboolean\n decompress(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, int codec, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n {\n+    if (length > MAX_DECOMPRESSION_SIZE) {\n+        expert_add_info(pinfo, NULL, &ei_kafka_bad_decompression_length);\n+        return FALSE;\n+    }\n     switch (codec) {\n         case KAFKA_MESSAGE_CODEC_SNAPPY:\n             return decompress_snappy(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n@@ -14,6 +18,6 @@\n             return decompress_none(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);\n         default:\n             col_append_str(pinfo->cinfo, COL_INFO, \" [unsupported compression type]\");\n-            return 0;\n+            return FALSE;\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int",
                "            return 0;"
            ],
            "added_lines": [
                "static gboolean",
                "    if (length > MAX_DECOMPRESSION_SIZE) {",
                "        expert_add_info(pinfo, NULL, &ei_kafka_bad_decompression_length);",
                "        return FALSE;",
                "    }",
                "            return FALSE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26418",
        "func_name": "wireshark/proto_register_kafka_expert_module",
        "description": "Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e",
        "commit_title": "Kafka: Limit our decompression size.",
        "commit_text": " Don't assume that the Internet has our best interests at heart when it gives us the size of our decompression buffer. Assign an arbitrary limit of 50 MB.  This fixes #16739 in that it takes care of  ** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion \"end >= fi->start\"  which is different from the original error output. It looks like *that* might have taken care of in one of the other recent Kafka bug fixes.  The decompression routines return a success or failure status. Use gbooleans instead of ints for that. ",
        "func_before": "static void\nproto_register_kafka_expert_module(const int proto) {\n    expert_module_t* expert_kafka;\n    static ei_register_info ei[] = {\n            { &ei_kafka_request_missing,\n                    { \"kafka.request_missing\", PI_UNDECODED, PI_WARN, \"Request missing\", EXPFILL }},\n            { &ei_kafka_unknown_api_key,\n                    { \"kafka.unknown_api_key\", PI_UNDECODED, PI_WARN, \"Unknown API key\", EXPFILL }},\n            { &ei_kafka_unsupported_api_version,\n                    { \"kafka.unsupported_api_version\", PI_UNDECODED, PI_WARN, \"Unsupported API version\", EXPFILL }},\n            { &ei_kafka_bad_string_length,\n                    { \"kafka.bad_string_length\", PI_MALFORMED, PI_WARN, \"Invalid string length field\", EXPFILL }},\n            { &ei_kafka_bad_bytes_length,\n                    { \"kafka.bad_bytes_length\", PI_MALFORMED, PI_WARN, \"Invalid byte length field\", EXPFILL }},\n            { &ei_kafka_bad_array_length,\n                    { \"kafka.bad_array_length\", PI_MALFORMED, PI_WARN, \"Invalid array length field\", EXPFILL }},\n            { &ei_kafka_bad_record_length,\n                    { \"kafka.bad_record_length\", PI_MALFORMED, PI_WARN, \"Invalid record length field\", EXPFILL }},\n            { &ei_kafka_bad_varint,\n                    { \"kafka.bad_varint\", PI_MALFORMED, PI_WARN, \"Invalid varint bytes\", EXPFILL }},\n            { &ei_kafka_bad_message_set_length,\n                    { \"kafka.ei_kafka_bad_message_set_length\", PI_MALFORMED, PI_WARN, \"Message set size does not match content\", EXPFILL }},\n            { &ei_kafka_unknown_message_magic,\n                    { \"kafka.unknown_message_magic\", PI_MALFORMED, PI_WARN, \"Invalid message magic field\", EXPFILL }},\n            { &ei_kafka_pdu_length_mismatch,\n                    { \"kafka.pdu_length_mismatch\", PI_MALFORMED, PI_WARN, \"Dissected message does not end at the pdu length offset\", EXPFILL }},\n    };\n    expert_kafka = expert_register_protocol(proto);\n    expert_register_field_array(expert_kafka, ei, array_length(ei));\n}",
        "func": "static void\nproto_register_kafka_expert_module(const int proto) {\n    expert_module_t* expert_kafka;\n    static ei_register_info ei[] = {\n            { &ei_kafka_request_missing,\n                    { \"kafka.request_missing\", PI_UNDECODED, PI_WARN, \"Request missing\", EXPFILL }},\n            { &ei_kafka_unknown_api_key,\n                    { \"kafka.unknown_api_key\", PI_UNDECODED, PI_WARN, \"Unknown API key\", EXPFILL }},\n            { &ei_kafka_unsupported_api_version,\n                    { \"kafka.unsupported_api_version\", PI_UNDECODED, PI_WARN, \"Unsupported API version\", EXPFILL }},\n            { &ei_kafka_bad_string_length,\n                    { \"kafka.bad_string_length\", PI_MALFORMED, PI_WARN, \"Invalid string length field\", EXPFILL }},\n            { &ei_kafka_bad_bytes_length,\n                    { \"kafka.bad_bytes_length\", PI_MALFORMED, PI_WARN, \"Invalid byte length field\", EXPFILL }},\n            { &ei_kafka_bad_array_length,\n                    { \"kafka.bad_array_length\", PI_MALFORMED, PI_WARN, \"Invalid array length field\", EXPFILL }},\n            { &ei_kafka_bad_record_length,\n                    { \"kafka.bad_record_length\", PI_MALFORMED, PI_WARN, \"Invalid record length field\", EXPFILL }},\n            { &ei_kafka_bad_varint,\n                    { \"kafka.bad_varint\", PI_MALFORMED, PI_WARN, \"Invalid varint bytes\", EXPFILL }},\n            { &ei_kafka_bad_message_set_length,\n                    { \"kafka.ei_kafka_bad_message_set_length\", PI_MALFORMED, PI_WARN, \"Message set size does not match content\", EXPFILL }},\n            { &ei_kafka_bad_decompression_length,\n                    { \"kafka.ei_kafka_bad_decompression_length\", PI_MALFORMED, PI_WARN, \"Decompression size too large\", EXPFILL }},\n            { &ei_kafka_unknown_message_magic,\n                    { \"kafka.unknown_message_magic\", PI_MALFORMED, PI_WARN, \"Invalid message magic field\", EXPFILL }},\n            { &ei_kafka_pdu_length_mismatch,\n                    { \"kafka.pdu_length_mismatch\", PI_MALFORMED, PI_WARN, \"Dissected message does not end at the pdu length offset\", EXPFILL }},\n    };\n    expert_kafka = expert_register_protocol(proto);\n    expert_register_field_array(expert_kafka, ei, array_length(ei));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,8 @@\n                     { \"kafka.bad_varint\", PI_MALFORMED, PI_WARN, \"Invalid varint bytes\", EXPFILL }},\n             { &ei_kafka_bad_message_set_length,\n                     { \"kafka.ei_kafka_bad_message_set_length\", PI_MALFORMED, PI_WARN, \"Message set size does not match content\", EXPFILL }},\n+            { &ei_kafka_bad_decompression_length,\n+                    { \"kafka.ei_kafka_bad_decompression_length\", PI_MALFORMED, PI_WARN, \"Decompression size too large\", EXPFILL }},\n             { &ei_kafka_unknown_message_magic,\n                     { \"kafka.unknown_message_magic\", PI_MALFORMED, PI_WARN, \"Invalid message magic field\", EXPFILL }},\n             { &ei_kafka_pdu_length_mismatch,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            { &ei_kafka_bad_decompression_length,",
                "                    { \"kafka.ei_kafka_bad_decompression_length\", PI_MALFORMED, PI_WARN, \"Decompression size too large\", EXPFILL }},"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26418",
        "func_name": "wireshark/decompress_zstd",
        "description": "Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e",
        "commit_title": "Kafka: Limit our decompression size.",
        "commit_text": " Don't assume that the Internet has our best interests at heart when it gives us the size of our decompression buffer. Assign an arbitrary limit of 50 MB.  This fixes #16739 in that it takes care of  ** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion \"end >= fi->start\"  which is different from the original error output. It looks like *that* might have taken care of in one of the other recent Kafka bug fixes.  The decompression routines return a success or failure status. Use gbooleans instead of ints for that. ",
        "func_before": "static int\ndecompress_zstd(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    ZSTD_inBuffer input = { tvb_memdup(wmem_packet_scope(), tvb, offset, length), length, 0 };\n    ZSTD_DStream *zds = ZSTD_createDStream();\n    size_t rc = 0;\n    tvbuff_t *composite_tvb = NULL;\n    int ret = 0;\n\n    do {\n        ZSTD_outBuffer output = { wmem_alloc(pinfo->pool, ZSTD_DStreamOutSize()), ZSTD_DStreamOutSize(), 0 };\n        rc = ZSTD_decompressStream(zds, &output, &input);\n        // rc holds either the number of decompressed offsets or the error code.\n        // Both values are positive, one has to use ZSTD_isError to determine if the call succeeded.\n        if (ZSTD_isError(rc)) {\n            goto end;\n        }\n        if (!composite_tvb) {\n            composite_tvb = tvb_new_composite();\n        }\n        tvb_composite_append(composite_tvb,\n                             tvb_new_child_real_data(tvb, (guint8*)output.dst, (guint)output.pos, (gint)output.pos));\n        // rc == 0 means there is nothing more to decompress, but there could be still something in the data\n    } while (rc > 0);\n    ret = 1;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n    }\n    ZSTD_freeDStream(zds);\n    if (ret == 1) {\n        *decompressed_tvb = composite_tvb;\n        *decompressed_offset = 0;\n    }\n    else {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [zstd decompression failed]\");\n    }\n    return ret;\n}",
        "func": "static gboolean\ndecompress_zstd(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    ZSTD_inBuffer input = { tvb_memdup(wmem_packet_scope(), tvb, offset, length), length, 0 };\n    ZSTD_DStream *zds = ZSTD_createDStream();\n    size_t rc = 0;\n    tvbuff_t *composite_tvb = NULL;\n    gboolean ret = FALSE;\n\n    do {\n        ZSTD_outBuffer output = { wmem_alloc(pinfo->pool, ZSTD_DStreamOutSize()), ZSTD_DStreamOutSize(), 0 };\n        rc = ZSTD_decompressStream(zds, &output, &input);\n        // rc holds either the number of decompressed offsets or the error code.\n        // Both values are positive, one has to use ZSTD_isError to determine if the call succeeded.\n        if (ZSTD_isError(rc)) {\n            goto end;\n        }\n        if (!composite_tvb) {\n            composite_tvb = tvb_new_composite();\n        }\n        tvb_composite_append(composite_tvb,\n                             tvb_new_child_real_data(tvb, (guint8*)output.dst, (guint)output.pos, (gint)output.pos));\n        // rc == 0 means there is nothing more to decompress, but there could be still something in the data\n    } while (rc > 0);\n    ret = TRUE;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n    }\n    ZSTD_freeDStream(zds);\n    if (ret == 1) {\n        *decompressed_tvb = composite_tvb;\n        *decompressed_offset = 0;\n    }\n    else {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [zstd decompression failed]\");\n    }\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,11 @@\n-static int\n+static gboolean\n decompress_zstd(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n {\n     ZSTD_inBuffer input = { tvb_memdup(wmem_packet_scope(), tvb, offset, length), length, 0 };\n     ZSTD_DStream *zds = ZSTD_createDStream();\n     size_t rc = 0;\n     tvbuff_t *composite_tvb = NULL;\n-    int ret = 0;\n+    gboolean ret = FALSE;\n \n     do {\n         ZSTD_outBuffer output = { wmem_alloc(pinfo->pool, ZSTD_DStreamOutSize()), ZSTD_DStreamOutSize(), 0 };\n@@ -22,7 +22,7 @@\n                              tvb_new_child_real_data(tvb, (guint8*)output.dst, (guint)output.pos, (gint)output.pos));\n         // rc == 0 means there is nothing more to decompress, but there could be still something in the data\n     } while (rc > 0);\n-    ret = 1;\n+    ret = TRUE;\n end:\n     if (composite_tvb) {\n         tvb_composite_finalize(composite_tvb);",
        "diff_line_info": {
            "deleted_lines": [
                "static int",
                "    int ret = 0;",
                "    ret = 1;"
            ],
            "added_lines": [
                "static gboolean",
                "    gboolean ret = FALSE;",
                "    ret = TRUE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26419",
        "func_name": "wireshark/_proto_tree_add_bits_ret_val",
        "description": "Memory leak in the dissection engine in Wireshark 3.4.0 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/a9fc769d7bb4b491efb61c699d57c9f35269d871",
        "commit_title": "epan: Fix a memory leak.",
        "commit_text": " Make sure _proto_tree_add_bits_ret_val allocates a bits array using the packet scope, otherwise we leak memory. Fixes #17032. ",
        "func_before": "static proto_item *\n_proto_tree_add_bits_ret_val(proto_tree *tree, const int hfindex, tvbuff_t *tvb,\n\t\t\t    const guint bit_offset, const gint no_of_bits,\n\t\t\t    guint64 *return_value, const guint encoding)\n{\n\tgint     offset;\n\tguint    length;\n\tguint8   tot_no_bits;\n\tchar    *bf_str;\n\tchar     lbl_str[ITEM_LABEL_LENGTH];\n\tguint64  value = 0;\n\tguint8  *bytes = NULL;\n\tsize_t bytes_length = 0;\n\n\tproto_item        *pi;\n\theader_field_info *hf_field;\n\n\tconst true_false_string *tfstring;\n\n\t/* We can't fake it just yet. We have to fill in the 'return_value' parameter */\n\tPROTO_REGISTRAR_GET_NTH(hfindex, hf_field);\n\n\tif (hf_field->bitmask != 0) {\n\t\tREPORT_DISSECTOR_BUG(\"Incompatible use of proto_tree_add_bits_ret_val\"\n\t\t\t\t     \" with field '%s' (%s) with bitmask != 0\",\n\t\t\t\t     hf_field->abbrev, hf_field->name);\n\t}\n\n\tif (no_of_bits == 0) {\n\t\tREPORT_DISSECTOR_BUG(\"field %s passed to proto_tree_add_bits_ret_val() has a bit width of 0\",\n\t\t\t\t     hf_field->abbrev);\n\t}\n\n\t/* Byte align offset */\n\toffset = bit_offset>>3;\n\n\t/*\n\t * Calculate the number of octets used to hold the bits\n\t */\n\ttot_no_bits = ((bit_offset&0x7) + no_of_bits);\n\tlength = (tot_no_bits + 7) >> 3;\n\n\tif (no_of_bits < 65) {\n\t\tvalue = tvb_get_bits64(tvb, bit_offset, no_of_bits, encoding);\n\t} else if (hf_field->type != FT_BYTES) {\n\t\tREPORT_DISSECTOR_BUG(\"field %s passed to proto_tree_add_bits_ret_val() has a bit width of %u > 65\",\n\t\t\t\t     hf_field->abbrev, no_of_bits);\n\t\treturn NULL;\n\t}\n\n\t/* Sign extend for signed types */\n\tswitch (hf_field->type) {\n\t\tcase FT_INT8:\n\t\tcase FT_INT16:\n\t\tcase FT_INT24:\n\t\tcase FT_INT32:\n\t\tcase FT_INT40:\n\t\tcase FT_INT48:\n\t\tcase FT_INT56:\n\t\tcase FT_INT64:\n\t\t\tvalue = ws_sign_ext64(value, no_of_bits);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (return_value) {\n\t\t*return_value = value;\n\t}\n\n\t/* Coast clear. Try and fake it */\n\tCHECK_FOR_NULL_TREE(tree);\n\tTRY_TO_FAKE_THIS_ITEM(tree, hfindex, hf_field);\n\n\tbf_str = decode_bits_in_field(bit_offset, no_of_bits, value);\n\n\tswitch (hf_field->type) {\n\tcase FT_BOOLEAN:\n\t\t/* Boolean field */\n\t\ttfstring = &tfs_true_false;\n\t\tif (hf_field->strings)\n\t\t\ttfstring = (const true_false_string *)hf_field->strings;\n\t\treturn proto_tree_add_boolean_format(tree, hfindex, tvb, offset, length, (guint32)value,\n\t\t\t\"%s = %s: %s\",\n\t\t\tbf_str, hf_field->name, tfs_get_string(!!value, tfstring));\n\t\tbreak;\n\n\tcase FT_CHAR:\n\t\tpi = proto_tree_add_uint(tree, hfindex, tvb, offset, length, (guint32)value);\n\t\tfill_label_char(PITEM_FINFO(pi), lbl_str);\n\t\tbreak;\n\n\tcase FT_UINT8:\n\tcase FT_UINT16:\n\tcase FT_UINT24:\n\tcase FT_UINT32:\n\t\tpi = proto_tree_add_uint(tree, hfindex, tvb, offset, length, (guint32)value);\n\t\tfill_label_number(PITEM_FINFO(pi), lbl_str, FALSE);\n\t\tbreak;\n\n\tcase FT_INT8:\n\tcase FT_INT16:\n\tcase FT_INT24:\n\tcase FT_INT32:\n\t\tpi = proto_tree_add_int(tree, hfindex, tvb, offset, length, (gint32)value);\n\t\tfill_label_number(PITEM_FINFO(pi), lbl_str, TRUE);\n\t\tbreak;\n\n\tcase FT_UINT40:\n\tcase FT_UINT48:\n\tcase FT_UINT56:\n\tcase FT_UINT64:\n\t\tpi = proto_tree_add_uint64(tree, hfindex, tvb, offset, length, value);\n\t\tfill_label_number64(PITEM_FINFO(pi), lbl_str, FALSE);\n\t\tbreak;\n\n\tcase FT_INT40:\n\tcase FT_INT48:\n\tcase FT_INT56:\n\tcase FT_INT64:\n\t\tpi = proto_tree_add_int64(tree, hfindex, tvb, offset, length, (gint64)value);\n\t\tfill_label_number64(PITEM_FINFO(pi), lbl_str, TRUE);\n\t\tbreak;\n\n\tcase FT_BYTES:\n\t\tbytes = tvb_get_bits_array(NULL, tvb, bit_offset, no_of_bits, &bytes_length);\n\t\tpi = proto_tree_add_bytes_with_length(tree, hfindex, tvb, offset, length, bytes, (gint) bytes_length);\n\t\tproto_item_fill_label(PITEM_FINFO(pi), lbl_str);\n\t\tproto_item_set_text(pi, \"%s\", lbl_str);\n\t\treturn pi;\n\t\tbreak;\n\n\tdefault:\n\t\tREPORT_DISSECTOR_BUG(\"field %s has type %d (%s) not handled in proto_tree_add_bits_ret_val()\",\n\t\t\t\t     hf_field->abbrev,\n\t\t\t\t     hf_field->type,\n\t\t\t\t     ftype_name(hf_field->type));\n\t\treturn NULL;\n\t\tbreak;\n\t}\n\n\tproto_item_set_text(pi, \"%s = %s\", bf_str, lbl_str);\n\treturn pi;\n}",
        "func": "static proto_item *\n_proto_tree_add_bits_ret_val(proto_tree *tree, const int hfindex, tvbuff_t *tvb,\n\t\t\t    const guint bit_offset, const gint no_of_bits,\n\t\t\t    guint64 *return_value, const guint encoding)\n{\n\tgint     offset;\n\tguint    length;\n\tguint8   tot_no_bits;\n\tchar    *bf_str;\n\tchar     lbl_str[ITEM_LABEL_LENGTH];\n\tguint64  value = 0;\n\tguint8  *bytes = NULL;\n\tsize_t bytes_length = 0;\n\n\tproto_item        *pi;\n\theader_field_info *hf_field;\n\n\tconst true_false_string *tfstring;\n\n\t/* We can't fake it just yet. We have to fill in the 'return_value' parameter */\n\tPROTO_REGISTRAR_GET_NTH(hfindex, hf_field);\n\n\tif (hf_field->bitmask != 0) {\n\t\tREPORT_DISSECTOR_BUG(\"Incompatible use of proto_tree_add_bits_ret_val\"\n\t\t\t\t     \" with field '%s' (%s) with bitmask != 0\",\n\t\t\t\t     hf_field->abbrev, hf_field->name);\n\t}\n\n\tif (no_of_bits == 0) {\n\t\tREPORT_DISSECTOR_BUG(\"field %s passed to proto_tree_add_bits_ret_val() has a bit width of 0\",\n\t\t\t\t     hf_field->abbrev);\n\t}\n\n\t/* Byte align offset */\n\toffset = bit_offset>>3;\n\n\t/*\n\t * Calculate the number of octets used to hold the bits\n\t */\n\ttot_no_bits = ((bit_offset&0x7) + no_of_bits);\n\tlength = (tot_no_bits + 7) >> 3;\n\n\tif (no_of_bits < 65) {\n\t\tvalue = tvb_get_bits64(tvb, bit_offset, no_of_bits, encoding);\n\t} else if (hf_field->type != FT_BYTES) {\n\t\tREPORT_DISSECTOR_BUG(\"field %s passed to proto_tree_add_bits_ret_val() has a bit width of %u > 65\",\n\t\t\t\t     hf_field->abbrev, no_of_bits);\n\t\treturn NULL;\n\t}\n\n\t/* Sign extend for signed types */\n\tswitch (hf_field->type) {\n\t\tcase FT_INT8:\n\t\tcase FT_INT16:\n\t\tcase FT_INT24:\n\t\tcase FT_INT32:\n\t\tcase FT_INT40:\n\t\tcase FT_INT48:\n\t\tcase FT_INT56:\n\t\tcase FT_INT64:\n\t\t\tvalue = ws_sign_ext64(value, no_of_bits);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (return_value) {\n\t\t*return_value = value;\n\t}\n\n\t/* Coast clear. Try and fake it */\n\tCHECK_FOR_NULL_TREE(tree);\n\tTRY_TO_FAKE_THIS_ITEM(tree, hfindex, hf_field);\n\n\tbf_str = decode_bits_in_field(bit_offset, no_of_bits, value);\n\n\tswitch (hf_field->type) {\n\tcase FT_BOOLEAN:\n\t\t/* Boolean field */\n\t\ttfstring = &tfs_true_false;\n\t\tif (hf_field->strings)\n\t\t\ttfstring = (const true_false_string *)hf_field->strings;\n\t\treturn proto_tree_add_boolean_format(tree, hfindex, tvb, offset, length, (guint32)value,\n\t\t\t\"%s = %s: %s\",\n\t\t\tbf_str, hf_field->name, tfs_get_string(!!value, tfstring));\n\t\tbreak;\n\n\tcase FT_CHAR:\n\t\tpi = proto_tree_add_uint(tree, hfindex, tvb, offset, length, (guint32)value);\n\t\tfill_label_char(PITEM_FINFO(pi), lbl_str);\n\t\tbreak;\n\n\tcase FT_UINT8:\n\tcase FT_UINT16:\n\tcase FT_UINT24:\n\tcase FT_UINT32:\n\t\tpi = proto_tree_add_uint(tree, hfindex, tvb, offset, length, (guint32)value);\n\t\tfill_label_number(PITEM_FINFO(pi), lbl_str, FALSE);\n\t\tbreak;\n\n\tcase FT_INT8:\n\tcase FT_INT16:\n\tcase FT_INT24:\n\tcase FT_INT32:\n\t\tpi = proto_tree_add_int(tree, hfindex, tvb, offset, length, (gint32)value);\n\t\tfill_label_number(PITEM_FINFO(pi), lbl_str, TRUE);\n\t\tbreak;\n\n\tcase FT_UINT40:\n\tcase FT_UINT48:\n\tcase FT_UINT56:\n\tcase FT_UINT64:\n\t\tpi = proto_tree_add_uint64(tree, hfindex, tvb, offset, length, value);\n\t\tfill_label_number64(PITEM_FINFO(pi), lbl_str, FALSE);\n\t\tbreak;\n\n\tcase FT_INT40:\n\tcase FT_INT48:\n\tcase FT_INT56:\n\tcase FT_INT64:\n\t\tpi = proto_tree_add_int64(tree, hfindex, tvb, offset, length, (gint64)value);\n\t\tfill_label_number64(PITEM_FINFO(pi), lbl_str, TRUE);\n\t\tbreak;\n\n\tcase FT_BYTES:\n\t\tbytes = tvb_get_bits_array(wmem_packet_scope(), tvb, bit_offset, no_of_bits, &bytes_length);\n\t\tpi = proto_tree_add_bytes_with_length(tree, hfindex, tvb, offset, length, bytes, (gint) bytes_length);\n\t\tproto_item_fill_label(PITEM_FINFO(pi), lbl_str);\n\t\tproto_item_set_text(pi, \"%s\", lbl_str);\n\t\treturn pi;\n\t\tbreak;\n\n\tdefault:\n\t\tREPORT_DISSECTOR_BUG(\"field %s has type %d (%s) not handled in proto_tree_add_bits_ret_val()\",\n\t\t\t\t     hf_field->abbrev,\n\t\t\t\t     hf_field->type,\n\t\t\t\t     ftype_name(hf_field->type));\n\t\treturn NULL;\n\t\tbreak;\n\t}\n\n\tproto_item_set_text(pi, \"%s = %s\", bf_str, lbl_str);\n\treturn pi;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,7 +124,7 @@\n \t\tbreak;\n \n \tcase FT_BYTES:\n-\t\tbytes = tvb_get_bits_array(NULL, tvb, bit_offset, no_of_bits, &bytes_length);\n+\t\tbytes = tvb_get_bits_array(wmem_packet_scope(), tvb, bit_offset, no_of_bits, &bytes_length);\n \t\tpi = proto_tree_add_bytes_with_length(tree, hfindex, tvb, offset, length, bytes, (gint) bytes_length);\n \t\tproto_item_fill_label(PITEM_FINFO(pi), lbl_str);\n \t\tproto_item_set_text(pi, \"%s\", lbl_str);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tbytes = tvb_get_bits_array(NULL, tvb, bit_offset, no_of_bits, &bytes_length);"
            ],
            "added_lines": [
                "\t\tbytes = tvb_get_bits_array(wmem_packet_scope(), tvb, bit_offset, no_of_bits, &bytes_length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26420",
        "func_name": "wireshark/coherent_set_key_hash_by_key",
        "description": "Memory leak in RTPS protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/33e63d19e5496c151bad69f65cdbc7cba2b4c211",
        "commit_title": "RTPS: Fixup our coherent set map.",
        "commit_text": " coherent_set_tracking.coherent_set_registry_map uses a struct as a key, but the hash and comparison routines treat keys as a sequence of bytes. Make sure every key byte is initialized. Fixes #16994.  Call wmem_strong_hash on our key in coherent_set_key_hash_by_key instead of creating and leaking a GBytes struct. ",
        "func_before": "static guint coherent_set_key_hash_by_key(gconstpointer key) {\n  GBytes * coherent_set_object_key_bytes = NULL;\n  coherent_set_object_key_bytes = g_bytes_new(key, sizeof(coherent_set_key));\n  return g_bytes_hash(coherent_set_object_key_bytes);\n}",
        "func": "static guint coherent_set_key_hash_by_key(gconstpointer key) {\n  return wmem_strong_hash((const guint8 *)key, sizeof(coherent_set_key));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,3 @@\n static guint coherent_set_key_hash_by_key(gconstpointer key) {\n-  GBytes * coherent_set_object_key_bytes = NULL;\n-  coherent_set_object_key_bytes = g_bytes_new(key, sizeof(coherent_set_key));\n-  return g_bytes_hash(coherent_set_object_key_bytes);\n+  return wmem_strong_hash((const guint8 *)key, sizeof(coherent_set_key));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  GBytes * coherent_set_object_key_bytes = NULL;",
                "  coherent_set_object_key_bytes = g_bytes_new(key, sizeof(coherent_set_key));",
                "  return g_bytes_hash(coherent_set_object_key_bytes);"
            ],
            "added_lines": [
                "  return wmem_strong_hash((const guint8 *)key, sizeof(coherent_set_key));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26420",
        "func_name": "wireshark/rtps_util_detect_coherent_set_end_empty_data_case",
        "description": "Memory leak in RTPS protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/33e63d19e5496c151bad69f65cdbc7cba2b4c211",
        "commit_title": "RTPS: Fixup our coherent set map.",
        "commit_text": " coherent_set_tracking.coherent_set_registry_map uses a struct as a key, but the hash and comparison routines treat keys as a sequence of bytes. Make sure every key byte is initialized. Fixes #16994.  Call wmem_strong_hash on our key in coherent_set_key_hash_by_key instead of creating and leaking a GBytes struct. ",
        "func_before": "static void rtps_util_detect_coherent_set_end_empty_data_case(\n\n  coherent_set_entity_info *coherent_set_entity_info_object) {\n  coherent_set_entity_info *coherent_set_entry = NULL;\n\n  coherent_set_entry = (coherent_set_entity_info*) wmem_map_lookup(coherent_set_tracking.entities_using_map, &coherent_set_entity_info_object->guid);\n  if (coherent_set_entry) {\n    coherent_set_info *coherent_set_info_entry;\n    coherent_set_key key;\n\n    key.guid = coherent_set_entity_info_object->guid;\n    key.coherent_set_seq_number = coherent_set_entry->coherent_set_seq_number;\n\n    coherent_set_info_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map, &key);\n    if (coherent_set_info_entry) {\n      if (coherent_set_entry->expected_coherent_set_end_writers_seq_number == coherent_set_entity_info_object->writer_seq_number) {\n\n        coherent_set_info_entry->is_set = TRUE;\n        coherent_set_info_entry->writer_seq_number = coherent_set_entry->expected_coherent_set_end_writers_seq_number - 1;\n      }\n    }\n  }\n}",
        "func": "static void rtps_util_detect_coherent_set_end_empty_data_case(\n\n  coherent_set_entity_info *coherent_set_entity_info_object) {\n  coherent_set_entity_info *coherent_set_entry = NULL;\n\n  coherent_set_entry = (coherent_set_entity_info*) wmem_map_lookup(coherent_set_tracking.entities_using_map, &coherent_set_entity_info_object->guid);\n  if (coherent_set_entry) {\n    coherent_set_info *coherent_set_info_entry;\n    coherent_set_key key;\n\n    // The hash and compare functions treat the key as a sequence of bytes.\n    memset(&key, 0, sizeof(key));\n    key.guid = coherent_set_entity_info_object->guid;\n    key.coherent_set_seq_number = coherent_set_entry->coherent_set_seq_number;\n\n    coherent_set_info_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map, &key);\n    if (coherent_set_info_entry) {\n      if (coherent_set_entry->expected_coherent_set_end_writers_seq_number == coherent_set_entity_info_object->writer_seq_number) {\n\n        coherent_set_info_entry->is_set = TRUE;\n        coherent_set_info_entry->writer_seq_number = coherent_set_entry->expected_coherent_set_end_writers_seq_number - 1;\n      }\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,8 @@\n     coherent_set_info *coherent_set_info_entry;\n     coherent_set_key key;\n \n+    // The hash and compare functions treat the key as a sequence of bytes.\n+    memset(&key, 0, sizeof(key));\n     key.guid = coherent_set_entity_info_object->guid;\n     key.coherent_set_seq_number = coherent_set_entry->coherent_set_seq_number;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // The hash and compare functions treat the key as a sequence of bytes.",
                "    memset(&key, 0, sizeof(key));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26420",
        "func_name": "wireshark/compare_by_guid",
        "description": "Memory leak in RTPS protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/33e63d19e5496c151bad69f65cdbc7cba2b4c211",
        "commit_title": "RTPS: Fixup our coherent set map.",
        "commit_text": " coherent_set_tracking.coherent_set_registry_map uses a struct as a key, but the hash and comparison routines treat keys as a sequence of bytes. Make sure every key byte is initialized. Fixes #16994.  Call wmem_strong_hash on our key in coherent_set_key_hash_by_key instead of creating and leaking a GBytes struct. ",
        "func_before": "static gboolean compare_by_guid(gconstpointer a, gconstpointer b) {\n  const endpoint_guid * guid_a = (const endpoint_guid *) a;\n  const endpoint_guid * guid_b = (const endpoint_guid *) b;\n  return memcmp(guid_a, guid_b, sizeof(endpoint_guid)) == 0;\n}",
        "func": "static gboolean compare_by_guid(gconstpointer guid_a, gconstpointer guid_b) {\n  return memcmp(guid_a, guid_b, sizeof(endpoint_guid)) == 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,3 @@\n-static gboolean compare_by_guid(gconstpointer a, gconstpointer b) {\n-  const endpoint_guid * guid_a = (const endpoint_guid *) a;\n-  const endpoint_guid * guid_b = (const endpoint_guid *) b;\n+static gboolean compare_by_guid(gconstpointer guid_a, gconstpointer guid_b) {\n   return memcmp(guid_a, guid_b, sizeof(endpoint_guid)) == 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static gboolean compare_by_guid(gconstpointer a, gconstpointer b) {",
                "  const endpoint_guid * guid_a = (const endpoint_guid *) a;",
                "  const endpoint_guid * guid_b = (const endpoint_guid *) b;"
            ],
            "added_lines": [
                "static gboolean compare_by_guid(gconstpointer guid_a, gconstpointer guid_b) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26420",
        "func_name": "wireshark/compare_by_coherent_set_key",
        "description": "Memory leak in RTPS protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/33e63d19e5496c151bad69f65cdbc7cba2b4c211",
        "commit_title": "RTPS: Fixup our coherent set map.",
        "commit_text": " coherent_set_tracking.coherent_set_registry_map uses a struct as a key, but the hash and comparison routines treat keys as a sequence of bytes. Make sure every key byte is initialized. Fixes #16994.  Call wmem_strong_hash on our key in coherent_set_key_hash_by_key instead of creating and leaking a GBytes struct. ",
        "func_before": "static gboolean compare_by_coherent_set_key(gconstpointer a, gconstpointer b) {\n  const coherent_set_key * guid_a = (const coherent_set_key *)a;\n  const coherent_set_key * guid_b = (const coherent_set_key *)b;\n  return memcmp(guid_a, guid_b, sizeof(coherent_set_key)) == 0;\n}",
        "func": "static gboolean compare_by_coherent_set_key(gconstpointer key_a, gconstpointer key_b) {\n  return memcmp(key_a, key_b, sizeof(coherent_set_key)) == 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,3 @@\n-static gboolean compare_by_coherent_set_key(gconstpointer a, gconstpointer b) {\n-  const coherent_set_key * guid_a = (const coherent_set_key *)a;\n-  const coherent_set_key * guid_b = (const coherent_set_key *)b;\n-  return memcmp(guid_a, guid_b, sizeof(coherent_set_key)) == 0;\n+static gboolean compare_by_coherent_set_key(gconstpointer key_a, gconstpointer key_b) {\n+  return memcmp(key_a, key_b, sizeof(coherent_set_key)) == 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static gboolean compare_by_coherent_set_key(gconstpointer a, gconstpointer b) {",
                "  const coherent_set_key * guid_a = (const coherent_set_key *)a;",
                "  const coherent_set_key * guid_b = (const coherent_set_key *)b;",
                "  return memcmp(guid_a, guid_b, sizeof(coherent_set_key)) == 0;"
            ],
            "added_lines": [
                "static gboolean compare_by_coherent_set_key(gconstpointer key_a, gconstpointer key_b) {",
                "  return memcmp(key_a, key_b, sizeof(coherent_set_key)) == 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26420",
        "func_name": "wireshark/rtps_util_add_coherent_set_general_cases_case",
        "description": "Memory leak in RTPS protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/33e63d19e5496c151bad69f65cdbc7cba2b4c211",
        "commit_title": "RTPS: Fixup our coherent set map.",
        "commit_text": " coherent_set_tracking.coherent_set_registry_map uses a struct as a key, but the hash and comparison routines treat keys as a sequence of bytes. Make sure every key byte is initialized. Fixes #16994.  Call wmem_strong_hash on our key in coherent_set_key_hash_by_key instead of creating and leaking a GBytes struct. ",
        "func_before": "static void rtps_util_add_coherent_set_general_cases_case(\n  proto_tree *tree,\n  tvbuff_t *tvb,\n  guint64 coherent_seq_number,\n  coherent_set_entity_info *coherent_set_entity_info_object) {\n\n  coherent_set_entity_info *register_entry;\n  proto_tree *marked_item_tree;\n  coherent_set_info *coherent_set_info_entry;\n  coherent_set_key coherent_set_info_key;\n\n  coherent_set_entity_info_object->coherent_set_seq_number = coherent_seq_number;\n  register_entry = (coherent_set_entity_info*)wmem_map_lookup(coherent_set_tracking.entities_using_map,\n    &coherent_set_entity_info_object->guid);\n  if (!register_entry) {\n    register_entry = (coherent_set_entity_info*)wmem_memdup(wmem_file_scope(), coherent_set_entity_info_object, sizeof(coherent_set_entity_info));\n    wmem_map_insert(\n      coherent_set_tracking.entities_using_map,\n      &register_entry->guid,\n      register_entry);\n  }\n\n  coherent_set_info_key.guid = coherent_set_entity_info_object->guid;\n  coherent_set_info_key.coherent_set_seq_number = coherent_seq_number;\n  coherent_set_info_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map,\n    &coherent_set_info_key);\n  if (!coherent_set_info_entry) {\n    coherent_set_info_entry = wmem_new0(wmem_file_scope(), coherent_set_info);\n    coherent_set_info_entry->key = (coherent_set_key*)wmem_memdup(wmem_file_scope(), &coherent_set_info_key, sizeof(coherent_set_key));\n    coherent_set_info_entry->is_set = FALSE;\n    wmem_map_insert(\n      coherent_set_tracking.coherent_set_registry_map,\n      coherent_set_info_entry->key,\n      coherent_set_info_entry);\n  }\n\n  if (coherent_set_info_entry->writer_seq_number < coherent_set_entity_info_object->writer_seq_number) {\n    coherent_set_info_entry->writer_seq_number = coherent_set_entity_info_object->writer_seq_number;\n  }\n  /* Start */\n  if (coherent_set_entity_info_object->coherent_set_seq_number == coherent_set_entity_info_object->writer_seq_number) {\n    marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_start,\n      tvb, 0, 0, coherent_seq_number);\n    proto_item_set_generated(marked_item_tree);\n\n    /* End case: Start of a new coherent set */\n    if (coherent_set_entity_info_object->coherent_set_seq_number > register_entry->coherent_set_seq_number &&\n      coherent_set_entity_info_object->writer_seq_number - 1 == register_entry->writer_seq_number) {\n      coherent_set_info *previous_entry;\n\n      marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end,\n        tvb, 0, 0, register_entry->coherent_set_seq_number);\n      proto_item_set_generated(marked_item_tree);\n      coherent_set_info_key.coherent_set_seq_number = register_entry->writer_seq_number;\n      coherent_set_info_key.guid = register_entry->guid;\n      previous_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map, &coherent_set_info_key);\n      if (previous_entry) {\n        previous_entry->is_set = TRUE;\n      }\n    }\n  }\n\n  if (!coherent_set_info_entry->is_set) {\n\n    coherent_set_info_key.coherent_set_seq_number = coherent_seq_number - 1;\n\n    /* End case: Sequence unknown received */\n    if (coherent_set_entity_info_object->coherent_set_seq_number == RTPS_SEQUENCENUMBER_UNKNOWN) {\n      register_entry->coherent_set_seq_number = coherent_set_entity_info_object->coherent_set_seq_number;\n      marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end,\n        tvb, 0, 0, coherent_set_info_entry->key->coherent_set_seq_number);\n      proto_item_set_generated(marked_item_tree);\n      coherent_set_info_entry->is_set = TRUE;\n    }\n  } else if (coherent_set_info_entry->writer_seq_number == coherent_set_entity_info_object->writer_seq_number) {\n    proto_tree *ti;\n\n    ti = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end,\n      tvb, 0, 0, coherent_set_info_entry->key->coherent_set_seq_number);\n    proto_item_set_generated(ti);\n  }\n  /* Update the entity */\n  coherent_set_entity_info_object->expected_coherent_set_end_writers_seq_number = coherent_set_entity_info_object->writer_seq_number + 1;\n  *register_entry = *coherent_set_entity_info_object;\n}",
        "func": "static void rtps_util_add_coherent_set_general_cases_case(\n  proto_tree *tree,\n  tvbuff_t *tvb,\n  guint64 coherent_seq_number,\n  coherent_set_entity_info *coherent_set_entity_info_object) {\n\n  coherent_set_entity_info *register_entry;\n  proto_tree *marked_item_tree;\n  coherent_set_info *coherent_set_info_entry;\n  coherent_set_key coherent_set_info_key;\n\n  coherent_set_entity_info_object->coherent_set_seq_number = coherent_seq_number;\n  register_entry = (coherent_set_entity_info*)wmem_map_lookup(coherent_set_tracking.entities_using_map,\n    &coherent_set_entity_info_object->guid);\n  if (!register_entry) {\n    register_entry = (coherent_set_entity_info*)wmem_memdup(wmem_file_scope(), coherent_set_entity_info_object, sizeof(coherent_set_entity_info));\n    wmem_map_insert(\n      coherent_set_tracking.entities_using_map,\n      &register_entry->guid,\n      register_entry);\n  }\n\n  // The hash and compare functions treat the key as a sequence of bytes.\n  memset(&coherent_set_info_key, 0, sizeof(coherent_set_info_key));\n  coherent_set_info_key.guid = coherent_set_entity_info_object->guid;\n  coherent_set_info_key.coherent_set_seq_number = coherent_seq_number;\n  coherent_set_info_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map,\n    &coherent_set_info_key);\n  if (!coherent_set_info_entry) {\n    coherent_set_info_entry = wmem_new0(wmem_file_scope(), coherent_set_info);\n    coherent_set_info_entry->key = (coherent_set_key*)wmem_memdup(wmem_file_scope(), &coherent_set_info_key, sizeof(coherent_set_key));\n    coherent_set_info_entry->is_set = FALSE;\n    wmem_map_insert(\n      coherent_set_tracking.coherent_set_registry_map,\n      coherent_set_info_entry->key,\n      coherent_set_info_entry);\n  }\n\n  if (coherent_set_info_entry->writer_seq_number < coherent_set_entity_info_object->writer_seq_number) {\n    coherent_set_info_entry->writer_seq_number = coherent_set_entity_info_object->writer_seq_number;\n  }\n  /* Start */\n  if (coherent_set_entity_info_object->coherent_set_seq_number == coherent_set_entity_info_object->writer_seq_number) {\n    marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_start,\n      tvb, 0, 0, coherent_seq_number);\n    proto_item_set_generated(marked_item_tree);\n\n    /* End case: Start of a new coherent set */\n    if (coherent_set_entity_info_object->coherent_set_seq_number > register_entry->coherent_set_seq_number &&\n      coherent_set_entity_info_object->writer_seq_number - 1 == register_entry->writer_seq_number) {\n      coherent_set_info *previous_entry;\n\n      marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end,\n        tvb, 0, 0, register_entry->coherent_set_seq_number);\n      proto_item_set_generated(marked_item_tree);\n      coherent_set_info_key.coherent_set_seq_number = register_entry->writer_seq_number;\n      coherent_set_info_key.guid = register_entry->guid;\n      previous_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map, &coherent_set_info_key);\n      if (previous_entry) {\n        previous_entry->is_set = TRUE;\n      }\n    }\n  }\n\n  if (!coherent_set_info_entry->is_set) {\n\n    coherent_set_info_key.coherent_set_seq_number = coherent_seq_number - 1;\n\n    /* End case: Sequence unknown received */\n    if (coherent_set_entity_info_object->coherent_set_seq_number == RTPS_SEQUENCENUMBER_UNKNOWN) {\n      register_entry->coherent_set_seq_number = coherent_set_entity_info_object->coherent_set_seq_number;\n      marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end,\n        tvb, 0, 0, coherent_set_info_entry->key->coherent_set_seq_number);\n      proto_item_set_generated(marked_item_tree);\n      coherent_set_info_entry->is_set = TRUE;\n    }\n  } else if (coherent_set_info_entry->writer_seq_number == coherent_set_entity_info_object->writer_seq_number) {\n    proto_tree *ti;\n\n    ti = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end,\n      tvb, 0, 0, coherent_set_info_entry->key->coherent_set_seq_number);\n    proto_item_set_generated(ti);\n  }\n  /* Update the entity */\n  coherent_set_entity_info_object->expected_coherent_set_end_writers_seq_number = coherent_set_entity_info_object->writer_seq_number + 1;\n  *register_entry = *coherent_set_entity_info_object;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,8 @@\n       register_entry);\n   }\n \n+  // The hash and compare functions treat the key as a sequence of bytes.\n+  memset(&coherent_set_info_key, 0, sizeof(coherent_set_info_key));\n   coherent_set_info_key.guid = coherent_set_entity_info_object->guid;\n   coherent_set_info_key.coherent_set_seq_number = coherent_seq_number;\n   coherent_set_info_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  // The hash and compare functions treat the key as a sequence of bytes.",
                "  memset(&coherent_set_info_key, 0, sizeof(coherent_set_info_key));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-35679",
        "func_name": "openbsd/src/table_regex_match",
        "description": "smtpd/table.c in OpenSMTPD before 6.8.0p1 lacks a certain regfree, which might allow attackers to trigger a \"very significant\" memory leak via messages to an instance that performs many regex lookups.",
        "git_url": "https://github.com/openbsd/src/commit/79a034b4aed29e965f45a13409268290c9910043",
        "commit_title": "Use regfree after we're done with preg.",
        "commit_text": " From gilles@",
        "func_before": "int\ntable_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\n\treturn (1);\n}",
        "func": "int\ntable_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tint ret;\n\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\n\tret = regexec(&preg, string, 0, NULL, 0);\n\n\tregfree(&preg);\n\n\tif (ret != 0)\n\t\treturn (0);\n\n\treturn (1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n {\n \tregex_t preg;\n \tint\tcflags = REG_EXTENDED|REG_NOSUB;\n+\tint ret;\n \n \tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n \t\tcflags |= REG_ICASE;\n@@ -12,7 +13,11 @@\n \tif (regcomp(&preg, pattern, cflags) != 0)\n \t\treturn (0);\n \n-\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n+\tret = regexec(&preg, string, 0, NULL, 0);\n+\n+\tregfree(&preg);\n+\n+\tif (ret != 0)\n \t\treturn (0);\n \n \treturn (1);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (regexec(&preg, string, 0, NULL, 0) != 0)"
            ],
            "added_lines": [
                "\tint ret;",
                "\tret = regexec(&preg, string, 0, NULL, 0);",
                "",
                "\tregfree(&preg);",
                "",
                "\tif (ret != 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3181",
        "func_name": "muttmua/mutt/rfc822_parse_adrlist",
        "description": "rfc822.c in Mutt through 2.0.4 allows remote attackers to cause a denial of service (mailbox unavailability) by sending email messages with sequences of semicolon characters in RFC822 address fields (aka terminators of empty groups). A small email message from the attacker can cause large memory consumption, and the victim may then be unable to see email messages from other persons.",
        "git_url": "https://gitlab.com/muttmua/mutt/-/commit/d4305208955c5cdd9fe96dfa61e7c1e14e176a14",
        "commit_title": "Add group terminator if it is left off.",
        "commit_text": " If there is no terminating \";\" add one to the list, to make the text re-rendering correct. ",
        "func_before": "ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s)\n{\n  int ws_pending, nl, in_group = 0;\n#ifdef EXACT_ADDRESS\n  const char *begin;\n#endif\n  const char *ps;\n  char comment[LONG_STRING], phrase[LONG_STRING];\n  size_t phraselen = 0, commentlen = 0;\n  ADDRESS *cur, *last = NULL;\n\n  RFC822Error = 0;\n\n  last = top;\n  while (last && last->next)\n    last = last->next;\n\n  ws_pending = is_email_wsp (*s);\n  if ((nl = mutt_strlen (s)))\n    nl = s[nl - 1] == '\\n';\n\n  s = skip_email_wsp(s);\n#ifdef EXACT_ADDRESS\n  begin = s;\n#endif\n  while (*s)\n  {\n    if (*s == ',')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n      commentlen = 0;\n      phraselen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == '(')\n    {\n      if (commentlen && commentlen < sizeof (comment) - 1)\n\tcomment[commentlen++] = ' ';\n      if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '\"')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = ' ';\n      if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '[')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if (phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = '[';\n      if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == ':')\n    {\n      cur = rfc822_new_address ();\n      terminate_buffer (phrase, phraselen);\n      cur->mailbox = safe_strdup (phrase);\n      cur->group = 1;\n      in_group = 1;\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n#ifdef EXACT_ADDRESS\n      last->val = mutt_substrdup (begin, s);\n#endif\n\n      phraselen = 0;\n      commentlen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == ';')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n\n      /* add group terminator */\n      if (last && in_group)\n      {\n\tlast->next = rfc822_new_address ();\n\tlast = last->next;\n      }\n      in_group = 0;\n\n      phraselen = 0;\n      commentlen = 0;\n#ifdef EXACT_ADDRESS\n      begin = s;\n#endif\n      s++;\n    }\n    else if (*s == '<')\n    {\n      terminate_buffer (phrase, phraselen);\n      cur = rfc822_new_address ();\n      if (phraselen)\n\tcur->personal = safe_strdup (phrase);\n      if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL)\n      {\n\trfc822_free_address (&top);\n\trfc822_free_address (&cur);\n\treturn NULL;\n      }\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n      phraselen = 0;\n      commentlen = 0;\n      s = ps;\n    }\n    else\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    ws_pending = is_email_wsp(*s);\n    s = skip_email_wsp(s);\n  }\n\n  if (phraselen)\n  {\n    terminate_buffer (phrase, phraselen);\n    terminate_buffer (comment, commentlen);\n    add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n  }\n  else if (commentlen && last && !last->personal)\n  {\n    terminate_buffer (comment, commentlen);\n    last->personal = safe_strdup (comment);\n  }\n#ifdef EXACT_ADDRESS\n  if (last && !last->val)\n    last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl);\n#endif\n\n  return top;\n}",
        "func": "ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s)\n{\n  int ws_pending, nl, in_group = 0;\n#ifdef EXACT_ADDRESS\n  const char *begin;\n#endif\n  const char *ps;\n  char comment[LONG_STRING], phrase[LONG_STRING];\n  size_t phraselen = 0, commentlen = 0;\n  ADDRESS *cur, *last = NULL;\n\n  RFC822Error = 0;\n\n  last = top;\n  while (last && last->next)\n    last = last->next;\n\n  ws_pending = is_email_wsp (*s);\n  if ((nl = mutt_strlen (s)))\n    nl = s[nl - 1] == '\\n';\n\n  s = skip_email_wsp(s);\n#ifdef EXACT_ADDRESS\n  begin = s;\n#endif\n  while (*s)\n  {\n    if (*s == ',')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n      commentlen = 0;\n      phraselen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == '(')\n    {\n      if (commentlen && commentlen < sizeof (comment) - 1)\n\tcomment[commentlen++] = ' ';\n      if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '\"')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = ' ';\n      if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '[')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if (phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = '[';\n      if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == ':')\n    {\n      cur = rfc822_new_address ();\n      terminate_buffer (phrase, phraselen);\n      cur->mailbox = safe_strdup (phrase);\n      cur->group = 1;\n      in_group = 1;\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n#ifdef EXACT_ADDRESS\n      last->val = mutt_substrdup (begin, s);\n#endif\n\n      phraselen = 0;\n      commentlen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == ';')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n\n      /* add group terminator */\n      if (last && in_group)\n      {\n\tlast->next = rfc822_new_address ();\n\tlast = last->next;\n      }\n      in_group = 0;\n\n      phraselen = 0;\n      commentlen = 0;\n#ifdef EXACT_ADDRESS\n      begin = s;\n#endif\n      s++;\n    }\n    else if (*s == '<')\n    {\n      terminate_buffer (phrase, phraselen);\n      cur = rfc822_new_address ();\n      if (phraselen)\n\tcur->personal = safe_strdup (phrase);\n      if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL)\n      {\n\trfc822_free_address (&top);\n\trfc822_free_address (&cur);\n\treturn NULL;\n      }\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n      phraselen = 0;\n      commentlen = 0;\n      s = ps;\n    }\n    else\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    ws_pending = is_email_wsp(*s);\n    s = skip_email_wsp(s);\n  }\n\n  if (phraselen)\n  {\n    terminate_buffer (phrase, phraselen);\n    terminate_buffer (comment, commentlen);\n    add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n  }\n  else if (commentlen && last && !last->personal)\n  {\n    terminate_buffer (comment, commentlen);\n    last->personal = safe_strdup (comment);\n  }\n#ifdef EXACT_ADDRESS\n  if (last && !last->val)\n    last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl);\n#endif\n\n  /* add group terminator, if it was left off */\n  if (last && in_group)\n    last->next = rfc822_new_address ();\n\n  return top;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -195,5 +195,9 @@\n     last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl);\n #endif\n \n+  /* add group terminator, if it was left off */\n+  if (last && in_group)\n+    last->next = rfc822_new_address ();\n+\n   return top;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  /* add group terminator, if it was left off */",
                "  if (last && in_group)",
                "    last->next = rfc822_new_address ();",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3181",
        "func_name": "muttmua/mutt/rfc822_parse_adrlist",
        "description": "rfc822.c in Mutt through 2.0.4 allows remote attackers to cause a denial of service (mailbox unavailability) by sending email messages with sequences of semicolon characters in RFC822 address fields (aka terminators of empty groups). A small email message from the attacker can cause large memory consumption, and the victim may then be unable to see email messages from other persons.",
        "git_url": "https://gitlab.com/muttmua/mutt/-/commit/939b02b33ae29bc0d642570c1dcfd4b339037d19",
        "commit_title": "Don't allocate a group terminator unless we are in a group-list.",
        "commit_text": " This will reduce memory allocation for garbage/spam address lists.  It also makes no sense to store a terminator when there wasn't a display-name indicating the start of a group. ",
        "func_before": "ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s)\n{\n  int ws_pending, nl;\n#ifdef EXACT_ADDRESS\n  const char *begin;\n#endif\n  const char *ps;\n  char comment[LONG_STRING], phrase[LONG_STRING];\n  size_t phraselen = 0, commentlen = 0;\n  ADDRESS *cur, *last = NULL;\n\n  RFC822Error = 0;\n\n  last = top;\n  while (last && last->next)\n    last = last->next;\n\n  ws_pending = is_email_wsp (*s);\n  if ((nl = mutt_strlen (s)))\n    nl = s[nl - 1] == '\\n';\n\n  s = skip_email_wsp(s);\n#ifdef EXACT_ADDRESS\n  begin = s;\n#endif\n  while (*s)\n  {\n    if (*s == ',')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n      commentlen = 0;\n      phraselen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == '(')\n    {\n      if (commentlen && commentlen < sizeof (comment) - 1)\n\tcomment[commentlen++] = ' ';\n      if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '\"')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = ' ';\n      if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '[')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if (phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = '[';\n      if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == ':')\n    {\n      cur = rfc822_new_address ();\n      terminate_buffer (phrase, phraselen);\n      cur->mailbox = safe_strdup (phrase);\n      cur->group = 1;\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n#ifdef EXACT_ADDRESS\n      last->val = mutt_substrdup (begin, s);\n#endif\n\n      phraselen = 0;\n      commentlen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == ';')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n\n      /* add group terminator */\n      if (last)\n      {\n\tlast->next = rfc822_new_address ();\n\tlast = last->next;\n      }\n\n      phraselen = 0;\n      commentlen = 0;\n#ifdef EXACT_ADDRESS\n      begin = s;\n#endif\n      s++;\n    }\n    else if (*s == '<')\n    {\n      terminate_buffer (phrase, phraselen);\n      cur = rfc822_new_address ();\n      if (phraselen)\n\tcur->personal = safe_strdup (phrase);\n      if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL)\n      {\n\trfc822_free_address (&top);\n\trfc822_free_address (&cur);\n\treturn NULL;\n      }\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n      phraselen = 0;\n      commentlen = 0;\n      s = ps;\n    }\n    else\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    ws_pending = is_email_wsp(*s);\n    s = skip_email_wsp(s);\n  }\n\n  if (phraselen)\n  {\n    terminate_buffer (phrase, phraselen);\n    terminate_buffer (comment, commentlen);\n    add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n  }\n  else if (commentlen && last && !last->personal)\n  {\n    terminate_buffer (comment, commentlen);\n    last->personal = safe_strdup (comment);\n  }\n#ifdef EXACT_ADDRESS\n  if (last && !last->val)\n    last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl);\n#endif\n\n  return top;\n}",
        "func": "ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s)\n{\n  int ws_pending, nl, in_group = 0;\n#ifdef EXACT_ADDRESS\n  const char *begin;\n#endif\n  const char *ps;\n  char comment[LONG_STRING], phrase[LONG_STRING];\n  size_t phraselen = 0, commentlen = 0;\n  ADDRESS *cur, *last = NULL;\n\n  RFC822Error = 0;\n\n  last = top;\n  while (last && last->next)\n    last = last->next;\n\n  ws_pending = is_email_wsp (*s);\n  if ((nl = mutt_strlen (s)))\n    nl = s[nl - 1] == '\\n';\n\n  s = skip_email_wsp(s);\n#ifdef EXACT_ADDRESS\n  begin = s;\n#endif\n  while (*s)\n  {\n    if (*s == ',')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n      commentlen = 0;\n      phraselen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == '(')\n    {\n      if (commentlen && commentlen < sizeof (comment) - 1)\n\tcomment[commentlen++] = ' ';\n      if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '\"')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = ' ';\n      if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '[')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if (phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = '[';\n      if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == ':')\n    {\n      cur = rfc822_new_address ();\n      terminate_buffer (phrase, phraselen);\n      cur->mailbox = safe_strdup (phrase);\n      cur->group = 1;\n      in_group = 1;\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n#ifdef EXACT_ADDRESS\n      last->val = mutt_substrdup (begin, s);\n#endif\n\n      phraselen = 0;\n      commentlen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == ';')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n\n      /* add group terminator */\n      if (last && in_group)\n      {\n\tlast->next = rfc822_new_address ();\n\tlast = last->next;\n      }\n      in_group = 0;\n\n      phraselen = 0;\n      commentlen = 0;\n#ifdef EXACT_ADDRESS\n      begin = s;\n#endif\n      s++;\n    }\n    else if (*s == '<')\n    {\n      terminate_buffer (phrase, phraselen);\n      cur = rfc822_new_address ();\n      if (phraselen)\n\tcur->personal = safe_strdup (phrase);\n      if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL)\n      {\n\trfc822_free_address (&top);\n\trfc822_free_address (&cur);\n\treturn NULL;\n      }\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n      phraselen = 0;\n      commentlen = 0;\n      s = ps;\n    }\n    else\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    ws_pending = is_email_wsp(*s);\n    s = skip_email_wsp(s);\n  }\n\n  if (phraselen)\n  {\n    terminate_buffer (phrase, phraselen);\n    terminate_buffer (comment, commentlen);\n    add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n  }\n  else if (commentlen && last && !last->personal)\n  {\n    terminate_buffer (comment, commentlen);\n    last->personal = safe_strdup (comment);\n  }\n#ifdef EXACT_ADDRESS\n  if (last && !last->val)\n    last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl);\n#endif\n\n  return top;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s)\n {\n-  int ws_pending, nl;\n+  int ws_pending, nl, in_group = 0;\n #ifdef EXACT_ADDRESS\n   const char *begin;\n #endif\n@@ -90,6 +90,7 @@\n       terminate_buffer (phrase, phraselen);\n       cur->mailbox = safe_strdup (phrase);\n       cur->group = 1;\n+      in_group = 1;\n \n       if (last)\n \tlast->next = cur;\n@@ -126,11 +127,12 @@\n #endif\n \n       /* add group terminator */\n-      if (last)\n+      if (last && in_group)\n       {\n \tlast->next = rfc822_new_address ();\n \tlast = last->next;\n       }\n+      in_group = 0;\n \n       phraselen = 0;\n       commentlen = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "  int ws_pending, nl;",
                "      if (last)"
            ],
            "added_lines": [
                "  int ws_pending, nl, in_group = 0;",
                "      in_group = 1;",
                "      if (last && in_group)",
                "      in_group = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3181",
        "func_name": "muttmua/mutt/rfc822_parse_adrlist",
        "description": "rfc822.c in Mutt through 2.0.4 allows remote attackers to cause a denial of service (mailbox unavailability) by sending email messages with sequences of semicolon characters in RFC822 address fields (aka terminators of empty groups). A small email message from the attacker can cause large memory consumption, and the victim may then be unable to see email messages from other persons.",
        "git_url": "https://gitlab.com/muttmua/mutt/-/commit/4a2becbdb4422aaffe3ce314991b9d670b7adf17",
        "commit_title": "Fix memory leak parsing group addresses without a display name.",
        "commit_text": " When there was a group address terminator with no previous addresses (including the group display-name), an address would be allocated but not attached to the address list.  Change this to only allocate when last exists.  It would be more correct to not allocate at all unless we are inside a group list, but I will address that in a separate commit to master. ",
        "func_before": "ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s)\n{\n  int ws_pending, nl;\n#ifdef EXACT_ADDRESS\n  const char *begin;\n#endif\n  const char *ps;\n  char comment[LONG_STRING], phrase[LONG_STRING];\n  size_t phraselen = 0, commentlen = 0;\n  ADDRESS *cur, *last = NULL;\n\n  RFC822Error = 0;\n\n  last = top;\n  while (last && last->next)\n    last = last->next;\n\n  ws_pending = is_email_wsp (*s);\n  if ((nl = mutt_strlen (s)))\n    nl = s[nl - 1] == '\\n';\n\n  s = skip_email_wsp(s);\n#ifdef EXACT_ADDRESS\n  begin = s;\n#endif\n  while (*s)\n  {\n    if (*s == ',')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n      commentlen = 0;\n      phraselen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == '(')\n    {\n      if (commentlen && commentlen < sizeof (comment) - 1)\n\tcomment[commentlen++] = ' ';\n      if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '\"')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = ' ';\n      if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '[')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if (phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = '[';\n      if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == ':')\n    {\n      cur = rfc822_new_address ();\n      terminate_buffer (phrase, phraselen);\n      cur->mailbox = safe_strdup (phrase);\n      cur->group = 1;\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n#ifdef EXACT_ADDRESS\n      last->val = mutt_substrdup (begin, s);\n#endif\n\n      phraselen = 0;\n      commentlen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == ';')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n\n      /* add group terminator */\n      cur = rfc822_new_address ();\n      if (last)\n      {\n\tlast->next = cur;\n\tlast = cur;\n      }\n\n      phraselen = 0;\n      commentlen = 0;\n#ifdef EXACT_ADDRESS\n      begin = s;\n#endif\n      s++;\n    }\n    else if (*s == '<')\n    {\n      terminate_buffer (phrase, phraselen);\n      cur = rfc822_new_address ();\n      if (phraselen)\n\tcur->personal = safe_strdup (phrase);\n      if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL)\n      {\n\trfc822_free_address (&top);\n\trfc822_free_address (&cur);\n\treturn NULL;\n      }\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n      phraselen = 0;\n      commentlen = 0;\n      s = ps;\n    }\n    else\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    ws_pending = is_email_wsp(*s);\n    s = skip_email_wsp(s);\n  }\n\n  if (phraselen)\n  {\n    terminate_buffer (phrase, phraselen);\n    terminate_buffer (comment, commentlen);\n    add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n  }\n  else if (commentlen && last && !last->personal)\n  {\n    terminate_buffer (comment, commentlen);\n    last->personal = safe_strdup (comment);\n  }\n#ifdef EXACT_ADDRESS\n  if (last && !last->val)\n    last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl);\n#endif\n\n  return top;\n}",
        "func": "ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s)\n{\n  int ws_pending, nl;\n#ifdef EXACT_ADDRESS\n  const char *begin;\n#endif\n  const char *ps;\n  char comment[LONG_STRING], phrase[LONG_STRING];\n  size_t phraselen = 0, commentlen = 0;\n  ADDRESS *cur, *last = NULL;\n\n  RFC822Error = 0;\n\n  last = top;\n  while (last && last->next)\n    last = last->next;\n\n  ws_pending = is_email_wsp (*s);\n  if ((nl = mutt_strlen (s)))\n    nl = s[nl - 1] == '\\n';\n\n  s = skip_email_wsp(s);\n#ifdef EXACT_ADDRESS\n  begin = s;\n#endif\n  while (*s)\n  {\n    if (*s == ',')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n      commentlen = 0;\n      phraselen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == '(')\n    {\n      if (commentlen && commentlen < sizeof (comment) - 1)\n\tcomment[commentlen++] = ' ';\n      if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '\"')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = ' ';\n      if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == '[')\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if (phraselen < sizeof (phrase) - 1)\n        phrase[phraselen++] = '[';\n      if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n        rfc822_free_address (&top);\n        return NULL;\n      }\n      s = ps;\n    }\n    else if (*s == ':')\n    {\n      cur = rfc822_new_address ();\n      terminate_buffer (phrase, phraselen);\n      cur->mailbox = safe_strdup (phrase);\n      cur->group = 1;\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n#ifdef EXACT_ADDRESS\n      last->val = mutt_substrdup (begin, s);\n#endif\n\n      phraselen = 0;\n      commentlen = 0;\n      s++;\n#ifdef EXACT_ADDRESS\n      begin = skip_email_wsp(s);\n#endif\n    }\n    else if (*s == ';')\n    {\n      if (phraselen)\n      {\n\tterminate_buffer (phrase, phraselen);\n\tadd_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n      }\n      else if (commentlen && last && !last->personal)\n      {\n\tterminate_buffer (comment, commentlen);\n\tlast->personal = safe_strdup (comment);\n      }\n#ifdef EXACT_ADDRESS\n      if (last && !last->val)\n\tlast->val = mutt_substrdup (begin, s);\n#endif\n\n      /* add group terminator */\n      if (last)\n      {\n\tlast->next = rfc822_new_address ();\n\tlast = last->next;\n      }\n\n      phraselen = 0;\n      commentlen = 0;\n#ifdef EXACT_ADDRESS\n      begin = s;\n#endif\n      s++;\n    }\n    else if (*s == '<')\n    {\n      terminate_buffer (phrase, phraselen);\n      cur = rfc822_new_address ();\n      if (phraselen)\n\tcur->personal = safe_strdup (phrase);\n      if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL)\n      {\n\trfc822_free_address (&top);\n\trfc822_free_address (&cur);\n\treturn NULL;\n      }\n\n      if (last)\n\tlast->next = cur;\n      else\n\ttop = cur;\n      last = cur;\n\n      phraselen = 0;\n      commentlen = 0;\n      s = ps;\n    }\n    else\n    {\n      if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending)\n\tphrase[phraselen++] = ' ';\n      if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL)\n      {\n\trfc822_free_address (&top);\n\treturn NULL;\n      }\n      s = ps;\n    }\n    ws_pending = is_email_wsp(*s);\n    s = skip_email_wsp(s);\n  }\n\n  if (phraselen)\n  {\n    terminate_buffer (phrase, phraselen);\n    terminate_buffer (comment, commentlen);\n    add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1);\n  }\n  else if (commentlen && last && !last->personal)\n  {\n    terminate_buffer (comment, commentlen);\n    last->personal = safe_strdup (comment);\n  }\n#ifdef EXACT_ADDRESS\n  if (last && !last->val)\n    last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl);\n#endif\n\n  return top;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -126,11 +126,10 @@\n #endif\n \n       /* add group terminator */\n-      cur = rfc822_new_address ();\n       if (last)\n       {\n-\tlast->next = cur;\n-\tlast = cur;\n+\tlast->next = rfc822_new_address ();\n+\tlast = last->next;\n       }\n \n       phraselen = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "      cur = rfc822_new_address ();",
                "\tlast->next = cur;",
                "\tlast = cur;"
            ],
            "added_lines": [
                "\tlast->next = rfc822_new_address ();",
                "\tlast = last->next;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22173",
        "func_name": "wireshark/get_usage_page_item_string",
        "description": "Memory leak in USB HID dissector in Wireshark 3.4.0 to 3.4.2 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/26f0db01a7f7e6c69eee2f1c601444c64ca53e19",
        "commit_title": "USB HID: Fix a memory leak.",
        "commit_text": " Replace mismatched g_strdup() + g_free()s with wmem_strdup_printf(wmem_packet_scope(), ...). Fixes #17124. ",
        "func_before": "static gchar*\nget_usage_page_item_string(guint32 usage_page, guint32 id)\n{\n    const char *str = NULL;\n\n    switch (usage_page)\n    {\n    case GENERIC_DESKTOP_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_generic_desktop_controls_usage_page_vals);\n        break;\n    case SIMULATION_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_simulation_control_usage_page_vals);\n        break;\n    case VR_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_vr_controls_usage_page_vals);\n        break;\n    case SPORT_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_sport_controls_usage_page_vals);\n        break;\n    case GAME_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_game_controls_usage_page_vals);\n        break;\n    case GENERIC_DEVICE_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_generic_device_controls_usage_page_vals);\n        break;\n    case KEYBOARD_KEYPAD_PAGE:\n        str = try_val_to_str(id, usb_hid_keyboard_keypad_usage_page_vals);\n        break;\n    case LED_PAGE:\n        str = try_val_to_str(id, usb_hid_led_usage_page_vals);\n        break;\n    case BUTTON_PAGE:\n        str = try_val_to_str(id, usb_hid_button_usage_page_vals);\n        if (!str)\n            str = \"Button %u\";\n        break;\n    case ORDINAL_PAGE:\n        str = try_val_to_str(id, usb_hid_ordinal_usage_page_vals);\n        break;\n    case TELEPHONY_PAGE:\n        str = try_val_to_str(id, usb_hid_telephony_device_usage_page_vals);\n        break;\n    case CONSUMER_PAGE:\n        str = try_val_to_str(id, usb_hid_consumer_usage_page_vals);\n        if (!str)\n            str = \"Instance %u\";\n        break;\n    case DIGITIZER_PAGE:\n        str = try_val_to_str(id, usb_hid_digitizers_usage_page_vals);\n        break;\n    case HAPTICS_PAGE:\n        str = try_val_to_str(id, usb_hid_haptic_usage_page_vals);\n        if (id >= 0x1006 && id <= 0x1FFF)\n            str = \"Reserved for standard waveforms\";\n        if (id >= 0x2001 && id <= 0x2FFF)\n            str = \"Vendor Waveforms\";\n        break;\n    case PID_PAGE:\n        str = try_val_to_str(id, usb_hid_physical_input_device_usage_page_vals);\n        break;\n    case UNICODE_PAGE:\n        str = \"Character U+%04X\";\n        break;\n    case EYE_AND_HEAD_TRACKER_PAGE:\n        str = try_val_to_str(id, usb_hid_eye_and_head_tracker_usage_page_vals);\n        break;\n    case ALPHANUMERIC_DISPLAY_PAGE:\n        str = try_val_to_str(id, usb_hid_alphanumeric_display_usage_page_vals);\n        break;\n    case SENSOR_PAGE:\n        str = try_val_to_str(id, usb_hid_sensor_usage_page_vals);\n        if (!str)\n            str = try_rval_to_str(id, usb_hid_sensor_usage_page_ranges);\n        break;\n    case MEDICAL_INSTRUMENTS_PAGE:\n        str = try_val_to_str(id, usb_hid_medical_instrument_usage_page_vals);\n        break;\n    case BRAILLE_DISPLAY_PAGE:\n        str = try_val_to_str(id, usb_hid_braille_dispaly_usage_page_vals);\n        break;\n    case LIGHTING_AND_ILLUMINATION_PAGE:\n        str = try_val_to_str(id, usb_hid_lighting_and_illumination_usage_page_vals);\n        break;\n    case USB_MONITOR_PAGE:\n        str = try_val_to_str(id, usb_hid_monitor_usage_page_vals);\n        break;\n    case USB_ENUMERATED_VALUES_PAGE:\n        str = \"ENUM_%u\";\n        break;\n    case VESA_VIRTUAL_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_vesa_virtual_control_usage_page_vals);\n        break;\n    case POWER_DEVICE_PAGE:\n        str = try_val_to_str(id, usb_hid_power_device_usage_page_vals);\n        break;\n    case BATTERY_SYSTEM_PAGE:\n        str = try_val_to_str(id, usb_hid_battery_system_usage_page_vals);\n        break;\n    case BARCODE_SCANNER_PAGE:\n        str = try_val_to_str(id, usb_hid_barcode_scanner_usage_page_vals);\n        break;\n    case WEIGHING_PAGE:\n        str = try_val_to_str(id, usb_hid_weighing_devices_usage_page_vals);\n        break;\n    case MSR_PAGE:\n        str = try_val_to_str(id, usb_hid_magnetic_stripe_reader_usage_page_vals);\n        break;\n    case ARCADE_PAGE:\n        str = try_val_to_str(id, usb_hid_arcade_usage_page_vals);\n        break;\n    case FIDO_ALLIANCE_PAGE:\n        str = try_val_to_str(id, usb_hid_fido_alliance_usage_page_vals);\n        break;\n    default:\n        if ((usage_page & VENDOR_PAGE_HBYTE) == VENDOR_PAGE_HBYTE)\n            str = \"Vendor\";\n        break;\n    }\n\n    if (!str)\n        str = \"Reserved\";\n\n    return g_strdup_printf(str, id);\n}",
        "func": "static gchar*\nget_usage_page_item_string(guint32 usage_page, guint32 id)\n{\n    const char *str = NULL;\n\n    switch (usage_page)\n    {\n    case GENERIC_DESKTOP_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_generic_desktop_controls_usage_page_vals);\n        break;\n    case SIMULATION_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_simulation_control_usage_page_vals);\n        break;\n    case VR_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_vr_controls_usage_page_vals);\n        break;\n    case SPORT_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_sport_controls_usage_page_vals);\n        break;\n    case GAME_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_game_controls_usage_page_vals);\n        break;\n    case GENERIC_DEVICE_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_generic_device_controls_usage_page_vals);\n        break;\n    case KEYBOARD_KEYPAD_PAGE:\n        str = try_val_to_str(id, usb_hid_keyboard_keypad_usage_page_vals);\n        break;\n    case LED_PAGE:\n        str = try_val_to_str(id, usb_hid_led_usage_page_vals);\n        break;\n    case BUTTON_PAGE:\n        str = try_val_to_str(id, usb_hid_button_usage_page_vals);\n        if (!str)\n            str = \"Button %u\";\n        break;\n    case ORDINAL_PAGE:\n        str = try_val_to_str(id, usb_hid_ordinal_usage_page_vals);\n        break;\n    case TELEPHONY_PAGE:\n        str = try_val_to_str(id, usb_hid_telephony_device_usage_page_vals);\n        break;\n    case CONSUMER_PAGE:\n        str = try_val_to_str(id, usb_hid_consumer_usage_page_vals);\n        if (!str)\n            str = \"Instance %u\";\n        break;\n    case DIGITIZER_PAGE:\n        str = try_val_to_str(id, usb_hid_digitizers_usage_page_vals);\n        break;\n    case HAPTICS_PAGE:\n        str = try_val_to_str(id, usb_hid_haptic_usage_page_vals);\n        if (id >= 0x1006 && id <= 0x1FFF)\n            str = \"Reserved for standard waveforms\";\n        if (id >= 0x2001 && id <= 0x2FFF)\n            str = \"Vendor Waveforms\";\n        break;\n    case PID_PAGE:\n        str = try_val_to_str(id, usb_hid_physical_input_device_usage_page_vals);\n        break;\n    case UNICODE_PAGE:\n        str = \"Character U+%04X\";\n        break;\n    case EYE_AND_HEAD_TRACKER_PAGE:\n        str = try_val_to_str(id, usb_hid_eye_and_head_tracker_usage_page_vals);\n        break;\n    case ALPHANUMERIC_DISPLAY_PAGE:\n        str = try_val_to_str(id, usb_hid_alphanumeric_display_usage_page_vals);\n        break;\n    case SENSOR_PAGE:\n        str = try_val_to_str(id, usb_hid_sensor_usage_page_vals);\n        if (!str)\n            str = try_rval_to_str(id, usb_hid_sensor_usage_page_ranges);\n        break;\n    case MEDICAL_INSTRUMENTS_PAGE:\n        str = try_val_to_str(id, usb_hid_medical_instrument_usage_page_vals);\n        break;\n    case BRAILLE_DISPLAY_PAGE:\n        str = try_val_to_str(id, usb_hid_braille_dispaly_usage_page_vals);\n        break;\n    case LIGHTING_AND_ILLUMINATION_PAGE:\n        str = try_val_to_str(id, usb_hid_lighting_and_illumination_usage_page_vals);\n        break;\n    case USB_MONITOR_PAGE:\n        str = try_val_to_str(id, usb_hid_monitor_usage_page_vals);\n        break;\n    case USB_ENUMERATED_VALUES_PAGE:\n        str = \"ENUM_%u\";\n        break;\n    case VESA_VIRTUAL_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_vesa_virtual_control_usage_page_vals);\n        break;\n    case POWER_DEVICE_PAGE:\n        str = try_val_to_str(id, usb_hid_power_device_usage_page_vals);\n        break;\n    case BATTERY_SYSTEM_PAGE:\n        str = try_val_to_str(id, usb_hid_battery_system_usage_page_vals);\n        break;\n    case BARCODE_SCANNER_PAGE:\n        str = try_val_to_str(id, usb_hid_barcode_scanner_usage_page_vals);\n        break;\n    case WEIGHING_PAGE:\n        str = try_val_to_str(id, usb_hid_weighing_devices_usage_page_vals);\n        break;\n    case MSR_PAGE:\n        str = try_val_to_str(id, usb_hid_magnetic_stripe_reader_usage_page_vals);\n        break;\n    case ARCADE_PAGE:\n        str = try_val_to_str(id, usb_hid_arcade_usage_page_vals);\n        break;\n    case FIDO_ALLIANCE_PAGE:\n        str = try_val_to_str(id, usb_hid_fido_alliance_usage_page_vals);\n        break;\n    default:\n        if ((usage_page & VENDOR_PAGE_HBYTE) == VENDOR_PAGE_HBYTE)\n            str = \"Vendor\";\n        break;\n    }\n\n    if (!str)\n        str = \"Reserved\";\n\n    return wmem_strdup_printf(wmem_packet_scope(), str, id);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -120,5 +120,5 @@\n     if (!str)\n         str = \"Reserved\";\n \n-    return g_strdup_printf(str, id);\n+    return wmem_strdup_printf(wmem_packet_scope(), str, id);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return g_strdup_printf(str, id);"
            ],
            "added_lines": [
                "    return wmem_strdup_printf(wmem_packet_scope(), str, id);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22173",
        "func_name": "wireshark/dissect_usb_hid_report_localitem_data",
        "description": "Memory leak in USB HID dissector in Wireshark 3.4.0 to 3.4.2 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/26f0db01a7f7e6c69eee2f1c601444c64ca53e19",
        "commit_title": "USB HID: Fix a memory leak.",
        "commit_text": " Replace mismatched g_strdup() + g_free()s with wmem_strdup_printf(wmem_packet_scope(), ...). Fixes #17124. ",
        "func_before": "static int\ndissect_usb_hid_report_localitem_data(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, int offset, unsigned int bSize, unsigned int bTag, struct usb_hid_global_state *global)\n{\n    guint32 id = 0xffff;\n    proto_item *ti = proto_tree_get_parent(tree);\n    gchar *str = NULL;\n    guint32 val;\n\n    switch (bTag) {\n        case USBHID_LOCALITEM_TAG_USAGE:\n            if (bSize > 2) {\n                /* Full page ID */\n                proto_tree_add_item(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, ENC_LITTLE_ENDIAN);\n            } else {\n                /* Only lower few bits given, need to combine with last global ID */\n                if (bSize == 1)\n                    id = tvb_get_guint8(tvb, offset);\n                else if (bSize == 2)\n                    id = tvb_get_ntohs(tvb, offset);\n                str = get_usage_page_item_string(global->usage_page, id);\n                proto_tree_add_uint_format(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, id, \"Usage: %s (0x%02x)\", str, id);\n                proto_item_append_text(ti, \" (%s)\", str);\n            }\n            break;\n        case USBHID_LOCALITEM_TAG_USAGE_MIN:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_usage_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_USAGE_MAX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_DESIG_INDEX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_index, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_DESIG_MIN:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_DESIG_MAX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_max, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_STRING_INDEX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_index, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_STRING_MIN:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_STRING_MAX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_max, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_DELIMITER:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_delimiter, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        default:\n            proto_tree_add_item(tree, hf_usb_hid_item_unk_data, tvb, offset, bSize, ENC_NA);\n            proto_item_append_text(ti, \" (Unknown)\");\n            break;\n    }\n    offset += bSize;\n\n    g_free(str);\n\n    return offset;\n}",
        "func": "static int\ndissect_usb_hid_report_localitem_data(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, int offset, unsigned int bSize, unsigned int bTag, struct usb_hid_global_state *global)\n{\n    guint32 id = 0xffff;\n    proto_item *ti = proto_tree_get_parent(tree);\n    gchar *str = NULL;\n    guint32 val;\n\n    switch (bTag) {\n        case USBHID_LOCALITEM_TAG_USAGE:\n            if (bSize > 2) {\n                /* Full page ID */\n                proto_tree_add_item(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, ENC_LITTLE_ENDIAN);\n            } else {\n                /* Only lower few bits given, need to combine with last global ID */\n                if (bSize == 1)\n                    id = tvb_get_guint8(tvb, offset);\n                else if (bSize == 2)\n                    id = tvb_get_ntohs(tvb, offset);\n                str = get_usage_page_item_string(global->usage_page, id);\n                proto_tree_add_uint_format(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, id, \"Usage: %s (0x%02x)\", str, id);\n                proto_item_append_text(ti, \" (%s)\", str);\n            }\n            break;\n        case USBHID_LOCALITEM_TAG_USAGE_MIN:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_usage_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_USAGE_MAX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_usage, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_DESIG_INDEX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_index, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_DESIG_MIN:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_DESIG_MAX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_desig_max, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_STRING_INDEX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_index, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_STRING_MIN:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_min, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_STRING_MAX:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_string_max, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        case USBHID_LOCALITEM_TAG_DELIMITER:\n            proto_tree_add_item_ret_uint(tree, hf_usb_hid_localitem_delimiter, tvb, offset, bSize, ENC_LITTLE_ENDIAN, &val);\n            proto_item_append_text(ti, \" (0x%02x)\", val);\n            break;\n        default:\n            proto_tree_add_item(tree, hf_usb_hid_item_unk_data, tvb, offset, bSize, ENC_NA);\n            proto_item_append_text(ti, \" (Unknown)\");\n            break;\n    }\n    offset += bSize;\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,7 +65,5 @@\n     }\n     offset += bSize;\n \n-    g_free(str);\n-\n     return offset;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    g_free(str);",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-20265",
        "func_name": "torvalds/linux/unix_stream_read_generic",
        "description": "A flaw was found in the way memory resources were freed in the unix_stream_recvmsg function in the Linux kernel when a signal was pending. This flaw allows an unprivileged local user to crash the system by exhausting available memory. The highest threat from this vulnerability is to system availability.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=fa0dc04df259ba2df3ce1920e9690c7842f8fa4b",
        "commit_title": "Dmitry reported a struct pid leak detected by a syzkaller program.",
        "commit_text": " Bug happens in unix_stream_recvmsg() when we break the loop when a signal is pending, without properly releasing scm.  Cc: Rainer Weikusat <rweikusat@mobileactivedefense.com> ",
        "func_before": "static int unix_stream_read_generic(struct unix_stream_read_state *state)\n{\n\tstruct scm_cookie scm;\n\tstruct socket *sock = state->socket;\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u = unix_sk(sk);\n\tint copied = 0;\n\tint flags = state->flags;\n\tint noblock = flags & MSG_DONTWAIT;\n\tbool check_creds = false;\n\tint target;\n\tint err = 0;\n\tlong timeo;\n\tint skip;\n\tsize_t size = state->size;\n\tunsigned int last_len;\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\terr = -EOPNOTSUPP;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n\ttimeo = sock_rcvtimeo(sk, noblock);\n\n\tmemset(&scm, 0, sizeof(scm));\n\n\t/* Lock the socket to prevent queue disordering\n\t * while sleeps in memcpy_tomsg\n\t */\n\tmutex_lock(&u->readlock);\n\n\tif (flags & MSG_PEEK)\n\t\tskip = sk_peek_offset(sk, flags);\n\telse\n\t\tskip = 0;\n\n\tdo {\n\t\tint chunk;\n\t\tbool drop_skb;\n\t\tstruct sk_buff *skb, *last;\n\n\t\tunix_state_lock(sk);\n\t\tif (sock_flag(sk, SOCK_DEAD)) {\n\t\t\terr = -ECONNRESET;\n\t\t\tgoto unlock;\n\t\t}\n\t\tlast = skb = skb_peek(&sk->sk_receive_queue);\n\t\tlast_len = last ? last->len : 0;\nagain:\n\t\tif (skb == NULL) {\n\t\t\tunix_sk(sk)->recursion_level = 0;\n\t\t\tif (copied >= target)\n\t\t\t\tgoto unlock;\n\n\t\t\t/*\n\t\t\t *\tPOSIX 1003.1g mandates this order.\n\t\t\t */\n\n\t\t\terr = sock_error(sk);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tgoto unlock;\n\n\t\t\tunix_state_unlock(sk);\n\t\t\terr = -EAGAIN;\n\t\t\tif (!timeo)\n\t\t\t\tbreak;\n\t\t\tmutex_unlock(&u->readlock);\n\n\t\t\ttimeo = unix_stream_data_wait(sk, timeo, last,\n\t\t\t\t\t\t      last_len);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeo);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmutex_lock(&u->readlock);\n\t\t\tcontinue;\nunlock:\n\t\t\tunix_state_unlock(sk);\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (skip >= unix_skb_len(skb)) {\n\t\t\tskip -= unix_skb_len(skb);\n\t\t\tlast = skb;\n\t\t\tlast_len = skb->len;\n\t\t\tskb = skb_peek_next(skb, &sk->sk_receive_queue);\n\t\t\tif (!skb)\n\t\t\t\tgoto again;\n\t\t}\n\n\t\tunix_state_unlock(sk);\n\n\t\tif (check_creds) {\n\t\t\t/* Never glue messages from different writers */\n\t\t\tif (!unix_skb_scm_eq(skb, &scm))\n\t\t\t\tbreak;\n\t\t} else if (test_bit(SOCK_PASSCRED, &sock->flags)) {\n\t\t\t/* Copy credentials */\n\t\t\tscm_set_cred(&scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);\n\t\t\tunix_set_secdata(&scm, skb);\n\t\t\tcheck_creds = true;\n\t\t}\n\n\t\t/* Copy address just once */\n\t\tif (state->msg && state->msg->msg_name) {\n\t\t\tDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr,\n\t\t\t\t\t state->msg->msg_name);\n\t\t\tunix_copy_addr(state->msg, skb->sk);\n\t\t\tsunaddr = NULL;\n\t\t}\n\n\t\tchunk = min_t(unsigned int, unix_skb_len(skb) - skip, size);\n\t\tskb_get(skb);\n\t\tchunk = state->recv_actor(skb, skip, chunk, state);\n\t\tdrop_skb = !unix_skb_len(skb);\n\t\t/* skb is only safe to use if !drop_skb */\n\t\tconsume_skb(skb);\n\t\tif (chunk < 0) {\n\t\t\tif (copied == 0)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize -= chunk;\n\n\t\tif (drop_skb) {\n\t\t\t/* the skb was touched by a concurrent reader;\n\t\t\t * we should not expect anything from this skb\n\t\t\t * anymore and assume it invalid - we can be\n\t\t\t * sure it was dropped from the socket queue\n\t\t\t *\n\t\t\t * let's report a short read\n\t\t\t */\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Mark read part of skb as used */\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tUNIXCB(skb).consumed += chunk;\n\n\t\t\tsk_peek_offset_bwd(sk, chunk);\n\n\t\t\tif (UNIXCB(skb).fp)\n\t\t\t\tunix_detach_fds(&scm, skb);\n\n\t\t\tif (unix_skb_len(skb))\n\t\t\t\tbreak;\n\n\t\t\tskb_unlink(skb, &sk->sk_receive_queue);\n\t\t\tconsume_skb(skb);\n\n\t\t\tif (scm.fp)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* It is questionable, see note in unix_dgram_recvmsg.\n\t\t\t */\n\t\t\tif (UNIXCB(skb).fp)\n\t\t\t\tscm.fp = scm_fp_dup(UNIXCB(skb).fp);\n\n\t\t\tsk_peek_offset_fwd(sk, chunk);\n\n\t\t\tif (UNIXCB(skb).fp)\n\t\t\t\tbreak;\n\n\t\t\tskip = 0;\n\t\t\tlast = skb;\n\t\t\tlast_len = skb->len;\n\t\t\tunix_state_lock(sk);\n\t\t\tskb = skb_peek_next(skb, &sk->sk_receive_queue);\n\t\t\tif (skb)\n\t\t\t\tgoto again;\n\t\t\tunix_state_unlock(sk);\n\t\t\tbreak;\n\t\t}\n\t} while (size);\n\n\tmutex_unlock(&u->readlock);\n\tif (state->msg)\n\t\tscm_recv(sock, state->msg, &scm, flags);\n\telse\n\t\tscm_destroy(&scm);\nout:\n\treturn copied ? : err;\n}",
        "func": "static int unix_stream_read_generic(struct unix_stream_read_state *state)\n{\n\tstruct scm_cookie scm;\n\tstruct socket *sock = state->socket;\n\tstruct sock *sk = sock->sk;\n\tstruct unix_sock *u = unix_sk(sk);\n\tint copied = 0;\n\tint flags = state->flags;\n\tint noblock = flags & MSG_DONTWAIT;\n\tbool check_creds = false;\n\tint target;\n\tint err = 0;\n\tlong timeo;\n\tint skip;\n\tsize_t size = state->size;\n\tunsigned int last_len;\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\terr = -EOPNOTSUPP;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n\ttimeo = sock_rcvtimeo(sk, noblock);\n\n\tmemset(&scm, 0, sizeof(scm));\n\n\t/* Lock the socket to prevent queue disordering\n\t * while sleeps in memcpy_tomsg\n\t */\n\tmutex_lock(&u->readlock);\n\n\tif (flags & MSG_PEEK)\n\t\tskip = sk_peek_offset(sk, flags);\n\telse\n\t\tskip = 0;\n\n\tdo {\n\t\tint chunk;\n\t\tbool drop_skb;\n\t\tstruct sk_buff *skb, *last;\n\n\t\tunix_state_lock(sk);\n\t\tif (sock_flag(sk, SOCK_DEAD)) {\n\t\t\terr = -ECONNRESET;\n\t\t\tgoto unlock;\n\t\t}\n\t\tlast = skb = skb_peek(&sk->sk_receive_queue);\n\t\tlast_len = last ? last->len : 0;\nagain:\n\t\tif (skb == NULL) {\n\t\t\tunix_sk(sk)->recursion_level = 0;\n\t\t\tif (copied >= target)\n\t\t\t\tgoto unlock;\n\n\t\t\t/*\n\t\t\t *\tPOSIX 1003.1g mandates this order.\n\t\t\t */\n\n\t\t\terr = sock_error(sk);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tgoto unlock;\n\n\t\t\tunix_state_unlock(sk);\n\t\t\terr = -EAGAIN;\n\t\t\tif (!timeo)\n\t\t\t\tbreak;\n\t\t\tmutex_unlock(&u->readlock);\n\n\t\t\ttimeo = unix_stream_data_wait(sk, timeo, last,\n\t\t\t\t\t\t      last_len);\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = sock_intr_errno(timeo);\n\t\t\t\tscm_destroy(&scm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmutex_lock(&u->readlock);\n\t\t\tcontinue;\nunlock:\n\t\t\tunix_state_unlock(sk);\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (skip >= unix_skb_len(skb)) {\n\t\t\tskip -= unix_skb_len(skb);\n\t\t\tlast = skb;\n\t\t\tlast_len = skb->len;\n\t\t\tskb = skb_peek_next(skb, &sk->sk_receive_queue);\n\t\t\tif (!skb)\n\t\t\t\tgoto again;\n\t\t}\n\n\t\tunix_state_unlock(sk);\n\n\t\tif (check_creds) {\n\t\t\t/* Never glue messages from different writers */\n\t\t\tif (!unix_skb_scm_eq(skb, &scm))\n\t\t\t\tbreak;\n\t\t} else if (test_bit(SOCK_PASSCRED, &sock->flags)) {\n\t\t\t/* Copy credentials */\n\t\t\tscm_set_cred(&scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);\n\t\t\tunix_set_secdata(&scm, skb);\n\t\t\tcheck_creds = true;\n\t\t}\n\n\t\t/* Copy address just once */\n\t\tif (state->msg && state->msg->msg_name) {\n\t\t\tDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr,\n\t\t\t\t\t state->msg->msg_name);\n\t\t\tunix_copy_addr(state->msg, skb->sk);\n\t\t\tsunaddr = NULL;\n\t\t}\n\n\t\tchunk = min_t(unsigned int, unix_skb_len(skb) - skip, size);\n\t\tskb_get(skb);\n\t\tchunk = state->recv_actor(skb, skip, chunk, state);\n\t\tdrop_skb = !unix_skb_len(skb);\n\t\t/* skb is only safe to use if !drop_skb */\n\t\tconsume_skb(skb);\n\t\tif (chunk < 0) {\n\t\t\tif (copied == 0)\n\t\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += chunk;\n\t\tsize -= chunk;\n\n\t\tif (drop_skb) {\n\t\t\t/* the skb was touched by a concurrent reader;\n\t\t\t * we should not expect anything from this skb\n\t\t\t * anymore and assume it invalid - we can be\n\t\t\t * sure it was dropped from the socket queue\n\t\t\t *\n\t\t\t * let's report a short read\n\t\t\t */\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Mark read part of skb as used */\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\tUNIXCB(skb).consumed += chunk;\n\n\t\t\tsk_peek_offset_bwd(sk, chunk);\n\n\t\t\tif (UNIXCB(skb).fp)\n\t\t\t\tunix_detach_fds(&scm, skb);\n\n\t\t\tif (unix_skb_len(skb))\n\t\t\t\tbreak;\n\n\t\t\tskb_unlink(skb, &sk->sk_receive_queue);\n\t\t\tconsume_skb(skb);\n\n\t\t\tif (scm.fp)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* It is questionable, see note in unix_dgram_recvmsg.\n\t\t\t */\n\t\t\tif (UNIXCB(skb).fp)\n\t\t\t\tscm.fp = scm_fp_dup(UNIXCB(skb).fp);\n\n\t\t\tsk_peek_offset_fwd(sk, chunk);\n\n\t\t\tif (UNIXCB(skb).fp)\n\t\t\t\tbreak;\n\n\t\t\tskip = 0;\n\t\t\tlast = skb;\n\t\t\tlast_len = skb->len;\n\t\t\tunix_state_lock(sk);\n\t\t\tskb = skb_peek_next(skb, &sk->sk_receive_queue);\n\t\t\tif (skb)\n\t\t\t\tgoto again;\n\t\t\tunix_state_unlock(sk);\n\t\t\tbreak;\n\t\t}\n\t} while (size);\n\n\tmutex_unlock(&u->readlock);\n\tif (state->msg)\n\t\tscm_recv(sock, state->msg, &scm, flags);\n\telse\n\t\tscm_destroy(&scm);\nout:\n\treturn copied ? : err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,6 +77,7 @@\n \n \t\t\tif (signal_pending(current)) {\n \t\t\t\terr = sock_intr_errno(timeo);\n+\t\t\t\tscm_destroy(&scm);\n \t\t\t\tgoto out;\n \t\t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tscm_destroy(&scm);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-20193",
        "func_name": "tar/read_header",
        "description": "A flaw was found in the src/list.c of tar 1.33 and earlier. This flaw allows an attacker who can submit a crafted input file to tar to cause uncontrolled consumption of memory. The highest threat from this vulnerability is to system availability.",
        "git_url": "https://git.savannah.gnu.org/cgit/tar.git/commit/?id=d9d4435692150fa8ff68e1b1a473d187cc3fd777",
        "commit_title": "Bug reported in https://savannah.gnu.org/bugs/?59897",
        "commit_text": " * src/list.c (read_header): Don't return directly from the loop. Instead set the status and break.  Return the status.  Free next_long_name and next_long_link before returning. ",
        "func_before": "enum read_header\nread_header (union block **return_block, struct tar_stat_info *info,\n\t     enum read_header_mode mode)\n{\n  union block *header;\n  union block *header_copy;\n  char *bp;\n  union block *data_block;\n  size_t size, written;\n  union block *next_long_name = 0;\n  union block *next_long_link = 0;\n  size_t next_long_name_blocks = 0;\n  size_t next_long_link_blocks = 0;\n\n  while (1)\n    {\n      enum read_header status;\n\n      header = find_next_block ();\n      *return_block = header;\n      if (!header)\n\treturn HEADER_END_OF_FILE;\n\n      if ((status = tar_checksum (header, false)) != HEADER_SUCCESS)\n\treturn status;\n\n      /* Good block.  Decode file size and return.  */\n\n      if (header->header.typeflag == LNKTYPE)\n\tinfo->stat.st_size = 0;\t/* links 0 size on tape */\n      else\n\t{\n\t  info->stat.st_size = OFF_FROM_HEADER (header->header.size);\n\t  if (info->stat.st_size < 0)\n\t    return HEADER_FAILURE;\n\t}\n\n      if (header->header.typeflag == GNUTYPE_LONGNAME\n\t  || header->header.typeflag == GNUTYPE_LONGLINK\n\t  || header->header.typeflag == XHDTYPE\n\t  || header->header.typeflag == XGLTYPE\n\t  || header->header.typeflag == SOLARIS_XHDTYPE)\n\t{\n\t  if (mode == read_header_x_raw)\n\t    return HEADER_SUCCESS_EXTENDED;\n\t  else if (header->header.typeflag == GNUTYPE_LONGNAME\n\t\t   || header->header.typeflag == GNUTYPE_LONGLINK)\n\t    {\n\t      size_t name_size = info->stat.st_size;\n\t      size_t n = name_size % BLOCKSIZE;\n\t      size = name_size + BLOCKSIZE;\n\t      if (n)\n\t\tsize += BLOCKSIZE - n;\n\n\t      if (name_size != info->stat.st_size || size < name_size)\n\t\txalloc_die ();\n\n\t      header_copy = xmalloc (size + 1);\n\n\t      if (header->header.typeflag == GNUTYPE_LONGNAME)\n\t\t{\n\t\t  free (next_long_name);\n\t\t  next_long_name = header_copy;\n\t\t  next_long_name_blocks = size / BLOCKSIZE;\n\t\t}\n\t      else\n\t\t{\n\t\t  free (next_long_link);\n\t\t  next_long_link = header_copy;\n\t\t  next_long_link_blocks = size / BLOCKSIZE;\n\t\t}\n\n\t      set_next_block_after (header);\n\t      *header_copy = *header;\n\t      bp = header_copy->buffer + BLOCKSIZE;\n\n\t      for (size -= BLOCKSIZE; size > 0; size -= written)\n\t\t{\n\t\t  data_block = find_next_block ();\n\t\t  if (! data_block)\n\t\t    {\n\t\t      ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t\t      break;\n\t\t    }\n\t\t  written = available_space_after (data_block);\n\t\t  if (written > size)\n\t\t    written = size;\n\n\t\t  memcpy (bp, data_block->buffer, written);\n\t\t  bp += written;\n\t\t  set_next_block_after ((union block *)\n\t\t\t\t\t(data_block->buffer + written - 1));\n\t\t}\n\n\t      *bp = '\\0';\n\t    }\n\t  else if (header->header.typeflag == XHDTYPE\n\t\t   || header->header.typeflag == SOLARIS_XHDTYPE)\n\t    xheader_read (&info->xhdr, header,\n\t\t\t  OFF_FROM_HEADER (header->header.size));\n\t  else if (header->header.typeflag == XGLTYPE)\n\t    {\n\t      struct xheader xhdr;\n\n\t      if (!recent_global_header)\n\t\trecent_global_header = xmalloc (sizeof *recent_global_header);\n\t      memcpy (recent_global_header, header,\n\t\t      sizeof *recent_global_header);\n\t      memset (&xhdr, 0, sizeof xhdr);\n\t      xheader_read (&xhdr, header,\n\t\t\t    OFF_FROM_HEADER (header->header.size));\n\t      xheader_decode_global (&xhdr);\n\t      xheader_destroy (&xhdr);\n\t      if (mode == read_header_x_global)\n\t\treturn HEADER_SUCCESS_EXTENDED;\n\t    }\n\n\t  /* Loop!  */\n\n\t}\n      else\n\t{\n\t  char const *name;\n\t  struct posix_header const *h = &header->header;\n\t  char namebuf[sizeof h->prefix + 1 + NAME_FIELD_SIZE + 1];\n\n\t  free (recent_long_name);\n\n\t  if (next_long_name)\n\t    {\n\t      name = next_long_name->buffer + BLOCKSIZE;\n\t      recent_long_name = next_long_name;\n\t      recent_long_name_blocks = next_long_name_blocks;\n\t    }\n\t  else\n\t    {\n\t      /* Accept file names as specified by POSIX.1-1996\n                 section 10.1.1.  */\n\t      char *np = namebuf;\n\n\t      if (h->prefix[0] && strcmp (h->magic, TMAGIC) == 0)\n\t\t{\n\t\t  memcpy (np, h->prefix, sizeof h->prefix);\n\t\t  np[sizeof h->prefix] = '\\0';\n\t\t  np += strlen (np);\n\t\t  *np++ = '/';\n\t\t}\n\t      memcpy (np, h->name, sizeof h->name);\n\t      np[sizeof h->name] = '\\0';\n\t      name = namebuf;\n\t      recent_long_name = 0;\n\t      recent_long_name_blocks = 0;\n\t    }\n\t  assign_string (&info->orig_file_name, name);\n\t  assign_string (&info->file_name, name);\n\t  info->had_trailing_slash = strip_trailing_slashes (info->file_name);\n\n\t  free (recent_long_link);\n\n\t  if (next_long_link)\n\t    {\n\t      name = next_long_link->buffer + BLOCKSIZE;\n\t      recent_long_link = next_long_link;\n\t      recent_long_link_blocks = next_long_link_blocks;\n\t    }\n\t  else\n\t    {\n\t      memcpy (namebuf, h->linkname, sizeof h->linkname);\n\t      namebuf[sizeof h->linkname] = '\\0';\n\t      name = namebuf;\n\t      recent_long_link = 0;\n\t      recent_long_link_blocks = 0;\n\t    }\n\t  assign_string (&info->link_name, name);\n\n\t  return HEADER_SUCCESS;\n\t}\n    }\n}",
        "func": "enum read_header\nread_header (union block **return_block, struct tar_stat_info *info,\n\t     enum read_header_mode mode)\n{\n  union block *header;\n  char *bp;\n  union block *data_block;\n  size_t size, written;\n  union block *next_long_name = NULL;\n  union block *next_long_link = NULL;\n  size_t next_long_name_blocks = 0;\n  size_t next_long_link_blocks = 0;\n  enum read_header status = HEADER_SUCCESS;\n  \n  while (1)\n    {\n      header = find_next_block ();\n      *return_block = header;\n      if (!header)\n\t{\n\t  status = HEADER_END_OF_FILE;\n\t  break;\n\t}\n\n      if ((status = tar_checksum (header, false)) != HEADER_SUCCESS)\n\tbreak;\n\n      /* Good block.  Decode file size and return.  */\n\n      if (header->header.typeflag == LNKTYPE)\n\tinfo->stat.st_size = 0;\t/* links 0 size on tape */\n      else\n\t{\n\t  info->stat.st_size = OFF_FROM_HEADER (header->header.size);\n\t  if (info->stat.st_size < 0)\n\t    {\n\t      status = HEADER_FAILURE;\n\t      break;\n\t    }\n\t}\n\n      if (header->header.typeflag == GNUTYPE_LONGNAME\n\t  || header->header.typeflag == GNUTYPE_LONGLINK\n\t  || header->header.typeflag == XHDTYPE\n\t  || header->header.typeflag == XGLTYPE\n\t  || header->header.typeflag == SOLARIS_XHDTYPE)\n\t{\n\t  if (mode == read_header_x_raw)\n\t    {\n\t      status = HEADER_SUCCESS_EXTENDED;\n\t      break;\n\t    }\n\t  else if (header->header.typeflag == GNUTYPE_LONGNAME\n\t\t   || header->header.typeflag == GNUTYPE_LONGLINK)\n\t    {\n\t      union block *header_copy;\n\t      size_t name_size = info->stat.st_size;\n\t      size_t n = name_size % BLOCKSIZE;\n\t      size = name_size + BLOCKSIZE;\n\t      if (n)\n\t\tsize += BLOCKSIZE - n;\n\n\t      if (name_size != info->stat.st_size || size < name_size)\n\t\txalloc_die ();\n\n\t      header_copy = xmalloc (size + 1);\n\n\t      if (header->header.typeflag == GNUTYPE_LONGNAME)\n\t\t{\n\t\t  free (next_long_name);\n\t\t  next_long_name = header_copy;\n\t\t  next_long_name_blocks = size / BLOCKSIZE;\n\t\t}\n\t      else\n\t\t{\n\t\t  free (next_long_link);\n\t\t  next_long_link = header_copy;\n\t\t  next_long_link_blocks = size / BLOCKSIZE;\n\t\t}\n\n\t      set_next_block_after (header);\n\t      *header_copy = *header;\n\t      bp = header_copy->buffer + BLOCKSIZE;\n\n\t      for (size -= BLOCKSIZE; size > 0; size -= written)\n\t\t{\n\t\t  data_block = find_next_block ();\n\t\t  if (! data_block)\n\t\t    {\n\t\t      ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t\t      break;\n\t\t    }\n\t\t  written = available_space_after (data_block);\n\t\t  if (written > size)\n\t\t    written = size;\n\n\t\t  memcpy (bp, data_block->buffer, written);\n\t\t  bp += written;\n\t\t  set_next_block_after ((union block *)\n\t\t\t\t\t(data_block->buffer + written - 1));\n\t\t}\n\n\t      *bp = '\\0';\n\t    }\n\t  else if (header->header.typeflag == XHDTYPE\n\t\t   || header->header.typeflag == SOLARIS_XHDTYPE)\n\t    xheader_read (&info->xhdr, header,\n\t\t\t  OFF_FROM_HEADER (header->header.size));\n\t  else if (header->header.typeflag == XGLTYPE)\n\t    {\n\t      struct xheader xhdr;\n\n\t      if (!recent_global_header)\n\t\trecent_global_header = xmalloc (sizeof *recent_global_header);\n\t      memcpy (recent_global_header, header,\n\t\t      sizeof *recent_global_header);\n\t      memset (&xhdr, 0, sizeof xhdr);\n\t      xheader_read (&xhdr, header,\n\t\t\t    OFF_FROM_HEADER (header->header.size));\n\t      xheader_decode_global (&xhdr);\n\t      xheader_destroy (&xhdr);\n\t      if (mode == read_header_x_global)\n\t\t{\n\t\t  status = HEADER_SUCCESS_EXTENDED;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* Loop!  */\n\n\t}\n      else\n\t{\n\t  char const *name;\n\t  struct posix_header const *h = &header->header;\n\t  char namebuf[sizeof h->prefix + 1 + NAME_FIELD_SIZE + 1];\n\n\t  free (recent_long_name);\n\n\t  if (next_long_name)\n\t    {\n\t      name = next_long_name->buffer + BLOCKSIZE;\n\t      recent_long_name = next_long_name;\n\t      recent_long_name_blocks = next_long_name_blocks;\n\t      next_long_name = NULL;\n\t    }\n\t  else\n\t    {\n\t      /* Accept file names as specified by POSIX.1-1996\n                 section 10.1.1.  */\n\t      char *np = namebuf;\n\n\t      if (h->prefix[0] && strcmp (h->magic, TMAGIC) == 0)\n\t\t{\n\t\t  memcpy (np, h->prefix, sizeof h->prefix);\n\t\t  np[sizeof h->prefix] = '\\0';\n\t\t  np += strlen (np);\n\t\t  *np++ = '/';\n\t\t}\n\t      memcpy (np, h->name, sizeof h->name);\n\t      np[sizeof h->name] = '\\0';\n\t      name = namebuf;\n\t      recent_long_name = 0;\n\t      recent_long_name_blocks = 0;\n\t    }\n\t  assign_string (&info->orig_file_name, name);\n\t  assign_string (&info->file_name, name);\n\t  info->had_trailing_slash = strip_trailing_slashes (info->file_name);\n\n\t  free (recent_long_link);\n\n\t  if (next_long_link)\n\t    {\n\t      name = next_long_link->buffer + BLOCKSIZE;\n\t      recent_long_link = next_long_link;\n\t      recent_long_link_blocks = next_long_link_blocks;\n\t      next_long_link = NULL;\n\t    }\n\t  else\n\t    {\n\t      memcpy (namebuf, h->linkname, sizeof h->linkname);\n\t      namebuf[sizeof h->linkname] = '\\0';\n\t      name = namebuf;\n\t      recent_long_link = 0;\n\t      recent_long_link_blocks = 0;\n\t    }\n\t  assign_string (&info->link_name, name);\n\n\t  break;\n\t}\n    }\n  free (next_long_name);\n  free (next_long_link);\n  return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,26 +3,27 @@\n \t     enum read_header_mode mode)\n {\n   union block *header;\n-  union block *header_copy;\n   char *bp;\n   union block *data_block;\n   size_t size, written;\n-  union block *next_long_name = 0;\n-  union block *next_long_link = 0;\n+  union block *next_long_name = NULL;\n+  union block *next_long_link = NULL;\n   size_t next_long_name_blocks = 0;\n   size_t next_long_link_blocks = 0;\n-\n+  enum read_header status = HEADER_SUCCESS;\n+  \n   while (1)\n     {\n-      enum read_header status;\n-\n       header = find_next_block ();\n       *return_block = header;\n       if (!header)\n-\treturn HEADER_END_OF_FILE;\n+\t{\n+\t  status = HEADER_END_OF_FILE;\n+\t  break;\n+\t}\n \n       if ((status = tar_checksum (header, false)) != HEADER_SUCCESS)\n-\treturn status;\n+\tbreak;\n \n       /* Good block.  Decode file size and return.  */\n \n@@ -32,7 +33,10 @@\n \t{\n \t  info->stat.st_size = OFF_FROM_HEADER (header->header.size);\n \t  if (info->stat.st_size < 0)\n-\t    return HEADER_FAILURE;\n+\t    {\n+\t      status = HEADER_FAILURE;\n+\t      break;\n+\t    }\n \t}\n \n       if (header->header.typeflag == GNUTYPE_LONGNAME\n@@ -42,10 +46,14 @@\n \t  || header->header.typeflag == SOLARIS_XHDTYPE)\n \t{\n \t  if (mode == read_header_x_raw)\n-\t    return HEADER_SUCCESS_EXTENDED;\n+\t    {\n+\t      status = HEADER_SUCCESS_EXTENDED;\n+\t      break;\n+\t    }\n \t  else if (header->header.typeflag == GNUTYPE_LONGNAME\n \t\t   || header->header.typeflag == GNUTYPE_LONGLINK)\n \t    {\n+\t      union block *header_copy;\n \t      size_t name_size = info->stat.st_size;\n \t      size_t n = name_size % BLOCKSIZE;\n \t      size = name_size + BLOCKSIZE;\n@@ -112,7 +120,10 @@\n \t      xheader_decode_global (&xhdr);\n \t      xheader_destroy (&xhdr);\n \t      if (mode == read_header_x_global)\n-\t\treturn HEADER_SUCCESS_EXTENDED;\n+\t\t{\n+\t\t  status = HEADER_SUCCESS_EXTENDED;\n+\t\t  break;\n+\t\t}\n \t    }\n \n \t  /* Loop!  */\n@@ -131,6 +142,7 @@\n \t      name = next_long_name->buffer + BLOCKSIZE;\n \t      recent_long_name = next_long_name;\n \t      recent_long_name_blocks = next_long_name_blocks;\n+\t      next_long_name = NULL;\n \t    }\n \t  else\n \t    {\n@@ -162,6 +174,7 @@\n \t      name = next_long_link->buffer + BLOCKSIZE;\n \t      recent_long_link = next_long_link;\n \t      recent_long_link_blocks = next_long_link_blocks;\n+\t      next_long_link = NULL;\n \t    }\n \t  else\n \t    {\n@@ -173,7 +186,10 @@\n \t    }\n \t  assign_string (&info->link_name, name);\n \n-\t  return HEADER_SUCCESS;\n+\t  break;\n \t}\n     }\n+  free (next_long_name);\n+  free (next_long_link);\n+  return status;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  union block *header_copy;",
                "  union block *next_long_name = 0;",
                "  union block *next_long_link = 0;",
                "",
                "      enum read_header status;",
                "",
                "\treturn HEADER_END_OF_FILE;",
                "\treturn status;",
                "\t    return HEADER_FAILURE;",
                "\t    return HEADER_SUCCESS_EXTENDED;",
                "\t\treturn HEADER_SUCCESS_EXTENDED;",
                "\t  return HEADER_SUCCESS;"
            ],
            "added_lines": [
                "  union block *next_long_name = NULL;",
                "  union block *next_long_link = NULL;",
                "  enum read_header status = HEADER_SUCCESS;",
                "  ",
                "\t{",
                "\t  status = HEADER_END_OF_FILE;",
                "\t  break;",
                "\t}",
                "\tbreak;",
                "\t    {",
                "\t      status = HEADER_FAILURE;",
                "\t      break;",
                "\t    }",
                "\t    {",
                "\t      status = HEADER_SUCCESS_EXTENDED;",
                "\t      break;",
                "\t    }",
                "\t      union block *header_copy;",
                "\t\t{",
                "\t\t  status = HEADER_SUCCESS_EXTENDED;",
                "\t\t  break;",
                "\t\t}",
                "\t      next_long_name = NULL;",
                "\t      next_long_link = NULL;",
                "\t  break;",
                "  free (next_long_name);",
                "  free (next_long_link);",
                "  return status;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29649",
        "func_name": "torvalds/linux/umd_cleanup",
        "description": "An issue was discovered in the Linux kernel before 5.11.11. The user mode driver (UMD) has a copy_process() memory leak, related to a lack of cleanup steps in kernel/usermode_driver.c and kernel/bpf/preload/bpf_preload_kern.c, aka CID-f60a85cad677.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f60a85cad677c4f9bb4cadd764f1d106c38c7cf8",
        "commit_title": "The syzbot reported a memleak as follows:",
        "commit_text": " BUG: memory leak unreferenced object 0xffff888101b41d00 (size 120):   comm \"kworker/u4:0\", pid 8, jiffies 4294944270 (age 12.780s)   backtrace:     [<ffffffff8125dc56>] alloc_pid+0x66/0x560     [<ffffffff81226405>] copy_process+0x1465/0x25e0     [<ffffffff81227943>] kernel_clone+0xf3/0x670     [<ffffffff812281a1>] kernel_thread+0x61/0x80     [<ffffffff81253464>] call_usermodehelper_exec_work     [<ffffffff81253464>] call_usermodehelper_exec_work+0xc4/0x120     [<ffffffff812591c9>] process_one_work+0x2c9/0x600     [<ffffffff81259ab9>] worker_thread+0x59/0x5d0     [<ffffffff812611c8>] kthread+0x178/0x1b0     [<ffffffff8100227f>] ret_from_fork+0x1f/0x30  unreferenced object 0xffff888110ef5c00 (size 232):   comm \"kworker/u4:0\", pid 8414, jiffies 4294944270 (age 12.780s)   backtrace:     [<ffffffff8154a0cf>] kmem_cache_zalloc     [<ffffffff8154a0cf>] __alloc_file+0x1f/0xf0     [<ffffffff8154a809>] alloc_empty_file+0x69/0x120     [<ffffffff8154a8f3>] alloc_file+0x33/0x1b0     [<ffffffff8154ab22>] alloc_file_pseudo+0xb2/0x140     [<ffffffff81559218>] create_pipe_files+0x138/0x2e0     [<ffffffff8126c793>] umd_setup+0x33/0x220     [<ffffffff81253574>] call_usermodehelper_exec_async+0xb4/0x1b0     [<ffffffff8100227f>] ret_from_fork+0x1f/0x30  After the UMD process exits, the pipe_to_umh/pipe_from_umh and tgid need to be released.  Link: https://lore.kernel.org/bpf/20210317030915.2865-1-qiang.zhang@windriver.com ",
        "func_before": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t/* cleanup if umh_setup() was successful but exec failed */\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}",
        "func": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t/* cleanup if umh_setup() was successful but exec failed */\n\tif (info->retval)\n\t\tumd_cleanup_helper(umd_info);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,6 @@\n \tstruct umd_info *umd_info = info->data;\n \n \t/* cleanup if umh_setup() was successful but exec failed */\n-\tif (info->retval) {\n-\t\tfput(umd_info->pipe_to_umh);\n-\t\tfput(umd_info->pipe_from_umh);\n-\t\tput_pid(umd_info->tgid);\n-\t\tumd_info->tgid = NULL;\n-\t}\n+\tif (info->retval)\n+\t\tumd_cleanup_helper(umd_info);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (info->retval) {",
                "\t\tfput(umd_info->pipe_to_umh);",
                "\t\tfput(umd_info->pipe_from_umh);",
                "\t\tput_pid(umd_info->tgid);",
                "\t\tumd_info->tgid = NULL;",
                "\t}"
            ],
            "added_lines": [
                "\tif (info->retval)",
                "\t\tumd_cleanup_helper(umd_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29649",
        "func_name": "torvalds/linux/finish",
        "description": "An issue was discovered in the Linux kernel before 5.11.11. The user mode driver (UMD) has a copy_process() memory leak, related to a lack of cleanup steps in kernel/usermode_driver.c and kernel/bpf/preload/bpf_preload_kern.c, aka CID-f60a85cad677.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f60a85cad677c4f9bb4cadd764f1d106c38c7cf8",
        "commit_title": "The syzbot reported a memleak as follows:",
        "commit_text": " BUG: memory leak unreferenced object 0xffff888101b41d00 (size 120):   comm \"kworker/u4:0\", pid 8, jiffies 4294944270 (age 12.780s)   backtrace:     [<ffffffff8125dc56>] alloc_pid+0x66/0x560     [<ffffffff81226405>] copy_process+0x1465/0x25e0     [<ffffffff81227943>] kernel_clone+0xf3/0x670     [<ffffffff812281a1>] kernel_thread+0x61/0x80     [<ffffffff81253464>] call_usermodehelper_exec_work     [<ffffffff81253464>] call_usermodehelper_exec_work+0xc4/0x120     [<ffffffff812591c9>] process_one_work+0x2c9/0x600     [<ffffffff81259ab9>] worker_thread+0x59/0x5d0     [<ffffffff812611c8>] kthread+0x178/0x1b0     [<ffffffff8100227f>] ret_from_fork+0x1f/0x30  unreferenced object 0xffff888110ef5c00 (size 232):   comm \"kworker/u4:0\", pid 8414, jiffies 4294944270 (age 12.780s)   backtrace:     [<ffffffff8154a0cf>] kmem_cache_zalloc     [<ffffffff8154a0cf>] __alloc_file+0x1f/0xf0     [<ffffffff8154a809>] alloc_empty_file+0x69/0x120     [<ffffffff8154a8f3>] alloc_file+0x33/0x1b0     [<ffffffff8154ab22>] alloc_file_pseudo+0xb2/0x140     [<ffffffff81559218>] create_pipe_files+0x138/0x2e0     [<ffffffff8126c793>] umd_setup+0x33/0x220     [<ffffffff81253574>] call_usermodehelper_exec_async+0xb4/0x1b0     [<ffffffff8100227f>] ret_from_fork+0x1f/0x30  After the UMD process exits, the pipe_to_umh/pipe_from_umh and tgid need to be released.  Link: https://lore.kernel.org/bpf/20210317030915.2865-1-qiang.zhang@windriver.com ",
        "func_before": "static int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\ttgid = umd_ops.info.tgid;\n\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\tumd_ops.info.tgid = NULL;\n\treturn 0;\n}",
        "func": "static int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,11 @@\n \t\t\t &magic, sizeof(magic), &pos);\n \tif (n != sizeof(magic))\n \t\treturn -EPIPE;\n+\n \ttgid = umd_ops.info.tgid;\n-\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n-\tumd_ops.info.tgid = NULL;\n+\tif (tgid) {\n+\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n+\t\tumd_cleanup_helper(&umd_ops.info);\n+\t}\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));",
                "\tumd_ops.info.tgid = NULL;"
            ],
            "added_lines": [
                "",
                "\tif (tgid) {",
                "\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));",
                "\t\tumd_cleanup_helper(&umd_ops.info);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29649",
        "func_name": "torvalds/linux/fini_umd",
        "description": "An issue was discovered in the Linux kernel before 5.11.11. The user mode driver (UMD) has a copy_process() memory leak, related to a lack of cleanup steps in kernel/usermode_driver.c and kernel/bpf/preload/bpf_preload_kern.c, aka CID-f60a85cad677.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f60a85cad677c4f9bb4cadd764f1d106c38c7cf8",
        "commit_title": "The syzbot reported a memleak as follows:",
        "commit_text": " BUG: memory leak unreferenced object 0xffff888101b41d00 (size 120):   comm \"kworker/u4:0\", pid 8, jiffies 4294944270 (age 12.780s)   backtrace:     [<ffffffff8125dc56>] alloc_pid+0x66/0x560     [<ffffffff81226405>] copy_process+0x1465/0x25e0     [<ffffffff81227943>] kernel_clone+0xf3/0x670     [<ffffffff812281a1>] kernel_thread+0x61/0x80     [<ffffffff81253464>] call_usermodehelper_exec_work     [<ffffffff81253464>] call_usermodehelper_exec_work+0xc4/0x120     [<ffffffff812591c9>] process_one_work+0x2c9/0x600     [<ffffffff81259ab9>] worker_thread+0x59/0x5d0     [<ffffffff812611c8>] kthread+0x178/0x1b0     [<ffffffff8100227f>] ret_from_fork+0x1f/0x30  unreferenced object 0xffff888110ef5c00 (size 232):   comm \"kworker/u4:0\", pid 8414, jiffies 4294944270 (age 12.780s)   backtrace:     [<ffffffff8154a0cf>] kmem_cache_zalloc     [<ffffffff8154a0cf>] __alloc_file+0x1f/0xf0     [<ffffffff8154a809>] alloc_empty_file+0x69/0x120     [<ffffffff8154a8f3>] alloc_file+0x33/0x1b0     [<ffffffff8154ab22>] alloc_file_pseudo+0xb2/0x140     [<ffffffff81559218>] create_pipe_files+0x138/0x2e0     [<ffffffff8126c793>] umd_setup+0x33/0x220     [<ffffffff81253574>] call_usermodehelper_exec_async+0xb4/0x1b0     [<ffffffff8100227f>] ret_from_fork+0x1f/0x30  After the UMD process exits, the pipe_to_umh/pipe_from_umh and tgid need to be released.  Link: https://lore.kernel.org/bpf/20210317030915.2865-1-qiang.zhang@windriver.com ",
        "func_before": "static void __exit fini_umd(void)\n{\n\tbpf_preload_ops = NULL;\n\t/* kill UMD in case it's still there due to earlier error */\n\tkill_pid(umd_ops.info.tgid, SIGKILL, 1);\n\tumd_ops.info.tgid = NULL;\n\tumd_unload_blob(&umd_ops.info);\n}",
        "func": "static void __exit fini_umd(void)\n{\n\tstruct pid *tgid;\n\n\tbpf_preload_ops = NULL;\n\n\t/* kill UMD in case it's still there due to earlier error */\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\tkill_pid(tgid, SIGKILL, 1);\n\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\tumd_unload_blob(&umd_ops.info);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,16 @@\n static void __exit fini_umd(void)\n {\n+\tstruct pid *tgid;\n+\n \tbpf_preload_ops = NULL;\n+\n \t/* kill UMD in case it's still there due to earlier error */\n-\tkill_pid(umd_ops.info.tgid, SIGKILL, 1);\n-\tumd_ops.info.tgid = NULL;\n+\ttgid = umd_ops.info.tgid;\n+\tif (tgid) {\n+\t\tkill_pid(tgid, SIGKILL, 1);\n+\n+\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n+\t\tumd_cleanup_helper(&umd_ops.info);\n+\t}\n \tumd_unload_blob(&umd_ops.info);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tkill_pid(umd_ops.info.tgid, SIGKILL, 1);",
                "\tumd_ops.info.tgid = NULL;"
            ],
            "added_lines": [
                "\tstruct pid *tgid;",
                "",
                "",
                "\ttgid = umd_ops.info.tgid;",
                "\tif (tgid) {",
                "\t\tkill_pid(tgid, SIGKILL, 1);",
                "",
                "\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));",
                "\t\tumd_cleanup_helper(&umd_ops.info);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-30002",
        "func_name": "torvalds/linux/video_usercopy",
        "description": "An issue was discovered in the Linux kernel before 5.11.3 when a webcam device exists. video_usercopy in drivers/media/v4l2-core/v4l2-ioctl.c has a memory leak for large arguments, aka CID-fb18802a338b.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=fb18802a338b36f675a388fc03d2aa504a0d0899",
        "commit_title": "When an IOCTL with argument size larger than 128 that also used array",
        "commit_text": "arguments were handled, two memory allocations were made but alas, only the latter one of them was released. This happened because there was only a single local variable to hold such a temporary allocation.  Fix this by adding separate variables to hold the pointers to the temporary allocations.  Cc: stable@vger.kernel.org ",
        "func_before": "long\nvideo_usercopy(struct file *file, unsigned int orig_cmd, unsigned long arg,\n\t       v4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tbool\talways_copy = false;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\tunsigned int cmd = video_translate_cmd(orig_cmd);\n\tconst size_t ioc_size = _IOC_SIZE(cmd);\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (ioc_size <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kvmalloc(ioc_size, GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = video_get_user((void __user *)arg, parg, cmd,\n\t\t\t\t     orig_cmd, &always_copy);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\t/*\n\t\t * When adding new types of array args, make sure that the\n\t\t * parent argument to ioctl (which contains the pointer to the\n\t\t * array) fits into sbuf (so that mbuf will still remain\n\t\t * unused up to here).\n\t\t */\n\t\tmbuf = kvmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (in_compat_syscall())\n\t\t\terr = v4l2_compat_get_array_args(file, mbuf, user_ptr,\n\t\t\t\t\t\t\t array_size, orig_cmd,\n\t\t\t\t\t\t\t parg);\n\t\telse\n\t\t\terr = copy_from_user(mbuf, user_ptr, array_size) ?\n\t\t\t\t\t\t\t\t-EFAULT : 0;\n\t\tif (err)\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\n\t/* Handles IOCTL */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOTTY || err == -ENOIOCTLCMD) {\n\t\terr = -ENOTTY;\n\t\tgoto out;\n\t}\n\n\tif (err == 0) {\n\t\tif (cmd == VIDIOC_DQBUF)\n\t\t\ttrace_v4l2_dqbuf(video_devdata(file)->minor, parg);\n\t\telse if (cmd == VIDIOC_QBUF)\n\t\t\ttrace_v4l2_qbuf(video_devdata(file)->minor, parg);\n\t}\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = (void __force *)user_ptr;\n\t\tif (in_compat_syscall()) {\n\t\t\tint put_err;\n\n\t\t\tput_err = v4l2_compat_put_array_args(file, user_ptr, mbuf,\n\t\t\t\t\t\t\t     array_size, orig_cmd,\n\t\t\t\t\t\t\t     parg);\n\t\t\tif (put_err)\n\t\t\t\terr = put_err;\n\t\t} else if (copy_to_user(user_ptr, mbuf, array_size)) {\n\t\t\terr = -EFAULT;\n\t\t}\n\t\tgoto out_array_args;\n\t}\n\t/*\n\t * Some ioctls can return an error, but still have valid\n\t * results that must be returned.\n\t */\n\tif (err < 0 && !always_copy)\n\t\tgoto out;\n\nout_array_args:\n\tif (video_put_user((void __user *)arg, parg, cmd, orig_cmd))\n\t\terr = -EFAULT;\nout:\n\tkvfree(mbuf);\n\treturn err;\n}",
        "func": "long\nvideo_usercopy(struct file *file, unsigned int orig_cmd, unsigned long arg,\n\t       v4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL, *array_buf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tbool\talways_copy = false;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\tunsigned int cmd = video_translate_cmd(orig_cmd);\n\tconst size_t ioc_size = _IOC_SIZE(cmd);\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (ioc_size <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kvmalloc(ioc_size, GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = video_get_user((void __user *)arg, parg, cmd,\n\t\t\t\t     orig_cmd, &always_copy);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\tarray_buf = kvmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (array_buf == NULL)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (in_compat_syscall())\n\t\t\terr = v4l2_compat_get_array_args(file, array_buf,\n\t\t\t\t\t\t\t user_ptr, array_size,\n\t\t\t\t\t\t\t orig_cmd, parg);\n\t\telse\n\t\t\terr = copy_from_user(array_buf, user_ptr, array_size) ?\n\t\t\t\t\t\t\t\t-EFAULT : 0;\n\t\tif (err)\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = array_buf;\n\t}\n\n\t/* Handles IOCTL */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOTTY || err == -ENOIOCTLCMD) {\n\t\terr = -ENOTTY;\n\t\tgoto out;\n\t}\n\n\tif (err == 0) {\n\t\tif (cmd == VIDIOC_DQBUF)\n\t\t\ttrace_v4l2_dqbuf(video_devdata(file)->minor, parg);\n\t\telse if (cmd == VIDIOC_QBUF)\n\t\t\ttrace_v4l2_qbuf(video_devdata(file)->minor, parg);\n\t}\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = (void __force *)user_ptr;\n\t\tif (in_compat_syscall()) {\n\t\t\tint put_err;\n\n\t\t\tput_err = v4l2_compat_put_array_args(file, user_ptr,\n\t\t\t\t\t\t\t     array_buf,\n\t\t\t\t\t\t\t     array_size,\n\t\t\t\t\t\t\t     orig_cmd, parg);\n\t\t\tif (put_err)\n\t\t\t\terr = put_err;\n\t\t} else if (copy_to_user(user_ptr, array_buf, array_size)) {\n\t\t\terr = -EFAULT;\n\t\t}\n\t\tgoto out_array_args;\n\t}\n\t/*\n\t * Some ioctls can return an error, but still have valid\n\t * results that must be returned.\n\t */\n\tif (err < 0 && !always_copy)\n\t\tgoto out;\n\nout_array_args:\n\tif (video_put_user((void __user *)arg, parg, cmd, orig_cmd))\n\t\terr = -EFAULT;\nout:\n\tkvfree(array_buf);\n\tkvfree(mbuf);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \t       v4l2_kioctl func)\n {\n \tchar\tsbuf[128];\n-\tvoid    *mbuf = NULL;\n+\tvoid    *mbuf = NULL, *array_buf = NULL;\n \tvoid\t*parg = (void *)arg;\n \tlong\terr  = -EINVAL;\n \tbool\thas_array_args;\n@@ -38,27 +38,21 @@\n \thas_array_args = err;\n \n \tif (has_array_args) {\n-\t\t/*\n-\t\t * When adding new types of array args, make sure that the\n-\t\t * parent argument to ioctl (which contains the pointer to the\n-\t\t * array) fits into sbuf (so that mbuf will still remain\n-\t\t * unused up to here).\n-\t\t */\n-\t\tmbuf = kvmalloc(array_size, GFP_KERNEL);\n+\t\tarray_buf = kvmalloc(array_size, GFP_KERNEL);\n \t\terr = -ENOMEM;\n-\t\tif (NULL == mbuf)\n+\t\tif (array_buf == NULL)\n \t\t\tgoto out_array_args;\n \t\terr = -EFAULT;\n \t\tif (in_compat_syscall())\n-\t\t\terr = v4l2_compat_get_array_args(file, mbuf, user_ptr,\n-\t\t\t\t\t\t\t array_size, orig_cmd,\n-\t\t\t\t\t\t\t parg);\n+\t\t\terr = v4l2_compat_get_array_args(file, array_buf,\n+\t\t\t\t\t\t\t user_ptr, array_size,\n+\t\t\t\t\t\t\t orig_cmd, parg);\n \t\telse\n-\t\t\terr = copy_from_user(mbuf, user_ptr, array_size) ?\n+\t\t\terr = copy_from_user(array_buf, user_ptr, array_size) ?\n \t\t\t\t\t\t\t\t-EFAULT : 0;\n \t\tif (err)\n \t\t\tgoto out_array_args;\n-\t\t*kernel_ptr = mbuf;\n+\t\t*kernel_ptr = array_buf;\n \t}\n \n \t/* Handles IOCTL */\n@@ -80,12 +74,13 @@\n \t\tif (in_compat_syscall()) {\n \t\t\tint put_err;\n \n-\t\t\tput_err = v4l2_compat_put_array_args(file, user_ptr, mbuf,\n-\t\t\t\t\t\t\t     array_size, orig_cmd,\n-\t\t\t\t\t\t\t     parg);\n+\t\t\tput_err = v4l2_compat_put_array_args(file, user_ptr,\n+\t\t\t\t\t\t\t     array_buf,\n+\t\t\t\t\t\t\t     array_size,\n+\t\t\t\t\t\t\t     orig_cmd, parg);\n \t\t\tif (put_err)\n \t\t\t\terr = put_err;\n-\t\t} else if (copy_to_user(user_ptr, mbuf, array_size)) {\n+\t\t} else if (copy_to_user(user_ptr, array_buf, array_size)) {\n \t\t\terr = -EFAULT;\n \t\t}\n \t\tgoto out_array_args;\n@@ -101,6 +96,7 @@\n \tif (video_put_user((void __user *)arg, parg, cmd, orig_cmd))\n \t\terr = -EFAULT;\n out:\n+\tkvfree(array_buf);\n \tkvfree(mbuf);\n \treturn err;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tvoid    *mbuf = NULL;",
                "\t\t/*",
                "\t\t * When adding new types of array args, make sure that the",
                "\t\t * parent argument to ioctl (which contains the pointer to the",
                "\t\t * array) fits into sbuf (so that mbuf will still remain",
                "\t\t * unused up to here).",
                "\t\t */",
                "\t\tmbuf = kvmalloc(array_size, GFP_KERNEL);",
                "\t\tif (NULL == mbuf)",
                "\t\t\terr = v4l2_compat_get_array_args(file, mbuf, user_ptr,",
                "\t\t\t\t\t\t\t array_size, orig_cmd,",
                "\t\t\t\t\t\t\t parg);",
                "\t\t\terr = copy_from_user(mbuf, user_ptr, array_size) ?",
                "\t\t*kernel_ptr = mbuf;",
                "\t\t\tput_err = v4l2_compat_put_array_args(file, user_ptr, mbuf,",
                "\t\t\t\t\t\t\t     array_size, orig_cmd,",
                "\t\t\t\t\t\t\t     parg);",
                "\t\t} else if (copy_to_user(user_ptr, mbuf, array_size)) {"
            ],
            "added_lines": [
                "\tvoid    *mbuf = NULL, *array_buf = NULL;",
                "\t\tarray_buf = kvmalloc(array_size, GFP_KERNEL);",
                "\t\tif (array_buf == NULL)",
                "\t\t\terr = v4l2_compat_get_array_args(file, array_buf,",
                "\t\t\t\t\t\t\t user_ptr, array_size,",
                "\t\t\t\t\t\t\t orig_cmd, parg);",
                "\t\t\terr = copy_from_user(array_buf, user_ptr, array_size) ?",
                "\t\t*kernel_ptr = array_buf;",
                "\t\t\tput_err = v4l2_compat_put_array_args(file, user_ptr,",
                "\t\t\t\t\t\t\t     array_buf,",
                "\t\t\t\t\t\t\t     array_size,",
                "\t\t\t\t\t\t\t     orig_cmd, parg);",
                "\t\t} else if (copy_to_user(user_ptr, array_buf, array_size)) {",
                "\tkvfree(array_buf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36312",
        "func_name": "torvalds/linux/kvm_io_bus_unregister_dev",
        "description": "An issue was discovered in the Linux kernel before 5.8.10. virt/kvm/kvm_main.c has a kvm_io_bus_unregister_dev memory leak upon a kmalloc failure, aka CID-f65886606c2d.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=f65886606c2d3b562716de030706dfe1bea4ed5e",
        "commit_title": "when kmalloc() fails in kvm_io_bus_unregister_dev(), before removing",
        "commit_text": "the bus, we should iterate over all other devices linked to it and call kvm_iodevice_destructor() for them  Cc: stable@vger.kernel.org Reported-and-tested-by: syzbot+f196caa45793d6374707@syzkaller.appspotmail.com Link: https://syzkaller.appspot.com/bug?extid=f196caa45793d6374707 Message-Id: <20200907185535.233114-1-rkovhaev@gmail.com> ",
        "func_before": "void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t       struct kvm_io_device *dev)\n{\n\tint i;\n\tstruct kvm_io_bus *new_bus, *bus;\n\n\tbus = kvm_get_bus(kvm, bus_idx);\n\tif (!bus)\n\t\treturn;\n\n\tfor (i = 0; i < bus->dev_count; i++)\n\t\tif (bus->range[i].dev == dev) {\n\t\t\tbreak;\n\t\t}\n\n\tif (i == bus->dev_count)\n\t\treturn;\n\n\tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (!new_bus)  {\n\t\tpr_err(\"kvm: failed to shrink bus, removing it completely\\n\");\n\t\tgoto broken;\n\t}\n\n\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n\tnew_bus->dev_count--;\n\tmemcpy(new_bus->range + i, bus->range + i + 1,\n\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));\n\nbroken:\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\treturn;\n}",
        "func": "void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t       struct kvm_io_device *dev)\n{\n\tint i, j;\n\tstruct kvm_io_bus *new_bus, *bus;\n\n\tbus = kvm_get_bus(kvm, bus_idx);\n\tif (!bus)\n\t\treturn;\n\n\tfor (i = 0; i < bus->dev_count; i++)\n\t\tif (bus->range[i].dev == dev) {\n\t\t\tbreak;\n\t\t}\n\n\tif (i == bus->dev_count)\n\t\treturn;\n\n\tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (new_bus) {\n\t\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n\t\tnew_bus->dev_count--;\n\t\tmemcpy(new_bus->range + i, bus->range + i + 1,\n\t\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));\n\t} else {\n\t\tpr_err(\"kvm: failed to shrink bus, removing it completely\\n\");\n\t\tfor (j = 0; j < bus->dev_count; j++) {\n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\t\t\tkvm_iodevice_destructor(bus->range[j].dev);\n\t\t}\n\t}\n\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n \t\t\t       struct kvm_io_device *dev)\n {\n-\tint i;\n+\tint i, j;\n \tstruct kvm_io_bus *new_bus, *bus;\n \n \tbus = kvm_get_bus(kvm, bus_idx);\n@@ -18,17 +18,20 @@\n \n \tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),\n \t\t\t  GFP_KERNEL_ACCOUNT);\n-\tif (!new_bus)  {\n+\tif (new_bus) {\n+\t\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n+\t\tnew_bus->dev_count--;\n+\t\tmemcpy(new_bus->range + i, bus->range + i + 1,\n+\t\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));\n+\t} else {\n \t\tpr_err(\"kvm: failed to shrink bus, removing it completely\\n\");\n-\t\tgoto broken;\n+\t\tfor (j = 0; j < bus->dev_count; j++) {\n+\t\t\tif (j == i)\n+\t\t\t\tcontinue;\n+\t\t\tkvm_iodevice_destructor(bus->range[j].dev);\n+\t\t}\n \t}\n \n-\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n-\tnew_bus->dev_count--;\n-\tmemcpy(new_bus->range + i, bus->range + i + 1,\n-\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));\n-\n-broken:\n \trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n \tsynchronize_srcu_expedited(&kvm->srcu);\n \tkfree(bus);",
        "diff_line_info": {
            "deleted_lines": [
                "\tint i;",
                "\tif (!new_bus)  {",
                "\t\tgoto broken;",
                "\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));",
                "\tnew_bus->dev_count--;",
                "\tmemcpy(new_bus->range + i, bus->range + i + 1,",
                "\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));",
                "",
                "broken:"
            ],
            "added_lines": [
                "\tint i, j;",
                "\tif (new_bus) {",
                "\t\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));",
                "\t\tnew_bus->dev_count--;",
                "\t\tmemcpy(new_bus->range + i, bus->range + i + 1,",
                "\t\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));",
                "\t} else {",
                "\t\tfor (j = 0; j < bus->dev_count; j++) {",
                "\t\t\tif (j == i)",
                "\t\t\t\tcontinue;",
                "\t\t\tkvm_iodevice_destructor(bus->range[j].dev);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-31256",
        "func_name": "gpac/stbl_GetSampleInfos",
        "description": "Memory leak in the stbl_GetSampleInfos function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.",
        "git_url": "https://github.com/gpac/gpac/commit/2da2f68bffd51d89b1d272d22aa8cc023c1c066e",
        "commit_title": "fixed #1705",
        "commit_text": "",
        "func_before": "GF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **out_ent)\n{\n\tGF_Err e;\n\tu32 i, k, offsetInChunk, size, chunk_num;\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\n\t(*offset) = 0;\n\t(*chunkNumber) = (*descIndex) = 0;\n\tif (out_ent) (*out_ent) = NULL;\n\tif (!stbl || !sampleNumber) return GF_BAD_PARAM;\n\tif (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;\n\n\tif (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {\n\t\tent = &stbl->SampleToChunk->entries[sampleNumber-1];\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\t(*descIndex) = ent->sampleDescriptionIndex;\n\t\t(*chunkNumber) = sampleNumber;\n\t\tif (out_ent) *out_ent = ent;\n\t\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!stco->offsets) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = (u64) stco->offsets[sampleNumber - 1];\n\t\t} else {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!co64->offsets) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = co64->offsets[sampleNumber - 1];\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//check our cache: if desired sample is at or above current cache entry, start from here\n\tif (stbl->SampleToChunk->firstSampleInCurrentChunk &&\n\t        (stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {\n\n\t\ti = stbl->SampleToChunk->currentIndex;\n\t\tent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];\n\t\tGetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\t//otherwise start from first entry\n\telse {\n\t\ti = 0;\n\t\tstbl->SampleToChunk->currentIndex = 0;\n\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = 1;\n\t\tent = &stbl->SampleToChunk->entries[0];\n\t\tGetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\n\t//first get the chunk\n\tfor (; i < stbl->SampleToChunk->nb_entries; i++) {\n\t\tassert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);\n\t\t//corrupted file (less sample2chunk info than sample count\n\t\tif (k > stbl->SampleToChunk->ghostNumber) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\n\t\t//check if sample is in current chunk\n\t\tu32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;\n\t\tu32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\tif (ent->samplesPerChunk) \n\t\t\tnb_chunks_for_sample /= ent->samplesPerChunk;\n\n\t\tif (\n\t\t\t(nb_chunks_for_sample <= max_chunks_in_entry)\n\t\t\t&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)\n\t\t) {\n\n\t\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;\n\t\t\tstbl->SampleToChunk->currentChunk += nb_chunks_for_sample;\n\t\t\tgoto sample_found;\n\t\t}\n\t\tmax_chunks_in_entry += 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;\n\t\tstbl->SampleToChunk->currentChunk += max_chunks_in_entry;\n\n\t\t//not in this entry, get the next entry if not the last one\n\t\tif (i+1 != stbl->SampleToChunk->nb_entries) {\n\t\t\tent = &stbl->SampleToChunk->entries[i+1];\n\t\t\t//update the GhostNumber\n\t\t\tGetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);\n\t\t\t//update the entry in our cache\n\t\t\tstbl->SampleToChunk->currentIndex = i+1;\n\t\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\t\tk = 1;\n\t\t}\n\t}\n\t//if we get here, gasp, the sample was not found\n\treturn GF_ISOM_INVALID_FILE;\n\nsample_found:\n\n\t(*descIndex) = ent->sampleDescriptionIndex;\n\t(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;\n\tif (out_ent) *out_ent = ent;\n\tif (! *chunkNumber)\n\t\treturn GF_ISOM_INVALID_FILE;\n\t\n\t//ok, get the size of all the previous samples in the chunk\n\toffsetInChunk = 0;\n\t//constant size\n\tif (stbl->SampleSize && stbl->SampleSize->sampleSize) {\n\t\tu32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\toffsetInChunk += diff * stbl->SampleSize->sampleSize;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {\n\t\te = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);\n\t\tif (e) return e;\n\t\tstbl->r_last_offset_in_chunk += size;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else {\n\t\t//warning, firstSampleInChunk is at least 1 - not 0\n\t\tfor (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {\n\t\t\te = stbl_GetSampleSize(stbl->SampleSize, i, &size);\n\t\t\tif (e) return e;\n\t\t\toffsetInChunk += size;\n\t\t}\n\t\tstbl->r_last_chunk_num = chunk_num;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\tstbl->r_last_offset_in_chunk = offsetInChunk;\n\t}\n\t//OK, that's the size of our offset in the chunk\n\t//now get the chunk\n\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\tif (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t} else {\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t}\n\treturn GF_OK;\n}",
        "func": "GF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **out_ent)\n{\n\tGF_Err e;\n\tu32 i, k, offsetInChunk, size, chunk_num;\n\tGF_ChunkOffsetBox *stco;\n\tGF_ChunkLargeOffsetBox *co64;\n\tGF_StscEntry *ent;\n\n\t(*offset) = 0;\n\t(*chunkNumber) = (*descIndex) = 0;\n\tif (out_ent) (*out_ent) = NULL;\n\tif (!stbl || !sampleNumber) return GF_BAD_PARAM;\n\tif (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;\n\n\tif (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {\n\t\tent = &stbl->SampleToChunk->entries[sampleNumber-1];\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\t(*descIndex) = ent->sampleDescriptionIndex;\n\t\t(*chunkNumber) = sampleNumber;\n\t\tif (out_ent) *out_ent = ent;\n\t\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!stco->offsets) return GF_ISOM_INVALID_FILE;\n\t\t\tif (stco->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = (u64) stco->offsets[sampleNumber - 1];\n\t\t} else {\n\t\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\t\tif (!co64->offsets) return GF_ISOM_INVALID_FILE;\n\t\t\tif (co64->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n\n\t\t\t(*offset) = co64->offsets[sampleNumber - 1];\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//check our cache: if desired sample is at or above current cache entry, start from here\n\tif (stbl->SampleToChunk->firstSampleInCurrentChunk &&\n\t        (stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {\n\n\t\ti = stbl->SampleToChunk->currentIndex;\n\t\tent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];\n\t\tGetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\t//otherwise start from first entry\n\telse {\n\t\ti = 0;\n\t\tstbl->SampleToChunk->currentIndex = 0;\n\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\tstbl->SampleToChunk->ghostNumber = 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk = 1;\n\t\tent = &stbl->SampleToChunk->entries[0];\n\t\tGetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);\n\t\tk = stbl->SampleToChunk->currentChunk;\n\t}\n\n\t//first get the chunk\n\tfor (; i < stbl->SampleToChunk->nb_entries; i++) {\n\t\tassert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);\n\t\t//corrupted file (less sample2chunk info than sample count\n\t\tif (k > stbl->SampleToChunk->ghostNumber) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\n\t\t//check if sample is in current chunk\n\t\tu32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;\n\t\tu32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\tif (ent->samplesPerChunk) \n\t\t\tnb_chunks_for_sample /= ent->samplesPerChunk;\n\n\t\tif (\n\t\t\t(nb_chunks_for_sample <= max_chunks_in_entry)\n\t\t\t&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)\n\t\t) {\n\n\t\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;\n\t\t\tstbl->SampleToChunk->currentChunk += nb_chunks_for_sample;\n\t\t\tgoto sample_found;\n\t\t}\n\t\tmax_chunks_in_entry += 1;\n\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;\n\t\tstbl->SampleToChunk->currentChunk += max_chunks_in_entry;\n\n\t\t//not in this entry, get the next entry if not the last one\n\t\tif (i+1 != stbl->SampleToChunk->nb_entries) {\n\t\t\tent = &stbl->SampleToChunk->entries[i+1];\n\t\t\t//update the GhostNumber\n\t\t\tGetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);\n\t\t\t//update the entry in our cache\n\t\t\tstbl->SampleToChunk->currentIndex = i+1;\n\t\t\tstbl->SampleToChunk->currentChunk = 1;\n\t\t\tk = 1;\n\t\t}\n\t}\n\t//if we get here, gasp, the sample was not found\n\treturn GF_ISOM_INVALID_FILE;\n\nsample_found:\n\n\t(*descIndex) = ent->sampleDescriptionIndex;\n\t(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;\n\tif (out_ent) *out_ent = ent;\n\tif (! *chunkNumber)\n\t\treturn GF_ISOM_INVALID_FILE;\n\t\n\t//ok, get the size of all the previous samples in the chunk\n\toffsetInChunk = 0;\n\t//constant size\n\tif (stbl->SampleSize && stbl->SampleSize->sampleSize) {\n\t\tu32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n\t\toffsetInChunk += diff * stbl->SampleSize->sampleSize;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {\n\t\te = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);\n\t\tif (e) return e;\n\t\tstbl->r_last_offset_in_chunk += size;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n\t} else {\n\t\t//warning, firstSampleInChunk is at least 1 - not 0\n\t\tfor (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {\n\t\t\te = stbl_GetSampleSize(stbl->SampleSize, i, &size);\n\t\t\tif (e) return e;\n\t\t\toffsetInChunk += size;\n\t\t}\n\t\tstbl->r_last_chunk_num = chunk_num;\n\t\tstbl->r_last_sample_num = sampleNumber;\n\t\tstbl->r_last_offset_in_chunk = offsetInChunk;\n\t}\n\t//OK, that's the size of our offset in the chunk\n\t//now get the chunk\n\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n\t\tif (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t} else {\n\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n\t\tif (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n\t\t(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n\t}\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,11 +21,13 @@\n \t\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n \t\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n \t\t\tif (!stco->offsets) return GF_ISOM_INVALID_FILE;\n+\t\t\tif (stco->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n \n \t\t\t(*offset) = (u64) stco->offsets[sampleNumber - 1];\n \t\t} else {\n \t\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n \t\t\tif (!co64->offsets) return GF_ISOM_INVALID_FILE;\n+\t\t\tif (co64->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n \n \t\t\t(*offset) = co64->offsets[sampleNumber - 1];\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif (stco->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;",
                "\t\t\tif (co64->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-39978",
        "func_name": "ImageMagick/ImageMagick6/CloneDrawInfo",
        "description": "ImageMagick before 6.9.12-91 allows attackers to cause a denial of service (memory consumption) in Magick::Draw.",
        "git_url": "https://github.com/ImageMagick/ImageMagick6/commit/c90e79b3b22fec309cab55af2ee606f71b027b12",
        "commit_title": "Fixed memory leak.",
        "commit_text": "",
        "func_before": "MagickExport DrawInfo *CloneDrawInfo(const ImageInfo *image_info,\n  const DrawInfo *draw_info)\n{\n  DrawInfo\n    *clone_info;\n\n  clone_info=(DrawInfo *) AcquireCriticalMemory(sizeof(*clone_info));\n  GetDrawInfo(image_info,clone_info);\n  if (draw_info == (DrawInfo *) NULL)\n    return(clone_info);\n  if (draw_info->id != (char *) NULL)\n    (void) CloneString(&clone_info->id,draw_info->id);\n  if (draw_info->primitive != (char *) NULL)\n    (void) CloneString(&clone_info->primitive,draw_info->primitive);\n  if (draw_info->geometry != (char *) NULL)\n    (void) CloneString(&clone_info->geometry,draw_info->geometry);\n  clone_info->compliance=draw_info->compliance;\n  clone_info->viewbox=draw_info->viewbox;\n  clone_info->affine=draw_info->affine;\n  clone_info->gravity=draw_info->gravity;\n  clone_info->fill=draw_info->fill;\n  clone_info->stroke=draw_info->stroke;\n  clone_info->stroke_width=draw_info->stroke_width;\n  if (draw_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(draw_info->fill_pattern,0,0,MagickTrue,\n      &draw_info->fill_pattern->exception);\n  else\n    if (draw_info->tile != (Image *) NULL)\n      clone_info->fill_pattern=CloneImage(draw_info->tile,0,0,MagickTrue,\n        &draw_info->tile->exception);\n  clone_info->tile=NewImageList();  /* tile is deprecated */\n  if (draw_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=CloneImage(draw_info->stroke_pattern,0,0,\n      MagickTrue,&draw_info->stroke_pattern->exception);\n  clone_info->stroke_antialias=draw_info->stroke_antialias;\n  clone_info->text_antialias=draw_info->text_antialias;\n  clone_info->fill_rule=draw_info->fill_rule;\n  clone_info->linecap=draw_info->linecap;\n  clone_info->linejoin=draw_info->linejoin;\n  clone_info->miterlimit=draw_info->miterlimit;\n  clone_info->dash_offset=draw_info->dash_offset;\n  clone_info->decorate=draw_info->decorate;\n  clone_info->compose=draw_info->compose;\n  if (draw_info->text != (char *) NULL)\n    (void) CloneString(&clone_info->text,draw_info->text);\n  if (draw_info->font != (char *) NULL)\n    (void) CloneString(&clone_info->font,draw_info->font);\n  if (draw_info->metrics != (char *) NULL)\n    (void) CloneString(&clone_info->metrics,draw_info->metrics);\n  if (draw_info->family != (char *) NULL)\n    (void) CloneString(&clone_info->family,draw_info->family);\n  clone_info->style=draw_info->style;\n  clone_info->stretch=draw_info->stretch;\n  clone_info->weight=draw_info->weight;\n  if (draw_info->encoding != (char *) NULL)\n    (void) CloneString(&clone_info->encoding,draw_info->encoding);\n  clone_info->pointsize=draw_info->pointsize;\n  clone_info->kerning=draw_info->kerning;\n  clone_info->interline_spacing=draw_info->interline_spacing;\n  clone_info->interword_spacing=draw_info->interword_spacing;\n  clone_info->direction=draw_info->direction;\n  if (draw_info->density != (char *) NULL)\n    (void) CloneString(&clone_info->density,draw_info->density);\n  clone_info->align=draw_info->align;\n  clone_info->undercolor=draw_info->undercolor;\n  clone_info->border_color=draw_info->border_color;\n  if (draw_info->server_name != (char *) NULL)\n    (void) CloneString(&clone_info->server_name,draw_info->server_name);\n  if (draw_info->dash_pattern != (double *) NULL)\n    {\n      ssize_t\n        x;\n\n      for (x=0; fabs(draw_info->dash_pattern[x]) >= MagickEpsilon; x++) ;\n      clone_info->dash_pattern=(double *) AcquireQuantumMemory((size_t) (2*x+2),\n        sizeof(*clone_info->dash_pattern));\n      if (clone_info->dash_pattern == (double *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\n          \"UnableToAllocateDashPattern\");\n      (void) memset(clone_info->dash_pattern,0,(size_t) (2*x+2)*\n        sizeof(*clone_info->dash_pattern));\n      (void) memcpy(clone_info->dash_pattern,draw_info->dash_pattern,(size_t)\n        (x+1)*sizeof(*clone_info->dash_pattern));\n    }\n  clone_info->gradient=draw_info->gradient;\n  if (draw_info->gradient.stops != (StopInfo *) NULL)\n    {\n      size_t\n        number_stops;\n\n      number_stops=clone_info->gradient.number_stops;\n      clone_info->gradient.stops=(StopInfo *) AcquireQuantumMemory((size_t)\n        number_stops,sizeof(*clone_info->gradient.stops));\n      if (clone_info->gradient.stops == (StopInfo *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\n          \"UnableToAllocateDashPattern\");\n      (void) memcpy(clone_info->gradient.stops,draw_info->gradient.stops,\n        (size_t) number_stops*sizeof(*clone_info->gradient.stops));\n    }\n  clone_info->bounds=draw_info->bounds;\n  clone_info->fill_opacity=draw_info->fill_opacity;\n  clone_info->stroke_opacity=draw_info->stroke_opacity;\n  clone_info->element_reference=draw_info->element_reference;\n  clone_info->clip_path=draw_info->clip_path;\n  clone_info->clip_units=draw_info->clip_units;\n  if (draw_info->clip_mask != (char *) NULL)\n    (void) CloneString(&clone_info->clip_mask,draw_info->clip_mask);\n  if (draw_info->clipping_mask != (Image *) NULL)\n    clone_info->clipping_mask=CloneImage(draw_info->clipping_mask,0,0,\n      MagickTrue,&draw_info->clipping_mask->exception);\n  if (draw_info->composite_mask != (Image *) NULL)\n    clone_info->composite_mask=CloneImage(draw_info->composite_mask,0,0,\n      MagickTrue,&draw_info->composite_mask->exception);\n  clone_info->render=draw_info->render;\n  clone_info->image_info=CloneImageInfo(draw_info->image_info);\n  clone_info->debug=draw_info->debug;\n  return(clone_info);\n}",
        "func": "MagickExport DrawInfo *CloneDrawInfo(const ImageInfo *image_info,\n  const DrawInfo *draw_info)\n{\n  DrawInfo\n    *clone_info;\n\n  clone_info=(DrawInfo *) AcquireCriticalMemory(sizeof(*clone_info));\n  GetDrawInfo(image_info,clone_info);\n  if (draw_info == (DrawInfo *) NULL)\n    return(clone_info);\n  if (draw_info->id != (char *) NULL)\n    (void) CloneString(&clone_info->id,draw_info->id);\n  if (draw_info->primitive != (char *) NULL)\n    (void) CloneString(&clone_info->primitive,draw_info->primitive);\n  if (draw_info->geometry != (char *) NULL)\n    (void) CloneString(&clone_info->geometry,draw_info->geometry);\n  clone_info->compliance=draw_info->compliance;\n  clone_info->viewbox=draw_info->viewbox;\n  clone_info->affine=draw_info->affine;\n  clone_info->gravity=draw_info->gravity;\n  clone_info->fill=draw_info->fill;\n  clone_info->stroke=draw_info->stroke;\n  clone_info->stroke_width=draw_info->stroke_width;\n  if (draw_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(draw_info->fill_pattern,0,0,MagickTrue,\n      &draw_info->fill_pattern->exception);\n  else\n    if (draw_info->tile != (Image *) NULL)\n      clone_info->fill_pattern=CloneImage(draw_info->tile,0,0,MagickTrue,\n        &draw_info->tile->exception);\n  clone_info->tile=NewImageList();  /* tile is deprecated */\n  if (draw_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=CloneImage(draw_info->stroke_pattern,0,0,\n      MagickTrue,&draw_info->stroke_pattern->exception);\n  clone_info->stroke_antialias=draw_info->stroke_antialias;\n  clone_info->text_antialias=draw_info->text_antialias;\n  clone_info->fill_rule=draw_info->fill_rule;\n  clone_info->linecap=draw_info->linecap;\n  clone_info->linejoin=draw_info->linejoin;\n  clone_info->miterlimit=draw_info->miterlimit;\n  clone_info->dash_offset=draw_info->dash_offset;\n  clone_info->decorate=draw_info->decorate;\n  clone_info->compose=draw_info->compose;\n  if (draw_info->text != (char *) NULL)\n    (void) CloneString(&clone_info->text,draw_info->text);\n  if (draw_info->font != (char *) NULL)\n    (void) CloneString(&clone_info->font,draw_info->font);\n  if (draw_info->metrics != (char *) NULL)\n    (void) CloneString(&clone_info->metrics,draw_info->metrics);\n  if (draw_info->family != (char *) NULL)\n    (void) CloneString(&clone_info->family,draw_info->family);\n  clone_info->style=draw_info->style;\n  clone_info->stretch=draw_info->stretch;\n  clone_info->weight=draw_info->weight;\n  if (draw_info->encoding != (char *) NULL)\n    (void) CloneString(&clone_info->encoding,draw_info->encoding);\n  clone_info->pointsize=draw_info->pointsize;\n  clone_info->kerning=draw_info->kerning;\n  clone_info->interline_spacing=draw_info->interline_spacing;\n  clone_info->interword_spacing=draw_info->interword_spacing;\n  clone_info->direction=draw_info->direction;\n  if (draw_info->density != (char *) NULL)\n    (void) CloneString(&clone_info->density,draw_info->density);\n  clone_info->align=draw_info->align;\n  clone_info->undercolor=draw_info->undercolor;\n  clone_info->border_color=draw_info->border_color;\n  if (draw_info->server_name != (char *) NULL)\n    (void) CloneString(&clone_info->server_name,draw_info->server_name);\n  if (draw_info->dash_pattern != (double *) NULL)\n    {\n      ssize_t\n        x;\n\n      for (x=0; fabs(draw_info->dash_pattern[x]) >= MagickEpsilon; x++) ;\n      clone_info->dash_pattern=(double *) AcquireQuantumMemory((size_t) (2*x+2),\n        sizeof(*clone_info->dash_pattern));\n      if (clone_info->dash_pattern == (double *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\n          \"UnableToAllocateDashPattern\");\n      (void) memset(clone_info->dash_pattern,0,(size_t) (2*x+2)*\n        sizeof(*clone_info->dash_pattern));\n      (void) memcpy(clone_info->dash_pattern,draw_info->dash_pattern,(size_t)\n        (x+1)*sizeof(*clone_info->dash_pattern));\n    }\n  clone_info->gradient=draw_info->gradient;\n  if (draw_info->gradient.stops != (StopInfo *) NULL)\n    {\n      size_t\n        number_stops;\n\n      number_stops=clone_info->gradient.number_stops;\n      clone_info->gradient.stops=(StopInfo *) AcquireQuantumMemory((size_t)\n        number_stops,sizeof(*clone_info->gradient.stops));\n      if (clone_info->gradient.stops == (StopInfo *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\n          \"UnableToAllocateDashPattern\");\n      (void) memcpy(clone_info->gradient.stops,draw_info->gradient.stops,\n        (size_t) number_stops*sizeof(*clone_info->gradient.stops));\n    }\n  clone_info->bounds=draw_info->bounds;\n  clone_info->fill_opacity=draw_info->fill_opacity;\n  clone_info->stroke_opacity=draw_info->stroke_opacity;\n  clone_info->element_reference=draw_info->element_reference;\n  clone_info->clip_path=draw_info->clip_path;\n  clone_info->clip_units=draw_info->clip_units;\n  if (draw_info->clip_mask != (char *) NULL)\n    (void) CloneString(&clone_info->clip_mask,draw_info->clip_mask);\n  if (draw_info->clipping_mask != (Image *) NULL)\n    clone_info->clipping_mask=CloneImage(draw_info->clipping_mask,0,0,\n      MagickTrue,&draw_info->clipping_mask->exception);\n  if (draw_info->composite_mask != (Image *) NULL)\n    clone_info->composite_mask=CloneImage(draw_info->composite_mask,0,0,\n      MagickTrue,&draw_info->composite_mask->exception);\n  clone_info->render=draw_info->render;\n  clone_info->debug=draw_info->debug;\n  return(clone_info);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -112,7 +112,6 @@\n     clone_info->composite_mask=CloneImage(draw_info->composite_mask,0,0,\n       MagickTrue,&draw_info->composite_mask->exception);\n   clone_info->render=draw_info->render;\n-  clone_info->image_info=CloneImageInfo(draw_info->image_info);\n   clone_info->debug=draw_info->debug;\n   return(clone_info);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  clone_info->image_info=CloneImageInfo(draw_info->image_info);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-19724",
        "func_name": "binutils-gdb/display_rel_file",
        "description": "A memory consumption issue in get_data function in binutils/nm.c in GNU nm before 2.34 allows attackers to cause a denial of service via crafted command.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=805f38bc551de820bcd7b31d3c5731ae27cf853a",
        "commit_title": "",
        "commit_text": "PR25362, memory leak in nm  \tPR 25362 \t* nm.c (display_rel_file): Free dyn_syms. ",
        "func_before": "static void\ndisplay_rel_file (bfd *abfd, bfd *archive_bfd)\n{\n  long symcount;\n  void *minisyms;\n  unsigned int size;\n  struct size_sym *symsizes;\n  asymbol *synthsyms = NULL;\n\n  if (! dynamic)\n    {\n      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n    }\n\n  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);\n  if (symcount < 0)\n    {\n      if (dynamic && bfd_get_error () == bfd_error_no_symbols)\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n\n      bfd_fatal (bfd_get_filename (abfd));\n    }\n\n  if (symcount == 0)\n    {\n      non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n      return;\n    }\n\n  if (show_synthetic && size == sizeof (asymbol *))\n    {\n      asymbol **static_syms = NULL;\n      asymbol **dyn_syms = NULL;\n      long static_count = 0;\n      long dyn_count = 0;\n      long synth_count;\n\n      if (dynamic)\n\t{\n\t  dyn_count = symcount;\n\t  dyn_syms = (asymbol **) minisyms;\n\t}\n      else\n\t{\n\t  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n\n\t  static_count = symcount;\n\t  static_syms = (asymbol **) minisyms;\n\n\t  if (storage > 0)\n\t    {\n\t      dyn_syms = (asymbol **) xmalloc (storage);\n\t      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);\n\t      if (dyn_count < 0)\n\t\tbfd_fatal (bfd_get_filename (abfd));\n\t    }\n\t}\n\n      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,\n\t\t\t\t\t      dyn_count, dyn_syms, &synthsyms);\n      if (synth_count > 0)\n\t{\n\t  asymbol **symp;\n\t  long i;\n\n\t  minisyms = xrealloc (minisyms,\n\t\t\t       (symcount + synth_count + 1) * sizeof (*symp));\n\t  symp = (asymbol **) minisyms + symcount;\n\t  for (i = 0; i < synth_count; i++)\n\t    *symp++ = synthsyms + i;\n\t  *symp = 0;\n\t  symcount += synth_count;\n\t}\n    }\n\n  /* lto_slim_object is set to false when a bfd is loaded with a compiler\n     LTO plugin.  */\n  if (abfd->lto_slim_object)\n    {\n      report_plugin_err = FALSE;\n      non_fatal (_(\"%s: plugin needed to handle lto object\"),\n\t\t bfd_get_filename (abfd));\n    }\n\n  /* Discard the symbols we don't want to print.\n     It's OK to do this in place; we'll free the storage anyway\n     (after printing).  */\n\n  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);\n\n  symsizes = NULL;\n  if (! no_sort)\n    {\n      sort_bfd = abfd;\n      sort_dynamic = dynamic;\n      sort_x = bfd_make_empty_symbol (abfd);\n      sort_y = bfd_make_empty_symbol (abfd);\n      if (sort_x == NULL || sort_y == NULL)\n\tbfd_fatal (bfd_get_filename (abfd));\n\n      if (! sort_by_size)\n\tqsort (minisyms, symcount, size,\n\t       sorters[sort_numerically][reverse_sort]);\n      else\n\tsymcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,\n\t\t\t\t\t size, &symsizes);\n    }\n\n  if (! sort_by_size)\n    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);\n  else\n    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);\n\n  if (synthsyms)\n    free (synthsyms);\n  free (minisyms);\n  free (symsizes);\n}",
        "func": "static void\ndisplay_rel_file (bfd *abfd, bfd *archive_bfd)\n{\n  long symcount;\n  void *minisyms;\n  unsigned int size;\n  struct size_sym *symsizes;\n  asymbol *synthsyms = NULL;\n\n  if (! dynamic)\n    {\n      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n    }\n\n  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);\n  if (symcount < 0)\n    {\n      if (dynamic && bfd_get_error () == bfd_error_no_symbols)\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n\n      bfd_fatal (bfd_get_filename (abfd));\n    }\n\n  if (symcount == 0)\n    {\n      non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n      return;\n    }\n\n  if (show_synthetic && size == sizeof (asymbol *))\n    {\n      asymbol **static_syms = NULL;\n      asymbol **dyn_syms = NULL;\n      long static_count = 0;\n      long dyn_count = 0;\n      long synth_count;\n\n      if (dynamic)\n\t{\n\t  dyn_count = symcount;\n\t  dyn_syms = (asymbol **) minisyms;\n\t}\n      else\n\t{\n\t  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n\n\t  static_count = symcount;\n\t  static_syms = (asymbol **) minisyms;\n\n\t  if (storage > 0)\n\t    {\n\t      dyn_syms = (asymbol **) xmalloc (storage);\n\t      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);\n\t      if (dyn_count < 0)\n\t\tbfd_fatal (bfd_get_filename (abfd));\n\t    }\n\t}\n\n      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,\n\t\t\t\t\t      dyn_count, dyn_syms, &synthsyms);\n      if (synth_count > 0)\n\t{\n\t  asymbol **symp;\n\t  long i;\n\n\t  minisyms = xrealloc (minisyms,\n\t\t\t       (symcount + synth_count + 1) * sizeof (*symp));\n\t  symp = (asymbol **) minisyms + symcount;\n\t  for (i = 0; i < synth_count; i++)\n\t    *symp++ = synthsyms + i;\n\t  *symp = 0;\n\t  symcount += synth_count;\n\t}\n      if (!dynamic && dyn_syms != NULL)\n\tfree (dyn_syms);\n    }\n\n  /* lto_slim_object is set to false when a bfd is loaded with a compiler\n     LTO plugin.  */\n  if (abfd->lto_slim_object)\n    {\n      report_plugin_err = FALSE;\n      non_fatal (_(\"%s: plugin needed to handle lto object\"),\n\t\t bfd_get_filename (abfd));\n    }\n\n  /* Discard the symbols we don't want to print.\n     It's OK to do this in place; we'll free the storage anyway\n     (after printing).  */\n\n  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);\n\n  symsizes = NULL;\n  if (! no_sort)\n    {\n      sort_bfd = abfd;\n      sort_dynamic = dynamic;\n      sort_x = bfd_make_empty_symbol (abfd);\n      sort_y = bfd_make_empty_symbol (abfd);\n      if (sort_x == NULL || sort_y == NULL)\n\tbfd_fatal (bfd_get_filename (abfd));\n\n      if (! sort_by_size)\n\tqsort (minisyms, symcount, size,\n\t       sorters[sort_numerically][reverse_sort]);\n      else\n\tsymcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,\n\t\t\t\t\t size, &symsizes);\n    }\n\n  if (! sort_by_size)\n    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);\n  else\n    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);\n\n  if (synthsyms)\n    free (synthsyms);\n  free (minisyms);\n  free (symsizes);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -78,6 +78,8 @@\n \t  *symp = 0;\n \t  symcount += synth_count;\n \t}\n+      if (!dynamic && dyn_syms != NULL)\n+\tfree (dyn_syms);\n     }\n \n   /* lto_slim_object is set to false when a bfd is loaded with a compiler",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if (!dynamic && dyn_syms != NULL)",
                "\tfree (dyn_syms);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26683",
        "func_name": "ArtifexSoftware/mupdf/pdf_add_cid_font_widths",
        "description": "A memory leak issue discovered in /pdf/pdf-font-add.c in Artifex Software MuPDF 1.17.0 allows attackers to obtain sensitive information.",
        "git_url": "https://github.com/ArtifexSoftware/mupdf/commit/05720b4ee3dbae57e65546dc2eecc3021c08eeea",
        "commit_title": "Bug 702566: Avoid leaking run_obj from pdf_add_cid_font_widths",
        "commit_text": " When we hit curr_code == face->num_glyphs we should publish any run_obj we have (and certainly drop it).",
        "func_before": "static void\npdf_add_cid_font_widths(fz_context *ctx, pdf_document *doc, pdf_obj *fobj, fz_font *font)\n{\n\tFT_Face face = font->ft_face;\n\tpdf_obj *run_obj = NULL;\n\tpdf_obj *fw;\n\tint curr_code;\n\tint prev_code;\n\tint curr_size;\n\tint prev_size;\n\tint first_code;\n\tint new_first_code;\n\tint state = FW_START;\n\tint new_state = FW_START;\n\tint publish = 0;\n\n\tfz_var(run_obj);\n\n\tfw = pdf_add_new_array(ctx, doc, 10);\n\tfz_try(ctx)\n\t{\n\t\tprev_code = 0;\n\t\tprev_size = fz_advance_glyph(ctx, font, 0, 0) * 1000;\n\t\tfirst_code = prev_code;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tcurr_code = prev_code + 1;\n\t\t\tif (curr_code >= face->num_glyphs)\n\t\t\t\tbreak;\n\t\t\tcurr_size = fz_advance_glyph(ctx, font, curr_code, 0) * 1000;\n\n\t\t\tswitch (state)\n\t\t\t{\n\t\t\tcase FW_SAME:\n\t\t\t\tif (curr_size != prev_size)\n\t\t\t\t{\n\t\t\t\t\t/* End of same widths for consecutive ids. Current will\n\t\t\t\t\t * be pushed as prev. below during next iteration */\n\t\t\t\t\tpublish = 1;\n\t\t\t\t\tif (curr_code < face->num_glyphs)\n\t\t\t\t\t\trun_obj = pdf_new_array(ctx, doc, 10);\n\t\t\t\t\tnew_state = FW_RUN;\n\t\t\t\t\t/* And the new first code is our current code */\n\t\t\t\t\tnew_first_code = curr_code;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FW_RUN:\n\t\t\t\tif (curr_size == prev_size)\n\t\t\t\t{\n\t\t\t\t\t/* Same width, so start a new same entry starting with\n\t\t\t\t\t * the previous code. i.e. the prev size is not put\n\t\t\t\t\t * in the run */\n\t\t\t\t\tpublish = 1;\n\t\t\t\t\tnew_state = FW_SAME;\n\t\t\t\t\tnew_first_code = prev_code;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Add prev size to run_obj */\n\t\t\t\t\tpdf_array_push_int(ctx, run_obj, prev_size);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FW_START:\n\t\t\t\t/* Starting fresh. Determine our state */\n\t\t\t\tif (curr_size == prev_size)\n\t\t\t\t{\n\t\t\t\t\tstate = FW_SAME;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trun_obj = pdf_new_array(ctx, doc, 10);\n\t\t\t\t\tpdf_array_push_int(ctx, run_obj, prev_size);\n\t\t\t\t\tstate = FW_RUN;\n\t\t\t\t}\n\t\t\t\tnew_first_code = prev_code;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (publish || curr_code == face->num_glyphs)\n\t\t\t{\n\t\t\t\tswitch (state)\n\t\t\t\t{\n\t\t\t\tcase FW_SAME:\n\t\t\t\t\t/* Add three entries. First cid, last cid and width */\n\t\t\t\t\tpdf_array_push_int(ctx, fw, first_code);\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_code);\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FW_RUN:\n\t\t\t\t\tif (pdf_array_len(ctx, run_obj) > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_array_push_int(ctx, fw, first_code);\n\t\t\t\t\t\tpdf_array_push(ctx, fw, run_obj);\n\t\t\t\t\t}\n\t\t\t\t\tpdf_drop_obj(ctx, run_obj);\n\t\t\t\t\trun_obj = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FW_START:\n\t\t\t\t\t/* Lone wolf. Not part of a consecutive run */\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_code);\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_code);\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (curr_code < face->num_glyphs)\n\t\t\t\t{\n\t\t\t\t\tstate = new_state;\n\t\t\t\t\tfirst_code = new_first_code;\n\t\t\t\t\tpublish = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev_size = curr_size;\n\t\t\tprev_code = curr_code;\n\t\t}\n\n\t\tif (font->width_table != NULL)\n\t\t\tpdf_dict_put_int(ctx, fobj, PDF_NAME(DW), font->width_default);\n\t\tif (pdf_array_len(ctx, fw) > 0)\n\t\t\tpdf_dict_put(ctx, fobj, PDF_NAME(W), fw);\n\t}\n\tfz_always(ctx)\n\t\tpdf_drop_obj(ctx, fw);\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}",
        "func": "static void\npdf_add_cid_font_widths(fz_context *ctx, pdf_document *doc, pdf_obj *fobj, fz_font *font)\n{\n\tFT_Face face = font->ft_face;\n\tpdf_obj *run_obj = NULL;\n\tpdf_obj *fw;\n\tint curr_code;\n\tint prev_code;\n\tint curr_size;\n\tint prev_size;\n\tint first_code;\n\tint new_first_code;\n\tint state = FW_START;\n\tint new_state = FW_START;\n\tint publish = 0;\n\n\tfz_var(run_obj);\n\n\tfw = pdf_add_new_array(ctx, doc, 10);\n\tfz_try(ctx)\n\t{\n\t\tprev_code = 0;\n\t\tprev_size = fz_advance_glyph(ctx, font, 0, 0) * 1000;\n\t\tfirst_code = prev_code;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tcurr_code = prev_code + 1;\n\t\t\tif (curr_code >= face->num_glyphs)\n\t\t\t\tbreak;\n\t\t\tcurr_size = fz_advance_glyph(ctx, font, curr_code, 0) * 1000;\n\n\t\t\tswitch (state)\n\t\t\t{\n\t\t\tcase FW_SAME:\n\t\t\t\tif (curr_size != prev_size)\n\t\t\t\t{\n\t\t\t\t\t/* End of same widths for consecutive ids. Current will\n\t\t\t\t\t * be pushed as prev. below during next iteration */\n\t\t\t\t\tpublish = 1;\n\t\t\t\t\tif (curr_code < face->num_glyphs)\n\t\t\t\t\t\trun_obj = pdf_new_array(ctx, doc, 10);\n\t\t\t\t\tnew_state = FW_RUN;\n\t\t\t\t\t/* And the new first code is our current code */\n\t\t\t\t\tnew_first_code = curr_code;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FW_RUN:\n\t\t\t\tif (curr_size == prev_size)\n\t\t\t\t{\n\t\t\t\t\t/* Same width, so start a new same entry starting with\n\t\t\t\t\t * the previous code. i.e. the prev size is not put\n\t\t\t\t\t * in the run */\n\t\t\t\t\tpublish = 1;\n\t\t\t\t\tnew_state = FW_SAME;\n\t\t\t\t\tnew_first_code = prev_code;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Add prev size to run_obj */\n\t\t\t\t\tpdf_array_push_int(ctx, run_obj, prev_size);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FW_START:\n\t\t\t\t/* Starting fresh. Determine our state */\n\t\t\t\tif (curr_size == prev_size)\n\t\t\t\t{\n\t\t\t\t\tstate = FW_SAME;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trun_obj = pdf_new_array(ctx, doc, 10);\n\t\t\t\t\tpdf_array_push_int(ctx, run_obj, prev_size);\n\t\t\t\t\tstate = FW_RUN;\n\t\t\t\t}\n\t\t\t\tnew_first_code = prev_code;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (publish || curr_code == face->num_glyphs)\n\t\t\t{\n\t\t\t\tswitch (state)\n\t\t\t\t{\n\t\t\t\tcase FW_SAME:\n\t\t\t\t\t/* Add three entries. First cid, last cid and width */\n\t\t\t\t\tpdf_array_push_int(ctx, fw, first_code);\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_code);\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase FW_RUN:\n\t\t\t\t\tif (pdf_array_len(ctx, run_obj) > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpdf_array_push_int(ctx, fw, first_code);\n\t\t\t\t\t\tpdf_array_push(ctx, fw, run_obj);\n\t\t\t\t\t}\n\t\t\t\t\tpdf_drop_obj(ctx, run_obj);\n\t\t\t\t\trun_obj = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FW_START:\n\t\t\t\t\t/* Lone wolf. Not part of a consecutive run */\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_code);\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_code);\n\t\t\t\t\tpdf_array_push_int(ctx, fw, prev_size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (curr_code < face->num_glyphs)\n\t\t\t\t{\n\t\t\t\t\tstate = new_state;\n\t\t\t\t\tfirst_code = new_first_code;\n\t\t\t\t\tpublish = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev_size = curr_size;\n\t\t\tprev_code = curr_code;\n\t\t}\n\n\t\tif (pdf_array_len(ctx, run_obj) > 0)\n\t\t{\n\t\t\tpdf_array_push_int(ctx, fw, first_code);\n\t\t\tpdf_array_push(ctx, fw, run_obj);\n\t\t}\n\n\t\tif (font->width_table != NULL)\n\t\t\tpdf_dict_put_int(ctx, fobj, PDF_NAME(DW), font->width_default);\n\t\tif (pdf_array_len(ctx, fw) > 0)\n\t\t\tpdf_dict_put(ctx, fobj, PDF_NAME(W), fw);\n\t}\n\tfz_always(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, fw);\n\t\tpdf_drop_obj(ctx, run_obj);\n\t}\n\tfz_catch(ctx)\n\t\tfz_rethrow(ctx);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -116,13 +116,22 @@\n \t\t\tprev_code = curr_code;\n \t\t}\n \n+\t\tif (pdf_array_len(ctx, run_obj) > 0)\n+\t\t{\n+\t\t\tpdf_array_push_int(ctx, fw, first_code);\n+\t\t\tpdf_array_push(ctx, fw, run_obj);\n+\t\t}\n+\n \t\tif (font->width_table != NULL)\n \t\t\tpdf_dict_put_int(ctx, fobj, PDF_NAME(DW), font->width_default);\n \t\tif (pdf_array_len(ctx, fw) > 0)\n \t\t\tpdf_dict_put(ctx, fobj, PDF_NAME(W), fw);\n \t}\n \tfz_always(ctx)\n+\t{\n \t\tpdf_drop_obj(ctx, fw);\n+\t\tpdf_drop_obj(ctx, run_obj);\n+\t}\n \tfz_catch(ctx)\n \t\tfz_rethrow(ctx);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (pdf_array_len(ctx, run_obj) > 0)",
                "\t\t{",
                "\t\t\tpdf_array_push_int(ctx, fw, first_code);",
                "\t\t\tpdf_array_push(ctx, fw, run_obj);",
                "\t\t}",
                "",
                "\t{",
                "\t\tpdf_drop_obj(ctx, run_obj);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48065",
        "func_name": "binutils-gdb/find_abstract_instance",
        "description": "GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=d28fbc7197ba0e021a43f873eff90b05dcdcff6a",
        "commit_title": "",
        "commit_text": "PR29925, Memory leak in find_abstract_instance  The testcase in the PR had a variable with both DW_AT_decl_file and DW_AT_specification, where the DW_AT_specification also specified DW_AT_decl_file.  This leads to a memory leak as the file name is malloced and duplicates are not expected.  I've also changed find_abstract_instance to not use a temp for \"name\", because that can result in a change in behaviour from the usual last of duplicate attributes wins.  \tPR 29925 \t* dwarf2.c (find_abstract_instance): Delete \"name\" variable. \tFree *filename_ptr before assigning new file name. \t(scan_unit_for_symbols): Similarly free func->file and \tvar->file before assigning. ",
        "func_before": "static bool\nfind_abstract_instance (struct comp_unit *unit,\n\t\t\tstruct attribute *attr_ptr,\n\t\t\tunsigned int recur_count,\n\t\t\tconst char **pname,\n\t\t\tbool *is_linkage,\n\t\t\tchar **filename_ptr,\n\t\t\tint *linenumber_ptr)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = NULL;\n  bfd_byte *info_ptr_end;\n  unsigned int abbrev_number, i;\n  struct abbrev_info *abbrev;\n  uint64_t die_ref = attr_ptr->u.val;\n  struct attribute attr;\n  const char *name = NULL;\n\n  if (recur_count == 100)\n    {\n      _bfd_error_handler\n\t(_(\"DWARF error: abstract instance recursion detected\"));\n      bfd_set_error (bfd_error_bad_value);\n      return false;\n    }\n\n  /* DW_FORM_ref_addr can reference an entry in a different CU. It\n     is an offset from the .debug_info section, not the current CU.  */\n  if (attr_ptr->form == DW_FORM_ref_addr)\n    {\n      /* We only support DW_FORM_ref_addr within the same file, so\n\t any relocations should be resolved already.  Check this by\n\t testing for a zero die_ref;  There can't be a valid reference\n\t to the header of a .debug_info section.\n\t DW_FORM_ref_addr is an offset relative to .debug_info.\n\t Normally when using the GNU linker this is accomplished by\n\t emitting a symbolic reference to a label, because .debug_info\n\t sections are linked at zero.  When there are multiple section\n\t groups containing .debug_info, as there might be in a\n\t relocatable object file, it would be reasonable to assume that\n\t a symbolic reference to a label in any .debug_info section\n\t might be used.  Since we lay out multiple .debug_info\n\t sections at non-zero VMAs (see place_sections), and read\n\t them contiguously into dwarf_info_buffer, that means the\n\t reference is relative to dwarf_info_buffer.  */\n      size_t total;\n\n      info_ptr = unit->file->dwarf_info_buffer;\n      info_ptr_end = info_ptr + unit->file->dwarf_info_size;\n      total = info_ptr_end - info_ptr;\n      if (!die_ref)\n\treturn true;\n      else if (die_ref >= total)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"DWARF error: invalid abstract instance DIE ref\"));\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n      info_ptr += die_ref;\n    }\n  else if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n    {\n      bool first_time = unit->stash->alt.dwarf_info_buffer == NULL;\n\n      info_ptr = read_alt_indirect_ref (unit, die_ref);\n      if (first_time)\n\tunit->stash->alt.info_ptr = unit->stash->alt.dwarf_info_buffer;\n      if (info_ptr == NULL)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"DWARF error: unable to read alt ref %\" PRIu64),\n\t     (uint64_t) die_ref);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n      info_ptr_end = (unit->stash->alt.dwarf_info_buffer\n\t\t      + unit->stash->alt.dwarf_info_size);\n      if (unit->stash->alt.all_comp_units)\n\tunit = unit->stash->alt.all_comp_units;\n    }\n\n  if (attr_ptr->form == DW_FORM_ref_addr\n      || attr_ptr->form == DW_FORM_GNU_ref_alt)\n    {\n      /* Now find the CU containing this pointer.  */\n      if (info_ptr >= unit->info_ptr_unit && info_ptr < unit->end_ptr)\n\tinfo_ptr_end = unit->end_ptr;\n      else\n\t{\n\t  /* Check other CUs to see if they contain the abbrev.  */\n\t  struct comp_unit *u = NULL;\n\t  struct addr_range range = { info_ptr, info_ptr };\n\t  splay_tree_node v = splay_tree_lookup (unit->file->comp_unit_tree,\n\t\t\t\t\t\t (splay_tree_key)&range);\n\t  if (v != NULL)\n\t    u = (struct comp_unit *)v->value;\n\n\t  if (attr_ptr->form == DW_FORM_ref_addr)\n\t    while (u == NULL)\n\t      {\n\t\tu = stash_comp_unit (unit->stash, &unit->stash->f);\n\t\tif (u == NULL)\n\t\t  break;\n\t\tif (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n\t\t  break;\n\t\tu = NULL;\n\t      }\n\n\t  if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n\t    while (u == NULL)\n\t      {\n\t\tu = stash_comp_unit (unit->stash, &unit->stash->alt);\n\t\tif (u == NULL)\n\t\t  break;\n\t\tif (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n\t\t  break;\n\t\tu = NULL;\n\t      }\n\n\t  if (u == NULL)\n\t    {\n\t      _bfd_error_handler\n\t\t(_(\"DWARF error: unable to locate abstract instance DIE ref %\"\n\t\t   PRIu64), (uint64_t) die_ref);\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return false;\n\t    }\n\t  unit = u;\n\t  info_ptr_end = unit->end_ptr;\n\t}\n    }\n  else\n    {\n      /* DW_FORM_ref1, DW_FORM_ref2, DW_FORM_ref4, DW_FORM_ref8 or\n\t DW_FORM_ref_udata.  These are all references relative to the\n\t start of the current CU.  */\n      size_t total;\n\n      info_ptr = unit->info_ptr_unit;\n      info_ptr_end = unit->end_ptr;\n      total = info_ptr_end - info_ptr;\n      if (!die_ref || die_ref >= total)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"DWARF error: invalid abstract instance DIE ref\"));\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n      info_ptr += die_ref;\n    }\n\n  abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n\t\t\t\t\t false, info_ptr_end);\n  if (abbrev_number)\n    {\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"DWARF error: could not find abbrev number %u\"), abbrev_number);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n      else\n\t{\n\t  for (i = 0; i < abbrev->num_attrs; ++i)\n\t    {\n\t      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit,\n\t\t\t\t\t info_ptr, info_ptr_end);\n\t      if (info_ptr == NULL)\n\t\tbreak;\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (name == NULL && is_str_form (&attr))\n\t\t    {\n\t\t      name = attr.u.str;\n\t\t      if (mangle_style (unit->lang) == 0)\n\t\t\t*is_linkage = true;\n\t\t    }\n\t\t  break;\n\t\tcase DW_AT_specification:\n\t\t  if (is_int_form (&attr)\n\t\t      && !find_abstract_instance (unit, &attr, recur_count + 1,\n\t\t\t\t\t\t  &name, is_linkage,\n\t\t\t\t\t\t  filename_ptr, linenumber_ptr))\n\t\t    return false;\n\t\t  break;\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_form (&attr))\n\t\t    {\n\t\t      name = attr.u.str;\n\t\t      *is_linkage = true;\n\t\t    }\n\t\t  break;\n\t\tcase DW_AT_decl_file:\n\t\t  if (!comp_unit_maybe_decode_line_info (unit))\n\t\t    return false;\n\t\t  if (is_int_form (&attr))\n\t\t    *filename_ptr = concat_filename (unit->line_table,\n\t\t\t\t\t\t     attr.u.val);\n\t\t  break;\n\t\tcase DW_AT_decl_line:\n\t\t  if (is_int_form (&attr))\n\t\t    *linenumber_ptr = attr.u.val;\n\t\t  break;\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  *pname = name;\n  return true;\n}",
        "func": "static bool\nfind_abstract_instance (struct comp_unit *unit,\n\t\t\tstruct attribute *attr_ptr,\n\t\t\tunsigned int recur_count,\n\t\t\tconst char **pname,\n\t\t\tbool *is_linkage,\n\t\t\tchar **filename_ptr,\n\t\t\tint *linenumber_ptr)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = NULL;\n  bfd_byte *info_ptr_end;\n  unsigned int abbrev_number, i;\n  struct abbrev_info *abbrev;\n  uint64_t die_ref = attr_ptr->u.val;\n  struct attribute attr;\n\n  if (recur_count == 100)\n    {\n      _bfd_error_handler\n\t(_(\"DWARF error: abstract instance recursion detected\"));\n      bfd_set_error (bfd_error_bad_value);\n      return false;\n    }\n\n  /* DW_FORM_ref_addr can reference an entry in a different CU. It\n     is an offset from the .debug_info section, not the current CU.  */\n  if (attr_ptr->form == DW_FORM_ref_addr)\n    {\n      /* We only support DW_FORM_ref_addr within the same file, so\n\t any relocations should be resolved already.  Check this by\n\t testing for a zero die_ref;  There can't be a valid reference\n\t to the header of a .debug_info section.\n\t DW_FORM_ref_addr is an offset relative to .debug_info.\n\t Normally when using the GNU linker this is accomplished by\n\t emitting a symbolic reference to a label, because .debug_info\n\t sections are linked at zero.  When there are multiple section\n\t groups containing .debug_info, as there might be in a\n\t relocatable object file, it would be reasonable to assume that\n\t a symbolic reference to a label in any .debug_info section\n\t might be used.  Since we lay out multiple .debug_info\n\t sections at non-zero VMAs (see place_sections), and read\n\t them contiguously into dwarf_info_buffer, that means the\n\t reference is relative to dwarf_info_buffer.  */\n      size_t total;\n\n      info_ptr = unit->file->dwarf_info_buffer;\n      info_ptr_end = info_ptr + unit->file->dwarf_info_size;\n      total = info_ptr_end - info_ptr;\n      if (!die_ref)\n\treturn true;\n      else if (die_ref >= total)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"DWARF error: invalid abstract instance DIE ref\"));\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n      info_ptr += die_ref;\n    }\n  else if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n    {\n      bool first_time = unit->stash->alt.dwarf_info_buffer == NULL;\n\n      info_ptr = read_alt_indirect_ref (unit, die_ref);\n      if (first_time)\n\tunit->stash->alt.info_ptr = unit->stash->alt.dwarf_info_buffer;\n      if (info_ptr == NULL)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"DWARF error: unable to read alt ref %\" PRIu64),\n\t     (uint64_t) die_ref);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n      info_ptr_end = (unit->stash->alt.dwarf_info_buffer\n\t\t      + unit->stash->alt.dwarf_info_size);\n      if (unit->stash->alt.all_comp_units)\n\tunit = unit->stash->alt.all_comp_units;\n    }\n\n  if (attr_ptr->form == DW_FORM_ref_addr\n      || attr_ptr->form == DW_FORM_GNU_ref_alt)\n    {\n      /* Now find the CU containing this pointer.  */\n      if (info_ptr >= unit->info_ptr_unit && info_ptr < unit->end_ptr)\n\tinfo_ptr_end = unit->end_ptr;\n      else\n\t{\n\t  /* Check other CUs to see if they contain the abbrev.  */\n\t  struct comp_unit *u = NULL;\n\t  struct addr_range range = { info_ptr, info_ptr };\n\t  splay_tree_node v = splay_tree_lookup (unit->file->comp_unit_tree,\n\t\t\t\t\t\t (splay_tree_key)&range);\n\t  if (v != NULL)\n\t    u = (struct comp_unit *)v->value;\n\n\t  if (attr_ptr->form == DW_FORM_ref_addr)\n\t    while (u == NULL)\n\t      {\n\t\tu = stash_comp_unit (unit->stash, &unit->stash->f);\n\t\tif (u == NULL)\n\t\t  break;\n\t\tif (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n\t\t  break;\n\t\tu = NULL;\n\t      }\n\n\t  if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n\t    while (u == NULL)\n\t      {\n\t\tu = stash_comp_unit (unit->stash, &unit->stash->alt);\n\t\tif (u == NULL)\n\t\t  break;\n\t\tif (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n\t\t  break;\n\t\tu = NULL;\n\t      }\n\n\t  if (u == NULL)\n\t    {\n\t      _bfd_error_handler\n\t\t(_(\"DWARF error: unable to locate abstract instance DIE ref %\"\n\t\t   PRIu64), (uint64_t) die_ref);\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return false;\n\t    }\n\t  unit = u;\n\t  info_ptr_end = unit->end_ptr;\n\t}\n    }\n  else\n    {\n      /* DW_FORM_ref1, DW_FORM_ref2, DW_FORM_ref4, DW_FORM_ref8 or\n\t DW_FORM_ref_udata.  These are all references relative to the\n\t start of the current CU.  */\n      size_t total;\n\n      info_ptr = unit->info_ptr_unit;\n      info_ptr_end = unit->end_ptr;\n      total = info_ptr_end - info_ptr;\n      if (!die_ref || die_ref >= total)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"DWARF error: invalid abstract instance DIE ref\"));\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n      info_ptr += die_ref;\n    }\n\n  abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n\t\t\t\t\t false, info_ptr_end);\n  if (abbrev_number)\n    {\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"DWARF error: could not find abbrev number %u\"), abbrev_number);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return false;\n\t}\n      else\n\t{\n\t  for (i = 0; i < abbrev->num_attrs; ++i)\n\t    {\n\t      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit,\n\t\t\t\t\t info_ptr, info_ptr_end);\n\t      if (info_ptr == NULL)\n\t\tbreak;\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (*pname == NULL && is_str_form (&attr))\n\t\t    {\n\t\t      *pname = attr.u.str;\n\t\t      if (mangle_style (unit->lang) == 0)\n\t\t\t*is_linkage = true;\n\t\t    }\n\t\t  break;\n\t\tcase DW_AT_specification:\n\t\t  if (is_int_form (&attr)\n\t\t      && !find_abstract_instance (unit, &attr, recur_count + 1,\n\t\t\t\t\t\t  pname, is_linkage,\n\t\t\t\t\t\t  filename_ptr, linenumber_ptr))\n\t\t    return false;\n\t\t  break;\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_form (&attr))\n\t\t    {\n\t\t      *pname = attr.u.str;\n\t\t      *is_linkage = true;\n\t\t    }\n\t\t  break;\n\t\tcase DW_AT_decl_file:\n\t\t  if (!comp_unit_maybe_decode_line_info (unit))\n\t\t    return false;\n\t\t  if (is_int_form (&attr))\n\t\t    {\n\t\t      free (*filename_ptr);\n\t\t      *filename_ptr = concat_filename (unit->line_table,\n\t\t\t\t\t\t       attr.u.val);\n\t\t    }\n\t\t  break;\n\t\tcase DW_AT_decl_line:\n\t\t  if (is_int_form (&attr))\n\t\t    *linenumber_ptr = attr.u.val;\n\t\t  break;\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,6 @@\n   struct abbrev_info *abbrev;\n   uint64_t die_ref = attr_ptr->u.val;\n   struct attribute attr;\n-  const char *name = NULL;\n \n   if (recur_count == 100)\n     {\n@@ -175,9 +174,9 @@\n \t\tcase DW_AT_name:\n \t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n \t\t     over DW_AT_name.  */\n-\t\t  if (name == NULL && is_str_form (&attr))\n+\t\t  if (*pname == NULL && is_str_form (&attr))\n \t\t    {\n-\t\t      name = attr.u.str;\n+\t\t      *pname = attr.u.str;\n \t\t      if (mangle_style (unit->lang) == 0)\n \t\t\t*is_linkage = true;\n \t\t    }\n@@ -185,7 +184,7 @@\n \t\tcase DW_AT_specification:\n \t\t  if (is_int_form (&attr)\n \t\t      && !find_abstract_instance (unit, &attr, recur_count + 1,\n-\t\t\t\t\t\t  &name, is_linkage,\n+\t\t\t\t\t\t  pname, is_linkage,\n \t\t\t\t\t\t  filename_ptr, linenumber_ptr))\n \t\t    return false;\n \t\t  break;\n@@ -195,7 +194,7 @@\n \t\t     non-string forms into these attributes.  */\n \t\t  if (is_str_form (&attr))\n \t\t    {\n-\t\t      name = attr.u.str;\n+\t\t      *pname = attr.u.str;\n \t\t      *is_linkage = true;\n \t\t    }\n \t\t  break;\n@@ -203,8 +202,11 @@\n \t\t  if (!comp_unit_maybe_decode_line_info (unit))\n \t\t    return false;\n \t\t  if (is_int_form (&attr))\n-\t\t    *filename_ptr = concat_filename (unit->line_table,\n-\t\t\t\t\t\t     attr.u.val);\n+\t\t    {\n+\t\t      free (*filename_ptr);\n+\t\t      *filename_ptr = concat_filename (unit->line_table,\n+\t\t\t\t\t\t       attr.u.val);\n+\t\t    }\n \t\t  break;\n \t\tcase DW_AT_decl_line:\n \t\t  if (is_int_form (&attr))\n@@ -216,6 +218,5 @@\n \t    }\n \t}\n     }\n-  *pname = name;\n   return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  const char *name = NULL;",
                "\t\t  if (name == NULL && is_str_form (&attr))",
                "\t\t      name = attr.u.str;",
                "\t\t\t\t\t\t  &name, is_linkage,",
                "\t\t      name = attr.u.str;",
                "\t\t    *filename_ptr = concat_filename (unit->line_table,",
                "\t\t\t\t\t\t     attr.u.val);",
                "  *pname = name;"
            ],
            "added_lines": [
                "\t\t  if (*pname == NULL && is_str_form (&attr))",
                "\t\t      *pname = attr.u.str;",
                "\t\t\t\t\t\t  pname, is_linkage,",
                "\t\t      *pname = attr.u.str;",
                "\t\t    {",
                "\t\t      free (*filename_ptr);",
                "\t\t      *filename_ptr = concat_filename (unit->line_table,",
                "\t\t\t\t\t\t       attr.u.val);",
                "\t\t    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48065",
        "func_name": "binutils-gdb/scan_unit_for_symbols",
        "description": "GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=d28fbc7197ba0e021a43f873eff90b05dcdcff6a",
        "commit_title": "",
        "commit_text": "PR29925, Memory leak in find_abstract_instance  The testcase in the PR had a variable with both DW_AT_decl_file and DW_AT_specification, where the DW_AT_specification also specified DW_AT_decl_file.  This leads to a memory leak as the file name is malloced and duplicates are not expected.  I've also changed find_abstract_instance to not use a temp for \"name\", because that can result in a change in behaviour from the usual last of duplicate attributes wins.  \tPR 29925 \t* dwarf2.c (find_abstract_instance): Delete \"name\" variable. \tFree *filename_ptr before assigning new file name. \t(scan_unit_for_symbols): Similarly free func->file and \tvar->file before assigning. ",
        "func_before": "static bool\nscan_unit_for_symbols (struct comp_unit *unit)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = unit->first_child_die_ptr;\n  bfd_byte *info_ptr_end = unit->end_ptr;\n  int nesting_level = 0;\n  struct nest_funcinfo\n  {\n    struct funcinfo *func;\n  } *nested_funcs;\n  int nested_funcs_size;\n  struct funcinfo *last_func;\n  struct varinfo *last_var;\n  \n  /* Maintain a stack of in-scope functions and inlined functions, which we\n     can use to set the caller_func field.  */\n  nested_funcs_size = 32;\n  nested_funcs = (struct nest_funcinfo *)\n    bfd_malloc (nested_funcs_size * sizeof (*nested_funcs));\n  if (nested_funcs == NULL)\n    return false;\n  nested_funcs[nesting_level].func = 0;\n\n  /* PR 27484: We must scan the DIEs twice.  The first time we look for\n     function and variable tags and accumulate them into their respective\n     tables.  The second time through we process the attributes of the\n     functions/variables and augment the table entries.  */\n  while (nesting_level >= 0)\n    {\n      unsigned int abbrev_number, i;\n      struct abbrev_info *abbrev;\n      struct funcinfo *func;\n      struct varinfo *var;\n      uint64_t current_offset;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      current_offset = info_ptr - unit->info_ptr_unit;\n      abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n\t\t\t\t\t     false, info_ptr_end);\n      if (abbrev_number == 0)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  static unsigned int previous_failed_abbrev = -1U;\n\n\t  /* Avoid multiple reports of the same missing abbrev.  */\n\t  if (abbrev_number != previous_failed_abbrev)\n\t    {\n\t      _bfd_error_handler\n\t\t(_(\"DWARF error: could not find abbrev number %u\"),\n\t\t abbrev_number);\n\t      previous_failed_abbrev = abbrev_number;\n\t    }\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto fail;\n\t}\n\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  size_t amt = sizeof (struct funcinfo);\n\n\t  var = NULL;\n\t  func = (struct funcinfo *) bfd_zalloc (abfd, amt);\n\t  if (func == NULL)\n\t    goto fail;\n\t  func->tag = abbrev->tag;\n\t  func->prev_func = unit->function_table;\n\t  func->unit_offset = current_offset;\n\t  unit->function_table = func;\n\t  unit->number_of_functions++;\n\t  BFD_ASSERT (!unit->cached);\n\n\t  if (func->tag == DW_TAG_inlined_subroutine)\n\t    for (i = nesting_level; i-- != 0; )\n\t      if (nested_funcs[i].func)\n\t\t{\n\t\t  func->caller_func = nested_funcs[i].func;\n\t\t  break;\n\t\t}\n\t  nested_funcs[nesting_level].func = func;\n\t}\n      else\n\t{\n\t  func = NULL;\n\t  if (abbrev->tag == DW_TAG_variable\n\t      || abbrev->tag == DW_TAG_member)\n\t    {\n\t      size_t amt = sizeof (struct varinfo);\n\n\t      var = (struct varinfo *) bfd_zalloc (abfd, amt);\n\t      if (var == NULL)\n\t\tgoto fail;\n\t      var->tag = abbrev->tag;\n\t      var->stack = true;\n\t      var->prev_var = unit->variable_table;\n\t      unit->variable_table = var;\n\t      var->unit_offset = current_offset;\n\t      /* PR 18205: Missing debug information can cause this\n\t\t var to be attached to an already cached unit.  */\n\t    }\n\t  else\n\t    var = NULL;\n\n\t  /* No inline function in scope at this nesting level.  */\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  struct attribute attr;\n\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n\t\t\t\t     unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  nesting_level++;\n\n\t  if (nesting_level >= nested_funcs_size)\n\t    {\n\t      struct nest_funcinfo *tmp;\n\n\t      nested_funcs_size *= 2;\n\t      tmp = (struct nest_funcinfo *)\n\t\tbfd_realloc (nested_funcs,\n\t\t\t     nested_funcs_size * sizeof (*nested_funcs));\n\t      if (tmp == NULL)\n\t\tgoto fail;\n\t      nested_funcs = tmp;\n\t    }\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n    }\n\n  unit->function_table = reverse_funcinfo_list (unit->function_table);\n  unit->variable_table = reverse_varinfo_list (unit->variable_table);\n\n  /* This is the second pass over the abbrevs.  */      \n  info_ptr = unit->first_child_die_ptr;\n  nesting_level = 0;\n  \n  last_func = NULL;\n  last_var = NULL;\n\n  while (nesting_level >= 0)\n    {\n      unsigned int abbrev_number, i;\n      struct abbrev_info *abbrev;\n      struct attribute attr;\n      struct funcinfo *func;\n      struct varinfo *var;\n      bfd_vma low_pc = 0;\n      bfd_vma high_pc = 0;\n      bool high_pc_relative = false;\n      uint64_t current_offset;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      current_offset = info_ptr - unit->info_ptr_unit;\n      abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n\t\t\t\t\t     false, info_ptr_end);\n      if (! abbrev_number)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      /* This should have been handled above.  */\n      BFD_ASSERT (abbrev != NULL);\n\n      func = NULL;\n      var = NULL;\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  if (last_func\n\t      && last_func->prev_func\n\t      && last_func->prev_func->unit_offset == current_offset)\n\t    func = last_func->prev_func;\n\t  else\n\t    func = lookup_func_by_offset (current_offset, unit->function_table);\n\n\t  if (func == NULL)\n\t    goto fail;\n\n\t  last_func = func;\n\t}\n      else if (abbrev->tag == DW_TAG_variable\n\t       || abbrev->tag == DW_TAG_member)\n\t{\n\t  if (last_var\n\t      && last_var->prev_var\n\t      && last_var->prev_var->unit_offset == current_offset)\n\t    var = last_var->prev_var;\n\t  else\n\t    var = lookup_var_by_offset (current_offset, unit->variable_table);\n\n\t  if (var == NULL)\n\t    goto fail;\n\n\t  last_var = var;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n\t\t\t\t     unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\n\t  if (func)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_call_file:\n\t\t  if (is_int_form (&attr))\n\t\t    func->caller_file = concat_filename (unit->line_table,\n\t\t\t\t\t\t\t attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_call_line:\n\t\t  if (is_int_form (&attr))\n\t\t    func->caller_line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_abstract_origin:\n\t\tcase DW_AT_specification:\n\t\t  if (is_int_form (&attr)\n\t\t      && !find_abstract_instance (unit, &attr, 0,\n\t\t\t\t\t\t  &func->name,\n\t\t\t\t\t\t  &func->is_linkage,\n\t\t\t\t\t\t  &func->file,\n\t\t\t\t\t\t  &func->line))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (func->name == NULL && is_str_form (&attr))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      if (mangle_style (unit->lang) == 0)\n\t\t\tfunc->is_linkage = true;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_form (&attr))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      func->is_linkage = true;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_low_pc:\n\t\t  if (is_int_form (&attr))\n\t\t    low_pc = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_high_pc:\n\t\t  if (is_int_form (&attr))\n\t\t    {\n\t\t      high_pc = attr.u.val;\n\t\t      high_pc_relative = attr.form != DW_FORM_addr;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_ranges:\n\t\t  if (is_int_form (&attr)\n\t\t      && !read_rangelist (unit, &func->arange,\n\t\t\t\t\t  &unit->file->trie_root, attr.u.val))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  if (is_int_form (&attr))\n\t\t    func->file = concat_filename (unit->line_table,\n\t\t\t\t\t\t  attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  if (is_int_form (&attr))\n\t\t    func->line = attr.u.val;\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t  else if (var)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_specification:\n\t\t  if (is_int_form (&attr) && attr.u.val)\n\t\t    {\n\t\t      bool is_linkage;\n\t\t      if (!find_abstract_instance (unit, &attr, 0,\n\t\t\t\t\t\t   &var->name,\n\t\t\t\t\t\t   &is_linkage,\n\t\t\t\t\t\t   &var->file,\n\t\t\t\t\t\t   &var->line))\n\t\t\t{\n\t\t\t  _bfd_error_handler (_(\"DWARF error: could not find \"\n\t\t\t\t\t\t\"variable specification \"\n\t\t\t\t\t\t\"at offset 0x%lx\"),\n\t\t\t\t\t      (unsigned long) attr.u.val);\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  if (is_str_form (&attr))\n\t\t    var->name = attr.u.str;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  if (is_int_form (&attr))\n\t\t    var->file = concat_filename (unit->line_table,\n\t\t\t\t\t\t attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  if (is_int_form (&attr))\n\t\t    var->line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_external:\n\t\t  if (is_int_form (&attr) && attr.u.val != 0)\n\t\t    var->stack = false;\n\t\t  break;\n\n\t\tcase DW_AT_location:\n\t\t  switch (attr.form)\n\t\t    {\n\t\t    case DW_FORM_block:\n\t\t    case DW_FORM_block1:\n\t\t    case DW_FORM_block2:\n\t\t    case DW_FORM_block4:\n\t\t    case DW_FORM_exprloc:\n\t\t      if (attr.u.blk->data != NULL\n\t\t\t  && *attr.u.blk->data == DW_OP_addr)\n\t\t\t{\n\t\t\t  var->stack = false;\n\n\t\t\t  /* Verify that DW_OP_addr is the only opcode in the\n\t\t\t     location, in which case the block size will be 1\n\t\t\t     plus the address size.  */\n\t\t\t  /* ??? For TLS variables, gcc can emit\n\t\t\t     DW_OP_addr <addr> DW_OP_GNU_push_tls_address\n\t\t\t     which we don't handle here yet.  */\n\t\t\t  if (attr.u.blk->size == unit->addr_size + 1U)\n\t\t\t    var->addr = bfd_get (unit->addr_size * 8,\n\t\t\t\t\t\t unit->abfd,\n\t\t\t\t\t\t attr.u.blk->data + 1);\n\t\t\t}\n\t\t      break;\n\n\t\t    default:\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (abbrev->has_children)\n\tnesting_level++;\n\n      if (high_pc_relative)\n\thigh_pc += low_pc;\n\n      if (func && high_pc != 0)\n\t{\n\t  if (!arange_add (unit, &func->arange, &unit->file->trie_root,\n\t\t\t   low_pc, high_pc))\n\t    goto fail;\n\t}\n    }\n\n  unit->function_table = reverse_funcinfo_list (unit->function_table);\n  unit->variable_table = reverse_varinfo_list (unit->variable_table);\n\n  free (nested_funcs);\n  return true;\n\n fail:\n  free (nested_funcs);\n  return false;\n}",
        "func": "static bool\nscan_unit_for_symbols (struct comp_unit *unit)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = unit->first_child_die_ptr;\n  bfd_byte *info_ptr_end = unit->end_ptr;\n  int nesting_level = 0;\n  struct nest_funcinfo\n  {\n    struct funcinfo *func;\n  } *nested_funcs;\n  int nested_funcs_size;\n  struct funcinfo *last_func;\n  struct varinfo *last_var;\n  \n  /* Maintain a stack of in-scope functions and inlined functions, which we\n     can use to set the caller_func field.  */\n  nested_funcs_size = 32;\n  nested_funcs = (struct nest_funcinfo *)\n    bfd_malloc (nested_funcs_size * sizeof (*nested_funcs));\n  if (nested_funcs == NULL)\n    return false;\n  nested_funcs[nesting_level].func = 0;\n\n  /* PR 27484: We must scan the DIEs twice.  The first time we look for\n     function and variable tags and accumulate them into their respective\n     tables.  The second time through we process the attributes of the\n     functions/variables and augment the table entries.  */\n  while (nesting_level >= 0)\n    {\n      unsigned int abbrev_number, i;\n      struct abbrev_info *abbrev;\n      struct funcinfo *func;\n      struct varinfo *var;\n      uint64_t current_offset;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      current_offset = info_ptr - unit->info_ptr_unit;\n      abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n\t\t\t\t\t     false, info_ptr_end);\n      if (abbrev_number == 0)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  static unsigned int previous_failed_abbrev = -1U;\n\n\t  /* Avoid multiple reports of the same missing abbrev.  */\n\t  if (abbrev_number != previous_failed_abbrev)\n\t    {\n\t      _bfd_error_handler\n\t\t(_(\"DWARF error: could not find abbrev number %u\"),\n\t\t abbrev_number);\n\t      previous_failed_abbrev = abbrev_number;\n\t    }\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto fail;\n\t}\n\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  size_t amt = sizeof (struct funcinfo);\n\n\t  var = NULL;\n\t  func = (struct funcinfo *) bfd_zalloc (abfd, amt);\n\t  if (func == NULL)\n\t    goto fail;\n\t  func->tag = abbrev->tag;\n\t  func->prev_func = unit->function_table;\n\t  func->unit_offset = current_offset;\n\t  unit->function_table = func;\n\t  unit->number_of_functions++;\n\t  BFD_ASSERT (!unit->cached);\n\n\t  if (func->tag == DW_TAG_inlined_subroutine)\n\t    for (i = nesting_level; i-- != 0; )\n\t      if (nested_funcs[i].func)\n\t\t{\n\t\t  func->caller_func = nested_funcs[i].func;\n\t\t  break;\n\t\t}\n\t  nested_funcs[nesting_level].func = func;\n\t}\n      else\n\t{\n\t  func = NULL;\n\t  if (abbrev->tag == DW_TAG_variable\n\t      || abbrev->tag == DW_TAG_member)\n\t    {\n\t      size_t amt = sizeof (struct varinfo);\n\n\t      var = (struct varinfo *) bfd_zalloc (abfd, amt);\n\t      if (var == NULL)\n\t\tgoto fail;\n\t      var->tag = abbrev->tag;\n\t      var->stack = true;\n\t      var->prev_var = unit->variable_table;\n\t      unit->variable_table = var;\n\t      var->unit_offset = current_offset;\n\t      /* PR 18205: Missing debug information can cause this\n\t\t var to be attached to an already cached unit.  */\n\t    }\n\t  else\n\t    var = NULL;\n\n\t  /* No inline function in scope at this nesting level.  */\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  struct attribute attr;\n\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n\t\t\t\t     unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  nesting_level++;\n\n\t  if (nesting_level >= nested_funcs_size)\n\t    {\n\t      struct nest_funcinfo *tmp;\n\n\t      nested_funcs_size *= 2;\n\t      tmp = (struct nest_funcinfo *)\n\t\tbfd_realloc (nested_funcs,\n\t\t\t     nested_funcs_size * sizeof (*nested_funcs));\n\t      if (tmp == NULL)\n\t\tgoto fail;\n\t      nested_funcs = tmp;\n\t    }\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n    }\n\n  unit->function_table = reverse_funcinfo_list (unit->function_table);\n  unit->variable_table = reverse_varinfo_list (unit->variable_table);\n\n  /* This is the second pass over the abbrevs.  */      \n  info_ptr = unit->first_child_die_ptr;\n  nesting_level = 0;\n  \n  last_func = NULL;\n  last_var = NULL;\n\n  while (nesting_level >= 0)\n    {\n      unsigned int abbrev_number, i;\n      struct abbrev_info *abbrev;\n      struct attribute attr;\n      struct funcinfo *func;\n      struct varinfo *var;\n      bfd_vma low_pc = 0;\n      bfd_vma high_pc = 0;\n      bool high_pc_relative = false;\n      uint64_t current_offset;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      current_offset = info_ptr - unit->info_ptr_unit;\n      abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n\t\t\t\t\t     false, info_ptr_end);\n      if (! abbrev_number)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      /* This should have been handled above.  */\n      BFD_ASSERT (abbrev != NULL);\n\n      func = NULL;\n      var = NULL;\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  if (last_func\n\t      && last_func->prev_func\n\t      && last_func->prev_func->unit_offset == current_offset)\n\t    func = last_func->prev_func;\n\t  else\n\t    func = lookup_func_by_offset (current_offset, unit->function_table);\n\n\t  if (func == NULL)\n\t    goto fail;\n\n\t  last_func = func;\n\t}\n      else if (abbrev->tag == DW_TAG_variable\n\t       || abbrev->tag == DW_TAG_member)\n\t{\n\t  if (last_var\n\t      && last_var->prev_var\n\t      && last_var->prev_var->unit_offset == current_offset)\n\t    var = last_var->prev_var;\n\t  else\n\t    var = lookup_var_by_offset (current_offset, unit->variable_table);\n\n\t  if (var == NULL)\n\t    goto fail;\n\n\t  last_var = var;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n\t\t\t\t     unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\n\t  if (func)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_call_file:\n\t\t  if (is_int_form (&attr))\n\t\t    func->caller_file = concat_filename (unit->line_table,\n\t\t\t\t\t\t\t attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_call_line:\n\t\t  if (is_int_form (&attr))\n\t\t    func->caller_line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_abstract_origin:\n\t\tcase DW_AT_specification:\n\t\t  if (is_int_form (&attr)\n\t\t      && !find_abstract_instance (unit, &attr, 0,\n\t\t\t\t\t\t  &func->name,\n\t\t\t\t\t\t  &func->is_linkage,\n\t\t\t\t\t\t  &func->file,\n\t\t\t\t\t\t  &func->line))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (func->name == NULL && is_str_form (&attr))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      if (mangle_style (unit->lang) == 0)\n\t\t\tfunc->is_linkage = true;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_form (&attr))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      func->is_linkage = true;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_low_pc:\n\t\t  if (is_int_form (&attr))\n\t\t    low_pc = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_high_pc:\n\t\t  if (is_int_form (&attr))\n\t\t    {\n\t\t      high_pc = attr.u.val;\n\t\t      high_pc_relative = attr.form != DW_FORM_addr;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_ranges:\n\t\t  if (is_int_form (&attr)\n\t\t      && !read_rangelist (unit, &func->arange,\n\t\t\t\t\t  &unit->file->trie_root, attr.u.val))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  if (is_int_form (&attr))\n\t\t    {\n\t\t      free (func->file);\n\t\t      func->file = concat_filename (unit->line_table,\n\t\t\t\t\t\t    attr.u.val);\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  if (is_int_form (&attr))\n\t\t    func->line = attr.u.val;\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t  else if (var)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_specification:\n\t\t  if (is_int_form (&attr) && attr.u.val)\n\t\t    {\n\t\t      bool is_linkage;\n\t\t      if (!find_abstract_instance (unit, &attr, 0,\n\t\t\t\t\t\t   &var->name,\n\t\t\t\t\t\t   &is_linkage,\n\t\t\t\t\t\t   &var->file,\n\t\t\t\t\t\t   &var->line))\n\t\t\t{\n\t\t\t  _bfd_error_handler (_(\"DWARF error: could not find \"\n\t\t\t\t\t\t\"variable specification \"\n\t\t\t\t\t\t\"at offset 0x%lx\"),\n\t\t\t\t\t      (unsigned long) attr.u.val);\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  if (is_str_form (&attr))\n\t\t    var->name = attr.u.str;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  if (is_int_form (&attr))\n\t\t    {\n\t\t      free (var->file);\n\t\t      var->file = concat_filename (unit->line_table,\n\t\t\t\t\t\t   attr.u.val);\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  if (is_int_form (&attr))\n\t\t    var->line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_external:\n\t\t  if (is_int_form (&attr) && attr.u.val != 0)\n\t\t    var->stack = false;\n\t\t  break;\n\n\t\tcase DW_AT_location:\n\t\t  switch (attr.form)\n\t\t    {\n\t\t    case DW_FORM_block:\n\t\t    case DW_FORM_block1:\n\t\t    case DW_FORM_block2:\n\t\t    case DW_FORM_block4:\n\t\t    case DW_FORM_exprloc:\n\t\t      if (attr.u.blk->data != NULL\n\t\t\t  && *attr.u.blk->data == DW_OP_addr)\n\t\t\t{\n\t\t\t  var->stack = false;\n\n\t\t\t  /* Verify that DW_OP_addr is the only opcode in the\n\t\t\t     location, in which case the block size will be 1\n\t\t\t     plus the address size.  */\n\t\t\t  /* ??? For TLS variables, gcc can emit\n\t\t\t     DW_OP_addr <addr> DW_OP_GNU_push_tls_address\n\t\t\t     which we don't handle here yet.  */\n\t\t\t  if (attr.u.blk->size == unit->addr_size + 1U)\n\t\t\t    var->addr = bfd_get (unit->addr_size * 8,\n\t\t\t\t\t\t unit->abfd,\n\t\t\t\t\t\t attr.u.blk->data + 1);\n\t\t\t}\n\t\t      break;\n\n\t\t    default:\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (abbrev->has_children)\n\tnesting_level++;\n\n      if (high_pc_relative)\n\thigh_pc += low_pc;\n\n      if (func && high_pc != 0)\n\t{\n\t  if (!arange_add (unit, &func->arange, &unit->file->trie_root,\n\t\t\t   low_pc, high_pc))\n\t    goto fail;\n\t}\n    }\n\n  unit->function_table = reverse_funcinfo_list (unit->function_table);\n  unit->variable_table = reverse_varinfo_list (unit->variable_table);\n\n  free (nested_funcs);\n  return true;\n\n fail:\n  free (nested_funcs);\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -296,8 +296,11 @@\n \n \t\tcase DW_AT_decl_file:\n \t\t  if (is_int_form (&attr))\n-\t\t    func->file = concat_filename (unit->line_table,\n-\t\t\t\t\t\t  attr.u.val);\n+\t\t    {\n+\t\t      free (func->file);\n+\t\t      func->file = concat_filename (unit->line_table,\n+\t\t\t\t\t\t    attr.u.val);\n+\t\t    }\n \t\t  break;\n \n \t\tcase DW_AT_decl_line:\n@@ -339,8 +342,11 @@\n \n \t\tcase DW_AT_decl_file:\n \t\t  if (is_int_form (&attr))\n-\t\t    var->file = concat_filename (unit->line_table,\n-\t\t\t\t\t\t attr.u.val);\n+\t\t    {\n+\t\t      free (var->file);\n+\t\t      var->file = concat_filename (unit->line_table,\n+\t\t\t\t\t\t   attr.u.val);\n+\t\t    }\n \t\t  break;\n \n \t\tcase DW_AT_decl_line:",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    func->file = concat_filename (unit->line_table,",
                "\t\t\t\t\t\t  attr.u.val);",
                "\t\t    var->file = concat_filename (unit->line_table,",
                "\t\t\t\t\t\t attr.u.val);"
            ],
            "added_lines": [
                "\t\t    {",
                "\t\t      free (func->file);",
                "\t\t      func->file = concat_filename (unit->line_table,",
                "\t\t\t\t\t\t    attr.u.val);",
                "\t\t    }",
                "\t\t    {",
                "\t\t      free (var->file);",
                "\t\t      var->file = concat_filename (unit->line_table,",
                "\t\t\t\t\t\t   attr.u.val);",
                "\t\t    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48541",
        "func_name": "ImageMagick/StreamImageCommand",
        "description": "A memory leak in ImageMagick 7.0.10-45 and 6.9.11-22 allows remote attackers to perform a denial of service via the \"identify -help\" command.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/155ebcd89ccb709522a102868e9d1a14e72d1f82",
        "commit_title": "Added missing calls to destroy methods (#2889).",
        "commit_text": "",
        "func_before": "WandExport MagickBooleanType StreamImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **metadata,ExceptionInfo *exception)\n{\n#define DestroyStream() \\\n{ \\\n  DestroyImageStack(); \\\n  stream_info=DestroyStreamInfo(stream_info); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowStreamException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n    option); \\\n  DestroyStream(); \\\n  return(MagickFalse); \\\n}\n#define ThrowStreamInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"'%s': %s\",option,argument); \\\n  DestroyStream(); \\\n  return(MagickFalse); \\\n}\n\n  char\n    *filename,\n    *option;\n\n  const char\n    *format;\n\n  Image\n    *image;\n\n  ImageStack\n    image_stack[MaxImageStackDepth+1];\n\n  MagickBooleanType\n    fire,\n    pend,\n    respect_parenthesis;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j,\n    k;\n\n  StreamInfo\n    *stream_info;\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) metadata;\n  if (argc == 2)\n    {\n      option=argv[1];\n      if ((LocaleCompare(\"version\",option+1) == 0) ||\n          (LocaleCompare(\"-version\",option+1) == 0))\n        {\n          ListMagickVersion(stdout);\n          return(MagickFalse);\n        }\n    }\n  if (argc < 3)\n    return(StreamUsage());\n  format=\"%w,%h,%m\";\n  (void) format;\n  j=1;\n  k=0;\n  NewImageStack();\n  option=(char *) NULL;\n  pend=MagickFalse;\n  respect_parenthesis=MagickFalse;\n  stream_info=AcquireStreamInfo(image_info,exception);\n  status=MagickTrue;\n  /*\n    Stream an image.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowStreamException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  status=OpenStream(image_info,stream_info,argv[argc-1],exception);\n  if (status == MagickFalse)\n    {\n      DestroyStream();\n      return(MagickFalse);\n    }\n  for (i=1; i < (ssize_t) (argc-1); i++)\n  {\n    option=argv[i];\n    if (LocaleCompare(option,\"(\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,pend);\n        if (k == MaxImageStackDepth)\n          ThrowStreamException(OptionError,\"ParenthesisNestedTooDeeply\",option);\n        PushImageStack();\n        continue;\n      }\n    if (LocaleCompare(option,\")\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n        if (k == 0)\n          ThrowStreamException(OptionError,\"UnableToParseExpression\",option);\n        PopImageStack();\n        continue;\n      }\n    if (IsCommandOption(option) == MagickFalse)\n      {\n        Image\n          *images;\n\n        /*\n          Stream input image.\n        */\n        FireImageStack(MagickFalse,MagickFalse,pend);\n        filename=argv[i];\n        if ((LocaleCompare(filename,\"--\") == 0) && (i < (ssize_t) (argc-1)))\n          filename=argv[++i];\n        (void) CopyMagickString(image_info->filename,filename,MagickPathExtent);\n        images=StreamImage(image_info,stream_info,exception);\n        status&=(images != (Image *) NULL) &&\n          (exception->severity < ErrorException);\n        if (images == (Image *) NULL)\n          continue;\n        AppendImageStack(images);\n        continue;\n      }\n    pend=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"authenticate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"cache\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            ssize_t\n              channel;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            channel=ParseChannelOption(argv[i]);\n            if (channel < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedChannelType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n              argv[i]);\n            if (colorspace < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"compress\",option+1) == 0)\n          {\n            ssize_t\n              compress;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            compress=ParseCommandOption(MagickCompressOptions,MagickFalse,\n              argv[i]);\n            if (compress < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedImageCompression\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedEventType\",argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"define\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              {\n                const char\n                  *define;\n\n                define=GetImageOption(image_info,argv[i]);\n                if (define == (const char *) NULL)\n                  ThrowStreamException(OptionError,\"NoSuchOption\",argv[i]);\n                break;\n              }\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"extract\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'h':\n      {\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          return(StreamUsage());\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"identify\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"interlace\",option+1) == 0)\n          {\n            ssize_t\n              interlace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            interlace=ParseCommandOption(MagickInterlaceOptions,MagickFalse,\n              argv[i]);\n            if (interlace < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedInterlaceType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            ssize_t\n              interpolate;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n              argv[i]);\n            if (interpolate < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedInterpolateMethod\",\n                argv[i]);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"limit\",option+1) == 0)\n          {\n            char\n              *p;\n\n            double\n              value;\n\n            ssize_t\n              resource;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            resource=ParseCommandOption(MagickResourceOptions,MagickFalse,\n              argv[i]);\n            if (resource < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedResourceType\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            value=StringToDouble(argv[i],&p);\n            (void) value;\n            if ((p == argv[i]) && (LocaleCompare(\"unlimited\",argv[i]) != 0))\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"list\",option+1) == 0)\n          {\n            ssize_t\n              list;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            list=ParseCommandOption(MagickListOptions,MagickFalse,argv[i]);\n            if (list < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedListType\",argv[i]);\n            status=MogrifyImageInfo(image_info,(int) (i-j+1),(const char **)\n              argv+j,exception);\n            DestroyStream();\n            return(status == 0 ? MagickFalse : MagickTrue);\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if ((i == (ssize_t) argc) || (strchr(argv[i],'%') == (char *) NULL))\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            (void) CopyMagickString(argv[i]+1,\"san\",MagickPathExtent);\n            if (*option == '+')\n              break;\n            i++;\n            SetStreamInfoMap(stream_info,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          break;\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quantize\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,\n              MagickFalse,argv[i]);\n            if (colorspace < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          break;\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleNCompare(\"respect-parentheses\",option+1,17) == 0)\n          {\n            respect_parenthesis=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"set\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"size\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"storage-type\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickStorageOptions,MagickFalse,argv[i]);\n            if (type < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedStorageType\",\n                argv[i]);\n            SetStreamInfoStorageType(stream_info,(StorageType) type);\n            break;\n          }\n        if (LocaleCompare(\"synchronize\",option+1) == 0)\n          break;\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 't':\n      {\n        if (LocaleCompare(\"taint\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"transparent-color\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          break;\n        if ((LocaleCompare(\"version\",option+1) == 0) ||\n            (LocaleCompare(\"-version\",option+1) == 0))\n          {\n            ListMagickVersion(stdout);\n            break;\n          }\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedVirtualPixelMethod\",\n                argv[i]);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case '?':\n        break;\n      default:\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n    }\n    fire=(GetCommandOptionFlags(MagickCommandOptions,MagickFalse,option) &\n      FireOptionFlag) == 0 ?  MagickFalse : MagickTrue;\n    if (fire != MagickFalse)\n      FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n  }\n  if (k != 0)\n    ThrowStreamException(OptionError,\"UnbalancedParenthesis\",argv[i]);\n  if (i-- != (ssize_t) (argc-1))\n    ThrowStreamException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  if (image == (Image *) NULL)\n    ThrowStreamException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  FinalizeImageSettings(image_info,image,MagickTrue);\n  if (image == (Image *) NULL)\n    ThrowStreamException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  DestroyStream();\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
        "func": "WandExport MagickBooleanType StreamImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **metadata,ExceptionInfo *exception)\n{\n#define DestroyStream() \\\n{ \\\n  DestroyImageStack(); \\\n  stream_info=DestroyStreamInfo(stream_info); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowStreamException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n    option); \\\n  DestroyStream(); \\\n  return(MagickFalse); \\\n}\n#define ThrowStreamInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"'%s': %s\",option,argument); \\\n  DestroyStream(); \\\n  return(MagickFalse); \\\n}\n\n  char\n    *filename,\n    *option;\n\n  const char\n    *format;\n\n  Image\n    *image;\n\n  ImageStack\n    image_stack[MaxImageStackDepth+1];\n\n  MagickBooleanType\n    fire,\n    pend,\n    respect_parenthesis;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    j,\n    k;\n\n  StreamInfo\n    *stream_info;\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) metadata;\n  if (argc == 2)\n    {\n      option=argv[1];\n      if ((LocaleCompare(\"version\",option+1) == 0) ||\n          (LocaleCompare(\"-version\",option+1) == 0))\n        {\n          ListMagickVersion(stdout);\n          return(MagickFalse);\n        }\n    }\n  if (argc < 3)\n    return(StreamUsage());\n  format=\"%w,%h,%m\";\n  (void) format;\n  j=1;\n  k=0;\n  NewImageStack();\n  option=(char *) NULL;\n  pend=MagickFalse;\n  respect_parenthesis=MagickFalse;\n  stream_info=AcquireStreamInfo(image_info,exception);\n  status=MagickTrue;\n  /*\n    Stream an image.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowStreamException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  status=OpenStream(image_info,stream_info,argv[argc-1],exception);\n  if (status == MagickFalse)\n    {\n      DestroyStream();\n      return(MagickFalse);\n    }\n  for (i=1; i < (ssize_t) (argc-1); i++)\n  {\n    option=argv[i];\n    if (LocaleCompare(option,\"(\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,pend);\n        if (k == MaxImageStackDepth)\n          ThrowStreamException(OptionError,\"ParenthesisNestedTooDeeply\",option);\n        PushImageStack();\n        continue;\n      }\n    if (LocaleCompare(option,\")\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n        if (k == 0)\n          ThrowStreamException(OptionError,\"UnableToParseExpression\",option);\n        PopImageStack();\n        continue;\n      }\n    if (IsCommandOption(option) == MagickFalse)\n      {\n        Image\n          *images;\n\n        /*\n          Stream input image.\n        */\n        FireImageStack(MagickFalse,MagickFalse,pend);\n        filename=argv[i];\n        if ((LocaleCompare(filename,\"--\") == 0) && (i < (ssize_t) (argc-1)))\n          filename=argv[++i];\n        (void) CopyMagickString(image_info->filename,filename,MagickPathExtent);\n        images=StreamImage(image_info,stream_info,exception);\n        status&=(images != (Image *) NULL) &&\n          (exception->severity < ErrorException);\n        if (images == (Image *) NULL)\n          continue;\n        AppendImageStack(images);\n        continue;\n      }\n    pend=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"authenticate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"cache\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            ssize_t\n              channel;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            channel=ParseChannelOption(argv[i]);\n            if (channel < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedChannelType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n              argv[i]);\n            if (colorspace < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"compress\",option+1) == 0)\n          {\n            ssize_t\n              compress;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            compress=ParseCommandOption(MagickCompressOptions,MagickFalse,\n              argv[i]);\n            if (compress < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedImageCompression\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedEventType\",argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"define\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              {\n                const char\n                  *define;\n\n                define=GetImageOption(image_info,argv[i]);\n                if (define == (const char *) NULL)\n                  ThrowStreamException(OptionError,\"NoSuchOption\",argv[i]);\n                break;\n              }\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"extract\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'h':\n      {\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          {\n            DestroyStream();\n            return(StreamUsage());\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"identify\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"interlace\",option+1) == 0)\n          {\n            ssize_t\n              interlace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            interlace=ParseCommandOption(MagickInterlaceOptions,MagickFalse,\n              argv[i]);\n            if (interlace < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedInterlaceType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            ssize_t\n              interpolate;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n              argv[i]);\n            if (interpolate < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedInterpolateMethod\",\n                argv[i]);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"limit\",option+1) == 0)\n          {\n            char\n              *p;\n\n            double\n              value;\n\n            ssize_t\n              resource;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            resource=ParseCommandOption(MagickResourceOptions,MagickFalse,\n              argv[i]);\n            if (resource < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedResourceType\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            value=StringToDouble(argv[i],&p);\n            (void) value;\n            if ((p == argv[i]) && (LocaleCompare(\"unlimited\",argv[i]) != 0))\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"list\",option+1) == 0)\n          {\n            ssize_t\n              list;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            list=ParseCommandOption(MagickListOptions,MagickFalse,argv[i]);\n            if (list < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedListType\",argv[i]);\n            status=MogrifyImageInfo(image_info,(int) (i-j+1),(const char **)\n              argv+j,exception);\n            DestroyStream();\n            return(status == 0 ? MagickFalse : MagickTrue);\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if ((i == (ssize_t) argc) || (strchr(argv[i],'%') == (char *) NULL))\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            (void) CopyMagickString(argv[i]+1,\"san\",MagickPathExtent);\n            if (*option == '+')\n              break;\n            i++;\n            SetStreamInfoMap(stream_info,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          break;\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quantize\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,\n              MagickFalse,argv[i]);\n            if (colorspace < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          break;\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleNCompare(\"respect-parentheses\",option+1,17) == 0)\n          {\n            respect_parenthesis=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"set\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"size\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowStreamInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"storage-type\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickStorageOptions,MagickFalse,argv[i]);\n            if (type < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedStorageType\",\n                argv[i]);\n            SetStreamInfoStorageType(stream_info,(StorageType) type);\n            break;\n          }\n        if (LocaleCompare(\"synchronize\",option+1) == 0)\n          break;\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 't':\n      {\n        if (LocaleCompare(\"taint\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"transparent-color\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          break;\n        if ((LocaleCompare(\"version\",option+1) == 0) ||\n            (LocaleCompare(\"-version\",option+1) == 0))\n          {\n            ListMagickVersion(stdout);\n            break;\n          }\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowStreamException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowStreamException(OptionError,\"UnrecognizedVirtualPixelMethod\",\n                argv[i]);\n            break;\n          }\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case '?':\n        break;\n      default:\n        ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n    }\n    fire=(GetCommandOptionFlags(MagickCommandOptions,MagickFalse,option) &\n      FireOptionFlag) == 0 ?  MagickFalse : MagickTrue;\n    if (fire != MagickFalse)\n      FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n  }\n  if (k != 0)\n    ThrowStreamException(OptionError,\"UnbalancedParenthesis\",argv[i]);\n  if (i-- != (ssize_t) (argc-1))\n    ThrowStreamException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  if (image == (Image *) NULL)\n    ThrowStreamException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  FinalizeImageSettings(image_info,image,MagickTrue);\n  if (image == (Image *) NULL)\n    ThrowStreamException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  DestroyStream();\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -312,7 +312,10 @@\n       {\n         if ((LocaleCompare(\"help\",option+1) == 0) ||\n             (LocaleCompare(\"-help\",option+1) == 0))\n-          return(StreamUsage());\n+          {\n+            DestroyStream();\n+            return(StreamUsage());\n+          }\n         ThrowStreamException(OptionError,\"UnrecognizedOption\",option)\n       }\n       case 'i':",
        "diff_line_info": {
            "deleted_lines": [
                "          return(StreamUsage());"
            ],
            "added_lines": [
                "          {",
                "            DestroyStream();",
                "            return(StreamUsage());",
                "          }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48541",
        "func_name": "ImageMagick/ConjureImageCommand",
        "description": "A memory leak in ImageMagick 7.0.10-45 and 6.9.11-22 allows remote attackers to perform a denial of service via the \"identify -help\" command.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/155ebcd89ccb709522a102868e9d1a14e72d1f82",
        "commit_title": "Added missing calls to destroy methods (#2889).",
        "commit_text": "",
        "func_before": "WandExport MagickBooleanType ConjureImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **wand_unused(metadata),ExceptionInfo *exception)\n{\n#define DestroyConjure() \\\n{ \\\n  image=DestroyImageList(image); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowConjureException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n     option); \\\n  DestroyConjure(); \\\n  return(MagickFalse); \\\n}\n#define ThrowConjureInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"'%s': %s\",option,argument); \\\n  DestroyConjure(); \\\n  return(MagickFalse); \\\n}\n\n  char\n    filename[MagickPathExtent],\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    number_images;\n\n  wand_unreferenced(metadata);\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  if (argc < 2)\n    return(ConjureUsage());\n  image=NewImageList();\n  number_images=0;\n  option=(char *) NULL;\n  /*\n    Conjure an image.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowConjureException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  for (i=1; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (IsCommandOption(option) != MagickFalse)\n      {\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowConjureException(OptionError,\"UnrecognizedEventType\",\n                argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            continue;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowConjureInvalidArgumentException(option,argv[i]);\n            continue;\n          }\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          {\n            if (*option == '-')\n              return(ConjureUsage());\n            continue;\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '-')\n              {\n                i++;\n                if (i == (ssize_t) argc)\n                  ThrowConjureException(OptionError,\"MissingLogFormat\",option);\n                (void) SetLogFormat(argv[i]);\n              }\n            continue;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          continue;\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          continue;\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowConjureInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            image_info->verbose=(*option == '-') ? MagickTrue : MagickFalse;\n            continue;\n          }\n        if ((LocaleCompare(\"version\",option+1) == 0) ||\n            (LocaleCompare(\"-version\",option+1) == 0))\n          {\n            ListMagickVersion(stdout);\n            return(MagickTrue);\n          }\n        /*\n          Persist key/value pair.\n        */\n        (void) DeleteImageOption(image_info,option+1);\n        status=SetImageOption(image_info,option+1,argv[i+1]);\n        if (status == MagickFalse)\n          ThrowConjureException(ImageError,\"UnableToPersistKey\",option);\n        i++;\n        continue;\n      }\n    /*\n      Interpret MSL script.\n    */\n    (void) DeleteImageOption(image_info,\"filename\");\n    status=SetImageOption(image_info,\"filename\",argv[i]);\n    if (status == MagickFalse)\n      ThrowConjureException(ImageError,\"UnableToPersistKey\",argv[i]);\n    (void) FormatLocaleString(filename,MagickPathExtent,\"%s\",argv[i]);\n    image=ReadImages(image_info,filename,exception);\n    CatchException(exception);\n    if (image != (Image *) NULL)\n      image=DestroyImageList(image);\n    status=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    number_images++;\n  }\n  if (i != (ssize_t) argc)\n    ThrowConjureException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  if (number_images == 0)\n    ThrowConjureException(OptionError,\"MissingAnImageFilename\",argv[argc-1]);\n  if (image != (Image *) NULL)\n    image=DestroyImageList(image);\n  for (i=0; i < (ssize_t) argc; i++)\n    argv[i]=DestroyString(argv[i]);\n  argv=(char **) RelinquishMagickMemory(argv);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
        "func": "WandExport MagickBooleanType ConjureImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **wand_unused(metadata),ExceptionInfo *exception)\n{\n#define DestroyConjure() \\\n{ \\\n  image=DestroyImageList(image); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowConjureException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n     option); \\\n  DestroyConjure(); \\\n  return(MagickFalse); \\\n}\n#define ThrowConjureInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"'%s': %s\",option,argument); \\\n  DestroyConjure(); \\\n  return(MagickFalse); \\\n}\n\n  char\n    filename[MagickPathExtent],\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    number_images;\n\n  wand_unreferenced(metadata);\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  if (argc < 2)\n    return(ConjureUsage());\n  image=NewImageList();\n  number_images=0;\n  option=(char *) NULL;\n  /*\n    Conjure an image.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowConjureException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  for (i=1; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (IsCommandOption(option) != MagickFalse)\n      {\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowConjureException(OptionError,\"UnrecognizedEventType\",\n                argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            continue;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowConjureInvalidArgumentException(option,argv[i]);\n            continue;\n          }\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          {\n            if (*option == '-')\n              {\n                DestroyConjure();\n                return(ConjureUsage());\n              }\n            continue;\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '-')\n              {\n                i++;\n                if (i == (ssize_t) argc)\n                  ThrowConjureException(OptionError,\"MissingLogFormat\",option);\n                (void) SetLogFormat(argv[i]);\n              }\n            continue;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          continue;\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          continue;\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowConjureInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            image_info->verbose=(*option == '-') ? MagickTrue : MagickFalse;\n            continue;\n          }\n        if ((LocaleCompare(\"version\",option+1) == 0) ||\n            (LocaleCompare(\"-version\",option+1) == 0))\n          {\n            ListMagickVersion(stdout);\n            return(MagickTrue);\n          }\n        /*\n          Persist key/value pair.\n        */\n        (void) DeleteImageOption(image_info,option+1);\n        status=SetImageOption(image_info,option+1,argv[i+1]);\n        if (status == MagickFalse)\n          ThrowConjureException(ImageError,\"UnableToPersistKey\",option);\n        i++;\n        continue;\n      }\n    /*\n      Interpret MSL script.\n    */\n    (void) DeleteImageOption(image_info,\"filename\");\n    status=SetImageOption(image_info,\"filename\",argv[i]);\n    if (status == MagickFalse)\n      ThrowConjureException(ImageError,\"UnableToPersistKey\",argv[i]);\n    (void) FormatLocaleString(filename,MagickPathExtent,\"%s\",argv[i]);\n    image=ReadImages(image_info,filename,exception);\n    CatchException(exception);\n    if (image != (Image *) NULL)\n      image=DestroyImageList(image);\n    status=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    number_images++;\n  }\n  if (i != (ssize_t) argc)\n    ThrowConjureException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  if (number_images == 0)\n    ThrowConjureException(OptionError,\"MissingAnImageFilename\",argv[argc-1]);\n  if (image != (Image *) NULL)\n    image=DestroyImageList(image);\n  for (i=0; i < (ssize_t) argc; i++)\n    argv[i]=DestroyString(argv[i]);\n  argv=(char **) RelinquishMagickMemory(argv);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -101,7 +101,10 @@\n             (LocaleCompare(\"-help\",option+1) == 0))\n           {\n             if (*option == '-')\n-              return(ConjureUsage());\n+              {\n+                DestroyConjure();\n+                return(ConjureUsage());\n+              }\n             continue;\n           }\n         if (LocaleCompare(\"log\",option+1) == 0)",
        "diff_line_info": {
            "deleted_lines": [
                "              return(ConjureUsage());"
            ],
            "added_lines": [
                "              {",
                "                DestroyConjure();",
                "                return(ConjureUsage());",
                "              }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48541",
        "func_name": "ImageMagick/IdentifyImageCommand",
        "description": "A memory leak in ImageMagick 7.0.10-45 and 6.9.11-22 allows remote attackers to perform a denial of service via the \"identify -help\" command.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/155ebcd89ccb709522a102868e9d1a14e72d1f82",
        "commit_title": "Added missing calls to destroy methods (#2889).",
        "commit_text": "",
        "func_before": "WandExport MagickBooleanType IdentifyImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **metadata,ExceptionInfo *exception)\n{\n#define DestroyIdentify() \\\n{ \\\n  DestroyImageStack(); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowIdentifyException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n    option); \\\n  DestroyIdentify(); \\\n  return(MagickFalse); \\\n}\n#define ThrowIdentifyInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"'%s': %s\",option,argument); \\\n  DestroyIdentify(); \\\n  return(MagickFalse); \\\n}\n\n  const char\n    *format,\n    *option;\n\n  Image\n    *image;\n\n  ImageStack\n    image_stack[MaxImageStackDepth+1];\n\n  MagickBooleanType\n    fire,\n    pend,\n    respect_parenthesis;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    j,\n    k;\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  if (argc == 2)\n    {\n      option=argv[1];\n      if ((LocaleCompare(\"version\",option+1) == 0) ||\n          (LocaleCompare(\"-version\",option+1) == 0))\n        {\n          ListMagickVersion(stdout);\n          return(MagickTrue);\n        }\n    }\n  if (argc < 2)\n    return(IdentifyUsage());\n  count=0;\n  format=NULL;\n  j=1;\n  k=0;\n  NewImageStack();\n  option=(char *) NULL;\n  pend=MagickFalse;\n  respect_parenthesis=MagickFalse;\n  status=MagickTrue;\n  /*\n    Identify an image.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowIdentifyException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  image_info->ping=MagickTrue;\n  for (i=1; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (LocaleCompare(option,\"(\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,pend);\n        if (k == MaxImageStackDepth)\n          ThrowIdentifyException(OptionError,\"ParenthesisNestedTooDeeply\",\n            option);\n        PushImageStack();\n        continue;\n      }\n    if (LocaleCompare(option,\")\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n        if (k == 0)\n          ThrowIdentifyException(OptionError,\"UnableToParseExpression\",option);\n        PopImageStack();\n        continue;\n      }\n    if (IsCommandOption(option) == MagickFalse)\n      {\n        char\n          *filename;\n\n        Image\n          *images;\n\n        ImageInfo\n          *identify_info;\n\n        /*\n          Read input image.\n        */\n        FireImageStack(MagickFalse,MagickFalse,pend);\n        identify_info=CloneImageInfo(image_info);\n        identify_info->verbose=MagickFalse;\n        filename=argv[i];\n        if ((LocaleCompare(filename,\"--\") == 0) && (i < (ssize_t) (argc-1)))\n          filename=argv[++i];\n        if (identify_info->ping != MagickFalse)\n          images=PingImages(identify_info,filename,exception);\n        else\n          images=ReadImages(identify_info,filename,exception);\n        identify_info=DestroyImageInfo(identify_info);\n        status&=(images != (Image *) NULL) &&\n          (exception->severity < ErrorException);\n        if (images == (Image *) NULL)\n          continue;\n        AppendImageStack(images);\n        FinalizeImageSettings(image_info,image,MagickFalse);\n        count=0;\n        for ( ; image != (Image *) NULL; image=GetNextImageInList(image))\n        {\n          if (image->scene == 0)\n            image->scene=count++;\n          if (format == (char *) NULL)\n            {\n              (void) IdentifyImage(image,stdout,image_info->verbose,exception);\n              continue;\n            }\n          if (metadata != (char **) NULL)\n            {\n              char\n                *text;\n\n              text=InterpretImageProperties(image_info,image,format,exception);\n              if (text == (char *) NULL)\n                ThrowIdentifyException(ResourceLimitError,\n                  \"MemoryAllocationFailed\",GetExceptionMessage(errno));\n              (void) ConcatenateString(&(*metadata),text);\n              text=DestroyString(text);\n            }\n        }\n        RemoveAllImageStack();\n        continue;\n      }\n    pend=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"alpha\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,\n              argv[i]);\n            if (type < 0)\n              ThrowIdentifyException(OptionError,\n                \"UnrecognizedAlphaChannelOption\",argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"antialias\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"authenticate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"cache\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            ssize_t\n              channel;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            channel=ParseChannelOption(argv[i]);\n            if (channel < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedChannelType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"clip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"clip-mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"clip-path\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,\n              MagickFalse,argv[i]);\n            if (colorspace < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"crop\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            image_info->ping=MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedEventType\",\n                argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"define\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              {\n                const char\n                  *define;\n\n                define=GetImageOption(image_info,argv[i]);\n                if (define == (const char *) NULL)\n                  ThrowIdentifyException(OptionError,\"NoSuchOption\",argv[i]);\n                break;\n              }\n            if (LocaleNCompare(\"identify:locate\",argv[i],15) == 0)\n              image_info->ping=MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"endian\",option+1) == 0)\n          {\n            ssize_t\n              endian;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            endian=ParseCommandOption(MagickEndianOptions,MagickFalse,\n              argv[i]);\n            if (endian < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedEndianType\",\n                argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"features\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"format\",option+1) == 0)\n          {\n            format=(char *) NULL;\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            format=argv[i];\n            break;\n          }\n        if (LocaleCompare(\"fuzz\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'g':\n      {\n        if (LocaleCompare(\"gamma\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"grayscale\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickPixelIntensityOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedIntensityMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"green-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'h':\n      {\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          return(IdentifyUsage());\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"interlace\",option+1) == 0)\n          {\n            ssize_t\n              interlace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            interlace=ParseCommandOption(MagickInterlaceOptions,MagickFalse,\n              argv[i]);\n            if (interlace < 0)\n              ThrowIdentifyException(OptionError,\n                \"UnrecognizedInterlaceType\",argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            ssize_t\n              interpolate;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n              argv[i]);\n            if (interpolate < 0)\n              ThrowIdentifyException(OptionError,\n                \"UnrecognizedInterpolateMethod\",argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"limit\",option+1) == 0)\n          {\n            char\n              *p;\n\n            double\n              value;\n\n            ssize_t\n              resource;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            resource=ParseCommandOption(MagickResourceOptions,MagickFalse,\n              argv[i]);\n            if (resource < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedResourceType\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            value=StringToDouble(argv[i],&p);\n            (void) value;\n            if ((p == argv[i]) && (LocaleCompare(\"unlimited\",argv[i]) != 0))\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"list\",option+1) == 0)\n          {\n            ssize_t\n              list;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            list=ParseCommandOption(MagickListOptions,MagickFalse,argv[i]);\n            if (list < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedListType\",\n                argv[i]);\n            status=MogrifyImageInfo(image_info,(int) (i-j+1),(const char **)\n              argv+j,exception);\n            DestroyIdentify();\n            return(status == 0 ? MagickFalse : MagickTrue);\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if ((i == (ssize_t) argc) ||\n                (strchr(argv[i],'%') == (char *) NULL))\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"matte\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"moments\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          break;\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'n':\n      {\n        if (LocaleCompare(\"negate\",option+1) == 0)\n          break;\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"ping\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"precision\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          break;\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleNCompare(\"respect-parentheses\",option+1,17) == 0)\n          {\n            respect_parenthesis=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"set\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"size\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"strip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"support\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'u':\n      {\n        if (LocaleCompare(\"unique\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"units\",option+1) == 0)\n          {\n            ssize_t\n              units;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            units=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n              argv[i]);\n            if (units < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedUnitsType\",\n                argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowIdentifyException(OptionError,\n                \"UnrecognizedVirtualPixelMethod\",argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case '?':\n        break;\n      default:\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n    }\n    fire=(GetCommandOptionFlags(MagickCommandOptions,MagickFalse,option) &\n      FireOptionFlag) == 0 ?  MagickFalse : MagickTrue;\n    if (fire != MagickFalse)\n      FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n  }\n  if (k != 0)\n    ThrowIdentifyException(OptionError,\"UnbalancedParenthesis\",argv[i]);\n  if (i != (ssize_t) argc)\n    ThrowIdentifyException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  DestroyIdentify();\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
        "func": "WandExport MagickBooleanType IdentifyImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **metadata,ExceptionInfo *exception)\n{\n#define DestroyIdentify() \\\n{ \\\n  DestroyImageStack(); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowIdentifyException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n    option); \\\n  DestroyIdentify(); \\\n  return(MagickFalse); \\\n}\n#define ThrowIdentifyInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"'%s': %s\",option,argument); \\\n  DestroyIdentify(); \\\n  return(MagickFalse); \\\n}\n\n  const char\n    *format,\n    *option;\n\n  Image\n    *image;\n\n  ImageStack\n    image_stack[MaxImageStackDepth+1];\n\n  MagickBooleanType\n    fire,\n    pend,\n    respect_parenthesis;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    j,\n    k;\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  if (argc == 2)\n    {\n      option=argv[1];\n      if ((LocaleCompare(\"version\",option+1) == 0) ||\n          (LocaleCompare(\"-version\",option+1) == 0))\n        {\n          ListMagickVersion(stdout);\n          return(MagickTrue);\n        }\n    }\n  if (argc < 2)\n    return(IdentifyUsage());\n  count=0;\n  format=NULL;\n  j=1;\n  k=0;\n  NewImageStack();\n  option=(char *) NULL;\n  pend=MagickFalse;\n  respect_parenthesis=MagickFalse;\n  status=MagickTrue;\n  /*\n    Identify an image.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowIdentifyException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  image_info->ping=MagickTrue;\n  for (i=1; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (LocaleCompare(option,\"(\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,pend);\n        if (k == MaxImageStackDepth)\n          ThrowIdentifyException(OptionError,\"ParenthesisNestedTooDeeply\",\n            option);\n        PushImageStack();\n        continue;\n      }\n    if (LocaleCompare(option,\")\") == 0)\n      {\n        FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n        if (k == 0)\n          ThrowIdentifyException(OptionError,\"UnableToParseExpression\",option);\n        PopImageStack();\n        continue;\n      }\n    if (IsCommandOption(option) == MagickFalse)\n      {\n        char\n          *filename;\n\n        Image\n          *images;\n\n        ImageInfo\n          *identify_info;\n\n        /*\n          Read input image.\n        */\n        FireImageStack(MagickFalse,MagickFalse,pend);\n        identify_info=CloneImageInfo(image_info);\n        identify_info->verbose=MagickFalse;\n        filename=argv[i];\n        if ((LocaleCompare(filename,\"--\") == 0) && (i < (ssize_t) (argc-1)))\n          filename=argv[++i];\n        if (identify_info->ping != MagickFalse)\n          images=PingImages(identify_info,filename,exception);\n        else\n          images=ReadImages(identify_info,filename,exception);\n        identify_info=DestroyImageInfo(identify_info);\n        status&=(images != (Image *) NULL) &&\n          (exception->severity < ErrorException);\n        if (images == (Image *) NULL)\n          continue;\n        AppendImageStack(images);\n        FinalizeImageSettings(image_info,image,MagickFalse);\n        count=0;\n        for ( ; image != (Image *) NULL; image=GetNextImageInList(image))\n        {\n          if (image->scene == 0)\n            image->scene=count++;\n          if (format == (char *) NULL)\n            {\n              (void) IdentifyImage(image,stdout,image_info->verbose,exception);\n              continue;\n            }\n          if (metadata != (char **) NULL)\n            {\n              char\n                *text;\n\n              text=InterpretImageProperties(image_info,image,format,exception);\n              if (text == (char *) NULL)\n                ThrowIdentifyException(ResourceLimitError,\n                  \"MemoryAllocationFailed\",GetExceptionMessage(errno));\n              (void) ConcatenateString(&(*metadata),text);\n              text=DestroyString(text);\n            }\n        }\n        RemoveAllImageStack();\n        continue;\n      }\n    pend=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"alpha\",option+1) == 0)\n          {\n            ssize_t\n              type;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            type=ParseCommandOption(MagickAlphaChannelOptions,MagickFalse,\n              argv[i]);\n            if (type < 0)\n              ThrowIdentifyException(OptionError,\n                \"UnrecognizedAlphaChannelOption\",argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"antialias\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"authenticate\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"cache\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"channel\",option+1) == 0)\n          {\n            ssize_t\n              channel;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            channel=ParseChannelOption(argv[i]);\n            if (channel < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedChannelType\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"clip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"clip-mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"clip-path\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"colorspace\",option+1) == 0)\n          {\n            ssize_t\n              colorspace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            colorspace=ParseCommandOption(MagickColorspaceOptions,\n              MagickFalse,argv[i]);\n            if (colorspace < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedColorspace\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"crop\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            image_info->ping=MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedEventType\",\n                argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"define\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              {\n                const char\n                  *define;\n\n                define=GetImageOption(image_info,argv[i]);\n                if (define == (const char *) NULL)\n                  ThrowIdentifyException(OptionError,\"NoSuchOption\",argv[i]);\n                break;\n              }\n            if (LocaleNCompare(\"identify:locate\",argv[i],15) == 0)\n              image_info->ping=MagickFalse;\n            break;\n          }\n        if (LocaleCompare(\"density\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"depth\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"endian\",option+1) == 0)\n          {\n            ssize_t\n              endian;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            endian=ParseCommandOption(MagickEndianOptions,MagickFalse,\n              argv[i]);\n            if (endian < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedEndianType\",\n                argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"features\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"format\",option+1) == 0)\n          {\n            format=(char *) NULL;\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            format=argv[i];\n            break;\n          }\n        if (LocaleCompare(\"fuzz\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'g':\n      {\n        if (LocaleCompare(\"gamma\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"grayscale\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickPixelIntensityOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedIntensityMethod\",\n                argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"green-primary\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'h':\n      {\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          {\n            DestroyIdentify();\n            return(IdentifyUsage());\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"interlace\",option+1) == 0)\n          {\n            ssize_t\n              interlace;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            interlace=ParseCommandOption(MagickInterlaceOptions,MagickFalse,\n              argv[i]);\n            if (interlace < 0)\n              ThrowIdentifyException(OptionError,\n                \"UnrecognizedInterlaceType\",argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            ssize_t\n              interpolate;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n              argv[i]);\n            if (interpolate < 0)\n              ThrowIdentifyException(OptionError,\n                \"UnrecognizedInterpolateMethod\",argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"limit\",option+1) == 0)\n          {\n            char\n              *p;\n\n            double\n              value;\n\n            ssize_t\n              resource;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            resource=ParseCommandOption(MagickResourceOptions,MagickFalse,\n              argv[i]);\n            if (resource < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedResourceType\",\n                argv[i]);\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            value=StringToDouble(argv[i],&p);\n            (void) value;\n            if ((p == argv[i]) && (LocaleCompare(\"unlimited\",argv[i]) != 0))\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"list\",option+1) == 0)\n          {\n            ssize_t\n              list;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            list=ParseCommandOption(MagickListOptions,MagickFalse,argv[i]);\n            if (list < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedListType\",\n                argv[i]);\n            status=MogrifyImageInfo(image_info,(int) (i-j+1),(const char **)\n              argv+j,exception);\n            DestroyIdentify();\n            return(status == 0 ? MagickFalse : MagickTrue);\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if ((i == (ssize_t) argc) ||\n                (strchr(argv[i],'%') == (char *) NULL))\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"mask\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"matte\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"moments\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          break;\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'n':\n      {\n        if (LocaleCompare(\"negate\",option+1) == 0)\n          break;\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"ping\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"precision\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'q':\n      {\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          break;\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleNCompare(\"respect-parentheses\",option+1,17) == 0)\n          {\n            respect_parenthesis=(*option == '-') ? MagickTrue : MagickFalse;\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"sampling-factor\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"set\",option+1) == 0)\n          {\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            break;\n          }\n        if (LocaleCompare(\"size\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"strip\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"support\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowIdentifyInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'u':\n      {\n        if (LocaleCompare(\"unique\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"units\",option+1) == 0)\n          {\n            ssize_t\n              units;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            units=ParseCommandOption(MagickResolutionOptions,MagickFalse,\n              argv[i]);\n            if (units < 0)\n              ThrowIdentifyException(OptionError,\"UnrecognizedUnitsType\",\n                argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case 'v':\n      {\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"virtual-pixel\",option+1) == 0)\n          {\n            ssize_t\n              method;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowIdentifyException(OptionError,\"MissingArgument\",option);\n            method=ParseCommandOption(MagickVirtualPixelOptions,MagickFalse,\n              argv[i]);\n            if (method < 0)\n              ThrowIdentifyException(OptionError,\n                \"UnrecognizedVirtualPixelMethod\",argv[i]);\n            break;\n          }\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n      }\n      case '?':\n        break;\n      default:\n        ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n    }\n    fire=(GetCommandOptionFlags(MagickCommandOptions,MagickFalse,option) &\n      FireOptionFlag) == 0 ?  MagickFalse : MagickTrue;\n    if (fire != MagickFalse)\n      FireImageStack(MagickFalse,MagickTrue,MagickTrue);\n  }\n  if (k != 0)\n    ThrowIdentifyException(OptionError,\"UnbalancedParenthesis\",argv[i]);\n  if (i != (ssize_t) argc)\n    ThrowIdentifyException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  DestroyIdentify();\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -457,7 +457,10 @@\n       {\n         if ((LocaleCompare(\"help\",option+1) == 0) ||\n             (LocaleCompare(\"-help\",option+1) == 0))\n-          return(IdentifyUsage());\n+          {\n+            DestroyIdentify();\n+            return(IdentifyUsage());\n+          }\n         ThrowIdentifyException(OptionError,\"UnrecognizedOption\",option)\n       }\n       case 'i':",
        "diff_line_info": {
            "deleted_lines": [
                "          return(IdentifyUsage());"
            ],
            "added_lines": [
                "          {",
                "            DestroyIdentify();",
                "            return(IdentifyUsage());",
                "          }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-4513",
        "func_name": "wireshark/wmem_block_fast_alloc",
        "description": "BT SDP dissector memory leak in Wireshark 4.0.0 to 4.0.7 and 3.6.0 to 3.6.15 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/d086f2733bc611eb310aafec51bd28d44166fa42",
        "commit_title": "wmem: Fix leak in block_fast when realloc'ing jumbo blocks",
        "commit_text": " In block fast wmem_allocator is used, keep the double linked list of jumbo blocks accurate by pointing the prev pointer of the old head (if it exists) to the newly allocated jumbo block.  This prevents a leak if a jumbo block which is not the most recently added jumbo block is realloc'ed. If the prev pointer isn't set properly, then all the jumbo blocks added afterwards will be lost from the list and leaked.  Fix #19259 ",
        "func_before": "static void *\nwmem_block_fast_alloc(void *private_data, const size_t size)\n{\n    wmem_block_fast_allocator_t *allocator = (wmem_block_fast_allocator_t*) private_data;\n    wmem_block_fast_chunk_t     *chunk;\n    int32_t real_size;\n\n    if (size > WMEM_BLOCK_MAX_ALLOC_SIZE) {\n        wmem_block_fast_jumbo_t *block;\n\n        /* allocate/initialize a new block of the necessary size */\n        block = (wmem_block_fast_jumbo_t *)wmem_alloc(NULL,\n                size + WMEM_JUMBO_HEADER_SIZE + WMEM_CHUNK_HEADER_SIZE);\n\n        block->next = allocator->jumbo_list;\n        block->prev = NULL;\n        allocator->jumbo_list = block;\n\n        chunk = ((wmem_block_fast_chunk_t*)((uint8_t*)(block) + WMEM_JUMBO_HEADER_SIZE));\n        chunk->len = JUMBO_MAGIC;\n\n        return WMEM_CHUNK_TO_DATA(chunk);\n    }\n\n    real_size = (int32_t)(WMEM_ALIGN_SIZE(size) + WMEM_CHUNK_HEADER_SIZE);\n\n    /* Allocate a new block if necessary. */\n    if (!allocator->block_list ||\n            (WMEM_BLOCK_SIZE - allocator->block_list->pos) < real_size) {\n        wmem_block_fast_new_block(allocator);\n    }\n\n    chunk = (wmem_block_fast_chunk_t *) ((uint8_t *) allocator->block_list + allocator->block_list->pos);\n    /* safe to cast, size smaller than WMEM_BLOCK_MAX_ALLOC_SIZE */\n    chunk->len = (uint32_t) size;\n\n    allocator->block_list->pos += real_size;\n\n    /* and return the user's pointer */\n    return WMEM_CHUNK_TO_DATA(chunk);\n}",
        "func": "static void *\nwmem_block_fast_alloc(void *private_data, const size_t size)\n{\n    wmem_block_fast_allocator_t *allocator = (wmem_block_fast_allocator_t*) private_data;\n    wmem_block_fast_chunk_t     *chunk;\n    int32_t real_size;\n\n    if (size > WMEM_BLOCK_MAX_ALLOC_SIZE) {\n        wmem_block_fast_jumbo_t *block;\n\n        /* allocate/initialize a new block of the necessary size */\n        block = (wmem_block_fast_jumbo_t *)wmem_alloc(NULL,\n                size + WMEM_JUMBO_HEADER_SIZE + WMEM_CHUNK_HEADER_SIZE);\n\n        block->next = allocator->jumbo_list;\n        if (block->next) {\n            block->next->prev = block;\n        }\n        block->prev = NULL;\n        allocator->jumbo_list = block;\n\n        chunk = ((wmem_block_fast_chunk_t*)((uint8_t*)(block) + WMEM_JUMBO_HEADER_SIZE));\n        chunk->len = JUMBO_MAGIC;\n\n        return WMEM_CHUNK_TO_DATA(chunk);\n    }\n\n    real_size = (int32_t)(WMEM_ALIGN_SIZE(size) + WMEM_CHUNK_HEADER_SIZE);\n\n    /* Allocate a new block if necessary. */\n    if (!allocator->block_list ||\n            (WMEM_BLOCK_SIZE - allocator->block_list->pos) < real_size) {\n        wmem_block_fast_new_block(allocator);\n    }\n\n    chunk = (wmem_block_fast_chunk_t *) ((uint8_t *) allocator->block_list + allocator->block_list->pos);\n    /* safe to cast, size smaller than WMEM_BLOCK_MAX_ALLOC_SIZE */\n    chunk->len = (uint32_t) size;\n\n    allocator->block_list->pos += real_size;\n\n    /* and return the user's pointer */\n    return WMEM_CHUNK_TO_DATA(chunk);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,9 @@\n                 size + WMEM_JUMBO_HEADER_SIZE + WMEM_CHUNK_HEADER_SIZE);\n \n         block->next = allocator->jumbo_list;\n+        if (block->next) {\n+            block->next->prev = block;\n+        }\n         block->prev = NULL;\n         allocator->jumbo_list = block;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (block->next) {",
                "            block->next->prev = block;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28366",
        "func_name": "eclipse/mosquitto/packet__queue",
        "description": "The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",
        "git_url": "https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9",
        "commit_title": "Fix for CVE-2023-28366",
        "commit_text": "",
        "func_before": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\n\t/* Write a single byte to sockpairW (connected to sockpairR) to break out\n\t * of select() if in threaded mode. */\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}",
        "func": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\n\t/* Write a single byte to sockpairW (connected to sockpairR) to break out\n\t * of select() if in threaded mode. */\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,21 @@\n \n \tpacket->next = NULL;\n \tpthread_mutex_lock(&mosq->out_packet_mutex);\n+\n+#ifdef WITH_BROKER\n+\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n+\t\tmosquitto__free(packet);\n+\t\tif(mosq->is_dropping == false){\n+\t\t\tmosq->is_dropping = true;\n+\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n+\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n+\t\t\t\t\tmosq->id);\n+\t\t}\n+\t\tG_MSGS_DROPPED_INC();\n+\t\treturn MOSQ_ERR_SUCCESS;\n+\t}\n+#endif\n+\n \tif(mosq->out_packet){\n \t\tmosq->out_packet_last->next = packet;\n \t}else{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "#ifdef WITH_BROKER",
                "\tif(mosq->out_packet_count >= db.config->max_queued_messages){",
                "\t\tmosquitto__free(packet);",
                "\t\tif(mosq->is_dropping == false){",
                "\t\t\tmosq->is_dropping = true;",
                "\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,",
                "\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",",
                "\t\t\t\t\tmosq->id);",
                "\t\t}",
                "\t\tG_MSGS_DROPPED_INC();",
                "\t\treturn MOSQ_ERR_SUCCESS;",
                "\t}",
                "#endif",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28366",
        "func_name": "eclipse/mosquitto/db__message_insert",
        "description": "The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",
        "git_url": "https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9",
        "commit_title": "Fix for CVE-2023-28366",
        "commit_text": "",
        "func_before": "int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n{\n\tstruct mosquitto_client_msg *msg;\n\tstruct mosquitto_msg_data *msg_data;\n\tenum mosquitto_msg_state state = mosq_ms_invalid;\n\tint rc = 0;\n\tint i;\n\tchar **dest_ids;\n\n\tassert(stored);\n\tif(!context) return MOSQ_ERR_INVAL;\n\tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n\n\tif(dir == mosq_md_out){\n\t\tmsg_data = &context->msgs_out;\n\t}else{\n\t\tmsg_data = &context->msgs_in;\n\t}\n\n\t/* Check whether we've already sent this message to this client\n\t * for outgoing messages only.\n\t * If retain==true then this is a stale retained message and so should be\n\t * sent regardless. FIXME - this does mean retained messages will received\n\t * multiple times for overlapping subscriptions, although this is only the\n\t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n\t */\n\tif(context->protocol != mosq_p_mqtt5\n\t\t\t&& db.config->allow_duplicate_messages == false\n\t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n\n\t\tfor(i=0; i<stored->dest_id_count; i++){\n\t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n\t\t\t\t/* We have already sent this message to this client. */\n\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\tif(context->sock == INVALID_SOCKET){\n\t\t/* Client is not connected only queue messages with QoS>0. */\n\t\tif(qos == 0 && !db.config->queue_qos0_messages){\n\t\t\tif(!context->bridge){\n\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\treturn 2;\n\t\t\t}else{\n\t\t\t\tif(context->bridge->start_type != bst_lazy){\n\t\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(context->bridge && context->bridge->clean_start_local == true){\n\t\t\tmosquitto_property_free_all(&properties);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif(context->sock != INVALID_SOCKET){\n\t\tif(db__ready_for_flight(context, dir, qos)){\n\t\t\tif(dir == mosq_md_out){\n\t\t\t\tswitch(qos){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tstate = mosq_ms_publish_qos0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstate = mosq_ms_publish_qos1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tstate = mosq_ms_publish_qos2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(qos == 2){\n\t\t\t\t\tstate = mosq_ms_wait_for_pubrel;\n\t\t\t\t}else{\n\t\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n\t\t\tstate = mosq_ms_queued;\n\t\t\trc = 2;\n\t\t}else{\n\t\t\t/* Dropping message due to full queue. */\n\t\t\tif(context->is_dropping == false){\n\t\t\t\tcontext->is_dropping = true;\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\t\tcontext->id);\n\t\t\t}\n\t\t\tG_MSGS_DROPPED_INC();\n\t\t\tmosquitto_property_free_all(&properties);\n\t\t\treturn 2;\n\t\t}\n\t}else{\n\t\tif (db__ready_for_queue(context, qos, msg_data)){\n\t\t\tstate = mosq_ms_queued;\n\t\t}else{\n\t\t\tG_MSGS_DROPPED_INC();\n\t\t\tif(context->is_dropping == false){\n\t\t\t\tcontext->is_dropping = true;\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\t\tcontext->id);\n\t\t\t}\n\t\t\tmosquitto_property_free_all(&properties);\n\t\t\treturn 2;\n\t\t}\n\t}\n\tassert(state != mosq_ms_invalid);\n\n#ifdef WITH_PERSISTENCE\n\tif(state == mosq_ms_queued){\n\t\tdb.persistence_changes++;\n\t}\n#endif\n\n\tmsg = mosquitto__malloc(sizeof(struct mosquitto_client_msg));\n\tif(!msg) return MOSQ_ERR_NOMEM;\n\tmsg->prev = NULL;\n\tmsg->next = NULL;\n\tmsg->store = stored;\n\tdb__msg_store_ref_inc(msg->store);\n\tmsg->mid = mid;\n\tmsg->timestamp = db.now_s;\n\tmsg->direction = dir;\n\tmsg->state = state;\n\tmsg->dup = false;\n\tif(qos > context->max_qos){\n\t\tmsg->qos = context->max_qos;\n\t}else{\n\t\tmsg->qos = qos;\n\t}\n\tmsg->retain = retain;\n\tmsg->properties = properties;\n\n\tif(state == mosq_ms_queued){\n\t\tDL_APPEND(msg_data->queued, msg);\n\t\tdb__msg_add_to_queued_stats(msg_data, msg);\n\t}else{\n\t\tDL_APPEND(msg_data->inflight, msg);\n\t\tdb__msg_add_to_inflight_stats(msg_data, msg);\n\t}\n\n\tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n\t\t/* Record which client ids this message has been sent to so we can avoid duplicates.\n\t\t * Outgoing messages only.\n\t\t * If retain==true then this is a stale retained message and so should be\n\t\t * sent regardless. FIXME - this does mean retained messages will received\n\t\t * multiple times for overlapping subscriptions, although this is only the\n\t\t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n\t\t */\n\t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n\t\tif(dest_ids){\n\t\t\tstored->dest_ids = dest_ids;\n\t\t\tstored->dest_id_count++;\n\t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n\t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t}\n\t\t}else{\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n#ifdef WITH_BRIDGE\n\tif(context->bridge && context->bridge->start_type == bst_lazy\n\t\t\t&& context->sock == INVALID_SOCKET\n\t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n\n\t\tcontext->bridge->lazy_reconnect = true;\n\t}\n#endif\n\n\tif(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){\n\t\tutil__decrement_send_quota(context);\n\t}\n\n\tif(dir == mosq_md_out && update){\n\t\trc = db__message_write_inflight_out_latest(context);\n\t\tif(rc) return rc;\n\t\trc = db__message_write_queued_out(context);\n\t\tif(rc) return rc;\n\t}\n\n\treturn rc;\n}",
        "func": "int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n{\n\tstruct mosquitto_client_msg *msg;\n\tstruct mosquitto_msg_data *msg_data;\n\tenum mosquitto_msg_state state = mosq_ms_invalid;\n\tint rc = 0;\n\tint i;\n\tchar **dest_ids;\n\n\tassert(stored);\n\tif(!context) return MOSQ_ERR_INVAL;\n\tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n\n\tif(dir == mosq_md_out){\n\t\tmsg_data = &context->msgs_out;\n\t}else{\n\t\tmsg_data = &context->msgs_in;\n\t}\n\n\t/* Check whether we've already sent this message to this client\n\t * for outgoing messages only.\n\t * If retain==true then this is a stale retained message and so should be\n\t * sent regardless. FIXME - this does mean retained messages will received\n\t * multiple times for overlapping subscriptions, although this is only the\n\t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n\t */\n\tif(context->protocol != mosq_p_mqtt5\n\t\t\t&& db.config->allow_duplicate_messages == false\n\t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n\n\t\tfor(i=0; i<stored->dest_id_count; i++){\n\t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n\t\t\t\t/* We have already sent this message to this client. */\n\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\tif(context->sock == INVALID_SOCKET){\n\t\t/* Client is not connected only queue messages with QoS>0. */\n\t\tif(qos == 0 && !db.config->queue_qos0_messages){\n\t\t\tif(!context->bridge){\n\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\treturn 2;\n\t\t\t}else{\n\t\t\t\tif(context->bridge->start_type != bst_lazy){\n\t\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(context->bridge && context->bridge->clean_start_local == true){\n\t\t\tmosquitto_property_free_all(&properties);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif(context->sock != INVALID_SOCKET){\n\t\tif(db__ready_for_flight(context, dir, qos)){\n\t\t\tif(dir == mosq_md_out){\n\t\t\t\tswitch(qos){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tstate = mosq_ms_publish_qos0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstate = mosq_ms_publish_qos1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tstate = mosq_ms_publish_qos2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(qos == 2){\n\t\t\t\t\tstate = mosq_ms_wait_for_pubrel;\n\t\t\t\t}else{\n\t\t\t\t\tmosquitto_property_free_all(&properties);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n\t\t\tstate = mosq_ms_queued;\n\t\t\trc = 2;\n\t\t}else{\n\t\t\t/* Dropping message due to full queue. */\n\t\t\tif(context->is_dropping == false){\n\t\t\t\tcontext->is_dropping = true;\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\t\tcontext->id);\n\t\t\t}\n\t\t\tG_MSGS_DROPPED_INC();\n\t\t\tmosquitto_property_free_all(&properties);\n\t\t\treturn 2;\n\t\t}\n\t}else{\n\t\tif (db__ready_for_queue(context, qos, msg_data)){\n\t\t\tstate = mosq_ms_queued;\n\t\t}else{\n\t\t\tG_MSGS_DROPPED_INC();\n\t\t\tif(context->is_dropping == false){\n\t\t\t\tcontext->is_dropping = true;\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\t\tcontext->id);\n\t\t\t}\n\t\t\tmosquitto_property_free_all(&properties);\n\t\t\treturn 2;\n\t\t}\n\t}\n\tassert(state != mosq_ms_invalid);\n\n#ifdef WITH_PERSISTENCE\n\tif(state == mosq_ms_queued){\n\t\tdb.persistence_changes++;\n\t}\n#endif\n\n\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));\n\tif(!msg) return MOSQ_ERR_NOMEM;\n\tmsg->prev = NULL;\n\tmsg->next = NULL;\n\tmsg->store = stored;\n\tdb__msg_store_ref_inc(msg->store);\n\tmsg->mid = mid;\n\tmsg->timestamp = db.now_s;\n\tmsg->direction = dir;\n\tmsg->state = state;\n\tmsg->dup = false;\n\tif(qos > context->max_qos){\n\t\tmsg->qos = context->max_qos;\n\t}else{\n\t\tmsg->qos = qos;\n\t}\n\tmsg->retain = retain;\n\tmsg->properties = properties;\n\n\tif(state == mosq_ms_queued){\n\t\tDL_APPEND(msg_data->queued, msg);\n\t\tdb__msg_add_to_queued_stats(msg_data, msg);\n\t}else{\n\t\tDL_APPEND(msg_data->inflight, msg);\n\t\tdb__msg_add_to_inflight_stats(msg_data, msg);\n\t}\n\n\tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n\t\t/* Record which client ids this message has been sent to so we can avoid duplicates.\n\t\t * Outgoing messages only.\n\t\t * If retain==true then this is a stale retained message and so should be\n\t\t * sent regardless. FIXME - this does mean retained messages will received\n\t\t * multiple times for overlapping subscriptions, although this is only the\n\t\t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n\t\t */\n\t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n\t\tif(dest_ids){\n\t\t\tstored->dest_ids = dest_ids;\n\t\t\tstored->dest_id_count++;\n\t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n\t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t}\n\t\t}else{\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n#ifdef WITH_BRIDGE\n\tif(context->bridge && context->bridge->start_type == bst_lazy\n\t\t\t&& context->sock == INVALID_SOCKET\n\t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n\n\t\tcontext->bridge->lazy_reconnect = true;\n\t}\n#endif\n\n\tif(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){\n\t\tutil__decrement_send_quota(context);\n\t}else if(dir == mosq_md_in && msg->qos > 0 && state != mosq_ms_queued){\n\t\tutil__decrement_receive_quota(context);\n\t}\n\n\tif(dir == mosq_md_out && update){\n\t\trc = db__message_write_inflight_out_latest(context);\n\t\tif(rc) return rc;\n\t\trc = db__message_write_queued_out(context);\n\t\tif(rc) return rc;\n\t}\n\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -115,7 +115,7 @@\n \t}\n #endif\n \n-\tmsg = mosquitto__malloc(sizeof(struct mosquitto_client_msg));\n+\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));\n \tif(!msg) return MOSQ_ERR_NOMEM;\n \tmsg->prev = NULL;\n \tmsg->next = NULL;\n@@ -173,6 +173,8 @@\n \n \tif(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){\n \t\tutil__decrement_send_quota(context);\n+\t}else if(dir == mosq_md_in && msg->qos > 0 && state != mosq_ms_queued){\n+\t\tutil__decrement_receive_quota(context);\n \t}\n \n \tif(dir == mosq_md_out && update){",
        "diff_line_info": {
            "deleted_lines": [
                "\tmsg = mosquitto__malloc(sizeof(struct mosquitto_client_msg));"
            ],
            "added_lines": [
                "\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));",
                "\t}else if(dir == mosq_md_in && msg->qos > 0 && state != mosq_ms_queued){",
                "\t\tutil__decrement_receive_quota(context);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28366",
        "func_name": "eclipse/mosquitto/db__message_store_find",
        "description": "The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",
        "git_url": "https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9",
        "commit_title": "Fix for CVE-2023-28366",
        "commit_text": "",
        "func_before": "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)\n{\n\tstruct mosquitto_client_msg *tail;\n\n\tif(!context) return MOSQ_ERR_INVAL;\n\n\t*stored = NULL;\n\tDL_FOREACH(context->msgs_in.inflight, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\n\tDL_FOREACH(context->msgs_in.queued, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\n\treturn 1;\n}",
        "func": "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_client_msg **client_msg)\n{\n\tstruct mosquitto_client_msg *cmsg;\n\n\t*client_msg = NULL;\n\n\tif(!context) return MOSQ_ERR_INVAL;\n\n\tDL_FOREACH(context->msgs_in.inflight, cmsg){\n\t\tif(cmsg->store->source_mid == mid){\n\t\t\t*client_msg = cmsg;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\n\tDL_FOREACH(context->msgs_in.queued, cmsg){\n\t\tif(cmsg->store->source_mid == mid){\n\t\t\t*client_msg = cmsg;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,20 +1,21 @@\n-int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)\n+int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_client_msg **client_msg)\n {\n-\tstruct mosquitto_client_msg *tail;\n+\tstruct mosquitto_client_msg *cmsg;\n+\n+\t*client_msg = NULL;\n \n \tif(!context) return MOSQ_ERR_INVAL;\n \n-\t*stored = NULL;\n-\tDL_FOREACH(context->msgs_in.inflight, tail){\n-\t\tif(tail->store->source_mid == mid){\n-\t\t\t*stored = tail->store;\n+\tDL_FOREACH(context->msgs_in.inflight, cmsg){\n+\t\tif(cmsg->store->source_mid == mid){\n+\t\t\t*client_msg = cmsg;\n \t\t\treturn MOSQ_ERR_SUCCESS;\n \t\t}\n \t}\n \n-\tDL_FOREACH(context->msgs_in.queued, tail){\n-\t\tif(tail->store->source_mid == mid){\n-\t\t\t*stored = tail->store;\n+\tDL_FOREACH(context->msgs_in.queued, cmsg){\n+\t\tif(cmsg->store->source_mid == mid){\n+\t\t\t*client_msg = cmsg;\n \t\t\treturn MOSQ_ERR_SUCCESS;\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)",
                "\tstruct mosquitto_client_msg *tail;",
                "\t*stored = NULL;",
                "\tDL_FOREACH(context->msgs_in.inflight, tail){",
                "\t\tif(tail->store->source_mid == mid){",
                "\t\t\t*stored = tail->store;",
                "\tDL_FOREACH(context->msgs_in.queued, tail){",
                "\t\tif(tail->store->source_mid == mid){",
                "\t\t\t*stored = tail->store;"
            ],
            "added_lines": [
                "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_client_msg **client_msg)",
                "\tstruct mosquitto_client_msg *cmsg;",
                "",
                "\t*client_msg = NULL;",
                "\tDL_FOREACH(context->msgs_in.inflight, cmsg){",
                "\t\tif(cmsg->store->source_mid == mid){",
                "\t\t\t*client_msg = cmsg;",
                "\tDL_FOREACH(context->msgs_in.queued, cmsg){",
                "\t\tif(cmsg->store->source_mid == mid){",
                "\t\t\t*client_msg = cmsg;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28366",
        "func_name": "eclipse/mosquitto/db__message_reconnect_reset_incoming",
        "description": "The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",
        "git_url": "https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9",
        "commit_title": "Fix for CVE-2023-28366",
        "commit_text": "",
        "func_before": "static int db__message_reconnect_reset_incoming(struct mosquitto *context)\n{\n\tstruct mosquitto_client_msg *msg, *tmp;\n\n\tcontext->msgs_in.inflight_bytes = 0;\n\tcontext->msgs_in.inflight_bytes12 = 0;\n\tcontext->msgs_in.inflight_count = 0;\n\tcontext->msgs_in.inflight_count12 = 0;\n\tcontext->msgs_in.queued_bytes = 0;\n\tcontext->msgs_in.queued_bytes12 = 0;\n\tcontext->msgs_in.queued_count = 0;\n\tcontext->msgs_in.queued_count12 = 0;\n\tcontext->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;\n\n\tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n\t\tdb__msg_add_to_inflight_stats(&context->msgs_in, msg);\n\t\tif(msg->qos > 0){\n\t\t\tutil__decrement_receive_quota(context);\n\t\t}\n\n\t\tif(msg->qos != 2){\n\t\t\t/* Anything <QoS 2 can be completely retried by the client at\n\t\t\t * no harm. */\n\t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n\t\t}else{\n\t\t\t/* Message state can be preserved here because it should match\n\t\t\t * whatever the client has got. */\n\t\t}\n\t}\n\n\t/* Messages received when the client was disconnected are put\n\t * in the mosq_ms_queued state. If we don't change them to the\n\t * appropriate \"publish\" state, then the queued messages won't\n\t * get sent until the client next receives a message - and they\n\t * will be sent out of order.\n\t */\n\tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n\t\tdb__msg_add_to_queued_stats(&context->msgs_in, msg);\n\t\tif(db__ready_for_flight(context, mosq_md_in, msg->qos)){\n\t\t\tswitch(msg->qos){\n\t\t\t\tcase 0:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdb__message_dequeue_first(context, &context->msgs_in);\n\t\t}\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}",
        "func": "static int db__message_reconnect_reset_incoming(struct mosquitto *context)\n{\n\tstruct mosquitto_client_msg *msg, *tmp;\n\n\tcontext->msgs_in.inflight_bytes = 0;\n\tcontext->msgs_in.inflight_bytes12 = 0;\n\tcontext->msgs_in.inflight_count = 0;\n\tcontext->msgs_in.inflight_count12 = 0;\n\tcontext->msgs_in.queued_bytes = 0;\n\tcontext->msgs_in.queued_bytes12 = 0;\n\tcontext->msgs_in.queued_count = 0;\n\tcontext->msgs_in.queued_count12 = 0;\n\tcontext->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;\n\n\tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n\t\tdb__msg_add_to_inflight_stats(&context->msgs_in, msg);\n\t\tif(msg->qos > 0){\n\t\t\tutil__decrement_receive_quota(context);\n\t\t}\n\n\t\tif(msg->qos != 2){\n\t\t\t/* Anything <QoS 2 can be completely retried by the client at\n\t\t\t * no harm. */\n\t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n\t\t}else{\n\t\t\t/* Message state can be preserved here because it should match\n\t\t\t * whatever the client has got. */\n\t\t\tmsg->dup = 0;\n\t\t}\n\t}\n\n\t/* Messages received when the client was disconnected are put\n\t * in the mosq_ms_queued state. If we don't change them to the\n\t * appropriate \"publish\" state, then the queued messages won't\n\t * get sent until the client next receives a message - and they\n\t * will be sent out of order.\n\t */\n\tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n\t\tmsg->dup = 0;\n\t\tdb__msg_add_to_queued_stats(&context->msgs_in, msg);\n\t\tif(db__ready_for_flight(context, mosq_md_in, msg->qos)){\n\t\t\tswitch(msg->qos){\n\t\t\t\tcase 0:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdb__message_dequeue_first(context, &context->msgs_in);\n\t\t}\n\t}\n\n\treturn MOSQ_ERR_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,7 @@\n \t\t}else{\n \t\t\t/* Message state can be preserved here because it should match\n \t\t\t * whatever the client has got. */\n+\t\t\tmsg->dup = 0;\n \t\t}\n \t}\n \n@@ -35,6 +36,7 @@\n \t * will be sent out of order.\n \t */\n \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n+\t\tmsg->dup = 0;\n \t\tdb__msg_add_to_queued_stats(&context->msgs_in, msg);\n \t\tif(db__ready_for_flight(context, mosq_md_in, msg->qos)){\n \t\t\tswitch(msg->qos){",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tmsg->dup = 0;",
                "\t\tmsg->dup = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28366",
        "func_name": "eclipse/mosquitto/handle__publish",
        "description": "The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",
        "git_url": "https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9",
        "commit_title": "Fix for CVE-2023-28366",
        "commit_text": "",
        "func_before": "int handle__publish(struct mosquitto *context)\n{\n\tuint8_t dup;\n\tint rc = 0;\n\tint rc2;\n\tuint8_t header = context->in_packet.command;\n\tint res = 0;\n\tstruct mosquitto_msg_store *msg, *stored = NULL;\n\tsize_t len;\n\tuint16_t slen;\n\tchar *topic_mount;\n\tmosquitto_property *properties = NULL;\n\tmosquitto_property *p, *p_prev;\n\tmosquitto_property *msg_properties_last;\n\tuint32_t message_expiry_interval = 0;\n\tint topic_alias = -1;\n\tuint8_t reason_code = 0;\n\tuint16_t mid = 0;\n\n\tif(context->state != mosq_cs_active){\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\n\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n\tif(msg == NULL){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tdup = (header & 0x08)>>3;\n\tmsg->qos = (header & 0x06)>>1;\n\tif(dup == 1 && msg->qos == 0){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos == 3){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos > context->max_qos){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n\t}\n\tmsg->retain = (header & 0x01);\n\n\tif(msg->retain && db.config->retain_available == false){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n\t}\n\n\tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(!slen && context->protocol != mosq_p_mqtt5){\n\t\t/* Invalid publish topic, disconnect client. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tif(msg->qos > 0){\n\t\tif(packet__read_uint16(&context->in_packet, &mid)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t\tif(mid == 0){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t}\n\t\t/* It is important to have a separate copy of mid, because msg may be\n\t\t * freed before we want to send a PUBACK/PUBREC. */\n\t\tmsg->source_mid = mid;\n\t}\n\n\t/* Handle properties */\n\tif(context->protocol == mosq_p_mqtt5){\n\t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n\t\tif(rc){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\n\t\tp = properties;\n\t\tp_prev = NULL;\n\t\tmsg->properties = NULL;\n\t\tmsg_properties_last = NULL;\n\t\twhile(p){\n\t\t\tswitch(p->identifier){\n\t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n\t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n\t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n\t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n\t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n\t\t\t\t\tif(msg->properties){\n\t\t\t\t\t\tmsg_properties_last->next = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmsg->properties = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}\n\t\t\t\t\tif(p_prev){\n\t\t\t\t\t\tp_prev->next = p->next;\n\t\t\t\t\t\tp = p_prev->next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tproperties = p->next;\n\t\t\t\t\t\tp = properties;\n\t\t\t\t\t}\n\t\t\t\t\tmsg_properties_last->next = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n\t\t\t\t\ttopic_alias = p->value.i16;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n\t\t\t\t\tmessage_expiry_interval = p->value.i32;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmosquitto_property_free_all(&properties);\n\n\tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n\t}else if(topic_alias > 0){\n\t\tif(msg->topic){\n\t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}else{\n\t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_BRIDGE\n\trc = bridge__remap_topic_in(context, &msg->topic);\n\tif(rc){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n#endif\n\tif(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){\n\t\t/* Invalid publish topic, just swallow it. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n\tG_PUB_BYTES_RECEIVED_INC(msg->payloadlen);\n\tif(context->listener && context->listener->mount_point){\n\t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n\t\ttopic_mount = mosquitto__malloc(len+1);\n\t\tif(!topic_mount){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n\t\ttopic_mount[len] = '\\0';\n\n\t\tmosquitto__free(msg->topic);\n\t\tmsg->topic = topic_mount;\n\t}\n\n\tif(msg->payloadlen){\n\t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\t\t\treason_code = MQTT_RC_PACKET_TOO_LARGE;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tmsg->payload = mosquitto__malloc(msg->payloadlen+1);\n\t\tif(msg->payload == NULL){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n\t\t((uint8_t *)msg->payload)[msg->payloadlen] = 0;\n\n\t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t}\n\n\t/* Check for topic access */\n\trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t(long)msg->payloadlen);\n\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\tgoto process_bad_message;\n\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\n\tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n#ifdef WITH_CONTROL\n\t\trc = control__process(context, msg);\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n#else\n\t\treason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC;\n\t\tgoto process_bad_message;\n#endif\n\t}\n\n\t{\n\t\trc = plugin__handle_message(context, msg);\n\t\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t\t(long)msg->payloadlen);\n\n\t\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\t\tgoto process_bad_message;\n\t\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif(msg->qos > 0){\n\t\tdb__message_store_find(context, msg->source_mid, &stored);\n\t}\n\n\tif(stored && msg->source_mid != 0 &&\n\t\t\t(stored->qos != msg->qos\n\t\t\t || stored->payloadlen != msg->payloadlen\n\t\t\t || strcmp(stored->topic, msg->topic)\n\t\t\t || memcmp(stored->payload, msg->payload, msg->payloadlen) )){\n\n\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n\t\tdb__message_remove_incoming(context, msg->source_mid);\n\t\tstored = NULL;\n\t}\n\n\tif(!stored){\n\t\tif(msg->qos == 0\n\t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n\t\t\t\t|| db__ready_for_queue(context, msg->qos, &context->msgs_in)){\n\n\t\t\tdup = 0;\n\t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n\t\t\tif(rc) return rc;\n\t\t}else{\n\t\t\t/* Client isn't allowed any more incoming messages, so fail early */\n\t\t\treason_code = MQTT_RC_QUOTA_EXCEEDED;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tstored = msg;\n\t\tmsg = NULL;\n\t}else{\n\t\tdb__msg_store_free(msg);\n\t\tmsg = NULL;\n\t\tdup = 1;\n\t}\n\n\tswitch(stored->qos){\n\t\tcase 0:\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\tif(rc2 > 0) rc = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tutil__decrement_receive_quota(context);\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\t/* stored may now be free, so don't refer to it */\n\t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n\t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n\t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n\t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n\t\t\t}else{\n\t\t\t\trc = rc2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(dup == 0){\n\t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n\t\t\t}else{\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\t/* db__message_insert() returns 2 to indicate dropped message\n\t\t\t * due to queue. This isn't an error so don't disconnect them. */\n\t\t\t/* FIXME - this is no longer necessary due to failing early above */\n\t\t\tif(!res){\n\t\t\t\tif(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1;\n\t\t\t}else if(res == 1){\n\t\t\t\trc = 1;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tdb__message_write_queued_in(context);\n\treturn rc;\nprocess_bad_message:\n\trc = 1;\n\tif(msg){\n\t\tswitch(msg->qos){\n\t\t\tcase 0:\n\t\t\t\trc = MOSQ_ERR_SUCCESS;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t}\n\t\tdb__msg_store_free(msg);\n\t}\n\treturn rc;\n}",
        "func": "int handle__publish(struct mosquitto *context)\n{\n\tuint8_t dup;\n\tint rc = 0;\n\tint rc2;\n\tuint8_t header = context->in_packet.command;\n\tint res = 0;\n\tstruct mosquitto_msg_store *msg, *stored = NULL;\n\tstruct mosquitto_client_msg *cmsg_stored = NULL;\n\tsize_t len;\n\tuint16_t slen;\n\tchar *topic_mount;\n\tmosquitto_property *properties = NULL;\n\tmosquitto_property *p, *p_prev;\n\tmosquitto_property *msg_properties_last;\n\tuint32_t message_expiry_interval = 0;\n\tint topic_alias = -1;\n\tuint8_t reason_code = 0;\n\tuint16_t mid = 0;\n\n\tif(context->state != mosq_cs_active){\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\n\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n\tif(msg == NULL){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tdup = (header & 0x08)>>3;\n\tmsg->qos = (header & 0x06)>>1;\n\tif(dup == 1 && msg->qos == 0){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos == 3){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos > context->max_qos){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n\t}\n\tmsg->retain = (header & 0x01);\n\n\tif(msg->retain && db.config->retain_available == false){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n\t}\n\n\tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(!slen && context->protocol != mosq_p_mqtt5){\n\t\t/* Invalid publish topic, disconnect client. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tif(msg->qos > 0){\n\t\tif(packet__read_uint16(&context->in_packet, &mid)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t\tif(mid == 0){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t}\n\t\t/* It is important to have a separate copy of mid, because msg may be\n\t\t * freed before we want to send a PUBACK/PUBREC. */\n\t\tmsg->source_mid = mid;\n\t}\n\n\t/* Handle properties */\n\tif(context->protocol == mosq_p_mqtt5){\n\t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n\t\tif(rc){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\n\t\tp = properties;\n\t\tp_prev = NULL;\n\t\tmsg->properties = NULL;\n\t\tmsg_properties_last = NULL;\n\t\twhile(p){\n\t\t\tswitch(p->identifier){\n\t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n\t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n\t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n\t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n\t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n\t\t\t\t\tif(msg->properties){\n\t\t\t\t\t\tmsg_properties_last->next = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmsg->properties = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}\n\t\t\t\t\tif(p_prev){\n\t\t\t\t\t\tp_prev->next = p->next;\n\t\t\t\t\t\tp = p_prev->next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tproperties = p->next;\n\t\t\t\t\t\tp = properties;\n\t\t\t\t\t}\n\t\t\t\t\tmsg_properties_last->next = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n\t\t\t\t\ttopic_alias = p->value.i16;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n\t\t\t\t\tmessage_expiry_interval = p->value.i32;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmosquitto_property_free_all(&properties);\n\n\tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n\t}else if(topic_alias > 0){\n\t\tif(msg->topic){\n\t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}else{\n\t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_BRIDGE\n\trc = bridge__remap_topic_in(context, &msg->topic);\n\tif(rc){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n#endif\n\tif(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){\n\t\t/* Invalid publish topic, just swallow it. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n\tG_PUB_BYTES_RECEIVED_INC(msg->payloadlen);\n\tif(context->listener && context->listener->mount_point){\n\t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n\t\ttopic_mount = mosquitto__malloc(len+1);\n\t\tif(!topic_mount){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n\t\ttopic_mount[len] = '\\0';\n\n\t\tmosquitto__free(msg->topic);\n\t\tmsg->topic = topic_mount;\n\t}\n\n\tif(msg->payloadlen){\n\t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\t\t\treason_code = MQTT_RC_PACKET_TOO_LARGE;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tmsg->payload = mosquitto__malloc(msg->payloadlen+1);\n\t\tif(msg->payload == NULL){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n\t\t((uint8_t *)msg->payload)[msg->payloadlen] = 0;\n\n\t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t}\n\n\t/* Check for topic access */\n\trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t(long)msg->payloadlen);\n\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\tgoto process_bad_message;\n\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\n\tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n#ifdef WITH_CONTROL\n\t\trc = control__process(context, msg);\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n#else\n\t\treason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC;\n\t\tgoto process_bad_message;\n#endif\n\t}\n\n\t{\n\t\trc = plugin__handle_message(context, msg);\n\t\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t\t(long)msg->payloadlen);\n\n\t\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\t\tgoto process_bad_message;\n\t\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif(msg->qos > 0){\n\t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);\n\t}\n\n\tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&\n\t\t\t(cmsg_stored->store->qos != msg->qos\n\t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen\n\t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)\n\t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){\n\n\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n\t\tdb__message_remove_incoming(context, msg->source_mid);\n\t\tcmsg_stored = NULL;\n\t}\n\n\tif(!cmsg_stored){\n\t\tif(msg->qos == 0\n\t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n\t\t\t\t){\n\n\t\t\tdup = 0;\n\t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n\t\t\tif(rc) return rc;\n\t\t}else{\n\t\t\t/* Client isn't allowed any more incoming messages, so fail early */\n\t\t\treason_code = MQTT_RC_QUOTA_EXCEEDED;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tstored = msg;\n\t\tmsg = NULL;\n\t\tdup = 0;\n\t}else{\n\t\tdb__msg_store_free(msg);\n\t\tmsg = NULL;\n\t\tstored = cmsg_stored->store;\n\t\tcmsg_stored->dup++;\n\t\tdup = cmsg_stored->dup;\n\t}\n\n\tswitch(stored->qos){\n\t\tcase 0:\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\tif(rc2 > 0) rc = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tutil__decrement_receive_quota(context);\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\t/* stored may now be free, so don't refer to it */\n\t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n\t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n\t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n\t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n\t\t\t}else{\n\t\t\t\trc = rc2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(dup == 0){\n\t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n\t\t\t}else{\n\t\t\t\tres = 0;\n\t\t\t}\n\n\t\t\t/* db__message_insert() returns 2 to indicate dropped message\n\t\t\t * due to queue. This isn't an error so don't disconnect them. */\n\t\t\t/* FIXME - this is no longer necessary due to failing early above */\n\t\t\tif(!res){\n\t\t\t\tif(dup == 0 || dup == 1){\n\t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);\n\t\t\t\t\tif(rc2) rc = rc2;\n\t\t\t\t}else{\n\t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t\t}\n\t\t\t}else if(res == 1){\n\t\t\t\trc = 1;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tdb__message_write_queued_in(context);\n\treturn rc;\nprocess_bad_message:\n\trc = 1;\n\tif(msg){\n\t\tswitch(msg->qos){\n\t\t\tcase 0:\n\t\t\t\trc = MOSQ_ERR_SUCCESS;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t}\n\t\tdb__msg_store_free(msg);\n\t}\n\tif(context->out_packet_count >= db.config->max_queued_messages){\n\t\trc = MQTT_RC_QUOTA_EXCEEDED;\n\t}\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n \tuint8_t header = context->in_packet.command;\n \tint res = 0;\n \tstruct mosquitto_msg_store *msg, *stored = NULL;\n+\tstruct mosquitto_client_msg *cmsg_stored = NULL;\n \tsize_t len;\n \tuint16_t slen;\n \tchar *topic_mount;\n@@ -251,24 +252,24 @@\n \t}\n \n \tif(msg->qos > 0){\n-\t\tdb__message_store_find(context, msg->source_mid, &stored);\n-\t}\n-\n-\tif(stored && msg->source_mid != 0 &&\n-\t\t\t(stored->qos != msg->qos\n-\t\t\t || stored->payloadlen != msg->payloadlen\n-\t\t\t || strcmp(stored->topic, msg->topic)\n-\t\t\t || memcmp(stored->payload, msg->payload, msg->payloadlen) )){\n+\t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);\n+\t}\n+\n+\tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&\n+\t\t\t(cmsg_stored->store->qos != msg->qos\n+\t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen\n+\t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)\n+\t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){\n \n \t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n \t\tdb__message_remove_incoming(context, msg->source_mid);\n-\t\tstored = NULL;\n-\t}\n-\n-\tif(!stored){\n+\t\tcmsg_stored = NULL;\n+\t}\n+\n+\tif(!cmsg_stored){\n \t\tif(msg->qos == 0\n \t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n-\t\t\t\t|| db__ready_for_queue(context, msg->qos, &context->msgs_in)){\n+\t\t\t\t){\n \n \t\t\tdup = 0;\n \t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n@@ -280,10 +281,13 @@\n \t\t}\n \t\tstored = msg;\n \t\tmsg = NULL;\n+\t\tdup = 0;\n \t}else{\n \t\tdb__msg_store_free(msg);\n \t\tmsg = NULL;\n-\t\tdup = 1;\n+\t\tstored = cmsg_stored->store;\n+\t\tcmsg_stored->dup++;\n+\t\tdup = cmsg_stored->dup;\n \t}\n \n \tswitch(stored->qos){\n@@ -309,11 +313,17 @@\n \t\t\t}else{\n \t\t\t\tres = 0;\n \t\t\t}\n+\n \t\t\t/* db__message_insert() returns 2 to indicate dropped message\n \t\t\t * due to queue. This isn't an error so don't disconnect them. */\n \t\t\t/* FIXME - this is no longer necessary due to failing early above */\n \t\t\tif(!res){\n-\t\t\t\tif(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1;\n+\t\t\t\tif(dup == 0 || dup == 1){\n+\t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);\n+\t\t\t\t\tif(rc2) rc = rc2;\n+\t\t\t\t}else{\n+\t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n+\t\t\t\t}\n \t\t\t}else if(res == 1){\n \t\t\t\trc = 1;\n \t\t\t}\n@@ -338,5 +348,8 @@\n \t\t}\n \t\tdb__msg_store_free(msg);\n \t}\n+\tif(context->out_packet_count >= db.config->max_queued_messages){\n+\t\trc = MQTT_RC_QUOTA_EXCEEDED;\n+\t}\n \treturn rc;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tdb__message_store_find(context, msg->source_mid, &stored);",
                "\t}",
                "",
                "\tif(stored && msg->source_mid != 0 &&",
                "\t\t\t(stored->qos != msg->qos",
                "\t\t\t || stored->payloadlen != msg->payloadlen",
                "\t\t\t || strcmp(stored->topic, msg->topic)",
                "\t\t\t || memcmp(stored->payload, msg->payload, msg->payloadlen) )){",
                "\t\tstored = NULL;",
                "\t}",
                "",
                "\tif(!stored){",
                "\t\t\t\t|| db__ready_for_queue(context, msg->qos, &context->msgs_in)){",
                "\t\tdup = 1;",
                "\t\t\t\tif(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1;"
            ],
            "added_lines": [
                "\tstruct mosquitto_client_msg *cmsg_stored = NULL;",
                "\t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);",
                "\t}",
                "",
                "\tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&",
                "\t\t\t(cmsg_stored->store->qos != msg->qos",
                "\t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen",
                "\t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)",
                "\t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){",
                "\t\tcmsg_stored = NULL;",
                "\t}",
                "",
                "\tif(!cmsg_stored){",
                "\t\t\t\t){",
                "\t\tdup = 0;",
                "\t\tstored = cmsg_stored->store;",
                "\t\tcmsg_stored->dup++;",
                "\t\tdup = cmsg_stored->dup;",
                "",
                "\t\t\t\tif(dup == 0 || dup == 1){",
                "\t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);",
                "\t\t\t\t\tif(rc2) rc = rc2;",
                "\t\t\t\t}else{",
                "\t\t\t\t\treturn MOSQ_ERR_PROTOCOL;",
                "\t\t\t\t}",
                "\tif(context->out_packet_count >= db.config->max_queued_messages){",
                "\t\trc = MQTT_RC_QUOTA_EXCEEDED;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28366",
        "func_name": "eclipse/mosquitto/context__init",
        "description": "The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",
        "git_url": "https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9",
        "commit_title": "Fix for CVE-2023-28366",
        "commit_text": "",
        "func_before": "struct mosquitto *context__init(mosq_sock_t sock)\n{\n\tstruct mosquitto *context;\n\tchar address[1024];\n\n\tcontext = mosquitto__calloc(1, sizeof(struct mosquitto));\n\tif(!context) return NULL;\n\n#ifdef WITH_EPOLL\n\tcontext->ident = id_client;\n#else\n\tcontext->pollfd_index = -1;\n#endif\n\tmosquitto__set_state(context, mosq_cs_new);\n\tcontext->sock = sock;\n\tcontext->last_msg_in = db.now_s;\n\tcontext->next_msg_out = db.now_s + 60;\n\tcontext->keepalive = 60; /* Default to 60s */\n\tcontext->clean_start = true;\n\tcontext->id = NULL;\n\tcontext->last_mid = 0;\n\tcontext->will = NULL;\n\tcontext->username = NULL;\n\tcontext->password = NULL;\n\tcontext->listener = NULL;\n\tcontext->acl_list = NULL;\n\tcontext->retain_available = true;\n\n\t/* is_bridge records whether this client is a bridge or not. This could be\n\t * done by looking at context->bridge for bridges that we create ourself,\n\t * but incoming bridges need some other way of being recorded. */\n\tcontext->is_bridge = false;\n\n\tcontext->in_packet.payload = NULL;\n\tpacket__cleanup(&context->in_packet);\n\tcontext->out_packet = NULL;\n\tcontext->current_out_packet = NULL;\n\tcontext->out_packet_count = 0;\n\n\tcontext->address = NULL;\n\tif((int)sock >= 0){\n\t\tif(!net__socket_get_address(sock, address, 1024, &context->remote_port)){\n\t\t\tcontext->address = mosquitto__strdup(address);\n\t\t}\n\t\tif(!context->address){\n\t\t\t/* getpeername and inet_ntop failed and not a bridge */\n\t\t\tmosquitto__free(context);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tcontext->bridge = NULL;\n\tcontext->msgs_in.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_in.inflight_quota = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_quota = db.config->max_inflight_messages;\n\tcontext->max_qos = 2;\n#ifdef WITH_TLS\n\tcontext->ssl = NULL;\n#endif\n\n\tif((int)context->sock >= 0){\n\t\tHASH_ADD(hh_sock, db.contexts_by_sock, sock, sizeof(context->sock), context);\n\t}\n\treturn context;\n}",
        "func": "struct mosquitto *context__init(mosq_sock_t sock)\n{\n\tstruct mosquitto *context;\n\tchar address[1024];\n\n\tcontext = mosquitto__calloc(1, sizeof(struct mosquitto));\n\tif(!context) return NULL;\n\n#ifdef WITH_EPOLL\n\tcontext->ident = id_client;\n#else\n\tcontext->pollfd_index = -1;\n#endif\n\tmosquitto__set_state(context, mosq_cs_new);\n\tcontext->sock = sock;\n\tcontext->last_msg_in = db.now_s;\n\tcontext->next_msg_out = db.now_s + 60;\n\tcontext->keepalive = 60; /* Default to 60s */\n\tcontext->clean_start = true;\n\tcontext->id = NULL;\n\tcontext->last_mid = 0;\n\tcontext->will = NULL;\n\tcontext->username = NULL;\n\tcontext->password = NULL;\n\tcontext->listener = NULL;\n\tcontext->acl_list = NULL;\n\tcontext->retain_available = true;\n\n\t/* is_bridge records whether this client is a bridge or not. This could be\n\t * done by looking at context->bridge for bridges that we create ourself,\n\t * but incoming bridges need some other way of being recorded. */\n\tcontext->is_bridge = false;\n\n\tcontext->in_packet.payload = NULL;\n\tpacket__cleanup(&context->in_packet);\n\tcontext->out_packet = NULL;\n\tcontext->current_out_packet = NULL;\n\tcontext->out_packet_count = 0;\n\n\tcontext->address = NULL;\n\tif((int)sock >= 0){\n\t\tif(!net__socket_get_address(sock, address, 1024, &context->remote_port)){\n\t\t\tcontext->address = mosquitto__strdup(address);\n\t\t}\n\t\tif(!context->address){\n\t\t\t/* getpeername and inet_ntop failed and not a bridge */\n\t\t\tmosquitto__free(context);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tcontext->bridge = NULL;\n\tcontext->msgs_in.inflight_maximum = 1;\n\tcontext->msgs_out.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_in.inflight_quota = 1;\n\tcontext->msgs_out.inflight_quota = db.config->max_inflight_messages;\n\tcontext->max_qos = 2;\n#ifdef WITH_TLS\n\tcontext->ssl = NULL;\n#endif\n\n\tif((int)context->sock >= 0){\n\t\tHASH_ADD(hh_sock, db.contexts_by_sock, sock, sizeof(context->sock), context);\n\t}\n\treturn context;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,9 +49,9 @@\n \t\t}\n \t}\n \tcontext->bridge = NULL;\n-\tcontext->msgs_in.inflight_maximum = db.config->max_inflight_messages;\n+\tcontext->msgs_in.inflight_maximum = 1;\n \tcontext->msgs_out.inflight_maximum = db.config->max_inflight_messages;\n-\tcontext->msgs_in.inflight_quota = db.config->max_inflight_messages;\n+\tcontext->msgs_in.inflight_quota = 1;\n \tcontext->msgs_out.inflight_quota = db.config->max_inflight_messages;\n \tcontext->max_qos = 2;\n #ifdef WITH_TLS",
        "diff_line_info": {
            "deleted_lines": [
                "\tcontext->msgs_in.inflight_maximum = db.config->max_inflight_messages;",
                "\tcontext->msgs_in.inflight_quota = db.config->max_inflight_messages;"
            ],
            "added_lines": [
                "\tcontext->msgs_in.inflight_maximum = 1;",
                "\tcontext->msgs_in.inflight_quota = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28366",
        "func_name": "eclipse/mosquitto/context__cleanup",
        "description": "The broker in Eclipse Mosquitto 1.3.2 through 2.x before 2.0.16 has a memory leak that can be abused remotely when a client sends many QoS 2 messages with duplicate message IDs, and fails to respond to PUBREC commands. This occurs because of mishandling of EAGAIN from the libc send function.",
        "git_url": "https://github.com/eclipse/mosquitto/commit/6113eac95a9df634fbc858be542c4a0456bfe7b9",
        "commit_title": "Fix for CVE-2023-28366",
        "commit_text": "",
        "func_before": "void context__cleanup(struct mosquitto *context, bool force_free)\n{\n\tstruct mosquitto__packet *packet;\n\n\tif(!context) return;\n\n\tif(force_free){\n\t\tcontext->clean_start = true;\n\t}\n\n#ifdef WITH_BRIDGE\n\tif(context->bridge){\n\t\tbridge__cleanup(context);\n\t}\n#endif\n\n\talias__free_all(context);\n\n\tmosquitto__free(context->auth_method);\n\tcontext->auth_method = NULL;\n\n\tmosquitto__free(context->username);\n\tcontext->username = NULL;\n\n\tmosquitto__free(context->password);\n\tcontext->password = NULL;\n\n\tnet__socket_close(context);\n\tif(force_free){\n\t\tsub__clean_session(context);\n\t}\n\tdb__messages_delete(context, force_free);\n\n\tmosquitto__free(context->address);\n\tcontext->address = NULL;\n\n\tcontext__send_will(context);\n\n\tif(context->id){\n\t\tcontext__remove_from_by_id(context);\n\t\tmosquitto__free(context->id);\n\t\tcontext->id = NULL;\n\t}\n\tpacket__cleanup(&(context->in_packet));\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)\n\tif(context->adns){\n\t\tgai_cancel(context->adns);\n\t\tmosquitto__free((struct addrinfo *)context->adns->ar_request);\n\t\tmosquitto__free(context->adns);\n\t}\n#endif\n\tif(force_free){\n\t\tmosquitto__free(context);\n\t}\n}",
        "func": "void context__cleanup(struct mosquitto *context, bool force_free)\n{\n\tif(!context) return;\n\n\tif(force_free){\n\t\tcontext->clean_start = true;\n\t}\n\n#ifdef WITH_BRIDGE\n\tif(context->bridge){\n\t\tbridge__cleanup(context);\n\t}\n#endif\n\n\talias__free_all(context);\n\tcontext__cleanup_out_packets(context);\n\n\tmosquitto__free(context->auth_method);\n\tcontext->auth_method = NULL;\n\n\tmosquitto__free(context->username);\n\tcontext->username = NULL;\n\n\tmosquitto__free(context->password);\n\tcontext->password = NULL;\n\n\tnet__socket_close(context);\n\tif(force_free){\n\t\tsub__clean_session(context);\n\t}\n\tdb__messages_delete(context, force_free);\n\n\tmosquitto__free(context->address);\n\tcontext->address = NULL;\n\n\tcontext__send_will(context);\n\n\tif(context->id){\n\t\tcontext__remove_from_by_id(context);\n\t\tmosquitto__free(context->id);\n\t\tcontext->id = NULL;\n\t}\n\tpacket__cleanup(&(context->in_packet));\n\tcontext__cleanup_out_packets(context);\n#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)\n\tif(context->adns){\n\t\tgai_cancel(context->adns);\n\t\tmosquitto__free((struct addrinfo *)context->adns->ar_request);\n\t\tmosquitto__free(context->adns);\n\t}\n#endif\n\tif(force_free){\n\t\tmosquitto__free(context);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,5 @@\n void context__cleanup(struct mosquitto *context, bool force_free)\n {\n-\tstruct mosquitto__packet *packet;\n-\n \tif(!context) return;\n \n \tif(force_free){\n@@ -15,6 +13,7 @@\n #endif\n \n \talias__free_all(context);\n+\tcontext__cleanup_out_packets(context);\n \n \tmosquitto__free(context->auth_method);\n \tcontext->auth_method = NULL;\n@@ -42,18 +41,7 @@\n \t\tcontext->id = NULL;\n \t}\n \tpacket__cleanup(&(context->in_packet));\n-\tif(context->current_out_packet){\n-\t\tpacket__cleanup(context->current_out_packet);\n-\t\tmosquitto__free(context->current_out_packet);\n-\t\tcontext->current_out_packet = NULL;\n-\t}\n-\twhile(context->out_packet){\n-\t\tpacket__cleanup(context->out_packet);\n-\t\tpacket = context->out_packet;\n-\t\tcontext->out_packet = context->out_packet->next;\n-\t\tmosquitto__free(packet);\n-\t}\n-\tcontext->out_packet_count = 0;\n+\tcontext__cleanup_out_packets(context);\n #if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)\n \tif(context->adns){\n \t\tgai_cancel(context->adns);",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct mosquitto__packet *packet;",
                "",
                "\tif(context->current_out_packet){",
                "\t\tpacket__cleanup(context->current_out_packet);",
                "\t\tmosquitto__free(context->current_out_packet);",
                "\t\tcontext->current_out_packet = NULL;",
                "\t}",
                "\twhile(context->out_packet){",
                "\t\tpacket__cleanup(context->out_packet);",
                "\t\tpacket = context->out_packet;",
                "\t\tcontext->out_packet = context->out_packet->next;",
                "\t\tmosquitto__free(packet);",
                "\t}",
                "\tcontext->out_packet_count = 0;"
            ],
            "added_lines": [
                "\tcontext__cleanup_out_packets(context);",
                "\tcontext__cleanup_out_packets(context);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4135",
        "func_name": "kernel/git/netdev/net/nsim_bpf_map_alloc",
        "description": "A memory leak vulnerability was found in the Linux kernel's eBPF for the Simulated networking device driver in the way user uses BPF for the device such that function nsim_map_alloc_elem being called. A local user could use this flaw to get unauthorized access to some data.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?h=481221775d53",
        "commit_title": "Zero-initialize memory for new map's value in function nsim_bpf_map_alloc",
        "commit_text": "since it may cause a potential kernel information leak issue, as follows: 1. nsim_bpf_map_alloc calls nsim_map_alloc_elem to allocate elements for a new map. 2. nsim_map_alloc_elem uses kmalloc to allocate map's value, but doesn't zero it. 3. A user application can use IOCTL BPF_MAP_LOOKUP_ELEM to get specific element's information in the map. 4. The kernel function map_lookup_elem will call bpf_map_copy_value to get the information allocated at step-2, then use copy_to_user to copy to the user buffer. This can only leak information for an array map.  Suggested-by: Jakub Kicinski <kuba@kernel.org> Link: https://lore.kernel.org/r/20211215111530.72103-1-tcs.kernel@gmail.com ",
        "func_before": "static int\nnsim_bpf_map_alloc(struct netdevsim *ns, struct bpf_offloaded_map *offmap)\n{\n\tstruct nsim_bpf_bound_map *nmap;\n\tint i, err;\n\n\tif (WARN_ON(offmap->map.map_type != BPF_MAP_TYPE_ARRAY &&\n\t\t    offmap->map.map_type != BPF_MAP_TYPE_HASH))\n\t\treturn -EINVAL;\n\tif (offmap->map.max_entries > NSIM_BPF_MAX_KEYS)\n\t\treturn -ENOMEM;\n\tif (offmap->map.map_flags)\n\t\treturn -EINVAL;\n\n\tnmap = kzalloc(sizeof(*nmap), GFP_USER);\n\tif (!nmap)\n\t\treturn -ENOMEM;\n\n\toffmap->dev_priv = nmap;\n\tnmap->ns = ns;\n\tnmap->map = offmap;\n\tmutex_init(&nmap->mutex);\n\n\tif (offmap->map.map_type == BPF_MAP_TYPE_ARRAY) {\n\t\tfor (i = 0; i < ARRAY_SIZE(nmap->entry); i++) {\n\t\t\tu32 *key;\n\n\t\t\terr = nsim_map_alloc_elem(offmap, i);\n\t\t\tif (err)\n\t\t\t\tgoto err_free;\n\t\t\tkey = nmap->entry[i].key;\n\t\t\t*key = i;\n\t\t}\n\t}\n\n\toffmap->dev_ops = &nsim_bpf_map_ops;\n\tlist_add_tail(&nmap->l, &ns->nsim_dev->bpf_bound_maps);\n\n\treturn 0;\n\nerr_free:\n\twhile (--i >= 0) {\n\t\tkfree(nmap->entry[i].key);\n\t\tkfree(nmap->entry[i].value);\n\t}\n\tkfree(nmap);\n\treturn err;\n}",
        "func": "static int\nnsim_bpf_map_alloc(struct netdevsim *ns, struct bpf_offloaded_map *offmap)\n{\n\tstruct nsim_bpf_bound_map *nmap;\n\tint i, err;\n\n\tif (WARN_ON(offmap->map.map_type != BPF_MAP_TYPE_ARRAY &&\n\t\t    offmap->map.map_type != BPF_MAP_TYPE_HASH))\n\t\treturn -EINVAL;\n\tif (offmap->map.max_entries > NSIM_BPF_MAX_KEYS)\n\t\treturn -ENOMEM;\n\tif (offmap->map.map_flags)\n\t\treturn -EINVAL;\n\n\tnmap = kzalloc(sizeof(*nmap), GFP_USER);\n\tif (!nmap)\n\t\treturn -ENOMEM;\n\n\toffmap->dev_priv = nmap;\n\tnmap->ns = ns;\n\tnmap->map = offmap;\n\tmutex_init(&nmap->mutex);\n\n\tif (offmap->map.map_type == BPF_MAP_TYPE_ARRAY) {\n\t\tfor (i = 0; i < ARRAY_SIZE(nmap->entry); i++) {\n\t\t\tu32 *key;\n\n\t\t\terr = nsim_map_alloc_elem(offmap, i);\n\t\t\tif (err)\n\t\t\t\tgoto err_free;\n\t\t\tkey = nmap->entry[i].key;\n\t\t\t*key = i;\n\t\t\tmemset(nmap->entry[i].value, 0, offmap->map.value_size);\n\t\t}\n\t}\n\n\toffmap->dev_ops = &nsim_bpf_map_ops;\n\tlist_add_tail(&nmap->l, &ns->nsim_dev->bpf_bound_maps);\n\n\treturn 0;\n\nerr_free:\n\twhile (--i >= 0) {\n\t\tkfree(nmap->entry[i].key);\n\t\tkfree(nmap->entry[i].value);\n\t}\n\tkfree(nmap);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,7 @@\n \t\t\t\tgoto err_free;\n \t\t\tkey = nmap->entry[i].key;\n \t\t\t*key = i;\n+\t\t\tmemset(nmap->entry[i].value, 0, offmap->map.value_size);\n \t\t}\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tmemset(nmap->entry[i].value, 0, offmap->map.value_size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1651",
        "func_name": "torvalds/linux/acrn_dev_ioctl",
        "description": "A memory leak flaw was found in the Linux kernel in acrn_dev_ioctl in the drivers/virt/acrn/hsm.c function in how the ACRN Device Model emulates virtual NICs in VM. This flaw allows a local privileged attacker to leak unauthorized kernel information, causing a denial of service.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ecd1735f14d6ac868ae5d8b7a2bf193fa11f388b",
        "commit_title": "The vm_param and cpu_regs need to be freed via kfree()",
        "commit_text": "before return -EINVAL error.  Link: https://lore.kernel.org/r/20220308092047.1008409-1-butterflyhuangxx@gmail.com ",
        "func_before": "static long acrn_dev_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t   unsigned long ioctl_param)\n{\n\tstruct acrn_vm *vm = filp->private_data;\n\tstruct acrn_vm_creation *vm_param;\n\tstruct acrn_vcpu_regs *cpu_regs;\n\tstruct acrn_ioreq_notify notify;\n\tstruct acrn_ptdev_irq *irq_info;\n\tstruct acrn_ioeventfd ioeventfd;\n\tstruct acrn_vm_memmap memmap;\n\tstruct acrn_mmiodev *mmiodev;\n\tstruct acrn_msi_entry *msi;\n\tstruct acrn_pcidev *pcidev;\n\tstruct acrn_irqfd irqfd;\n\tstruct acrn_vdev *vdev;\n\tstruct page *page;\n\tu64 cstate_cmd;\n\tint i, ret = 0;\n\n\tif (vm->vmid == ACRN_INVALID_VMID && cmd != ACRN_IOCTL_CREATE_VM) {\n\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\"ioctl 0x%x: Invalid VM state!\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase ACRN_IOCTL_CREATE_VM:\n\t\tvm_param = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_vm_creation));\n\t\tif (IS_ERR(vm_param))\n\t\t\treturn PTR_ERR(vm_param);\n\n\t\tif ((vm_param->reserved0 | vm_param->reserved1) != 0)\n\t\t\treturn -EINVAL;\n\n\t\tvm = acrn_vm_create(vm, vm_param);\n\t\tif (!vm) {\n\t\t\tret = -EINVAL;\n\t\t\tkfree(vm_param);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user((void __user *)ioctl_param, vm_param,\n\t\t\t\t sizeof(struct acrn_vm_creation))) {\n\t\t\tacrn_vm_destroy(vm);\n\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(vm_param);\n\t\tbreak;\n\tcase ACRN_IOCTL_START_VM:\n\t\tret = hcall_start_vm(vm->vmid);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to start VM %u!\\n\", vm->vmid);\n\t\tbreak;\n\tcase ACRN_IOCTL_PAUSE_VM:\n\t\tret = hcall_pause_vm(vm->vmid);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to pause VM %u!\\n\", vm->vmid);\n\t\tbreak;\n\tcase ACRN_IOCTL_RESET_VM:\n\t\tret = hcall_reset_vm(vm->vmid);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to restart VM %u!\\n\", vm->vmid);\n\t\tbreak;\n\tcase ACRN_IOCTL_DESTROY_VM:\n\t\tret = acrn_vm_destroy(vm);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_VCPU_REGS:\n\t\tcpu_regs = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_vcpu_regs));\n\t\tif (IS_ERR(cpu_regs))\n\t\t\treturn PTR_ERR(cpu_regs);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->reserved); i++)\n\t\t\tif (cpu_regs->reserved[i])\n\t\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.reserved_32); i++)\n\t\t\tif (cpu_regs->vcpu_regs.reserved_32[i])\n\t\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.reserved_64); i++)\n\t\t\tif (cpu_regs->vcpu_regs.reserved_64[i])\n\t\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.gdt.reserved); i++)\n\t\t\tif (cpu_regs->vcpu_regs.gdt.reserved[i] |\n\t\t\t    cpu_regs->vcpu_regs.idt.reserved[i])\n\t\t\t\treturn -EINVAL;\n\n\t\tret = hcall_set_vcpu_regs(vm->vmid, virt_to_phys(cpu_regs));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to set regs state of VM%u!\\n\",\n\t\t\t\tvm->vmid);\n\t\tkfree(cpu_regs);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_MEMSEG:\n\t\tif (copy_from_user(&memmap, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(memmap)))\n\t\t\treturn -EFAULT;\n\n\t\tret = acrn_vm_memseg_map(vm, &memmap);\n\t\tbreak;\n\tcase ACRN_IOCTL_UNSET_MEMSEG:\n\t\tif (copy_from_user(&memmap, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(memmap)))\n\t\t\treturn -EFAULT;\n\n\t\tret = acrn_vm_memseg_unmap(vm, &memmap);\n\t\tbreak;\n\tcase ACRN_IOCTL_ASSIGN_MMIODEV:\n\t\tmmiodev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t      sizeof(struct acrn_mmiodev));\n\t\tif (IS_ERR(mmiodev))\n\t\t\treturn PTR_ERR(mmiodev);\n\n\t\tret = hcall_assign_mmiodev(vm->vmid, virt_to_phys(mmiodev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to assign MMIO device!\\n\");\n\t\tkfree(mmiodev);\n\t\tbreak;\n\tcase ACRN_IOCTL_DEASSIGN_MMIODEV:\n\t\tmmiodev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t      sizeof(struct acrn_mmiodev));\n\t\tif (IS_ERR(mmiodev))\n\t\t\treturn PTR_ERR(mmiodev);\n\n\t\tret = hcall_deassign_mmiodev(vm->vmid, virt_to_phys(mmiodev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to deassign MMIO device!\\n\");\n\t\tkfree(mmiodev);\n\t\tbreak;\n\tcase ACRN_IOCTL_ASSIGN_PCIDEV:\n\t\tpcidev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t     sizeof(struct acrn_pcidev));\n\t\tif (IS_ERR(pcidev))\n\t\t\treturn PTR_ERR(pcidev);\n\n\t\tret = hcall_assign_pcidev(vm->vmid, virt_to_phys(pcidev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to assign pci device!\\n\");\n\t\tkfree(pcidev);\n\t\tbreak;\n\tcase ACRN_IOCTL_DEASSIGN_PCIDEV:\n\t\tpcidev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t     sizeof(struct acrn_pcidev));\n\t\tif (IS_ERR(pcidev))\n\t\t\treturn PTR_ERR(pcidev);\n\n\t\tret = hcall_deassign_pcidev(vm->vmid, virt_to_phys(pcidev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to deassign pci device!\\n\");\n\t\tkfree(pcidev);\n\t\tbreak;\n\tcase ACRN_IOCTL_CREATE_VDEV:\n\t\tvdev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t   sizeof(struct acrn_vdev));\n\t\tif (IS_ERR(vdev))\n\t\t\treturn PTR_ERR(vdev);\n\n\t\tret = hcall_create_vdev(vm->vmid, virt_to_phys(vdev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to create virtual device!\\n\");\n\t\tkfree(vdev);\n\t\tbreak;\n\tcase ACRN_IOCTL_DESTROY_VDEV:\n\t\tvdev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t   sizeof(struct acrn_vdev));\n\t\tif (IS_ERR(vdev))\n\t\t\treturn PTR_ERR(vdev);\n\t\tret = hcall_destroy_vdev(vm->vmid, virt_to_phys(vdev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to destroy virtual device!\\n\");\n\t\tkfree(vdev);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_PTDEV_INTR:\n\t\tirq_info = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_ptdev_irq));\n\t\tif (IS_ERR(irq_info))\n\t\t\treturn PTR_ERR(irq_info);\n\n\t\tret = hcall_set_ptdev_intr(vm->vmid, virt_to_phys(irq_info));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to configure intr for ptdev!\\n\");\n\t\tkfree(irq_info);\n\t\tbreak;\n\tcase ACRN_IOCTL_RESET_PTDEV_INTR:\n\t\tirq_info = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_ptdev_irq));\n\t\tif (IS_ERR(irq_info))\n\t\t\treturn PTR_ERR(irq_info);\n\n\t\tret = hcall_reset_ptdev_intr(vm->vmid, virt_to_phys(irq_info));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to reset intr for ptdev!\\n\");\n\t\tkfree(irq_info);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_IRQLINE:\n\t\tret = hcall_set_irqline(vm->vmid, ioctl_param);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to set interrupt line!\\n\");\n\t\tbreak;\n\tcase ACRN_IOCTL_INJECT_MSI:\n\t\tmsi = memdup_user((void __user *)ioctl_param,\n\t\t\t\t  sizeof(struct acrn_msi_entry));\n\t\tif (IS_ERR(msi))\n\t\t\treturn PTR_ERR(msi);\n\n\t\tret = hcall_inject_msi(vm->vmid, virt_to_phys(msi));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to inject MSI!\\n\");\n\t\tkfree(msi);\n\t\tbreak;\n\tcase ACRN_IOCTL_VM_INTR_MONITOR:\n\t\tret = pin_user_pages_fast(ioctl_param, 1,\n\t\t\t\t\t  FOLL_WRITE | FOLL_LONGTERM, &page);\n\t\tif (unlikely(ret != 1)) {\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to pin intr hdr buffer!\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tret = hcall_vm_intr_monitor(vm->vmid, page_to_phys(page));\n\t\tif (ret < 0) {\n\t\t\tunpin_user_page(page);\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to monitor intr data!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (vm->monitor_page)\n\t\t\tunpin_user_page(vm->monitor_page);\n\t\tvm->monitor_page = page;\n\t\tbreak;\n\tcase ACRN_IOCTL_CREATE_IOREQ_CLIENT:\n\t\tif (vm->default_client)\n\t\t\treturn -EEXIST;\n\t\tif (!acrn_ioreq_client_create(vm, NULL, NULL, true, \"acrndm\"))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase ACRN_IOCTL_DESTROY_IOREQ_CLIENT:\n\t\tif (vm->default_client)\n\t\t\tacrn_ioreq_client_destroy(vm->default_client);\n\t\tbreak;\n\tcase ACRN_IOCTL_ATTACH_IOREQ_CLIENT:\n\t\tif (vm->default_client)\n\t\t\tret = acrn_ioreq_client_wait(vm->default_client);\n\t\telse\n\t\t\tret = -ENODEV;\n\t\tbreak;\n\tcase ACRN_IOCTL_NOTIFY_REQUEST_FINISH:\n\t\tif (copy_from_user(&notify, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(struct acrn_ioreq_notify)))\n\t\t\treturn -EFAULT;\n\n\t\tif (notify.reserved != 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = acrn_ioreq_request_default_complete(vm, notify.vcpu);\n\t\tbreak;\n\tcase ACRN_IOCTL_CLEAR_VM_IOREQ:\n\t\tacrn_ioreq_request_clear(vm);\n\t\tbreak;\n\tcase ACRN_IOCTL_PM_GET_CPU_STATE:\n\t\tif (copy_from_user(&cstate_cmd, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(cstate_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tret = pmcmd_ioctl(cstate_cmd, (void __user *)ioctl_param);\n\t\tbreak;\n\tcase ACRN_IOCTL_IOEVENTFD:\n\t\tif (copy_from_user(&ioeventfd, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(ioeventfd)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ioeventfd.reserved != 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = acrn_ioeventfd_config(vm, &ioeventfd);\n\t\tbreak;\n\tcase ACRN_IOCTL_IRQFD:\n\t\tif (copy_from_user(&irqfd, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(irqfd)))\n\t\t\treturn -EFAULT;\n\t\tret = acrn_irqfd_config(vm, &irqfd);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(acrn_dev.this_device, \"Unknown IOCTL 0x%x!\\n\", cmd);\n\t\tret = -ENOTTY;\n\t}\n\n\treturn ret;\n}",
        "func": "static long acrn_dev_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t   unsigned long ioctl_param)\n{\n\tstruct acrn_vm *vm = filp->private_data;\n\tstruct acrn_vm_creation *vm_param;\n\tstruct acrn_vcpu_regs *cpu_regs;\n\tstruct acrn_ioreq_notify notify;\n\tstruct acrn_ptdev_irq *irq_info;\n\tstruct acrn_ioeventfd ioeventfd;\n\tstruct acrn_vm_memmap memmap;\n\tstruct acrn_mmiodev *mmiodev;\n\tstruct acrn_msi_entry *msi;\n\tstruct acrn_pcidev *pcidev;\n\tstruct acrn_irqfd irqfd;\n\tstruct acrn_vdev *vdev;\n\tstruct page *page;\n\tu64 cstate_cmd;\n\tint i, ret = 0;\n\n\tif (vm->vmid == ACRN_INVALID_VMID && cmd != ACRN_IOCTL_CREATE_VM) {\n\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\"ioctl 0x%x: Invalid VM state!\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase ACRN_IOCTL_CREATE_VM:\n\t\tvm_param = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_vm_creation));\n\t\tif (IS_ERR(vm_param))\n\t\t\treturn PTR_ERR(vm_param);\n\n\t\tif ((vm_param->reserved0 | vm_param->reserved1) != 0) {\n\t\t\tkfree(vm_param);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvm = acrn_vm_create(vm, vm_param);\n\t\tif (!vm) {\n\t\t\tret = -EINVAL;\n\t\t\tkfree(vm_param);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user((void __user *)ioctl_param, vm_param,\n\t\t\t\t sizeof(struct acrn_vm_creation))) {\n\t\t\tacrn_vm_destroy(vm);\n\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(vm_param);\n\t\tbreak;\n\tcase ACRN_IOCTL_START_VM:\n\t\tret = hcall_start_vm(vm->vmid);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to start VM %u!\\n\", vm->vmid);\n\t\tbreak;\n\tcase ACRN_IOCTL_PAUSE_VM:\n\t\tret = hcall_pause_vm(vm->vmid);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to pause VM %u!\\n\", vm->vmid);\n\t\tbreak;\n\tcase ACRN_IOCTL_RESET_VM:\n\t\tret = hcall_reset_vm(vm->vmid);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to restart VM %u!\\n\", vm->vmid);\n\t\tbreak;\n\tcase ACRN_IOCTL_DESTROY_VM:\n\t\tret = acrn_vm_destroy(vm);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_VCPU_REGS:\n\t\tcpu_regs = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_vcpu_regs));\n\t\tif (IS_ERR(cpu_regs))\n\t\t\treturn PTR_ERR(cpu_regs);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->reserved); i++)\n\t\t\tif (cpu_regs->reserved[i]) {\n\t\t\t\tkfree(cpu_regs);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.reserved_32); i++)\n\t\t\tif (cpu_regs->vcpu_regs.reserved_32[i]) {\n\t\t\t\tkfree(cpu_regs);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.reserved_64); i++)\n\t\t\tif (cpu_regs->vcpu_regs.reserved_64[i]) {\n\t\t\t\tkfree(cpu_regs);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.gdt.reserved); i++)\n\t\t\tif (cpu_regs->vcpu_regs.gdt.reserved[i] |\n\t\t\t    cpu_regs->vcpu_regs.idt.reserved[i]) {\n\t\t\t\tkfree(cpu_regs);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\tret = hcall_set_vcpu_regs(vm->vmid, virt_to_phys(cpu_regs));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to set regs state of VM%u!\\n\",\n\t\t\t\tvm->vmid);\n\t\tkfree(cpu_regs);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_MEMSEG:\n\t\tif (copy_from_user(&memmap, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(memmap)))\n\t\t\treturn -EFAULT;\n\n\t\tret = acrn_vm_memseg_map(vm, &memmap);\n\t\tbreak;\n\tcase ACRN_IOCTL_UNSET_MEMSEG:\n\t\tif (copy_from_user(&memmap, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(memmap)))\n\t\t\treturn -EFAULT;\n\n\t\tret = acrn_vm_memseg_unmap(vm, &memmap);\n\t\tbreak;\n\tcase ACRN_IOCTL_ASSIGN_MMIODEV:\n\t\tmmiodev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t      sizeof(struct acrn_mmiodev));\n\t\tif (IS_ERR(mmiodev))\n\t\t\treturn PTR_ERR(mmiodev);\n\n\t\tret = hcall_assign_mmiodev(vm->vmid, virt_to_phys(mmiodev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to assign MMIO device!\\n\");\n\t\tkfree(mmiodev);\n\t\tbreak;\n\tcase ACRN_IOCTL_DEASSIGN_MMIODEV:\n\t\tmmiodev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t      sizeof(struct acrn_mmiodev));\n\t\tif (IS_ERR(mmiodev))\n\t\t\treturn PTR_ERR(mmiodev);\n\n\t\tret = hcall_deassign_mmiodev(vm->vmid, virt_to_phys(mmiodev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to deassign MMIO device!\\n\");\n\t\tkfree(mmiodev);\n\t\tbreak;\n\tcase ACRN_IOCTL_ASSIGN_PCIDEV:\n\t\tpcidev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t     sizeof(struct acrn_pcidev));\n\t\tif (IS_ERR(pcidev))\n\t\t\treturn PTR_ERR(pcidev);\n\n\t\tret = hcall_assign_pcidev(vm->vmid, virt_to_phys(pcidev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to assign pci device!\\n\");\n\t\tkfree(pcidev);\n\t\tbreak;\n\tcase ACRN_IOCTL_DEASSIGN_PCIDEV:\n\t\tpcidev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t     sizeof(struct acrn_pcidev));\n\t\tif (IS_ERR(pcidev))\n\t\t\treturn PTR_ERR(pcidev);\n\n\t\tret = hcall_deassign_pcidev(vm->vmid, virt_to_phys(pcidev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to deassign pci device!\\n\");\n\t\tkfree(pcidev);\n\t\tbreak;\n\tcase ACRN_IOCTL_CREATE_VDEV:\n\t\tvdev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t   sizeof(struct acrn_vdev));\n\t\tif (IS_ERR(vdev))\n\t\t\treturn PTR_ERR(vdev);\n\n\t\tret = hcall_create_vdev(vm->vmid, virt_to_phys(vdev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to create virtual device!\\n\");\n\t\tkfree(vdev);\n\t\tbreak;\n\tcase ACRN_IOCTL_DESTROY_VDEV:\n\t\tvdev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t   sizeof(struct acrn_vdev));\n\t\tif (IS_ERR(vdev))\n\t\t\treturn PTR_ERR(vdev);\n\t\tret = hcall_destroy_vdev(vm->vmid, virt_to_phys(vdev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to destroy virtual device!\\n\");\n\t\tkfree(vdev);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_PTDEV_INTR:\n\t\tirq_info = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_ptdev_irq));\n\t\tif (IS_ERR(irq_info))\n\t\t\treturn PTR_ERR(irq_info);\n\n\t\tret = hcall_set_ptdev_intr(vm->vmid, virt_to_phys(irq_info));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to configure intr for ptdev!\\n\");\n\t\tkfree(irq_info);\n\t\tbreak;\n\tcase ACRN_IOCTL_RESET_PTDEV_INTR:\n\t\tirq_info = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_ptdev_irq));\n\t\tif (IS_ERR(irq_info))\n\t\t\treturn PTR_ERR(irq_info);\n\n\t\tret = hcall_reset_ptdev_intr(vm->vmid, virt_to_phys(irq_info));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to reset intr for ptdev!\\n\");\n\t\tkfree(irq_info);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_IRQLINE:\n\t\tret = hcall_set_irqline(vm->vmid, ioctl_param);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to set interrupt line!\\n\");\n\t\tbreak;\n\tcase ACRN_IOCTL_INJECT_MSI:\n\t\tmsi = memdup_user((void __user *)ioctl_param,\n\t\t\t\t  sizeof(struct acrn_msi_entry));\n\t\tif (IS_ERR(msi))\n\t\t\treturn PTR_ERR(msi);\n\n\t\tret = hcall_inject_msi(vm->vmid, virt_to_phys(msi));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to inject MSI!\\n\");\n\t\tkfree(msi);\n\t\tbreak;\n\tcase ACRN_IOCTL_VM_INTR_MONITOR:\n\t\tret = pin_user_pages_fast(ioctl_param, 1,\n\t\t\t\t\t  FOLL_WRITE | FOLL_LONGTERM, &page);\n\t\tif (unlikely(ret != 1)) {\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to pin intr hdr buffer!\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tret = hcall_vm_intr_monitor(vm->vmid, page_to_phys(page));\n\t\tif (ret < 0) {\n\t\t\tunpin_user_page(page);\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to monitor intr data!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (vm->monitor_page)\n\t\t\tunpin_user_page(vm->monitor_page);\n\t\tvm->monitor_page = page;\n\t\tbreak;\n\tcase ACRN_IOCTL_CREATE_IOREQ_CLIENT:\n\t\tif (vm->default_client)\n\t\t\treturn -EEXIST;\n\t\tif (!acrn_ioreq_client_create(vm, NULL, NULL, true, \"acrndm\"))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase ACRN_IOCTL_DESTROY_IOREQ_CLIENT:\n\t\tif (vm->default_client)\n\t\t\tacrn_ioreq_client_destroy(vm->default_client);\n\t\tbreak;\n\tcase ACRN_IOCTL_ATTACH_IOREQ_CLIENT:\n\t\tif (vm->default_client)\n\t\t\tret = acrn_ioreq_client_wait(vm->default_client);\n\t\telse\n\t\t\tret = -ENODEV;\n\t\tbreak;\n\tcase ACRN_IOCTL_NOTIFY_REQUEST_FINISH:\n\t\tif (copy_from_user(&notify, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(struct acrn_ioreq_notify)))\n\t\t\treturn -EFAULT;\n\n\t\tif (notify.reserved != 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = acrn_ioreq_request_default_complete(vm, notify.vcpu);\n\t\tbreak;\n\tcase ACRN_IOCTL_CLEAR_VM_IOREQ:\n\t\tacrn_ioreq_request_clear(vm);\n\t\tbreak;\n\tcase ACRN_IOCTL_PM_GET_CPU_STATE:\n\t\tif (copy_from_user(&cstate_cmd, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(cstate_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tret = pmcmd_ioctl(cstate_cmd, (void __user *)ioctl_param);\n\t\tbreak;\n\tcase ACRN_IOCTL_IOEVENTFD:\n\t\tif (copy_from_user(&ioeventfd, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(ioeventfd)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ioeventfd.reserved != 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = acrn_ioeventfd_config(vm, &ioeventfd);\n\t\tbreak;\n\tcase ACRN_IOCTL_IRQFD:\n\t\tif (copy_from_user(&irqfd, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(irqfd)))\n\t\t\treturn -EFAULT;\n\t\tret = acrn_irqfd_config(vm, &irqfd);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(acrn_dev.this_device, \"Unknown IOCTL 0x%x!\\n\", cmd);\n\t\tret = -ENOTTY;\n\t}\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,8 +30,10 @@\n \t\tif (IS_ERR(vm_param))\n \t\t\treturn PTR_ERR(vm_param);\n \n-\t\tif ((vm_param->reserved0 | vm_param->reserved1) != 0)\n+\t\tif ((vm_param->reserved0 | vm_param->reserved1) != 0) {\n+\t\t\tkfree(vm_param);\n \t\t\treturn -EINVAL;\n+\t\t}\n \n \t\tvm = acrn_vm_create(vm, vm_param);\n \t\tif (!vm) {\n@@ -76,21 +78,29 @@\n \t\t\treturn PTR_ERR(cpu_regs);\n \n \t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->reserved); i++)\n-\t\t\tif (cpu_regs->reserved[i])\n+\t\t\tif (cpu_regs->reserved[i]) {\n+\t\t\t\tkfree(cpu_regs);\n \t\t\t\treturn -EINVAL;\n+\t\t\t}\n \n \t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.reserved_32); i++)\n-\t\t\tif (cpu_regs->vcpu_regs.reserved_32[i])\n+\t\t\tif (cpu_regs->vcpu_regs.reserved_32[i]) {\n+\t\t\t\tkfree(cpu_regs);\n \t\t\t\treturn -EINVAL;\n+\t\t\t}\n \n \t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.reserved_64); i++)\n-\t\t\tif (cpu_regs->vcpu_regs.reserved_64[i])\n+\t\t\tif (cpu_regs->vcpu_regs.reserved_64[i]) {\n+\t\t\t\tkfree(cpu_regs);\n \t\t\t\treturn -EINVAL;\n+\t\t\t}\n \n \t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.gdt.reserved); i++)\n \t\t\tif (cpu_regs->vcpu_regs.gdt.reserved[i] |\n-\t\t\t    cpu_regs->vcpu_regs.idt.reserved[i])\n+\t\t\t    cpu_regs->vcpu_regs.idt.reserved[i]) {\n+\t\t\t\tkfree(cpu_regs);\n \t\t\t\treturn -EINVAL;\n+\t\t\t}\n \n \t\tret = hcall_set_vcpu_regs(vm->vmid, virt_to_phys(cpu_regs));\n \t\tif (ret < 0)",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif ((vm_param->reserved0 | vm_param->reserved1) != 0)",
                "\t\t\tif (cpu_regs->reserved[i])",
                "\t\t\tif (cpu_regs->vcpu_regs.reserved_32[i])",
                "\t\t\tif (cpu_regs->vcpu_regs.reserved_64[i])",
                "\t\t\t    cpu_regs->vcpu_regs.idt.reserved[i])"
            ],
            "added_lines": [
                "\t\tif ((vm_param->reserved0 | vm_param->reserved1) != 0) {",
                "\t\t\tkfree(vm_param);",
                "\t\t}",
                "\t\t\tif (cpu_regs->reserved[i]) {",
                "\t\t\t\tkfree(cpu_regs);",
                "\t\t\t}",
                "\t\t\tif (cpu_regs->vcpu_regs.reserved_32[i]) {",
                "\t\t\t\tkfree(cpu_regs);",
                "\t\t\t}",
                "\t\t\tif (cpu_regs->vcpu_regs.reserved_64[i]) {",
                "\t\t\t\tkfree(cpu_regs);",
                "\t\t\t}",
                "\t\t\t    cpu_regs->vcpu_regs.idt.reserved[i]) {",
                "\t\t\t\tkfree(cpu_regs);",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12768",
        "func_name": "torvalds/linux/svm_cpu_init",
        "description": "An issue was discovered in the Linux kernel before 5.6. svm_cpu_uninit in arch/x86/kvm/svm.c has a memory leak, aka CID-d80b64ff297e. NOTE: third parties dispute this issue because it's a one-time leak at the boot, the size is negligible, and it can't be triggered at will",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=d80b64ff297e40c2b6f7d7abc1b3eba70d22a068",
        "commit_title": "When kmalloc memory for sd->sev_vmcbs failed, we forget to free the page",
        "commit_text": "held by sd->save_area. Also get rid of the var r as '-ENOMEM' is actually the only possible outcome here.  ",
        "func_before": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tr = -ENOMEM;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\n\tif (svm_sev_enabled()) {\n\t\tr = -ENOMEM;\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto err_1;\n\t}\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nerr_1:\n\tkfree(sd);\n\treturn r;\n\n}",
        "func": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto free_cpu_data;\n\n\tif (svm_sev_enabled()) {\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto free_save_area;\n\t}\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nfree_save_area:\n\t__free_page(sd->save_area);\nfree_cpu_data:\n\tkfree(sd);\n\treturn -ENOMEM;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,32 +1,31 @@\n static int svm_cpu_init(int cpu)\n {\n \tstruct svm_cpu_data *sd;\n-\tint r;\n \n \tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n \tif (!sd)\n \t\treturn -ENOMEM;\n \tsd->cpu = cpu;\n-\tr = -ENOMEM;\n \tsd->save_area = alloc_page(GFP_KERNEL);\n \tif (!sd->save_area)\n-\t\tgoto err_1;\n+\t\tgoto free_cpu_data;\n \n \tif (svm_sev_enabled()) {\n-\t\tr = -ENOMEM;\n \t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n \t\t\t\t\t      sizeof(void *),\n \t\t\t\t\t      GFP_KERNEL);\n \t\tif (!sd->sev_vmcbs)\n-\t\t\tgoto err_1;\n+\t\t\tgoto free_save_area;\n \t}\n \n \tper_cpu(svm_data, cpu) = sd;\n \n \treturn 0;\n \n-err_1:\n+free_save_area:\n+\t__free_page(sd->save_area);\n+free_cpu_data:\n \tkfree(sd);\n-\treturn r;\n+\treturn -ENOMEM;\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tint r;",
                "\tr = -ENOMEM;",
                "\t\tgoto err_1;",
                "\t\tr = -ENOMEM;",
                "\t\t\tgoto err_1;",
                "err_1:",
                "\treturn r;"
            ],
            "added_lines": [
                "\t\tgoto free_cpu_data;",
                "\t\t\tgoto free_save_area;",
                "free_save_area:",
                "\t__free_page(sd->save_area);",
                "free_cpu_data:",
                "\treturn -ENOMEM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20810",
        "func_name": "torvalds/linux/go7007_snd_init",
        "description": "go7007_snd_init in drivers/media/usb/go7007/snd-go7007.c in the Linux kernel before 5.6 does not call snd_card_free for a failure path, which causes a memory leak, aka CID-9453264ef586.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=9453264ef58638ce8976121ac44c07a3ef375983",
        "commit_title": "go7007_snd_init() misses a snd_card_free() in an error path.",
        "commit_text": "Add the missed call to fix it.  ",
        "func_before": "int go7007_snd_init(struct go7007 *go)\n{\n\tstatic int dev;\n\tstruct go7007_snd *gosnd;\n\tint ret;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\tgosnd = kmalloc(sizeof(struct go7007_snd), GFP_KERNEL);\n\tif (gosnd == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&gosnd->lock);\n\tgosnd->hw_ptr = gosnd->w_idx = gosnd->avail = 0;\n\tgosnd->capturing = 0;\n\tret = snd_card_new(go->dev, index[dev], id[dev], THIS_MODULE, 0,\n\t\t\t   &gosnd->card);\n\tif (ret < 0) {\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tret = snd_device_new(gosnd->card, SNDRV_DEV_LOWLEVEL, go,\n\t\t\t&go7007_snd_device_ops);\n\tif (ret < 0) {\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tret = snd_pcm_new(gosnd->card, \"go7007\", 0, 0, 1, &gosnd->pcm);\n\tif (ret < 0) {\n\t\tsnd_card_free(gosnd->card);\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\tstrscpy(gosnd->card->driver, \"go7007\", sizeof(gosnd->card->driver));\n\tstrscpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->shortname));\n\tstrscpy(gosnd->card->longname, gosnd->card->shortname,\n\t\tsizeof(gosnd->card->longname));\n\n\tgosnd->pcm->private_data = go;\n\tsnd_pcm_set_ops(gosnd->pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&go7007_snd_capture_ops);\n\n\tret = snd_card_register(gosnd->card);\n\tif (ret < 0) {\n\t\tsnd_card_free(gosnd->card);\n\t\tkfree(gosnd);\n\t\treturn ret;\n\t}\n\n\tgosnd->substream = NULL;\n\tgo->snd_context = gosnd;\n\tv4l2_device_get(&go->v4l2_dev);\n\t++dev;\n\n\treturn 0;\n}",
        "func": "int go7007_snd_init(struct go7007 *go)\n{\n\tstatic int dev;\n\tstruct go7007_snd *gosnd;\n\tint ret;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\tgosnd = kmalloc(sizeof(struct go7007_snd), GFP_KERNEL);\n\tif (gosnd == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&gosnd->lock);\n\tgosnd->hw_ptr = gosnd->w_idx = gosnd->avail = 0;\n\tgosnd->capturing = 0;\n\tret = snd_card_new(go->dev, index[dev], id[dev], THIS_MODULE, 0,\n\t\t\t   &gosnd->card);\n\tif (ret < 0)\n\t\tgoto free_snd;\n\n\tret = snd_device_new(gosnd->card, SNDRV_DEV_LOWLEVEL, go,\n\t\t\t&go7007_snd_device_ops);\n\tif (ret < 0)\n\t\tgoto free_card;\n\n\tret = snd_pcm_new(gosnd->card, \"go7007\", 0, 0, 1, &gosnd->pcm);\n\tif (ret < 0)\n\t\tgoto free_card;\n\n\tstrscpy(gosnd->card->driver, \"go7007\", sizeof(gosnd->card->driver));\n\tstrscpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->shortname));\n\tstrscpy(gosnd->card->longname, gosnd->card->shortname,\n\t\tsizeof(gosnd->card->longname));\n\n\tgosnd->pcm->private_data = go;\n\tsnd_pcm_set_ops(gosnd->pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&go7007_snd_capture_ops);\n\n\tret = snd_card_register(gosnd->card);\n\tif (ret < 0)\n\t\tgoto free_card;\n\n\tgosnd->substream = NULL;\n\tgo->snd_context = gosnd;\n\tv4l2_device_get(&go->v4l2_dev);\n\t++dev;\n\n\treturn 0;\n\nfree_card:\n\tsnd_card_free(gosnd->card);\nfree_snd:\n\tkfree(gosnd);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,22 +18,18 @@\n \tgosnd->capturing = 0;\n \tret = snd_card_new(go->dev, index[dev], id[dev], THIS_MODULE, 0,\n \t\t\t   &gosnd->card);\n-\tif (ret < 0) {\n-\t\tkfree(gosnd);\n-\t\treturn ret;\n-\t}\n+\tif (ret < 0)\n+\t\tgoto free_snd;\n+\n \tret = snd_device_new(gosnd->card, SNDRV_DEV_LOWLEVEL, go,\n \t\t\t&go7007_snd_device_ops);\n-\tif (ret < 0) {\n-\t\tkfree(gosnd);\n-\t\treturn ret;\n-\t}\n+\tif (ret < 0)\n+\t\tgoto free_card;\n+\n \tret = snd_pcm_new(gosnd->card, \"go7007\", 0, 0, 1, &gosnd->pcm);\n-\tif (ret < 0) {\n-\t\tsnd_card_free(gosnd->card);\n-\t\tkfree(gosnd);\n-\t\treturn ret;\n-\t}\n+\tif (ret < 0)\n+\t\tgoto free_card;\n+\n \tstrscpy(gosnd->card->driver, \"go7007\", sizeof(gosnd->card->driver));\n \tstrscpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->shortname));\n \tstrscpy(gosnd->card->longname, gosnd->card->shortname,\n@@ -44,11 +40,8 @@\n \t\t\t&go7007_snd_capture_ops);\n \n \tret = snd_card_register(gosnd->card);\n-\tif (ret < 0) {\n-\t\tsnd_card_free(gosnd->card);\n-\t\tkfree(gosnd);\n-\t\treturn ret;\n-\t}\n+\tif (ret < 0)\n+\t\tgoto free_card;\n \n \tgosnd->substream = NULL;\n \tgo->snd_context = gosnd;\n@@ -56,4 +49,10 @@\n \t++dev;\n \n \treturn 0;\n+\n+free_card:\n+\tsnd_card_free(gosnd->card);\n+free_snd:\n+\tkfree(gosnd);\n+\treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (ret < 0) {",
                "\t\tkfree(gosnd);",
                "\t\treturn ret;",
                "\t}",
                "\tif (ret < 0) {",
                "\t\tkfree(gosnd);",
                "\t\treturn ret;",
                "\t}",
                "\tif (ret < 0) {",
                "\t\tsnd_card_free(gosnd->card);",
                "\t\tkfree(gosnd);",
                "\t\treturn ret;",
                "\t}",
                "\tif (ret < 0) {",
                "\t\tsnd_card_free(gosnd->card);",
                "\t\tkfree(gosnd);",
                "\t\treturn ret;",
                "\t}"
            ],
            "added_lines": [
                "\tif (ret < 0)",
                "\t\tgoto free_snd;",
                "",
                "\tif (ret < 0)",
                "\t\tgoto free_card;",
                "",
                "\tif (ret < 0)",
                "\t\tgoto free_card;",
                "",
                "\tif (ret < 0)",
                "\t\tgoto free_card;",
                "",
                "free_card:",
                "\tsnd_card_free(gosnd->card);",
                "free_snd:",
                "\tkfree(gosnd);",
                "\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12887",
        "func_name": "mjurczak/mbed-coap/parse_ext_option",
        "description": "Memory leaks were discovered in the CoAP library in Arm Mbed OS 5.15.3 when using the Arm mbed-coap library 5.1.5. The CoAP parser is responsible for parsing received CoAP packets. The function sn_coap_parser_options_parse() parses the CoAP option number field of all options present in the input packet. Each option number is calculated as a sum of the previous option number and a delta of the current option. The delta and the previous option number are expressed as unsigned 16-bit integers. Due to lack of overflow detection, it is possible to craft a packet that wraps the option number around and results in the same option number being processed again in a single packet. Certain options allocate memory by calling a memory allocation function. In the cases of COAP_OPTION_URI_QUERY, COAP_OPTION_URI_PATH, COAP_OPTION_LOCATION_QUERY, and COAP_OPTION_ETAG, there is no check on whether memory has already been allocated, which in conjunction with the option number integer overflow may lead to multiple assignments of allocated memory to a single pointer. This has been demonstrated to lead to memory leak by buffer orphaning. As a result, the memory is never freed.",
        "git_url": "https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93",
        "commit_title": "Implemented measures to prevent memory leaks in sn_coap_parser_options_parse().",
        "commit_text": " Added a helper uint16_t addition function with overflow detection. The function is used when calculating the extended length and option delta. The overlow detection is needed to avoid wrap-around of option number or length. Additional checks in options using sn_coap_parser_options_parse_multiple_options() have been implemented to avoid overwriting of pointers pointing to previously allocated memory.",
        "func_before": "static int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n        else {\n                option_number += option_ext;\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                               packet_data_start_ptr,\n                                                               packet_len,\n                                                               1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                /* packet_data_pptr would overflow! */\n                tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n                return -1;\n            }\n            else {\n            option_number += 269;\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                           packet_data_start_ptr,\n                                                           packet_len,\n                                                           2);\n            }\n    }\n    /* Option number 15 reserved for payload marker. This is handled as a error! */\n    else if (option_number == 15) {\n        tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n        return -1;\n    }\n\n    *dst = option_number;\n    return 0;\n}",
        "func": "static int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n        else {\n            if(sn_coap_parser_add_u16_limit(option_number, option_ext, &option_number) != 0)\n            {\n                return -1;\n            }\n\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len,\n                                                            1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                /* packet_data_pptr would overflow! */\n                tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n                return -1;\n            }\n            else {\n                if(sn_coap_parser_add_u16_limit(option_number, 269, &option_number) != 0)\n                {\n                    return -1;\n                }\n\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len,\n                                                            2);\n            }\n    }\n    /* Option number 15 reserved for payload marker. This is handled as a error! */\n    else if (option_number == 15) {\n        tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n        return -1;\n    }\n\n    *dst = option_number;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,11 +14,15 @@\n             return -1;\n         }\n         else {\n-                option_number += option_ext;\n-                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n-                                                               packet_data_start_ptr,\n-                                                               packet_len,\n-                                                               1);\n+            if(sn_coap_parser_add_u16_limit(option_number, option_ext, &option_number) != 0)\n+            {\n+                return -1;\n+            }\n+\n+            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n+                                                            packet_data_start_ptr,\n+                                                            packet_len,\n+                                                            1);\n         }\n     } else if (option_number == 14) {\n             int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n@@ -31,11 +35,15 @@\n                 return -1;\n             }\n             else {\n-            option_number += 269;\n-            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n-                                                           packet_data_start_ptr,\n-                                                           packet_len,\n-                                                           2);\n+                if(sn_coap_parser_add_u16_limit(option_number, 269, &option_number) != 0)\n+                {\n+                    return -1;\n+                }\n+\n+                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n+                                                            packet_data_start_ptr,\n+                                                            packet_len,\n+                                                            2);\n             }\n     }\n     /* Option number 15 reserved for payload marker. This is handled as a error! */",
        "diff_line_info": {
            "deleted_lines": [
                "                option_number += option_ext;",
                "                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,",
                "                                                               packet_data_start_ptr,",
                "                                                               packet_len,",
                "                                                               1);",
                "            option_number += 269;",
                "            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,",
                "                                                           packet_data_start_ptr,",
                "                                                           packet_len,",
                "                                                           2);"
            ],
            "added_lines": [
                "            if(sn_coap_parser_add_u16_limit(option_number, option_ext, &option_number) != 0)",
                "            {",
                "                return -1;",
                "            }",
                "",
                "            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,",
                "                                                            packet_data_start_ptr,",
                "                                                            packet_len,",
                "                                                            1);",
                "                if(sn_coap_parser_add_u16_limit(option_number, 269, &option_number) != 0)",
                "                {",
                "                    return -1;",
                "                }",
                "",
                "                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,",
                "                                                            packet_data_start_ptr,",
                "                                                            packet_len,",
                "                                                            2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12887",
        "func_name": "mjurczak/mbed-coap/sn_coap_parser_options_parse",
        "description": "Memory leaks were discovered in the CoAP library in Arm Mbed OS 5.15.3 when using the Arm mbed-coap library 5.1.5. The CoAP parser is responsible for parsing received CoAP packets. The function sn_coap_parser_options_parse() parses the CoAP option number field of all options present in the input packet. Each option number is calculated as a sum of the previous option number and a delta of the current option. The delta and the previous option number are expressed as unsigned 16-bit integers. Due to lack of overflow detection, it is possible to craft a packet that wraps the option number around and results in the same option number being processed again in a single packet. Certain options allocate memory by calling a memory allocation function. In the cases of COAP_OPTION_URI_QUERY, COAP_OPTION_URI_PATH, COAP_OPTION_LOCATION_QUERY, and COAP_OPTION_ETAG, there is no check on whether memory has already been allocated, which in conjunction with the option number integer overflow may lead to multiple assignments of allocated memory to a single pointer. This has been demonstrated to lead to memory leak by buffer orphaning. As a result, the memory is never freed.",
        "git_url": "https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93",
        "commit_title": "Implemented measures to prevent memory leaks in sn_coap_parser_options_parse().",
        "commit_text": " Added a helper uint16_t addition function with overflow detection. The function is used when calculating the extended length and option delta. The overlow detection is needed to avoid wrap-around of option number or length. Additional checks in options using sn_coap_parser_options_parse_multiple_options() have been implemented to avoid overwriting of pointers pointing to previously allocated memory.",
        "func_before": "static int8_t sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    uint8_t previous_option_number = 0;\n    int8_t  ret_status             = 0;\n    uint16_t message_left          = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                                    packet_data_start_ptr,\n                                                                    packet_len,\n                                                                    0);\n\n    /*  Parse token, if exists  */\n    dst_coap_msg_ptr->token_len = *packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK;\n\n    if (dst_coap_msg_ptr->token_len) {\n        int8_t ptr_check_result;\n        if ((dst_coap_msg_ptr->token_len > 8) || dst_coap_msg_ptr->token_ptr) {\n            tr_error(\"sn_coap_parser_options_parse - token not valid!\");\n            return -1;\n        }\n\n        ptr_check_result = sn_coap_parser_check_packet_ptr(*packet_data_pptr, packet_data_start_ptr, packet_len, dst_coap_msg_ptr->token_len);\n        if (0 != ptr_check_result) {\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n\n        dst_coap_msg_ptr->token_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, dst_coap_msg_ptr->token_len);\n\n        if (dst_coap_msg_ptr->token_ptr == NULL) {\n            tr_error(\"sn_coap_parser_options_parse - failed to allocate token!\");\n            return -1;\n        }\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      dst_coap_msg_ptr->token_len);\n    }\n\n    /* Loop all Options */\n    while (message_left && (**packet_data_pptr != 0xff)) {\n        /* Get option length WITHOUT extensions */\n        uint16_t option_len = (**packet_data_pptr & 0x0F);\n        /* Get option number WITHOUT extensions */\n        uint16_t  option_number = (**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT);\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, 1);\n\n        int8_t    option_parse_result;\n        /* Add possible option delta extension */\n        option_parse_result = parse_ext_option(&option_number,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n        /* Add previous option to option delta and get option number */\n        option_number += previous_option_number;\n\n        /* Add possible option length extension to resolve full length of the option */\n        option_parse_result = parse_ext_option(&option_len,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n\n        /* * * Parse option itself * * */\n        /* Some options are handled independently in own functions */\n        previous_option_number = option_number;\n        /* Allocate options_list_ptr if needed */\n        switch (option_number) {\n            case COAP_OPTION_MAX_AGE:\n            case COAP_OPTION_PROXY_URI:\n            case COAP_OPTION_ETAG:\n            case COAP_OPTION_URI_HOST:\n            case COAP_OPTION_LOCATION_PATH:\n            case COAP_OPTION_URI_PORT:\n            case COAP_OPTION_LOCATION_QUERY:\n            case COAP_OPTION_OBSERVE:\n            case COAP_OPTION_URI_QUERY:\n            case COAP_OPTION_BLOCK2:\n            case COAP_OPTION_BLOCK1:\n            case COAP_OPTION_ACCEPT:\n            case COAP_OPTION_SIZE1:\n            case COAP_OPTION_SIZE2:\n                if (sn_coap_parser_alloc_options(handle, dst_coap_msg_ptr) == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - failed to allocate options!\");\n                    return -1;\n                }\n                break;\n        }\n\n        if (message_left < option_len){\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr would overflow when parsing options!\");\n            return -1;\n        }\n\n        /* Parse option */\n        switch (option_number) {\n            case COAP_OPTION_CONTENT_FORMAT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->content_format != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_CONTENT_FORMAT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->content_format = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_MAX_AGE:\n                if (option_len > 4) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_MAX_AGE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->max_age = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_PROXY_URI:\n                if ((option_len > 1034) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_ETAG:\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr,\n                             message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->etag_ptr,\n                             (uint16_t *)&dst_coap_msg_ptr->options_list_ptr->etag_len,\n                             COAP_OPTION_ETAG, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_HOST:\n                if ((option_len > 255) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->uri_host_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_host_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->uri_host_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->uri_host_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_PATH:\n                if (dst_coap_msg_ptr->options_list_ptr->location_path_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH exists!\");\n                    return -1;\n                }\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_path_ptr, &dst_coap_msg_ptr->options_list_ptr->location_path_len,\n                             COAP_OPTION_LOCATION_PATH, option_len);\n                if (ret_status <0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_PORT:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PORT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_port = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_query_ptr, &dst_coap_msg_ptr->options_list_ptr->location_query_len,\n                             COAP_OPTION_LOCATION_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY not valid!\");\n                    return -1;\n                }\n\n                break;\n\n            case COAP_OPTION_URI_PATH:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->uri_path_ptr, &dst_coap_msg_ptr->uri_path_len,\n                             COAP_OPTION_URI_PATH, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_OBSERVE:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_OBSERVE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->observe = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_URI_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->uri_query_ptr, &dst_coap_msg_ptr->options_list_ptr->uri_query_len,\n                             COAP_OPTION_URI_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_QUERY not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_BLOCK2:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_BLOCK1:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_ACCEPT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ACCEPT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->accept = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE1:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size1) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size1 = true;\n                dst_coap_msg_ptr->options_list_ptr->size1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE2:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size2) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size2 = true;\n                dst_coap_msg_ptr->options_list_ptr->size2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            default:\n                tr_error(\"sn_coap_parser_options_parse - unknown option!\");\n                return -1;\n        }\n\n        /* Check for overflow */\n        if ((*packet_data_pptr - packet_data_start_ptr) > packet_len) {\n            return -1;\n        }\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      0);\n    }\n    return 0;\n}",
        "func": "static int8_t sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n{\n    uint8_t previous_option_number = 0;\n    int8_t  ret_status             = 0;\n    uint16_t message_left          = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                                    packet_data_start_ptr,\n                                                                    packet_len,\n                                                                    0);\n\n    /*  Parse token, if exists  */\n    dst_coap_msg_ptr->token_len = *packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK;\n\n    if (dst_coap_msg_ptr->token_len) {\n        int8_t ptr_check_result;\n        if ((dst_coap_msg_ptr->token_len > 8) || dst_coap_msg_ptr->token_ptr) {\n            tr_error(\"sn_coap_parser_options_parse - token not valid!\");\n            return -1;\n        }\n\n        ptr_check_result = sn_coap_parser_check_packet_ptr(*packet_data_pptr, packet_data_start_ptr, packet_len, dst_coap_msg_ptr->token_len);\n        if (0 != ptr_check_result) {\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n\n        dst_coap_msg_ptr->token_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, dst_coap_msg_ptr->token_len);\n\n        if (dst_coap_msg_ptr->token_ptr == NULL) {\n            tr_error(\"sn_coap_parser_options_parse - failed to allocate token!\");\n            return -1;\n        }\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      dst_coap_msg_ptr->token_len);\n    }\n\n    /* Loop all Options */\n    while (message_left && (**packet_data_pptr != 0xff)) {\n        /* Get option length WITHOUT extensions */\n        uint16_t option_len = (**packet_data_pptr & 0x0F);\n        /* Get option number WITHOUT extensions */\n        uint16_t  option_number = (**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT);\n\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, 1);\n\n        int8_t    option_parse_result;\n        /* Add possible option delta extension */\n        option_parse_result = parse_ext_option(&option_number,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n        /* Add previous option to option delta and get option number */\n        if(sn_coap_parser_add_u16_limit(option_number, previous_option_number, &option_number) != 0)\n        {\n            return -1;\n        }\n\n        /* Add possible option length extension to resolve full length of the option */\n        option_parse_result = parse_ext_option(&option_len,\n                                                packet_data_pptr,\n                                                packet_data_start_ptr,\n                                                packet_len,\n                                                &message_left);\n        if (option_parse_result != 0) {\n            return -1;\n        }\n\n        /* * * Parse option itself * * */\n        /* Some options are handled independently in own functions */\n        previous_option_number = option_number;\n        /* Allocate options_list_ptr if needed */\n        switch (option_number) {\n            case COAP_OPTION_MAX_AGE:\n            case COAP_OPTION_PROXY_URI:\n            case COAP_OPTION_ETAG:\n            case COAP_OPTION_URI_HOST:\n            case COAP_OPTION_LOCATION_PATH:\n            case COAP_OPTION_URI_PORT:\n            case COAP_OPTION_LOCATION_QUERY:\n            case COAP_OPTION_OBSERVE:\n            case COAP_OPTION_URI_QUERY:\n            case COAP_OPTION_BLOCK2:\n            case COAP_OPTION_BLOCK1:\n            case COAP_OPTION_ACCEPT:\n            case COAP_OPTION_SIZE1:\n            case COAP_OPTION_SIZE2:\n                if (sn_coap_parser_alloc_options(handle, dst_coap_msg_ptr) == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - failed to allocate options!\");\n                    return -1;\n                }\n                break;\n        }\n\n        if (message_left < option_len){\n            /* packet_data_pptr would overflow! */\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr would overflow when parsing options!\");\n            return -1;\n        }\n\n        /* Parse option */\n        switch (option_number) {\n            case COAP_OPTION_CONTENT_FORMAT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->content_format != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_CONTENT_FORMAT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->content_format = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_MAX_AGE:\n                if (option_len > 4) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_MAX_AGE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->max_age = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_PROXY_URI:\n                if ((option_len > 1034) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_ETAG:\n                if (dst_coap_msg_ptr->options_list_ptr->etag_ptr)\n                {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG exists!\");\n                    return -1;\n                }\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr,\n                             message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->etag_ptr,\n                             (uint16_t *)&dst_coap_msg_ptr->options_list_ptr->etag_len,\n                             COAP_OPTION_ETAG, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_HOST:\n                if ((option_len > 255) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->uri_host_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_host_len = option_len;\n                dst_coap_msg_ptr->options_list_ptr->uri_host_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n\n                if (dst_coap_msg_ptr->options_list_ptr->uri_host_ptr == NULL) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST allocation failed!\");\n                    return -1;\n                }\n                message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_PATH:\n                if (dst_coap_msg_ptr->options_list_ptr->location_path_ptr) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH exists!\");\n                    return -1;\n                }\n                /* This is managed independently because User gives this option in one character table */\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_path_ptr, &dst_coap_msg_ptr->options_list_ptr->location_path_len,\n                             COAP_OPTION_LOCATION_PATH, option_len);\n                if (ret_status <0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_URI_PORT:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PORT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->uri_port = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_LOCATION_QUERY:\n                if (dst_coap_msg_ptr->options_list_ptr->location_query_ptr)\n                {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY exists!\");\n                    return -1;\n                }\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->location_query_ptr, &dst_coap_msg_ptr->options_list_ptr->location_query_len,\n                             COAP_OPTION_LOCATION_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY not valid!\");\n                    return -1;\n                }\n\n                break;\n\n            case COAP_OPTION_URI_PATH:\n                if (dst_coap_msg_ptr->uri_path_ptr)\n                {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH exists!\");\n                    return -1;\n                }\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->uri_path_ptr, &dst_coap_msg_ptr->uri_path_len,\n                             COAP_OPTION_URI_PATH, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_OBSERVE:\n                if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_OBSERVE not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->observe = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_URI_QUERY:\n                ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                             &dst_coap_msg_ptr->options_list_ptr->uri_query_ptr, &dst_coap_msg_ptr->options_list_ptr->uri_query_len,\n                             COAP_OPTION_URI_QUERY, option_len);\n                if (ret_status < 0) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_QUERY not valid!\");\n                    return -1;\n                }\n                break;\n\n            case COAP_OPTION_BLOCK2:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_BLOCK1:\n                if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->block1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_ACCEPT:\n                if ((option_len > 2) || (dst_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE)) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ACCEPT not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->accept = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE1:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size1) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE1 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size1 = true;\n                dst_coap_msg_ptr->options_list_ptr->size1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            case COAP_OPTION_SIZE2:\n                if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size2) {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE2 not valid!\");\n                    return -1;\n                }\n                dst_coap_msg_ptr->options_list_ptr->use_size2 = true;\n                dst_coap_msg_ptr->options_list_ptr->size2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                break;\n\n            default:\n                tr_error(\"sn_coap_parser_options_parse - unknown option!\");\n                return -1;\n        }\n\n        /* Check for overflow */\n        if ((*packet_data_pptr - packet_data_start_ptr) > packet_len) {\n            return -1;\n        }\n        message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                      packet_data_start_ptr,\n                                                      packet_len,\n                                                      0);\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,7 +56,10 @@\n             return -1;\n         }\n         /* Add previous option to option delta and get option number */\n-        option_number += previous_option_number;\n+        if(sn_coap_parser_add_u16_limit(option_number, previous_option_number, &option_number) != 0)\n+        {\n+            return -1;\n+        }\n \n         /* Add possible option length extension to resolve full length of the option */\n         option_parse_result = parse_ext_option(&option_len,\n@@ -134,6 +137,11 @@\n                 break;\n \n             case COAP_OPTION_ETAG:\n+                if (dst_coap_msg_ptr->options_list_ptr->etag_ptr)\n+                {\n+                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG exists!\");\n+                    return -1;\n+                }\n                 /* This is managed independently because User gives this option in one character table */\n                 ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr,\n                              message_left,\n@@ -185,6 +193,11 @@\n                 break;\n \n             case COAP_OPTION_LOCATION_QUERY:\n+                if (dst_coap_msg_ptr->options_list_ptr->location_query_ptr)\n+                {\n+                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY exists!\");\n+                    return -1;\n+                }\n                 ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                              &dst_coap_msg_ptr->options_list_ptr->location_query_ptr, &dst_coap_msg_ptr->options_list_ptr->location_query_len,\n                              COAP_OPTION_LOCATION_QUERY, option_len);\n@@ -196,6 +209,11 @@\n                 break;\n \n             case COAP_OPTION_URI_PATH:\n+                if (dst_coap_msg_ptr->uri_path_ptr)\n+                {\n+                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH exists!\");\n+                    return -1;\n+                }\n                 ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                              &dst_coap_msg_ptr->uri_path_ptr, &dst_coap_msg_ptr->uri_path_len,\n                              COAP_OPTION_URI_PATH, option_len);",
        "diff_line_info": {
            "deleted_lines": [
                "        option_number += previous_option_number;"
            ],
            "added_lines": [
                "        if(sn_coap_parser_add_u16_limit(option_number, previous_option_number, &option_number) != 0)",
                "        {",
                "            return -1;",
                "        }",
                "                if (dst_coap_msg_ptr->options_list_ptr->etag_ptr)",
                "                {",
                "                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG exists!\");",
                "                    return -1;",
                "                }",
                "                if (dst_coap_msg_ptr->options_list_ptr->location_query_ptr)",
                "                {",
                "                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY exists!\");",
                "                    return -1;",
                "                }",
                "                if (dst_coap_msg_ptr->uri_path_ptr)",
                "                {",
                "                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH exists!\");",
                "                    return -1;",
                "                }"
            ]
        }
    }
]