[
    {
        "cve_id": "CVE-2019-15164",
        "func_name": "the-tcpdump-group/libpcap/daemon_msg_open_req",
        "description": "rpcapd/daemon.c in libpcap before 1.9.1 allows SSRF because a URL may be provided as a capture source.",
        "git_url": "https://github.com/the-tcpdump-group/libpcap/commit/33834cb2a4d035b52aa2a26742f832a112e90a0a",
        "commit_title": "In the open request, reject capture sources that are URLs.",
        "commit_text": " You shouldn't be able to ask a server to open a remote device on some *other* server; just open it yourself.  This addresses Include Security issue F13: [libpcap] Remote Packet Capture Daemon Allows Opening Capture URLs.",
        "func_before": "static int\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\tsource[nread] = '\\0';\n\tplen -= nread;\n\n\t// XXX - make sure it's *not* a URL; we don't support opening\n\t// remote devices here.\n\n\t// Open the selected device\n\t// This is a fake open, since we do that only to get the needed parameters, then we close the device again\n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\t// Now, I can send a RPCAP open reply message\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\t// We're done with the pcap_t.\n\tpcap_close(fp);\n\n\t// Send the reply.\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "func": "static int\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\tsource[nread] = '\\0';\n\tplen -= nread;\n\n\t// Is this a URL rather than a device?\n\t// If so, reject it.\n\tif (is_url(source))\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");\n\t\tgoto error;\n\t}\n\n\t// Open the selected device\n\t// This is a fake open, since we do that only to get the needed parameters, then we close the device again\n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\t// Now, I can send a RPCAP open reply message\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\t// We're done with the pcap_t.\n\tpcap_close(fp);\n\n\t// Send the reply.\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,8 +26,13 @@\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n-\t// XXX - make sure it's *not* a URL; we don't support opening\n-\t// remote devices here.\n+\t// Is this a URL rather than a device?\n+\t// If so, reject it.\n+\tif (is_url(source))\n+\t{\n+\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");\n+\t\tgoto error;\n+\t}\n \n \t// Open the selected device\n \t// This is a fake open, since we do that only to get the needed parameters, then we close the device again",
        "diff_line_info": {
            "deleted_lines": [
                "\t// XXX - make sure it's *not* a URL; we don't support opening",
                "\t// remote devices here."
            ],
            "added_lines": [
                "\t// Is this a URL rather than a device?",
                "\t// If so, reject it.",
                "\tif (is_url(source))",
                "\t{",
                "\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");",
                "\t\tgoto error;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25939",
        "func_name": "arangodb/ServerSecurityFeature::collectOptions",
        "description": "In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",
        "git_url": "https://github.com/arangodb/arangodb/commit/d9b7f019d2435f107b19a59190bf9cc27d5f34dd",
        "commit_title": "[APM-78] Disable installation from remote URL (#15292)",
        "commit_text": "",
        "func_before": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n\n}",
        "func": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  \n  options->addOption(\"--foxx.allow-install-from-remote\", \"allow installing Foxx apps from remote URLs other than Github\",\n                     new BooleanParameter(&_foxxAllowInstallFromRemote),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30805);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n                      .setIntroducedIn(30500);\n+\n   options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                      new BooleanParameter(&_enableFoxxStore),\n                      arangodb::options::makeFlags(\n@@ -19,5 +20,12 @@\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n                      .setIntroducedIn(30500);\n-\n+  \n+  options->addOption(\"--foxx.allow-install-from-remote\", \"allow installing Foxx apps from remote URLs other than Github\",\n+                     new BooleanParameter(&_foxxAllowInstallFromRemote),\n+                     arangodb::options::makeFlags(\n+                     arangodb::options::Flags::DefaultNoComponents,\n+                     arangodb::options::Flags::OnCoordinator,\n+                     arangodb::options::Flags::OnSingle))\n+                     .setIntroducedIn(30805);\n }",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "",
                "  ",
                "  options->addOption(\"--foxx.allow-install-from-remote\", \"allow installing Foxx apps from remote URLs other than Github\",",
                "                     new BooleanParameter(&_foxxAllowInstallFromRemote),",
                "                     arangodb::options::makeFlags(",
                "                     arangodb::options::Flags::DefaultNoComponents,",
                "                     arangodb::options::Flags::OnCoordinator,",
                "                     arangodb::options::Flags::OnSingle))",
                "                     .setIntroducedIn(30805);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25939",
        "func_name": "arangodb/ServerSecurityFeature::ServerSecurityFeature",
        "description": "In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",
        "git_url": "https://github.com/arangodb/arangodb/commit/d9b7f019d2435f107b19a59190bf9cc27d5f34dd",
        "commit_title": "[APM-78] Disable installation from remote URL (#15292)",
        "commit_text": "",
        "func_before": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}",
        "func": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false),\n      _foxxAllowInstallFromRemote(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,8 @@\n     : ApplicationFeature(server, \"ServerSecurity\"),\n       _enableFoxxApi(true),\n       _enableFoxxStore(true),\n-      _hardenedRestApi(false) {\n+      _hardenedRestApi(false),\n+      _foxxAllowInstallFromRemote(false) {\n   setOptional(false);\n   startsAfter<application_features::GreetingsFeaturePhase>();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      _hardenedRestApi(false) {"
            ],
            "added_lines": [
                "      _hardenedRestApi(false),",
                "      _foxxAllowInstallFromRemote(false) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25939",
        "func_name": "arangodb/TRI_InitV8ServerUtils",
        "description": "In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",
        "git_url": "https://github.com/arangodb/arangodb/commit/d9b7f019d2435f107b19a59190bf9cc27d5f34dd",
        "commit_title": "[APM-78] Disable installation from remote URL (#15292)",
        "commit_text": "",
        "func_before": "void TRI_InitV8ServerUtils(v8::Isolate* isolate) {\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_CLUSTER_API_JWT_POLICY\"), JS_ClusterApiJwtPolicy, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_API_DISABLED\"), JS_IsFoxxApiDisabled, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"), JS_IsFoxxStoreDisabled, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"), JS_RunInRestrictedContext, true);\n  \n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_CREATE_HOTBACKUP\"),\n                               JS_CreateHotbackup);\n\n  // debugging functions\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_CLEAR_FAILAT\"),\n                               JS_DebugClearFailAt);\n\n#ifdef ARANGODB_ENABLE_FAILURE_TESTS\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_TERMINATE\"), JS_DebugTerminate);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_SET_FAILAT\"),\n                               JS_DebugSetFailAt);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_REMOVE_FAILAT\"),\n                               JS_DebugRemoveFailAt);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_SHOULD_FAILAT\"),\n                               JS_DebugShouldFailAt);\n#endif\n\n  // poll interval for Foxx queues\n  TRI_GET_GLOBALS();\n  FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC, TRI_V8_ASCII_STRING(isolate, \"FOXX_QUEUES_POLL_INTERVAL\"),\n          v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC,\n          TRI_V8_ASCII_STRING(isolate, \"FOXX_STARTUP_WAIT_FOR_SELF_HEAL\"),\n          v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n}",
        "func": "void TRI_InitV8ServerUtils(v8::Isolate* isolate) {\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_CLUSTER_API_JWT_POLICY\"), JS_ClusterApiJwtPolicy, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_API_DISABLED\"), JS_IsFoxxApiDisabled, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"), JS_IsFoxxStoreDisabled, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE\"), JS_FoxxAllowInstallFromRemote, true);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"), JS_RunInRestrictedContext, true);\n  \n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_CREATE_HOTBACKUP\"),\n                               JS_CreateHotbackup);\n\n  // debugging functions\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_CLEAR_FAILAT\"),\n                               JS_DebugClearFailAt);\n\n#ifdef ARANGODB_ENABLE_FAILURE_TESTS\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_TERMINATE\"), JS_DebugTerminate);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_SET_FAILAT\"),\n                               JS_DebugSetFailAt);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_REMOVE_FAILAT\"),\n                               JS_DebugRemoveFailAt);\n  TRI_AddGlobalFunctionVocbase(isolate,\n                               TRI_V8_ASCII_STRING(isolate,\n                                                   \"SYS_DEBUG_SHOULD_FAILAT\"),\n                               JS_DebugShouldFailAt);\n#endif\n\n  // poll interval for Foxx queues\n  TRI_GET_GLOBALS();\n  FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC, TRI_V8_ASCII_STRING(isolate, \"FOXX_QUEUES_POLL_INTERVAL\"),\n          v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC,\n          TRI_V8_ASCII_STRING(isolate, \"FOXX_STARTUP_WAIT_FOR_SELF_HEAL\"),\n          v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n                                TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_API_DISABLED\"), JS_IsFoxxApiDisabled, true);\n   TRI_AddGlobalFunctionVocbase(isolate,\n                                TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"), JS_IsFoxxStoreDisabled, true);\n+  TRI_AddGlobalFunctionVocbase(isolate,\n+                               TRI_V8_ASCII_STRING(isolate, \"SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE\"), JS_FoxxAllowInstallFromRemote, true);\n   TRI_AddGlobalFunctionVocbase(isolate,\n                                TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"), JS_RunInRestrictedContext, true);\n   ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  TRI_AddGlobalFunctionVocbase(isolate,",
                "                               TRI_V8_ASCII_STRING(isolate, \"SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE\"), JS_FoxxAllowInstallFromRemote, true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25939",
        "func_name": "arangodb/ServerSecurityFeature::collectOptions",
        "description": "In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",
        "git_url": "https://github.com/arangodb/arangodb/commit/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175",
        "commit_title": "[APM-78] Disable installation from remote URL (#15292) (#15343)",
        "commit_text": " * [APM-78] Disable installation from remote URL (#15292)\r \r * Update CHANGELOG\r \r * Fix clang-format\r \r Co-authored-by: Vadim <vadim@arangodb.com>",
        "func_before": "void ServerSecurityFeature::collectOptions(\n    std::shared_ptr<ProgramOptions> options) {\n  options\n      ->addOption(\n          \"--server.harden\",\n          \"lock down REST APIs that reveal version information or server \"\n          \"internals for non-admin users\",\n          new BooleanParameter(&_hardenedRestApi))\n      .setIntroducedIn(30500);\n\n  options\n      ->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                  new BooleanParameter(&_enableFoxxApi),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                  new BooleanParameter(&_enableFoxxStore),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n}",
        "func": "void ServerSecurityFeature::collectOptions(\n    std::shared_ptr<ProgramOptions> options) {\n  options\n      ->addOption(\n          \"--server.harden\",\n          \"lock down REST APIs that reveal version information or server \"\n          \"internals for non-admin users\",\n          new BooleanParameter(&_hardenedRestApi))\n      .setIntroducedIn(30500);\n\n  options\n      ->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                  new BooleanParameter(&_enableFoxxApi),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                  new BooleanParameter(&_enableFoxxStore),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\n          \"--foxx.allow-install-from-remote\",\n          \"allow installing Foxx apps from remote URLs other than Github\",\n          new BooleanParameter(&_foxxAllowInstallFromRemote),\n          arangodb::options::makeFlags(\n              arangodb::options::Flags::DefaultNoComponents,\n              arangodb::options::Flags::OnCoordinator,\n              arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30805);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,4 +24,14 @@\n                       arangodb::options::Flags::OnCoordinator,\n                       arangodb::options::Flags::OnSingle))\n       .setIntroducedIn(30500);\n+  options\n+      ->addOption(\n+          \"--foxx.allow-install-from-remote\",\n+          \"allow installing Foxx apps from remote URLs other than Github\",\n+          new BooleanParameter(&_foxxAllowInstallFromRemote),\n+          arangodb::options::makeFlags(\n+              arangodb::options::Flags::DefaultNoComponents,\n+              arangodb::options::Flags::OnCoordinator,\n+              arangodb::options::Flags::OnSingle))\n+      .setIntroducedIn(30805);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  options",
                "      ->addOption(",
                "          \"--foxx.allow-install-from-remote\",",
                "          \"allow installing Foxx apps from remote URLs other than Github\",",
                "          new BooleanParameter(&_foxxAllowInstallFromRemote),",
                "          arangodb::options::makeFlags(",
                "              arangodb::options::Flags::DefaultNoComponents,",
                "              arangodb::options::Flags::OnCoordinator,",
                "              arangodb::options::Flags::OnSingle))",
                "      .setIntroducedIn(30805);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25939",
        "func_name": "arangodb/ServerSecurityFeature::ServerSecurityFeature",
        "description": "In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",
        "git_url": "https://github.com/arangodb/arangodb/commit/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175",
        "commit_title": "[APM-78] Disable installation from remote URL (#15292) (#15343)",
        "commit_text": " * [APM-78] Disable installation from remote URL (#15292)\r \r * Update CHANGELOG\r \r * Fix clang-format\r \r Co-authored-by: Vadim <vadim@arangodb.com>",
        "func_before": "ServerSecurityFeature::ServerSecurityFeature(\n    application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}",
        "func": "ServerSecurityFeature::ServerSecurityFeature(\n    application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false),\n      _foxxAllowInstallFromRemote(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,8 @@\n     : ApplicationFeature(server, \"ServerSecurity\"),\n       _enableFoxxApi(true),\n       _enableFoxxStore(true),\n-      _hardenedRestApi(false) {\n+      _hardenedRestApi(false),\n+      _foxxAllowInstallFromRemote(false) {\n   setOptional(false);\n   startsAfter<application_features::GreetingsFeaturePhase>();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      _hardenedRestApi(false) {"
            ],
            "added_lines": [
                "      _hardenedRestApi(false),",
                "      _foxxAllowInstallFromRemote(false) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25939",
        "func_name": "arangodb/TRI_InitV8ServerUtils",
        "description": "In ArangoDB, versions v3.7.0 through v3.9.0-alpha.1 have a feature which allows downloading a Foxx service from a publicly available URL. This feature does not enforce proper filtering of requests performed internally, which can be abused by a highly-privileged attacker to perform blind SSRF and send internal requests to localhost.",
        "git_url": "https://github.com/arangodb/arangodb/commit/d7b35a6884c6b2802d34d79fb2a79fb2c9ec2175",
        "commit_title": "[APM-78] Disable installation from remote URL (#15292) (#15343)",
        "commit_text": " * [APM-78] Disable installation from remote URL (#15292)\r \r * Update CHANGELOG\r \r * Fix clang-format\r \r Co-authored-by: Vadim <vadim@arangodb.com>",
        "func_before": "void TRI_InitV8ServerUtils(v8::Isolate* isolate) {\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_CLUSTER_API_JWT_POLICY\"),\n      JS_ClusterApiJwtPolicy, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_API_DISABLED\"),\n      JS_IsFoxxApiDisabled, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"),\n      JS_IsFoxxStoreDisabled, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"),\n      JS_RunInRestrictedContext, true);\n\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_CREATE_HOTBACKUP\"),\n      JS_CreateHotbackup);\n\n  // debugging functions\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_CLEAR_FAILAT\"),\n      JS_DebugClearFailAt);\n\n#ifdef ARANGODB_ENABLE_FAILURE_TESTS\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_TERMINATE\"),\n      JS_DebugTerminate);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_SET_FAILAT\"),\n      JS_DebugSetFailAt);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_REMOVE_FAILAT\"),\n      JS_DebugRemoveFailAt);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_SHOULD_FAILAT\"),\n      JS_DebugShouldFailAt);\n#endif\n\n  // poll interval for Foxx queues\n  TRI_GET_GLOBALS();\n  FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC, TRI_V8_ASCII_STRING(isolate, \"FOXX_QUEUES_POLL_INTERVAL\"),\n          v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC,\n          TRI_V8_ASCII_STRING(isolate, \"FOXX_STARTUP_WAIT_FOR_SELF_HEAL\"),\n          v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()),\n          v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n}",
        "func": "void TRI_InitV8ServerUtils(v8::Isolate* isolate) {\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_CLUSTER_API_JWT_POLICY\"),\n      JS_ClusterApiJwtPolicy, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_API_DISABLED\"),\n      JS_IsFoxxApiDisabled, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"),\n      JS_IsFoxxStoreDisabled, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate,\n      TRI_V8_ASCII_STRING(isolate, \"SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE\"),\n      JS_FoxxAllowInstallFromRemote, true);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"),\n      JS_RunInRestrictedContext, true);\n\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_CREATE_HOTBACKUP\"),\n      JS_CreateHotbackup);\n\n  // debugging functions\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_CLEAR_FAILAT\"),\n      JS_DebugClearFailAt);\n\n#ifdef ARANGODB_ENABLE_FAILURE_TESTS\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_TERMINATE\"),\n      JS_DebugTerminate);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_SET_FAILAT\"),\n      JS_DebugSetFailAt);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_REMOVE_FAILAT\"),\n      JS_DebugRemoveFailAt);\n  TRI_AddGlobalFunctionVocbase(\n      isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_DEBUG_SHOULD_FAILAT\"),\n      JS_DebugShouldFailAt);\n#endif\n\n  // poll interval for Foxx queues\n  TRI_GET_GLOBALS();\n  FoxxFeature& foxxFeature = v8g->_server.getFeature<FoxxFeature>();\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC, TRI_V8_ASCII_STRING(isolate, \"FOXX_QUEUES_POLL_INTERVAL\"),\n          v8::Number::New(isolate, foxxFeature.pollInterval()), v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n\n  isolate->GetCurrentContext()\n      ->Global()\n      ->DefineOwnProperty(\n          TRI_IGETC,\n          TRI_V8_ASCII_STRING(isolate, \"FOXX_STARTUP_WAIT_FOR_SELF_HEAL\"),\n          v8::Boolean::New(isolate, foxxFeature.startupWaitForSelfHeal()),\n          v8::ReadOnly)\n      .FromMaybe(false);  // ignore result\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,10 @@\n   TRI_AddGlobalFunctionVocbase(\n       isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_IS_FOXX_STORE_DISABLED\"),\n       JS_IsFoxxStoreDisabled, true);\n+  TRI_AddGlobalFunctionVocbase(\n+      isolate,\n+      TRI_V8_ASCII_STRING(isolate, \"SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE\"),\n+      JS_FoxxAllowInstallFromRemote, true);\n   TRI_AddGlobalFunctionVocbase(\n       isolate, TRI_V8_ASCII_STRING(isolate, \"SYS_RUN_IN_RESTRICTED_CONTEXT\"),\n       JS_RunInRestrictedContext, true);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  TRI_AddGlobalFunctionVocbase(",
                "      isolate,",
                "      TRI_V8_ASCII_STRING(isolate, \"SYS_FOXX_ALLOW_INSTALL_FROM_REMOTE\"),",
                "      JS_FoxxAllowInstallFromRemote, true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7272",
        "func_name": "php/php-src/parse_ip_address_ex",
        "description": "PHP through 7.1.11 enables potential SSRF in applications that accept an fsockopen or pfsockopen hostname argument with an expectation that the port number is constrained. Because a :port syntax is recognized, fsockopen will use the port number that is specified in the hostname argument, instead of the port number in the second argument of the function.",
        "git_url": "https://github.com/php/php-src/commit/bab0b99f376dac9170ac81382a5ed526938d595a",
        "commit_title": "Detect invalid port in xp_socket parse ip address",
        "commit_text": " For historical reasons, fsockopen() accepts the port and hostname separately: fsockopen('127.0.0.1', 80)  However, with the introdcution of stream transports in PHP 4.3, it became possible to include the port in the hostname specifier:  fsockopen('127.0.0.1:80') Or more formally: fsockopen('tcp://127.0.0.1:80')  Confusing results when these two forms are combined, however. fsockopen('127.0.0.1:80', 443) results in fsockopen() attempting to connect to '127.0.0.1:80:443' which any reasonable stack would consider invalid.  Unfortunately, PHP parses the address looking for the first colon (with special handling for IPv6, don't worry) and calls atoi() from there.  atoi() in turn, simply stops parsing at the first non-numeric character and returns the value so far.  The end result is that the explicitly supplied port is treated as ignored garbage, rather than producing an error.  This diff replaces atoi() with strtol() and inspects the stop character.  If additional \"garbage\" of any kind is found, it fails and returns an error.",
        "func_before": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n\tchar *host = NULL;\n\n#ifdef HAVE_IPV6\n\tchar *p;\n\n\tif (*(str) == '[' && str_len > 1) {\n\t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n\t\tp = memchr(str + 1, ']', str_len - 2);\n\t\tif (!p || *(p + 1) != ':') {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t*portno = atoi(p + 2);\n\t\treturn estrndup(str + 1, p - str - 1);\n\t}\n#endif\n\tif (str_len) {\n\t\tcolon = memchr(str, ':', str_len - 1);\n\t} else {\n\t\tcolon = NULL;\n\t}\n\tif (colon) {\n\t\t*portno = atoi(colon + 1);\n\t\thost = estrndup(str, colon - str);\n\t} else {\n\t\tif (get_err) {\n\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn host;\n}",
        "func": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n\tchar *host = NULL;\n\n#ifdef HAVE_IPV6\n\tif (*(str) == '[' && str_len > 1) {\n\t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n\t\tchar *p = memchr(str + 1, ']', str_len - 2), *e = NULL;\n\t\tif (!p || *(p + 1) != ':') {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t*portno = strtol(p + 2, &e, 10);\n\t\tif (e && *e) {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\treturn estrndup(str + 1, p - str - 1);\n\t}\n#endif\n\n\tif (str_len) {\n\t\tcolon = memchr(str, ':', str_len - 1);\n\t} else {\n\t\tcolon = NULL;\n\t}\n\n\tif (colon) {\n\t\tchar *e = NULL;\n\t\t*portno = strtol(colon + 1, &e, 10);\n\t\tif (!e || !*e) {\n\t\t\treturn estrndup(str, colon - str);\n\t\t}\n\t}\n\n\tif (get_err) {\n\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t}\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,35 +4,42 @@\n \tchar *host = NULL;\n \n #ifdef HAVE_IPV6\n-\tchar *p;\n-\n \tif (*(str) == '[' && str_len > 1) {\n \t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n-\t\tp = memchr(str + 1, ']', str_len - 2);\n+\t\tchar *p = memchr(str + 1, ']', str_len - 2), *e = NULL;\n \t\tif (!p || *(p + 1) != ':') {\n \t\t\tif (get_err) {\n \t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n \t\t\t}\n \t\t\treturn NULL;\n \t\t}\n-\t\t*portno = atoi(p + 2);\n+\t\t*portno = strtol(p + 2, &e, 10);\n+\t\tif (e && *e) {\n+\t\t\tif (get_err) {\n+\t\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n+\t\t\t}\n+\t\t\treturn NULL;\n+\t\t}\n \t\treturn estrndup(str + 1, p - str - 1);\n \t}\n #endif\n+\n \tif (str_len) {\n \t\tcolon = memchr(str, ':', str_len - 1);\n \t} else {\n \t\tcolon = NULL;\n \t}\n+\n \tif (colon) {\n-\t\t*portno = atoi(colon + 1);\n-\t\thost = estrndup(str, colon - str);\n-\t} else {\n-\t\tif (get_err) {\n-\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n+\t\tchar *e = NULL;\n+\t\t*portno = strtol(colon + 1, &e, 10);\n+\t\tif (!e || !*e) {\n+\t\t\treturn estrndup(str, colon - str);\n \t\t}\n-\t\treturn NULL;\n \t}\n \n-\treturn host;\n+\tif (get_err) {\n+\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n+\t}\n+\treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar *p;",
                "",
                "\t\tp = memchr(str + 1, ']', str_len - 2);",
                "\t\t*portno = atoi(p + 2);",
                "\t\t*portno = atoi(colon + 1);",
                "\t\thost = estrndup(str, colon - str);",
                "\t} else {",
                "\t\tif (get_err) {",
                "\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);",
                "\t\treturn NULL;",
                "\treturn host;"
            ],
            "added_lines": [
                "\t\tchar *p = memchr(str + 1, ']', str_len - 2), *e = NULL;",
                "\t\t*portno = strtol(p + 2, &e, 10);",
                "\t\tif (e && *e) {",
                "\t\t\tif (get_err) {",
                "\t\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);",
                "\t\t\t}",
                "\t\t\treturn NULL;",
                "\t\t}",
                "",
                "",
                "\t\tchar *e = NULL;",
                "\t\t*portno = strtol(colon + 1, &e, 10);",
                "\t\tif (!e || !*e) {",
                "\t\t\treturn estrndup(str, colon - str);",
                "\tif (get_err) {",
                "\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);",
                "\t}",
                "\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-24806",
        "func_name": "libuv/uv__idna_toascii",
        "description": "libuv is a multi-platform support library with a focus on asynchronous I/O. The `uv_getaddrinfo` function in `src/unix/getaddrinfo.c` (and its windows counterpart `src/win/getaddrinfo.c`), truncates hostnames to 256 characters before calling `getaddrinfo`. This behavior can be exploited to create addresses like `0x00007f000001`, which are considered valid by `getaddrinfo` and could allow an attacker to craft payloads that resolve to unintended IP addresses, bypassing developer checks. The vulnerability arises due to how the `hostname_ascii` variable (with a length of 256 bytes) is handled in `uv_getaddrinfo` and subsequently in `uv__idna_toascii`. When the hostname exceeds 256 characters, it gets truncated without a terminating null byte. As a result attackers may be able to access internal APIs or for websites (similar to MySpace) that allows users to have `username.example.com` pages. Internal services that crawl or cache these user pages can be exposed to SSRF attacks if a malicious user chooses a long vulnerable username. This issue has been addressed in release version 1.48.0. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/libuv/libuv/commit/0f2d7e784a256b54b2385043438848047bc2a629",
        "commit_title": "fix: always zero-terminate idna output",
        "commit_text": "",
        "func_before": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d < de)\n    *d++ = '\\0';\n\n  return d - ds;  /* Number of bytes written. */\n}",
        "func": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,8 +39,9 @@\n       return rc;\n   }\n \n-  if (d < de)\n-    *d++ = '\\0';\n+  if (d >= de)\n+    return UV_EINVAL;\n \n+  *d++ = '\\0';\n   return d - ds;  /* Number of bytes written. */\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (d < de)",
                "    *d++ = '\\0';"
            ],
            "added_lines": [
                "  if (d >= de)",
                "    return UV_EINVAL;",
                "  *d++ = '\\0';"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-24806",
        "func_name": "libuv/uv__idna_toascii",
        "description": "libuv is a multi-platform support library with a focus on asynchronous I/O. The `uv_getaddrinfo` function in `src/unix/getaddrinfo.c` (and its windows counterpart `src/win/getaddrinfo.c`), truncates hostnames to 256 characters before calling `getaddrinfo`. This behavior can be exploited to create addresses like `0x00007f000001`, which are considered valid by `getaddrinfo` and could allow an attacker to craft payloads that resolve to unintended IP addresses, bypassing developer checks. The vulnerability arises due to how the `hostname_ascii` variable (with a length of 256 bytes) is handled in `uv_getaddrinfo` and subsequently in `uv__idna_toascii`. When the hostname exceeds 256 characters, it gets truncated without a terminating null byte. As a result attackers may be able to access internal APIs or for websites (similar to MySpace) that allows users to have `username.example.com` pages. Internal services that crawl or cache these user pages can be exposed to SSRF attacks if a malicious user chooses a long vulnerable username. This issue has been addressed in release version 1.48.0. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/libuv/libuv/commit/3530bcc30350d4a6ccf35d2f7b33e23292b9de70",
        "commit_title": "fix: reject zero-length idna inputs",
        "commit_text": "",
        "func_before": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}",
        "func": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  if (s == se)\n    return UV_EINVAL;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* 。 */\n        if (c != 0xFF0E)  /* ． */\n          if (c != 0xFF61)  /* ｡ */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n   unsigned c;\n   char* ds;\n   int rc;\n+\n+  if (s == se)\n+    return UV_EINVAL;\n \n   ds = d;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (s == se)",
                "    return UV_EINVAL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-35850",
        "func_name": "cockpit-project/cockpit/cockpit_session_launch",
        "description": "An SSRF issue was discovered in cockpit-project.org Cockpit 234. NOTE: this is unrelated to the Agentejo Cockpit product. NOTE: the vendor states \"I don't think [it] is a big real-life issue.",
        "git_url": "https://github.com/cockpit-project/cockpit/commit/211c14b39b787bf817f6cd94e7e596e150fd32a7",
        "commit_title": "ws: Disallow direct URL logins with LoginTo=false",
        "commit_text": " The current documentation of LoginTo= isn't very specific about what exactly happens with a \"false\" value; but it is plausible for an admin to assume that \"false\" would disallow logging into a remote host completely -- not merely hide the \"Connect to:\" field and then allowing a direct URL login anyway.  It is sometimes important to disallow direct SSH logins from the login page on publicly exposed bastion hosts, as this functionality allows unauthenticated remote users to:   - scan the internal network for existing hosts, which might otherwise    not be accessible directly from the internet    (Fixes #18540, https://bugzilla.redhat.com/show_bug.cgi?id=2167006)   - scan the cockpit-ws host or internal network hosts for open ports    (Fixes #15077, https://bugzilla.redhat.com/show_bug.cgi?id=2018741)  So change ws to reject direct URL logins with `LoginTo=false`. This happens most naturally in cockpit_session_launch(), as we still want to allow remote URLs from the shell's host switcher in already authenticated sessions. This will not produce a very friendly error message, but it doesn't have to be -- at that point specifying direct URLs can be considered hacking anyway.  Clarify the documentation accordingly.",
        "func_before": "static CockpitSession *\ncockpit_session_launch (CockpitAuth *self,\n                        CockpitWebRequest *request,\n                        const gchar *type,\n                        const gchar *authorization,\n                        const gchar *application,\n                        GError **error)\n{\n  g_return_val_if_fail (type != NULL, NULL);\n\n  const gchar *host = application_parse_host (application);\n  const gchar *action = cockpit_conf_string (type, \"action\");\n  if (g_strcmp0 (action, ACTION_NONE) == 0)\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  /* These are the credentials we'll carry around for this session */\n  g_autoptr(CockpitCreds) creds = build_session_credentials (self, request, application, host, type, authorization);\n\n  const gchar *section;\n  if (host)\n    section = COCKPIT_CONF_SSH_SECTION;\n  else if (self->login_loopback && g_str_equal (type, \"basic\"))\n    section = COCKPIT_CONF_SSH_SECTION;\n  else if (g_strcmp0 (action, ACTION_SSH) == 0)\n    section = COCKPIT_CONF_SSH_SECTION;\n  else\n    section = type;\n\n  const gchar *command = cockpit_conf_string (section, \"Command\");\n  const gchar *unix_path = cockpit_conf_string (section, \"UnixPath\");\n\n  gboolean capture_stderr = FALSE;\n  if (g_str_equal (section, COCKPIT_CONF_SSH_SECTION))\n    {\n      if (!host)\n        host = cockpit_conf_string (COCKPIT_CONF_SSH_SECTION, \"host\") ?: \"127.0.0.1\";\n\n      /* We capture stderr only for Cockpit Client; we don't want to\n       * send log messages to potential remote attackers.\n       */\n      capture_stderr = cockpit_conf_bool (\"WebService\", \"X-For-CockpitClient\", FALSE);\n\n      if (command == NULL && unix_path == NULL)\n        command = cockpit_ws_ssh_program;\n    }\n  else if (g_str_equal (type, \"basic\") ||\n           g_str_equal (type, \"negotiate\") ||\n           g_str_equal (type, \"tls-cert\"))\n    {\n      if (command == NULL && unix_path == NULL)\n        command = cockpit_ws_session_program;\n    }\n\n  g_autoptr(CockpitPipe) pipe = NULL;\n  if (command != NULL)\n    {\n      g_auto(GStrv) env = g_get_environ ();\n      if (cockpit_creds_get_rhost (creds))\n        {\n          env = g_environ_setenv (env, \"COCKPIT_REMOTE_PEER\",\n                                  cockpit_creds_get_rhost (creds),\n                                  TRUE);\n        }\n      if (g_strcmp0 (cockpit_web_request_lookup_header (request, \"X-SSH-Connect-Unknown-Hosts\"), \"yes\") == 0)\n        {\n          env = g_environ_setenv (env, \"COCKPIT_SSH_CONNECT_TO_UNKNOWN_HOSTS\",\n                                  \"1\",\n                                  TRUE);\n        }\n\n      const gchar *argv[] = { command, host ?: \"localhost\", NULL };\n      pipe = session_start_process (argv, (const gchar **)env, capture_stderr);\n    }\n  else if (unix_path != NULL)\n    {\n      g_autoptr(GSocketAddress) address = g_unix_socket_address_new (unix_path);\n      pipe = cockpit_pipe_connect (unix_path, address);\n    }\n  else\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  if (!pipe)\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_FAILED,\n                   \"Authentication failed to start\");\n      return NULL;\n    }\n\n  g_autoptr(CockpitTransport) transport = cockpit_pipe_transport_new (pipe);\n  CockpitSession *session = cockpit_session_create (self, cockpit_pipe_get_name (pipe), creds, transport);\n\n  /* How long to wait for the auth process to send some data */\n  session->authorize_timeout = timeout_option (\"timeout\", section, cockpit_ws_auth_process_timeout);\n\n  /* How long to wait for a response from the client to a auth prompt */\n  session->client_timeout = timeout_option (\"response-timeout\", section, cockpit_ws_auth_response_timeout);\n\n  return session;\n}",
        "func": "static CockpitSession *\ncockpit_session_launch (CockpitAuth *self,\n                        CockpitWebRequest *request,\n                        const gchar *type,\n                        const gchar *authorization,\n                        const gchar *application,\n                        GError **error)\n{\n  g_return_val_if_fail (type != NULL, NULL);\n\n  const gchar *host = application_parse_host (application);\n  const gchar *action = cockpit_conf_string (type, \"action\");\n  if (g_strcmp0 (action, ACTION_NONE) == 0)\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  /* this might be unset, which means \"allow if cockpit-ssh is installed\"; if it isn't, this will fail later on */\n  if (host && !cockpit_conf_bool (\"WebService\", \"LoginTo\", TRUE)) {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Direct remote login is disabled\");\n      return NULL;\n    }\n\n  /* These are the credentials we'll carry around for this session */\n  g_autoptr(CockpitCreds) creds = build_session_credentials (self, request, application, host, type, authorization);\n\n  const gchar *section;\n  if (host)\n    section = COCKPIT_CONF_SSH_SECTION;\n  else if (self->login_loopback && g_str_equal (type, \"basic\"))\n    section = COCKPIT_CONF_SSH_SECTION;\n  else if (g_strcmp0 (action, ACTION_SSH) == 0)\n    section = COCKPIT_CONF_SSH_SECTION;\n  else\n    section = type;\n\n  const gchar *command = cockpit_conf_string (section, \"Command\");\n  const gchar *unix_path = cockpit_conf_string (section, \"UnixPath\");\n\n  gboolean capture_stderr = FALSE;\n  if (g_str_equal (section, COCKPIT_CONF_SSH_SECTION))\n    {\n      if (!host)\n        host = cockpit_conf_string (COCKPIT_CONF_SSH_SECTION, \"host\") ?: \"127.0.0.1\";\n\n      /* We capture stderr only for Cockpit Client; we don't want to\n       * send log messages to potential remote attackers.\n       */\n      capture_stderr = cockpit_conf_bool (\"WebService\", \"X-For-CockpitClient\", FALSE);\n\n      if (command == NULL && unix_path == NULL)\n        command = cockpit_ws_ssh_program;\n    }\n  else if (g_str_equal (type, \"basic\") ||\n           g_str_equal (type, \"negotiate\") ||\n           g_str_equal (type, \"tls-cert\"))\n    {\n      if (command == NULL && unix_path == NULL)\n        command = cockpit_ws_session_program;\n    }\n\n  g_autoptr(CockpitPipe) pipe = NULL;\n  if (command != NULL)\n    {\n      g_auto(GStrv) env = g_get_environ ();\n      if (cockpit_creds_get_rhost (creds))\n        {\n          env = g_environ_setenv (env, \"COCKPIT_REMOTE_PEER\",\n                                  cockpit_creds_get_rhost (creds),\n                                  TRUE);\n        }\n      if (g_strcmp0 (cockpit_web_request_lookup_header (request, \"X-SSH-Connect-Unknown-Hosts\"), \"yes\") == 0)\n        {\n          env = g_environ_setenv (env, \"COCKPIT_SSH_CONNECT_TO_UNKNOWN_HOSTS\",\n                                  \"1\",\n                                  TRUE);\n        }\n\n      const gchar *argv[] = { command, host ?: \"localhost\", NULL };\n      pipe = session_start_process (argv, (const gchar **)env, capture_stderr);\n    }\n  else if (unix_path != NULL)\n    {\n      g_autoptr(GSocketAddress) address = g_unix_socket_address_new (unix_path);\n      pipe = cockpit_pipe_connect (unix_path, address);\n    }\n  else\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                   \"Authentication disabled\");\n      return NULL;\n    }\n\n  if (!pipe)\n    {\n      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_FAILED,\n                   \"Authentication failed to start\");\n      return NULL;\n    }\n\n  g_autoptr(CockpitTransport) transport = cockpit_pipe_transport_new (pipe);\n  CockpitSession *session = cockpit_session_create (self, cockpit_pipe_get_name (pipe), creds, transport);\n\n  /* How long to wait for the auth process to send some data */\n  session->authorize_timeout = timeout_option (\"timeout\", section, cockpit_ws_auth_process_timeout);\n\n  /* How long to wait for a response from the client to a auth prompt */\n  session->client_timeout = timeout_option (\"response-timeout\", section, cockpit_ws_auth_response_timeout);\n\n  return session;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,13 @@\n     {\n       g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n                    \"Authentication disabled\");\n+      return NULL;\n+    }\n+\n+  /* this might be unset, which means \"allow if cockpit-ssh is installed\"; if it isn't, this will fail later on */\n+  if (host && !cockpit_conf_bool (\"WebService\", \"LoginTo\", TRUE)) {\n+      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,\n+                   \"Direct remote login is disabled\");\n       return NULL;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      return NULL;",
                "    }",
                "",
                "  /* this might be unset, which means \"allow if cockpit-ssh is installed\"; if it isn't, this will fail later on */",
                "  if (host && !cockpit_conf_bool (\"WebService\", \"LoginTo\", TRUE)) {",
                "      g_set_error (error, COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED,",
                "                   \"Direct remote login is disabled\");"
            ]
        }
    }
]