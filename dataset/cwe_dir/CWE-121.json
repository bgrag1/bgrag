[
    {
        "cve_id": "CVE-2022-2078",
        "func_name": "torvalds/linux/nft_set_desc_concat_parse",
        "description": "A vulnerability was found in the Linux kernel's nft_set_desc_concat_parse() function .This flaw allows an attacker to trigger a buffer overflow via nft_set_desc_concat_parse() , causing a denial of service and possibly to run code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/nf_tables_api.c?h=fecf31ee395b0295f2d7260aa29946b7605f7c85",
        "commit_title": "Add several sanity checks for nft_set_desc_concat_parse():",
        "commit_text": " - validate desc->field_count not larger than desc->field_len array. - field length cannot be larger than desc->field_len (ie. U8_MAX) - total length of the concatenation cannot be larger than register array.  Joint work with Florian Westphal.  ",
        "func_before": "static int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\n\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\n\tdesc->field_len[desc->field_count++] = len;\n\n\treturn 0;\n}",
        "func": "static int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\n\tif (desc->field_count >= ARRAY_SIZE(desc->field_len))\n\t\treturn -E2BIG;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\tif (!len || len > U8_MAX)\n\t\treturn -EINVAL;\n\n\tdesc->field_len[desc->field_count++] = len;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n \tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n \tu32 len;\n \tint err;\n+\n+\tif (desc->field_count >= ARRAY_SIZE(desc->field_len))\n+\t\treturn -E2BIG;\n \n \terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n \t\t\t\t\t  nft_concat_policy, NULL);\n@@ -14,9 +17,8 @@\n \t\treturn -EINVAL;\n \n \tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n-\n-\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)\n-\t\treturn -E2BIG;\n+\tif (!len || len > U8_MAX)\n+\t\treturn -EINVAL;\n \n \tdesc->field_len[desc->field_count++] = len;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)",
                "\t\treturn -E2BIG;"
            ],
            "added_lines": [
                "",
                "\tif (desc->field_count >= ARRAY_SIZE(desc->field_len))",
                "\t\treturn -E2BIG;",
                "\tif (!len || len > U8_MAX)",
                "\t\treturn -EINVAL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2078",
        "func_name": "torvalds/linux/nft_set_desc_concat",
        "description": "A vulnerability was found in the Linux kernel's nft_set_desc_concat_parse() function .This flaw allows an attacker to trigger a buffer overflow via nft_set_desc_concat_parse() , causing a denial of service and possibly to run code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/nf_tables_api.c?h=fecf31ee395b0295f2d7260aa29946b7605f7c85",
        "commit_title": "Add several sanity checks for nft_set_desc_concat_parse():",
        "commit_text": " - validate desc->field_count not larger than desc->field_len array. - field length cannot be larger than desc->field_len (ie. U8_MAX) - total length of the concatenation cannot be larger than register array.  Joint work with Florian Westphal.  ",
        "func_before": "static int nft_set_desc_concat(struct nft_set_desc *desc,\n\t\t\t       const struct nlattr *nla)\n{\n\tstruct nlattr *attr;\n\tint rem, err;\n\n\tnla_for_each_nested(attr, nla, rem) {\n\t\tif (nla_type(attr) != NFTA_LIST_ELEM)\n\t\t\treturn -EINVAL;\n\n\t\terr = nft_set_desc_concat_parse(attr, desc);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}",
        "func": "static int nft_set_desc_concat(struct nft_set_desc *desc,\n\t\t\t       const struct nlattr *nla)\n{\n\tstruct nlattr *attr;\n\tu32 num_regs = 0;\n\tint rem, err, i;\n\n\tnla_for_each_nested(attr, nla, rem) {\n\t\tif (nla_type(attr) != NFTA_LIST_ELEM)\n\t\t\treturn -EINVAL;\n\n\t\terr = nft_set_desc_concat_parse(attr, desc);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < desc->field_count; i++)\n\t\tnum_regs += DIV_ROUND_UP(desc->field_len[i], sizeof(u32));\n\n\tif (num_regs > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,8 @@\n \t\t\t       const struct nlattr *nla)\n {\n \tstruct nlattr *attr;\n-\tint rem, err;\n+\tu32 num_regs = 0;\n+\tint rem, err, i;\n \n \tnla_for_each_nested(attr, nla, rem) {\n \t\tif (nla_type(attr) != NFTA_LIST_ELEM)\n@@ -13,5 +14,11 @@\n \t\t\treturn err;\n \t}\n \n+\tfor (i = 0; i < desc->field_count; i++)\n+\t\tnum_regs += DIV_ROUND_UP(desc->field_len[i], sizeof(u32));\n+\n+\tif (num_regs > NFT_REG32_COUNT)\n+\t\treturn -E2BIG;\n+\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tint rem, err;"
            ],
            "added_lines": [
                "\tu32 num_regs = 0;",
                "\tint rem, err, i;",
                "\tfor (i = 0; i < desc->field_count; i++)",
                "\t\tnum_regs += DIV_ROUND_UP(desc->field_len[i], sizeof(u32));",
                "",
                "\tif (num_regs > NFT_REG32_COUNT)",
                "\t\treturn -E2BIG;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2304",
        "func_name": "vim/spell_dump_compl",
        "description": "Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.",
        "git_url": "https://github.com/vim/vim/commit/54e5fed6d27b747ff152cdb6edfb72ff60e70939",
        "commit_title": "patch 9.0.0035: spell dump may go beyond end of an array",
        "commit_text": " Problem:    Spell dump may go beyond end of an array. Solution:   Limit the word length.",
        "func_before": "void\nspell_dump_compl(\n    char_u\t*pat,\t    // leading part of the word\n    int\t\tic,\t    // ignore case\n    int\t\t*dir,\t    // direction for adding matches\n    int\t\tdumpflags_arg)\t// DUMPFLAG_*\n{\n    langp_T\t*lp;\n    slang_T\t*slang;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tword[MAXWLEN];\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = 0;\n    int\t\tround;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tflags;\n    char_u\t*region_names = NULL;\t    // region names being used\n    int\t\tdo_region = TRUE;\t    // dump region names and numbers\n    char_u\t*p;\n    int\t\tlpi;\n    int\t\tdumpflags = dumpflags_arg;\n    int\t\tpatlen;\n\n    // When ignoring case or when the pattern starts with capital pass this on\n    // to dump_word().\n    if (pat != NULL)\n    {\n\tif (ic)\n\t    dumpflags |= DUMPFLAG_ICASE;\n\telse\n\t{\n\t    n = captype(pat, NULL);\n\t    if (n == WF_ONECAP)\n\t\tdumpflags |= DUMPFLAG_ONECAP;\n\t    else if (n == WF_ALLCAP && (int)STRLEN(pat) > mb_ptr2len(pat))\n\t\tdumpflags |= DUMPFLAG_ALLCAP;\n\t}\n    }\n\n    // Find out if we can support regions: All languages must support the same\n    // regions or none at all.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tp = lp->lp_slang->sl_regions;\n\tif (p[0] != 0)\n\t{\n\t    if (region_names == NULL)\t    // first language with regions\n\t\tregion_names = p;\n\t    else if (STRCMP(region_names, p) != 0)\n\t    {\n\t\tdo_region = FALSE;\t    // region names are different\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (do_region && region_names != NULL)\n    {\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n    }\n    else\n\tdo_region = FALSE;\n\n    /*\n     * Loop over all files loaded for the entries in 'spelllang'.\n     */\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_fbyts == NULL)\t    // reloading failed\n\t    continue;\n\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n\n\t// When matching with a pattern and there are no prefixes only use\n\t// parts of the tree that match \"pat\".\n\tif (pat != NULL && slang->sl_pbyts == NULL)\n\t    patlen = (int)STRLEN(pat);\n\telse\n\t    patlen = -1;\n\n\t// round 1: case-folded tree\n\t// round 2: keep-case tree\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t    {\n\t\tdumpflags &= ~DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_fbyts;\n\t\tidxs = slang->sl_fidxs;\n\t    }\n\t    else\n\t    {\n\t\tdumpflags |= DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_kbyts;\n\t\tidxs = slang->sl_kidxs;\n\t    }\n\t    if (byts == NULL)\n\t\tcontinue;\t\t// array is empty\n\n\t    depth = 0;\n\t    arridx[0] = 0;\n\t    curi[0] = 1;\n\t    while (depth >= 0 && !got_int\n\t\t\t\t  && (pat == NULL || !ins_compl_interrupted()))\n\t    {\n\t\tif (curi[depth] > byts[arridx[depth]])\n\t\t{\n\t\t    // Done all bytes at this node, go up one level.\n\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0)\n\t\t    {\n\t\t\t// End of word, deal with the word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))\n\t\t\t{\n\t\t\t    word[depth] = NUL;\n\t\t\t    if (!do_region)\n\t\t\t\tflags &= ~WF_REGION;\n\n\t\t\t    // Dump the basic word if there is no prefix or\n\t\t\t    // when it's the first one.\n\t\t\t    c = (unsigned)flags >> 24;\n\t\t\t    if (c == 0 || curi[depth] == 2)\n\t\t\t    {\n\t\t\t\tdump_word(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t\tif (pat == NULL)\n\t\t\t\t    ++lnum;\n\t\t\t    }\n\n\t\t\t    // Apply the prefix, if there is one.\n\t\t\t    if (c != 0)\n\t\t\t\tlnum = dump_prefixes(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Normal char, go one level deeper.\n\t\t\tword[depth++] = c;\n\t\t\tarridx[depth] = idxs[n];\n\t\t\tcuri[depth] = 1;\n\n\t\t\t// Check if this character matches with the pattern.\n\t\t\t// If not skip the whole tree below it.\n\t\t\t// Always ignore case here, dump_word() will check\n\t\t\t// proper case later.  This isn't exactly right when\n\t\t\t// length changes for multi-byte characters with\n\t\t\t// ignore case...\n\t\t\tif (depth <= patlen\n\t\t\t\t\t&& MB_STRNICMP(word, pat, depth) != 0)\n\t\t\t    --depth;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}",
        "func": "void\nspell_dump_compl(\n    char_u\t*pat,\t    // leading part of the word\n    int\t\tic,\t    // ignore case\n    int\t\t*dir,\t    // direction for adding matches\n    int\t\tdumpflags_arg)\t// DUMPFLAG_*\n{\n    langp_T\t*lp;\n    slang_T\t*slang;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tword[MAXWLEN];\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = 0;\n    int\t\tround;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tflags;\n    char_u\t*region_names = NULL;\t    // region names being used\n    int\t\tdo_region = TRUE;\t    // dump region names and numbers\n    char_u\t*p;\n    int\t\tlpi;\n    int\t\tdumpflags = dumpflags_arg;\n    int\t\tpatlen;\n\n    // When ignoring case or when the pattern starts with capital pass this on\n    // to dump_word().\n    if (pat != NULL)\n    {\n\tif (ic)\n\t    dumpflags |= DUMPFLAG_ICASE;\n\telse\n\t{\n\t    n = captype(pat, NULL);\n\t    if (n == WF_ONECAP)\n\t\tdumpflags |= DUMPFLAG_ONECAP;\n\t    else if (n == WF_ALLCAP && (int)STRLEN(pat) > mb_ptr2len(pat))\n\t\tdumpflags |= DUMPFLAG_ALLCAP;\n\t}\n    }\n\n    // Find out if we can support regions: All languages must support the same\n    // regions or none at all.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tp = lp->lp_slang->sl_regions;\n\tif (p[0] != 0)\n\t{\n\t    if (region_names == NULL)\t    // first language with regions\n\t\tregion_names = p;\n\t    else if (STRCMP(region_names, p) != 0)\n\t    {\n\t\tdo_region = FALSE;\t    // region names are different\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (do_region && region_names != NULL)\n    {\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n    }\n    else\n\tdo_region = FALSE;\n\n    /*\n     * Loop over all files loaded for the entries in 'spelllang'.\n     */\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_fbyts == NULL)\t    // reloading failed\n\t    continue;\n\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n\n\t// When matching with a pattern and there are no prefixes only use\n\t// parts of the tree that match \"pat\".\n\tif (pat != NULL && slang->sl_pbyts == NULL)\n\t    patlen = (int)STRLEN(pat);\n\telse\n\t    patlen = -1;\n\n\t// round 1: case-folded tree\n\t// round 2: keep-case tree\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t    {\n\t\tdumpflags &= ~DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_fbyts;\n\t\tidxs = slang->sl_fidxs;\n\t    }\n\t    else\n\t    {\n\t\tdumpflags |= DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_kbyts;\n\t\tidxs = slang->sl_kidxs;\n\t    }\n\t    if (byts == NULL)\n\t\tcontinue;\t\t// array is empty\n\n\t    depth = 0;\n\t    arridx[0] = 0;\n\t    curi[0] = 1;\n\t    while (depth >= 0 && !got_int\n\t\t\t\t  && (pat == NULL || !ins_compl_interrupted()))\n\t    {\n\t\tif (curi[depth] > byts[arridx[depth]])\n\t\t{\n\t\t    // Done all bytes at this node, go up one level.\n\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0 || depth >= MAXWLEN - 1)\n\t\t    {\n\t\t\t// End of word or reached maximum length, deal with the\n\t\t\t// word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))\n\t\t\t{\n\t\t\t    word[depth] = NUL;\n\t\t\t    if (!do_region)\n\t\t\t\tflags &= ~WF_REGION;\n\n\t\t\t    // Dump the basic word if there is no prefix or\n\t\t\t    // when it's the first one.\n\t\t\t    c = (unsigned)flags >> 24;\n\t\t\t    if (c == 0 || curi[depth] == 2)\n\t\t\t    {\n\t\t\t\tdump_word(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t\tif (pat == NULL)\n\t\t\t\t    ++lnum;\n\t\t\t    }\n\n\t\t\t    // Apply the prefix, if there is one.\n\t\t\t    if (c != 0)\n\t\t\t\tlnum = dump_prefixes(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Normal char, go one level deeper.\n\t\t\tword[depth++] = c;\n\t\t\tarridx[depth] = idxs[n];\n\t\t\tcuri[depth] = 1;\n\n\t\t\t// Check if this character matches with the pattern.\n\t\t\t// If not skip the whole tree below it.\n\t\t\t// Always ignore case here, dump_word() will check\n\t\t\t// proper case later.  This isn't exactly right when\n\t\t\t// length changes for multi-byte characters with\n\t\t\t// ignore case...\n\t\t\tif (depth <= patlen\n\t\t\t\t\t&& MB_STRNICMP(word, pat, depth) != 0)\n\t\t\t    --depth;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -131,9 +131,10 @@\n \t\t    n = arridx[depth] + curi[depth];\n \t\t    ++curi[depth];\n \t\t    c = byts[n];\n-\t\t    if (c == 0)\n+\t\t    if (c == 0 || depth >= MAXWLEN - 1)\n \t\t    {\n-\t\t\t// End of word, deal with the word.\n+\t\t\t// End of word or reached maximum length, deal with the\n+\t\t\t// word.\n \t\t\t// Don't use keep-case words in the fold-case tree,\n \t\t\t// they will appear in the keep-case tree.\n \t\t\t// Only use the word when the region matches.",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    if (c == 0)",
                "\t\t\t// End of word, deal with the word."
            ],
            "added_lines": [
                "\t\t    if (c == 0 || depth >= MAXWLEN - 1)",
                "\t\t\t// End of word or reached maximum length, deal with the",
                "\t\t\t// word."
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1355",
        "func_name": "libtiff/TIFFCleanup",
        "description": "A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/97574866cbab026acb1bbd735201f790091b9400",
        "commit_title": "extra flag for anonymous (unknown) tags (fixes #8)",
        "commit_text": "",
        "func_before": "void\nTIFFCleanup(TIFF* tif)\n{\n\t/*\n         * Flush buffered data and directory (if dirty).\n         */\n\tif (tif->tif_mode != O_RDONLY)\n\t\tTIFFFlush(tif);\n\t(*tif->tif_cleanup)(tif);\n\tTIFFFreeDirectory(tif);\n\n\tif (tif->tif_dirlist)\n\t\t_TIFFfree(tif->tif_dirlist);\n\n\t/*\n         * Clean up client info links.\n         */\n\twhile( tif->tif_clientinfo )\n\t{\n\t\tTIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n\t\ttif->tif_clientinfo = psLink->next;\n\t\t_TIFFfree( psLink->name );\n\t\t_TIFFfree( psLink );\n\t}\n\n\tif (tif->tif_rawdata && (tif->tif_flags&TIFF_MYBUFFER))\n\t\t_TIFFfree(tif->tif_rawdata);\n\tif (isMapped(tif))\n\t\tTIFFUnmapFileContents(tif, tif->tif_base, (toff_t)tif->tif_size);\n\n\t/*\n         * Clean up custom fields.\n         */\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32_t i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_name != NULL) {\n\t\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t}\n\n        if (tif->tif_nfieldscompat > 0) {\n                uint32_t i;\n\n                for (i = 0; i < tif->tif_nfieldscompat; i++) {\n                        if (tif->tif_fieldscompat[i].allocated_size)\n                                _TIFFfree(tif->tif_fieldscompat[i].fields);\n                }\n                _TIFFfree(tif->tif_fieldscompat);\n        }\n\n\t_TIFFfree(tif);\n}",
        "func": "void\nTIFFCleanup(TIFF* tif)\n{\n\t/*\n         * Flush buffered data and directory (if dirty).\n         */\n\tif (tif->tif_mode != O_RDONLY)\n\t\tTIFFFlush(tif);\n\t(*tif->tif_cleanup)(tif);\n\tTIFFFreeDirectory(tif);\n\n\tif (tif->tif_dirlist)\n\t\t_TIFFfree(tif->tif_dirlist);\n\n\t/*\n         * Clean up client info links.\n         */\n\twhile( tif->tif_clientinfo )\n\t{\n\t\tTIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n\t\ttif->tif_clientinfo = psLink->next;\n\t\t_TIFFfree( psLink->name );\n\t\t_TIFFfree( psLink );\n\t}\n\n\tif (tif->tif_rawdata && (tif->tif_flags&TIFF_MYBUFFER))\n\t\t_TIFFfree(tif->tif_rawdata);\n\tif (isMapped(tif))\n\t\tTIFFUnmapFileContents(tif, tif->tif_base, (toff_t)tif->tif_size);\n\n\t/*\n         * Clean up custom fields.\n         */\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32_t i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_name != NULL) {\n\t\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\t\t/* catuion: tif_fields[i] must not be the beginning of a fields-array.\n\t\t\t\t\t *          Otherwise the following tags are also freed with the first free().\n\t\t\t\t\t */\n\t\t\t\t\tTIFFFieldIsAnonymous(fld)) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t}\n\n        if (tif->tif_nfieldscompat > 0) {\n                uint32_t i;\n\n                for (i = 0; i < tif->tif_nfieldscompat; i++) {\n                        if (tif->tif_fieldscompat[i].allocated_size)\n                                _TIFFfree(tif->tif_fieldscompat[i].fields);\n                }\n                _TIFFfree(tif->tif_fieldscompat);\n        }\n\n\t_TIFFfree(tif);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,10 @@\n \t\t\tTIFFField *fld = tif->tif_fields[i];\n \t\t\tif (fld->field_name != NULL) {\n \t\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n-\t\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {\n+\t\t\t\t\t/* catuion: tif_fields[i] must not be the beginning of a fields-array.\n+\t\t\t\t\t *          Otherwise the following tags are also freed with the first free().\n+\t\t\t\t\t */\n+\t\t\t\t\tTIFFFieldIsAnonymous(fld)) {\n \t\t\t\t\t_TIFFfree(fld->field_name);\n \t\t\t\t\t_TIFFfree(fld);\n \t\t\t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {"
            ],
            "added_lines": [
                "\t\t\t\t\t/* catuion: tif_fields[i] must not be the beginning of a fields-array.",
                "\t\t\t\t\t *          Otherwise the following tags are also freed with the first free().",
                "\t\t\t\t\t */",
                "\t\t\t\t\tTIFFFieldIsAnonymous(fld)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1355",
        "func_name": "libtiff/TIFFReadCustomDirectory",
        "description": "A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/97574866cbab026acb1bbd735201f790091b9400",
        "commit_title": "extra flag for anonymous (unknown) tags (fixes #8)",
        "commit_text": "",
        "func_before": "int\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16_t dircount;\n\tTIFFDirEntry* dp;\n\tuint16_t di;\n\tconst TIFFField* fip;\n\tuint32_t fii;\n        (*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset %\" PRIu64,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %\"PRIu16\" (0x%\"PRIx16\") encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %\"PRIu16\" (0x%\"PRIx16\") failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (!dp->tdir_ignore)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32_t)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %\"PRIu16\" for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32_t)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32_t)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!dp->tdir_ignore) {\n\t\t\t\tswitch (dp->tdir_tag) \n\t\t\t\t{\n\t\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n                        if(fip->field_name != NULL && strncmp(fip->field_name, \"Tag \", 4) != 0 ) {\n                            /* should only be called on a Exif directory */\n                            /* when exifFields[] is active */\n                            (void)TIFFFetchSubjectDistance(tif, dp);\n                        }\n                        else {\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t(void)TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} /*-- if (!dp->tdir_ignore) */\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}",
        "func": "int\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16_t dircount;\n\tTIFFDirEntry* dp;\n\tuint16_t di;\n\tconst TIFFField* fip;\n\tuint32_t fii;\n        (*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset %\" PRIu64,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %\"PRIu16\" (0x%\"PRIx16\") encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %\"PRIu16\" (0x%\"PRIx16\") failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (!dp->tdir_ignore)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32_t)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %\"PRIu16\" for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32_t)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32_t)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!dp->tdir_ignore) {\n\t\t\t\tswitch (dp->tdir_tag) \n\t\t\t\t{\n\t\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n                        if(!TIFFFieldIsAnonymous(fip)) {\n                            /* should only be called on a Exif directory */\n                            /* when exifFields[] is active */\n                            (void)TIFFFetchSubjectDistance(tif, dp);\n                        }\n                        else {\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t(void)TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} /*-- if (!dp->tdir_ignore) */\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -88,7 +88,7 @@\n \t\t\t\tswitch (dp->tdir_tag) \n \t\t\t\t{\n \t\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n-                        if(fip->field_name != NULL && strncmp(fip->field_name, \"Tag \", 4) != 0 ) {\n+                        if(!TIFFFieldIsAnonymous(fip)) {\n                             /* should only be called on a Exif directory */\n                             /* when exifFields[] is active */\n                             (void)TIFFFetchSubjectDistance(tif, dp);",
        "diff_line_info": {
            "deleted_lines": [
                "                        if(fip->field_name != NULL && strncmp(fip->field_name, \"Tag \", 4) != 0 ) {"
            ],
            "added_lines": [
                "                        if(!TIFFFieldIsAnonymous(fip)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1355",
        "func_name": "libtiff/_TIFFPrettyPrintField",
        "description": "A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/97574866cbab026acb1bbd735201f790091b9400",
        "commit_title": "extra flag for anonymous (unknown) tags (fixes #8)",
        "commit_text": "",
        "func_before": "static int\n_TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32_t tag,\n                      uint32_t value_count, void *raw_data)\n{\n        (void) tif;\n\n\t/* do not try to pretty print auto-defined fields */\n\tif (fip->field_name != NULL && strncmp(fip->field_name,\"Tag \", 4) == 0) {\n\t\treturn 0;\n\t}\n        \n\tswitch (tag)\n\t{\n\t\tcase TIFFTAG_INKSET:\n\t\t\tif (value_count == 2 && fip->field_type == TIFF_SHORT) {\n\t\t\t\tfprintf(fd, \"  Ink Set: \");\n\t\t\t\tswitch (*((uint16_t*)raw_data)) {\n\t\t\t\tcase INKSET_CMYK:\n\t\t\t\t\tfprintf(fd, \"CMYK\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(fd, \"%\"PRIu16\" (0x%\"PRIx16\")\\n\",\n\t\t\t\t\t\t*((uint16_t*)raw_data),\n\t\t\t\t\t\t*((uint16_t*)raw_data));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\tcase TIFFTAG_DOTRANGE:\n\t\t\tif (value_count == 2 && fip->field_type == TIFF_SHORT) {\n\t\t\t\tfprintf(fd, \"  Dot Range: %\"PRIu16\"-%\"PRIu16\"\\n\",\n                        ((uint16_t*)raw_data)[0], ((uint16_t*)raw_data)[1]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\tcase TIFFTAG_WHITEPOINT:\n\t\t\tif (value_count == 2 && fip->field_type == TIFF_RATIONAL) {\n\t\t\t\tfprintf(fd, \"  White Point: %g-%g\\n\",\n\t\t\t\t\t((float *)raw_data)[0], ((float *)raw_data)[1]);\n\t\t\t\treturn 1;\n\t\t\t} \n\t\t\treturn 0;\n\n\t\tcase TIFFTAG_XMLPACKET:\n\t\t{\n\t\t\tuint32_t i;\n\n\t\t\tfprintf(fd, \"  XMLPacket (XMP Metadata):\\n\" );\n\t\t\tfor(i = 0; i < value_count; i++)\n\t\t\t\tfputc(((char *)raw_data)[i], fd);\n\t\t\tfprintf( fd, \"\\n\" );\n\t\t\treturn 1;\n\t\t}\n\t\tcase TIFFTAG_RICHTIFFIPTC:\n\t\t\t/*\n\t\t\t * XXX: for some weird reason RichTIFFIPTC tag\n\t\t\t * defined as array of LONG values.\n\t\t\t */\n\t\t\tfprintf(fd,\n\t\t\t    \"  RichTIFFIPTC Data: <present>, %\"PRIu32\" bytes\\n\",\n\t\t\t    value_count * 4u);\n\t\t\treturn 1;\n\n\t\tcase TIFFTAG_PHOTOSHOP:\n\t\t\tfprintf(fd, \"  Photoshop Data: <present>, %\"PRIu32\" bytes\\n\",\n\t\t\t    value_count);\n\t\t\treturn 1;\n\n\t\tcase TIFFTAG_ICCPROFILE:\n\t\t\tfprintf(fd, \"  ICC Profile: <present>, %\"PRIu32\" bytes\\n\",\n\t\t\t    value_count);\n\t\t\treturn 1;\n\n\t\tcase TIFFTAG_STONITS:\n\t\t\tif (value_count == 1 && fip->field_type == TIFF_DOUBLE) { \n\t\t\t\tfprintf(fd,\n\t\t\t\t\t\"  Sample to Nits conversion factor: %.4e\\n\",\n\t\t\t\t\t*((double*)raw_data));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
        "func": "static int\n_TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32_t tag,\n                      uint32_t value_count, void *raw_data)\n{\n        (void) tif;\n\n\t/* do not try to pretty print auto-defined fields */\n\tif ( TIFFFieldIsAnonymous(fip) ) {\n\t\treturn 0;\n\t}\n        \n\tswitch (tag)\n\t{\n\t\tcase TIFFTAG_INKSET:\n\t\t\tif (value_count == 2 && fip->field_type == TIFF_SHORT) {\n\t\t\t\tfprintf(fd, \"  Ink Set: \");\n\t\t\t\tswitch (*((uint16_t*)raw_data)) {\n\t\t\t\tcase INKSET_CMYK:\n\t\t\t\t\tfprintf(fd, \"CMYK\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(fd, \"%\"PRIu16\" (0x%\"PRIx16\")\\n\",\n\t\t\t\t\t\t*((uint16_t*)raw_data),\n\t\t\t\t\t\t*((uint16_t*)raw_data));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\tcase TIFFTAG_DOTRANGE:\n\t\t\tif (value_count == 2 && fip->field_type == TIFF_SHORT) {\n\t\t\t\tfprintf(fd, \"  Dot Range: %\"PRIu16\"-%\"PRIu16\"\\n\",\n                        ((uint16_t*)raw_data)[0], ((uint16_t*)raw_data)[1]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\tcase TIFFTAG_WHITEPOINT:\n\t\t\tif (value_count == 2 && fip->field_type == TIFF_RATIONAL) {\n\t\t\t\tfprintf(fd, \"  White Point: %g-%g\\n\",\n\t\t\t\t\t((float *)raw_data)[0], ((float *)raw_data)[1]);\n\t\t\t\treturn 1;\n\t\t\t} \n\t\t\treturn 0;\n\n\t\tcase TIFFTAG_XMLPACKET:\n\t\t{\n\t\t\tuint32_t i;\n\n\t\t\tfprintf(fd, \"  XMLPacket (XMP Metadata):\\n\" );\n\t\t\tfor(i = 0; i < value_count; i++)\n\t\t\t\tfputc(((char *)raw_data)[i], fd);\n\t\t\tfprintf( fd, \"\\n\" );\n\t\t\treturn 1;\n\t\t}\n\t\tcase TIFFTAG_RICHTIFFIPTC:\n\t\t\t/*\n\t\t\t * XXX: for some weird reason RichTIFFIPTC tag\n\t\t\t * defined as array of LONG values.\n\t\t\t */\n\t\t\tfprintf(fd,\n\t\t\t    \"  RichTIFFIPTC Data: <present>, %\"PRIu32\" bytes\\n\",\n\t\t\t    value_count * 4u);\n\t\t\treturn 1;\n\n\t\tcase TIFFTAG_PHOTOSHOP:\n\t\t\tfprintf(fd, \"  Photoshop Data: <present>, %\"PRIu32\" bytes\\n\",\n\t\t\t    value_count);\n\t\t\treturn 1;\n\n\t\tcase TIFFTAG_ICCPROFILE:\n\t\t\tfprintf(fd, \"  ICC Profile: <present>, %\"PRIu32\" bytes\\n\",\n\t\t\t    value_count);\n\t\t\treturn 1;\n\n\t\tcase TIFFTAG_STONITS:\n\t\t\tif (value_count == 1 && fip->field_type == TIFF_DOUBLE) { \n\t\t\t\tfprintf(fd,\n\t\t\t\t\t\"  Sample to Nits conversion factor: %.4e\\n\",\n\t\t\t\t\t*((double*)raw_data));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n         (void) tif;\n \n \t/* do not try to pretty print auto-defined fields */\n-\tif (fip->field_name != NULL && strncmp(fip->field_name,\"Tag \", 4) == 0) {\n+\tif ( TIFFFieldIsAnonymous(fip) ) {\n \t\treturn 0;\n \t}\n         ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (fip->field_name != NULL && strncmp(fip->field_name,\"Tag \", 4) == 0) {"
            ],
            "added_lines": [
                "\tif ( TIFFFieldIsAnonymous(fip) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1355",
        "func_name": "libtiff/_TIFFPrintField",
        "description": "A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/97574866cbab026acb1bbd735201f790091b9400",
        "commit_title": "extra flag for anonymous (unknown) tags (fixes #8)",
        "commit_text": "",
        "func_before": "static void\n_TIFFPrintField(FILE* fd, const TIFFField *fip,\n                uint32_t value_count, void *raw_data)\n{\n\tuint32_t j;\n\n    /* Print a user-friendly name for tags of relatively common use, but */\n    /* which aren't registered by libtiff itself. */\n    const char* field_name = fip->field_name;\n    if( fip->field_name != NULL && strncmp(fip->field_name, \"Tag \", 4) == 0 ) {\n        for( size_t i = 0; i < NTAGS; ++i ) {\n            if( fip->field_tag == tagnames[i].tag ) {\n                field_name = tagnames[i].name;\n                break;\n            }\n        }\n    }\n\tfprintf(fd, \"  %s: \", field_name);\n\n\tfor(j = 0; j < value_count; j++) {\n\t\tif(fip->field_type == TIFF_BYTE)\n\t\t\tfprintf(fd, \"%\"PRIu8, ((uint8_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_UNDEFINED)\n\t\t\tfprintf(fd, \"0x%\"PRIx8, ((uint8_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SBYTE)\n\t\t\tfprintf(fd, \"%\"PRId8, ((int8_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SHORT)\n\t\t\tfprintf(fd, \"%\"PRIu16, ((uint16_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SSHORT)\n\t\t\tfprintf(fd, \"%\"PRId16, ((int16_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_LONG)\n\t\t\tfprintf(fd, \"%\"PRIu32, ((uint32_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SLONG)\n\t\t\tfprintf(fd, \"%\"PRId32, ((int32_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_IFD)\n\t\t\tfprintf(fd, \"0x%\"PRIx32, ((uint32_t *) raw_data)[j]);\n\t\telse if (fip->field_type == TIFF_RATIONAL\n\t\t\t|| fip->field_type == TIFF_SRATIONAL) {\n\t\t\tint tv_size = _TIFFSetGetFieldSize(fip->set_field_type);\n\t\t\tif(tv_size==8)\n\t\t\t\tfprintf(fd, \"%lf\", ((double*)raw_data)[j]);\n\t\t\telse\n\t\t\t\tfprintf(fd, \"%f\", ((float *) raw_data)[j]);\n\t\t}\n\t\telse if(fip->field_type == TIFF_FLOAT)\n\t\t\tfprintf(fd, \"%f\", ((float*)raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_LONG8)\n\t\t\tfprintf(fd, \"%\"PRIu64, ((uint64_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SLONG8)\n\t\t\tfprintf(fd, \"%\"PRId64, ((int64_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_IFD8)\n\t\t\tfprintf(fd, \"0x%\"PRIx64, ((uint64_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_DOUBLE)\n\t\t\tfprintf(fd, \"%lf\", ((double *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_ASCII) {\n\t\t\tfprintf(fd, \"%s\", (char *) raw_data);\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfprintf(fd, \"<unsupported data type in TIFFPrint>\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif(j < value_count - 1)\n\t\t\tfprintf(fd, \",\");\n\t}\n\n\tfprintf(fd, \"\\n\");\n}",
        "func": "static void\n_TIFFPrintField(FILE* fd, const TIFFField *fip,\n                uint32_t value_count, void *raw_data)\n{\n\tuint32_t j;\n\n    /* Print a user-friendly name for tags of relatively common use, but */\n    /* which aren't registered by libtiff itself. */\n    const char* field_name = fip->field_name;\n    if( TIFFFieldIsAnonymous(fip) ) {\n        for( size_t i = 0; i < NTAGS; ++i ) {\n            if( fip->field_tag == tagnames[i].tag ) {\n                field_name = tagnames[i].name;\n                break;\n            }\n        }\n    }\n\tfprintf(fd, \"  %s: \", field_name);\n\n\tfor(j = 0; j < value_count; j++) {\n\t\tif(fip->field_type == TIFF_BYTE)\n\t\t\tfprintf(fd, \"%\"PRIu8, ((uint8_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_UNDEFINED)\n\t\t\tfprintf(fd, \"0x%\"PRIx8, ((uint8_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SBYTE)\n\t\t\tfprintf(fd, \"%\"PRId8, ((int8_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SHORT)\n\t\t\tfprintf(fd, \"%\"PRIu16, ((uint16_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SSHORT)\n\t\t\tfprintf(fd, \"%\"PRId16, ((int16_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_LONG)\n\t\t\tfprintf(fd, \"%\"PRIu32, ((uint32_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SLONG)\n\t\t\tfprintf(fd, \"%\"PRId32, ((int32_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_IFD)\n\t\t\tfprintf(fd, \"0x%\"PRIx32, ((uint32_t *) raw_data)[j]);\n\t\telse if (fip->field_type == TIFF_RATIONAL\n\t\t\t|| fip->field_type == TIFF_SRATIONAL) {\n\t\t\tint tv_size = _TIFFSetGetFieldSize(fip->set_field_type);\n\t\t\tif(tv_size==8)\n\t\t\t\tfprintf(fd, \"%lf\", ((double*)raw_data)[j]);\n\t\t\telse\n\t\t\t\tfprintf(fd, \"%f\", ((float *) raw_data)[j]);\n\t\t}\n\t\telse if(fip->field_type == TIFF_FLOAT)\n\t\t\tfprintf(fd, \"%f\", ((float*)raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_LONG8)\n\t\t\tfprintf(fd, \"%\"PRIu64, ((uint64_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SLONG8)\n\t\t\tfprintf(fd, \"%\"PRId64, ((int64_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_IFD8)\n\t\t\tfprintf(fd, \"0x%\"PRIx64, ((uint64_t *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_DOUBLE)\n\t\t\tfprintf(fd, \"%lf\", ((double *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_ASCII) {\n\t\t\tfprintf(fd, \"%s\", (char *) raw_data);\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfprintf(fd, \"<unsupported data type in TIFFPrint>\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif(j < value_count - 1)\n\t\t\tfprintf(fd, \",\");\n\t}\n\n\tfprintf(fd, \"\\n\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n     /* Print a user-friendly name for tags of relatively common use, but */\n     /* which aren't registered by libtiff itself. */\n     const char* field_name = fip->field_name;\n-    if( fip->field_name != NULL && strncmp(fip->field_name, \"Tag \", 4) == 0 ) {\n+    if( TIFFFieldIsAnonymous(fip) ) {\n         for( size_t i = 0; i < NTAGS; ++i ) {\n             if( fip->field_tag == tagnames[i].tag ) {\n                 field_name = tagnames[i].name;",
        "diff_line_info": {
            "deleted_lines": [
                "    if( fip->field_name != NULL && strncmp(fip->field_name, \"Tag \", 4) == 0 ) {"
            ],
            "added_lines": [
                "    if( TIFFFieldIsAnonymous(fip) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1355",
        "func_name": "libtiff/_TIFFCreateAnonField",
        "description": "A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/97574866cbab026acb1bbd735201f790091b9400",
        "commit_title": "extra flag for anonymous (unknown) tags (fixes #8)",
        "commit_text": "",
        "func_before": "TIFFField*\n_TIFFCreateAnonField(TIFF *tif, uint32_t tag, TIFFDataType field_type)\n{\n\tTIFFField *fld;\n\t(void) tif;\n\n\tfld = (TIFFField *) _TIFFmalloc(sizeof (TIFFField));\n\tif (fld == NULL)\n\t    return NULL;\n\t_TIFFmemset(fld, 0, sizeof(TIFFField));\n\n\tfld->field_tag = tag;\n\tfld->field_readcount = TIFF_VARIABLE2;\n\tfld->field_writecount = TIFF_VARIABLE2;\n\tfld->field_type = field_type;\n\tfld->reserved = 0;\n\tswitch (field_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tbreak;\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_IFD8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfld->set_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tfld->get_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tbreak;\n\t}\n\tfld->field_bit = FIELD_CUSTOM;\n\tfld->field_oktochange = TRUE;\n\tfld->field_passcount = TRUE;\n\tfld->field_name = (char *) _TIFFmalloc(32);\n\tif (fld->field_name == NULL) {\n\t    _TIFFfree(fld);\n\t    return NULL;\n\t}\n\tfld->field_subfields = NULL;\n\n\t/* \n\t * note that this name is a special sign to TIFFClose() and\n\t * _TIFFSetupFields() to free the field\n\t */\n\t(void) snprintf(fld->field_name, 32, \"Tag %d\", (int) tag);\n\n\treturn fld;    \n}",
        "func": "TIFFField*\n_TIFFCreateAnonField(TIFF *tif, uint32_t tag, TIFFDataType field_type)\n{\n\tTIFFField *fld;\n\t(void) tif;\n\n\tfld = (TIFFField *) _TIFFmalloc(sizeof (TIFFField));\n\tif (fld == NULL)\n\t    return NULL;\n\t_TIFFmemset(fld, 0, sizeof(TIFFField));\n\n\tfld->field_tag = tag;\n\tfld->field_readcount = TIFF_VARIABLE2;\n\tfld->field_writecount = TIFF_VARIABLE2;\n\tfld->field_type = field_type;\n\tfld->field_anonymous = 1;    /* indicate that this is an anonymous / unknown tag */\n\tswitch (field_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tbreak;\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_IFD8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfld->set_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tfld->get_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tbreak;\n\t}\n\tfld->field_bit = FIELD_CUSTOM;\n\tfld->field_oktochange = TRUE;\n\tfld->field_passcount = TRUE;\n\tfld->field_name = (char *) _TIFFmalloc(32);\n\tif (fld->field_name == NULL) {\n\t    _TIFFfree(fld);\n\t    return NULL;\n\t}\n\tfld->field_subfields = NULL;\n\n\t/* \n\t * note that this name is a special sign to TIFFClose() and\n\t * _TIFFSetupFields() to free the field\n\t * Update:\n\t *   This special sign is replaced by fld->field_anonymous  flag.\n\t */\n\t(void) snprintf(fld->field_name, 32, \"Tag %d\", (int) tag);\n\n\treturn fld;    \n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \tfld->field_readcount = TIFF_VARIABLE2;\n \tfld->field_writecount = TIFF_VARIABLE2;\n \tfld->field_type = field_type;\n-\tfld->reserved = 0;\n+\tfld->field_anonymous = 1;    /* indicate that this is an anonymous / unknown tag */\n \tswitch (field_type)\n \t{\n \t\tcase TIFF_BYTE:\n@@ -86,6 +86,8 @@\n \t/* \n \t * note that this name is a special sign to TIFFClose() and\n \t * _TIFFSetupFields() to free the field\n+\t * Update:\n+\t *   This special sign is replaced by fld->field_anonymous  flag.\n \t */\n \t(void) snprintf(fld->field_name, 32, \"Tag %d\", (int) tag);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tfld->reserved = 0;"
            ],
            "added_lines": [
                "\tfld->field_anonymous = 1;    /* indicate that this is an anonymous / unknown tag */",
                "\t * Update:",
                "\t *   This special sign is replaced by fld->field_anonymous  flag."
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1355",
        "func_name": "libtiff/_TIFFSetupFields",
        "description": "A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/97574866cbab026acb1bbd735201f790091b9400",
        "commit_title": "extra flag for anonymous (unknown) tags (fixes #8)",
        "commit_text": "",
        "func_before": "void\n_TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n{\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32_t i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_name != NULL) {\n\t\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t\ttif->tif_fields = NULL;\n\t\ttif->tif_nfields = 0;\n\t}\n\tif (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFSetupFields\",\n\t\t\t     \"Setting up field info failed\");\n\t}\n}",
        "func": "void\n_TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n{\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32_t i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_name != NULL) {\n\t\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\t\tTIFFFieldIsAnonymous(fld)) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t/* catuion: tif_fields[i] must not be the beginning of a fields-array. \n\t\t\t\t\t *          Otherwise the following tags are also freed with the first free().\n\t\t\t\t\t */\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t\ttif->tif_fields = NULL;\n\t\ttif->tif_nfields = 0;\n\t}\n\tif (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFSetupFields\",\n\t\t\t     \"Setting up field info failed\");\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,11 @@\n \t\t\tTIFFField *fld = tif->tif_fields[i];\n \t\t\tif (fld->field_name != NULL) {\n \t\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n-\t\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {\n+\t\t\t\t\tTIFFFieldIsAnonymous(fld)) {\n \t\t\t\t\t_TIFFfree(fld->field_name);\n+\t\t\t\t\t/* catuion: tif_fields[i] must not be the beginning of a fields-array. \n+\t\t\t\t\t *          Otherwise the following tags are also freed with the first free().\n+\t\t\t\t\t */\n \t\t\t\t\t_TIFFfree(fld);\n \t\t\t\t}\n \t\t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {"
            ],
            "added_lines": [
                "\t\t\t\t\tTIFFFieldIsAnonymous(fld)) {",
                "\t\t\t\t\t/* catuion: tif_fields[i] must not be the beginning of a fields-array. ",
                "\t\t\t\t\t *          Otherwise the following tags are also freed with the first free().",
                "\t\t\t\t\t */"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1355",
        "func_name": "libtiff/TIFFMergeFieldInfo",
        "description": "A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/97574866cbab026acb1bbd735201f790091b9400",
        "commit_title": "extra flag for anonymous (unknown) tags (fixes #8)",
        "commit_text": "",
        "func_before": "int\nTIFFMergeFieldInfo(TIFF* tif, const TIFFFieldInfo info[], uint32_t n)\n{\n\tstatic const char module[] = \"TIFFMergeFieldInfo\";\n\tstatic const char reason[] = \"for fields array\";\n\tTIFFField *tp;\n\tsize_t nfields;\n\tuint32_t i;\n\n\tif (tif->tif_nfieldscompat > 0) {\n\t\ttif->tif_fieldscompat = (TIFFFieldArray *)\n\t\t\t_TIFFCheckRealloc(tif, tif->tif_fieldscompat,\n\t\t\t\t\t  tif->tif_nfieldscompat + 1,\n\t\t\t\t\t  sizeof(TIFFFieldArray), reason);\n\t} else {\n\t\ttif->tif_fieldscompat = (TIFFFieldArray *)\n\t\t\t_TIFFCheckMalloc(tif, 1, sizeof(TIFFFieldArray),\n\t\t\t\t\t reason);\n\t}\n\tif (!tif->tif_fieldscompat) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn -1;\n\t}\n\tnfields = tif->tif_nfieldscompat++;\n\n\ttif->tif_fieldscompat[nfields].type = tfiatOther;\n\ttif->tif_fieldscompat[nfields].allocated_size = n;\n\ttif->tif_fieldscompat[nfields].count = n;\n\ttif->tif_fieldscompat[nfields].fields =\n\t\t(TIFFField *)_TIFFCheckMalloc(tif, n, sizeof(TIFFField),\n\t\t\t\t\t      reason);\n\tif (!tif->tif_fieldscompat[nfields].fields) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn -1;\n\t}\n\n\ttp = tif->tif_fieldscompat[nfields].fields;\n\tfor (i = 0; i < n; i++) {\n\t\ttp->field_tag = info[i].field_tag;\n\t\ttp->field_readcount = info[i].field_readcount;\n\t\ttp->field_writecount = info[i].field_writecount;\n\t\ttp->field_type = info[i].field_type;\n\t\ttp->reserved = 0;\n\t\ttp->set_field_type =\n\t\t     _TIFFSetGetType(info[i].field_type,\n\t\t\t\tinfo[i].field_readcount,\n\t\t\t\tinfo[i].field_passcount);\n\t\ttp->get_field_type =\n\t\t     _TIFFSetGetType(info[i].field_type,\n\t\t\t\tinfo[i].field_readcount,\n\t\t\t\tinfo[i].field_passcount);\n\t\ttp->field_bit = info[i].field_bit;\n\t\ttp->field_oktochange = info[i].field_oktochange;\n\t\ttp->field_passcount = info[i].field_passcount;\n\t\tif (info[i].field_name == NULL) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Field_name of %d.th allocation tag %d is NULL\", i, info[i].field_tag);\n\t\t\treturn -1;\n\t\t}\n\t\ttp->field_name = info[i].field_name;\n\t\ttp->field_subfields = NULL;\n\t\ttp++;\n\t}\n\n\tif (!_TIFFMergeFields(tif, tif->tif_fieldscompat[nfields].fields, n)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Setting up field info failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "func": "int\nTIFFMergeFieldInfo(TIFF* tif, const TIFFFieldInfo info[], uint32_t n)\n{\n\tstatic const char module[] = \"TIFFMergeFieldInfo\";\n\tstatic const char reason[] = \"for fields array\";\n\tTIFFField *tp;\n\tsize_t nfields;\n\tuint32_t i;\n\n\tif (tif->tif_nfieldscompat > 0) {\n\t\ttif->tif_fieldscompat = (TIFFFieldArray *)\n\t\t\t_TIFFCheckRealloc(tif, tif->tif_fieldscompat,\n\t\t\t\t\t  tif->tif_nfieldscompat + 1,\n\t\t\t\t\t  sizeof(TIFFFieldArray), reason);\n\t} else {\n\t\ttif->tif_fieldscompat = (TIFFFieldArray *)\n\t\t\t_TIFFCheckMalloc(tif, 1, sizeof(TIFFFieldArray),\n\t\t\t\t\t reason);\n\t}\n\tif (!tif->tif_fieldscompat) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn -1;\n\t}\n\tnfields = tif->tif_nfieldscompat++;\n\n\ttif->tif_fieldscompat[nfields].type = tfiatOther;\n\ttif->tif_fieldscompat[nfields].allocated_size = n;\n\ttif->tif_fieldscompat[nfields].count = n;\n\ttif->tif_fieldscompat[nfields].fields =\n\t\t(TIFFField *)_TIFFCheckMalloc(tif, n, sizeof(TIFFField),\n\t\t\t\t\t      reason);\n\tif (!tif->tif_fieldscompat[nfields].fields) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn -1;\n\t}\n\n\ttp = tif->tif_fieldscompat[nfields].fields;\n\tfor (i = 0; i < n; i++) {\n\t\ttp->field_tag = info[i].field_tag;\n\t\ttp->field_readcount = info[i].field_readcount;\n\t\ttp->field_writecount = info[i].field_writecount;\n\t\ttp->field_type = info[i].field_type;\n\t\ttp->field_anonymous = 0;\n\t\ttp->set_field_type =\n\t\t     _TIFFSetGetType(info[i].field_type,\n\t\t\t\tinfo[i].field_readcount,\n\t\t\t\tinfo[i].field_passcount);\n\t\ttp->get_field_type =\n\t\t     _TIFFSetGetType(info[i].field_type,\n\t\t\t\tinfo[i].field_readcount,\n\t\t\t\tinfo[i].field_passcount);\n\t\ttp->field_bit = info[i].field_bit;\n\t\ttp->field_oktochange = info[i].field_oktochange;\n\t\ttp->field_passcount = info[i].field_passcount;\n\t\tif (info[i].field_name == NULL) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Field_name of %d.th allocation tag %d is NULL\", i, info[i].field_tag);\n\t\t\treturn -1;\n\t\t}\n\t\ttp->field_name = info[i].field_name;\n\t\ttp->field_subfields = NULL;\n\t\ttp++;\n\t}\n\n\tif (!_TIFFMergeFields(tif, tif->tif_fieldscompat[nfields].fields, n)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Setting up field info failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n \t\ttp->field_readcount = info[i].field_readcount;\n \t\ttp->field_writecount = info[i].field_writecount;\n \t\ttp->field_type = info[i].field_type;\n-\t\ttp->reserved = 0;\n+\t\ttp->field_anonymous = 0;\n \t\ttp->set_field_type =\n \t\t     _TIFFSetGetType(info[i].field_type,\n \t\t\t\tinfo[i].field_readcount,",
        "diff_line_info": {
            "deleted_lines": [
                "\t\ttp->reserved = 0;"
            ],
            "added_lines": [
                "\t\ttp->field_anonymous = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1355",
        "func_name": "libtiff/main",
        "description": "A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/fb1db384959698edd6caeea84e28253d272a0f96",
        "commit_title": "tiffcp: avoid buffer overflow in \"mode\" string (fixes #400)",
        "commit_text": "",
        "func_before": "int\nmain(int argc, char* argv[])\n{\n\tuint16_t defconfig = (uint16_t) -1;\n\tuint16_t deffillorder = 0;\n\tuint32_t deftilewidth = (uint32_t) -1;\n\tuint32_t deftilelength = (uint32_t) -1;\n\tuint32_t defrowsperstrip = (uint32_t) 0;\n\tuint64_t diroff = 0;\n\tTIFF* in;\n\tTIFF* out;\n\tchar mode[10];\n\tchar* mp = mode;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\t*mp++ = 'w';\n\t*mp = '\\0';\n\twhile ((c = getopt(argc, argv, \"m:,:b:c:f:l:o:p:r:w:aistBLMC8xh\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'm':\n\t\t\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\tif (optarg[0] != '=') usage(EXIT_FAILURE);\n\t\t\tcomma = optarg[1];\n\t\t\tbreak;\n\t\tcase 'b':   /* this file is bias image subtracted from others */\n\t\t\tif (bias) {\n\t\t\t\tfputs (\"Only 1 bias image may be specified\\n\", stderr);\n\t\t\t\texit (EXIT_FAILURE);\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint16_t samples = (uint16_t) -1;\n\t\t\t\tchar **biasFn = &optarg;\n\t\t\t\tbias = openSrcImage (biasFn);\n\t\t\t\tif (!bias) exit (EXIT_FAILURE);\n\t\t\t\tif (TIFFIsTiled (bias)) {\n\t\t\t\t\tfputs (\"Bias image must be organized in strips\\n\", stderr);\n\t\t\t\t\texit (EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tTIFFGetField(bias, TIFFTAG_SAMPLESPERPIXEL, &samples);\n\t\t\t\tif (samples != 1) {\n\t\t\t\t\tfputs (\"Bias image must be monochrome\\n\", stderr);\n\t\t\t\t\texit (EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':   /* append to output */\n\t\t\tmode[0] = 'a';\n\t\t\tbreak;\n\t\tcase 'c':   /* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage(EXIT_FAILURE);\n\t\t\tbreak;\n\t\tcase 'f':   /* fill order */\n\t\t\tif (streq(optarg, \"lsb2msb\"))\n\t\t\t\tdeffillorder = FILLORDER_LSB2MSB;\n\t\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t\t\tdeffillorder = FILLORDER_MSB2LSB;\n\t\t\telse\n\t\t\t\tusage(EXIT_FAILURE);\n\t\t\tbreak;\n\t\tcase 'i':   /* ignore errors */\n\t\t\tignore = TRUE;\n\t\t\tbreak;\n\t\tcase 'l':   /* tile length */\n\t\t\touttiled = TRUE;\n\t\t\tdeftilelength = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'o':   /* initial directory offset */\n\t\t\tdiroff = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'p':   /* planar configuration */\n\t\t\tif (streq(optarg, \"separate\"))\n\t\t\t\tdefconfig = PLANARCONFIG_SEPARATE;\n\t\t\telse if (streq(optarg, \"contig\"))\n\t\t\t\tdefconfig = PLANARCONFIG_CONTIG;\n\t\t\telse\n\t\t\t\tusage(EXIT_FAILURE);\n\t\t\tbreak;\n\t\tcase 'r':   /* rows/strip */\n\t\t\tdefrowsperstrip = atol(optarg);\n\t\t\tbreak;\n\t\tcase 's':   /* generate stripped output */\n\t\t\touttiled = FALSE;\n\t\t\tbreak;\n\t\tcase 't':   /* generate tiled output */\n\t\t\touttiled = TRUE;\n\t\t\tbreak;\n\t\tcase 'w':   /* tile width */\n\t\t\touttiled = TRUE;\n\t\t\tdeftilewidth = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\t*mp++ = 'b'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t*mp++ = 'l'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\t*mp++ = 'm'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t*mp++ = 'c'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\t*mp++ = '8'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tpageInSeq = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(EXIT_SUCCESS);\n\t\t\t/*NOTREACHED*/\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage(EXIT_FAILURE);\n\t\t\t/*NOTREACHED*/\n\t\t\tbreak;\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage(EXIT_FAILURE);\n\tout = TIFFOpen(argv[argc-1], mode);\n\tif (out == NULL)\n\t\treturn (EXIT_FAILURE);\n\tif ((argc - optind) == 2)\n\t\tpageNum = -1;\n\tfor (; optind < argc-1 ; optind++) {\n\t\tchar *imageCursor = argv[optind];\n\t\tin = openSrcImage (&imageCursor);\n\t\tif (in == NULL) {\n\t\t\t(void) TIFFClose(out);\n\t\t\treturn (EXIT_FAILURE);\n\t\t}\n\t\tif (diroff != 0 && !TIFFSetSubDirectory(in, diroff)) {\n\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t    \"Error, setting subdirectory at %\" PRIu64, diroff);\n\t\t\t(void) TIFFClose(in);\n\t\t\t(void) TIFFClose(out);\n\t\t\treturn (EXIT_FAILURE);\n\t\t}\n\t\tfor (;;) {\n\t\t\tconfig = defconfig;\n\t\t\tcompression = defcompression;\n\t\t\tpredictor = defpredictor;\n                        preset = defpreset;\n\t\t\tfillorder = deffillorder;\n\t\t\trowsperstrip = defrowsperstrip;\n\t\t\ttilewidth = deftilewidth;\n\t\t\ttilelength = deftilelength;\n\t\t\tg3opts = defg3opts;\n\t\t\tif (!tiffcp(in, out) || !TIFFWriteDirectory(out)) {\n\t\t\t\t(void) TIFFClose(in);\n\t\t\t\t(void) TIFFClose(out);\n\t\t\t\treturn (EXIT_FAILURE);\n\t\t\t}\n\t\t\tif (imageCursor) { /* seek next image directory */\n\t\t\t\tif (!nextSrcImage(in, &imageCursor)) break;\n\t\t\t}else\n\t\t\t\tif (!TIFFReadDirectory(in)) break;\n\t\t}\n\t\t(void) TIFFClose(in);\n\t}\n\n\t(void) TIFFClose(out);\n\treturn (EXIT_SUCCESS);\n}",
        "func": "int\nmain(int argc, char* argv[])\n{\n\tuint16_t defconfig = (uint16_t) -1;\n\tuint16_t deffillorder = 0;\n\tuint32_t deftilewidth = (uint32_t) -1;\n\tuint32_t deftilelength = (uint32_t) -1;\n\tuint32_t defrowsperstrip = (uint32_t) 0;\n\tuint64_t diroff = 0;\n\tTIFF* in;\n\tTIFF* out;\n\tchar mode[10];\n\tchar* mp = mode;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\t*mp++ = 'w';\n\t*mp = '\\0';\n\twhile ((c = getopt(argc, argv, \"m:,:b:c:f:l:o:p:r:w:aistBLMC8xh\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'm':\n\t\t\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\tif (optarg[0] != '=') usage(EXIT_FAILURE);\n\t\t\tcomma = optarg[1];\n\t\t\tbreak;\n\t\tcase 'b':   /* this file is bias image subtracted from others */\n\t\t\tif (bias) {\n\t\t\t\tfputs (\"Only 1 bias image may be specified\\n\", stderr);\n\t\t\t\texit (EXIT_FAILURE);\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint16_t samples = (uint16_t) -1;\n\t\t\t\tchar **biasFn = &optarg;\n\t\t\t\tbias = openSrcImage (biasFn);\n\t\t\t\tif (!bias) exit (EXIT_FAILURE);\n\t\t\t\tif (TIFFIsTiled (bias)) {\n\t\t\t\t\tfputs (\"Bias image must be organized in strips\\n\", stderr);\n\t\t\t\t\texit (EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tTIFFGetField(bias, TIFFTAG_SAMPLESPERPIXEL, &samples);\n\t\t\t\tif (samples != 1) {\n\t\t\t\t\tfputs (\"Bias image must be monochrome\\n\", stderr);\n\t\t\t\t\texit (EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':   /* append to output */\n\t\t\tmode[0] = 'a';\n\t\t\tbreak;\n\t\tcase 'c':   /* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage(EXIT_FAILURE);\n\t\t\tbreak;\n\t\tcase 'f':   /* fill order */\n\t\t\tif (streq(optarg, \"lsb2msb\"))\n\t\t\t\tdeffillorder = FILLORDER_LSB2MSB;\n\t\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t\t\tdeffillorder = FILLORDER_MSB2LSB;\n\t\t\telse\n\t\t\t\tusage(EXIT_FAILURE);\n\t\t\tbreak;\n\t\tcase 'i':   /* ignore errors */\n\t\t\tignore = TRUE;\n\t\t\tbreak;\n\t\tcase 'l':   /* tile length */\n\t\t\touttiled = TRUE;\n\t\t\tdeftilelength = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'o':   /* initial directory offset */\n\t\t\tdiroff = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'p':   /* planar configuration */\n\t\t\tif (streq(optarg, \"separate\"))\n\t\t\t\tdefconfig = PLANARCONFIG_SEPARATE;\n\t\t\telse if (streq(optarg, \"contig\"))\n\t\t\t\tdefconfig = PLANARCONFIG_CONTIG;\n\t\t\telse\n\t\t\t\tusage(EXIT_FAILURE);\n\t\t\tbreak;\n\t\tcase 'r':   /* rows/strip */\n\t\t\tdefrowsperstrip = atol(optarg);\n\t\t\tbreak;\n\t\tcase 's':   /* generate stripped output */\n\t\t\touttiled = FALSE;\n\t\t\tbreak;\n\t\tcase 't':   /* generate tiled output */\n\t\t\touttiled = TRUE;\n\t\t\tbreak;\n\t\tcase 'w':   /* tile width */\n\t\t\touttiled = TRUE;\n\t\t\tdeftilewidth = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tif (strlen(mode) < (sizeof(mode) - 1))\n\t\t\t{\n\t\t\t\t*mp++ = 'b'; *mp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (strlen(mode) < (sizeof(mode) - 1))\n\t\t\t{\n\t\t\t\t*mp++ = 'l'; *mp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tif (strlen(mode) < (sizeof(mode) - 1))\n\t\t\t{\n\t\t\t\t*mp++ = 'm'; *mp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tif (strlen(mode) < (sizeof(mode) - 1))\n\t\t\t{\n\t\t\t\t*mp++ = 'c'; *mp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\tif (strlen(mode) < (sizeof(mode)-1))\n\t\t\t{\n\t\t\t\t*mp++ = '8'; *mp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tpageInSeq = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(EXIT_SUCCESS);\n\t\t\t/*NOTREACHED*/\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage(EXIT_FAILURE);\n\t\t\t/*NOTREACHED*/\n\t\t\tbreak;\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage(EXIT_FAILURE);\n\tout = TIFFOpen(argv[argc-1], mode);\n\tif (out == NULL)\n\t\treturn (EXIT_FAILURE);\n\tif ((argc - optind) == 2)\n\t\tpageNum = -1;\n\tfor (; optind < argc-1 ; optind++) {\n\t\tchar *imageCursor = argv[optind];\n\t\tin = openSrcImage (&imageCursor);\n\t\tif (in == NULL) {\n\t\t\t(void) TIFFClose(out);\n\t\t\treturn (EXIT_FAILURE);\n\t\t}\n\t\tif (diroff != 0 && !TIFFSetSubDirectory(in, diroff)) {\n\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t    \"Error, setting subdirectory at %\" PRIu64, diroff);\n\t\t\t(void) TIFFClose(in);\n\t\t\t(void) TIFFClose(out);\n\t\t\treturn (EXIT_FAILURE);\n\t\t}\n\t\tfor (;;) {\n\t\t\tconfig = defconfig;\n\t\t\tcompression = defcompression;\n\t\t\tpredictor = defpredictor;\n                        preset = defpreset;\n\t\t\tfillorder = deffillorder;\n\t\t\trowsperstrip = defrowsperstrip;\n\t\t\ttilewidth = deftilewidth;\n\t\t\ttilelength = deftilelength;\n\t\t\tg3opts = defg3opts;\n\t\t\tif (!tiffcp(in, out) || !TIFFWriteDirectory(out)) {\n\t\t\t\t(void) TIFFClose(in);\n\t\t\t\t(void) TIFFClose(out);\n\t\t\t\treturn (EXIT_FAILURE);\n\t\t\t}\n\t\t\tif (imageCursor) { /* seek next image directory */\n\t\t\t\tif (!nextSrcImage(in, &imageCursor)) break;\n\t\t\t}else\n\t\t\t\tif (!TIFFReadDirectory(in)) break;\n\t\t}\n\t\t(void) TIFFClose(in);\n\t}\n\n\t(void) TIFFClose(out);\n\treturn (EXIT_SUCCESS);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -96,19 +96,34 @@\n \t\t\tdeftilewidth = atoi(optarg);\n \t\t\tbreak;\n \t\tcase 'B':\n-\t\t\t*mp++ = 'b'; *mp = '\\0';\n+\t\t\tif (strlen(mode) < (sizeof(mode) - 1))\n+\t\t\t{\n+\t\t\t\t*mp++ = 'b'; *mp = '\\0';\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase 'L':\n-\t\t\t*mp++ = 'l'; *mp = '\\0';\n+\t\t\tif (strlen(mode) < (sizeof(mode) - 1))\n+\t\t\t{\n+\t\t\t\t*mp++ = 'l'; *mp = '\\0';\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase 'M':\n-\t\t\t*mp++ = 'm'; *mp = '\\0';\n+\t\t\tif (strlen(mode) < (sizeof(mode) - 1))\n+\t\t\t{\n+\t\t\t\t*mp++ = 'm'; *mp = '\\0';\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase 'C':\n-\t\t\t*mp++ = 'c'; *mp = '\\0';\n+\t\t\tif (strlen(mode) < (sizeof(mode) - 1))\n+\t\t\t{\n+\t\t\t\t*mp++ = 'c'; *mp = '\\0';\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase '8':\n-\t\t\t*mp++ = '8'; *mp = '\\0';\n+\t\t\tif (strlen(mode) < (sizeof(mode)-1))\n+\t\t\t{\n+\t\t\t\t*mp++ = '8'; *mp = '\\0';\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase 'x':\n \t\t\tpageInSeq = 1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t*mp++ = 'b'; *mp = '\\0';",
                "\t\t\t*mp++ = 'l'; *mp = '\\0';",
                "\t\t\t*mp++ = 'm'; *mp = '\\0';",
                "\t\t\t*mp++ = 'c'; *mp = '\\0';",
                "\t\t\t*mp++ = '8'; *mp = '\\0';"
            ],
            "added_lines": [
                "\t\t\tif (strlen(mode) < (sizeof(mode) - 1))",
                "\t\t\t{",
                "\t\t\t\t*mp++ = 'b'; *mp = '\\0';",
                "\t\t\t}",
                "\t\t\tif (strlen(mode) < (sizeof(mode) - 1))",
                "\t\t\t{",
                "\t\t\t\t*mp++ = 'l'; *mp = '\\0';",
                "\t\t\t}",
                "\t\t\tif (strlen(mode) < (sizeof(mode) - 1))",
                "\t\t\t{",
                "\t\t\t\t*mp++ = 'm'; *mp = '\\0';",
                "\t\t\t}",
                "\t\t\tif (strlen(mode) < (sizeof(mode) - 1))",
                "\t\t\t{",
                "\t\t\t\t*mp++ = 'c'; *mp = '\\0';",
                "\t\t\t}",
                "\t\t\tif (strlen(mode) < (sizeof(mode)-1))",
                "\t\t\t{",
                "\t\t\t\t*mp++ = '8'; *mp = '\\0';",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25308",
        "func_name": "fribidi/main",
        "description": "A stack-based buffer overflow flaw was found in the Fribidi package. This flaw allows an attacker to pass a specially crafted file to the Fribidi application, which leads to a possible memory leak or a denial of service.",
        "git_url": "https://github.com/fribidi/fribidi/commit/ad3a19e6372b1e667128ed1ea2f49919884587e1",
        "commit_title": "Fix the stack buffer overflow issue",
        "commit_text": " strlen() could returns 0. Without a conditional check for len, accessing S_ pointer with len - 1 may causes a stack buffer overflow.  AddressSanitizer reports this like: ==1219243==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffdce043c1f at pc 0x000000403547 bp 0x7ffdce0 43b30 sp 0x7ffdce043b28 READ of size 1 at 0x7ffdce043c1f thread T0     #0 0x403546 in main ../bin/fribidi-main.c:393     #1 0x7f226804e58f in __libc_start_call_main (/lib64/libc.so.6+0x2d58f)     #2 0x7f226804e648 in __libc_start_main_impl (/lib64/libc.so.6+0x2d648)     #3 0x4036f4 in _start (/tmp/fribidi/build/bin/fribidi+0x4036f4)  Address 0x7ffdce043c1f is located in stack of thread T0 at offset 63 in frame     #0 0x4022bf in main ../bin/fribidi-main.c:193    This frame has 5 object(s):     [32, 36) 'option_index' (line 233)     [48, 52) 'base' (line 386)     [64, 65064) 'S_' (line 375) <== Memory access at offset 63 underflows this variable     [65328, 130328) 'outstring' (line 385)     [130592, 390592) 'logical' (line 384)  This fixes https://github.com/fribidi/fribidi/issues/181",
        "func_before": "int\nmain (\n  int argc,\n  char *argv[]\n)\n{\n  int exit_val;\n  fribidi_boolean file_found;\n  char *s;\n  FILE *IN;\n\n  text_width = default_text_width;\n  do_break = true;\n  do_pad = true;\n  do_mirror = true;\n  do_clean = false;\n  do_reorder_nsm = false;\n  show_input = false;\n  show_visual = true;\n  show_basedir = false;\n  show_ltov = false;\n  show_vtol = false;\n  show_levels = false;\n  char_set = \"UTF-8\";\n  bol_text = NULL;\n  eol_text = NULL;\n  input_base_direction = FRIBIDI_PAR_ON;\n\n  if ((s = (char *) getenv (\"COLUMNS\")))\n    {\n      int i;\n\n      i = atoi (s);\n      if (i > 0)\n\ttext_width = i;\n    }\n\n#define CHARSETDESC 257\n#define CAPRTL 258\n\n  /* Parse the command line with getopt library */\n  /* Must set argv[0], getopt uses it to generate error messages */\n  argv[0] = appname;\n  while (1)\n    {\n      int option_index = 0, c;\n      static struct option long_options[] = {\n\t{\"help\", 0, 0, 'h'},\n\t{\"version\", 0, 0, 'V'},\n\t{\"verbose\", 0, 0, 'v'},\n\t{\"debug\", 0, 0, 'd'},\n\t{\"test\", 0, 0, 't'},\n\t{\"charset\", 1, 0, 'c'},\n\t{\"charsetdesc\", 1, 0, CHARSETDESC},\n\t{\"caprtl\", 0, 0, CAPRTL},\n\t{\"showinput\", 0, (int *) (void *) &show_input, true},\n\t{\"nopad\", 0, (int *) (void *) &do_pad, false},\n\t{\"nobreak\", 0, (int *) (void *) &do_break, false},\n\t{\"width\", 1, 0, 'w'},\n\t{\"bol\", 1, 0, 'B'},\n\t{\"eol\", 1, 0, 'E'},\n\t{\"nomirror\", 0, (int *) (void *) &do_mirror, false},\n\t{\"reordernsm\", 0, (int *) (void *) &do_reorder_nsm, true},\n\t{\"clean\", 0, (int *) (void *) &do_clean, true},\n\t{\"ltr\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_LTR},\n\t{\"rtl\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_RTL},\n\t{\"wltr\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WLTR},\n\t{\"wrtl\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WRTL},\n\t{\"basedir\", 0, (int *) (void *) &show_basedir, true},\n\t{\"ltov\", 0, (int *) (void *) &show_ltov, true},\n\t{\"vtol\", 0, (int *) (void *) &show_vtol, true},\n\t{\"levels\", 0, (int *) (void *) &show_levels, true},\n\t{\"novisual\", 0, (int *) (void *) &show_visual, false},\n\t{0, 0, 0, 0}\n      };\n\n      c =\n\tgetopt_long (argc, argv, \"hVvdtc:w:B:E:\", long_options,\n\t\t     &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  break;\n\tcase 'h':\n\t  help ();\n\t  break;\n\tcase 'V':\n\t  version ();\n\t  break;\n\tcase 'v':\n\t  show_basedir = show_ltov = show_vtol = show_levels = true;\n\t  break;\n\tcase 'w':\n\t  text_width = atoi (optarg);\n\t  if (text_width <= 0)\n\t    die2 (\"invalid screen width `%s'\\n\", optarg);\n\t  break;\n\tcase 'B':\n\t  bol_text = optarg;\n\t  break;\n\tcase 'E':\n\t  eol_text = optarg;\n\t  break;\n\tcase 'd':\n\t  if (!fribidi_set_debug (true))\n\t    die1\n\t      (\"lib\" FRIBIDI\n\t       \" must be compiled with DEBUG option to enable\\nturn debug info on.\\n\");\n\t  break;\n\tcase 't':\n\t  do_clean = show_input = do_reorder_nsm = true;\n\t  do_break = false;\n\t  text_width = default_text_width;\n\t  break;\n\tcase 'c':\n\t  char_set = my_fribidi_strdup (optarg);\n\t  if (!char_set)\n\t    die1 (\"memory allocation failed for char_set!\");\n\t  break;\n\tcase CAPRTL:\n\t  char_set = \"CapRTL\";\n\t  break;\n\tcase CHARSETDESC:\n\t  char_set = optarg;\n\t  char_set_num = fribidi_parse_charset (char_set);\n\t  if (!char_set_num)\n\t    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\t  if (!fribidi_char_set_desc (char_set_num))\n\t    die2 (\"no description available for character set `%s'\\n\",\n\t\t  fribidi_char_set_name (char_set_num));\n\t  else\n\t    printf (\"Descriptions for character set %s:\\n\"\n\t\t    \"\\n\" \"%s\", fribidi_char_set_title (char_set_num),\n\t\t    fribidi_char_set_desc (char_set_num));\n\t  exit (0);\n\t  break;\n\tcase ':':\n\tcase '?':\n\t  die2 (NULL, NULL);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n\n  char_set_num = fribidi_parse_charset (char_set);\n\n  if (!char_set_num)\n    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\nFRIBIDI_BEGIN_IGNORE_DEPRECATIONS\n  fribidi_set_mirroring (do_mirror);\n  fribidi_set_reorder_nsm (do_reorder_nsm);\nFRIBIDI_END_IGNORE_DEPRECATIONS\n  exit_val = 0;\n  file_found = false;\n  while (optind < argc || !file_found)\n    {\n      const char *filename;\n\n      filename = optind < argc ? argv[optind++] : \"-\";\n      file_found = true;\n\n      /* Open the infile for reading */\n      if (filename[0] == '-' && !filename[1])\n\t{\n\t  IN = stdin;\n\t}\n      else\n\t{\n\t  IN = fopen (filename, \"r\");\n\t  if (!IN)\n\t    {\n\t      fprintf (stderr, \"%s: %s: no such file or directory\\n\",\n\t\t       appname, filename);\n\t      exit_val = 1;\n\t      continue;\n\t    }\n\t}\n\n      /* Read and process input one line at a time */\n      {\n\tchar S_[MAX_STR_LEN];\n\tint padding_width, break_width;\n\n\tpadding_width = show_input ? (text_width - 10) / 2 : text_width;\n\tbreak_width = do_break ? padding_width : 3 * MAX_STR_LEN;\n\n\twhile (fgets (S_, sizeof (S_) - 1, IN))\n\t  {\n\t    const char *new_line, *nl_found;\n\t    FriBidiChar logical[MAX_STR_LEN];\n\t    char outstring[MAX_STR_LEN];\n\t    FriBidiParType base;\n\t    FriBidiStrIndex len;\n\n\t    nl_found = \"\";\n\t    S_[sizeof (S_) - 1] = 0;\n\t    len = strlen (S_);\n\t    /* chop */\n\t    if (S_[len - 1] == '\\n')\n\t      {\n\t\tlen--;\n\t\tS_[len] = '\\0';\n\t\tnew_line = \"\\n\";\n\t      }\n\t    else\n\t      new_line = \"\";\n\t    /* TODO: handle \\r */\n\n\t    len = fribidi_charset_to_unicode (char_set_num, S_, len, logical);\n\n\t    {\n\t      FriBidiChar *visual;\n\t      FriBidiStrIndex *ltov, *vtol;\n\t      FriBidiLevel *levels;\n\t      fribidi_boolean log2vis;\n\n\t      visual = show_visual ? ALLOCATE (FriBidiChar,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\t      ltov = show_ltov ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      vtol = show_vtol ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      levels = show_levels ? ALLOCATE (FriBidiLevel,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\n\t      /* Create a bidi string. */\n\t      base = input_base_direction;\n\n\t      log2vis = fribidi_log2vis (logical, len, &base,\n\t\t\t\t\t /* output */\n\t\t\t\t\t visual, ltov, vtol, levels);\n\n\t      if (log2vis)\n\t\t{\n\n\t\t  if (show_input)\n\t\t    printf (\"%-*s => \", padding_width, S_);\n\n\t\t  /* Remove explicit marks, if asked for. */\n\n\t\t  if (do_clean)\n\t\t    len =\n\t\t      fribidi_remove_bidi_marks (visual, len, ltov, vtol,\n\t\t\t\t\t\t levels);\n\n\t\t  if (show_visual)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\n\t\t      if (bol_text)\n\t\t\tprintf (\"%s\", bol_text);\n\n\t\t      /* Convert it to input charset and print. */\n\t\t      {\n\t\t\tFriBidiStrIndex idx, st;\n\t\t\tfor (idx = 0; idx < len;)\n\t\t\t  {\n\t\t\t    FriBidiStrIndex wid, inlen;\n\n\t\t\t    wid = break_width;\n\t\t\t    st = idx;\n\t\t\t    if (char_set_num != FRIBIDI_CHAR_SET_CAP_RTL)\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid -=\n\t\t\t\t    FRIBIDI_IS_EXPLICIT_OR_ISOLATE_OR_BN_OR_NSM\n\t\t\t\t    (fribidi_get_bidi_type (visual[idx])) ? 0\n\t\t\t\t    : 1;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid--;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    if (wid < 0 && idx - st > 1)\n\t\t\t      idx--;\n\t\t\t    inlen = idx - st;\n\n\t\t\t    fribidi_unicode_to_charset (char_set_num,\n\t\t\t\t\t\t\tvisual + st, inlen,\n\t\t\t\t\t\t\toutstring);\n\t\t\t    if (FRIBIDI_IS_RTL (base))\n\t\t\t      printf (\"%*s\",\n\t\t\t\t      (int) (do_pad ? (padding_width +\n\t\t\t\t\t\t       strlen (outstring) -\n\t\t\t\t\t\t       (break_width -\n\t\t\t\t\t\t\twid)) : 0),\n\t\t\t\t      outstring);\n\t\t\t    else\n\t\t\t      printf (\"%s\", outstring);\n\t\t\t    if (idx < len)\n\t\t\t      printf (\"\\n\");\n\t\t\t  }\n\t\t      }\n\t\t      if (eol_text)\n\t\t\tprintf (\"%s\", eol_text);\n\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_basedir)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\t\t      printf (\"Base direction: %s\",\n\t\t\t      (FRIBIDI_DIR_TO_LEVEL (base) ? \"R\" : \"L\"));\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_ltov)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) ltov[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_vtol)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) vtol[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_levels)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%d \", (int) levels[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  exit_val = 2;\n\t\t}\n\n\t      if (show_visual)\n\t\tfree (visual);\n\t      if (show_ltov)\n\t\tfree (ltov);\n\t      if (show_vtol)\n\t\tfree (vtol);\n\t      if (show_levels)\n\t\tfree (levels);\n\t    }\n\n\t    if (*nl_found)\n\t      printf (\"%s\", new_line);\n\t  }\n      }\n    }",
        "func": "int\nmain (\n  int argc,\n  char *argv[]\n)\n{\n  int exit_val;\n  fribidi_boolean file_found;\n  char *s;\n  FILE *IN;\n\n  text_width = default_text_width;\n  do_break = true;\n  do_pad = true;\n  do_mirror = true;\n  do_clean = false;\n  do_reorder_nsm = false;\n  show_input = false;\n  show_visual = true;\n  show_basedir = false;\n  show_ltov = false;\n  show_vtol = false;\n  show_levels = false;\n  char_set = \"UTF-8\";\n  bol_text = NULL;\n  eol_text = NULL;\n  input_base_direction = FRIBIDI_PAR_ON;\n\n  if ((s = (char *) getenv (\"COLUMNS\")))\n    {\n      int i;\n\n      i = atoi (s);\n      if (i > 0)\n\ttext_width = i;\n    }\n\n#define CHARSETDESC 257\n#define CAPRTL 258\n\n  /* Parse the command line with getopt library */\n  /* Must set argv[0], getopt uses it to generate error messages */\n  argv[0] = appname;\n  while (1)\n    {\n      int option_index = 0, c;\n      static struct option long_options[] = {\n\t{\"help\", 0, 0, 'h'},\n\t{\"version\", 0, 0, 'V'},\n\t{\"verbose\", 0, 0, 'v'},\n\t{\"debug\", 0, 0, 'd'},\n\t{\"test\", 0, 0, 't'},\n\t{\"charset\", 1, 0, 'c'},\n\t{\"charsetdesc\", 1, 0, CHARSETDESC},\n\t{\"caprtl\", 0, 0, CAPRTL},\n\t{\"showinput\", 0, (int *) (void *) &show_input, true},\n\t{\"nopad\", 0, (int *) (void *) &do_pad, false},\n\t{\"nobreak\", 0, (int *) (void *) &do_break, false},\n\t{\"width\", 1, 0, 'w'},\n\t{\"bol\", 1, 0, 'B'},\n\t{\"eol\", 1, 0, 'E'},\n\t{\"nomirror\", 0, (int *) (void *) &do_mirror, false},\n\t{\"reordernsm\", 0, (int *) (void *) &do_reorder_nsm, true},\n\t{\"clean\", 0, (int *) (void *) &do_clean, true},\n\t{\"ltr\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_LTR},\n\t{\"rtl\", 0, (int *) (void *) &input_base_direction, FRIBIDI_PAR_RTL},\n\t{\"wltr\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WLTR},\n\t{\"wrtl\", 0, (int *) (void *) &input_base_direction,\n\t FRIBIDI_PAR_WRTL},\n\t{\"basedir\", 0, (int *) (void *) &show_basedir, true},\n\t{\"ltov\", 0, (int *) (void *) &show_ltov, true},\n\t{\"vtol\", 0, (int *) (void *) &show_vtol, true},\n\t{\"levels\", 0, (int *) (void *) &show_levels, true},\n\t{\"novisual\", 0, (int *) (void *) &show_visual, false},\n\t{0, 0, 0, 0}\n      };\n\n      c =\n\tgetopt_long (argc, argv, \"hVvdtc:w:B:E:\", long_options,\n\t\t     &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  break;\n\tcase 'h':\n\t  help ();\n\t  break;\n\tcase 'V':\n\t  version ();\n\t  break;\n\tcase 'v':\n\t  show_basedir = show_ltov = show_vtol = show_levels = true;\n\t  break;\n\tcase 'w':\n\t  text_width = atoi (optarg);\n\t  if (text_width <= 0)\n\t    die2 (\"invalid screen width `%s'\\n\", optarg);\n\t  break;\n\tcase 'B':\n\t  bol_text = optarg;\n\t  break;\n\tcase 'E':\n\t  eol_text = optarg;\n\t  break;\n\tcase 'd':\n\t  if (!fribidi_set_debug (true))\n\t    die1\n\t      (\"lib\" FRIBIDI\n\t       \" must be compiled with DEBUG option to enable\\nturn debug info on.\\n\");\n\t  break;\n\tcase 't':\n\t  do_clean = show_input = do_reorder_nsm = true;\n\t  do_break = false;\n\t  text_width = default_text_width;\n\t  break;\n\tcase 'c':\n\t  char_set = my_fribidi_strdup (optarg);\n\t  if (!char_set)\n\t    die1 (\"memory allocation failed for char_set!\");\n\t  break;\n\tcase CAPRTL:\n\t  char_set = \"CapRTL\";\n\t  break;\n\tcase CHARSETDESC:\n\t  char_set = optarg;\n\t  char_set_num = fribidi_parse_charset (char_set);\n\t  if (!char_set_num)\n\t    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\t  if (!fribidi_char_set_desc (char_set_num))\n\t    die2 (\"no description available for character set `%s'\\n\",\n\t\t  fribidi_char_set_name (char_set_num));\n\t  else\n\t    printf (\"Descriptions for character set %s:\\n\"\n\t\t    \"\\n\" \"%s\", fribidi_char_set_title (char_set_num),\n\t\t    fribidi_char_set_desc (char_set_num));\n\t  exit (0);\n\t  break;\n\tcase ':':\n\tcase '?':\n\t  die2 (NULL, NULL);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n\n  char_set_num = fribidi_parse_charset (char_set);\n\n  if (!char_set_num)\n    die2 (\"unrecognized character set `%s'\\n\", char_set);\n\nFRIBIDI_BEGIN_IGNORE_DEPRECATIONS\n  fribidi_set_mirroring (do_mirror);\n  fribidi_set_reorder_nsm (do_reorder_nsm);\nFRIBIDI_END_IGNORE_DEPRECATIONS\n  exit_val = 0;\n  file_found = false;\n  while (optind < argc || !file_found)\n    {\n      const char *filename;\n\n      filename = optind < argc ? argv[optind++] : \"-\";\n      file_found = true;\n\n      /* Open the infile for reading */\n      if (filename[0] == '-' && !filename[1])\n\t{\n\t  IN = stdin;\n\t}\n      else\n\t{\n\t  IN = fopen (filename, \"r\");\n\t  if (!IN)\n\t    {\n\t      fprintf (stderr, \"%s: %s: no such file or directory\\n\",\n\t\t       appname, filename);\n\t      exit_val = 1;\n\t      continue;\n\t    }\n\t}\n\n      /* Read and process input one line at a time */\n      {\n\tchar S_[MAX_STR_LEN];\n\tint padding_width, break_width;\n\n\tpadding_width = show_input ? (text_width - 10) / 2 : text_width;\n\tbreak_width = do_break ? padding_width : 3 * MAX_STR_LEN;\n\n\twhile (fgets (S_, sizeof (S_) - 1, IN))\n\t  {\n\t    const char *new_line, *nl_found;\n\t    FriBidiChar logical[MAX_STR_LEN];\n\t    char outstring[MAX_STR_LEN];\n\t    FriBidiParType base;\n\t    FriBidiStrIndex len;\n\n\t    nl_found = \"\";\n\t    S_[sizeof (S_) - 1] = 0;\n\t    len = strlen (S_);\n\t    /* chop */\n\t    if (len > 0 && S_[len - 1] == '\\n')\n\t      {\n\t\tlen--;\n\t\tS_[len] = '\\0';\n\t\tnew_line = \"\\n\";\n\t      }\n\t    else\n\t      new_line = \"\";\n\t    /* TODO: handle \\r */\n\n\t    len = fribidi_charset_to_unicode (char_set_num, S_, len, logical);\n\n\t    {\n\t      FriBidiChar *visual;\n\t      FriBidiStrIndex *ltov, *vtol;\n\t      FriBidiLevel *levels;\n\t      fribidi_boolean log2vis;\n\n\t      visual = show_visual ? ALLOCATE (FriBidiChar,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\t      ltov = show_ltov ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      vtol = show_vtol ? ALLOCATE (FriBidiStrIndex,\n\t\t\t\t\t   len + 1\n\t      ) : NULL;\n\t      levels = show_levels ? ALLOCATE (FriBidiLevel,\n\t\t\t\t\t       len + 1\n\t      ) : NULL;\n\n\t      /* Create a bidi string. */\n\t      base = input_base_direction;\n\n\t      log2vis = fribidi_log2vis (logical, len, &base,\n\t\t\t\t\t /* output */\n\t\t\t\t\t visual, ltov, vtol, levels);\n\n\t      if (log2vis)\n\t\t{\n\n\t\t  if (show_input)\n\t\t    printf (\"%-*s => \", padding_width, S_);\n\n\t\t  /* Remove explicit marks, if asked for. */\n\n\t\t  if (do_clean)\n\t\t    len =\n\t\t      fribidi_remove_bidi_marks (visual, len, ltov, vtol,\n\t\t\t\t\t\t levels);\n\n\t\t  if (show_visual)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\n\t\t      if (bol_text)\n\t\t\tprintf (\"%s\", bol_text);\n\n\t\t      /* Convert it to input charset and print. */\n\t\t      {\n\t\t\tFriBidiStrIndex idx, st;\n\t\t\tfor (idx = 0; idx < len;)\n\t\t\t  {\n\t\t\t    FriBidiStrIndex wid, inlen;\n\n\t\t\t    wid = break_width;\n\t\t\t    st = idx;\n\t\t\t    if (char_set_num != FRIBIDI_CHAR_SET_CAP_RTL)\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid -=\n\t\t\t\t    FRIBIDI_IS_EXPLICIT_OR_ISOLATE_OR_BN_OR_NSM\n\t\t\t\t    (fribidi_get_bidi_type (visual[idx])) ? 0\n\t\t\t\t    : 1;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    else\n\t\t\t      while (wid > 0 && idx < len)\n\t\t\t\t{\n\t\t\t\t  wid--;\n\t\t\t\t  idx++;\n\t\t\t\t}\n\t\t\t    if (wid < 0 && idx - st > 1)\n\t\t\t      idx--;\n\t\t\t    inlen = idx - st;\n\n\t\t\t    fribidi_unicode_to_charset (char_set_num,\n\t\t\t\t\t\t\tvisual + st, inlen,\n\t\t\t\t\t\t\toutstring);\n\t\t\t    if (FRIBIDI_IS_RTL (base))\n\t\t\t      printf (\"%*s\",\n\t\t\t\t      (int) (do_pad ? (padding_width +\n\t\t\t\t\t\t       strlen (outstring) -\n\t\t\t\t\t\t       (break_width -\n\t\t\t\t\t\t\twid)) : 0),\n\t\t\t\t      outstring);\n\t\t\t    else\n\t\t\t      printf (\"%s\", outstring);\n\t\t\t    if (idx < len)\n\t\t\t      printf (\"\\n\");\n\t\t\t  }\n\t\t      }\n\t\t      if (eol_text)\n\t\t\tprintf (\"%s\", eol_text);\n\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_basedir)\n\t\t    {\n\t\t      printf (\"%s\", nl_found);\n\t\t      printf (\"Base direction: %s\",\n\t\t\t      (FRIBIDI_DIR_TO_LEVEL (base) ? \"R\" : \"L\"));\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_ltov)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) ltov[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_vtol)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%ld \", (long) vtol[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t  if (show_levels)\n\t\t    {\n\t\t      FriBidiStrIndex i;\n\n\t\t      printf (\"%s\", nl_found);\n\t\t      for (i = 0; i < len; i++)\n\t\t\tprintf (\"%d \", (int) levels[i]);\n\t\t      nl_found = \"\\n\";\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  exit_val = 2;\n\t\t}\n\n\t      if (show_visual)\n\t\tfree (visual);\n\t      if (show_ltov)\n\t\tfree (ltov);\n\t      if (show_vtol)\n\t\tfree (vtol);\n\t      if (show_levels)\n\t\tfree (levels);\n\t    }\n\n\t    if (*nl_found)\n\t      printf (\"%s\", new_line);\n\t  }\n      }\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -203,7 +203,7 @@\n \t    S_[sizeof (S_) - 1] = 0;\n \t    len = strlen (S_);\n \t    /* chop */\n-\t    if (S_[len - 1] == '\\n')\n+\t    if (len > 0 && S_[len - 1] == '\\n')\n \t      {\n \t\tlen--;\n \t\tS_[len] = '\\0';",
        "diff_line_info": {
            "deleted_lines": [
                "\t    if (S_[len - 1] == '\\n')"
            ],
            "added_lines": [
                "\t    if (len > 0 && S_[len - 1] == '\\n')"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3324",
        "func_name": "vim/win_new_width",
        "description": "Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0598.",
        "git_url": "https://github.com/vim/vim/commit/8279af514ca7e5fd3c31cf13b0864163d1a0bfeb",
        "commit_title": "patch 9.0.0598: using negative array index with negative width window",
        "commit_text": " Problem:    Using negative array index with negative width window. Solution:   Make sure the window width does not become negative.",
        "func_before": "void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    // Handled in win_fix_scroll()\n    if (p_spsc)\n    {\n\tinvalidate_botline_win(wp);\n\tif (wp == curwin)\n\t{\n\t    update_topline();\n\t    curs_columns(TRUE);\t// validate w_wrow\n\t}\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n    wp->w_redr_status = TRUE;\n}",
        "func": "void\nwin_new_width(win_T *wp, int width)\n{\n    // Should we give an error if width < 0?\n    wp->w_width = width < 0 ? 0 : width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    // Handled in win_fix_scroll()\n    if (p_spsc)\n    {\n\tinvalidate_botline_win(wp);\n\tif (wp == curwin)\n\t{\n\t    update_topline();\n\t    curs_columns(TRUE);\t// validate w_wrow\n\t}\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n    wp->w_redr_status = TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,8 @@\n void\n win_new_width(win_T *wp, int width)\n {\n-    wp->w_width = width;\n+    // Should we give an error if width < 0?\n+    wp->w_width = width < 0 ? 0 : width;\n     wp->w_lines_valid = 0;\n     changed_line_abv_curs_win(wp);\n     // Handled in win_fix_scroll()",
        "diff_line_info": {
            "deleted_lines": [
                "    wp->w_width = width;"
            ],
            "added_lines": [
                "    // Should we give an error if width < 0?",
                "    wp->w_width = width < 0 ? 0 : width;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3324",
        "func_name": "vim/win_equal_rec",
        "description": "Stack-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0598.",
        "git_url": "https://github.com/vim/vim/commit/8279af514ca7e5fd3c31cf13b0864163d1a0bfeb",
        "commit_title": "patch 9.0.0598: using negative array index with negative width window",
        "commit_text": " Problem:    Using negative array index with negative width window. Solution:   Make sure the window width does not become negative.",
        "func_before": "static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(UPD_NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    if (!frame_fixed_width(fr))\n\t\t\tcontinue;\n\t\t    // If 'winfixwidth' set keep the window width if possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    n = frame_minwidth(fr, NOWIN);\n\t\t    new_size = fr->fr_width;\n\t\t    if (frame_has_win(fr, next_curwin))\n\t\t    {\n\t\t\troom += p_wiw - p_wmw;\n\t\t\tnext_curwin_size = 0;\n\t\t\tif (new_size < p_wiw)\n\t\t\t    new_size = p_wiw;\n\t\t    }\n\t\t    else\n\t\t\t// These windows don't use up room.\n\t\t\ttotwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t       ? extra_sep : 0)) / (p_wmw + 1);\n\t\t    room -= new_size - n;\n\t\t    if (room < 0)\n\t\t    {\n\t\t\tnew_size += room;\n\t\t\troom = 0;\n\t\t    }\n\t\t    fr->fr_newwidth = new_size;\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    if (!frame_fixed_height(fr))\n\t\t\tcontinue;\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    n = frame_minheight(fr, NOWIN);\n\t\t    new_size = fr->fr_height;\n\t\t    if (frame_has_win(fr, next_curwin))\n\t\t    {\n\t\t\troom += p_wh - p_wmh;\n\t\t\tnext_curwin_size = 0;\n\t\t\tif (new_size < p_wh)\n\t\t\t    new_size = p_wh;\n\t\t    }\n\t\t    else\n\t\t\t// These windows don't use up room.\n\t\t\ttotwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t       ? extra_sep : 0)) / (p_wmh + 1);\n\t\t    room -= new_size - n;\n\t\t    if (room < 0)\n\t\t    {\n\t\t\tnew_size += room;\n\t\t\troom = 0;\n\t\t    }\n\t\t    fr->fr_newheight = new_size;\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}",
        "func": "static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(UPD_NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    if (!frame_fixed_width(fr))\n\t\t\tcontinue;\n\t\t    // If 'winfixwidth' set keep the window width if possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    n = frame_minwidth(fr, NOWIN);\n\t\t    new_size = fr->fr_width;\n\t\t    if (frame_has_win(fr, next_curwin))\n\t\t    {\n\t\t\troom += p_wiw - p_wmw;\n\t\t\tnext_curwin_size = 0;\n\t\t\tif (new_size < p_wiw)\n\t\t\t    new_size = p_wiw;\n\t\t    }\n\t\t    else\n\t\t\t// These windows don't use up room.\n\t\t\ttotwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t       ? extra_sep : 0)) / (p_wmw + 1);\n\t\t    room -= new_size - n;\n\t\t    if (room < 0)\n\t\t    {\n\t\t\tnew_size += room;\n\t\t\troom = 0;\n\t\t    }\n\t\t    fr->fr_newwidth = new_size;\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    if (next_curwin_size < 0)\n\t\t\tnext_curwin_size = 0;\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    if (!frame_fixed_height(fr))\n\t\t\tcontinue;\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    n = frame_minheight(fr, NOWIN);\n\t\t    new_size = fr->fr_height;\n\t\t    if (frame_has_win(fr, next_curwin))\n\t\t    {\n\t\t\troom += p_wh - p_wmh;\n\t\t\tnext_curwin_size = 0;\n\t\t\tif (new_size < p_wh)\n\t\t\t    new_size = p_wh;\n\t\t    }\n\t\t    else\n\t\t\t// These windows don't use up room.\n\t\t\ttotwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t       ? extra_sep : 0)) / (p_wmh + 1);\n\t\t    room -= new_size - n;\n\t\t    if (room < 0)\n\t\t    {\n\t\t\tnew_size += room;\n\t\t\troom = 0;\n\t\t    }\n\t\t    fr->fr_newheight = new_size;\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -152,6 +152,8 @@\n \t\tif (hnc)\t    // add next_curwin size\n \t\t{\n \t\t    next_curwin_size -= p_wiw - (m - n);\n+\t\t    if (next_curwin_size < 0)\n+\t\t\tnext_curwin_size = 0;\n \t\t    new_size += next_curwin_size;\n \t\t    room -= new_size - next_curwin_size;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t    if (next_curwin_size < 0)",
                "\t\t\tnext_curwin_size = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24764",
        "func_name": "pjsip/pjproject/print_media_desc",
        "description": "PJSIP is a free and open source multimedia communication library written in C. Versions 2.12 and prior contain a stack buffer overflow vulnerability that affects PJSUA2 users or users that call the API `pjmedia_sdp_print(), pjmedia_sdp_media_print()`. Applications that do not use PJSUA2 and do not directly call `pjmedia_sdp_print()` or `pjmedia_sdp_media_print()` should not be affected. A patch is available on the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.",
        "git_url": "https://github.com/pjsip/pjproject/commit/560a1346f87aabe126509bb24930106dea292b00",
        "commit_title": "Merge pull request from GHSA-f5qg-pqcg-765m",
        "commit_text": "",
        "func_before": "static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\t*p++ = ' ';\n\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\tp += m->desc.fmt[i].slen;\n    }\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}",
        "func": "static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\tif (end-p > m->desc.fmt[i].slen) {\n\t    *p++ = ' ';\n\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\t    p += m->desc.fmt[i].slen;\n\t} else {\n\t    return -1;\n\t}\n    }\n\n    if (end-p >= 2) {\n\t*p++ = '\\r';\n\t*p++ = '\\n';\n    } else {\n\treturn -1;\n    }\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,12 +25,21 @@\n     pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n     p += m->desc.transport.slen;\n     for (i=0; i<m->desc.fmt_count; ++i) {\n-\t*p++ = ' ';\n-\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n-\tp += m->desc.fmt[i].slen;\n+\tif (end-p > m->desc.fmt[i].slen) {\n+\t    *p++ = ' ';\n+\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n+\t    p += m->desc.fmt[i].slen;\n+\t} else {\n+\t    return -1;\n+\t}\n     }\n-    *p++ = '\\r';\n-    *p++ = '\\n';\n+\n+    if (end-p >= 2) {\n+\t*p++ = '\\r';\n+\t*p++ = '\\n';\n+    } else {\n+\treturn -1;\n+    }\n \n     /* print connection info, if present. */\n     if (m->conn) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t*p++ = ' ';",
                "\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);",
                "\tp += m->desc.fmt[i].slen;",
                "    *p++ = '\\r';",
                "    *p++ = '\\n';"
            ],
            "added_lines": [
                "\tif (end-p > m->desc.fmt[i].slen) {",
                "\t    *p++ = ' ';",
                "\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);",
                "\t    p += m->desc.fmt[i].slen;",
                "\t} else {",
                "\t    return -1;",
                "\t}",
                "",
                "    if (end-p >= 2) {",
                "\t*p++ = '\\r';",
                "\t*p++ = '\\n';",
                "    } else {",
                "\treturn -1;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-2630",
        "func_name": "qemu/drop_sync",
        "description": "A stack buffer overflow flaw was found in the Quick Emulator (QEMU) before 2.9 built with the Network Block Device (NBD) client support. The flaw could occur while processing server's response to a 'NBD_OPT_LIST' request. A malicious NBD server could use this issue to crash a remote NBD client resulting in DoS or potentially execute arbitrary code on client host with privileges of the QEMU process.",
        "git_url": "https://github.com/qemu/qemu/commit/2563c9c6b8670400c48e562034b321a7cf3d9a85",
        "commit_title": "nbd/client: fix drop_sync [CVE-2017-2630]",
        "commit_text": " Comparison symbol is misused. It may lead to memory corruption. Introduced in commit 7d3123e.  Message-Id: <20170203154757.36140-6-vsementsov@virtuozzo.com> [eblake: add CVE details, update conditional] Message-Id: <20170307151627.27212-1-eblake@redhat.com>",
        "func_before": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}",
        "func": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n\n    buffer = sizeof(small) >= size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n     char small[1024];\n     char *buffer;\n \n-    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n+    buffer = sizeof(small) >= size ? small : g_malloc(MIN(65536, size));\n     while (size > 0) {\n         ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));"
            ],
            "added_lines": [
                "    buffer = sizeof(small) >= size ? small : g_malloc(MIN(65536, size));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14633",
        "func_name": "kernel/git/mkp/scsi/chap_server_compute_md5",
        "description": "A security flaw was found in the chap_server_compute_md5() function in the ISCSI target code in the Linux kernel in a way an authentication request from an ISCSI initiator is processed. An unauthenticated remote attacker can cause a stack buffer overflow and smash up to 17 bytes of the stack. The attack requires the iSCSI target to be enabled on the victim host. Depending on how the target's code was built (i.e. depending on a compiler, compile flags and hardware architecture) an attack may lead to a system crash and thus to a denial-of-service or possibly to a non-authorized access to data exported by an iSCSI target. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although we believe it is highly unlikely. Kernel versions 4.18.x, 4.14.x and 3.10.x are believed to be vulnerable.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git/commit/?h=4.19/scsi-fixes&h=8c39e2699f8acb2e29782a834e56306da24937fe",
        "commit_title": "",
        "commit_text": "",
        "func_before": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {\n\t\tpr_err(\"Malformed CHAP_C\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "func": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tbin2hex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {\n\t\tpr_err(\"Malformed CHAP_C\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tbin2hex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,7 +124,7 @@\n \t\tgoto out;\n \t}\n \n-\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n+\tbin2hex(response, server_digest, MD5_SIGNATURE_SIZE);\n \tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n \n \tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n@@ -246,7 +246,7 @@\n \t/*\n \t * Convert response from binary hex to ascii hext.\n \t */\n-\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n+\tbin2hex(response, digest, MD5_SIGNATURE_SIZE);\n \t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n \t\t\tresponse);\n \t*nr_out_len += 1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);",
                "\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);"
            ],
            "added_lines": [
                "\tbin2hex(response, server_digest, MD5_SIGNATURE_SIZE);",
                "\tbin2hex(response, digest, MD5_SIGNATURE_SIZE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14633",
        "func_name": "kernel/git/mkp/scsi/chap_gen_challenge",
        "description": "A security flaw was found in the chap_server_compute_md5() function in the ISCSI target code in the Linux kernel in a way an authentication request from an ISCSI initiator is processed. An unauthenticated remote attacker can cause a stack buffer overflow and smash up to 17 bytes of the stack. The attack requires the iSCSI target to be enabled on the victim host. Depending on how the target's code was built (i.e. depending on a compiler, compile flags and hardware architecture) an attack may lead to a system crash and thus to a denial-of-service or possibly to a non-authorized access to data exported by an iSCSI target. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although we believe it is highly unlikely. Kernel versions 4.18.x, 4.14.x and 3.10.x are believed to be vulnerable.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git/commit/?h=4.19/scsi-fixes&h=8c39e2699f8acb2e29782a834e56306da24937fe",
        "commit_title": "",
        "commit_text": "",
        "func_before": "static int chap_gen_challenge(\n\tstruct iscsi_conn *conn,\n\tint caller,\n\tchar *c_str,\n\tunsigned int *c_len)\n{\n\tint ret;\n\tunsigned char challenge_asciihex[CHAP_CHALLENGE_LENGTH * 2 + 1];\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\n\tmemset(challenge_asciihex, 0, CHAP_CHALLENGE_LENGTH * 2 + 1);\n\n\tret = get_random_bytes_wait(chap->challenge, CHAP_CHALLENGE_LENGTH);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tchap_binaryhex_to_asciihex(challenge_asciihex, chap->challenge,\n\t\t\t\tCHAP_CHALLENGE_LENGTH);\n\t/*\n\t * Set CHAP_C, and copy the generated challenge into c_str.\n\t */\n\t*c_len += sprintf(c_str + *c_len, \"CHAP_C=0x%s\", challenge_asciihex);\n\t*c_len += 1;\n\n\tpr_debug(\"[%s] Sending CHAP_C=0x%s\\n\\n\", (caller) ? \"server\" : \"client\",\n\t\t\tchallenge_asciihex);\n\treturn 0;\n}",
        "func": "static int chap_gen_challenge(\n\tstruct iscsi_conn *conn,\n\tint caller,\n\tchar *c_str,\n\tunsigned int *c_len)\n{\n\tint ret;\n\tunsigned char challenge_asciihex[CHAP_CHALLENGE_LENGTH * 2 + 1];\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\n\tmemset(challenge_asciihex, 0, CHAP_CHALLENGE_LENGTH * 2 + 1);\n\n\tret = get_random_bytes_wait(chap->challenge, CHAP_CHALLENGE_LENGTH);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tbin2hex(challenge_asciihex, chap->challenge,\n\t\t\t\tCHAP_CHALLENGE_LENGTH);\n\t/*\n\t * Set CHAP_C, and copy the generated challenge into c_str.\n\t */\n\t*c_len += sprintf(c_str + *c_len, \"CHAP_C=0x%s\", challenge_asciihex);\n\t*c_len += 1;\n\n\tpr_debug(\"[%s] Sending CHAP_C=0x%s\\n\\n\", (caller) ? \"server\" : \"client\",\n\t\t\tchallenge_asciihex);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \tret = get_random_bytes_wait(chap->challenge, CHAP_CHALLENGE_LENGTH);\n \tif (unlikely(ret))\n \t\treturn ret;\n-\tchap_binaryhex_to_asciihex(challenge_asciihex, chap->challenge,\n+\tbin2hex(challenge_asciihex, chap->challenge,\n \t\t\t\tCHAP_CHALLENGE_LENGTH);\n \t/*\n \t * Set CHAP_C, and copy the generated challenge into c_str.",
        "diff_line_info": {
            "deleted_lines": [
                "\tchap_binaryhex_to_asciihex(challenge_asciihex, chap->challenge,"
            ],
            "added_lines": [
                "\tbin2hex(challenge_asciihex, chap->challenge,"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14633",
        "func_name": "kernel/git/mkp/scsi/chap_server_compute_md5",
        "description": "A security flaw was found in the chap_server_compute_md5() function in the ISCSI target code in the Linux kernel in a way an authentication request from an ISCSI initiator is processed. An unauthenticated remote attacker can cause a stack buffer overflow and smash up to 17 bytes of the stack. The attack requires the iSCSI target to be enabled on the victim host. Depending on how the target's code was built (i.e. depending on a compiler, compile flags and hardware architecture) an attack may lead to a system crash and thus to a denial-of-service or possibly to a non-authorized access to data exported by an iSCSI target. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although we believe it is highly unlikely. Kernel versions 4.18.x, 4.14.x and 3.10.x are believed to be vulnerable.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git/commit/?h=4.19/scsi-fixes&h=1816494330a83f2a064499d8ed2797045641f92c",
        "commit_title": "This change has the following effects, in order of descreasing importance:",
        "commit_text": " 1) Prevent a stack buffer overflow  2) Do not append an unnecessary NULL to an anyway binary buffer, which    is writing one byte past client_digest when caller is:    chap_string_to_hex(client_digest, chap_r, strlen(chap_r));  The latter was found by KASAN (see below) when input value hes expected size (32 hex chars), and further analysis revealed a stack buffer overflow can happen when network-received value is longer, allowing an unauthenticated remote attacker to smash up to 17 bytes after destination buffer (16 bytes attacker-controlled and one null).  As switching to hex2bin requires specifying destination buffer length, and does not internally append any null, it solves both issues.  This addresses CVE-2018-14633.  Beyond this:  - Validate received value length and check hex2bin accepted the input, to log   this rejection reason instead of just failing authentication.  - Only log received CHAP_R and CHAP_C values once they passed sanity checks.  ================================================================== BUG: KASAN: stack-out-of-bounds in chap_string_to_hex+0x32/0x60 [iscsi_target_mod] Write of size 1 at addr ffff8801090ef7c8 by task kworker/0:0/1021  CPU: 0 PID: 1021 Comm: kworker/0:0 Tainted: G           O      4.17.8kasan.sess.connops+ #2 Hardware name: To be filled by O.E.M. To be filled by O.E.M./Aptio CRB, BIOS 5.6.5 05/19/2014 Workqueue: events iscsi_target_do_login_rx [iscsi_target_mod] Call Trace:  dump_stack+0x71/0xac  print_address_description+0x65/0x22e  ? chap_string_to_hex+0x32/0x60 [iscsi_target_mod]  kasan_report.cold.6+0x241/0x2fd  chap_string_to_hex+0x32/0x60 [iscsi_target_mod]  chap_server_compute_md5.isra.2+0x2cb/0x860 [iscsi_target_mod]  ? chap_binaryhex_to_asciihex.constprop.5+0x50/0x50 [iscsi_target_mod]  ? ftrace_caller_op_ptr+0xe/0xe  ? __orc_find+0x6f/0xc0  ? unwind_next_frame+0x231/0x850  ? kthread+0x1a0/0x1c0  ? ret_from_fork+0x35/0x40  ? ret_from_fork+0x35/0x40  ? iscsi_target_do_login_rx+0x3bc/0x4c0 [iscsi_target_mod]  ? deref_stack_reg+0xd0/0xd0  ? iscsi_target_do_login_rx+0x3bc/0x4c0 [iscsi_target_mod]  ? is_module_text_address+0xa/0x11  ? kernel_text_address+0x4c/0x110  ? __save_stack_trace+0x82/0x100  ? ret_from_fork+0x35/0x40  ? save_stack+0x8c/0xb0  ? 0xffffffffc1660000  ? iscsi_target_do_login+0x155/0x8d0 [iscsi_target_mod]  ? iscsi_target_do_login_rx+0x3bc/0x4c0 [iscsi_target_mod]  ? process_one_work+0x35c/0x640  ? worker_thread+0x66/0x5d0  ? kthread+0x1a0/0x1c0  ? ret_from_fork+0x35/0x40  ? iscsi_update_param_value+0x80/0x80 [iscsi_target_mod]  ? iscsit_release_cmd+0x170/0x170 [iscsi_target_mod]  chap_main_loop+0x172/0x570 [iscsi_target_mod]  ? chap_server_compute_md5.isra.2+0x860/0x860 [iscsi_target_mod]  ? rx_data+0xd6/0x120 [iscsi_target_mod]  ? iscsit_print_session_params+0xd0/0xd0 [iscsi_target_mod]  ? cyc2ns_read_begin.part.2+0x90/0x90  ? _raw_spin_lock_irqsave+0x25/0x50  ? memcmp+0x45/0x70  iscsi_target_do_login+0x875/0x8d0 [iscsi_target_mod]  ? iscsi_target_check_first_request.isra.5+0x1a0/0x1a0 [iscsi_target_mod]  ? del_timer+0xe0/0xe0  ? memset+0x1f/0x40  ? flush_sigqueue+0x29/0xd0  iscsi_target_do_login_rx+0x3bc/0x4c0 [iscsi_target_mod]  ? iscsi_target_nego_release+0x80/0x80 [iscsi_target_mod]  ? iscsi_target_restore_sock_callbacks+0x130/0x130 [iscsi_target_mod]  process_one_work+0x35c/0x640  worker_thread+0x66/0x5d0  ? flush_rcu_work+0x40/0x40  kthread+0x1a0/0x1c0  ? kthread_bind+0x30/0x30  ret_from_fork+0x35/0x40  The buggy address belongs to the page: page:ffffea0004243bc0 count:0 mapcount:0 mapping:0000000000000000 index:0x0 flags: 0x17fffc000000000() raw: 017fffc000000000 0000000000000000 0000000000000000 00000000ffffffff raw: ffffea0004243c20 ffffea0004243ba0 0000000000000000 0000000000000000 page dumped because: kasan: bad access detected  Memory state around the buggy address:  ffff8801090ef680: f2 f2 f2 f2 f2 f2 f2 01 f2 f2 f2 f2 f2 f2 f2 00  ffff8801090ef700: f2 f2 f2 f2 f2 f2 f2 00 02 f2 f2 f2 f2 f2 f2 00 >ffff8801090ef780: 00 f2 f2 f2 f2 f2 f2 00 00 f2 f2 f2 f2 f2 f2 00                                               ^  ffff8801090ef800: 00 f2 f2 f2 f2 f2 f2 00 00 00 00 02 f2 f2 f2 f2  ffff8801090ef880: f2 f2 f2 00 00 00 00 00 00 00 00 f2 f2 f2 f2 00 ==================================================================  ",
        "func_before": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\tchap_string_to_hex(client_digest, chap_r, strlen(chap_r));\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\tchallenge_len = chap_string_to_hex(challenge_binhex, challenge,\n\t\t\t\tstrlen(challenge));\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "func": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {\n\t\tpr_err(\"Malformed CHAP_C\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,9 +71,16 @@\n \t\tpr_err(\"Could not find CHAP_R.\\n\");\n \t\tgoto out;\n \t}\n+\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {\n+\t\tpr_err(\"Malformed CHAP_R\\n\");\n+\t\tgoto out;\n+\t}\n+\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {\n+\t\tpr_err(\"Malformed CHAP_R\\n\");\n+\t\tgoto out;\n+\t}\n \n \tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n-\tchap_string_to_hex(client_digest, chap_r, strlen(chap_r));\n \n \ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n \tif (IS_ERR(tfm)) {\n@@ -172,9 +179,7 @@\n \t\tpr_err(\"Could not find CHAP_C.\\n\");\n \t\tgoto out;\n \t}\n-\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n-\tchallenge_len = chap_string_to_hex(challenge_binhex, challenge,\n-\t\t\t\tstrlen(challenge));\n+\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);\n \tif (!challenge_len) {\n \t\tpr_err(\"Unable to convert incoming challenge\\n\");\n \t\tgoto out;\n@@ -183,6 +188,11 @@\n \t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n \t\tgoto out;\n \t}\n+\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {\n+\t\tpr_err(\"Malformed CHAP_C\\n\");\n+\t\tgoto out;\n+\t}\n+\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n \t/*\n \t * During mutual authentication, the CHAP_C generated by the\n \t * initiator must not match the original CHAP_C generated by",
        "diff_line_info": {
            "deleted_lines": [
                "\tchap_string_to_hex(client_digest, chap_r, strlen(chap_r));",
                "\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);",
                "\tchallenge_len = chap_string_to_hex(challenge_binhex, challenge,",
                "\t\t\t\tstrlen(challenge));"
            ],
            "added_lines": [
                "\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {",
                "\t\tpr_err(\"Malformed CHAP_R\\n\");",
                "\t\tgoto out;",
                "\t}",
                "\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {",
                "\t\tpr_err(\"Malformed CHAP_R\\n\");",
                "\t\tgoto out;",
                "\t}",
                "\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);",
                "\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {",
                "\t\tpr_err(\"Malformed CHAP_C\\n\");",
                "\t\tgoto out;",
                "\t}",
                "\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-27590",
        "func_name": "rizinorg/rizin/__io_maps",
        "description": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. In version 0.5.1 and prior, converting a GDB registers profile file into a Rizin register profile can result in a stack-based buffer overflow when the `name`, `type`, or `groups` fields have longer values than expected. Users opening untrusted GDB registers files (e.g. with the `drpg` or `arpg` commands) are affected by this flaw. Commit d6196703d89c84467b600ba2692534579dc25ed4 contains a patch for this issue. As a workaround, review the GDB register profiles before loading them with `drpg`/`arpg` commands.",
        "git_url": "https://github.com/rizinorg/rizin/commit/d6196703d89c84467b600ba2692534579dc25ed4",
        "commit_title": "Fix conversion from GDB register profile to rizin profile",
        "commit_text": "",
        "func_before": "static RzList /*<RzDebugMap *>*/ *__io_maps(RzDebug *dbg) {\n\tRzList *list = rz_list_new();\n\tchar *str = dbg->iob.system(dbg->iob.io, \"dm\");\n\tif (!str) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\tchar *ostr = str;\n\tut64 map_start, map_end;\n\tchar perm[32];\n\tchar name[512];\n\tfor (;;) {\n\t\tchar *nl = strchr(str, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\t*name = 0;\n\t\t\t*perm = 0;\n\t\t\tmap_start = map_end = 0LL;\n\t\t\tif (!strncmp(str, \"sys \", 4)) {\n\t\t\t\tchar *sp = strchr(str + 4, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\tstr = sp + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *_s_ = strstr(str, \" s \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\t_s_ = strstr(str, \" ? \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %s %s\",\n\t\t\t\t&map_start, &map_end, perm, name);\n\t\t\tif (map_end != 0LL) {\n\t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0);\n\t\t\t\trz_list_append(list, map);\n\t\t\t}\n\t\t\tstr = nl + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(ostr);\n\trz_cons_reset();\n\treturn list;\n}",
        "func": "static RzList /*<RzDebugMap *>*/ *__io_maps(RzDebug *dbg) {\n\tRzList *list = rz_list_new();\n\tchar *str = dbg->iob.system(dbg->iob.io, \"dm\");\n\tif (!str) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\tchar *ostr = str;\n\tut64 map_start, map_end;\n\tchar perm[IO_MAPS_PERM_SZ + 1];\n\tchar name[IO_MAPS_NAME_SZ + 1];\n\tfor (;;) {\n\t\tchar *nl = strchr(str, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\t*name = 0;\n\t\t\t*perm = 0;\n\t\t\tmap_start = map_end = 0LL;\n\t\t\tif (!strncmp(str, \"sys \", 4)) {\n\t\t\t\tchar *sp = strchr(str + 4, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\tstr = sp + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *_s_ = strstr(str, \" s \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\t_s_ = strstr(str, \" ? \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %\" RZ_STR_DEF(IO_MAPS_PERM_SZ) \"s %\" RZ_STR_DEF(IO_MAPS_NAME_SZ) \"s\",\n\t\t\t\t&map_start, &map_end, perm, name);\n\t\t\tif (map_end != 0LL) {\n\t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0);\n\t\t\t\trz_list_append(list, map);\n\t\t\t}\n\t\t\tstr = nl + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(ostr);\n\trz_cons_reset();\n\treturn list;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,8 @@\n \t}\n \tchar *ostr = str;\n \tut64 map_start, map_end;\n-\tchar perm[32];\n-\tchar name[512];\n+\tchar perm[IO_MAPS_PERM_SZ + 1];\n+\tchar name[IO_MAPS_NAME_SZ + 1];\n \tfor (;;) {\n \t\tchar *nl = strchr(str, '\\n');\n \t\tif (nl) {\n@@ -32,7 +32,7 @@\n \t\t\tif (_s_) {\n \t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n \t\t\t}\n-\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %s %s\",\n+\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %\" RZ_STR_DEF(IO_MAPS_PERM_SZ) \"s %\" RZ_STR_DEF(IO_MAPS_NAME_SZ) \"s\",\n \t\t\t\t&map_start, &map_end, perm, name);\n \t\t\tif (map_end != 0LL) {\n \t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0);",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar perm[32];",
                "\tchar name[512];",
                "\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %s %s\","
            ],
            "added_lines": [
                "\tchar perm[IO_MAPS_PERM_SZ + 1];",
                "\tchar name[IO_MAPS_NAME_SZ + 1];",
                "\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %\" RZ_STR_DEF(IO_MAPS_PERM_SZ) \"s %\" RZ_STR_DEF(IO_MAPS_NAME_SZ) \"s\","
            ]
        }
    },
    {
        "cve_id": "CVE-2023-27590",
        "func_name": "rizinorg/rizin/gdb_to_rz_profile",
        "description": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. In version 0.5.1 and prior, converting a GDB registers profile file into a Rizin register profile can result in a stack-based buffer overflow when the `name`, `type`, or `groups` fields have longer values than expected. Users opening untrusted GDB registers files (e.g. with the `drpg` or `arpg` commands) are affected by this flaw. Commit d6196703d89c84467b600ba2692534579dc25ed4 contains a patch for this issue. As a workaround, review the GDB register profiles before loading them with `drpg`/`arpg` commands.",
        "git_url": "https://github.com/rizinorg/rizin/commit/d6196703d89c84467b600ba2692534579dc25ed4",
        "commit_title": "Fix conversion from GDB register profile to rizin profile",
        "commit_text": "",
        "func_before": "static char *gdb_to_rz_profile(const char *gdb) {\n\trz_return_val_if_fail(gdb, NULL);\n\tRzStrBuf *sb = rz_strbuf_new(\"\");\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\tchar *ptr1, *gptr, *gptr1;\n\tchar name[16], groups[128], type[16];\n\tconst int all = 1, gpr = 2, save = 4, restore = 8, float_ = 16,\n\t\t  sse = 32, vector = 64, system = 128, mmx = 256;\n\tint number, rel, offset, size, type_bits, ret;\n\t// Every line is -\n\t// Name Number Rel Offset Size Type Groups\n\tconst char *ptr = rz_str_trim_head_ro(gdb);\n\n\t// It's possible someone includes the heading line too. Skip it\n\tif (rz_str_startswith(ptr, \"Name\")) {\n\t\tif (!(ptr = strchr(ptr, '\\n'))) {\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr++;\n\t}\n\tfor (;;) {\n\t\t// Skip whitespace at beginning of line and empty lines\n\t\twhile (isspace((ut8)*ptr)) {\n\t\t\tptr++;\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ptr1 = strchr(ptr, '\\n'))) {\n\t\t\t*ptr1 = '\\0';\n\t\t} else {\n\t\t\teprintf(\"Could not parse line: %s (missing \\\\n)\\n\", ptr);\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn false;\n\t\t}\n\t\tret = sscanf(ptr, \" %s %d %d %d %d %s %s\", name, &number, &rel,\n\t\t\t&offset, &size, type, groups);\n\t\t// Groups is optional, others not\n\t\tif (ret < 6) {\n\t\t\tif (*ptr != '*') {\n\t\t\t\teprintf(\"Could not parse line: %s\\n\", ptr);\n\t\t\t\trz_strbuf_free(sb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If name is '', then skip\n\t\tif (rz_str_startswith(name, \"''\")) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If size is 0, skip\n\t\tif (size == 0) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\ttype_bits = 0;\n\t\t// Parse group\n\t\tif (ret >= 7) {\n\t\t\tgptr = groups;\n\t\t\twhile (1) {\n\t\t\t\tif ((gptr1 = strchr(gptr, ','))) {\n\t\t\t\t\t*gptr1 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (rz_str_startswith(gptr, \"general\")) {\n\t\t\t\t\ttype_bits |= gpr;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"all\")) {\n\t\t\t\t\ttype_bits |= all;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"save\")) {\n\t\t\t\t\ttype_bits |= save;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"restore\")) {\n\t\t\t\t\ttype_bits |= restore;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"float\")) {\n\t\t\t\t\ttype_bits |= float_;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"sse\")) {\n\t\t\t\t\ttype_bits |= sse;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"mmx\")) {\n\t\t\t\t\ttype_bits |= mmx;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"vector\")) {\n\t\t\t\t\ttype_bits |= vector;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"system\")) {\n\t\t\t\t\ttype_bits |= system;\n\t\t\t\t}\n\t\t\t\tif (!gptr1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgptr = gptr1 + 1;\n\t\t\t}\n\t\t}\n\t\t// If type is not defined, skip\n\t\tif (!*type) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: More mappings between gdb and rizin reg groups. For now, either fpu or gpr\n\t\tif (!(type_bits & sse) && !(type_bits & float_)) {\n\t\t\ttype_bits |= gpr;\n\t\t}\n\t\t// Print line\n\t\trz_strbuf_appendf(sb, \"%s\\t%s\\t.%d\\t%d\\t0\\n\",\n\t\t\t// Ref: Comment above about more register type mappings\n\t\t\t((type_bits & mmx) || (type_bits & float_) || (type_bits & sse)) ? \"fpu\" : \"gpr\",\n\t\t\tname, size * 8, offset);\n\t\t// Go to next line\n\t\tif (!ptr1) {\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr1 + 1;\n\t\tcontinue;\n\t}\n\treturn rz_strbuf_drain(sb);\n}",
        "func": "static char *gdb_to_rz_profile(const char *gdb) {\n\trz_return_val_if_fail(gdb, NULL);\n\tRzStrBuf *sb = rz_strbuf_new(\"\");\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\tchar *ptr1, *gptr, *gptr1;\n\tchar name[GDB_NAME_SZ + 1], groups[GDB_GROUPS_SZ + 1], type[GDB_TYPE_SZ + 1];\n\tconst int all = 1, gpr = 2, save = 4, restore = 8, float_ = 16,\n\t\t  sse = 32, vector = 64, system = 128, mmx = 256;\n\tint number, rel, offset, size, type_bits, ret;\n\t// Every line is -\n\t// Name Number Rel Offset Size Type Groups\n\tconst char *ptr = rz_str_trim_head_ro(gdb);\n\n\t// It's possible someone includes the heading line too. Skip it\n\tif (rz_str_startswith(ptr, \"Name\")) {\n\t\tif (!(ptr = strchr(ptr, '\\n'))) {\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn NULL;\n\t\t}\n\t\tptr++;\n\t}\n\tfor (;;) {\n\t\t// Skip whitespace at beginning of line and empty lines\n\t\twhile (isspace((ut8)*ptr)) {\n\t\t\tptr++;\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ptr1 = strchr(ptr, '\\n'))) {\n\t\t\t*ptr1 = '\\0';\n\t\t} else {\n\t\t\teprintf(\"Could not parse line: %s (missing \\\\n)\\n\", ptr);\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn false;\n\t\t}\n\t\tret = sscanf(ptr, \" %\" RZ_STR_DEF(GDB_NAME_SZ) \"s %d %d %d %d %\" RZ_STR_DEF(GDB_TYPE_SZ) \"s %\" RZ_STR_DEF(GDB_GROUPS_SZ) \"s\",\n\t\t\tname, &number, &rel, &offset, &size, type, groups);\n\t\t// Groups is optional, others not\n\t\tif (ret < 6) {\n\t\t\tif (*ptr != '*') {\n\t\t\t\teprintf(\"Could not parse line: %s\\n\", ptr);\n\t\t\t\trz_strbuf_free(sb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If name is '', then skip\n\t\tif (rz_str_startswith(name, \"''\")) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// If size is 0, skip\n\t\tif (size == 0) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\ttype_bits = 0;\n\t\t// Parse group\n\t\tif (ret >= 7) {\n\t\t\tgptr = groups;\n\t\t\twhile (1) {\n\t\t\t\tif ((gptr1 = strchr(gptr, ','))) {\n\t\t\t\t\t*gptr1 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (rz_str_startswith(gptr, \"general\")) {\n\t\t\t\t\ttype_bits |= gpr;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"all\")) {\n\t\t\t\t\ttype_bits |= all;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"save\")) {\n\t\t\t\t\ttype_bits |= save;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"restore\")) {\n\t\t\t\t\ttype_bits |= restore;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"float\")) {\n\t\t\t\t\ttype_bits |= float_;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"sse\")) {\n\t\t\t\t\ttype_bits |= sse;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"mmx\")) {\n\t\t\t\t\ttype_bits |= mmx;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"vector\")) {\n\t\t\t\t\ttype_bits |= vector;\n\t\t\t\t} else if (rz_str_startswith(gptr, \"system\")) {\n\t\t\t\t\ttype_bits |= system;\n\t\t\t\t}\n\t\t\t\tif (!gptr1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgptr = gptr1 + 1;\n\t\t\t}\n\t\t}\n\t\t// If type is not defined, skip\n\t\tif (!*type) {\n\t\t\tif (!ptr1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr = ptr1 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: More mappings between gdb and rizin reg groups. For now, either fpu or gpr\n\t\tif (!(type_bits & sse) && !(type_bits & float_)) {\n\t\t\ttype_bits |= gpr;\n\t\t}\n\t\t// Print line\n\t\trz_strbuf_appendf(sb, \"%s\\t%s\\t.%d\\t%d\\t0\\n\",\n\t\t\t// Ref: Comment above about more register type mappings\n\t\t\t((type_bits & mmx) || (type_bits & float_) || (type_bits & sse)) ? \"fpu\" : \"gpr\",\n\t\t\tname, size * 8, offset);\n\t\t// Go to next line\n\t\tif (!ptr1) {\n\t\t\tbreak;\n\t\t}\n\t\tptr = ptr1 + 1;\n\t\tcontinue;\n\t}\n\treturn rz_strbuf_drain(sb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \t\treturn NULL;\n \t}\n \tchar *ptr1, *gptr, *gptr1;\n-\tchar name[16], groups[128], type[16];\n+\tchar name[GDB_NAME_SZ + 1], groups[GDB_GROUPS_SZ + 1], type[GDB_TYPE_SZ + 1];\n \tconst int all = 1, gpr = 2, save = 4, restore = 8, float_ = 16,\n \t\t  sse = 32, vector = 64, system = 128, mmx = 256;\n \tint number, rel, offset, size, type_bits, ret;\n@@ -36,8 +36,8 @@\n \t\t\trz_strbuf_free(sb);\n \t\t\treturn false;\n \t\t}\n-\t\tret = sscanf(ptr, \" %s %d %d %d %d %s %s\", name, &number, &rel,\n-\t\t\t&offset, &size, type, groups);\n+\t\tret = sscanf(ptr, \" %\" RZ_STR_DEF(GDB_NAME_SZ) \"s %d %d %d %d %\" RZ_STR_DEF(GDB_TYPE_SZ) \"s %\" RZ_STR_DEF(GDB_GROUPS_SZ) \"s\",\n+\t\t\tname, &number, &rel, &offset, &size, type, groups);\n \t\t// Groups is optional, others not\n \t\tif (ret < 6) {\n \t\t\tif (*ptr != '*') {",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar name[16], groups[128], type[16];",
                "\t\tret = sscanf(ptr, \" %s %d %d %d %d %s %s\", name, &number, &rel,",
                "\t\t\t&offset, &size, type, groups);"
            ],
            "added_lines": [
                "\tchar name[GDB_NAME_SZ + 1], groups[GDB_GROUPS_SZ + 1], type[GDB_TYPE_SZ + 1];",
                "\t\tret = sscanf(ptr, \" %\" RZ_STR_DEF(GDB_NAME_SZ) \"s %d %d %d %d %\" RZ_STR_DEF(GDB_TYPE_SZ) \"s %\" RZ_STR_DEF(GDB_GROUPS_SZ) \"s\",",
                "\t\t\tname, &number, &rel, &offset, &size, type, groups);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-27590",
        "func_name": "rizinorg/rizin/rz_debug_gdb_map_get",
        "description": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. In version 0.5.1 and prior, converting a GDB registers profile file into a Rizin register profile can result in a stack-based buffer overflow when the `name`, `type`, or `groups` fields have longer values than expected. Users opening untrusted GDB registers files (e.g. with the `drpg` or `arpg` commands) are affected by this flaw. Commit d6196703d89c84467b600ba2692534579dc25ed4 contains a patch for this issue. As a workaround, review the GDB register profiles before loading them with `drpg`/`arpg` commands.",
        "git_url": "https://github.com/rizinorg/rizin/commit/d6196703d89c84467b600ba2692534579dc25ed4",
        "commit_title": "Fix conversion from GDB register profile to rizin profile",
        "commit_text": "",
        "func_before": "static RzList /*<RzDebugMap *>*/ *rz_debug_gdb_map_get(RzDebug *dbg) { // TODO\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc || ctx->desc->pid <= 0) {\n\t\treturn NULL;\n\t}\n\tRzList *retlist = NULL;\n\tif (ctx->desc->get_baddr) {\n\t\tctx->desc->get_baddr = false;\n\t\tut64 baddr;\n\t\tif ((baddr = gdbr_get_baddr(ctx->desc)) != UINT64_MAX) {\n\t\t\tif (!(retlist = rz_list_new())) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRzDebugMap *map;\n\t\t\tif (!(map = rz_debug_map_new(\"\", baddr, baddr, RZ_PERM_RX, 0))) {\n\t\t\t\trz_list_free(retlist);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trz_list_append(retlist, map);\n\t\t\treturn retlist;\n\t\t}\n\t}\n\n\t// Get file from GDB\n\tchar path[128];\n\tut8 *buf;\n\tint ret;\n\t// TODO don't hardcode buffer size, get from remote target\n\t// (I think gdb doesn't do that, it just keeps reading till EOF)\n\t// fstat info can get file size, but it doesn't work for /proc/pid/maps\n\tut64 buflen = 16384;\n\t// If /proc/%d/maps is not valid for gdbserver, we return NULL, as of now\n\tsnprintf(path, sizeof(path) - 1, \"/proc/%d/maps\", ctx->desc->pid);\n\n#ifdef _MSC_VER\n#define GDB_FILE_OPEN_MODE (_S_IREAD | _S_IWRITE)\n#else\n#define GDB_FILE_OPEN_MODE (S_IRUSR | S_IWUSR | S_IXUSR)\n#endif\n\n\tif (gdbr_open_file(ctx->desc, path, O_RDONLY, GDB_FILE_OPEN_MODE) < 0) {\n\t\treturn NULL;\n\t}\n\tif (!(buf = malloc(buflen))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\treturn NULL;\n\t}\n\tif ((ret = gdbr_read_file(ctx->desc, buf, buflen - 1)) <= 0) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tbuf[ret] = '\\0';\n\n\t// Get map list\n\tint unk = 0, perm, i;\n\tchar *ptr, *pos_1;\n\tsize_t line_len;\n\tchar name[1024], region1[100], region2[100], perms[5];\n\tRzDebugMap *map = NULL;\n\tregion1[0] = region2[0] = '0';\n\tregion1[1] = region2[1] = 'x';\n\tif (!(ptr = strtok((char *)buf, \"\\n\"))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (!(retlist = rz_list_new())) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\twhile (ptr) {\n\t\tut64 map_start, map_end, offset;\n\t\tbool map_is_shared = false;\n\t\tline_len = strlen(ptr);\n\t\t// maps files should not have empty lines\n\t\tif (line_len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// We assume Linux target, for now, so -\n\t\t// 7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 265428 /usr/lib/ld-2.25.so\n\t\tret = sscanf(ptr, \"%s %s %\" PFMT64x \" %*s %*s %[^\\n]\", &region1[2],\n\t\t\tperms, &offset, name);\n\t\tif (ret == 3) {\n\t\t\tname[0] = '\\0';\n\t\t} else if (ret != 4) {\n\t\t\teprintf(\"%s: Unable to parse \\\"%s\\\"\\nContent:\\n%s\\n\",\n\t\t\t\t__func__, path, buf);\n\t\t\tgdbr_close_file(ctx->desc);\n\t\t\tfree(buf);\n\t\t\trz_list_free(retlist);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(pos_1 = strchr(&region1[2], '-'))) {\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tstrncpy(&region2[2], pos_1 + 1, sizeof(region2) - 2 - 1);\n\t\tif (!*name) {\n\t\t\tsnprintf(name, sizeof(name), \"unk%d\", unk++);\n\t\t}\n\t\tperm = 0;\n\t\tfor (i = 0; i < 5 && perms[i]; i++) {\n\t\t\tswitch (perms[i]) {\n\t\t\tcase 'r': perm |= RZ_PERM_R; break;\n\t\t\tcase 'w': perm |= RZ_PERM_W; break;\n\t\t\tcase 'x': perm |= RZ_PERM_X; break;\n\t\t\tcase 'p': map_is_shared = false; break;\n\t\t\tcase 's': map_is_shared = true; break;\n\t\t\t}\n\t\t}\n\t\tmap_start = rz_num_get(NULL, region1);\n\t\tmap_end = rz_num_get(NULL, region2);\n\t\tif (map_start == map_end || map_end == 0) {\n\t\t\teprintf(\"%s: ignoring invalid map size: %s - %s\\n\",\n\t\t\t\t__func__, region1, region2);\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(map = rz_debug_map_new(name, map_start, map_end, perm, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tmap->offset = offset;\n\t\tmap->shared = map_is_shared;\n\t\tmap->file = strdup(name);\n\t\trz_list_append(retlist, map);\n\t\tptr = strtok(NULL, \"\\n\");\n\t}\n\tgdbr_close_file(ctx->desc);\n\tfree(buf);\n\treturn retlist;\n}",
        "func": "static RzList /*<RzDebugMap *>*/ *rz_debug_gdb_map_get(RzDebug *dbg) { // TODO\n\tRzDebugGdbCtx *ctx = dbg->plugin_data;\n\tcheck_connection(dbg);\n\tif (!ctx->desc || ctx->desc->pid <= 0) {\n\t\treturn NULL;\n\t}\n\tRzList *retlist = NULL;\n\tif (ctx->desc->get_baddr) {\n\t\tctx->desc->get_baddr = false;\n\t\tut64 baddr;\n\t\tif ((baddr = gdbr_get_baddr(ctx->desc)) != UINT64_MAX) {\n\t\t\tif (!(retlist = rz_list_new())) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tRzDebugMap *map;\n\t\t\tif (!(map = rz_debug_map_new(\"\", baddr, baddr, RZ_PERM_RX, 0))) {\n\t\t\t\trz_list_free(retlist);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trz_list_append(retlist, map);\n\t\t\treturn retlist;\n\t\t}\n\t}\n\n\t// Get file from GDB\n\tchar path[128];\n\tut8 *buf;\n\tint ret;\n\t// TODO don't hardcode buffer size, get from remote target\n\t// (I think gdb doesn't do that, it just keeps reading till EOF)\n\t// fstat info can get file size, but it doesn't work for /proc/pid/maps\n\tut64 buflen = 16384;\n\t// If /proc/%d/maps is not valid for gdbserver, we return NULL, as of now\n\tsnprintf(path, sizeof(path) - 1, \"/proc/%d/maps\", ctx->desc->pid);\n\n#ifdef _MSC_VER\n#define GDB_FILE_OPEN_MODE (_S_IREAD | _S_IWRITE)\n#else\n#define GDB_FILE_OPEN_MODE (S_IRUSR | S_IWUSR | S_IXUSR)\n#endif\n\n\tif (gdbr_open_file(ctx->desc, path, O_RDONLY, GDB_FILE_OPEN_MODE) < 0) {\n\t\treturn NULL;\n\t}\n\tif (!(buf = malloc(buflen))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\treturn NULL;\n\t}\n\tif ((ret = gdbr_read_file(ctx->desc, buf, buflen - 1)) <= 0) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tbuf[ret] = '\\0';\n\n\t// Get map list\n\tint unk = 0, perm, i;\n\tchar *ptr, *pos_1;\n\tsize_t line_len;\n\tchar name[PROC_NAME_SZ + 1], region1[PROC_REGION_SZ + 1], region2[PROC_REGION_SZ + 1], perms[PROC_PERM_SZ + 1];\n\tRzDebugMap *map = NULL;\n\tregion1[0] = region2[0] = '0';\n\tregion1[1] = region2[1] = 'x';\n\tif (!(ptr = strtok((char *)buf, \"\\n\"))) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tif (!(retlist = rz_list_new())) {\n\t\tgdbr_close_file(ctx->desc);\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\twhile (ptr) {\n\t\tut64 map_start, map_end, offset;\n\t\tbool map_is_shared = false;\n\t\tline_len = strlen(ptr);\n\t\t// maps files should not have empty lines\n\t\tif (line_len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// We assume Linux target, for now, so -\n\t\t// 7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 265428 /usr/lib/ld-2.25.so\n\t\tret = sscanf(ptr, \"%\" RZ_STR_DEF(PROC_REGION_LEFT_SZ) \"s %\" RZ_STR_DEF(PROC_PERM_SZ) \"s %\" PFMT64x \" %*s %*s %\" RZ_STR_DEF(PROC_NAME_SZ) \"[^\\n]\",\n\t\t\t&region1[2], perms, &offset, name);\n\t\tif (ret == 3) {\n\t\t\tname[0] = '\\0';\n\t\t} else if (ret != 4) {\n\t\t\teprintf(\"%s: Unable to parse \\\"%s\\\"\\nContent:\\n%s\\n\",\n\t\t\t\t__func__, path, buf);\n\t\t\tgdbr_close_file(ctx->desc);\n\t\t\tfree(buf);\n\t\t\trz_list_free(retlist);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(pos_1 = strchr(&region1[2], '-'))) {\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tstrncpy(&region2[2], pos_1 + 1, sizeof(region2) - 2 - 1);\n\t\tif (!*name) {\n\t\t\tsnprintf(name, sizeof(name), \"unk%d\", unk++);\n\t\t}\n\t\tperm = 0;\n\t\tfor (i = 0; i < 5 && perms[i]; i++) {\n\t\t\tswitch (perms[i]) {\n\t\t\tcase 'r': perm |= RZ_PERM_R; break;\n\t\t\tcase 'w': perm |= RZ_PERM_W; break;\n\t\t\tcase 'x': perm |= RZ_PERM_X; break;\n\t\t\tcase 'p': map_is_shared = false; break;\n\t\t\tcase 's': map_is_shared = true; break;\n\t\t\t}\n\t\t}\n\t\tmap_start = rz_num_get(NULL, region1);\n\t\tmap_end = rz_num_get(NULL, region2);\n\t\tif (map_start == map_end || map_end == 0) {\n\t\t\teprintf(\"%s: ignoring invalid map size: %s - %s\\n\",\n\t\t\t\t__func__, region1, region2);\n\t\t\tptr = strtok(NULL, \"\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(map = rz_debug_map_new(name, map_start, map_end, perm, 0))) {\n\t\t\tbreak;\n\t\t}\n\t\tmap->offset = offset;\n\t\tmap->shared = map_is_shared;\n\t\tmap->file = strdup(name);\n\t\trz_list_append(retlist, map);\n\t\tptr = strtok(NULL, \"\\n\");\n\t}\n\tgdbr_close_file(ctx->desc);\n\tfree(buf);\n\treturn retlist;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,7 +57,7 @@\n \tint unk = 0, perm, i;\n \tchar *ptr, *pos_1;\n \tsize_t line_len;\n-\tchar name[1024], region1[100], region2[100], perms[5];\n+\tchar name[PROC_NAME_SZ + 1], region1[PROC_REGION_SZ + 1], region2[PROC_REGION_SZ + 1], perms[PROC_PERM_SZ + 1];\n \tRzDebugMap *map = NULL;\n \tregion1[0] = region2[0] = '0';\n \tregion1[1] = region2[1] = 'x';\n@@ -81,8 +81,8 @@\n \t\t}\n \t\t// We assume Linux target, for now, so -\n \t\t// 7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 265428 /usr/lib/ld-2.25.so\n-\t\tret = sscanf(ptr, \"%s %s %\" PFMT64x \" %*s %*s %[^\\n]\", &region1[2],\n-\t\t\tperms, &offset, name);\n+\t\tret = sscanf(ptr, \"%\" RZ_STR_DEF(PROC_REGION_LEFT_SZ) \"s %\" RZ_STR_DEF(PROC_PERM_SZ) \"s %\" PFMT64x \" %*s %*s %\" RZ_STR_DEF(PROC_NAME_SZ) \"[^\\n]\",\n+\t\t\t&region1[2], perms, &offset, name);\n \t\tif (ret == 3) {\n \t\t\tname[0] = '\\0';\n \t\t} else if (ret != 4) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar name[1024], region1[100], region2[100], perms[5];",
                "\t\tret = sscanf(ptr, \"%s %s %\" PFMT64x \" %*s %*s %[^\\n]\", &region1[2],",
                "\t\t\tperms, &offset, name);"
            ],
            "added_lines": [
                "\tchar name[PROC_NAME_SZ + 1], region1[PROC_REGION_SZ + 1], region2[PROC_REGION_SZ + 1], perms[PROC_PERM_SZ + 1];",
                "\t\tret = sscanf(ptr, \"%\" RZ_STR_DEF(PROC_REGION_LEFT_SZ) \"s %\" RZ_STR_DEF(PROC_PERM_SZ) \"s %\" PFMT64x \" %*s %*s %\" RZ_STR_DEF(PROC_NAME_SZ) \"[^\\n]\",",
                "\t\t\t&region1[2], perms, &offset, name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2837",
        "func_name": "gpac/xml_sax_parse",
        "description": "Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.2.",
        "git_url": "https://github.com/gpac/gpac/commit/6f28c4cd607d83ce381f9b4a9f8101ca1e79c611",
        "commit_title": "fixed #2473",
        "commit_text": "",
        "func_before": "static GF_Err xml_sax_parse(GF_SAXParser *parser, Bool force_parse)\n{\n\tu32 i = 0;\n\tBool is_text;\n\tu32 is_end;\n\tu8 c;\n\tchar *elt, sep;\n\tu32 cdata_sep;\n\n\twhile (parser->current_pos<parser->line_size) {\n\t\tif (!force_parse && parser->suspended) goto exit;\n\nrestart:\n\t\tis_text = GF_FALSE;\n\t\tswitch (parser->sax_state) {\n\t\t/*load an XML element*/\n\t\tcase SAX_STATE_TEXT_CONTENT:\n\t\t\tis_text = GF_TRUE;\n\t\tcase SAX_STATE_ELEMENT:\n\t\t\telt = NULL;\n\t\t\ti=0;\n\t\t\twhile ((c = parser->buffer[parser->current_pos+i]) !='<') {\n\t\t\t\tif ((parser->init_state==2) && (c ==']')) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\t\t\tparser->current_pos+=i+1;\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (c=='\\n') parser->line++;\n\t\t\t\tif (is_text) {\n\t\t\t\t\tif (c=='&') parser->text_check_escapes |= 1;\n\t\t\t\t\telse if (c==';') parser->text_check_escapes |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (parser->current_pos+i==parser->line_size) {\n\t\t\t\t\tif ((parser->line_size>=2*XML_INPUT_SIZE) && !parser->init_state)\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_text && i) {\n\t\t\t\tu32 has_esc = parser->text_check_escapes;\n\t\t\t\txml_sax_store_text(parser, i);\n\t\t\t\tparser->text_check_escapes = has_esc;\n\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t} else if (i) {\n\t\t\t\tparser->current_pos += i;\n\t\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\t}\n\t\t\tis_end = 0;\n\t\t\ti = 0;\n\t\t\tcdata_sep = 0;\n\t\t\twhile (1) {\n\t\t\t\tc = parser->buffer[parser->current_pos+1+i];\n\t\t\t\tif (!strncmp(parser->buffer+parser->current_pos+1+i, \"!--\", 3)) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\t\ti += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif ((c=='\\t') || (c=='\\r') || (c==' ') ) {\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='\\n') {\n\t\t\t\t\tparser->line++;\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='>') break;\n\t\t\t\telse if (c=='=') break;\n\t\t\t\telse if (c=='[') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!cdata_sep) cdata_sep = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c=='/') {\n\t\t\t\t\tis_end = !i ? 1 : 2;\n\t\t\t\t\ti++;\n\t\t\t\t} else if (c=='<') {\n\t\t\t\t\tif (parser->sax_state != SAX_STATE_COMMENT) {\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t/*\t\t\t\tif ((c=='[') && (parser->buffer[parser->elt_name_start-1 + i-2]=='A') ) break; */\n\t\t\t\tif (parser->current_pos+1+i==parser->line_size) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i) {\n\t\t\t\tparser->elt_name_start = parser->current_pos+1 + 1;\n\t\t\t\tif (is_end==1) parser->elt_name_start ++;\n\t\t\t\tif (is_end==2) parser->elt_name_end = parser->current_pos+1+i;\n\t\t\t\telse parser->elt_name_end = parser->current_pos+1+i + 1;\n\t\t\t}\n\t\t\tif (is_end) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos + i;\n\t\t\t\tif (is_end==2) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tparser->elt_end_pos += parser->elt_name_end - parser->elt_name_start;\n\t\t\t\t\txml_sax_node_end(parser, GF_TRUE);\n\t\t\t\t}\n\t\t\t\tif (parser->sax_state == SAX_STATE_SYNTAX_ERROR) break;\n\t\t\t\tparser->current_pos+=2+i;\n\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!parser->elt_name_end) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\t\t\tsep = parser->buffer[parser->elt_name_end-1];\n\t\t\tparser->buffer[parser->elt_name_end-1] = 0;\n\t\t\telt = parser->buffer + parser->elt_name_start-1;\n\n\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\tassert(parser->elt_start_pos <= parser->file_pos + parser->current_pos);\n\t\t\tparser->elt_start_pos = parser->file_pos + parser->current_pos;\n\n\t\t\tif (!strncmp(elt, \"!--\", 3)) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\tif (i>3) parser->current_pos -= (i-3);\n\t\t\t}\n\t\t\telse if (!strcmp(elt, \"?xml\")) parser->init_state = 1;\n\t\t\telse if (!strcmp(elt, \"!DOCTYPE\")) parser->init_state = 2;\n\t\t\telse if (!strcmp(elt, \"!ENTITY\")) parser->sax_state = SAX_STATE_ENTITY;\n\t\t\telse if (!strcmp(elt, \"!ATTLIST\") || !strcmp(elt, \"!ELEMENT\")) parser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\telse if (!strcmp(elt, \"![CDATA[\"))\n\t\t\t\tparser->sax_state = SAX_STATE_CDATA;\n\t\t\telse if (elt[0]=='?') {\n\t\t\t\ti--;\n\t\t\t\tparser->sax_state = SAX_STATE_XML_PROC;\n\t\t\t}\n\t\t\t/*node found*/\n\t\t\telse {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tif (parser->init_state) {\n\t\t\t\t\tparser->init_state = 0;\n\t\t\t\t\t/*that's a bit ugly: since we solve entities when appending text, we need to\n\t\t\t\t\treparse the current buffer*/\n\t\t\t\t\tif (gf_list_count(parser->entities)) {\n\t\t\t\t\t\tchar *orig_buf;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\t\t\t\torig_buf = gf_strdup(parser->buffer + parser->current_pos);\n\t\t\t\t\t\tparser->current_pos = 0;\n\t\t\t\t\t\tparser->line_size = 0;\n\t\t\t\t\t\tparser->elt_start_pos = 0;\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n\t\t\t\t\t\tgf_free(orig_buf);\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser->current_pos+=1+i;\n\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\tbreak;\n\t\tcase SAX_STATE_COMMENT:\n\t\t\tif (!xml_sax_parse_comments(parser)) {\n\t\t\t\txml_sax_swap(parser);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAX_STATE_ATT_NAME:\n\t\tcase SAX_STATE_ATT_VALUE:\n\t\t\tif (xml_sax_parse_attribute(parser))\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase SAX_STATE_ENTITY:\n\t\t\txml_sax_parse_entity(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SKIP_DOCTYPE:\n\t\t\txml_sax_skip_doctype(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_XML_PROC:\n\t\t\txml_sax_skip_xml_proc(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_CDATA:\n\t\t\txml_sax_cdata(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SYNTAX_ERROR:\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\tcase SAX_STATE_ALLOC_ERROR:\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tcase SAX_STATE_DONE:\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\nexit:\n#if 0\n\tif (is_text) {\n\t\tif (i) xml_sax_store_text(parser, i);\n\t\t/*DON'T FLUSH TEXT YET, wait for next '<' to do so otherwise we may corrupt xml base entities (&apos;, ...)*/\n\t}\n#endif\n\txml_sax_swap(parser);\n\n\tif (parser->sax_state==SAX_STATE_SYNTAX_ERROR)\n\t\treturn GF_CORRUPTED_DATA;\n\telse\n\t\treturn GF_OK;\n}",
        "func": "static GF_Err xml_sax_parse(GF_SAXParser *parser, Bool force_parse)\n{\n\tu32 i = 0;\n\tBool is_text;\n\tu32 is_end;\n\tu8 c;\n\tchar *elt, sep;\n\tu32 cdata_sep;\n\n\twhile (parser->current_pos<parser->line_size) {\n\t\tif (!force_parse && parser->suspended) goto exit;\n\nrestart:\n\t\tis_text = GF_FALSE;\n\t\tswitch (parser->sax_state) {\n\t\t/*load an XML element*/\n\t\tcase SAX_STATE_TEXT_CONTENT:\n\t\t\tis_text = GF_TRUE;\n\t\tcase SAX_STATE_ELEMENT:\n\t\t\telt = NULL;\n\t\t\ti=0;\n\t\t\twhile ((c = parser->buffer[parser->current_pos+i]) !='<') {\n\t\t\t\tif ((parser->init_state==2) && (c ==']')) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\t\t\tparser->current_pos+=i+1;\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (c=='\\n') parser->line++;\n\t\t\t\tif (is_text) {\n\t\t\t\t\tif (c=='&') parser->text_check_escapes |= 1;\n\t\t\t\t\telse if (c==';') parser->text_check_escapes |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (parser->current_pos+i==parser->line_size) {\n\t\t\t\t\tif ((parser->line_size>=2*XML_INPUT_SIZE) && !parser->init_state)\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_text && i) {\n\t\t\t\tu32 has_esc = parser->text_check_escapes;\n\t\t\t\txml_sax_store_text(parser, i);\n\t\t\t\tparser->text_check_escapes = has_esc;\n\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t} else if (i) {\n\t\t\t\tparser->current_pos += i;\n\t\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\t}\n\t\t\tis_end = 0;\n\t\t\ti = 0;\n\t\t\tcdata_sep = 0;\n\t\t\twhile (1) {\n\t\t\t\tc = parser->buffer[parser->current_pos+1+i];\n\t\t\t\tif (!strncmp(parser->buffer+parser->current_pos+1+i, \"!--\", 3)) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\t\ti += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif ((c=='\\t') || (c=='\\r') || (c==' ') ) {\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='\\n') {\n\t\t\t\t\tparser->line++;\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='>') break;\n\t\t\t\telse if (c=='=') break;\n\t\t\t\telse if (c=='[') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!cdata_sep) cdata_sep = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c=='/') {\n\t\t\t\t\tis_end = !i ? 1 : 2;\n\t\t\t\t\ti++;\n\t\t\t\t} else if (c=='<') {\n\t\t\t\t\tif (parser->sax_state != SAX_STATE_COMMENT) {\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t/*\t\t\t\tif ((c=='[') && (parser->buffer[parser->elt_name_start-1 + i-2]=='A') ) break; */\n\t\t\t\tif (parser->current_pos+1+i==parser->line_size) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i) {\n\t\t\t\tparser->elt_name_start = parser->current_pos+1 + 1;\n\t\t\t\tif (is_end==1) parser->elt_name_start ++;\n\t\t\t\tif (is_end==2) parser->elt_name_end = parser->current_pos+1+i;\n\t\t\t\telse parser->elt_name_end = parser->current_pos+1+i + 1;\n\t\t\t}\n\t\t\tif (is_end) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos + i;\n\t\t\t\tif (is_end==2) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tparser->elt_end_pos += parser->elt_name_end - parser->elt_name_start;\n\t\t\t\t\txml_sax_node_end(parser, GF_TRUE);\n\t\t\t\t}\n\t\t\t\tif (parser->sax_state == SAX_STATE_SYNTAX_ERROR) break;\n\t\t\t\tparser->current_pos+=2+i;\n\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!parser->elt_name_end) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\t\t\tsep = parser->buffer[parser->elt_name_end-1];\n\t\t\tparser->buffer[parser->elt_name_end-1] = 0;\n\t\t\telt = parser->buffer + parser->elt_name_start-1;\n\n\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\tassert(parser->elt_start_pos <= parser->file_pos + parser->current_pos);\n\t\t\tparser->elt_start_pos = parser->file_pos + parser->current_pos;\n\n\t\t\tif (!strncmp(elt, \"!--\", 3)) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\tif (i>3) parser->current_pos -= (i-3);\n\t\t\t}\n\t\t\telse if (!strcmp(elt, \"?xml\")) parser->init_state = 1;\n\t\t\telse if (!strcmp(elt, \"!DOCTYPE\")) parser->init_state = 2;\n\t\t\telse if (!strcmp(elt, \"!ENTITY\")) parser->sax_state = SAX_STATE_ENTITY;\n\t\t\telse if (!strcmp(elt, \"!ATTLIST\") || !strcmp(elt, \"!ELEMENT\")) parser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\telse if (!strcmp(elt, \"![CDATA[\"))\n\t\t\t\tparser->sax_state = SAX_STATE_CDATA;\n\t\t\telse if (elt[0]=='?') {\n\t\t\t\ti--;\n\t\t\t\tparser->sax_state = SAX_STATE_XML_PROC;\n\t\t\t}\n\t\t\t/*node found*/\n\t\t\telse {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tif (parser->init_state) {\n\t\t\t\t\tparser->init_state = 0;\n\t\t\t\t\t/*that's a bit ugly: since we solve entities when appending text, we need to\n\t\t\t\t\treparse the current buffer*/\n\t\t\t\t\tif (gf_list_count(parser->entities)) {\n\t\t\t\t\t\tchar *orig_buf;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\t\t\t\torig_buf = gf_strdup(parser->buffer + parser->current_pos);\n\t\t\t\t\t\tparser->current_pos = 0;\n\t\t\t\t\t\tparser->line_size = 0;\n\t\t\t\t\t\tparser->elt_start_pos = 0;\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->ent_rec_level++;\n\t\t\t\t\t\tif (parser->ent_rec_level>100) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Too many recursions in entity solving, max 100 allowed\\n\"));\n\t\t\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n\t\t\t\t\t\t\tparser->ent_rec_level--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(orig_buf);\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser->current_pos+=1+i;\n\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\tbreak;\n\t\tcase SAX_STATE_COMMENT:\n\t\t\tif (!xml_sax_parse_comments(parser)) {\n\t\t\t\txml_sax_swap(parser);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAX_STATE_ATT_NAME:\n\t\tcase SAX_STATE_ATT_VALUE:\n\t\t\tif (xml_sax_parse_attribute(parser))\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase SAX_STATE_ENTITY:\n\t\t\txml_sax_parse_entity(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SKIP_DOCTYPE:\n\t\t\txml_sax_skip_doctype(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_XML_PROC:\n\t\t\txml_sax_skip_xml_proc(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_CDATA:\n\t\t\txml_sax_cdata(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SYNTAX_ERROR:\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\tcase SAX_STATE_ALLOC_ERROR:\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tcase SAX_STATE_DONE:\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\nexit:\n#if 0\n\tif (is_text) {\n\t\tif (i) xml_sax_store_text(parser, i);\n\t\t/*DON'T FLUSH TEXT YET, wait for next '<' to do so otherwise we may corrupt xml base entities (&apos;, ...)*/\n\t}\n#endif\n\txml_sax_swap(parser);\n\n\tif (parser->sax_state==SAX_STATE_SYNTAX_ERROR)\n\t\treturn GF_CORRUPTED_DATA;\n\telse\n\t\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -159,7 +159,14 @@\n \t\t\t\t\t\tparser->line_size = 0;\n \t\t\t\t\t\tparser->elt_start_pos = 0;\n \t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n-\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n+\t\t\t\t\t\tparser->ent_rec_level++;\n+\t\t\t\t\t\tif (parser->ent_rec_level>100) {\n+\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Too many recursions in entity solving, max 100 allowed\\n\"));\n+\t\t\t\t\t\t\te = GF_NOT_SUPPORTED;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n+\t\t\t\t\t\t\tparser->ent_rec_level--;\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tgf_free(orig_buf);\n \t\t\t\t\t\treturn e;\n \t\t\t\t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);"
            ],
            "added_lines": [
                "\t\t\t\t\t\tparser->ent_rec_level++;",
                "\t\t\t\t\t\tif (parser->ent_rec_level>100) {",
                "\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Too many recursions in entity solving, max 100 allowed\\n\"));",
                "\t\t\t\t\t\t\te = GF_NOT_SUPPORTED;",
                "\t\t\t\t\t\t} else {",
                "\t\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);",
                "\t\t\t\t\t\t\tparser->ent_rec_level--;",
                "\t\t\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2837",
        "func_name": "gpac/gf_xml_sax_parse_intern",
        "description": "Stack-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.2.",
        "git_url": "https://github.com/gpac/gpac/commit/6f28c4cd607d83ce381f9b4a9f8101ca1e79c611",
        "commit_title": "fixed #2473",
        "commit_text": "",
        "func_before": "static GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current)\n{\n\tu32 count;\n\t/*solve entities*/\n\tcount = gf_list_count(parser->entities);\n\twhile (count) {\n\t\tchar *entityEnd;\n\t\tXML_Entity *ent;\n\t\tchar *entityStart = strstr(current, \"&\");\n\t\tBool needs_text;\n\t\tu32 line_num;\n\n\t\t/*if in entity, the start of the entity is in the buffer !!*/\n\t\tif (parser->in_entity) {\n\t\t\tu32 len;\n\t\t\tchar *name;\n\t\t\tentityEnd = strstr(current, \";\");\n\t\t\tif (!entityEnd) return xml_sax_append_string(parser, current);\n\t\t\tentityStart = strrchr(parser->buffer, '&');\n\n\t\t\tentityEnd[0] = 0;\n\t\t\tlen = (u32) strlen(entityStart) + (u32) strlen(current) + 1;\n\t\t\tname = (char*)gf_malloc(sizeof(char)*len);\n\t\t\tsprintf(name, \"%s%s;\", entityStart+1, current);\n\n\t\t\tent = gf_xml_locate_entity(parser, name, &needs_text);\n\t\t\tgf_free(name);\n\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, current);\n\t\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\t\tentityEnd[0] = ';';\n\t\t\t\tcurrent = entityEnd;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(ent);\n\t\t\t/*truncate input buffer*/\n\t\t\tparser->line_size -= (u32) strlen(entityStart);\n\t\t\tentityStart[0] = 0;\n\n\t\t\tparser->in_entity = GF_FALSE;\n\t\t\tentityEnd[0] = ';';\n\t\t\tcurrent = entityEnd+1;\n\t\t} else {\n\t\t\tif (!entityStart) break;\n\n\t\t\tent = gf_xml_locate_entity(parser, entityStart+1, &needs_text);\n\n\t\t\t/*store current string before entity start*/\n\t\t\tentityStart[0] = 0;\n\t\t\txml_sax_append_string(parser, current);\n\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\tentityStart[0] = '&';\n\n\t\t\t/*this is not an entitiy*/\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, \"&\");\n\t\t\t\tcurrent = entityStart+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!ent) {\n\t\t\t\tparser->in_entity = GF_TRUE;\n\t\t\t\t/*store entity start*/\n\t\t\t\treturn xml_sax_append_string(parser, entityStart);\n\t\t\t}\n\t\t\tcurrent = entityStart + ent->namelen + 2;\n\t\t}\n\t\t/*append entity*/\n\t\tline_num = parser->line;\n\t\txml_sax_append_string(parser, ent->value);\n\t\txml_sax_parse(parser, GF_TRUE);\n\t\tparser->line = line_num;\n\n\t}\n\txml_sax_append_string(parser, current);\n\treturn xml_sax_parse(parser, GF_FALSE);\n}",
        "func": "static GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current)\n{\n\tu32 count;\n\t/*solve entities*/\n\tcount = gf_list_count(parser->entities);\n\twhile (count) {\n\t\tchar *entityEnd;\n\t\tXML_Entity *ent;\n\t\tchar *entityStart = strstr(current, \"&\");\n\t\tBool needs_text;\n\t\tu32 line_num;\n\n\t\t/*if in entity, the start of the entity is in the buffer !!*/\n\t\tif (parser->in_entity) {\n\t\t\tu32 len;\n\t\t\tchar *name;\n\t\t\tentityEnd = strstr(current, \";\");\n\t\t\tif (!entityEnd) return xml_sax_append_string(parser, current);\n\t\t\tentityStart = strrchr(parser->buffer, '&');\n\n\t\t\tentityEnd[0] = 0;\n\t\t\tlen = (u32) strlen(entityStart) + (u32) strlen(current) + 1;\n\t\t\tname = (char*)gf_malloc(sizeof(char)*len);\n\t\t\tsprintf(name, \"%s%s;\", entityStart+1, current);\n\n\t\t\tent = gf_xml_locate_entity(parser, name, &needs_text);\n\t\t\tgf_free(name);\n\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, current);\n\t\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\t\tentityEnd[0] = ';';\n\t\t\t\tcurrent = entityEnd;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(ent);\n\t\t\t/*truncate input buffer*/\n\t\t\tparser->line_size -= (u32) strlen(entityStart);\n\t\t\tentityStart[0] = 0;\n\n\t\t\tparser->in_entity = GF_FALSE;\n\t\t\tentityEnd[0] = ';';\n\t\t\tcurrent = entityEnd+1;\n\t\t} else {\n\t\t\tif (!entityStart) break;\n\n\t\t\tent = gf_xml_locate_entity(parser, entityStart+1, &needs_text);\n\n\t\t\t/*store current string before entity start*/\n\t\t\tentityStart[0] = 0;\n\t\t\txml_sax_append_string(parser, current);\n\t\t\txml_sax_parse(parser, GF_TRUE);\n\t\t\tentityStart[0] = '&';\n\n\t\t\t/*this is not an entitiy*/\n\t\t\tif (!ent && !needs_text) {\n\t\t\t\txml_sax_append_string(parser, \"&\");\n\t\t\t\tcurrent = entityStart+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!ent) {\n\t\t\t\tparser->in_entity = GF_TRUE;\n\t\t\t\t/*store entity start*/\n\t\t\t\treturn xml_sax_append_string(parser, entityStart);\n\t\t\t}\n\t\t\tcurrent = entityStart + ent->namelen + 2;\n\t\t}\n\t\t/*append entity*/\n\t\tline_num = parser->line;\n\t\txml_sax_append_string(parser, ent->value);\n\t\tGF_Err e = xml_sax_parse(parser, GF_TRUE);\n\t\tparser->line = line_num;\n\t\tif (e) return e;\n\n\t}\n\txml_sax_append_string(parser, current);\n\treturn xml_sax_parse(parser, GF_FALSE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,8 +69,9 @@\n \t\t/*append entity*/\n \t\tline_num = parser->line;\n \t\txml_sax_append_string(parser, ent->value);\n-\t\txml_sax_parse(parser, GF_TRUE);\n+\t\tGF_Err e = xml_sax_parse(parser, GF_TRUE);\n \t\tparser->line = line_num;\n+\t\tif (e) return e;\n \n \t}\n \txml_sax_append_string(parser, current);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\txml_sax_parse(parser, GF_TRUE);"
            ],
            "added_lines": [
                "\t\tGF_Err e = xml_sax_parse(parser, GF_TRUE);",
                "\t\tif (e) return e;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-34095",
        "func_name": "OpenPrinting/cpdb-libs/parse_commands",
        "description": "cpdb-libs provides frontend and backend libraries for the Common Printing Dialog Backends (CPDB) project. In versions 1.0 through 2.0b4, cpdb-libs is vulnerable to buffer overflows via improper use of `scanf(3)`. cpdb-libs uses the `fscanf()` and `scanf()` functions to parse command lines and configuration files, dropping the read string components into fixed-length buffers, but does not limit the length of the strings to be read by `fscanf()` and `scanf()` causing buffer overflows when a string is longer than 1023 characters. A patch for this issue is available at commit f181bd1f14757c2ae0f17cc76dc20421a40f30b7. As all buffers have a length of 1024 characters, the patch limits the maximum string length to be read to 1023 by replacing all occurrences of `%s` with `%1023s` in all calls of the `fscanf()` and `scanf()` functions.\n",
        "git_url": "https://github.com/OpenPrinting/cpdb-libs/commit/f181bd1f14757c2ae0f17cc76dc20421a40f30b7",
        "commit_title": "Merge pull request from GHSA-25j7-9gfc-f46x",
        "commit_text": " cpdb-libs uses the fscanf() and scanf() functions to parse command lines and configuration files, dropping the read string components into fixed-length buffers, but does not limit the length of the strings to be read by fscanf() and scanf() causing buffer overflows when a string is longer than 1023 characters.  As all buffers have a length of 1024 characters we limit the maximum string length to be read to 1023 by replaceing all occurences of \"%s\" by \"%1023s\" in all calls of the fscanf() and scanf() functions.  Simply done by  perl -p -i -e 's/(scanf\\(.*?\".*?)%s/\\1%1023s/' cpdb/cpdb-frontend.c tools/cpdb-text-frontend.c  and verifying with  grep scanf */*.c",
        "func_before": "gpointer parse_commands(gpointer user_data)\n{\n    fflush(stdout);\n    char buf[BUFSIZE];\n    while (1)\n    {\n        printf(\"> \");\n        fflush(stdout);\n        scanf(\"%s\", buf);\n        if (strcmp(buf, \"stop\") == 0)\n        {\n            cpdbDeleteFrontendObj(f);\n            g_message(\"Stopping front end..\\n\");\n            exit(0);\n        }\n        else if (strcmp(buf, \"restart\") == 0)\n        {\n            cpdbDisconnectFromDBus(f);\n            cpdbConnectToDBus(f);\n        }\n        else if (strcmp(buf, \"hide-remote\") == 0)\n        {\n            cpdbHideRemotePrinters(f);\n            g_message(\"Hiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"unhide-remote\") == 0)\n        {\n            cpdbUnhideRemotePrinters(f);\n            g_message(\"Unhiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"hide-temporary\") == 0)\n        {\n            cpdbHideTemporaryPrinters(f);\n            g_message(\"Hiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"unhide-temporary\") == 0)\n        {\n            cpdbUnhideTemporaryPrinters(f);\n            g_message(\"Unhiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"get-all-options\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            g_message(\"Getting all attributes ..\\n\");\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(p == NULL)\n              continue;\n\n            cpdb_options_t *opts = cpdbGetAllOptions(p);\n\n            printf(\"Retrieved %d options.\\n\", opts->count);\n            GHashTableIter iter;\n            gpointer value;\n\n            g_hash_table_iter_init(&iter, opts->table);\n            while (g_hash_table_iter_next(&iter, NULL, &value))\n            {\n                printOption(value);\n            }\n        }\n        else if (strcmp(buf, \"get-all-media\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            g_message(\"Getting all attributes ..\\n\");\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(p == NULL)\n              continue;\n\n            cpdb_options_t *opts = cpdbGetAllOptions(p);\n\n            printf(\"Retrieved %d medias.\\n\", opts->media_count);\n            GHashTableIter iter;\n            gpointer value;\n\n            g_hash_table_iter_init(&iter, opts->media);\n            while (g_hash_table_iter_next(&iter, NULL, &value))\n            {\n                printMedia(value);\n            }\n        }\n        else if (strcmp(buf, \"get-default\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetDefault(p, option_name);\n            if (!ans)\n                printf(\"cpdb_option_t %s doesn't exist.\", option_name);\n            else\n                printf(\"Default : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"get-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], setting_name[BUFSIZE];\n            scanf(\"%s%s%s\", setting_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetSetting(p, setting_name);\n            if (!ans)\n                printf(\"Setting %s doesn't exist.\\n\", setting_name);\n            else\n                printf(\"Setting value : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"get-current\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetCurrent(p, option_name);\n            if (!ans)\n                printf(\"cpdb_option_t %s doesn't exist.\", option_name);\n            else\n                printf(\"Current value : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"add-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE], option_val[BUFSIZE];\n            scanf(\"%s %s %s %s\", option_name, option_val, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s : %s\\n\", option_name, option_val);\n            cpdbAddSettingToPrinter(p, cpdbGetStringCopy(option_name), cpdbGetStringCopy(option_val));\n        }\n        else if (strcmp(buf, \"clear-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbClearSettingFromPrinter(p, option_name);\n        }\n        else if (strcmp(buf, \"get-state\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetState(p));\n        }\n        else if (strcmp(buf, \"is-accepting-jobs\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"Accepting jobs ? : %d \\n\", cpdbIsAcceptingJobs(p));\n        }\n        else if (strcmp(buf, \"help\") == 0)\n        {\n            display_help();\n        }\n        else if (strcmp(buf, \"ping\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            print_backend_call_ping_sync(p->backend_proxy, p->id, NULL, NULL);\n        }\n        else if (strcmp(buf, \"get-default-printer\") == 0)\n        {\n            cpdb_printer_obj_t *p = cpdbGetDefaultPrinter(f);\n            if (p)\n                printf(\"%s#%s\\n\", p->name, p->backend_name);\n            else\n                printf(\"No default printer found\\n\");\n        }\n        else if (strcmp(buf, \"get-default-printer-for-backend\") == 0)\n        {\n            char backend_name[BUFSIZE];\n            scanf(\"%s\", backend_name);\n            /**\n             * Backend name = The last part of the backend dbus service\n             * Eg. \"CUPS\" or \"GCP\"\n             */\n            cpdb_printer_obj_t *p = cpdbGetDefaultPrinterForBackend(f, backend_name);\n            printf(\"%s\\n\", p->name);\n        }\n        else if (strcmp(buf, \"set-user-default-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (p)\n            {\n                if (cpdbSetUserDefaultPrinter(p))\n                    printf(\"Set printer as user default\\n\");\n                else\n                    printf(\"Couldn't set printer as user default\\n\");\n            }\n        }\n        else if (strcmp(buf, \"set-system-default-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (p)\n            {\n                if (cpdbSetSystemDefaultPrinter(p))\n                    printf(\"Set printer as system default\\n\");\n                else\n                    printf(\"Couldn't set printer as system default\\n\");\n            }\n        }\n        else if (strcmp(buf, \"print-file\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], file_path[BUFSIZE];\n            scanf(\"%s%s%s\", file_path, printer_id, backend_name);\n            /**\n             * Try adding some settings here .. change them and experiment\n             */\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(strcmp(backend_name, \"FILE\") == 0)\n            {\n              char final_file_path[BUFSIZE];\n              printf(\"Please give the final file path: \");\n              scanf(\"%s\", final_file_path);\n              cpdbPrintFilePath(p, file_path, final_file_path);\n              continue;\n            }\n\n            cpdbAddSettingToPrinter(p, \"copies\", \"3\");\n            cpdbPrintFile(p, file_path);\n        }\n        else if (strcmp(buf, \"get-active-jobs-count\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%d jobs currently active.\\n\", cpdbGetActiveJobsCount(p));\n        }\n        else if (strcmp(buf, \"get-all-jobs\") == 0)\n        {\n            int active_only;\n            scanf(\"%d\", &active_only);\n            cpdb_job_t *j;\n            int x = cpdbGetAllJobs(f, &j, active_only);\n            printf(\"Total %d jobs\\n\", x);\n            int i;\n            for (i = 0; i < x; i++)\n            {\n                printf(\"%s .. %s  .. %s  .. %s  .. %s\\n\", j[i].job_id, j[i].title, j[i].printer_id, j[i].state, j[i].submitted_at);\n            }\n        }\n        else if (strcmp(buf, \"cancel-job\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char job_id[BUFSIZE];\n            scanf(\"%s%s%s\", job_id, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (cpdbCancelJob(p, job_id))\n                printf(\"cpdb_job_t %s has been cancelled.\\n\", job_id);\n            else\n                printf(\"Unable to cancel job %s\\n\", job_id);\n        }\n        else if (strcmp(buf, \"pickle-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char job_id[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbPicklePrinterToFile(p, \"/tmp/.printer-pickle\", f);\n        }\n        else if (strcmp(buf, \"get-option-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char option_name[BUFSIZE];\n            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetOptionTranslation(p, option_name, locale));\n        }\n        else if (strcmp(buf, \"get-choice-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char option_name[BUFSIZE];\n            char choice_name[BUFSIZE];\n            scanf(\"%s%s%s%s\", option_name, choice_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetChoiceTranslation(p, option_name, choice_name, locale));\n        }\n        else if (strcmp(buf, \"get-group-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char group_name[BUFSIZE];\n            scanf(\"%s%s%s\", group_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetGroupTranslation(p, group_name, locale));\n        }\n        else if (strcmp(buf, \"get-all-translations\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbGetAllTranslations(p, locale);\n            printTranslations(p);\n        }\n        else if (strcmp(buf, \"get-media-size\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char media[BUFSIZE];\n            int width, length;\n            scanf(\"%s%s%s\", media, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            int ok = cpdbGetMediaSize(p, media, &width, &length);\n            if (ok)\n                printf(\"%dx%d\\n\", width, length);\n        }\n        else if (strcmp(buf, \"get-media-margins\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char media[BUFSIZE];\n            scanf(\"%s%s%s\", media, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            cpdb_margin_t *margins;\n            int num_margins = cpdbGetMediaMargins(p, media, &margins);\n            for (int i = 0; i < num_margins; i++)\n                printf(\"%d %d %d %d\\n\", margins[i].left, margins[i].right, margins[i].top, margins[i].bottom);\n        }\n        else if (strcmp(buf, \"acquire-details\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            \n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if(p == NULL)\n              continue;\n\n            g_message(\"Acquiring printer details asynchronously...\\n\");\n            cpdbAcquireDetails(p, acquire_details_callback, NULL);\n\t\t}\n        else if (strcmp(buf, \"acquire-translations\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            \n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if(p == NULL)\n              continue;\n\n            g_message(\"Acquiring printer translations asynchronously...\\n\");\n            cpdbAcquireTranslations(p, locale, acquire_translations_callback, NULL);\n        }\n    }\n}",
        "func": "gpointer parse_commands(gpointer user_data)\n{\n    fflush(stdout);\n    char buf[BUFSIZE];\n    while (1)\n    {\n        printf(\"> \");\n        fflush(stdout);\n        scanf(\"%1023s\", buf);\n        if (strcmp(buf, \"stop\") == 0)\n        {\n            cpdbDeleteFrontendObj(f);\n            g_message(\"Stopping front end..\\n\");\n            exit(0);\n        }\n        else if (strcmp(buf, \"restart\") == 0)\n        {\n            cpdbDisconnectFromDBus(f);\n            cpdbConnectToDBus(f);\n        }\n        else if (strcmp(buf, \"hide-remote\") == 0)\n        {\n            cpdbHideRemotePrinters(f);\n            g_message(\"Hiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"unhide-remote\") == 0)\n        {\n            cpdbUnhideRemotePrinters(f);\n            g_message(\"Unhiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"hide-temporary\") == 0)\n        {\n            cpdbHideTemporaryPrinters(f);\n            g_message(\"Hiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"unhide-temporary\") == 0)\n        {\n            cpdbUnhideTemporaryPrinters(f);\n            g_message(\"Unhiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"get-all-options\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            g_message(\"Getting all attributes ..\\n\");\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(p == NULL)\n              continue;\n\n            cpdb_options_t *opts = cpdbGetAllOptions(p);\n\n            printf(\"Retrieved %d options.\\n\", opts->count);\n            GHashTableIter iter;\n            gpointer value;\n\n            g_hash_table_iter_init(&iter, opts->table);\n            while (g_hash_table_iter_next(&iter, NULL, &value))\n            {\n                printOption(value);\n            }\n        }\n        else if (strcmp(buf, \"get-all-media\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            g_message(\"Getting all attributes ..\\n\");\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(p == NULL)\n              continue;\n\n            cpdb_options_t *opts = cpdbGetAllOptions(p);\n\n            printf(\"Retrieved %d medias.\\n\", opts->media_count);\n            GHashTableIter iter;\n            gpointer value;\n\n            g_hash_table_iter_init(&iter, opts->media);\n            while (g_hash_table_iter_next(&iter, NULL, &value))\n            {\n                printMedia(value);\n            }\n        }\n        else if (strcmp(buf, \"get-default\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetDefault(p, option_name);\n            if (!ans)\n                printf(\"cpdb_option_t %s doesn't exist.\", option_name);\n            else\n                printf(\"Default : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"get-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], setting_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", setting_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetSetting(p, setting_name);\n            if (!ans)\n                printf(\"Setting %s doesn't exist.\\n\", setting_name);\n            else\n                printf(\"Setting value : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"get-current\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetCurrent(p, option_name);\n            if (!ans)\n                printf(\"cpdb_option_t %s doesn't exist.\", option_name);\n            else\n                printf(\"Current value : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"add-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE], option_val[BUFSIZE];\n            scanf(\"%1023s %1023s %1023s %1023s\", option_name, option_val, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s : %s\\n\", option_name, option_val);\n            cpdbAddSettingToPrinter(p, cpdbGetStringCopy(option_name), cpdbGetStringCopy(option_val));\n        }\n        else if (strcmp(buf, \"clear-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbClearSettingFromPrinter(p, option_name);\n        }\n        else if (strcmp(buf, \"get-state\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetState(p));\n        }\n        else if (strcmp(buf, \"is-accepting-jobs\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"Accepting jobs ? : %d \\n\", cpdbIsAcceptingJobs(p));\n        }\n        else if (strcmp(buf, \"help\") == 0)\n        {\n            display_help();\n        }\n        else if (strcmp(buf, \"ping\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            print_backend_call_ping_sync(p->backend_proxy, p->id, NULL, NULL);\n        }\n        else if (strcmp(buf, \"get-default-printer\") == 0)\n        {\n            cpdb_printer_obj_t *p = cpdbGetDefaultPrinter(f);\n            if (p)\n                printf(\"%s#%s\\n\", p->name, p->backend_name);\n            else\n                printf(\"No default printer found\\n\");\n        }\n        else if (strcmp(buf, \"get-default-printer-for-backend\") == 0)\n        {\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s\", backend_name);\n            /**\n             * Backend name = The last part of the backend dbus service\n             * Eg. \"CUPS\" or \"GCP\"\n             */\n            cpdb_printer_obj_t *p = cpdbGetDefaultPrinterForBackend(f, backend_name);\n            printf(\"%s\\n\", p->name);\n        }\n        else if (strcmp(buf, \"set-user-default-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (p)\n            {\n                if (cpdbSetUserDefaultPrinter(p))\n                    printf(\"Set printer as user default\\n\");\n                else\n                    printf(\"Couldn't set printer as user default\\n\");\n            }\n        }\n        else if (strcmp(buf, \"set-system-default-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (p)\n            {\n                if (cpdbSetSystemDefaultPrinter(p))\n                    printf(\"Set printer as system default\\n\");\n                else\n                    printf(\"Couldn't set printer as system default\\n\");\n            }\n        }\n        else if (strcmp(buf, \"print-file\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], file_path[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", file_path, printer_id, backend_name);\n            /**\n             * Try adding some settings here .. change them and experiment\n             */\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(strcmp(backend_name, \"FILE\") == 0)\n            {\n              char final_file_path[BUFSIZE];\n              printf(\"Please give the final file path: \");\n              scanf(\"%1023s\", final_file_path);\n              cpdbPrintFilePath(p, file_path, final_file_path);\n              continue;\n            }\n\n            cpdbAddSettingToPrinter(p, \"copies\", \"3\");\n            cpdbPrintFile(p, file_path);\n        }\n        else if (strcmp(buf, \"get-active-jobs-count\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%d jobs currently active.\\n\", cpdbGetActiveJobsCount(p));\n        }\n        else if (strcmp(buf, \"get-all-jobs\") == 0)\n        {\n            int active_only;\n            scanf(\"%d\", &active_only);\n            cpdb_job_t *j;\n            int x = cpdbGetAllJobs(f, &j, active_only);\n            printf(\"Total %d jobs\\n\", x);\n            int i;\n            for (i = 0; i < x; i++)\n            {\n                printf(\"%s .. %s  .. %s  .. %s  .. %s\\n\", j[i].job_id, j[i].title, j[i].printer_id, j[i].state, j[i].submitted_at);\n            }\n        }\n        else if (strcmp(buf, \"cancel-job\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char job_id[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", job_id, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (cpdbCancelJob(p, job_id))\n                printf(\"cpdb_job_t %s has been cancelled.\\n\", job_id);\n            else\n                printf(\"Unable to cancel job %s\\n\", job_id);\n        }\n        else if (strcmp(buf, \"pickle-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char job_id[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbPicklePrinterToFile(p, \"/tmp/.printer-pickle\", f);\n        }\n        else if (strcmp(buf, \"get-option-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char option_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetOptionTranslation(p, option_name, locale));\n        }\n        else if (strcmp(buf, \"get-choice-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char option_name[BUFSIZE];\n            char choice_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s%1023s\", option_name, choice_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetChoiceTranslation(p, option_name, choice_name, locale));\n        }\n        else if (strcmp(buf, \"get-group-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char group_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", group_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetGroupTranslation(p, group_name, locale));\n        }\n        else if (strcmp(buf, \"get-all-translations\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbGetAllTranslations(p, locale);\n            printTranslations(p);\n        }\n        else if (strcmp(buf, \"get-media-size\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char media[BUFSIZE];\n            int width, length;\n            scanf(\"%1023s%1023s%1023s\", media, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            int ok = cpdbGetMediaSize(p, media, &width, &length);\n            if (ok)\n                printf(\"%dx%d\\n\", width, length);\n        }\n        else if (strcmp(buf, \"get-media-margins\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char media[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", media, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            cpdb_margin_t *margins;\n            int num_margins = cpdbGetMediaMargins(p, media, &margins);\n            for (int i = 0; i < num_margins; i++)\n                printf(\"%d %d %d %d\\n\", margins[i].left, margins[i].right, margins[i].top, margins[i].bottom);\n        }\n        else if (strcmp(buf, \"acquire-details\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            \n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if(p == NULL)\n              continue;\n\n            g_message(\"Acquiring printer details asynchronously...\\n\");\n            cpdbAcquireDetails(p, acquire_details_callback, NULL);\n\t\t}\n        else if (strcmp(buf, \"acquire-translations\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            \n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if(p == NULL)\n              continue;\n\n            g_message(\"Acquiring printer translations asynchronously...\\n\");\n            cpdbAcquireTranslations(p, locale, acquire_translations_callback, NULL);\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n     {\n         printf(\"> \");\n         fflush(stdout);\n-        scanf(\"%s\", buf);\n+        scanf(\"%1023s\", buf);\n         if (strcmp(buf, \"stop\") == 0)\n         {\n             cpdbDeleteFrontendObj(f);\n@@ -42,7 +42,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             g_message(\"Getting all attributes ..\\n\");\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n \n@@ -65,7 +65,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             g_message(\"Getting all attributes ..\\n\");\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n \n@@ -87,7 +87,7 @@\n         else if (strcmp(buf, \"get-default\") == 0)\n         {\n             char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n-            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             char *ans = cpdbGetDefault(p, option_name);\n             if (!ans)\n@@ -98,7 +98,7 @@\n         else if (strcmp(buf, \"get-setting\") == 0)\n         {\n             char printer_id[BUFSIZE], backend_name[BUFSIZE], setting_name[BUFSIZE];\n-            scanf(\"%s%s%s\", setting_name, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", setting_name, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             char *ans = cpdbGetSetting(p, setting_name);\n             if (!ans)\n@@ -109,7 +109,7 @@\n         else if (strcmp(buf, \"get-current\") == 0)\n         {\n             char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n-            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             char *ans = cpdbGetCurrent(p, option_name);\n             if (!ans)\n@@ -120,7 +120,7 @@\n         else if (strcmp(buf, \"add-setting\") == 0)\n         {\n             char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE], option_val[BUFSIZE];\n-            scanf(\"%s %s %s %s\", option_name, option_val, printer_id, backend_name);\n+            scanf(\"%1023s %1023s %1023s %1023s\", option_name, option_val, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             printf(\"%s : %s\\n\", option_name, option_val);\n             cpdbAddSettingToPrinter(p, cpdbGetStringCopy(option_name), cpdbGetStringCopy(option_val));\n@@ -128,7 +128,7 @@\n         else if (strcmp(buf, \"clear-setting\") == 0)\n         {\n             char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n-            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             cpdbClearSettingFromPrinter(p, option_name);\n         }\n@@ -136,7 +136,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             printf(\"%s\\n\", cpdbGetState(p));\n         }\n@@ -144,7 +144,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             printf(\"Accepting jobs ? : %d \\n\", cpdbIsAcceptingJobs(p));\n         }\n@@ -155,7 +155,7 @@\n         else if (strcmp(buf, \"ping\") == 0)\n         {\n             char printer_id[BUFSIZE], backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             print_backend_call_ping_sync(p->backend_proxy, p->id, NULL, NULL);\n         }\n@@ -170,7 +170,7 @@\n         else if (strcmp(buf, \"get-default-printer-for-backend\") == 0)\n         {\n             char backend_name[BUFSIZE];\n-            scanf(\"%s\", backend_name);\n+            scanf(\"%1023s\", backend_name);\n             /**\n              * Backend name = The last part of the backend dbus service\n              * Eg. \"CUPS\" or \"GCP\"\n@@ -182,7 +182,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             if (p)\n             {\n@@ -196,7 +196,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             if (p)\n             {\n@@ -209,7 +209,7 @@\n         else if (strcmp(buf, \"print-file\") == 0)\n         {\n             char printer_id[BUFSIZE], backend_name[BUFSIZE], file_path[BUFSIZE];\n-            scanf(\"%s%s%s\", file_path, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", file_path, printer_id, backend_name);\n             /**\n              * Try adding some settings here .. change them and experiment\n              */\n@@ -219,7 +219,7 @@\n             {\n               char final_file_path[BUFSIZE];\n               printf(\"Please give the final file path: \");\n-              scanf(\"%s\", final_file_path);\n+              scanf(\"%1023s\", final_file_path);\n               cpdbPrintFilePath(p, file_path, final_file_path);\n               continue;\n             }\n@@ -231,7 +231,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             printf(\"%d jobs currently active.\\n\", cpdbGetActiveJobsCount(p));\n         }\n@@ -253,7 +253,7 @@\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n             char job_id[BUFSIZE];\n-            scanf(\"%s%s%s\", job_id, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", job_id, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             if (cpdbCancelJob(p, job_id))\n                 printf(\"cpdb_job_t %s has been cancelled.\\n\", job_id);\n@@ -265,7 +265,7 @@\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n             char job_id[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             cpdbPicklePrinterToFile(p, \"/tmp/.printer-pickle\", f);\n         }\n@@ -274,7 +274,7 @@\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n             char option_name[BUFSIZE];\n-            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             printf(\"%s\\n\", cpdbGetOptionTranslation(p, option_name, locale));\n         }\n@@ -284,7 +284,7 @@\n             char backend_name[BUFSIZE];\n             char option_name[BUFSIZE];\n             char choice_name[BUFSIZE];\n-            scanf(\"%s%s%s%s\", option_name, choice_name, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s%1023s\", option_name, choice_name, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             printf(\"%s\\n\", cpdbGetChoiceTranslation(p, option_name, choice_name, locale));\n         }\n@@ -293,7 +293,7 @@\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n             char group_name[BUFSIZE];\n-            scanf(\"%s%s%s\", group_name, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", group_name, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             printf(\"%s\\n\", cpdbGetGroupTranslation(p, group_name, locale));\n         }\n@@ -301,7 +301,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             cpdbGetAllTranslations(p, locale);\n             printTranslations(p);\n@@ -312,7 +312,7 @@\n             char backend_name[BUFSIZE];\n             char media[BUFSIZE];\n             int width, length;\n-            scanf(\"%s%s%s\", media, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", media, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             int ok = cpdbGetMediaSize(p, media, &width, &length);\n             if (ok)\n@@ -323,7 +323,7 @@\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n             char media[BUFSIZE];\n-            scanf(\"%s%s%s\", media, printer_id, backend_name);\n+            scanf(\"%1023s%1023s%1023s\", media, printer_id, backend_name);\n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n \n             cpdb_margin_t *margins;\n@@ -335,7 +335,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             \n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             if(p == NULL)\n@@ -348,7 +348,7 @@\n         {\n             char printer_id[BUFSIZE];\n             char backend_name[BUFSIZE];\n-            scanf(\"%s%s\", printer_id, backend_name);\n+            scanf(\"%1023s%1023s\", printer_id, backend_name);\n             \n             cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n             if(p == NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "        scanf(\"%s\", buf);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s%s\", option_name, printer_id, backend_name);",
                "            scanf(\"%s%s%s\", setting_name, printer_id, backend_name);",
                "            scanf(\"%s%s%s\", option_name, printer_id, backend_name);",
                "            scanf(\"%s %s %s %s\", option_name, option_val, printer_id, backend_name);",
                "            scanf(\"%s%s%s\", option_name, printer_id, backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s\", backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s%s\", file_path, printer_id, backend_name);",
                "              scanf(\"%s\", final_file_path);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s%s\", job_id, printer_id, backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s%s\", option_name, printer_id, backend_name);",
                "            scanf(\"%s%s%s%s\", option_name, choice_name, printer_id, backend_name);",
                "            scanf(\"%s%s%s\", group_name, printer_id, backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s%s\", media, printer_id, backend_name);",
                "            scanf(\"%s%s%s\", media, printer_id, backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);",
                "            scanf(\"%s%s\", printer_id, backend_name);"
            ],
            "added_lines": [
                "        scanf(\"%1023s\", buf);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", setting_name, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);",
                "            scanf(\"%1023s %1023s %1023s %1023s\", option_name, option_val, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s\", backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", file_path, printer_id, backend_name);",
                "              scanf(\"%1023s\", final_file_path);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", job_id, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s%1023s\", option_name, choice_name, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", group_name, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", media, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s%1023s\", media, printer_id, backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);",
                "            scanf(\"%1023s%1023s\", printer_id, backend_name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-34095",
        "func_name": "OpenPrinting/cpdb-libs/cpdbCreateBackendFromFile",
        "description": "cpdb-libs provides frontend and backend libraries for the Common Printing Dialog Backends (CPDB) project. In versions 1.0 through 2.0b4, cpdb-libs is vulnerable to buffer overflows via improper use of `scanf(3)`. cpdb-libs uses the `fscanf()` and `scanf()` functions to parse command lines and configuration files, dropping the read string components into fixed-length buffers, but does not limit the length of the strings to be read by `fscanf()` and `scanf()` causing buffer overflows when a string is longer than 1023 characters. A patch for this issue is available at commit f181bd1f14757c2ae0f17cc76dc20421a40f30b7. As all buffers have a length of 1024 characters, the patch limits the maximum string length to be read to 1023 by replacing all occurrences of `%s` with `%1023s` in all calls of the `fscanf()` and `scanf()` functions.\n",
        "git_url": "https://github.com/OpenPrinting/cpdb-libs/commit/f181bd1f14757c2ae0f17cc76dc20421a40f30b7",
        "commit_title": "Merge pull request from GHSA-25j7-9gfc-f46x",
        "commit_text": " cpdb-libs uses the fscanf() and scanf() functions to parse command lines and configuration files, dropping the read string components into fixed-length buffers, but does not limit the length of the strings to be read by fscanf() and scanf() causing buffer overflows when a string is longer than 1023 characters.  As all buffers have a length of 1024 characters we limit the maximum string length to be read to 1023 by replaceing all occurences of \"%s\" by \"%1023s\" in all calls of the fscanf() and scanf() functions.  Simply done by  perl -p -i -e 's/(scanf\\(.*?\".*?)%s/\\1%1023s/' cpdb/cpdb-frontend.c tools/cpdb-text-frontend.c  and verifying with  grep scanf */*.c",
        "func_before": "PrintBackend *cpdbCreateBackendFromFile(GDBusConnection *connection,\n                                        const char *backend_file_name)\n{\n    FILE *file = NULL;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    char *path, *backend_name;\n    const char *info_dir_name;\n    char obj_path[CPDB_BSIZE];\n    \n    backend_name = cpdbGetStringCopy(backend_file_name);\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    \n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    \n    proxy = print_backend_proxy_new_sync(connection,\n                                         0,\n                                         backend_name,\n                                         obj_path,\n                                         NULL,\n                                         &error);\n    if (error)\n    {\n        logerror(\"Error creating backend proxy for %s : %s\\n\",\n                    backend_name, error->message);\n        return NULL;\n    }\n    \n    return proxy;\n}",
        "func": "PrintBackend *cpdbCreateBackendFromFile(GDBusConnection *connection,\n                                        const char *backend_file_name)\n{\n    FILE *file = NULL;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    char *path, *backend_name;\n    const char *info_dir_name;\n    char obj_path[CPDB_BSIZE];\n    \n    backend_name = cpdbGetStringCopy(backend_file_name);\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    \n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%1023s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    \n    proxy = print_backend_proxy_new_sync(connection,\n                                         0,\n                                         backend_name,\n                                         obj_path,\n                                         NULL,\n                                         &error);\n    if (error)\n    {\n        logerror(\"Error creating backend proxy for %s : %s\\n\",\n                    backend_name, error->message);\n        return NULL;\n    }\n    \n    return proxy;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n         free(path);\n         return NULL;\n     }\n-    if (fscanf(file, \"%s\", obj_path) == 0)\n+    if (fscanf(file, \"%1023s\", obj_path) == 0)\n     {\n         logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                     backend_name, path);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (fscanf(file, \"%s\", obj_path) == 0)"
            ],
            "added_lines": [
                "    if (fscanf(file, \"%1023s\", obj_path) == 0)"
            ]
        }
    }
]