[
    {
        "cve_id": "CVE-2022-1975",
        "func_name": "torvalds/linux/nfc_genl_fw_download_done",
        "description": "There is a sleep-in-atomic bug in /net/nfc/netlink.c that allows an attacker to crash the Linux kernel by simulating a nfc device from user-space.",
        "git_url": "https://github.com/torvalds/linux/commit/4071bf121d59944d5cd2238de0642f3d7995a997",
        "commit_title": "NFC: netlink: fix sleep in atomic bug when firmware download timeout",
        "commit_text": " There are sleep in atomic bug that could cause kernel panic during firmware download process. The root cause is that nlmsg_new with GFP_KERNEL parameter is called in fw_dnld_timeout which is a timer handler. The call trace is shown below:  BUG: sleeping function called from invalid context at include/linux/sched/mm.h:265 Call Trace: kmem_cache_alloc_node __alloc_skb nfc_genl_fw_download_done call_timer_fn __run_timers.part.0 run_timer_softirq __do_softirq ...  The nlmsg_new with GFP_KERNEL parameter may sleep during memory allocation process, and the timer handler is run as the result of a \"software interrupt\" that should not call any other function that could sleep.  This patch changes allocation mode of netlink message from GFP_KERNEL to GFP_ATOMIC in order to prevent sleep in atomic bug. The GFP_ATOMIC flag makes memory allocation operation could be used in atomic context.  Link: https://lore.kernel.org/r/20220504055847.38026-1-duoming@zju.edu.cn",
        "func_before": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}",
        "func": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \tstruct sk_buff *msg;\n \tvoid *hdr;\n \n-\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n+\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n \tif (!msg)\n \t\treturn -ENOMEM;\n \n@@ -20,7 +20,7 @@\n \n \tgenlmsg_end(msg, hdr);\n \n-\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n+\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n \n \treturn 0;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);",
                "\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);"
            ],
            "added_lines": [
                "\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);",
                "\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-6019",
        "func_name": "ValveSoftware/GameNetworkingSockets/CConnectionTransportUDPBase::Received_Data",
        "description": "Valve's Game Networking Sockets prior to version v1.2.0 improperly handles inlined statistics messages in function CConnectionTransportUDPBase::Received_Data(), leading to an exception thrown from libprotobuf and resulting in a crash.",
        "git_url": "https://github.com/ValveSoftware/GameNetworkingSockets/commit/d944a10808891d202bb1d5e1998de6e0423af678",
        "commit_title": "Tweak pointer math to avoid possible integer overflow",
        "commit_text": "",
        "func_before": "void CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\n\tif ( cbPkt < sizeof(UDPDataMsgHdr) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Packet of size %d is too small.\", cbPkt );\n\t\treturn;\n\t}\n\n\t// Check cookie\n\tconst UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;\n\tif ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )\n\t{\n\n\t\t// Wrong session.  It could be an old session, or it could be spoofed.\n\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Incorrect connection ID\" );\n\t\tif ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t{\n\t\t\tSendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );\n\t\t}\n\t\treturn;\n\t}\n\tuint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// Ignore it.  We don't have the SteamID of whoever is on the other end yet,\n\t\t\t// their encryption keys, etc.  The most likely cause is that a server sent\n\t\t\t// a ConnectOK, which dropped.  So they think we're connected but we don't\n\t\t\t// have everything yet.\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP, but might be used for derived class\n\n\t\t\t// We'll process the chunk\n\t\t\tbreak;\n\t}\n\n\tconst uint8 *pIn = pPkt + sizeof(*hdr);\n\tconst uint8 *pPktEnd = pPkt + cbPkt;\n\n\t// Inline stats?\n\tstatic CMsgSteamSockets_UDP_Stats msgStats;\n\tCMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;\n\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \"Received inline stats from %s\", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );\n\t\t\treturn;\n\t\t}\n\t\tif ( pIn + cbStatsMsgIn > pPktEnd )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %d, packet size %d\", cbStatsMsgIn, cbPkt );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"protobuf failed to parse inline stats message\" );\n\t\t\treturn;\n\t\t}\n\n\t\t// Shove sequence number so we know what acks to pend, etc\n\t\tpMsgStatsIn = &msgStats;\n\n\t\t// Advance pointer\n\t\tpIn += cbStatsMsgIn;\n\t}\n\n\tconst void *pChunk = pIn;\n\tint cbChunk = pPktEnd - pIn;\n\n\t// Decrypt it, and check packet number\n\tUDPRecvPacketContext_t ctx;\n\tctx.m_usecNow = usecNow;\n\tctx.m_pTransport = this;\n\tctx.m_pStatsIn = pMsgStatsIn;\n\tif ( !m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, ctx ) )\n\t\treturn;\n\n\t// This is a valid packet.  P2P connections might want to make a note of this\n\tRecvValidUDPDataPacket( ctx );\n\n\t// Process plaintext\n\tint usecTimeSinceLast = 0; // FIXME - should we plumb this through so we can measure jitter?\n\tif ( !m_connection.ProcessPlainTextDataChunk( usecTimeSinceLast, ctx ) )\n\t\treturn;\n\n\t// Process the stats, if any\n\tif ( pMsgStatsIn )\n\t\tRecvStats( *pMsgStatsIn, usecNow );\n}",
        "func": "void CConnectionTransportUDPBase::Received_Data( const uint8 *pPkt, int cbPkt, SteamNetworkingMicroseconds usecNow )\n{\n\n\tif ( cbPkt < sizeof(UDPDataMsgHdr) )\n\t{\n\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Packet of size %d is too small.\", cbPkt );\n\t\treturn;\n\t}\n\n\t// Check cookie\n\tconst UDPDataMsgHdr *hdr = (const UDPDataMsgHdr *)pPkt;\n\tif ( LittleDWord( hdr->m_unToConnectionID ) != ConnectionIDLocal() )\n\t{\n\n\t\t// Wrong session.  It could be an old session, or it could be spoofed.\n\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Incorrect connection ID\" );\n\t\tif ( BCheckGlobalSpamReplyRateLimit( usecNow ) )\n\t\t{\n\t\t\tSendNoConnection( LittleDWord( hdr->m_unToConnectionID ), 0 );\n\t\t}\n\t\treturn;\n\t}\n\tuint16 nWirePktNumber = LittleWord( hdr->m_unSeqNum );\n\n\t// Check state\n\tswitch ( ConnectionState() )\n\t{\n\t\tcase k_ESteamNetworkingConnectionState_Dead:\n\t\tcase k_ESteamNetworkingConnectionState_None:\n\t\tdefault:\n\t\t\tAssert( false );\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_ClosedByPeer:\n\t\tcase k_ESteamNetworkingConnectionState_FinWait:\n\t\tcase k_ESteamNetworkingConnectionState_ProblemDetectedLocally:\n\t\t\tSendConnectionClosedOrNoConnection();\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Connecting:\n\t\t\t// Ignore it.  We don't have the SteamID of whoever is on the other end yet,\n\t\t\t// their encryption keys, etc.  The most likely cause is that a server sent\n\t\t\t// a ConnectOK, which dropped.  So they think we're connected but we don't\n\t\t\t// have everything yet.\n\t\t\treturn;\n\n\t\tcase k_ESteamNetworkingConnectionState_Linger:\n\t\tcase k_ESteamNetworkingConnectionState_Connected:\n\t\tcase k_ESteamNetworkingConnectionState_FindingRoute: // not used for raw UDP, but might be used for derived class\n\n\t\t\t// We'll process the chunk\n\t\t\tbreak;\n\t}\n\n\tconst uint8 *pIn = pPkt + sizeof(*hdr);\n\tconst uint8 *pPktEnd = pPkt + cbPkt;\n\n\t// Inline stats?\n\tstatic CMsgSteamSockets_UDP_Stats msgStats;\n\tCMsgSteamSockets_UDP_Stats *pMsgStatsIn = nullptr;\n\tuint32 cbStatsMsgIn = 0;\n\tif ( hdr->m_unMsgFlags & hdr->kFlag_ProtobufBlob )\n\t{\n\t\t//Msg_Verbose( \"Received inline stats from %s\", server.m_szName );\n\n\t\tpIn = DeserializeVarInt( pIn, pPktEnd, cbStatsMsgIn );\n\t\tif ( pIn == NULL )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );\n\t\t\treturn;\n\t\t}\n\t\tif ( cbStatsMsgIn > pPktEnd - pIn )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %u, packet size %d\", cbStatsMsgIn, cbPkt );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !msgStats.ParseFromArray( pIn, cbStatsMsgIn ) )\n\t\t{\n\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"protobuf failed to parse inline stats message\" );\n\t\t\treturn;\n\t\t}\n\n\t\t// Shove sequence number so we know what acks to pend, etc\n\t\tpMsgStatsIn = &msgStats;\n\n\t\t// Advance pointer\n\t\tpIn += cbStatsMsgIn;\n\t}\n\n\tconst void *pChunk = pIn;\n\tint cbChunk = pPktEnd - pIn;\n\n\t// Decrypt it, and check packet number\n\tUDPRecvPacketContext_t ctx;\n\tctx.m_usecNow = usecNow;\n\tctx.m_pTransport = this;\n\tctx.m_pStatsIn = pMsgStatsIn;\n\tif ( !m_connection.DecryptDataChunk( nWirePktNumber, cbPkt, pChunk, cbChunk, ctx ) )\n\t\treturn;\n\n\t// This is a valid packet.  P2P connections might want to make a note of this\n\tRecvValidUDPDataPacket( ctx );\n\n\t// Process plaintext\n\tint usecTimeSinceLast = 0; // FIXME - should we plumb this through so we can measure jitter?\n\tif ( !m_connection.ProcessPlainTextDataChunk( usecTimeSinceLast, ctx ) )\n\t\treturn;\n\n\t// Process the stats, if any\n\tif ( pMsgStatsIn )\n\t\tRecvStats( *pMsgStatsIn, usecNow );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,9 +69,9 @@\n \t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"Failed to varint decode size of stats blob\" );\n \t\t\treturn;\n \t\t}\n-\t\tif ( pIn + cbStatsMsgIn > pPktEnd )\n+\t\tif ( cbStatsMsgIn > pPktEnd - pIn )\n \t\t{\n-\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %d, packet size %d\", cbStatsMsgIn, cbPkt );\n+\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %u, packet size %d\", cbStatsMsgIn, cbPkt );\n \t\t\treturn;\n \t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif ( pIn + cbStatsMsgIn > pPktEnd )",
                "\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %d, packet size %d\", cbStatsMsgIn, cbPkt );"
            ],
            "added_lines": [
                "\t\tif ( cbStatsMsgIn > pPktEnd - pIn )",
                "\t\t\tReportBadUDPPacketFromConnectionPeer( \"DataPacket\", \"stats message size doesn't make sense.  Stats message size %u, packet size %d\", cbStatsMsgIn, cbPkt );"
            ]
        }
    }
]