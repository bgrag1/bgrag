[
    {
        "cve_id": "CVE-2019-15162",
        "func_name": "the-tcpdump-group/libpcap/daemon_AuthUserPwd",
        "description": "rpcapd/daemon.c in libpcap before 1.9.1 on non-Windows platforms provides details about why authentication failed, which might make it easier for attackers to enumerate valid usernames.",
        "git_url": "https://github.com/the-tcpdump-group/libpcap/commit/484d60cbf7ca4ec758c3cbb8a82d68b244a78d58",
        "commit_title": "On UN*X, don't tell the client why authentication failed.",
        "commit_text": " \"no such user\" tells the client that the user ID isn't valid and, therefore, that it needn't bother trying to do password cracking for that user ID; just saying that the authentication failed dosn't give them that hint.  This resolves the third problem in Include Security issue F11: [libpcap] Remote Packet Capture Daemon Multiple Authentication Improvements.  The Windows LogonUser() API returns ERROR_LOGON_FAILURE for both cases, so the Windows code doesn't have this issue.  Just return the same \"Authentication failed\" message on Windows to the user.  For various authentication failures *other* than \"no such user\" and \"password not valid\", log a message, as there's a problem that may need debugging.  We don't need to tell the end user what the problem is, as they may not bother reporting it and, even if they do, they may not give the full error message.",
        "func_before": "static int\ndaemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \"Act as part of the Operating System\"\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tchar *crypt_password;\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setgid\");\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}",
        "func": "static int\ndaemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \"Act as part of the Operating System\"\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tDWORD error;\n\tHANDLE Token;\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to log\n\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\terror = GetLastError();\n\t\tif (error != ERROR_LOGON_FAILURE)\n\t\t{\n\t\t\t// Some error other than an authentication error;\n\t\t\t// log it.\n\t\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, error, \"LogonUser() failed\");\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n\t\t}\t\t\t    \n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tint error;\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tchar *crypt_password;\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\t//\n\t// The Single UNIX Specification says that if crypt() fails it\n\t// sets errno, but some implementatons that haven't been run\n\t// through the SUS test suite might not do so.\n\t//\n\terrno = 0;\n\tcrypt_password = crypt(password, user_password);\n\tif (crypt_password == NULL)\n\t{\n\t\terror = errno;\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\tif (error == 0)\n\t\t{\n\t\t\t// It didn't set errno.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed: %s\",\n\t\t\t    strerror(error));\n\t\t}\n\t\treturn -1;\n\t}\n\tif (strcmp(user_password, crypt_password) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\terror = errno;\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    error, \"setuid\");\n\t\trpcapd_log(LOGPRIO_ERROR, \"setuid() failed: %s\",\n\t\t    strerror(error));\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\terror = errno;\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setgid\");\n\t\trpcapd_log(LOGPRIO_ERROR, \"setgid() failed: %s\",\n\t\t    strerror(error));\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,11 +20,22 @@\n \t * stop trying to log in with a given user name and move on\n \t * to another user name.\n \t */\n+\tDWORD error;\n \tHANDLE Token;\n+\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to log\n+\n \tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n \t{\n-\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t    GetLastError(), \"LogonUser() failed\");\n+\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n+\t\terror = GetLastError();\n+\t\tif (error != ERROR_LOGON_FAILURE)\n+\t\t{\n+\t\t\t// Some error other than an authentication error;\n+\t\t\t// log it.\n+\t\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf,\n+\t\t\t    PCAP_ERRBUF_SIZE, error, \"LogonUser() failed\");\n+\t\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n+\t\t}\t\t\t    \n \t\treturn -1;\n \t}\n \n@@ -32,8 +43,10 @@\n \t// I didn't test it.\n \tif (ImpersonateLoggedOnUser(Token) == 0)\n \t{\n-\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n+\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n+\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,\n \t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n+\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n \t\tCloseHandle(Token);\n \t\treturn -1;\n \t}\n@@ -61,6 +74,7 @@\n \t * only password database or some other authentication mechanism,\n \t * behind its API.\n \t */\n+\tint error;\n \tstruct passwd *user;\n \tchar *user_password;\n #ifdef HAVE_GETSPNAM\n@@ -71,7 +85,7 @@\n \t// This call is needed to get the uid\n \tif ((user = getpwnam(username)) == NULL)\n \t{\n-\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n+\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n \t\treturn -1;\n \t}\n \n@@ -79,7 +93,7 @@\n \t// This call is needed to get the password; otherwise 'x' is returned\n \tif ((usersp = getspnam(username)) == NULL)\n \t{\n-\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n+\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n \t\treturn -1;\n \t}\n \tuser_password = usersp->sp_pwdp;\n@@ -97,29 +111,52 @@\n \tuser_password = user->pw_passwd;\n #endif\n \n+\t//\n+\t// The Single UNIX Specification says that if crypt() fails it\n+\t// sets errno, but some implementatons that haven't been run\n+\t// through the SUS test suite might not do so.\n+\t//\n+\terrno = 0;\n \tcrypt_password = crypt(password, user_password);\n \tif (crypt_password == NULL)\n \t{\n+\t\terror = errno;\n \t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n+\t\tif (error == 0)\n+\t\t{\n+\t\t\t// It didn't set errno.\n+\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed\");\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed: %s\",\n+\t\t\t    strerror(error));\n+\t\t}\n \t\treturn -1;\n \t}\n \tif (strcmp(user_password, crypt_password) != 0)\n \t{\n-\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n+\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");\n \t\treturn -1;\n \t}\n \n \tif (setuid(user->pw_uid))\n \t{\n+\t\terror = errno;\n \t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n-\t\t    errno, \"setuid\");\n+\t\t    error, \"setuid\");\n+\t\trpcapd_log(LOGPRIO_ERROR, \"setuid() failed: %s\",\n+\t\t    strerror(error));\n \t\treturn -1;\n \t}\n \n /*\tif (setgid(user->pw_gid))\n \t{\n+\t\terror = errno;\n \t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n \t\t    errno, \"setgid\");\n+\t\trpcapd_log(LOGPRIO_ERROR, \"setgid() failed: %s\",\n+\t\t    strerror(error));\n \t\treturn -1;\n \t}\n */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,",
                "\t\t    GetLastError(), \"LogonUser() failed\");",
                "\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,",
                "\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");",
                "\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");",
                "\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");",
                "\t\t    errno, \"setuid\");"
            ],
            "added_lines": [
                "\tDWORD error;",
                "\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to log",
                "",
                "\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");",
                "\t\terror = GetLastError();",
                "\t\tif (error != ERROR_LOGON_FAILURE)",
                "\t\t{",
                "\t\t\t// Some error other than an authentication error;",
                "\t\t\t// log it.",
                "\t\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf,",
                "\t\t\t    PCAP_ERRBUF_SIZE, error, \"LogonUser() failed\");",
                "\t\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);",
                "\t\t}\t\t\t    ",
                "\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");",
                "\t\tpcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,",
                "\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);",
                "\tint error;",
                "\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");",
                "\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");",
                "\t//",
                "\t// The Single UNIX Specification says that if crypt() fails it",
                "\t// sets errno, but some implementatons that haven't been run",
                "\t// through the SUS test suite might not do so.",
                "\t//",
                "\terrno = 0;",
                "\t\terror = errno;",
                "\t\tif (error == 0)",
                "\t\t{",
                "\t\t\t// It didn't set errno.",
                "\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed\");",
                "\t\t}",
                "\t\telse",
                "\t\t{",
                "\t\t\trpcapd_log(LOGPRIO_ERROR, \"crypt() failed: %s\",",
                "\t\t\t    strerror(error));",
                "\t\t}",
                "\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed\");",
                "\t\terror = errno;",
                "\t\t    error, \"setuid\");",
                "\t\trpcapd_log(LOGPRIO_ERROR, \"setuid() failed: %s\",",
                "\t\t    strerror(error));",
                "\t\terror = errno;",
                "\t\trpcapd_log(LOGPRIO_ERROR, \"setgid() failed: %s\",",
                "\t\t    strerror(error));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-38597",
        "func_name": "wolfSSL/wolfssl/ParseCertRelative",
        "description": "wolfSSL before 4.8.1 incorrectly skips OCSP verification in certain situations of irrelevant response data that contains the NoCheck extension.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/f93083be72a3b3d956b52a7ec13f307a27b6e093",
        "commit_title": "OCSP: improve handling of OCSP no check extension",
        "commit_text": "",
        "func_before": "int ParseCertRelative(DecodedCert* cert, int type, int verify, void* cm)\n{\n    int    ret = 0;\n    int    checkPathLen = 0;\n    int    decrementMaxPathLen = 0;\n    word32 confirmOID = 0;\n#if defined(WOLFSSL_RENESAS_TSIP)\n    int    idx = 0;\n#endif\n    byte*  tsip_encRsaKeyIdx;\n#ifdef WOLFSSL_CERT_REQ\n    int    len = 0;\n#endif\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef WOLFSSL_CERT_REQ\n    if (type == CERTREQ_TYPE)\n        cert->isCSR = 1;\n#endif\n\n    if (cert->sigCtx.state == SIG_STATE_BEGIN) {\n        cert->badDate = 0;\n        cert->criticalExt = 0;\n        if ((ret = DecodeToKey(cert, verify)) < 0) {\n            if (ret == ASN_BEFORE_DATE_E || ret == ASN_AFTER_DATE_E)\n                cert->badDate = ret;\n            else\n                return ret;\n        }\n\n        WOLFSSL_MSG(\"Parsed Past Key\");\n\n\n#ifdef WOLFSSL_CERT_REQ\n        /* Read attributes */\n        if (cert->isCSR) {\n            if (GetASNHeader_ex(cert->source,\n                    ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED, &cert->srcIdx,\n                    &len, cert->maxIdx, 1) < 0) {\n                WOLFSSL_MSG(\"GetASNHeader_ex error\");\n                return ASN_PARSE_E;\n            }\n\n            if (len) {\n                word32 attrMaxIdx = cert->srcIdx + len;\n                word32 oid;\n                byte   tag;\n\n                if (attrMaxIdx > cert->maxIdx) {\n                    WOLFSSL_MSG(\"Attribute length greater than CSR length\");\n                    return ASN_PARSE_E;\n                }\n\n                while (cert->srcIdx < attrMaxIdx) {\n                    /* Attributes have the structure:\n                     * SEQ -> OID -> SET -> ATTRIBUTE */\n                    if (GetSequence(cert->source, &cert->srcIdx, &len,\n                            attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetSequence error\");\n                        return ASN_PARSE_E;\n                    }\n                    if (GetObjectId(cert->source, &cert->srcIdx, &oid,\n                            oidCsrAttrType, attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetObjectId error\");\n                        return ASN_PARSE_E;\n                    }\n                    if (GetSet(cert->source, &cert->srcIdx, &len,\n                            attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetSet error\");\n                        return ASN_PARSE_E;\n                    }\n                    switch (oid) {\n                    case CHALLENGE_PASSWORD_OID:\n                        if (GetHeader(cert->source, &tag,\n                                &cert->srcIdx, &len, attrMaxIdx, 1) < 0) {\n                            WOLFSSL_MSG(\"attr GetHeader error\");\n                            return ASN_PARSE_E;\n                        }\n                        if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&\n                                tag != ASN_IA5_STRING) {\n                            WOLFSSL_MSG(\"Unsupported attribute value format\");\n                            return ASN_PARSE_E;\n                        }\n                        cert->cPwd = (char*)cert->source + cert->srcIdx;\n                        cert->cPwdLen = len;\n                        cert->srcIdx += len;\n                        break;\n                    case SERIAL_NUMBER_OID:\n                        if (GetHeader(cert->source, &tag,\n                                &cert->srcIdx, &len, attrMaxIdx, 1) < 0) {\n                            WOLFSSL_MSG(\"attr GetHeader error\");\n                            return ASN_PARSE_E;\n                        }\n                        if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&\n                                tag != ASN_IA5_STRING) {\n                            WOLFSSL_MSG(\"Unsupported attribute value format\");\n                            return ASN_PARSE_E;\n                        }\n                        cert->sNum = (char*)cert->source + cert->srcIdx;\n                        cert->sNumLen = len;\n                        cert->srcIdx += len;\n                        if (cert->sNumLen <= EXTERNAL_SERIAL_SIZE) {\n                            XMEMCPY(cert->serial, cert->sNum, cert->sNumLen);\n                            cert->serialSz = cert->sNumLen;\n                        }\n                        break;\n                    case EXTENSION_REQUEST_OID:\n                        /* save extensions */\n                        cert->extensions    = &cert->source[cert->srcIdx];\n                        cert->extensionsSz  = len;\n                        cert->extensionsIdx = cert->srcIdx;   /* for potential later use */\n\n                        if ((ret = DecodeCertExtensions(cert)) < 0) {\n                            if (ret == ASN_CRIT_EXT_E)\n                                cert->criticalExt = ret;\n                            else\n                                return ret;\n                        }\n                        cert->srcIdx += len;\n                        break;\n                    default:\n                        WOLFSSL_MSG(\"Unsupported attribute type\");\n                        return ASN_PARSE_E;\n                    }\n                }\n            }\n        }\n#endif\n\n        if (cert->srcIdx < cert->sigIndex) {\n        #ifndef ALLOW_V1_EXTENSIONS\n            if (cert->version < 2) {\n                WOLFSSL_MSG(\"\\tv1 and v2 certs not allowed extensions\");\n                return ASN_VERSION_E;\n            }\n        #endif\n\n            /* save extensions */\n            cert->extensions    = &cert->source[cert->srcIdx];\n            cert->extensionsSz  = cert->sigIndex - cert->srcIdx;\n            cert->extensionsIdx = cert->srcIdx;   /* for potential later use */\n\n            if ((ret = DecodeCertExtensions(cert)) < 0) {\n                if (ret == ASN_CRIT_EXT_E)\n                    cert->criticalExt = ret;\n                else\n                    return ret;\n            }\n\n        #ifdef HAVE_OCSP\n            /* trust for the lifetime of the responder's cert*/\n            if (cert->ocspNoCheckSet && verify == VERIFY_OCSP)\n                verify = NO_VERIFY;\n        #endif\n            /* advance past extensions */\n            cert->srcIdx = cert->sigIndex;\n        }\n\n        if ((ret = GetAlgoId(cert->source, &cert->srcIdx,\n#ifdef WOLFSSL_CERT_REQ\n                !cert->isCSR ? &confirmOID : &cert->signatureOID,\n#else\n                &confirmOID,\n#endif\n                oidSigType, cert->maxIdx)) < 0)\n            return ret;\n\n        if ((ret = GetSignature(cert)) < 0)\n            return ret;\n\n        if (confirmOID != cert->signatureOID\n#ifdef WOLFSSL_CERT_REQ\n                && !cert->isCSR\n#endif\n                )\n            return ASN_SIG_OID_E;\n\n    #ifndef NO_SKID\n        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&\n                                                         cert->pubKeySize > 0) {\n            ret = CalcHashId(cert->publicKey, cert->pubKeySize,\n                                                            cert->extSubjKeyId);\n            if (ret != 0)\n                return ret;\n        }\n    #endif /* !NO_SKID */\n\n        if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&\n                                                   type != TRUSTED_PEER_TYPE)) {\n            cert->ca = NULL;\n    #ifndef NO_SKID\n            if (cert->extAuthKeyIdSet) {\n                cert->ca = GetCA(cm, cert->extAuthKeyId);\n            }\n            if (cert->ca == NULL && cert->extSubjKeyIdSet\n                                 && verify != VERIFY_OCSP) {\n                cert->ca = GetCA(cm, cert->extSubjKeyId);\n            }\n            if (cert->ca != NULL && XMEMCMP(cert->issuerHash,\n                                  cert->ca->subjectNameHash, KEYID_SIZE) != 0) {\n                cert->ca = NULL;\n            }\n            if (cert->ca == NULL) {\n                cert->ca = GetCAByName(cm, cert->issuerHash);\n                /* If AKID is available then this CA doesn't have the public\n                 * key required */\n                if (cert->ca && cert->extAuthKeyIdSet) {\n                    WOLFSSL_MSG(\"CA SKID doesn't match AKID\");\n                    cert->ca = NULL;\n                }\n            }\n\n            /* OCSP Only: alt lookup using subject and pub key w/o sig check */\n        #ifdef WOLFSSL_NO_TRUSTED_CERTS_VERIFY\n            if (cert->ca == NULL && verify == VERIFY_OCSP) {\n                cert->ca = GetCABySubjectAndPubKey(cert, cm);\n                if (cert->ca) {\n                    ret = 0; /* success */\n                    goto exit_pcr;\n                }\n            }\n        #endif /* WOLFSSL_NO_TRUSTED_CERTS_VERIFY */\n    #else\n            cert->ca = GetCA(cm, cert->issuerHash);\n    #endif /* !NO_SKID */\n\n            if (cert->ca) {\n                WOLFSSL_MSG(\"CA found\");\n            }\n        }\n\n        if (cert->selfSigned) {\n            cert->maxPathLen = WOLFSSL_MAX_PATH_LEN;\n        } else {\n            /* RFC 5280 Section 4.2.1.9:\n             *\n             * load/receive check\n             *\n             * 1) Is CA boolean set?\n             *      No  - SKIP CHECK\n             *      Yes - Check key usage\n             * 2) Is Key usage extension present?\n             *      No  - goto 3\n             *      Yes - check keyCertSign assertion\n             *     2.a) Is keyCertSign asserted?\n             *          No  - goto 4\n             *          Yes - goto 3\n             * 3) Is pathLen set?\n             *      No  - goto 4\n             *      Yes - check pathLen against maxPathLen.\n             *      3.a) Is pathLen less than maxPathLen?\n             *           No - goto 4\n             *           Yes - set maxPathLen to pathLen and EXIT\n             * 4) Is maxPathLen > 0?\n             *      Yes - Reduce by 1\n             *      No  - ERROR\n             */\n\n            if (cert->ca && cert->pathLengthSet) {\n                cert->maxPathLen = cert->pathLength;\n                if (cert->isCA) {\n                    WOLFSSL_MSG(\"\\tCA boolean set\");\n                    if (cert->extKeyUsageSet) {\n                         WOLFSSL_MSG(\"\\tExtension Key Usage Set\");\n                         if ((cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0) {\n                            checkPathLen = 1;\n                         } else {\n                            decrementMaxPathLen = 1;\n                         }\n                    } else {\n                        checkPathLen = 1;\n                    } /* !cert->ca check */\n                } /* cert is not a CA (assuming entity cert) */\n\n                if (checkPathLen && cert->pathLengthSet) {\n                    if (cert->pathLength < cert->ca->maxPathLen) {\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: set to pathLength\");\n                        cert->maxPathLen = cert->pathLength;\n                    } else {\n                        decrementMaxPathLen = 1;\n                    }\n                }\n\n                if (decrementMaxPathLen && cert->ca->maxPathLen > 0) {\n                    WOLFSSL_MSG(\"\\tmaxPathLen status: reduce by 1\");\n                    cert->maxPathLen = cert->ca->maxPathLen - 1;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: OK\");\n                    }\n                } else if (decrementMaxPathLen && cert->ca->maxPathLen == 0) {\n                    cert->maxPathLen = 0;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tNon-entity cert, maxPathLen is 0\");\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: ERROR\");\n                        return ASN_PATHLEN_INV_E;\n                    }\n                }\n            } else if (cert->ca && cert->isCA) {\n                /* case where cert->pathLength extension is not set */\n                if (cert->ca->maxPathLen > 0) {\n                    cert->maxPathLen = cert->ca->maxPathLen - 1;\n                } else {\n                    cert->maxPathLen = 0;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tNon-entity cert, maxPathLen is 0\");\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: ERROR\");\n                        return ASN_PATHLEN_INV_E;\n                    }\n                }\n            }\n        }\n\n        #ifdef HAVE_OCSP\n        if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                type != TRUSTED_PEER_TYPE) {\n            if (cert->ca) {\n                /* Need the CA's public key hash for OCSP */\n                XMEMCPY(cert->issuerKeyHash, cert->ca->subjectKeyHash,\n                                                                KEYID_SIZE);\n            }\n        }\n        #endif /* HAVE_OCSP */\n    }\n#if defined(WOLFSSL_RENESAS_TSIP)\n    /* prepare for TSIP TLS cert verification API use */\n    if (cert->keyOID == RSAk) {\n        /* to call TSIP API, it needs keys position info in bytes */\n        if ((ret = RsaPublicKeyDecodeRawIndex(cert->publicKey, (word32*)&idx,\n                                   cert->pubKeySize,\n                                   &cert->sigCtx.pubkey_n_start,\n                                   &cert->sigCtx.pubkey_n_len,\n                                   &cert->sigCtx.pubkey_e_start,\n                                   &cert->sigCtx.pubkey_e_len)) != 0) {\n            WOLFSSL_MSG(\"Decoding index from cert failed.\");\n            return ret;\n        }\n        cert->sigCtx.certBegin = cert->certBegin;\n    }\n    /* check if we can use TSIP for cert verification */\n    /* if the ca is verified as tsip root ca.         */\n    /* TSIP can only handle 2048 bits(256 byte) key.  */\n    if (cert->ca && tsip_checkCA(cert->ca->cm_idx) != 0 &&\n        cert->sigCtx.pubkey_n_len == 256) {\n\n        /* assign memory to encrypted tsip Rsa key index */\n        if (!cert->tsip_encRsaKeyIdx)\n            cert->tsip_encRsaKeyIdx =\n                            (byte*)XMALLOC(TSIP_TLS_ENCPUBKEY_SZ_BY_CERTVRFY,\n                             cert->heap, DYNAMIC_TYPE_RSA);\n        if (cert->tsip_encRsaKeyIdx == NULL)\n                return MEMORY_E;\n    } else {\n        if (cert->ca) {\n            /* TSIP isn't usable */\n            if (tsip_checkCA(cert->ca->cm_idx) == 0)\n                WOLFSSL_MSG(\"TSIP isn't usable because the ca isn't verified \"\n                            \"by TSIP.\");\n            else if (cert->sigCtx.pubkey_n_len != 256)\n                WOLFSSL_MSG(\"TSIP isn't usable because the ca isn't signed by \"\n                            \"RSA 2048.\");\n            else\n                WOLFSSL_MSG(\"TSIP isn't usable\");\n        }\n        cert->tsip_encRsaKeyIdx = NULL;\n    }\n\n    tsip_encRsaKeyIdx = cert->tsip_encRsaKeyIdx;\n#else\n    tsip_encRsaKeyIdx = NULL;\n#endif\n\n    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {\n        if (cert->ca) {\n            if (verify == VERIFY || verify == VERIFY_OCSP ||\n                                                 verify == VERIFY_SKIP_DATE) {\n                /* try to confirm/verify signature */\n                if ((ret = ConfirmSignature(&cert->sigCtx,\n                        cert->source + cert->certBegin,\n                        cert->sigIndex - cert->certBegin,\n                        cert->ca->publicKey, cert->ca->pubKeySize,\n                        cert->ca->keyOID, cert->signature,\n                        cert->sigLength, cert->signatureOID,\n                        tsip_encRsaKeyIdx)) != 0) {\n                    if (ret != WC_PENDING_E) {\n                        WOLFSSL_MSG(\"Confirm signature failed\");\n                    }\n                    return ret;\n                }\n            }\n        #ifndef IGNORE_NAME_CONSTRAINTS\n            if (verify == VERIFY || verify == VERIFY_OCSP ||\n                        verify == VERIFY_NAME || verify == VERIFY_SKIP_DATE) {\n                /* check that this cert's name is permitted by the signer's\n                 * name constraints */\n                if (!ConfirmNameConstraints(cert->ca, cert)) {\n                    WOLFSSL_MSG(\"Confirm name constraint failed\");\n                    return ASN_NAME_INVALID_E;\n                }\n            }\n        #endif /* IGNORE_NAME_CONSTRAINTS */\n        }\n        else {\n            /* no signer */\n            WOLFSSL_MSG(\"No CA signer to verify with\");\n            return ASN_NO_SIGNER_E;\n        }\n    }\n\n#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)\nexit_pcr:\n#endif\n\n    if (cert->badDate != 0) {\n        if (verify != VERIFY_SKIP_DATE) {\n            return cert->badDate;\n        }\n        WOLFSSL_MSG(\"Date error: Verify option is skipping\");\n    }\n\n    if (cert->criticalExt != 0)\n        return cert->criticalExt;\n\n    return ret;\n}",
        "func": "int ParseCertRelative(DecodedCert* cert, int type, int verify, void* cm)\n{\n    int    ret = 0;\n    int    checkPathLen = 0;\n    int    decrementMaxPathLen = 0;\n    word32 confirmOID = 0;\n#if defined(WOLFSSL_RENESAS_TSIP)\n    int    idx = 0;\n#endif\n    byte*  tsip_encRsaKeyIdx;\n#ifdef WOLFSSL_CERT_REQ\n    int    len = 0;\n#endif\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef WOLFSSL_CERT_REQ\n    if (type == CERTREQ_TYPE)\n        cert->isCSR = 1;\n#endif\n\n    if (cert->sigCtx.state == SIG_STATE_BEGIN) {\n        cert->badDate = 0;\n        cert->criticalExt = 0;\n        if ((ret = DecodeToKey(cert, verify)) < 0) {\n            if (ret == ASN_BEFORE_DATE_E || ret == ASN_AFTER_DATE_E)\n                cert->badDate = ret;\n            else\n                return ret;\n        }\n\n        WOLFSSL_MSG(\"Parsed Past Key\");\n\n\n#ifdef WOLFSSL_CERT_REQ\n        /* Read attributes */\n        if (cert->isCSR) {\n            if (GetASNHeader_ex(cert->source,\n                    ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED, &cert->srcIdx,\n                    &len, cert->maxIdx, 1) < 0) {\n                WOLFSSL_MSG(\"GetASNHeader_ex error\");\n                return ASN_PARSE_E;\n            }\n\n            if (len) {\n                word32 attrMaxIdx = cert->srcIdx + len;\n                word32 oid;\n                byte   tag;\n\n                if (attrMaxIdx > cert->maxIdx) {\n                    WOLFSSL_MSG(\"Attribute length greater than CSR length\");\n                    return ASN_PARSE_E;\n                }\n\n                while (cert->srcIdx < attrMaxIdx) {\n                    /* Attributes have the structure:\n                     * SEQ -> OID -> SET -> ATTRIBUTE */\n                    if (GetSequence(cert->source, &cert->srcIdx, &len,\n                            attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetSequence error\");\n                        return ASN_PARSE_E;\n                    }\n                    if (GetObjectId(cert->source, &cert->srcIdx, &oid,\n                            oidCsrAttrType, attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetObjectId error\");\n                        return ASN_PARSE_E;\n                    }\n                    if (GetSet(cert->source, &cert->srcIdx, &len,\n                            attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetSet error\");\n                        return ASN_PARSE_E;\n                    }\n                    switch (oid) {\n                    case CHALLENGE_PASSWORD_OID:\n                        if (GetHeader(cert->source, &tag,\n                                &cert->srcIdx, &len, attrMaxIdx, 1) < 0) {\n                            WOLFSSL_MSG(\"attr GetHeader error\");\n                            return ASN_PARSE_E;\n                        }\n                        if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&\n                                tag != ASN_IA5_STRING) {\n                            WOLFSSL_MSG(\"Unsupported attribute value format\");\n                            return ASN_PARSE_E;\n                        }\n                        cert->cPwd = (char*)cert->source + cert->srcIdx;\n                        cert->cPwdLen = len;\n                        cert->srcIdx += len;\n                        break;\n                    case SERIAL_NUMBER_OID:\n                        if (GetHeader(cert->source, &tag,\n                                &cert->srcIdx, &len, attrMaxIdx, 1) < 0) {\n                            WOLFSSL_MSG(\"attr GetHeader error\");\n                            return ASN_PARSE_E;\n                        }\n                        if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&\n                                tag != ASN_IA5_STRING) {\n                            WOLFSSL_MSG(\"Unsupported attribute value format\");\n                            return ASN_PARSE_E;\n                        }\n                        cert->sNum = (char*)cert->source + cert->srcIdx;\n                        cert->sNumLen = len;\n                        cert->srcIdx += len;\n                        if (cert->sNumLen <= EXTERNAL_SERIAL_SIZE) {\n                            XMEMCPY(cert->serial, cert->sNum, cert->sNumLen);\n                            cert->serialSz = cert->sNumLen;\n                        }\n                        break;\n                    case EXTENSION_REQUEST_OID:\n                        /* save extensions */\n                        cert->extensions    = &cert->source[cert->srcIdx];\n                        cert->extensionsSz  = len;\n                        cert->extensionsIdx = cert->srcIdx;   /* for potential later use */\n\n                        if ((ret = DecodeCertExtensions(cert)) < 0) {\n                            if (ret == ASN_CRIT_EXT_E)\n                                cert->criticalExt = ret;\n                            else\n                                return ret;\n                        }\n                        cert->srcIdx += len;\n                        break;\n                    default:\n                        WOLFSSL_MSG(\"Unsupported attribute type\");\n                        return ASN_PARSE_E;\n                    }\n                }\n            }\n        }\n#endif\n\n        if (cert->srcIdx < cert->sigIndex) {\n        #ifndef ALLOW_V1_EXTENSIONS\n            if (cert->version < 2) {\n                WOLFSSL_MSG(\"\\tv1 and v2 certs not allowed extensions\");\n                return ASN_VERSION_E;\n            }\n        #endif\n\n            /* save extensions */\n            cert->extensions    = &cert->source[cert->srcIdx];\n            cert->extensionsSz  = cert->sigIndex - cert->srcIdx;\n            cert->extensionsIdx = cert->srcIdx;   /* for potential later use */\n\n            if ((ret = DecodeCertExtensions(cert)) < 0) {\n                if (ret == ASN_CRIT_EXT_E)\n                    cert->criticalExt = ret;\n                else\n                    return ret;\n            }\n\n        #ifdef HAVE_OCSP\n            if (verify == VERIFY_OCSP_CERT) {\n                /* trust for the lifetime of the responder's cert*/\n                if (cert->ocspNoCheckSet)\n                    verify = VERIFY;\n                else\n                    verify = VERIFY_OCSP;\n            }\n        #endif\n            /* advance past extensions */\n            cert->srcIdx = cert->sigIndex;\n        }\n\n        if ((ret = GetAlgoId(cert->source, &cert->srcIdx,\n#ifdef WOLFSSL_CERT_REQ\n                !cert->isCSR ? &confirmOID : &cert->signatureOID,\n#else\n                &confirmOID,\n#endif\n                oidSigType, cert->maxIdx)) < 0)\n            return ret;\n\n        if ((ret = GetSignature(cert)) < 0)\n            return ret;\n\n        if (confirmOID != cert->signatureOID\n#ifdef WOLFSSL_CERT_REQ\n                && !cert->isCSR\n#endif\n                )\n            return ASN_SIG_OID_E;\n\n    #ifndef NO_SKID\n        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&\n                                                         cert->pubKeySize > 0) {\n            ret = CalcHashId(cert->publicKey, cert->pubKeySize,\n                                                            cert->extSubjKeyId);\n            if (ret != 0)\n                return ret;\n        }\n    #endif /* !NO_SKID */\n\n        if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&\n                                                   type != TRUSTED_PEER_TYPE)) {\n            cert->ca = NULL;\n    #ifndef NO_SKID\n            if (cert->extAuthKeyIdSet) {\n                cert->ca = GetCA(cm, cert->extAuthKeyId);\n            }\n            if (cert->ca == NULL && cert->extSubjKeyIdSet\n                                 && verify != VERIFY_OCSP) {\n                cert->ca = GetCA(cm, cert->extSubjKeyId);\n            }\n            if (cert->ca != NULL && XMEMCMP(cert->issuerHash,\n                                  cert->ca->subjectNameHash, KEYID_SIZE) != 0) {\n                cert->ca = NULL;\n            }\n            if (cert->ca == NULL) {\n                cert->ca = GetCAByName(cm, cert->issuerHash);\n                /* If AKID is available then this CA doesn't have the public\n                 * key required */\n                if (cert->ca && cert->extAuthKeyIdSet) {\n                    WOLFSSL_MSG(\"CA SKID doesn't match AKID\");\n                    cert->ca = NULL;\n                }\n            }\n\n            /* OCSP Only: alt lookup using subject and pub key w/o sig check */\n        #ifdef WOLFSSL_NO_TRUSTED_CERTS_VERIFY\n            if (cert->ca == NULL && verify == VERIFY_OCSP) {\n                cert->ca = GetCABySubjectAndPubKey(cert, cm);\n                if (cert->ca) {\n                    ret = 0; /* success */\n                    goto exit_pcr;\n                }\n            }\n        #endif /* WOLFSSL_NO_TRUSTED_CERTS_VERIFY */\n    #else\n            cert->ca = GetCA(cm, cert->issuerHash);\n    #endif /* !NO_SKID */\n\n            if (cert->ca) {\n                WOLFSSL_MSG(\"CA found\");\n            }\n        }\n\n        if (cert->selfSigned) {\n            cert->maxPathLen = WOLFSSL_MAX_PATH_LEN;\n        } else {\n            /* RFC 5280 Section 4.2.1.9:\n             *\n             * load/receive check\n             *\n             * 1) Is CA boolean set?\n             *      No  - SKIP CHECK\n             *      Yes - Check key usage\n             * 2) Is Key usage extension present?\n             *      No  - goto 3\n             *      Yes - check keyCertSign assertion\n             *     2.a) Is keyCertSign asserted?\n             *          No  - goto 4\n             *          Yes - goto 3\n             * 3) Is pathLen set?\n             *      No  - goto 4\n             *      Yes - check pathLen against maxPathLen.\n             *      3.a) Is pathLen less than maxPathLen?\n             *           No - goto 4\n             *           Yes - set maxPathLen to pathLen and EXIT\n             * 4) Is maxPathLen > 0?\n             *      Yes - Reduce by 1\n             *      No  - ERROR\n             */\n\n            if (cert->ca && cert->pathLengthSet) {\n                cert->maxPathLen = cert->pathLength;\n                if (cert->isCA) {\n                    WOLFSSL_MSG(\"\\tCA boolean set\");\n                    if (cert->extKeyUsageSet) {\n                         WOLFSSL_MSG(\"\\tExtension Key Usage Set\");\n                         if ((cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0) {\n                            checkPathLen = 1;\n                         } else {\n                            decrementMaxPathLen = 1;\n                         }\n                    } else {\n                        checkPathLen = 1;\n                    } /* !cert->ca check */\n                } /* cert is not a CA (assuming entity cert) */\n\n                if (checkPathLen && cert->pathLengthSet) {\n                    if (cert->pathLength < cert->ca->maxPathLen) {\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: set to pathLength\");\n                        cert->maxPathLen = cert->pathLength;\n                    } else {\n                        decrementMaxPathLen = 1;\n                    }\n                }\n\n                if (decrementMaxPathLen && cert->ca->maxPathLen > 0) {\n                    WOLFSSL_MSG(\"\\tmaxPathLen status: reduce by 1\");\n                    cert->maxPathLen = cert->ca->maxPathLen - 1;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: OK\");\n                    }\n                } else if (decrementMaxPathLen && cert->ca->maxPathLen == 0) {\n                    cert->maxPathLen = 0;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tNon-entity cert, maxPathLen is 0\");\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: ERROR\");\n                        return ASN_PATHLEN_INV_E;\n                    }\n                }\n            } else if (cert->ca && cert->isCA) {\n                /* case where cert->pathLength extension is not set */\n                if (cert->ca->maxPathLen > 0) {\n                    cert->maxPathLen = cert->ca->maxPathLen - 1;\n                } else {\n                    cert->maxPathLen = 0;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tNon-entity cert, maxPathLen is 0\");\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: ERROR\");\n                        return ASN_PATHLEN_INV_E;\n                    }\n                }\n            }\n        }\n\n        #ifdef HAVE_OCSP\n        if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                type != TRUSTED_PEER_TYPE) {\n            if (cert->ca) {\n                /* Need the CA's public key hash for OCSP */\n                XMEMCPY(cert->issuerKeyHash, cert->ca->subjectKeyHash,\n                                                                KEYID_SIZE);\n            }\n        }\n        #endif /* HAVE_OCSP */\n    }\n#if defined(WOLFSSL_RENESAS_TSIP)\n    /* prepare for TSIP TLS cert verification API use */\n    if (cert->keyOID == RSAk) {\n        /* to call TSIP API, it needs keys position info in bytes */\n        if ((ret = RsaPublicKeyDecodeRawIndex(cert->publicKey, (word32*)&idx,\n                                   cert->pubKeySize,\n                                   &cert->sigCtx.pubkey_n_start,\n                                   &cert->sigCtx.pubkey_n_len,\n                                   &cert->sigCtx.pubkey_e_start,\n                                   &cert->sigCtx.pubkey_e_len)) != 0) {\n            WOLFSSL_MSG(\"Decoding index from cert failed.\");\n            return ret;\n        }\n        cert->sigCtx.certBegin = cert->certBegin;\n    }\n    /* check if we can use TSIP for cert verification */\n    /* if the ca is verified as tsip root ca.         */\n    /* TSIP can only handle 2048 bits(256 byte) key.  */\n    if (cert->ca && tsip_checkCA(cert->ca->cm_idx) != 0 &&\n        cert->sigCtx.pubkey_n_len == 256) {\n\n        /* assign memory to encrypted tsip Rsa key index */\n        if (!cert->tsip_encRsaKeyIdx)\n            cert->tsip_encRsaKeyIdx =\n                            (byte*)XMALLOC(TSIP_TLS_ENCPUBKEY_SZ_BY_CERTVRFY,\n                             cert->heap, DYNAMIC_TYPE_RSA);\n        if (cert->tsip_encRsaKeyIdx == NULL)\n                return MEMORY_E;\n    } else {\n        if (cert->ca) {\n            /* TSIP isn't usable */\n            if (tsip_checkCA(cert->ca->cm_idx) == 0)\n                WOLFSSL_MSG(\"TSIP isn't usable because the ca isn't verified \"\n                            \"by TSIP.\");\n            else if (cert->sigCtx.pubkey_n_len != 256)\n                WOLFSSL_MSG(\"TSIP isn't usable because the ca isn't signed by \"\n                            \"RSA 2048.\");\n            else\n                WOLFSSL_MSG(\"TSIP isn't usable\");\n        }\n        cert->tsip_encRsaKeyIdx = NULL;\n    }\n\n    tsip_encRsaKeyIdx = cert->tsip_encRsaKeyIdx;\n#else\n    tsip_encRsaKeyIdx = NULL;\n#endif\n\n    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {\n        if (cert->ca) {\n            if (verify == VERIFY || verify == VERIFY_OCSP ||\n                                                 verify == VERIFY_SKIP_DATE) {\n                /* try to confirm/verify signature */\n                if ((ret = ConfirmSignature(&cert->sigCtx,\n                        cert->source + cert->certBegin,\n                        cert->sigIndex - cert->certBegin,\n                        cert->ca->publicKey, cert->ca->pubKeySize,\n                        cert->ca->keyOID, cert->signature,\n                        cert->sigLength, cert->signatureOID,\n                        tsip_encRsaKeyIdx)) != 0) {\n                    if (ret != WC_PENDING_E) {\n                        WOLFSSL_MSG(\"Confirm signature failed\");\n                    }\n                    return ret;\n                }\n            }\n        #ifndef IGNORE_NAME_CONSTRAINTS\n            if (verify == VERIFY || verify == VERIFY_OCSP ||\n                        verify == VERIFY_NAME || verify == VERIFY_SKIP_DATE) {\n                /* check that this cert's name is permitted by the signer's\n                 * name constraints */\n                if (!ConfirmNameConstraints(cert->ca, cert)) {\n                    WOLFSSL_MSG(\"Confirm name constraint failed\");\n                    return ASN_NAME_INVALID_E;\n                }\n            }\n        #endif /* IGNORE_NAME_CONSTRAINTS */\n        }\n        else {\n            /* no signer */\n            WOLFSSL_MSG(\"No CA signer to verify with\");\n            return ASN_NO_SIGNER_E;\n        }\n    }\n\n#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)\nexit_pcr:\n#endif\n\n    if (cert->badDate != 0) {\n        if (verify != VERIFY_SKIP_DATE) {\n            return cert->badDate;\n        }\n        WOLFSSL_MSG(\"Date error: Verify option is skipping\");\n    }\n\n    if (cert->criticalExt != 0)\n        return cert->criticalExt;\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -151,9 +151,13 @@\n             }\n \n         #ifdef HAVE_OCSP\n-            /* trust for the lifetime of the responder's cert*/\n-            if (cert->ocspNoCheckSet && verify == VERIFY_OCSP)\n-                verify = NO_VERIFY;\n+            if (verify == VERIFY_OCSP_CERT) {\n+                /* trust for the lifetime of the responder's cert*/\n+                if (cert->ocspNoCheckSet)\n+                    verify = VERIFY;\n+                else\n+                    verify = VERIFY_OCSP;\n+            }\n         #endif\n             /* advance past extensions */\n             cert->srcIdx = cert->sigIndex;",
        "diff_line_info": {
            "deleted_lines": [
                "            /* trust for the lifetime of the responder's cert*/",
                "            if (cert->ocspNoCheckSet && verify == VERIFY_OCSP)",
                "                verify = NO_VERIFY;"
            ],
            "added_lines": [
                "            if (verify == VERIFY_OCSP_CERT) {",
                "                /* trust for the lifetime of the responder's cert*/",
                "                if (cert->ocspNoCheckSet)",
                "                    verify = VERIFY;",
                "                else",
                "                    verify = VERIFY_OCSP;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-38597",
        "func_name": "wolfSSL/wolfssl/DecodeBasicOcspResponse",
        "description": "wolfSSL before 4.8.1 incorrectly skips OCSP verification in certain situations of irrelevant response data that contains the NoCheck extension.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/f93083be72a3b3d956b52a7ec13f307a27b6e093",
        "commit_title": "OCSP: improve handling of OCSP no check extension",
        "commit_text": "",
        "func_before": "static int DecodeBasicOcspResponse(byte* source, word32* ioIndex,\n            OcspResponse* resp, word32 size, void* cm, void* heap, int noVerify)\n{\n    int    length;\n    word32 idx = *ioIndex;\n    word32 end_index;\n    int    ret;\n    int    sigLength;\n\n    WOLFSSL_ENTER(\"DecodeBasicOcspResponse\");\n    (void)heap;\n\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    if (idx + length > size)\n        return ASN_INPUT_E;\n    end_index = idx + length;\n\n    if ((ret = DecodeResponseData(source, &idx, resp, size)) < 0)\n        return ret; /* ASN_PARSE_E, ASN_BEFORE_DATE_E, ASN_AFTER_DATE_E */\n\n    /* Get the signature algorithm */\n    if (GetAlgoId(source, &idx, &resp->sigOID, oidSigType, size) < 0)\n        return ASN_PARSE_E;\n\n    ret = CheckBitString(source, &idx, &sigLength, size, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    resp->sigSz = sigLength;\n    resp->sig = source + idx;\n    idx += sigLength;\n\n    /*\n     * Check the length of the BasicOcspResponse against the current index to\n     * see if there are certificates, they are optional.\n     */\n#ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS\n    if (idx < end_index)\n    {\n        DecodedCert cert;\n\n        if (DecodeCerts(source, &idx, resp, size) < 0)\n            return ASN_PARSE_E;\n\n        InitDecodedCert(&cert, resp->cert, resp->certSz, heap);\n\n        /* Don't verify if we don't have access to Cert Manager. */\n        ret = ParseCertRelative(&cert, CERT_TYPE,\n                                noVerify ? NO_VERIFY : VERIFY_OCSP, cm);\n        if (ret < 0) {\n            WOLFSSL_MSG(\"\\tOCSP Responder certificate parsing failed\");\n            FreeDecodedCert(&cert);\n            return ret;\n        }\n\n#ifndef WOLFSSL_NO_OCSP_ISSUER_CHECK\n        if ((cert.extExtKeyUsage & EXTKEYUSE_OCSP_SIGN) == 0) {\n            if (XMEMCMP(cert.subjectHash,\n                        resp->single->issuerHash, OCSP_DIGEST_SIZE) == 0) {\n                WOLFSSL_MSG(\"\\tOCSP Response signed by issuer\");\n            }\n            else {\n                WOLFSSL_MSG(\"\\tOCSP Responder key usage check failed\");\n    #ifdef OPENSSL_EXTRA\n                resp->verifyError = OCSP_BAD_ISSUER;\n    #else\n                FreeDecodedCert(&cert);\n                return BAD_OCSP_RESPONDER;\n    #endif\n            }\n        }\n#endif\n\n        /* ConfirmSignature is blocking here */\n        ret = ConfirmSignature(&cert.sigCtx,\n            resp->response, resp->responseSz,\n            cert.publicKey, cert.pubKeySize, cert.keyOID,\n            resp->sig, resp->sigSz, resp->sigOID, NULL);\n\n        FreeDecodedCert(&cert);\n\n        if (ret != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n    }\n    else\n#endif /* WOLFSSL_NO_OCSP_OPTIONAL_CERTS */\n    {\n        Signer* ca;\n        int sigValid = -1;\n\n        #ifndef NO_SKID\n            ca = GetCA(cm, resp->single->issuerKeyHash);\n        #else\n            ca = GetCA(cm, resp->single->issuerHash);\n        #endif\n\n        if (ca) {\n            SignatureCtx sigCtx;\n            InitSignatureCtx(&sigCtx, heap, INVALID_DEVID);\n\n            /* ConfirmSignature is blocking here */\n            sigValid = ConfirmSignature(&sigCtx, resp->response,\n                resp->responseSz, ca->publicKey, ca->pubKeySize, ca->keyOID,\n                                resp->sig, resp->sigSz, resp->sigOID, NULL);\n        }\n        if (ca == NULL || sigValid != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n\n        (void)noVerify;\n    }\n\n    *ioIndex = idx;\n    return 0;\n}",
        "func": "static int DecodeBasicOcspResponse(byte* source, word32* ioIndex,\n            OcspResponse* resp, word32 size, void* cm, void* heap, int noVerify)\n{\n    int    length;\n    word32 idx = *ioIndex;\n    word32 end_index;\n    int    ret;\n    int    sigLength;\n\n    WOLFSSL_ENTER(\"DecodeBasicOcspResponse\");\n    (void)heap;\n\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    if (idx + length > size)\n        return ASN_INPUT_E;\n    end_index = idx + length;\n\n    if ((ret = DecodeResponseData(source, &idx, resp, size)) < 0)\n        return ret; /* ASN_PARSE_E, ASN_BEFORE_DATE_E, ASN_AFTER_DATE_E */\n\n    /* Get the signature algorithm */\n    if (GetAlgoId(source, &idx, &resp->sigOID, oidSigType, size) < 0)\n        return ASN_PARSE_E;\n\n    ret = CheckBitString(source, &idx, &sigLength, size, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    resp->sigSz = sigLength;\n    resp->sig = source + idx;\n    idx += sigLength;\n\n    /*\n     * Check the length of the BasicOcspResponse against the current index to\n     * see if there are certificates, they are optional.\n     */\n#ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS\n    if (idx < end_index)\n    {\n        DecodedCert cert;\n\n        if (DecodeCerts(source, &idx, resp, size) < 0)\n            return ASN_PARSE_E;\n\n        InitDecodedCert(&cert, resp->cert, resp->certSz, heap);\n\n        /* Don't verify if we don't have access to Cert Manager. */\n        ret = ParseCertRelative(&cert, CERT_TYPE,\n                                noVerify ? NO_VERIFY : VERIFY_OCSP_CERT, cm);\n        if (ret < 0) {\n            WOLFSSL_MSG(\"\\tOCSP Responder certificate parsing failed\");\n            FreeDecodedCert(&cert);\n            return ret;\n        }\n\n#ifndef WOLFSSL_NO_OCSP_ISSUER_CHECK\n        if ((cert.extExtKeyUsage & EXTKEYUSE_OCSP_SIGN) == 0) {\n            if (XMEMCMP(cert.subjectHash,\n                        resp->single->issuerHash, OCSP_DIGEST_SIZE) == 0) {\n                WOLFSSL_MSG(\"\\tOCSP Response signed by issuer\");\n            }\n            else {\n                WOLFSSL_MSG(\"\\tOCSP Responder key usage check failed\");\n    #ifdef OPENSSL_EXTRA\n                resp->verifyError = OCSP_BAD_ISSUER;\n    #else\n                FreeDecodedCert(&cert);\n                return BAD_OCSP_RESPONDER;\n    #endif\n            }\n        }\n#endif\n\n        /* ConfirmSignature is blocking here */\n        ret = ConfirmSignature(&cert.sigCtx,\n            resp->response, resp->responseSz,\n            cert.publicKey, cert.pubKeySize, cert.keyOID,\n            resp->sig, resp->sigSz, resp->sigOID, NULL);\n\n        FreeDecodedCert(&cert);\n\n        if (ret != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n    }\n    else\n#endif /* WOLFSSL_NO_OCSP_OPTIONAL_CERTS */\n    {\n        Signer* ca;\n        int sigValid = -1;\n\n        #ifndef NO_SKID\n            ca = GetCA(cm, resp->single->issuerKeyHash);\n        #else\n            ca = GetCA(cm, resp->single->issuerHash);\n        #endif\n\n        if (ca) {\n            SignatureCtx sigCtx;\n            InitSignatureCtx(&sigCtx, heap, INVALID_DEVID);\n\n            /* ConfirmSignature is blocking here */\n            sigValid = ConfirmSignature(&sigCtx, resp->response,\n                resp->responseSz, ca->publicKey, ca->pubKeySize, ca->keyOID,\n                                resp->sig, resp->sigSz, resp->sigOID, NULL);\n        }\n        if (ca == NULL || sigValid != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n\n        (void)noVerify;\n    }\n\n    *ioIndex = idx;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,7 +48,7 @@\n \n         /* Don't verify if we don't have access to Cert Manager. */\n         ret = ParseCertRelative(&cert, CERT_TYPE,\n-                                noVerify ? NO_VERIFY : VERIFY_OCSP, cm);\n+                                noVerify ? NO_VERIFY : VERIFY_OCSP_CERT, cm);\n         if (ret < 0) {\n             WOLFSSL_MSG(\"\\tOCSP Responder certificate parsing failed\");\n             FreeDecodedCert(&cert);",
        "diff_line_info": {
            "deleted_lines": [
                "                                noVerify ? NO_VERIFY : VERIFY_OCSP, cm);"
            ],
            "added_lines": [
                "                                noVerify ? NO_VERIFY : VERIFY_OCSP_CERT, cm);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40491",
        "func_name": "inetutils/initconn",
        "description": "The ftp client in GNU Inetutils before 2.2 does not validate addresses returned by PASV/LSPV responses to make sure they match the server address. This is similar to CVE-2020-8284 for curl.",
        "git_url": "https://git.savannah.gnu.org/cgit/inetutils.git/commit/?id=58cb043b190fd04effdaea7c9403416b436e50dd",
        "commit_title": "* NEWS: Mention change.",
        "commit_text": "* ftp/ftp.c (initconn): Validate returned addresses. ",
        "func_before": "int\ninitconn (void)\n{\n  char *p = NULL, *a = NULL;\n  int result, tmpno = 0;\n  int good_epsv = 0, good_lpsv = 0, j;\n  socklen_t len;\n  int on = 1;\n  uint32_t a0, a1, a2, a3, p0, p1, port;\n  uint32_t af, hal, h[16], pal; /* RFC 1639: LPSV resonse.  */\n  struct sockaddr_in *data_addr_sa4 = (struct sockaddr_in *) &data_addr;\n  struct sockaddr_in6 *data_addr_sa6 = (struct sockaddr_in6 *) &data_addr;\n\n  if (passivemode)\n    {\n      data = socket (myctladdr.ss_family, SOCK_STREAM, 0);\n      if (data < 0)\n\t{\n\t  perror (\"ftp: socket\");\n\t  return (1);\n\t}\n      if ((options & SO_DEBUG) &&\n\t  setsockopt (data, SOL_SOCKET, SO_DEBUG, (char *) &on,\n\t\t      sizeof (on)) < 0)\n\tif (errno != EACCES)\t/* Ignore insufficient permission.  */\n\t  error (0, errno, \"setsockopt DEBUG (ignored)\");\n\n      /* Be contemporary:\n       *   first try EPSV,\n       *   then fall back to PASV/LPSV.\n       */\n      switch (myctladdr.ss_family)\n        {\n\t  case AF_INET:\n\t    if (doepsv4 && command (\"EPSV\") == COMPLETE)\n\t      {\n\t        good_epsv = 1;\n\t        break;\n\t      }\n\t    if (doepsv4)\n\t      {\n\t\t/* When arriving here, EPSV failed. Prevent new attempts.  */\n\t\tdoepsv4 = 0;\n\t      }\n\t    if (command (\"PASV\") == COMPLETE)\n\t\tbreak;\n\t    if (command (\"LPSV\") == COMPLETE)\n\t      {\n\t\tgood_lpsv = 1;\n\t\tbreak;\n\t      }\n\t    printf (\"Passive mode refused.\\n\");\n\t    goto bad;\n\t    break;\n\t  case AF_INET6:\n\t    if (command (\"EPSV\") == COMPLETE)\n\t      {\n\t\tgood_epsv = 1;\n\t\tbreak;\n\t      }\n\t    if (command (\"LPSV\") == COMPLETE)\n\t      {\n\t\tgood_lpsv = 1;\n\t\tbreak;\n\t      }\n\t    printf (\"Passive mode refused.\\n\");\n\t    goto bad;\n\t    break;\n\t}\n\n      if (good_epsv)\n\t{\n\t  /* EPSV: IPv4 or IPv6\n\t   *\n\t   * Expected response (perl): pasv =~ '%u|'\n\t   * This communicates a port number.\n\t   */\n\t  if (sscanf (pasv, \"%u|\", &port) != 1)\n\t    {\n\t      printf (\"Extended passive mode scan failure. \"\n\t\t\t\"Should not happen!\\n\");\n\t      (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t      goto bad;\n\t    }\n\t  data_addr = hisctladdr;\n\t  switch (data_addr.ss_family)\n\t    {\n\t      case AF_INET:\n\t\tdata_addr_sa4->sin_port = htons (port);\n\t\tbreak;\n\t      case AF_INET6:\n\t\tdata_addr_sa6->sin6_port = htons (port);\n\t\tbreak;\n\t    }\n\t} /* EPSV */\n      else if (good_lpsv)\n\t{\n\t  /* LPSV: IPv4 or IPv6\n\t   *\n\t   * At this point we have got a string of comma\n\t   * separated, one-byte unsigned integer values.\n\t   * Length and interpretation depends on address\n\t   * family.\n\t   */\n\n\t  if (myctladdr.ss_family == AF_INET)\n\t    {\n\t      if ((sscanf (pasv, \"%u,\" /* af */\n\t\t\t\t\"%u,%u,%u,%u,%u,\" /* hal, h[4] */\n\t\t\t\t\"%u,%u,%u\", /* pal, p0, p1 */\n\t\t\t\t&af, &hal, &h[0], &h[1], &h[2], &h[3], &pal, &p0, &p1) != 9)\n\t\t  || (/* Strong checking */ af != 4 || hal != 4 || pal != 2) )\n\t\t{\n\t\t  printf (\"Passive mode address scan failure. \"\n\t\t\t  \"Shouldn't happen!\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t      for (j = 0; j < 4; ++j)\n\t\th[j] &= 0xff; /* Mask only the significant bits.  */\n\n\t      data_addr.ss_family = AF_INET;\n\t      data_addr_sa4->sin_port =\n\t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n\n\t\t{\n\t\t  uint32_t *pu32 = (uint32_t *) &data_addr_sa4->sin_addr.s_addr;\n\t\t  pu32[0] = htonl ( (h[0] << 24) | (h[1] << 16) | (h[2] << 8) | h[3]);\n\t\t}\n\t    } /* LPSV IPv4 */\n\t  else /* IPv6 */\n\t    {\n\t      if ((sscanf (pasv, \"%u,\" /* af */\n\t\t\t\t\"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,\" /* hal, h[16] */\n\t\t\t\t\"%u,%u,%u\", /* pal, p0, p1 */\n\t\t\t\t&af, &hal, &h[0], &h[1], &h[2], &h[3], &h[4], &h[5], &h[6], &h[7],\n\t\t\t\t&h[8], &h[9], &h[10], &h[11], &h[12], &h[13], &h[14], &h[15],\n\t\t\t\t&pal, &p0, &p1) != 21)\n\t\t  || (/* Strong checking */ af != 6 || hal != 16 || pal != 2) )\n\t\t{\n\t\t  printf (\"Passive mode address scan failure. \"\n\t\t\t  \"Shouldn't happen!\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t      for (j = 0; j < 16; ++j)\n\t\th[j] &= 0xff; /* Mask only the significant bits.  */\n\n\t      data_addr.ss_family = AF_INET6;\n\t      data_addr_sa6->sin6_port =\n\t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n\n\t\t{\n\t\t  uint32_t *pu32 = (uint32_t *) &data_addr_sa6->sin6_addr.s6_addr;\n\t\t  pu32[0] = htonl ( (h[0] << 24) | (h[1] << 16) | (h[2] << 8) | h[3]);\n\t\t  pu32[1] = htonl ( (h[4] << 24) | (h[5] << 16) | (h[6] << 8) | h[7]);\n\t\t  pu32[2] = htonl ( (h[8] << 24) | (h[9] << 16) | (h[10] << 8) | h[11]);\n\t\t  pu32[3] = htonl ( (h[12] << 24) | (h[13] << 16) | (h[14] << 8) | h[15]);\n\t\t}\n\t    } /* LPSV IPv6 */\n\t}\n      else /* !EPSV && !LPSV */\n\t{ /* PASV */\n\t  if (myctladdr.ss_family == AF_INET)\n\t    { /* PASV */\n\t      if (sscanf (pasv, \"%u,%u,%u,%u,%u,%u\",\n\t\t\t  &a0, &a1, &a2, &a3, &p0, &p1) != 6)\n\t\t{\n\t\t  printf (\"Passive mode address scan failure. \"\n\t\t\t  \"Shouldn't happen!\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t      data_addr.ss_family = AF_INET;\n\t      data_addr_sa4->sin_addr.s_addr =\n\t\t  htonl ( (a0 << 24) | ((a1 & 0xff) << 16)\n\t\t\t | ((a2 & 0xff) << 8) | (a3 & 0xff) );\n\t      data_addr_sa4->sin_port =\n\t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n\t    } /* PASV */\n\t  else\n\t    {\n\t      /* Catch all impossible cases.  */\n\t      printf (\"Passive mode address scan failure. Shouldn't happen!\\n\");\n\t      goto bad;\n\t    }\n\t} /* PASV */\n\n      if (connect (data, (struct sockaddr *) &data_addr, ctladdrlen) < 0)\n\t{\n\t  perror (\"ftp: connect\");\n\t  goto bad;\n\t}\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n      on = IPTOS_THROUGHPUT;\n      if (data_addr.ss_family == AF_INET &&\n\t   setsockopt (data, IPPROTO_IP, IP_TOS, (char *) &on,\n\t\t      sizeof (int)) < 0)\n\tperror (\"ftp: setsockopt TOS (ignored)\");\n#endif\n      return (0);\n    }\n\nnoport:\n  data_addr = myctladdr;\n  if (sendport)\n    /* Let the system pick a port.  */\n    switch (myctladdr.ss_family)\n      {\n\tcase AF_INET:\n\t  data_addr_sa4->sin_port = 0;\n\t  break;\n\tcase AF_INET6:\n\t  data_addr_sa6->sin6_port = 0;\n\t  break;\n      }\n\n  if (data != -1)\n    close (data);\n  data = socket (myctladdr.ss_family, SOCK_STREAM, 0);\n  if (data < 0)\n    {\n      error (0, errno, \"socket\");\n      if (tmpno)\n\tsendport = 1;\n      return (1);\n    }\n  if (!sendport)\n    if (setsockopt (data, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof (on))\n\t< 0)\n      {\n\terror (0, errno, \"setsockopt (reuse address)\");\n\tgoto bad;\n      }\n  if (bind (data, (struct sockaddr *) &data_addr, ctladdrlen) < 0)\n    {\n      error (0, errno, \"bind\");\n      goto bad;\n    }\n  if (options & SO_DEBUG\n      && setsockopt (data, SOL_SOCKET, SO_DEBUG,\n\t\t     (char *) &on, sizeof (on)) < 0)\n    if (errno != EACCES)\t/* Ignore insufficient permission.  */\n      error (0, errno, \"setsockopt DEBUG (ignored)\");\n  len = sizeof (data_addr);\n  if (getsockname (data, (struct sockaddr *) &data_addr, &len) < 0)\n    {\n      error (0, errno, \"getsockname\");\n      goto bad;\n    }\n  if (listen (data, 1) < 0)\n    error (0, errno, \"listen\");\n  if (sendport)\n    {\n#define UC(b)\t(((int)b)&0xff)\n      /* Preferences:\n       *   IPv4: EPRT, PORT, LPRT\n       *   IPv6: EPRT, LPRT\n       */\n      result = ERROR;\t/* For success detection.  */\n      if (data_addr.ss_family != AF_INET || doepsv4)\n\t{\n\t  /* Use EPRT mode.  */\n\t  getnameinfo ((struct sockaddr *) &data_addr, ctladdrlen,\n\t\t\tia, sizeof (ia), portstr, sizeof (portstr),\n\t\t\tNI_NUMERICHOST | NI_NUMERICSERV);\n\t  result = command (\"EPRT |%d|%s|%s|\",\n\t\t\t    (data_addr.ss_family == AF_INET) ? 1 : 2,\n\t\t\t    ia, portstr);\n\t}\n\n      if (data_addr.ss_family == AF_INET && doepsv4 && result != COMPLETE)\n\t/* Do not try EPRT with IPv4 again.  It fails for this host.  */\n\tdoepsv4 = 0;\n\n      if (data_addr.ss_family == AF_INET && result != COMPLETE)\n\t{\n\t  /* PORT for IPv4; possibly EPRT has failed.  */\n\t  a = (char *) &data_addr_sa4->sin_addr;\n\t  p = (char *) &data_addr_sa4->sin_port;\n\t  result = command (\"PORT %d,%d,%d,%d,%d,%d\",\n\t\t\t    UC (a[0]), UC (a[1]), UC (a[2]), UC (a[3]),\n\t\t\t    UC (p[0]), UC (p[1]));\n\t}\n\n      if (result != COMPLETE)\n\t{\n\t  /* Fall back to LPRT.  */\n\t  uint8_t *h, *p;\n\n\t  switch (data_addr.ss_family)\n\t    {\n\t      case AF_INET:\n\t\th = (uint8_t *) &data_addr_sa4->sin_addr;\n\t\tp = (uint8_t *) &data_addr_sa4->sin_port;\n\t\tresult = command (\"LPRT 4,4,%u,%u,%u,%u,2,%u,%u\",\n\t\t\t\t  h[0], h[1], h[2], h[3], p[0], p[1]);\n\t\tbreak;\n\t      case AF_INET6:\n\t\th = (uint8_t *) &data_addr_sa6->sin6_addr;\n\t\tp = (uint8_t *) &data_addr_sa6->sin6_port;\n\t\tresult = command (\"LPRT 6,16,\" /* af, hal */\n\t\t\t\t  \"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,\" /* h[16] */\n\t\t\t\t  \"2,%u,%u\", /* pal, p[2] */\n\t\t\t\t  h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7],\n\t\t\t\t  h[8], h[9], h[10], h[11], h[12], h[13], h[14], h[15],\n\t\t\t\t  p[0], p[1]);\n\t\tbreak;\n\t    }\n\t}\n\n      if (result == ERROR && sendport == -1)\n\t{\n\t  sendport = 0;\n\t  tmpno = 1;\n\t  goto noport;\n\t}\n      return (result != COMPLETE);\n    }\n  if (tmpno)\n    sendport = 1;\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n  on = IPTOS_THROUGHPUT;\n  if (data_addr.ss_family == AF_INET &&\n\tsetsockopt (data, IPPROTO_IP, IP_TOS, (char *) &on, sizeof (int)) < 0)\n    error (0, errno, \"setsockopt TOS (ignored)\");\n#endif\n  return (0);\nbad:\n  close (data), data = -1;\n  if (tmpno)\n    sendport = 1;\n  return (1);\n}",
        "func": "int\ninitconn (void)\n{\n  char *p = NULL, *a = NULL;\n  int result, tmpno = 0;\n  int good_epsv = 0, good_lpsv = 0, j;\n  socklen_t len;\n  int on = 1;\n  uint32_t a0, a1, a2, a3, p0, p1, port;\n  uint32_t af, hal, h[16], pal; /* RFC 1639: LPSV resonse.  */\n  struct sockaddr_in *data_addr_sa4 = (struct sockaddr_in *) &data_addr;\n  struct sockaddr_in6 *data_addr_sa6 = (struct sockaddr_in6 *) &data_addr;\n\n  if (passivemode)\n    {\n      data = socket (myctladdr.ss_family, SOCK_STREAM, 0);\n      if (data < 0)\n\t{\n\t  perror (\"ftp: socket\");\n\t  return (1);\n\t}\n      if ((options & SO_DEBUG) &&\n\t  setsockopt (data, SOL_SOCKET, SO_DEBUG, (char *) &on,\n\t\t      sizeof (on)) < 0)\n\tif (errno != EACCES)\t/* Ignore insufficient permission.  */\n\t  error (0, errno, \"setsockopt DEBUG (ignored)\");\n\n      /* Be contemporary:\n       *   first try EPSV,\n       *   then fall back to PASV/LPSV.\n       */\n      switch (myctladdr.ss_family)\n        {\n\t  case AF_INET:\n\t    if (doepsv4 && command (\"EPSV\") == COMPLETE)\n\t      {\n\t        good_epsv = 1;\n\t        break;\n\t      }\n\t    if (doepsv4)\n\t      {\n\t\t/* When arriving here, EPSV failed. Prevent new attempts.  */\n\t\tdoepsv4 = 0;\n\t      }\n\t    if (command (\"PASV\") == COMPLETE)\n\t\tbreak;\n\t    if (command (\"LPSV\") == COMPLETE)\n\t      {\n\t\tgood_lpsv = 1;\n\t\tbreak;\n\t      }\n\t    printf (\"Passive mode refused.\\n\");\n\t    goto bad;\n\t    break;\n\t  case AF_INET6:\n\t    if (command (\"EPSV\") == COMPLETE)\n\t      {\n\t\tgood_epsv = 1;\n\t\tbreak;\n\t      }\n\t    if (command (\"LPSV\") == COMPLETE)\n\t      {\n\t\tgood_lpsv = 1;\n\t\tbreak;\n\t      }\n\t    printf (\"Passive mode refused.\\n\");\n\t    goto bad;\n\t    break;\n\t}\n\n      if (good_epsv)\n\t{\n\t  /* EPSV: IPv4 or IPv6\n\t   *\n\t   * Expected response (perl): pasv =~ '%u|'\n\t   * This communicates a port number.\n\t   */\n\t  if (sscanf (pasv, \"%u|\", &port) != 1)\n\t    {\n\t      printf (\"Extended passive mode scan failure. \"\n\t\t\t\"Should not happen!\\n\");\n\t      (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t      goto bad;\n\t    }\n\t  data_addr = hisctladdr;\n\t  switch (data_addr.ss_family)\n\t    {\n\t      case AF_INET:\n\t\tdata_addr_sa4->sin_port = htons (port);\n\t\tbreak;\n\t      case AF_INET6:\n\t\tdata_addr_sa6->sin6_port = htons (port);\n\t\tbreak;\n\t    }\n\t} /* EPSV */\n      else if (good_lpsv)\n\t{\n\t  /* LPSV: IPv4 or IPv6\n\t   *\n\t   * At this point we have got a string of comma\n\t   * separated, one-byte unsigned integer values.\n\t   * Length and interpretation depends on address\n\t   * family.\n\t   */\n\n\t  if (myctladdr.ss_family == AF_INET)\n\t    {\n\t      if ((sscanf (pasv, \"%u,\" /* af */\n\t\t\t\t\"%u,%u,%u,%u,%u,\" /* hal, h[4] */\n\t\t\t\t\"%u,%u,%u\", /* pal, p0, p1 */\n\t\t\t\t&af, &hal, &h[0], &h[1], &h[2], &h[3], &pal, &p0, &p1) != 9)\n\t\t  || (/* Strong checking */ af != 4 || hal != 4 || pal != 2) )\n\t\t{\n\t\t  printf (\"Passive mode address scan failure. \"\n\t\t\t  \"Shouldn't happen!\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t      for (j = 0; j < 4; ++j)\n\t\th[j] &= 0xff; /* Mask only the significant bits.  */\n\n\t      data_addr.ss_family = AF_INET;\n\t      data_addr_sa4->sin_port =\n\t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n\n\t\t{\n\t\t  uint32_t *pu32 = (uint32_t *) &data_addr_sa4->sin_addr.s_addr;\n\t\t  pu32[0] = htonl ( (h[0] << 24) | (h[1] << 16) | (h[2] << 8) | h[3]);\n\t\t}\n\t\tif (data_addr_sa4->sin_addr.s_addr\n\t\t    != ((struct sockaddr_in *) &hisctladdr)->sin_addr.s_addr)\n\t\t  {\n\t\t    printf (\"Passive mode address mismatch.\\n\");\n\t\t    (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t    goto bad;\n\t\t  }\n\t    } /* LPSV IPv4 */\n\t  else /* IPv6 */\n\t    {\n\t      if ((sscanf (pasv, \"%u,\" /* af */\n\t\t\t\t\"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,\" /* hal, h[16] */\n\t\t\t\t\"%u,%u,%u\", /* pal, p0, p1 */\n\t\t\t\t&af, &hal, &h[0], &h[1], &h[2], &h[3], &h[4], &h[5], &h[6], &h[7],\n\t\t\t\t&h[8], &h[9], &h[10], &h[11], &h[12], &h[13], &h[14], &h[15],\n\t\t\t\t&pal, &p0, &p1) != 21)\n\t\t  || (/* Strong checking */ af != 6 || hal != 16 || pal != 2) )\n\t\t{\n\t\t  printf (\"Passive mode address scan failure. \"\n\t\t\t  \"Shouldn't happen!\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t      for (j = 0; j < 16; ++j)\n\t\th[j] &= 0xff; /* Mask only the significant bits.  */\n\n\t      data_addr.ss_family = AF_INET6;\n\t      data_addr_sa6->sin6_port =\n\t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n\n\t\t{\n\t\t  uint32_t *pu32 = (uint32_t *) &data_addr_sa6->sin6_addr.s6_addr;\n\t\t  pu32[0] = htonl ( (h[0] << 24) | (h[1] << 16) | (h[2] << 8) | h[3]);\n\t\t  pu32[1] = htonl ( (h[4] << 24) | (h[5] << 16) | (h[6] << 8) | h[7]);\n\t\t  pu32[2] = htonl ( (h[8] << 24) | (h[9] << 16) | (h[10] << 8) | h[11]);\n\t\t  pu32[3] = htonl ( (h[12] << 24) | (h[13] << 16) | (h[14] << 8) | h[15]);\n\t\t}\n\t\tif (data_addr_sa6->sin6_addr.s6_addr\n\t\t    != ((struct sockaddr_in6 *) &hisctladdr)->sin6_addr.s6_addr)\n\t\t  {\n\t\t    printf (\"Passive mode address mismatch.\\n\");\n\t\t    (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t    goto bad;\n\t\t  }\n\t    } /* LPSV IPv6 */\n\t}\n      else /* !EPSV && !LPSV */\n\t{ /* PASV */\n\t  if (myctladdr.ss_family == AF_INET)\n\t    { /* PASV */\n\t      if (sscanf (pasv, \"%u,%u,%u,%u,%u,%u\",\n\t\t\t  &a0, &a1, &a2, &a3, &p0, &p1) != 6)\n\t\t{\n\t\t  printf (\"Passive mode address scan failure. \"\n\t\t\t  \"Shouldn't happen!\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t      data_addr.ss_family = AF_INET;\n\t      data_addr_sa4->sin_addr.s_addr =\n\t\t  htonl ( (a0 << 24) | ((a1 & 0xff) << 16)\n\t\t\t | ((a2 & 0xff) << 8) | (a3 & 0xff) );\n\t      data_addr_sa4->sin_port =\n\t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n\t      if (data_addr_sa4->sin_addr.s_addr\n\t\t  != ((struct sockaddr_in *) &hisctladdr)->sin_addr.s_addr)\n\t\t{\n\t\t  printf (\"Passive mode address mismatch.\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t    } /* PASV */\n\t  else\n\t    {\n\t      /* Catch all impossible cases.  */\n\t      printf (\"Passive mode address scan failure. Shouldn't happen!\\n\");\n\t      goto bad;\n\t    }\n\t} /* PASV */\n\n      if (connect (data, (struct sockaddr *) &data_addr, ctladdrlen) < 0)\n\t{\n\t  perror (\"ftp: connect\");\n\t  goto bad;\n\t}\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n      on = IPTOS_THROUGHPUT;\n      if (data_addr.ss_family == AF_INET &&\n\t   setsockopt (data, IPPROTO_IP, IP_TOS, (char *) &on,\n\t\t      sizeof (int)) < 0)\n\tperror (\"ftp: setsockopt TOS (ignored)\");\n#endif\n      return (0);\n    }\n\nnoport:\n  data_addr = myctladdr;\n  if (sendport)\n    /* Let the system pick a port.  */\n    switch (myctladdr.ss_family)\n      {\n\tcase AF_INET:\n\t  data_addr_sa4->sin_port = 0;\n\t  break;\n\tcase AF_INET6:\n\t  data_addr_sa6->sin6_port = 0;\n\t  break;\n      }\n\n  if (data != -1)\n    close (data);\n  data = socket (myctladdr.ss_family, SOCK_STREAM, 0);\n  if (data < 0)\n    {\n      error (0, errno, \"socket\");\n      if (tmpno)\n\tsendport = 1;\n      return (1);\n    }\n  if (!sendport)\n    if (setsockopt (data, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof (on))\n\t< 0)\n      {\n\terror (0, errno, \"setsockopt (reuse address)\");\n\tgoto bad;\n      }\n  if (bind (data, (struct sockaddr *) &data_addr, ctladdrlen) < 0)\n    {\n      error (0, errno, \"bind\");\n      goto bad;\n    }\n  if (options & SO_DEBUG\n      && setsockopt (data, SOL_SOCKET, SO_DEBUG,\n\t\t     (char *) &on, sizeof (on)) < 0)\n    if (errno != EACCES)\t/* Ignore insufficient permission.  */\n      error (0, errno, \"setsockopt DEBUG (ignored)\");\n  len = sizeof (data_addr);\n  if (getsockname (data, (struct sockaddr *) &data_addr, &len) < 0)\n    {\n      error (0, errno, \"getsockname\");\n      goto bad;\n    }\n  if (listen (data, 1) < 0)\n    error (0, errno, \"listen\");\n  if (sendport)\n    {\n#define UC(b)\t(((int)b)&0xff)\n      /* Preferences:\n       *   IPv4: EPRT, PORT, LPRT\n       *   IPv6: EPRT, LPRT\n       */\n      result = ERROR;\t/* For success detection.  */\n      if (data_addr.ss_family != AF_INET || doepsv4)\n\t{\n\t  /* Use EPRT mode.  */\n\t  getnameinfo ((struct sockaddr *) &data_addr, ctladdrlen,\n\t\t\tia, sizeof (ia), portstr, sizeof (portstr),\n\t\t\tNI_NUMERICHOST | NI_NUMERICSERV);\n\t  result = command (\"EPRT |%d|%s|%s|\",\n\t\t\t    (data_addr.ss_family == AF_INET) ? 1 : 2,\n\t\t\t    ia, portstr);\n\t}\n\n      if (data_addr.ss_family == AF_INET && doepsv4 && result != COMPLETE)\n\t/* Do not try EPRT with IPv4 again.  It fails for this host.  */\n\tdoepsv4 = 0;\n\n      if (data_addr.ss_family == AF_INET && result != COMPLETE)\n\t{\n\t  /* PORT for IPv4; possibly EPRT has failed.  */\n\t  a = (char *) &data_addr_sa4->sin_addr;\n\t  p = (char *) &data_addr_sa4->sin_port;\n\t  result = command (\"PORT %d,%d,%d,%d,%d,%d\",\n\t\t\t    UC (a[0]), UC (a[1]), UC (a[2]), UC (a[3]),\n\t\t\t    UC (p[0]), UC (p[1]));\n\t}\n\n      if (result != COMPLETE)\n\t{\n\t  /* Fall back to LPRT.  */\n\t  uint8_t *h, *p;\n\n\t  switch (data_addr.ss_family)\n\t    {\n\t      case AF_INET:\n\t\th = (uint8_t *) &data_addr_sa4->sin_addr;\n\t\tp = (uint8_t *) &data_addr_sa4->sin_port;\n\t\tresult = command (\"LPRT 4,4,%u,%u,%u,%u,2,%u,%u\",\n\t\t\t\t  h[0], h[1], h[2], h[3], p[0], p[1]);\n\t\tbreak;\n\t      case AF_INET6:\n\t\th = (uint8_t *) &data_addr_sa6->sin6_addr;\n\t\tp = (uint8_t *) &data_addr_sa6->sin6_port;\n\t\tresult = command (\"LPRT 6,16,\" /* af, hal */\n\t\t\t\t  \"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,\" /* h[16] */\n\t\t\t\t  \"2,%u,%u\", /* pal, p[2] */\n\t\t\t\t  h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7],\n\t\t\t\t  h[8], h[9], h[10], h[11], h[12], h[13], h[14], h[15],\n\t\t\t\t  p[0], p[1]);\n\t\tbreak;\n\t    }\n\t}\n\n      if (result == ERROR && sendport == -1)\n\t{\n\t  sendport = 0;\n\t  tmpno = 1;\n\t  goto noport;\n\t}\n      return (result != COMPLETE);\n    }\n  if (tmpno)\n    sendport = 1;\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n  on = IPTOS_THROUGHPUT;\n  if (data_addr.ss_family == AF_INET &&\n\tsetsockopt (data, IPPROTO_IP, IP_TOS, (char *) &on, sizeof (int)) < 0)\n    error (0, errno, \"setsockopt TOS (ignored)\");\n#endif\n  return (0);\nbad:\n  close (data), data = -1;\n  if (tmpno)\n    sendport = 1;\n  return (1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -127,6 +127,13 @@\n \t\t  uint32_t *pu32 = (uint32_t *) &data_addr_sa4->sin_addr.s_addr;\n \t\t  pu32[0] = htonl ( (h[0] << 24) | (h[1] << 16) | (h[2] << 8) | h[3]);\n \t\t}\n+\t\tif (data_addr_sa4->sin_addr.s_addr\n+\t\t    != ((struct sockaddr_in *) &hisctladdr)->sin_addr.s_addr)\n+\t\t  {\n+\t\t    printf (\"Passive mode address mismatch.\\n\");\n+\t\t    (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n+\t\t    goto bad;\n+\t\t  }\n \t    } /* LPSV IPv4 */\n \t  else /* IPv6 */\n \t    {\n@@ -157,6 +164,13 @@\n \t\t  pu32[2] = htonl ( (h[8] << 24) | (h[9] << 16) | (h[10] << 8) | h[11]);\n \t\t  pu32[3] = htonl ( (h[12] << 24) | (h[13] << 16) | (h[14] << 8) | h[15]);\n \t\t}\n+\t\tif (data_addr_sa6->sin6_addr.s6_addr\n+\t\t    != ((struct sockaddr_in6 *) &hisctladdr)->sin6_addr.s6_addr)\n+\t\t  {\n+\t\t    printf (\"Passive mode address mismatch.\\n\");\n+\t\t    (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n+\t\t    goto bad;\n+\t\t  }\n \t    } /* LPSV IPv6 */\n \t}\n       else /* !EPSV && !LPSV */\n@@ -177,6 +191,13 @@\n \t\t\t | ((a2 & 0xff) << 8) | (a3 & 0xff) );\n \t      data_addr_sa4->sin_port =\n \t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n+\t      if (data_addr_sa4->sin_addr.s_addr\n+\t\t  != ((struct sockaddr_in *) &hisctladdr)->sin_addr.s_addr)\n+\t\t{\n+\t\t  printf (\"Passive mode address mismatch.\\n\");\n+\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n+\t\t  goto bad;\n+\t\t}\n \t    } /* PASV */\n \t  else\n \t    {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (data_addr_sa4->sin_addr.s_addr",
                "\t\t    != ((struct sockaddr_in *) &hisctladdr)->sin_addr.s_addr)",
                "\t\t  {",
                "\t\t    printf (\"Passive mode address mismatch.\\n\");",
                "\t\t    (void) command (\"ABOR\");\t/* Cancel any open connection.  */",
                "\t\t    goto bad;",
                "\t\t  }",
                "\t\tif (data_addr_sa6->sin6_addr.s6_addr",
                "\t\t    != ((struct sockaddr_in6 *) &hisctladdr)->sin6_addr.s6_addr)",
                "\t\t  {",
                "\t\t    printf (\"Passive mode address mismatch.\\n\");",
                "\t\t    (void) command (\"ABOR\");\t/* Cancel any open connection.  */",
                "\t\t    goto bad;",
                "\t\t  }",
                "\t      if (data_addr_sa4->sin_addr.s_addr",
                "\t\t  != ((struct sockaddr_in *) &hisctladdr)->sin_addr.s_addr)",
                "\t\t{",
                "\t\t  printf (\"Passive mode address mismatch.\\n\");",
                "\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */",
                "\t\t  goto bad;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-20180",
        "func_name": "Zerocoin/libzerocoin/CoinSpend::CoinSpend",
        "description": "A vulnerability classified as critical has been found in Zerocoin libzerocoin. Affected is the function CoinSpend::CoinSpend of the file CoinSpend.cpp of the component Proof Handler. The manipulation leads to insufficient verification of data authenticity. Continious delivery with rolling releases is used by this product. Therefore, no version details of affected nor updated releases are available. The patch is identified as ce103a09ec079d0a0ed95475992348bed6e860de. It is recommended to apply a patch to fix this issue. VDB-222318 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/Zerocoin/libzerocoin/commit/ce103a09ec079d0a0ed95475992348bed6e860de",
        "commit_title": "Patch serial # exploit.",
        "commit_text": " The serial # range needs to be checked or else the serial number is able to be incremented to a value that will create a valid proof, thus allowing multiple spends of a single mint.",
        "func_before": "CoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\n\t// Sanity check: let's verify that the Witness is valid with respect to\n\t// the coin and Accumulator provided.\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\n\t// 1: Generate two separate commitments to the public coin (C), each under\n\t// a different set of public parameters. We do this because the RSA accumulator\n\t// has specific requirements for the commitment parameters that are not\n\t// compatible with the group we use for the serial number proof.\n\t// Specifically, our serial number proof requires the order of the commitment group\n\t// to be the same as the modulus of the upper group. The Accumulator proof requires a\n\t// group with a significantly larger order.\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\n\t// 2. Generate a ZK proof that the two commitments contain the same public coin.\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\n\t// Now generate the two core ZK proofs:\n\t// 3. Proves that the committed public coin is in the Accumulator (PoK of \"witness\")\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\n\t// 4. Proves that the coin is correct w.r.t. serial number and hidden coin secret\n\t// (This proof is bound to the coin 'metadata', i.e., transaction hash)\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}",
        "func": "CoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\n\t// Sanity check: let's verify that the Witness is valid with respect to\n\t// the coin and Accumulator provided.\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\n\t// The serial # needs to be within the specified range our else it can be incremented by the modulus and create another valid proof\n\tif (!HasValidSerial()) {\n\t\tthrow ZerocoinException(\"Invalid serial # range\");\n\t}\n\n\t// 1: Generate two separate commitments to the public coin (C), each under\n\t// a different set of public parameters. We do this because the RSA accumulator\n\t// has specific requirements for the commitment parameters that are not\n\t// compatible with the group we use for the serial number proof.\n\t// Specifically, our serial number proof requires the order of the commitment group\n\t// to be the same as the modulus of the upper group. The Accumulator proof requires a\n\t// group with a significantly larger order.\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\n\t// 2. Generate a ZK proof that the two commitments contain the same public coin.\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\n\t// Now generate the two core ZK proofs:\n\t// 3. Proves that the committed public coin is in the Accumulator (PoK of \"witness\")\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\n\t// 4. Proves that the coin is correct w.r.t. serial number and hidden coin secret\n\t// (This proof is bound to the coin 'metadata', i.e., transaction hash)\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,11 @@\n \t// the coin and Accumulator provided.\n \tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n \t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n+\t}\n+\n+\t// The serial # needs to be within the specified range our else it can be incremented by the modulus and create another valid proof\n+\tif (!HasValidSerial()) {\n+\t\tthrow ZerocoinException(\"Invalid serial # range\");\n \t}\n \n \t// 1: Generate two separate commitments to the public coin (C), each under",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t}",
                "",
                "\t// The serial # needs to be within the specified range our else it can be incremented by the modulus and create another valid proof",
                "\tif (!HasValidSerial()) {",
                "\t\tthrow ZerocoinException(\"Invalid serial # range\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-44402",
        "func_name": "electron/NodeBindings::CreateEnvironment",
        "description": "Electron is an open source framework for writing cross-platform desktop applications using JavaScript, HTML and CSS. This only impacts apps that have the `embeddedAsarIntegrityValidation` and `onlyLoadAppFromAsar` fuses enabled.  Apps without these fuses enabled are not impacted.  This issue is specific to macOS as these fuses are only currently supported on macOS. Specifically this issue can only be exploited if your app is launched from a filesystem the attacker has write access too.  i.e. the ability to edit files inside the `.app` bundle on macOS which these fuses are supposed to protect against. There are no app side workarounds, you must update to a patched version of Electron.",
        "git_url": "https://github.com/electron/electron/commit/342cf186d98eee64a68382bc74382b2e6745eb61",
        "commit_title": "fix: ensure app load is limited to real asar files when appropriate",
        "commit_text": "",
        "func_before": "std::shared_ptr<node::Environment> NodeBindings::CreateEnvironment(\n    v8::Handle<v8::Context> context,\n    node::MultiIsolatePlatform* platform,\n    std::vector<std::string> args,\n    std::vector<std::string> exec_args,\n    absl::optional<base::RepeatingCallback<void()>> on_app_code_ready) {\n  // Feed node the path to initialization script.\n  std::string process_type;\n  switch (browser_env_) {\n    case BrowserEnvironment::kBrowser:\n      process_type = \"browser\";\n      break;\n    case BrowserEnvironment::kRenderer:\n      process_type = \"renderer\";\n      break;\n    case BrowserEnvironment::kWorker:\n      process_type = \"worker\";\n      break;\n    case BrowserEnvironment::kUtility:\n      process_type = \"utility\";\n      break;\n  }\n\n  v8::Isolate* isolate = context->GetIsolate();\n  gin_helper::Dictionary global(isolate, context->Global());\n\n  if (browser_env_ == BrowserEnvironment::kBrowser) {\n    const std::vector<std::string> search_paths = {\"app.asar\", \"app\",\n                                                   \"default_app.asar\"};\n    const std::vector<std::string> app_asar_search_paths = {\"app.asar\"};\n    context->Global()->SetPrivate(\n        context,\n        v8::Private::ForApi(\n            isolate,\n            gin::ConvertToV8(isolate, \"appSearchPaths\").As<v8::String>()),\n        gin::ConvertToV8(isolate,\n                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()\n                             ? app_asar_search_paths\n                             : search_paths));\n  }\n\n  base::FilePath resources_path = GetResourcesPath();\n  std::string init_script = \"electron/js2c/\" + process_type + \"_init\";\n\n  args.insert(args.begin() + 1, init_script);\n\n  auto* isolate_data = node::CreateIsolateData(isolate, uv_loop_, platform);\n  context->SetAlignedPointerInEmbedderData(kElectronContextEmbedderDataIndex,\n                                           static_cast<void*>(isolate_data));\n\n  node::Environment* env;\n  uint64_t flags = node::EnvironmentFlags::kDefaultFlags |\n                   node::EnvironmentFlags::kHideConsoleWindows |\n                   node::EnvironmentFlags::kNoGlobalSearchPaths |\n                   node::EnvironmentFlags::kNoRegisterESMLoader;\n\n  if (browser_env_ == BrowserEnvironment::kRenderer ||\n      browser_env_ == BrowserEnvironment::kWorker) {\n    // Only one ESM loader can be registered per isolate -\n    // in renderer processes this should be blink. We need to tell Node.js\n    // not to register its handler (overriding blinks) in non-browser processes.\n    // We also avoid overriding globals like setImmediate, clearImmediate\n    // queueMicrotask etc during the bootstrap phase of Node.js\n    // for processes that already have these defined by DOM.\n    // Check //third_party/electron_node/lib/internal/bootstrap/node.js\n    // for the list of overrides on globalThis.\n    flags |= node::EnvironmentFlags::kNoBrowserGlobals |\n             node::EnvironmentFlags::kNoCreateInspector;\n  }\n\n  if (!electron::fuses::IsNodeCliInspectEnabled()) {\n    // If --inspect and friends are disabled we also shouldn't listen for\n    // SIGUSR1\n    flags |= node::EnvironmentFlags::kNoStartDebugSignalHandler;\n  }\n\n  {\n    v8::TryCatch try_catch(isolate);\n    env = node::CreateEnvironment(\n        static_cast<node::IsolateData*>(isolate_data), context, args, exec_args,\n        static_cast<node::EnvironmentFlags::Flags>(flags));\n\n    if (try_catch.HasCaught()) {\n      std::string err_msg =\n          \"Failed to initialize node environment in process: \" + process_type;\n      v8::Local<v8::Message> message = try_catch.Message();\n      std::string msg;\n      if (!message.IsEmpty() &&\n          gin::ConvertFromV8(isolate, message->Get(), &msg))\n        err_msg += \" , with error: \" + msg;\n      LOG(ERROR) << err_msg;\n    }\n  }\n\n  DCHECK(env);\n\n  node::IsolateSettings is;\n\n  // Use a custom fatal error callback to allow us to add\n  // crash message and location to CrashReports.\n  is.fatal_error_callback = V8FatalErrorCallback;\n\n  // We don't want to abort either in the renderer or browser processes.\n  // We already listen for uncaught exceptions and handle them there.\n  // For utility process we expect the process to behave as standard\n  // Node.js runtime and abort the process with appropriate exit\n  // code depending on a handler being set for `uncaughtException` event.\n  if (browser_env_ != BrowserEnvironment::kUtility) {\n    is.should_abort_on_uncaught_exception_callback = [](v8::Isolate*) {\n      return false;\n    };\n  }\n\n  // Use a custom callback here to allow us to leverage Blink's logic in the\n  // renderer process.\n  is.allow_wasm_code_generation_callback = AllowWasmCodeGenerationCallback;\n  is.flags |= node::IsolateSettingsFlags::\n      ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK;\n  is.modify_code_generation_from_strings_callback =\n      ModifyCodeGenerationFromStrings;\n\n  if (browser_env_ == BrowserEnvironment::kBrowser ||\n      browser_env_ == BrowserEnvironment::kUtility) {\n    // Node.js requires that microtask checkpoints be explicitly invoked.\n    is.policy = v8::MicrotasksPolicy::kExplicit;\n  } else {\n    // Blink expects the microtasks policy to be kScoped, but Node.js expects it\n    // to be kExplicit. In the renderer, there can be many contexts within the\n    // same isolate, so we don't want to change the existing policy here, which\n    // could be either kExplicit or kScoped depending on whether we're executing\n    // from within a Node.js or a Blink entrypoint. Instead, the policy is\n    // toggled to kExplicit when entering Node.js through UvRunOnce.\n    is.policy = context->GetIsolate()->GetMicrotasksPolicy();\n\n    // We do not want to use Node.js' message listener as it interferes with\n    // Blink's.\n    is.flags &= ~node::IsolateSettingsFlags::MESSAGE_LISTENER_WITH_ERROR_LEVEL;\n\n    // Isolate message listeners are additive (you can add multiple), so instead\n    // we add an extra one here to ensure that the async hook stack is properly\n    // cleared when errors are thrown.\n    context->GetIsolate()->AddMessageListenerWithErrorLevel(\n        ErrorMessageListener, v8::Isolate::kMessageError);\n\n    // We do not want to use the promise rejection callback that Node.js uses,\n    // because it does not send PromiseRejectionEvents to the global script\n    // context. We need to use the one Blink already provides.\n    is.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK;\n\n    // We do not want to use the stack trace callback that Node.js uses,\n    // because it relies on Node.js being aware of the current Context and\n    // that's not always the case. We need to use the one Blink already\n    // provides.\n    is.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK;\n  }\n\n  node::SetIsolateUpForNode(context->GetIsolate(), is);\n  context->GetIsolate()->SetHostImportModuleDynamicallyCallback(\n      HostImportModuleDynamically);\n  context->GetIsolate()->SetHostInitializeImportMetaObjectCallback(\n      HostInitializeImportMetaObject);\n\n  gin_helper::Dictionary process(context->GetIsolate(), env->process_object());\n  process.SetReadOnly(\"type\", process_type);\n  process.Set(\"resourcesPath\", resources_path);\n  // The path to helper app.\n  base::FilePath helper_exec_path;\n  base::PathService::Get(content::CHILD_PROCESS_EXE, &helper_exec_path);\n  process.Set(\"helperExecPath\", helper_exec_path);\n\n  if (browser_env_ == BrowserEnvironment::kBrowser ||\n      browser_env_ == BrowserEnvironment::kRenderer) {\n    if (on_app_code_ready) {\n      process.SetMethod(\"appCodeLoaded\", std::move(*on_app_code_ready));\n    } else {\n      process.SetMethod(\"appCodeLoaded\",\n                        base::BindRepeating(&NodeBindings::SetAppCodeLoaded,\n                                            base::Unretained(this)));\n    }\n  }\n\n  auto env_deleter = [isolate, isolate_data,\n                      context = v8::Global<v8::Context>{isolate, context}](\n                         node::Environment* nenv) mutable {\n    // When `isolate_data` was created above, a pointer to it was kept\n    // in context's embedder_data[kElectronContextEmbedderDataIndex].\n    // Since we're about to free `isolate_data`, clear that entry\n    v8::HandleScope handle_scope{isolate};\n    context.Get(isolate)->SetAlignedPointerInEmbedderData(\n        kElectronContextEmbedderDataIndex, nullptr);\n    context.Reset();\n\n    node::FreeEnvironment(nenv);\n    node::FreeIsolateData(isolate_data);\n  };\n\n  return {env, std::move(env_deleter)};\n}",
        "func": "std::shared_ptr<node::Environment> NodeBindings::CreateEnvironment(\n    v8::Handle<v8::Context> context,\n    node::MultiIsolatePlatform* platform,\n    std::vector<std::string> args,\n    std::vector<std::string> exec_args,\n    absl::optional<base::RepeatingCallback<void()>> on_app_code_ready) {\n  // Feed node the path to initialization script.\n  std::string process_type;\n  switch (browser_env_) {\n    case BrowserEnvironment::kBrowser:\n      process_type = \"browser\";\n      break;\n    case BrowserEnvironment::kRenderer:\n      process_type = \"renderer\";\n      break;\n    case BrowserEnvironment::kWorker:\n      process_type = \"worker\";\n      break;\n    case BrowserEnvironment::kUtility:\n      process_type = \"utility\";\n      break;\n  }\n\n  v8::Isolate* isolate = context->GetIsolate();\n  gin_helper::Dictionary global(isolate, context->Global());\n\n  if (browser_env_ == BrowserEnvironment::kBrowser) {\n    const std::vector<std::string> search_paths = {\"app.asar\", \"app\",\n                                                   \"default_app.asar\"};\n    const std::vector<std::string> app_asar_search_paths = {\"app.asar\"};\n    context->Global()->SetPrivate(\n        context,\n        v8::Private::ForApi(\n            isolate,\n            gin::ConvertToV8(isolate, \"appSearchPaths\").As<v8::String>()),\n        gin::ConvertToV8(isolate,\n                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()\n                             ? app_asar_search_paths\n                             : search_paths));\n    context->Global()->SetPrivate(\n        context,\n        v8::Private::ForApi(\n            isolate, gin::ConvertToV8(isolate, \"appSearchPathsOnlyLoadASAR\")\n                         .As<v8::String>()),\n        gin::ConvertToV8(isolate,\n                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()));\n  }\n\n  base::FilePath resources_path = GetResourcesPath();\n  std::string init_script = \"electron/js2c/\" + process_type + \"_init\";\n\n  args.insert(args.begin() + 1, init_script);\n\n  auto* isolate_data = node::CreateIsolateData(isolate, uv_loop_, platform);\n  context->SetAlignedPointerInEmbedderData(kElectronContextEmbedderDataIndex,\n                                           static_cast<void*>(isolate_data));\n\n  node::Environment* env;\n  uint64_t flags = node::EnvironmentFlags::kDefaultFlags |\n                   node::EnvironmentFlags::kHideConsoleWindows |\n                   node::EnvironmentFlags::kNoGlobalSearchPaths |\n                   node::EnvironmentFlags::kNoRegisterESMLoader;\n\n  if (browser_env_ == BrowserEnvironment::kRenderer ||\n      browser_env_ == BrowserEnvironment::kWorker) {\n    // Only one ESM loader can be registered per isolate -\n    // in renderer processes this should be blink. We need to tell Node.js\n    // not to register its handler (overriding blinks) in non-browser processes.\n    // We also avoid overriding globals like setImmediate, clearImmediate\n    // queueMicrotask etc during the bootstrap phase of Node.js\n    // for processes that already have these defined by DOM.\n    // Check //third_party/electron_node/lib/internal/bootstrap/node.js\n    // for the list of overrides on globalThis.\n    flags |= node::EnvironmentFlags::kNoBrowserGlobals |\n             node::EnvironmentFlags::kNoCreateInspector;\n  }\n\n  if (!electron::fuses::IsNodeCliInspectEnabled()) {\n    // If --inspect and friends are disabled we also shouldn't listen for\n    // SIGUSR1\n    flags |= node::EnvironmentFlags::kNoStartDebugSignalHandler;\n  }\n\n  {\n    v8::TryCatch try_catch(isolate);\n    env = node::CreateEnvironment(\n        static_cast<node::IsolateData*>(isolate_data), context, args, exec_args,\n        static_cast<node::EnvironmentFlags::Flags>(flags));\n\n    if (try_catch.HasCaught()) {\n      std::string err_msg =\n          \"Failed to initialize node environment in process: \" + process_type;\n      v8::Local<v8::Message> message = try_catch.Message();\n      std::string msg;\n      if (!message.IsEmpty() &&\n          gin::ConvertFromV8(isolate, message->Get(), &msg))\n        err_msg += \" , with error: \" + msg;\n      LOG(ERROR) << err_msg;\n    }\n  }\n\n  DCHECK(env);\n\n  node::IsolateSettings is;\n\n  // Use a custom fatal error callback to allow us to add\n  // crash message and location to CrashReports.\n  is.fatal_error_callback = V8FatalErrorCallback;\n\n  // We don't want to abort either in the renderer or browser processes.\n  // We already listen for uncaught exceptions and handle them there.\n  // For utility process we expect the process to behave as standard\n  // Node.js runtime and abort the process with appropriate exit\n  // code depending on a handler being set for `uncaughtException` event.\n  if (browser_env_ != BrowserEnvironment::kUtility) {\n    is.should_abort_on_uncaught_exception_callback = [](v8::Isolate*) {\n      return false;\n    };\n  }\n\n  // Use a custom callback here to allow us to leverage Blink's logic in the\n  // renderer process.\n  is.allow_wasm_code_generation_callback = AllowWasmCodeGenerationCallback;\n  is.flags |= node::IsolateSettingsFlags::\n      ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK;\n  is.modify_code_generation_from_strings_callback =\n      ModifyCodeGenerationFromStrings;\n\n  if (browser_env_ == BrowserEnvironment::kBrowser ||\n      browser_env_ == BrowserEnvironment::kUtility) {\n    // Node.js requires that microtask checkpoints be explicitly invoked.\n    is.policy = v8::MicrotasksPolicy::kExplicit;\n  } else {\n    // Blink expects the microtasks policy to be kScoped, but Node.js expects it\n    // to be kExplicit. In the renderer, there can be many contexts within the\n    // same isolate, so we don't want to change the existing policy here, which\n    // could be either kExplicit or kScoped depending on whether we're executing\n    // from within a Node.js or a Blink entrypoint. Instead, the policy is\n    // toggled to kExplicit when entering Node.js through UvRunOnce.\n    is.policy = context->GetIsolate()->GetMicrotasksPolicy();\n\n    // We do not want to use Node.js' message listener as it interferes with\n    // Blink's.\n    is.flags &= ~node::IsolateSettingsFlags::MESSAGE_LISTENER_WITH_ERROR_LEVEL;\n\n    // Isolate message listeners are additive (you can add multiple), so instead\n    // we add an extra one here to ensure that the async hook stack is properly\n    // cleared when errors are thrown.\n    context->GetIsolate()->AddMessageListenerWithErrorLevel(\n        ErrorMessageListener, v8::Isolate::kMessageError);\n\n    // We do not want to use the promise rejection callback that Node.js uses,\n    // because it does not send PromiseRejectionEvents to the global script\n    // context. We need to use the one Blink already provides.\n    is.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK;\n\n    // We do not want to use the stack trace callback that Node.js uses,\n    // because it relies on Node.js being aware of the current Context and\n    // that's not always the case. We need to use the one Blink already\n    // provides.\n    is.flags |=\n        node::IsolateSettingsFlags::SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK;\n  }\n\n  node::SetIsolateUpForNode(context->GetIsolate(), is);\n  context->GetIsolate()->SetHostImportModuleDynamicallyCallback(\n      HostImportModuleDynamically);\n  context->GetIsolate()->SetHostInitializeImportMetaObjectCallback(\n      HostInitializeImportMetaObject);\n\n  gin_helper::Dictionary process(context->GetIsolate(), env->process_object());\n  process.SetReadOnly(\"type\", process_type);\n  process.Set(\"resourcesPath\", resources_path);\n  // The path to helper app.\n  base::FilePath helper_exec_path;\n  base::PathService::Get(content::CHILD_PROCESS_EXE, &helper_exec_path);\n  process.Set(\"helperExecPath\", helper_exec_path);\n\n  if (browser_env_ == BrowserEnvironment::kBrowser ||\n      browser_env_ == BrowserEnvironment::kRenderer) {\n    if (on_app_code_ready) {\n      process.SetMethod(\"appCodeLoaded\", std::move(*on_app_code_ready));\n    } else {\n      process.SetMethod(\"appCodeLoaded\",\n                        base::BindRepeating(&NodeBindings::SetAppCodeLoaded,\n                                            base::Unretained(this)));\n    }\n  }\n\n  auto env_deleter = [isolate, isolate_data,\n                      context = v8::Global<v8::Context>{isolate, context}](\n                         node::Environment* nenv) mutable {\n    // When `isolate_data` was created above, a pointer to it was kept\n    // in context's embedder_data[kElectronContextEmbedderDataIndex].\n    // Since we're about to free `isolate_data`, clear that entry\n    v8::HandleScope handle_scope{isolate};\n    context.Get(isolate)->SetAlignedPointerInEmbedderData(\n        kElectronContextEmbedderDataIndex, nullptr);\n    context.Reset();\n\n    node::FreeEnvironment(nenv);\n    node::FreeIsolateData(isolate_data);\n  };\n\n  return {env, std::move(env_deleter)};\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,13 @@\n                          electron::fuses::IsOnlyLoadAppFromAsarEnabled()\n                              ? app_asar_search_paths\n                              : search_paths));\n+    context->Global()->SetPrivate(\n+        context,\n+        v8::Private::ForApi(\n+            isolate, gin::ConvertToV8(isolate, \"appSearchPathsOnlyLoadASAR\")\n+                         .As<v8::String>()),\n+        gin::ConvertToV8(isolate,\n+                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()));\n   }\n \n   base::FilePath resources_path = GetResourcesPath();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    context->Global()->SetPrivate(",
                "        context,",
                "        v8::Private::ForApi(",
                "            isolate, gin::ConvertToV8(isolate, \"appSearchPathsOnlyLoadASAR\")",
                "                         .As<v8::String>()),",
                "        gin::ConvertToV8(isolate,",
                "                         electron::fuses::IsOnlyLoadAppFromAsarEnabled()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1000004",
        "func_name": "facebook/hhvm/SimpleXMLElement_exportNode",
        "description": "Insufficient type checks were employed prior to casting input data in SimpleXMLElement_exportNode and simplexml_import_dom. This issue affects HHVM versions prior to 3.9.5, all versions between 3.10.0 and 3.12.3 (inclusive), and all versions between 3.13.0 and 3.14.1 (inclusive).",
        "git_url": "https://github.com/facebook/hhvm/commit/8e7266fef1f329b805b37f32c9ad0090215ab269",
        "commit_title": "Type safety in simplexml import routines",
        "commit_text": " Reviewed By: Orvid  Differential Revision: D3447275  fbshipit-source-id: d859c97f9d85c520b0e371cef6dcb19bb2ef7dbf",
        "func_before": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}",
        "func": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  if (!sxe->instanceof(SimpleXMLElement_classof())) return nullptr;\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n-  assert(sxe->instanceof(SimpleXMLElement_classof()));\n+  if (!sxe->instanceof(SimpleXMLElement_classof())) return nullptr;\n   auto data = Native::data<SimpleXMLElement>(sxe.get());\n   return php_sxe_get_first_node(data, data->nodep());\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  assert(sxe->instanceof(SimpleXMLElement_classof()));"
            ],
            "added_lines": [
                "  if (!sxe->instanceof(SimpleXMLElement_classof())) return nullptr;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/amd_iommu_setup_domain_device",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/0514a3a25fb9ebff5d75cc8f00a9229385300858",
        "commit_title": "AMD/IOMMU: ensure suitable ordering of DTE modifications",
        "commit_text": " DMA and interrupt translation should be enabled only after other applicable DTE fields have been written. Similarly when disabling translation or when moving a device between domains, translation should first be disabled, before other entry fields get modified. Note however that the \"moving\" aspect doesn't apply to the interrupt remapping side, as domain specifics are maintained in the IRTEs here, not the DTE. We also never disable interrupt remapping once it got enabled for a device (the respective argument passed is always the immutable iommu_intremap).  This is part of XSA-347. ",
        "func_before": "static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    BUG_ON( !hd->arch.amd.root_table ||\n            !hd->arch.amd.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        const struct ivrs_mappings *ivrs_dev;\n\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.amd.root_table),\n            domain->domain_id, hd->arch.amd.paging_mode, valid);\n\n        /* Undo what amd_iommu_disable_domain_device() may have done. */\n        ivrs_dev = &get_ivrs_mappings(iommu->seg)[req_id];\n        if ( dte->it_root )\n            dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n        dte->iv = iommu_intremap;\n        dte->ex = ivrs_dev->dte_allow_exclusion;\n        dte->sys_mgt = MASK_EXTR(ivrs_dev->device_flags, ACPI_IVHD_SYSTEM_MGMT);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\"Setup I/O page table: device id = %#x, type = %#x, \"\n                        \"root table = %#\"PRIx64\", \"\n                        \"domain = %d, paging mode = %d\\n\",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.amd.root_table),\n                        domain->domain_id, hd->arch.amd.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}",
        "func": "static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    BUG_ON( !hd->arch.amd.root_table ||\n            !hd->arch.amd.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        const struct ivrs_mappings *ivrs_dev;\n\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.amd.root_table),\n            domain->domain_id, hd->arch.amd.paging_mode, valid);\n\n        /* Undo what amd_iommu_disable_domain_device() may have done. */\n        ivrs_dev = &get_ivrs_mappings(iommu->seg)[req_id];\n        if ( dte->it_root )\n        {\n            dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n            smp_wmb();\n        }\n        dte->iv = iommu_intremap;\n        dte->ex = ivrs_dev->dte_allow_exclusion;\n        dte->sys_mgt = MASK_EXTR(ivrs_dev->device_flags, ACPI_IVHD_SYSTEM_MGMT);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\"Setup I/O page table: device id = %#x, type = %#x, \"\n                        \"root table = %#\"PRIx64\", \"\n                        \"domain = %d, paging mode = %d\\n\",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.amd.root_table),\n                        domain->domain_id, hd->arch.amd.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,10 @@\n         /* Undo what amd_iommu_disable_domain_device() may have done. */\n         ivrs_dev = &get_ivrs_mappings(iommu->seg)[req_id];\n         if ( dte->it_root )\n+        {\n             dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n+            smp_wmb();\n+        }\n         dte->iv = iommu_intremap;\n         dte->ex = ivrs_dev->dte_allow_exclusion;\n         dte->sys_mgt = MASK_EXTR(ivrs_dev->device_flags, ACPI_IVHD_SYSTEM_MGMT);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        {",
                "            smp_wmb();",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/amd_iommu_set_root_page_table",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/0514a3a25fb9ebff5d75cc8f00a9229385300858",
        "commit_title": "AMD/IOMMU: ensure suitable ordering of DTE modifications",
        "commit_text": " DMA and interrupt translation should be enabled only after other applicable DTE fields have been written. Similarly when disabling translation or when moving a device between domains, translation should first be disabled, before other entry fields get modified. Note however that the \"moving\" aspect doesn't apply to the interrupt remapping side, as domain specifics are maintained in the IRTEs here, not the DTE. We also never disable interrupt remapping once it got enabled for a device (the respective argument passed is always the immutable iommu_intremap).  This is part of XSA-347. ",
        "func_before": "void amd_iommu_set_root_page_table(struct amd_iommu_dte *dte,\n                                   uint64_t root_ptr, uint16_t domain_id,\n                                   uint8_t paging_mode, bool valid)\n{\n    dte->domain_id = domain_id;\n    dte->pt_root = paddr_to_pfn(root_ptr);\n    dte->iw = true;\n    dte->ir = true;\n    dte->paging_mode = paging_mode;\n    dte->tv = true;\n    dte->v = valid;\n}",
        "func": "void amd_iommu_set_root_page_table(struct amd_iommu_dte *dte,\n                                   uint64_t root_ptr, uint16_t domain_id,\n                                   uint8_t paging_mode, bool valid)\n{\n    if ( valid || dte->v )\n    {\n        dte->tv = false;\n        dte->v = true;\n        smp_wmb();\n    }\n    dte->domain_id = domain_id;\n    dte->pt_root = paddr_to_pfn(root_ptr);\n    dte->iw = true;\n    dte->ir = true;\n    dte->paging_mode = paging_mode;\n    smp_wmb();\n    dte->tv = true;\n    dte->v = valid;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,11 +2,18 @@\n                                    uint64_t root_ptr, uint16_t domain_id,\n                                    uint8_t paging_mode, bool valid)\n {\n+    if ( valid || dte->v )\n+    {\n+        dte->tv = false;\n+        dte->v = true;\n+        smp_wmb();\n+    }\n     dte->domain_id = domain_id;\n     dte->pt_root = paddr_to_pfn(root_ptr);\n     dte->iw = true;\n     dte->ir = true;\n     dte->paging_mode = paging_mode;\n+    smp_wmb();\n     dte->tv = true;\n     dte->v = valid;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if ( valid || dte->v )",
                "    {",
                "        dte->tv = false;",
                "        dte->v = true;",
                "        smp_wmb();",
                "    }",
                "    smp_wmb();"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/amd_iommu_set_intremap_table",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/0514a3a25fb9ebff5d75cc8f00a9229385300858",
        "commit_title": "AMD/IOMMU: ensure suitable ordering of DTE modifications",
        "commit_text": " DMA and interrupt translation should be enabled only after other applicable DTE fields have been written. Similarly when disabling translation or when moving a device between domains, translation should first be disabled, before other entry fields get modified. Note however that the \"moving\" aspect doesn't apply to the interrupt remapping side, as domain specifics are maintained in the IRTEs here, not the DTE. We also never disable interrupt remapping once it got enabled for a device (the respective argument passed is always the immutable iommu_intremap).  This is part of XSA-347. ",
        "func_before": "void amd_iommu_set_intremap_table(\n    struct amd_iommu_dte *dte, const void *ptr,\n    const struct amd_iommu *iommu, bool valid)\n{\n    if ( ptr )\n    {\n        dte->it_root = virt_to_maddr(ptr) >> 6;\n        dte->int_tab_len = amd_iommu_intremap_table_order(ptr, iommu);\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n    }\n    else\n    {\n        dte->it_root = 0;\n        dte->int_tab_len = 0;\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;\n    }\n\n    dte->ig = false; /* unmapped interrupts result in i/o page faults */\n    dte->iv = valid;\n}",
        "func": "void amd_iommu_set_intremap_table(\n    struct amd_iommu_dte *dte, const void *ptr,\n    const struct amd_iommu *iommu, bool valid)\n{\n    if ( ptr )\n    {\n        dte->it_root = virt_to_maddr(ptr) >> 6;\n        dte->int_tab_len = amd_iommu_intremap_table_order(ptr, iommu);\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_TRANSLATED;\n    }\n    else\n    {\n        dte->it_root = 0;\n        dte->int_tab_len = 0;\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;\n    }\n\n    dte->ig = false; /* unmapped interrupts result in i/o page faults */\n    smp_wmb();\n    dte->iv = valid;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,5 +16,6 @@\n     }\n \n     dte->ig = false; /* unmapped interrupts result in i/o page faults */\n+    smp_wmb();\n     dte->iv = valid;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    smp_wmb();"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/clear_iommu_pte_present",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/3b055121c5410e2c3105d6d06aa24ca0d58868cd",
        "commit_title": "AMD/IOMMU: update live PTEs atomically",
        "commit_text": " Updating a live PTE bitfield by bitfield risks the compiler re-ordering the individual updates as well as splitting individual updates into multiple memory writes. Construct the new entry fully in a local variable, do the check to determine the flushing needs on the thus established new entry, and then write the new entry by a single insn.  Similarly using memset() to clear a PTE is unsafe, as the order of writes the function does is, at least in principle, undefined.  This is part of XSA-347. ",
        "func_before": "static unsigned int clear_iommu_pte_present(unsigned long l1_mfn,\n                                            unsigned long dfn)\n{\n    union amd_iommu_pte *table, *pte;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(l1_mfn));\n    pte = &table[pfn_to_pde_idx(dfn, 1)];\n\n    flush_flags = pte->pr ? IOMMU_FLUSHF_modified : 0;\n    memset(pte, 0, sizeof(*pte));\n\n    unmap_domain_page(table);\n\n    return flush_flags;\n}",
        "func": "static unsigned int clear_iommu_pte_present(unsigned long l1_mfn,\n                                            unsigned long dfn)\n{\n    union amd_iommu_pte *table, *pte;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(l1_mfn));\n    pte = &table[pfn_to_pde_idx(dfn, 1)];\n\n    flush_flags = pte->pr ? IOMMU_FLUSHF_modified : 0;\n    write_atomic(&pte->raw, 0);\n\n    unmap_domain_page(table);\n\n    return flush_flags;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n     pte = &table[pfn_to_pde_idx(dfn, 1)];\n \n     flush_flags = pte->pr ? IOMMU_FLUSHF_modified : 0;\n-    memset(pte, 0, sizeof(*pte));\n+    write_atomic(&pte->raw, 0);\n \n     unmap_domain_page(table);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    memset(pte, 0, sizeof(*pte));"
            ],
            "added_lines": [
                "    write_atomic(&pte->raw, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/set_iommu_pde_present",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/3b055121c5410e2c3105d6d06aa24ca0d58868cd",
        "commit_title": "AMD/IOMMU: update live PTEs atomically",
        "commit_text": " Updating a live PTE bitfield by bitfield risks the compiler re-ordering the individual updates as well as splitting individual updates into multiple memory writes. Construct the new entry fully in a local variable, do the check to determine the flushing needs on the thus established new entry, and then write the new entry by a single insn.  Similarly using memset() to clear a PTE is unsafe, as the order of writes the function does is, at least in principle, undefined.  This is part of XSA-347. ",
        "func_before": "static unsigned int set_iommu_pde_present(union amd_iommu_pte *pte,\n                                          unsigned long next_mfn,\n                                          unsigned int next_level, bool iw,\n                                          bool ir)\n{\n    unsigned int flush_flags = IOMMU_FLUSHF_added;\n\n    if ( pte->pr &&\n         (pte->mfn != next_mfn ||\n          pte->iw != iw ||\n          pte->ir != ir ||\n          pte->next_level != next_level) )\n            flush_flags |= IOMMU_FLUSHF_modified;\n\n    /*\n     * FC bit should be enabled in PTE, this helps to solve potential\n     * issues with ATS devices\n     */\n    pte->fc = !next_level;\n\n    pte->mfn = next_mfn;\n    pte->iw = iw;\n    pte->ir = ir;\n    pte->next_level = next_level;\n    pte->pr = 1;\n\n    return flush_flags;\n}",
        "func": "static unsigned int set_iommu_pde_present(union amd_iommu_pte *pte,\n                                          unsigned long next_mfn,\n                                          unsigned int next_level, bool iw,\n                                          bool ir)\n{\n    union amd_iommu_pte new = {}, old;\n    unsigned int flush_flags = IOMMU_FLUSHF_added;\n\n    /*\n     * FC bit should be enabled in PTE, this helps to solve potential\n     * issues with ATS devices\n     */\n    new.fc = !next_level;\n\n    new.mfn = next_mfn;\n    new.iw = iw;\n    new.ir = ir;\n    new.next_level = next_level;\n    new.pr = true;\n\n    old.raw = read_atomic(&pte->raw);\n    old.ign0 = 0;\n    old.ign1 = 0;\n    old.ign2 = 0;\n\n    if ( old.pr && old.raw != new.raw )\n        flush_flags |= IOMMU_FLUSHF_modified;\n\n    write_atomic(&pte->raw, new.raw);\n\n    return flush_flags;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,26 +3,30 @@\n                                           unsigned int next_level, bool iw,\n                                           bool ir)\n {\n+    union amd_iommu_pte new = {}, old;\n     unsigned int flush_flags = IOMMU_FLUSHF_added;\n-\n-    if ( pte->pr &&\n-         (pte->mfn != next_mfn ||\n-          pte->iw != iw ||\n-          pte->ir != ir ||\n-          pte->next_level != next_level) )\n-            flush_flags |= IOMMU_FLUSHF_modified;\n \n     /*\n      * FC bit should be enabled in PTE, this helps to solve potential\n      * issues with ATS devices\n      */\n-    pte->fc = !next_level;\n+    new.fc = !next_level;\n \n-    pte->mfn = next_mfn;\n-    pte->iw = iw;\n-    pte->ir = ir;\n-    pte->next_level = next_level;\n-    pte->pr = 1;\n+    new.mfn = next_mfn;\n+    new.iw = iw;\n+    new.ir = ir;\n+    new.next_level = next_level;\n+    new.pr = true;\n+\n+    old.raw = read_atomic(&pte->raw);\n+    old.ign0 = 0;\n+    old.ign1 = 0;\n+    old.ign2 = 0;\n+\n+    if ( old.pr && old.raw != new.raw )\n+        flush_flags |= IOMMU_FLUSHF_modified;\n+\n+    write_atomic(&pte->raw, new.raw);\n \n     return flush_flags;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "    if ( pte->pr &&",
                "         (pte->mfn != next_mfn ||",
                "          pte->iw != iw ||",
                "          pte->ir != ir ||",
                "          pte->next_level != next_level) )",
                "            flush_flags |= IOMMU_FLUSHF_modified;",
                "    pte->fc = !next_level;",
                "    pte->mfn = next_mfn;",
                "    pte->iw = iw;",
                "    pte->ir = ir;",
                "    pte->next_level = next_level;",
                "    pte->pr = 1;"
            ],
            "added_lines": [
                "    union amd_iommu_pte new = {}, old;",
                "    new.fc = !next_level;",
                "    new.mfn = next_mfn;",
                "    new.iw = iw;",
                "    new.ir = ir;",
                "    new.next_level = next_level;",
                "    new.pr = true;",
                "",
                "    old.raw = read_atomic(&pte->raw);",
                "    old.ign0 = 0;",
                "    old.ign1 = 0;",
                "    old.ign2 = 0;",
                "",
                "    if ( old.pr && old.raw != new.raw )",
                "        flush_flags |= IOMMU_FLUSHF_modified;",
                "",
                "    write_atomic(&pte->raw, new.raw);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/amd_dump_p2m_table_level",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/73f62c7380edf07469581a3049aba98abd63b275",
        "commit_title": "AMD/IOMMU: convert amd_iommu_pte from struct to union",
        "commit_text": " This is to add a \"raw\" counterpart to the bitfield equivalent. Take the opportunity and  - convert fields to bool / unsigned int,  - drop the naming of the reserved field,  - shorten the names of the ignored ones.  This is part of XSA-347. ",
        "func_before": "static void amd_dump_p2m_table_level(struct page_info* pg, int level, \n                                     paddr_t gpa, int indent)\n{\n    paddr_t address;\n    struct amd_iommu_pte *table_vaddr;\n    int index;\n\n    if ( level < 1 )\n        return;\n\n    table_vaddr = __map_domain_page(pg);\n    if ( table_vaddr == NULL )\n    {\n        printk(\"Failed to map IOMMU domain page %\"PRIpaddr\"\\n\", \n                page_to_maddr(pg));\n        return;\n    }\n\n    for ( index = 0; index < PTE_PER_TABLE_SIZE; index++ )\n    {\n        struct amd_iommu_pte *pde = &table_vaddr[index];\n\n        if ( !(index % 2) )\n            process_pending_softirqs();\n\n        if ( !pde->pr )\n            continue;\n\n        if ( pde->next_level && (pde->next_level != (level - 1)) )\n        {\n            printk(\"IOMMU p2m table error. next_level = %d, expected %d\\n\",\n                   pde->next_level, level - 1);\n\n            continue;\n        }\n\n        address = gpa + amd_offset_level_address(index, level);\n        if ( pde->next_level >= 1 )\n            amd_dump_p2m_table_level(\n                mfn_to_page(_mfn(pde->mfn)), pde->next_level,\n                address, indent + 1);\n        else\n            printk(\"%*sdfn: %08lx  mfn: %08lx\\n\",\n                   indent, \"\",\n                   (unsigned long)PFN_DOWN(address),\n                   (unsigned long)PFN_DOWN(pfn_to_paddr(pde->mfn)));\n    }\n\n    unmap_domain_page(table_vaddr);\n}",
        "func": "static void amd_dump_p2m_table_level(struct page_info* pg, int level, \n                                     paddr_t gpa, int indent)\n{\n    paddr_t address;\n    const union amd_iommu_pte *table_vaddr;\n    int index;\n\n    if ( level < 1 )\n        return;\n\n    table_vaddr = __map_domain_page(pg);\n    if ( table_vaddr == NULL )\n    {\n        printk(\"Failed to map IOMMU domain page %\"PRIpaddr\"\\n\", \n                page_to_maddr(pg));\n        return;\n    }\n\n    for ( index = 0; index < PTE_PER_TABLE_SIZE; index++ )\n    {\n        const union amd_iommu_pte *pde = &table_vaddr[index];\n\n        if ( !(index % 2) )\n            process_pending_softirqs();\n\n        if ( !pde->pr )\n            continue;\n\n        if ( pde->next_level && (pde->next_level != (level - 1)) )\n        {\n            printk(\"IOMMU p2m table error. next_level = %d, expected %d\\n\",\n                   pde->next_level, level - 1);\n\n            continue;\n        }\n\n        address = gpa + amd_offset_level_address(index, level);\n        if ( pde->next_level >= 1 )\n            amd_dump_p2m_table_level(\n                mfn_to_page(_mfn(pde->mfn)), pde->next_level,\n                address, indent + 1);\n        else\n            printk(\"%*sdfn: %08lx  mfn: %08lx\\n\",\n                   indent, \"\",\n                   (unsigned long)PFN_DOWN(address),\n                   (unsigned long)PFN_DOWN(pfn_to_paddr(pde->mfn)));\n    }\n\n    unmap_domain_page(table_vaddr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n                                      paddr_t gpa, int indent)\n {\n     paddr_t address;\n-    struct amd_iommu_pte *table_vaddr;\n+    const union amd_iommu_pte *table_vaddr;\n     int index;\n \n     if ( level < 1 )\n@@ -18,7 +18,7 @@\n \n     for ( index = 0; index < PTE_PER_TABLE_SIZE; index++ )\n     {\n-        struct amd_iommu_pte *pde = &table_vaddr[index];\n+        const union amd_iommu_pte *pde = &table_vaddr[index];\n \n         if ( !(index % 2) )\n             process_pending_softirqs();",
        "diff_line_info": {
            "deleted_lines": [
                "    struct amd_iommu_pte *table_vaddr;",
                "        struct amd_iommu_pte *pde = &table_vaddr[index];"
            ],
            "added_lines": [
                "    const union amd_iommu_pte *table_vaddr;",
                "        const union amd_iommu_pte *pde = &table_vaddr[index];"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/iommu_pde_from_dfn",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/73f62c7380edf07469581a3049aba98abd63b275",
        "commit_title": "AMD/IOMMU: convert amd_iommu_pte from struct to union",
        "commit_text": " This is to add a \"raw\" counterpart to the bitfield equivalent. Take the opportunity and  - convert fields to bool / unsigned int,  - drop the naming of the reserved field,  - shorten the names of the ignored ones.  This is part of XSA-347. ",
        "func_before": "static int iommu_pde_from_dfn(struct domain *d, unsigned long dfn,\n                              unsigned long pt_mfn[], bool map)\n{\n    struct amd_iommu_pte *pde, *next_table_vaddr;\n    unsigned long  next_table_mfn;\n    unsigned int level;\n    struct page_info *table;\n    const struct domain_iommu *hd = dom_iommu(d);\n\n    table = hd->arch.amd.root_table;\n    level = hd->arch.amd.paging_mode;\n\n    BUG_ON( table == NULL || level < 1 || level > 6 );\n\n    /*\n     * A frame number past what the current page tables can represent can't\n     * possibly have a mapping.\n     */\n    if ( dfn >> (PTE_PER_TABLE_SHIFT * level) )\n        return 0;\n\n    next_table_mfn = mfn_x(page_to_mfn(table));\n\n    while ( level > 1 )\n    {\n        unsigned int next_level = level - 1;\n        pt_mfn[level] = next_table_mfn;\n\n        next_table_vaddr = map_domain_page(_mfn(next_table_mfn));\n        pde = &next_table_vaddr[pfn_to_pde_idx(dfn, level)];\n\n        /* Here might be a super page frame */\n        next_table_mfn = pde->mfn;\n\n        /* Split super page frame into smaller pieces.*/\n        if ( pde->pr && !pde->next_level && next_table_mfn )\n        {\n            int i;\n            unsigned long mfn, pfn;\n            unsigned int page_sz;\n\n            page_sz = 1 << (PTE_PER_TABLE_SHIFT * (next_level - 1));\n            pfn =  dfn & ~((1 << (PTE_PER_TABLE_SHIFT * next_level)) - 1);\n            mfn = next_table_mfn;\n\n            /* allocate lower level page table */\n            table = iommu_alloc_pgtable(d);\n            if ( table == NULL )\n            {\n                AMD_IOMMU_DEBUG(\"Cannot allocate I/O page table\\n\");\n                unmap_domain_page(next_table_vaddr);\n                return 1;\n            }\n\n            next_table_mfn = mfn_x(page_to_mfn(table));\n            set_iommu_pde_present(pde, next_table_mfn, next_level, true,\n                                  true);\n\n            for ( i = 0; i < PTE_PER_TABLE_SIZE; i++ )\n            {\n                set_iommu_pte_present(next_table_mfn, pfn, mfn, next_level,\n                                      true, true);\n                mfn += page_sz;\n                pfn += page_sz;\n             }\n\n            amd_iommu_flush_all_pages(d);\n        }\n\n        /* Install lower level page table for non-present entries */\n        else if ( !pde->pr )\n        {\n            if ( !map )\n                return 0;\n\n            if ( next_table_mfn == 0 )\n            {\n                table = iommu_alloc_pgtable(d);\n                if ( table == NULL )\n                {\n                    AMD_IOMMU_DEBUG(\"Cannot allocate I/O page table\\n\");\n                    unmap_domain_page(next_table_vaddr);\n                    return 1;\n                }\n                next_table_mfn = mfn_x(page_to_mfn(table));\n                set_iommu_pde_present(pde, next_table_mfn, next_level, true,\n                                      true);\n            }\n            else /* should never reach here */\n            {\n                unmap_domain_page(next_table_vaddr);\n                return 1;\n            }\n        }\n\n        unmap_domain_page(next_table_vaddr);\n        level--;\n    }\n\n    /* mfn of level 1 page table */\n    pt_mfn[level] = next_table_mfn;\n    return 0;\n}",
        "func": "static int iommu_pde_from_dfn(struct domain *d, unsigned long dfn,\n                              unsigned long pt_mfn[], bool map)\n{\n    union amd_iommu_pte *pde, *next_table_vaddr;\n    unsigned long  next_table_mfn;\n    unsigned int level;\n    struct page_info *table;\n    const struct domain_iommu *hd = dom_iommu(d);\n\n    table = hd->arch.amd.root_table;\n    level = hd->arch.amd.paging_mode;\n\n    BUG_ON( table == NULL || level < 1 || level > 6 );\n\n    /*\n     * A frame number past what the current page tables can represent can't\n     * possibly have a mapping.\n     */\n    if ( dfn >> (PTE_PER_TABLE_SHIFT * level) )\n        return 0;\n\n    next_table_mfn = mfn_x(page_to_mfn(table));\n\n    while ( level > 1 )\n    {\n        unsigned int next_level = level - 1;\n        pt_mfn[level] = next_table_mfn;\n\n        next_table_vaddr = map_domain_page(_mfn(next_table_mfn));\n        pde = &next_table_vaddr[pfn_to_pde_idx(dfn, level)];\n\n        /* Here might be a super page frame */\n        next_table_mfn = pde->mfn;\n\n        /* Split super page frame into smaller pieces.*/\n        if ( pde->pr && !pde->next_level && next_table_mfn )\n        {\n            int i;\n            unsigned long mfn, pfn;\n            unsigned int page_sz;\n\n            page_sz = 1 << (PTE_PER_TABLE_SHIFT * (next_level - 1));\n            pfn =  dfn & ~((1 << (PTE_PER_TABLE_SHIFT * next_level)) - 1);\n            mfn = next_table_mfn;\n\n            /* allocate lower level page table */\n            table = iommu_alloc_pgtable(d);\n            if ( table == NULL )\n            {\n                AMD_IOMMU_DEBUG(\"Cannot allocate I/O page table\\n\");\n                unmap_domain_page(next_table_vaddr);\n                return 1;\n            }\n\n            next_table_mfn = mfn_x(page_to_mfn(table));\n            set_iommu_pde_present(pde, next_table_mfn, next_level, true,\n                                  true);\n\n            for ( i = 0; i < PTE_PER_TABLE_SIZE; i++ )\n            {\n                set_iommu_pte_present(next_table_mfn, pfn, mfn, next_level,\n                                      true, true);\n                mfn += page_sz;\n                pfn += page_sz;\n             }\n\n            amd_iommu_flush_all_pages(d);\n        }\n\n        /* Install lower level page table for non-present entries */\n        else if ( !pde->pr )\n        {\n            if ( !map )\n                return 0;\n\n            if ( next_table_mfn == 0 )\n            {\n                table = iommu_alloc_pgtable(d);\n                if ( table == NULL )\n                {\n                    AMD_IOMMU_DEBUG(\"Cannot allocate I/O page table\\n\");\n                    unmap_domain_page(next_table_vaddr);\n                    return 1;\n                }\n                next_table_mfn = mfn_x(page_to_mfn(table));\n                set_iommu_pde_present(pde, next_table_mfn, next_level, true,\n                                      true);\n            }\n            else /* should never reach here */\n            {\n                unmap_domain_page(next_table_vaddr);\n                return 1;\n            }\n        }\n\n        unmap_domain_page(next_table_vaddr);\n        level--;\n    }\n\n    /* mfn of level 1 page table */\n    pt_mfn[level] = next_table_mfn;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static int iommu_pde_from_dfn(struct domain *d, unsigned long dfn,\n                               unsigned long pt_mfn[], bool map)\n {\n-    struct amd_iommu_pte *pde, *next_table_vaddr;\n+    union amd_iommu_pte *pde, *next_table_vaddr;\n     unsigned long  next_table_mfn;\n     unsigned int level;\n     struct page_info *table;",
        "diff_line_info": {
            "deleted_lines": [
                "    struct amd_iommu_pte *pde, *next_table_vaddr;"
            ],
            "added_lines": [
                "    union amd_iommu_pte *pde, *next_table_vaddr;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/amd_iommu_quarantine_init",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/73f62c7380edf07469581a3049aba98abd63b275",
        "commit_title": "AMD/IOMMU: convert amd_iommu_pte from struct to union",
        "commit_text": " This is to add a \"raw\" counterpart to the bitfield equivalent. Take the opportunity and  - convert fields to bool / unsigned int,  - drop the naming of the reserved field,  - shorten the names of the ignored ones.  This is part of XSA-347. ",
        "func_before": "int __init amd_iommu_quarantine_init(struct domain *d)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    unsigned long end_gfn =\n        1ul << (DEFAULT_DOMAIN_ADDRESS_WIDTH - PAGE_SHIFT);\n    unsigned int level = amd_iommu_get_paging_mode(end_gfn);\n    struct amd_iommu_pte *table;\n\n    if ( hd->arch.amd.root_table )\n    {\n        ASSERT_UNREACHABLE();\n        return 0;\n    }\n\n    spin_lock(&hd->arch.mapping_lock);\n\n    hd->arch.amd.root_table = iommu_alloc_pgtable(d);\n    if ( !hd->arch.amd.root_table )\n        goto out;\n\n    table = __map_domain_page(hd->arch.amd.root_table);\n    while ( level )\n    {\n        struct page_info *pg;\n        unsigned int i;\n\n        /*\n         * The pgtable allocator is fine for the leaf page, as well as\n         * page table pages, and the resulting allocations are always\n         * zeroed.\n         */\n        pg = iommu_alloc_pgtable(d);\n        if ( !pg )\n            break;\n\n        for ( i = 0; i < PTE_PER_TABLE_SIZE; i++ )\n        {\n            struct amd_iommu_pte *pde = &table[i];\n\n            /*\n             * PDEs are essentially a subset of PTEs, so this function\n             * is fine to use even at the leaf.\n             */\n            set_iommu_pde_present(pde, mfn_x(page_to_mfn(pg)), level - 1,\n                                  false, true);\n        }\n\n        unmap_domain_page(table);\n        table = __map_domain_page(pg);\n        level--;\n    }\n    unmap_domain_page(table);\n\n out:\n    spin_unlock(&hd->arch.mapping_lock);\n\n    amd_iommu_flush_all_pages(d);\n\n    /* Pages leaked in failure case */\n    return level ? -ENOMEM : 0;\n}",
        "func": "int __init amd_iommu_quarantine_init(struct domain *d)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    unsigned long end_gfn =\n        1ul << (DEFAULT_DOMAIN_ADDRESS_WIDTH - PAGE_SHIFT);\n    unsigned int level = amd_iommu_get_paging_mode(end_gfn);\n    union amd_iommu_pte *table;\n\n    if ( hd->arch.amd.root_table )\n    {\n        ASSERT_UNREACHABLE();\n        return 0;\n    }\n\n    spin_lock(&hd->arch.mapping_lock);\n\n    hd->arch.amd.root_table = iommu_alloc_pgtable(d);\n    if ( !hd->arch.amd.root_table )\n        goto out;\n\n    table = __map_domain_page(hd->arch.amd.root_table);\n    while ( level )\n    {\n        struct page_info *pg;\n        unsigned int i;\n\n        /*\n         * The pgtable allocator is fine for the leaf page, as well as\n         * page table pages, and the resulting allocations are always\n         * zeroed.\n         */\n        pg = iommu_alloc_pgtable(d);\n        if ( !pg )\n            break;\n\n        for ( i = 0; i < PTE_PER_TABLE_SIZE; i++ )\n        {\n            union amd_iommu_pte *pde = &table[i];\n\n            /*\n             * PDEs are essentially a subset of PTEs, so this function\n             * is fine to use even at the leaf.\n             */\n            set_iommu_pde_present(pde, mfn_x(page_to_mfn(pg)), level - 1,\n                                  false, true);\n        }\n\n        unmap_domain_page(table);\n        table = __map_domain_page(pg);\n        level--;\n    }\n    unmap_domain_page(table);\n\n out:\n    spin_unlock(&hd->arch.mapping_lock);\n\n    amd_iommu_flush_all_pages(d);\n\n    /* Pages leaked in failure case */\n    return level ? -ENOMEM : 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n     unsigned long end_gfn =\n         1ul << (DEFAULT_DOMAIN_ADDRESS_WIDTH - PAGE_SHIFT);\n     unsigned int level = amd_iommu_get_paging_mode(end_gfn);\n-    struct amd_iommu_pte *table;\n+    union amd_iommu_pte *table;\n \n     if ( hd->arch.amd.root_table )\n     {\n@@ -35,7 +35,7 @@\n \n         for ( i = 0; i < PTE_PER_TABLE_SIZE; i++ )\n         {\n-            struct amd_iommu_pte *pde = &table[i];\n+            union amd_iommu_pte *pde = &table[i];\n \n             /*\n              * PDEs are essentially a subset of PTEs, so this function",
        "diff_line_info": {
            "deleted_lines": [
                "    struct amd_iommu_pte *table;",
                "            struct amd_iommu_pte *pde = &table[i];"
            ],
            "added_lines": [
                "    union amd_iommu_pte *table;",
                "            union amd_iommu_pte *pde = &table[i];"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/set_iommu_pte_present",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/73f62c7380edf07469581a3049aba98abd63b275",
        "commit_title": "AMD/IOMMU: convert amd_iommu_pte from struct to union",
        "commit_text": " This is to add a \"raw\" counterpart to the bitfield equivalent. Take the opportunity and  - convert fields to bool / unsigned int,  - drop the naming of the reserved field,  - shorten the names of the ignored ones.  This is part of XSA-347. ",
        "func_before": "static unsigned int set_iommu_pte_present(unsigned long pt_mfn,\n                                          unsigned long dfn,\n                                          unsigned long next_mfn,\n                                          int pde_level,\n                                          bool iw, bool ir)\n{\n    struct amd_iommu_pte *table, *pde;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(pt_mfn));\n    pde = &table[pfn_to_pde_idx(dfn, pde_level)];\n\n    flush_flags = set_iommu_pde_present(pde, next_mfn, 0, iw, ir);\n    unmap_domain_page(table);\n\n    return flush_flags;\n}",
        "func": "static unsigned int set_iommu_pte_present(unsigned long pt_mfn,\n                                          unsigned long dfn,\n                                          unsigned long next_mfn,\n                                          int pde_level,\n                                          bool iw, bool ir)\n{\n    union amd_iommu_pte *table, *pde;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(pt_mfn));\n    pde = &table[pfn_to_pde_idx(dfn, pde_level)];\n\n    flush_flags = set_iommu_pde_present(pde, next_mfn, 0, iw, ir);\n    unmap_domain_page(table);\n\n    return flush_flags;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n                                           int pde_level,\n                                           bool iw, bool ir)\n {\n-    struct amd_iommu_pte *table, *pde;\n+    union amd_iommu_pte *table, *pde;\n     unsigned int flush_flags;\n \n     table = map_domain_page(_mfn(pt_mfn));",
        "diff_line_info": {
            "deleted_lines": [
                "    struct amd_iommu_pte *table, *pde;"
            ],
            "added_lines": [
                "    union amd_iommu_pte *table, *pde;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/clear_iommu_pte_present",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/73f62c7380edf07469581a3049aba98abd63b275",
        "commit_title": "AMD/IOMMU: convert amd_iommu_pte from struct to union",
        "commit_text": " This is to add a \"raw\" counterpart to the bitfield equivalent. Take the opportunity and  - convert fields to bool / unsigned int,  - drop the naming of the reserved field,  - shorten the names of the ignored ones.  This is part of XSA-347. ",
        "func_before": "static unsigned int clear_iommu_pte_present(unsigned long l1_mfn,\n                                            unsigned long dfn)\n{\n    struct amd_iommu_pte *table, *pte;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(l1_mfn));\n    pte = &table[pfn_to_pde_idx(dfn, 1)];\n\n    flush_flags = pte->pr ? IOMMU_FLUSHF_modified : 0;\n    memset(pte, 0, sizeof(*pte));\n\n    unmap_domain_page(table);\n\n    return flush_flags;\n}",
        "func": "static unsigned int clear_iommu_pte_present(unsigned long l1_mfn,\n                                            unsigned long dfn)\n{\n    union amd_iommu_pte *table, *pte;\n    unsigned int flush_flags;\n\n    table = map_domain_page(_mfn(l1_mfn));\n    pte = &table[pfn_to_pde_idx(dfn, 1)];\n\n    flush_flags = pte->pr ? IOMMU_FLUSHF_modified : 0;\n    memset(pte, 0, sizeof(*pte));\n\n    unmap_domain_page(table);\n\n    return flush_flags;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static unsigned int clear_iommu_pte_present(unsigned long l1_mfn,\n                                             unsigned long dfn)\n {\n-    struct amd_iommu_pte *table, *pte;\n+    union amd_iommu_pte *table, *pte;\n     unsigned int flush_flags;\n \n     table = map_domain_page(_mfn(l1_mfn));",
        "diff_line_info": {
            "deleted_lines": [
                "    struct amd_iommu_pte *table, *pte;"
            ],
            "added_lines": [
                "    union amd_iommu_pte *table, *pte;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27670",
        "func_name": "xen-project/xen/set_iommu_pde_present",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because an AMD IOMMU page-table entry can be half-updated.",
        "git_url": "https://github.com/xen-project/xen/commit/73f62c7380edf07469581a3049aba98abd63b275",
        "commit_title": "AMD/IOMMU: convert amd_iommu_pte from struct to union",
        "commit_text": " This is to add a \"raw\" counterpart to the bitfield equivalent. Take the opportunity and  - convert fields to bool / unsigned int,  - drop the naming of the reserved field,  - shorten the names of the ignored ones.  This is part of XSA-347. ",
        "func_before": "static unsigned int set_iommu_pde_present(struct amd_iommu_pte *pte,\n                                          unsigned long next_mfn,\n                                          unsigned int next_level, bool iw,\n                                          bool ir)\n{\n    unsigned int flush_flags = IOMMU_FLUSHF_added;\n\n    if ( pte->pr &&\n         (pte->mfn != next_mfn ||\n          pte->iw != iw ||\n          pte->ir != ir ||\n          pte->next_level != next_level) )\n            flush_flags |= IOMMU_FLUSHF_modified;\n\n    /*\n     * FC bit should be enabled in PTE, this helps to solve potential\n     * issues with ATS devices\n     */\n    pte->fc = !next_level;\n\n    pte->mfn = next_mfn;\n    pte->iw = iw;\n    pte->ir = ir;\n    pte->next_level = next_level;\n    pte->pr = 1;\n\n    return flush_flags;\n}",
        "func": "static unsigned int set_iommu_pde_present(union amd_iommu_pte *pte,\n                                          unsigned long next_mfn,\n                                          unsigned int next_level, bool iw,\n                                          bool ir)\n{\n    unsigned int flush_flags = IOMMU_FLUSHF_added;\n\n    if ( pte->pr &&\n         (pte->mfn != next_mfn ||\n          pte->iw != iw ||\n          pte->ir != ir ||\n          pte->next_level != next_level) )\n            flush_flags |= IOMMU_FLUSHF_modified;\n\n    /*\n     * FC bit should be enabled in PTE, this helps to solve potential\n     * issues with ATS devices\n     */\n    pte->fc = !next_level;\n\n    pte->mfn = next_mfn;\n    pte->iw = iw;\n    pte->ir = ir;\n    pte->next_level = next_level;\n    pte->pr = 1;\n\n    return flush_flags;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static unsigned int set_iommu_pde_present(struct amd_iommu_pte *pte,\n+static unsigned int set_iommu_pde_present(union amd_iommu_pte *pte,\n                                           unsigned long next_mfn,\n                                           unsigned int next_level, bool iw,\n                                           bool ir)",
        "diff_line_info": {
            "deleted_lines": [
                "static unsigned int set_iommu_pde_present(struct amd_iommu_pte *pte,"
            ],
            "added_lines": [
                "static unsigned int set_iommu_pde_present(union amd_iommu_pte *pte,"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-20271",
        "func_name": "rpm-software-management/rpm/headerMergeLegacySigs",
        "description": "A flaw was found in RPM's signature check functionality when reading a package file. This flaw allows an attacker who can convince a victim to install a seemingly verifiable package, whose signature header was modified, to cause RPM database corruption and execute code. The highest threat from this vulnerability is to data integrity, confidentiality, and system availability.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/d6a86b5e69e46cc283b1e06c92343319beb42e21",
        "commit_title": "Be much more careful about copying data from the signature header",
        "commit_text": " Only look for known tags, and ensure correct type and size where known before copying over. Bump the old arbitrary 16k count limit to 16M limit though, it's not inconceivable that a package could have that many files. While at it, ensure none of these tags exist in the main header, which would confuse us greatly.  This is optimized for backporting ease, upstream can remove redundancies and further improve checking later.  Reported and initial patches by Demi Marie Obenour.  ",
        "func_before": "static\nvoid headerMergeLegacySigs(Header h, Header sigh)\n{\n    HeaderIterator hi;\n    struct rpmtd_s td;\n\n    hi = headerInitIterator(sigh);\n    for (; headerNext(hi, &td); rpmtdFreeData(&td))\n    {\n\tswitch (td.tag) {\n\t/* XXX Translate legacy signature tag values. */\n\tcase RPMSIGTAG_SIZE:\n\t    td.tag = RPMTAG_SIGSIZE;\n\t    break;\n\tcase RPMSIGTAG_PGP:\n\t    td.tag = RPMTAG_SIGPGP;\n\t    break;\n\tcase RPMSIGTAG_MD5:\n\t    td.tag = RPMTAG_SIGMD5;\n\t    break;\n\tcase RPMSIGTAG_GPG:\n\t    td.tag = RPMTAG_SIGGPG;\n\t    break;\n\tcase RPMSIGTAG_PGP5:\n\t    td.tag = RPMTAG_SIGPGP5;\n\t    break;\n\tcase RPMSIGTAG_PAYLOADSIZE:\n\t    td.tag = RPMTAG_ARCHIVESIZE;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURES:\n\t    td.tag = RPMTAG_FILESIGNATURES;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURELENGTH:\n\t    td.tag = RPMTAG_FILESIGNATURELENGTH;\n\t    break;\n\tcase RPMSIGTAG_VERITYSIGNATURES:\n\tcase RPMSIGTAG_VERITYSIGNATUREALGO:\n\tcase RPMSIGTAG_SHA1:\n\tcase RPMSIGTAG_SHA256:\n\tcase RPMSIGTAG_DSA:\n\tcase RPMSIGTAG_RSA:\n\tdefault:\n\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))\n\t\tcontinue;\n\t    break;\n\t}\n\tif (!headerIsEntry(h, td.tag)) {\n\t    switch (td.type) {\n\t    case RPM_NULL_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    case RPM_CHAR_TYPE:\n\t    case RPM_INT8_TYPE:\n\t    case RPM_INT16_TYPE:\n\t    case RPM_INT32_TYPE:\n\t    case RPM_INT64_TYPE:\n\t\tif (td.count != 1)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_STRING_TYPE:\n\t    case RPM_STRING_ARRAY_TYPE:\n\t    case RPM_BIN_TYPE:\n\t\tif (td.count >= 16*1024)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_I18NSTRING_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    }\n\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);\n\t}\n    }\n    headerFreeIterator(hi);\n}",
        "func": "static\nrpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)\n{\n    const struct taglate_s *xl;\n    struct rpmtd_s td;\n\n    rpmtdReset(&td);\n    for (xl = xlateTags; xl->stag; xl++) {\n\t/* There mustn't be one in the main header */\n\tif (headerIsEntry(h, xl->xtag))\n\t    break;\n\tif (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {\n\t    /* Translate legacy tags */\n\t    if (xl->stag != xl->xtag)\n\t\ttd.tag = xl->xtag;\n\t    /* Ensure type and tag size match expectations */\n\t    if (td.type != rpmTagGetTagType(td.tag))\n\t\tbreak;\n\t    if (td.count < 1 || td.count > 16*1024*1024)\n\t\tbreak;\n\t    if (xl->count && td.count != xl->count)\n\t\tbreak;\n\t    if (!headerPut(h, &td, HEADERPUT_DEFAULT))\n\t\tbreak;\n\t    rpmtdFreeData(&td);\n\t}\n    }\n    rpmtdFreeData(&td);\n\n    if (xl->stag) {\n\trasprintf(msg, \"invalid signature tag %s (%d)\",\n\t\t\trpmTagGetName(xl->xtag), xl->xtag);\n    }\n\n    return xl->stag;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,74 +1,36 @@\n static\n-void headerMergeLegacySigs(Header h, Header sigh)\n+rpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)\n {\n-    HeaderIterator hi;\n+    const struct taglate_s *xl;\n     struct rpmtd_s td;\n \n-    hi = headerInitIterator(sigh);\n-    for (; headerNext(hi, &td); rpmtdFreeData(&td))\n-    {\n-\tswitch (td.tag) {\n-\t/* XXX Translate legacy signature tag values. */\n-\tcase RPMSIGTAG_SIZE:\n-\t    td.tag = RPMTAG_SIGSIZE;\n+    rpmtdReset(&td);\n+    for (xl = xlateTags; xl->stag; xl++) {\n+\t/* There mustn't be one in the main header */\n+\tif (headerIsEntry(h, xl->xtag))\n \t    break;\n-\tcase RPMSIGTAG_PGP:\n-\t    td.tag = RPMTAG_SIGPGP;\n-\t    break;\n-\tcase RPMSIGTAG_MD5:\n-\t    td.tag = RPMTAG_SIGMD5;\n-\t    break;\n-\tcase RPMSIGTAG_GPG:\n-\t    td.tag = RPMTAG_SIGGPG;\n-\t    break;\n-\tcase RPMSIGTAG_PGP5:\n-\t    td.tag = RPMTAG_SIGPGP5;\n-\t    break;\n-\tcase RPMSIGTAG_PAYLOADSIZE:\n-\t    td.tag = RPMTAG_ARCHIVESIZE;\n-\t    break;\n-\tcase RPMSIGTAG_FILESIGNATURES:\n-\t    td.tag = RPMTAG_FILESIGNATURES;\n-\t    break;\n-\tcase RPMSIGTAG_FILESIGNATURELENGTH:\n-\t    td.tag = RPMTAG_FILESIGNATURELENGTH;\n-\t    break;\n-\tcase RPMSIGTAG_VERITYSIGNATURES:\n-\tcase RPMSIGTAG_VERITYSIGNATUREALGO:\n-\tcase RPMSIGTAG_SHA1:\n-\tcase RPMSIGTAG_SHA256:\n-\tcase RPMSIGTAG_DSA:\n-\tcase RPMSIGTAG_RSA:\n-\tdefault:\n-\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))\n-\t\tcontinue;\n-\t    break;\n-\t}\n-\tif (!headerIsEntry(h, td.tag)) {\n-\t    switch (td.type) {\n-\t    case RPM_NULL_TYPE:\n-\t\tcontinue;\n+\tif (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {\n+\t    /* Translate legacy tags */\n+\t    if (xl->stag != xl->xtag)\n+\t\ttd.tag = xl->xtag;\n+\t    /* Ensure type and tag size match expectations */\n+\t    if (td.type != rpmTagGetTagType(td.tag))\n \t\tbreak;\n-\t    case RPM_CHAR_TYPE:\n-\t    case RPM_INT8_TYPE:\n-\t    case RPM_INT16_TYPE:\n-\t    case RPM_INT32_TYPE:\n-\t    case RPM_INT64_TYPE:\n-\t\tif (td.count != 1)\n-\t\t    continue;\n+\t    if (td.count < 1 || td.count > 16*1024*1024)\n \t\tbreak;\n-\t    case RPM_STRING_TYPE:\n-\t    case RPM_STRING_ARRAY_TYPE:\n-\t    case RPM_BIN_TYPE:\n-\t\tif (td.count >= 16*1024)\n-\t\t    continue;\n+\t    if (xl->count && td.count != xl->count)\n \t\tbreak;\n-\t    case RPM_I18NSTRING_TYPE:\n-\t\tcontinue;\n+\t    if (!headerPut(h, &td, HEADERPUT_DEFAULT))\n \t\tbreak;\n-\t    }\n-\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);\n+\t    rpmtdFreeData(&td);\n \t}\n     }\n-    headerFreeIterator(hi);\n+    rpmtdFreeData(&td);\n+\n+    if (xl->stag) {\n+\trasprintf(msg, \"invalid signature tag %s (%d)\",\n+\t\t\trpmTagGetName(xl->xtag), xl->xtag);\n+    }\n+\n+    return xl->stag;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "void headerMergeLegacySigs(Header h, Header sigh)",
                "    HeaderIterator hi;",
                "    hi = headerInitIterator(sigh);",
                "    for (; headerNext(hi, &td); rpmtdFreeData(&td))",
                "    {",
                "\tswitch (td.tag) {",
                "\t/* XXX Translate legacy signature tag values. */",
                "\tcase RPMSIGTAG_SIZE:",
                "\t    td.tag = RPMTAG_SIGSIZE;",
                "\tcase RPMSIGTAG_PGP:",
                "\t    td.tag = RPMTAG_SIGPGP;",
                "\t    break;",
                "\tcase RPMSIGTAG_MD5:",
                "\t    td.tag = RPMTAG_SIGMD5;",
                "\t    break;",
                "\tcase RPMSIGTAG_GPG:",
                "\t    td.tag = RPMTAG_SIGGPG;",
                "\t    break;",
                "\tcase RPMSIGTAG_PGP5:",
                "\t    td.tag = RPMTAG_SIGPGP5;",
                "\t    break;",
                "\tcase RPMSIGTAG_PAYLOADSIZE:",
                "\t    td.tag = RPMTAG_ARCHIVESIZE;",
                "\t    break;",
                "\tcase RPMSIGTAG_FILESIGNATURES:",
                "\t    td.tag = RPMTAG_FILESIGNATURES;",
                "\t    break;",
                "\tcase RPMSIGTAG_FILESIGNATURELENGTH:",
                "\t    td.tag = RPMTAG_FILESIGNATURELENGTH;",
                "\t    break;",
                "\tcase RPMSIGTAG_VERITYSIGNATURES:",
                "\tcase RPMSIGTAG_VERITYSIGNATUREALGO:",
                "\tcase RPMSIGTAG_SHA1:",
                "\tcase RPMSIGTAG_SHA256:",
                "\tcase RPMSIGTAG_DSA:",
                "\tcase RPMSIGTAG_RSA:",
                "\tdefault:",
                "\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))",
                "\t\tcontinue;",
                "\t    break;",
                "\t}",
                "\tif (!headerIsEntry(h, td.tag)) {",
                "\t    switch (td.type) {",
                "\t    case RPM_NULL_TYPE:",
                "\t\tcontinue;",
                "\t    case RPM_CHAR_TYPE:",
                "\t    case RPM_INT8_TYPE:",
                "\t    case RPM_INT16_TYPE:",
                "\t    case RPM_INT32_TYPE:",
                "\t    case RPM_INT64_TYPE:",
                "\t\tif (td.count != 1)",
                "\t\t    continue;",
                "\t    case RPM_STRING_TYPE:",
                "\t    case RPM_STRING_ARRAY_TYPE:",
                "\t    case RPM_BIN_TYPE:",
                "\t\tif (td.count >= 16*1024)",
                "\t\t    continue;",
                "\t    case RPM_I18NSTRING_TYPE:",
                "\t\tcontinue;",
                "\t    }",
                "\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);",
                "    headerFreeIterator(hi);"
            ],
            "added_lines": [
                "rpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)",
                "    const struct taglate_s *xl;",
                "    rpmtdReset(&td);",
                "    for (xl = xlateTags; xl->stag; xl++) {",
                "\t/* There mustn't be one in the main header */",
                "\tif (headerIsEntry(h, xl->xtag))",
                "\tif (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {",
                "\t    /* Translate legacy tags */",
                "\t    if (xl->stag != xl->xtag)",
                "\t\ttd.tag = xl->xtag;",
                "\t    /* Ensure type and tag size match expectations */",
                "\t    if (td.type != rpmTagGetTagType(td.tag))",
                "\t    if (td.count < 1 || td.count > 16*1024*1024)",
                "\t    if (xl->count && td.count != xl->count)",
                "\t    if (!headerPut(h, &td, HEADERPUT_DEFAULT))",
                "\t    rpmtdFreeData(&td);",
                "    rpmtdFreeData(&td);",
                "",
                "    if (xl->stag) {",
                "\trasprintf(msg, \"invalid signature tag %s (%d)\",",
                "\t\t\trpmTagGetName(xl->xtag), xl->xtag);",
                "    }",
                "",
                "    return xl->stag;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-20271",
        "func_name": "rpm-software-management/rpm/rpmReadPackageFile",
        "description": "A flaw was found in RPM's signature check functionality when reading a package file. This flaw allows an attacker who can convince a victim to install a seemingly verifiable package, whose signature header was modified, to cause RPM database corruption and execute code. The highest threat from this vulnerability is to data integrity, confidentiality, and system availability.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/d6a86b5e69e46cc283b1e06c92343319beb42e21",
        "commit_title": "Be much more careful about copying data from the signature header",
        "commit_text": " Only look for known tags, and ensure correct type and size where known before copying over. Bump the old arbitrary 16k count limit to 16M limit though, it's not inconceivable that a package could have that many files. While at it, ensure none of these tags exist in the main header, which would confuse us greatly.  This is optimized for backporting ease, upstream can remove redundancies and further improve checking later.  Reported and initial patches by Demi Marie Obenour.  ",
        "func_before": "rpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n\n    /* XXX: lots of 3rd party software relies on the behavior */\n    if (hdrp)\n\t*hdrp = NULL;\n\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n\n    /* Actually all verify discovered signatures and digests */\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\t/* Finally import the headers and do whatever required retrofits etc */\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\n\t    /* Append (and remap) signature tags to the metadata. */\n\t    headerMergeLegacySigs(h, sigh);\n\t    applyRetrofits(h);\n\n\t    /* Bump reference count for return. */\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n\n    /* If there was a \"substatus\" (NOKEY in practise), return that instead */\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\n\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n\n    return rc;\n}",
        "func": "rpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n\n    /* XXX: lots of 3rd party software relies on the behavior */\n    if (hdrp)\n\t*hdrp = NULL;\n\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n\n    /* Actually all verify discovered signatures and digests */\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\t/* Finally import the headers and do whatever required retrofits etc */\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\n\t    /* Append (and remap) signature tags to the metadata. */\n\t    if (headerMergeLegacySigs(h, sigh, &msg))\n\t\tgoto exit;\n\t    applyRetrofits(h);\n\n\t    /* Bump reference count for return. */\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n\n    /* If there was a \"substatus\" (NOKEY in practise), return that instead */\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\n\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,8 @@\n \t\tgoto exit;\n \n \t    /* Append (and remap) signature tags to the metadata. */\n-\t    headerMergeLegacySigs(h, sigh);\n+\t    if (headerMergeLegacySigs(h, sigh, &msg))\n+\t\tgoto exit;\n \t    applyRetrofits(h);\n \n \t    /* Bump reference count for return. */",
        "diff_line_info": {
            "deleted_lines": [
                "\t    headerMergeLegacySigs(h, sigh);"
            ],
            "added_lines": [
                "\t    if (headerMergeLegacySigs(h, sigh, &msg))",
                "\t\tgoto exit;"
            ]
        }
    }
]