[
    {
        "cve_id": "CVE-2022-41859",
        "func_name": "FreeRADIUS/freeradius-server/compute_password_element",
        "description": "In freeradius, the EAP-PWD function compute_password_element() leaks information about the password which allows an attacker to substantially reduce the size of an offline dictionary attack.",
        "git_url": "https://github.com/FreeRADIUS/freeradius-server/commit/9e5e8f2f912ad2da8ac6e176ac3a606333469937",
        "commit_title": "port fixes from master",
        "commit_text": " via the simple expedient of copying the entire function, with some minor changes to work in v3",
        "func_before": "int compute_password_element (REQUEST *request, pwd_session_t *session, uint16_t grp_num,\n\t\t\t      char const *password, int password_len,\n\t\t\t      char const *id_server, int id_server_len,\n\t\t\t      char const *id_peer, int id_peer_len,\n\t\t\t      uint32_t *token)\n{\n\tBIGNUM *x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL;\n\tHMAC_CTX *ctx = NULL;\n\tuint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, ctr;\n\tint nid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;\n\tint save, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;\n\tunsigned int skip;\n\n\tctx = HMAC_CTX_new();\n\tif (ctx == NULL) {\n\t\tDEBUG(\"failed allocating HMAC context\");\n\t\tgoto fail;\n\t}\n\n\tswitch (grp_num) { /* from IANA registry for IKE D-H groups */\n\tcase 19:\n\t\tnid = NID_X9_62_prime256v1;\n\t\tbreak;\n\n\tcase 20:\n\t\tnid = NID_secp384r1;\n\t\tbreak;\n\n\tcase 21:\n\t\tnid = NID_secp521r1;\n\t\tbreak;\n\n\tcase 25:\n\t\tnid = NID_X9_62_prime192v1;\n\t\tbreak;\n\n\tcase 26:\n\t\tnid = NID_secp224r1;\n\t\tbreak;\n\n\tdefault:\n\t\tDEBUG(\"unknown group %d\", grp_num);\n\t\tgoto fail;\n\t}\n\n\tsession->pwe = NULL;\n\tsession->order = NULL;\n\tsession->prime = NULL;\n\n\tif ((session->group = EC_GROUP_new_by_curve_name(nid)) == NULL) {\n\t\tDEBUG(\"unable to create EC_GROUP\");\n\t\tgoto fail;\n\t}\n\n\tif (((rnd = consttime_BN()) == NULL) ||\n\t    ((session->pwe = EC_POINT_new(session->group)) == NULL) ||\n\t    ((session->order = consttime_BN()) == NULL) ||\n\t    ((session->prime = consttime_BN()) == NULL) ||\n\t    ((qr = consttime_BN()) == NULL) ||\n\t    ((qnr = consttime_BN()) == NULL) ||\n\t    ((x_candidate = consttime_BN()) == NULL) ||\n\t    ((y_sqrd = consttime_BN()) == NULL)) {\n\t\tDEBUG(\"unable to create bignums\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_curve(session->group, session->prime, NULL, NULL, NULL)) {\n\t\tDEBUG(\"unable to get prime for GFp curve\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_order(session->group, session->order, NULL)) {\n\t\tDEBUG(\"unable to get order for curve\");\n\t\tgoto fail;\n\t}\n\n\tprimebitlen = BN_num_bits(session->prime);\n\tprimebytelen = BN_num_bytes(session->prime);\n\tif ((prfbuf = talloc_zero_array(session, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for prf buffer\");\n\t\tgoto fail;\n\t}\n\tif ((xbuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for x buffer\");\n\t\tgoto fail;\n\t}\n\tif ((pm1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for pm1 buffer\");\n\t\tgoto fail;\n\t}\n\n\t/*\n\t* derive random quadradic residue and quadratic non-residue\n\t*/\n\tdo {\n\t\tBN_rand_range(qr, session->prime);\n\t} while (legendre(qr, session->prime, session->bnctx) != 1);\n\n\tdo {\n\t\tBN_rand_range(qnr, session->prime);\n\t} while (legendre(qnr, session->prime, session->bnctx) != -1);\n\n\tif (!BN_sub(rnd, session->prime, BN_value_one())) {\n\t\tgoto fail;\n\t}\n\tBN_bn2bin(rnd, pm1buf);\n\n\tsave_is_odd = 0;\n\tfound = 0;\n\tmemset(xbuf, 0, primebytelen);\n\tctr = 0;\n\twhile (ctr < 40) {\n\t\tctr++;\n\n\t\t/*\n\t\t * compute counter-mode password value and stretch to prime\n\t\t *\tpwd-seed = H(token | peer-id | server-id | password |\n\t\t *\t\t     counter)\n\t\t */\n\t\tHMAC_Init_ex(ctx, allzero, SHA256_DIGEST_LENGTH, EVP_sha256(),NULL);\n\t\tHMAC_Update(ctx, (uint8_t *)token, sizeof(*token));\n\t\tHMAC_Update(ctx, (uint8_t const *)id_peer, id_peer_len);\n\t\tHMAC_Update(ctx, (uint8_t const *)id_server, id_server_len);\n\t\tHMAC_Update(ctx, (uint8_t const *)password, password_len);\n\t\tHMAC_Update(ctx, (uint8_t *)&ctr, sizeof(ctr));\n\t\tpwd_hmac_final(ctx, pwe_digest);\n\n\t\tBN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd);\n\t\teap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, \"EAP-pwd Hunting And Pecking\",\n\t\t\t    strlen(\"EAP-pwd Hunting And Pecking\"), prfbuf, primebitlen);\n\n\t\t/*\n\t\t * eap_pwd_kdf() returns a string of bits 0..primebitlen but\n\t\t * BN_bin2bn will treat that string of bits as a big endian\n\t\t * number. If the primebitlen is not an even multiple of 8\n\t\t * then excessive bits-- those _after_ primebitlen-- so now\n\t\t * we have to shift right the amount we masked off.\n\t\t */\n\t\tif (primebitlen % 8) {\n\t\t\trbits = 8 - (primebitlen % 8);\n\t\t\tfor (i = primebytelen - 1; i > 0; i--) {\n\t\t\t\tprfbuf[i] = (prfbuf[i - 1] << (8 - rbits)) | (prfbuf[i] >> rbits);\n\t\t\t}\n\t\t\tprfbuf[0] >>= rbits;\n\t\t}\n\t\tBN_bin2bn(prfbuf, primebytelen, x_candidate);\n\n\t\t/*\n\t\t* it would've been better if the spec reduced the candidate\n\t\t* modulo the prime but it didn't. So if the candidate >= prime\n\t\t* we need to skip it but still run through the operations below\n\t\t*/\n\t\tcmp = const_time_memcmp(pm1buf, prfbuf, primebytelen);\n\t\tskip = const_time_fill_msb((unsigned int)cmp);\n\n\t\t/*\n\t\t* need to unambiguously identify the solution, if there is\n\t\t* one..\n\t\t*/\n\t\tis_odd = BN_is_odd(rnd) ? 1 : 0;\n\n\t\t/*\n\t\t* check whether x^3 + a*x + b is a quadratic residue\n\t\t*\n\t\t* save the first quadratic residue we find in the loop but do\n\t\t* it in constant time.\n\t\t*/\n\t\tdo_equation(session->group, y_sqrd, x_candidate, session->bnctx);\n\t\tqr_or_qnr = is_quadratic_residue(y_sqrd, session->prime, qr, qnr, session->bnctx);\n\n\t\t/*\n\t\t* if the candidate >= prime then we want to skip it\n\t\t*/\n\t\tqr_or_qnr = const_time_select(skip, 0, qr_or_qnr);\n\n\t\t/*\n\t\t* if we haven't found PWE yet (found = 0) then mask will be true,\n\t\t* if we have found PWE then mask will be false\n\t\t*/\n\t\tmask = const_time_select(found, 0, -1);\n\n\t\t/*\n\t\t* save will be 1 if we want to save this value-- i.e. we haven't\n\t\t* found PWE yet and this is a quadratic residue-- and 0 otherwise\n\t\t*/\n\t\tsave = const_time_select(mask, qr_or_qnr, 0);\n\n\t\t/*\n\t\t* mask will be true (-1) if we want to save this and false (0)\n\t\t* otherwise\n\t\t*/\n\t\tmask = const_time_eq(save, 1);\n\n\t\tconst_time_select_bin(mask, prfbuf, xbuf, primebytelen, xbuf);\n\t\tsave_is_odd = const_time_select(mask, is_odd, save_is_odd);\n\t\tfound = const_time_select(mask, -1, found);\n\t}\n\n\t/*\n\t* now we can savely construct PWE\n\t*/\n\tBN_bin2bn(xbuf, primebytelen, x_candidate);\n\tif (!EC_POINT_set_compressed_coordinates(session->group, session->pwe,\n\t\t\t\t\t\t     x_candidate, save_is_odd, NULL)) {\n\t\tgoto fail;\n\t}\n\n\tsession->group_num = grp_num;\n\tif (0) {\n\t\tfail:\t\t/* DON'T free session, it's in handler->opaque */\n\t\tret = -1;\n\t}\n\n\t/* cleanliness and order.... */\n\tBN_clear_free(x_candidate);\n\tBN_clear_free(y_sqrd);\n\tBN_clear_free(qr);\n\tBN_clear_free(qnr);\n\tBN_clear_free(rnd);\n\n\tif (prfbuf) talloc_free(prfbuf);\n\tif (xbuf) talloc_free(xbuf);\n\tif (pm1buf) talloc_free(pm1buf);\n\n\tHMAC_CTX_free(ctx);\n\n\treturn ret;\n}",
        "func": "int compute_password_element (REQUEST *request, pwd_session_t *session, uint16_t grp_num,\n\t\t\t      char const *password, int password_len,\n\t\t\t      char const *id_server, int id_server_len,\n\t\t\t      char const *id_peer, int id_peer_len,\n\t\t\t      uint32_t *token)\n{\n\tBIGNUM\t\t*x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL, *y1 = NULL, *y2 = NULL, *y = NULL, *exp = NULL;\n\tEVP_MD_CTX\t*hmac_ctx;\n\tEVP_PKEY\t*hmac_pkey;\n\tuint8_t\t\tpwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, *y1buf = NULL, *y2buf = NULL, *ybuf = NULL, ctr;\n\tint\t\tnid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;\n\tint\t\tsave, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;\n\tunsigned int\tskip;\n\n\tMEM(hmac_ctx = EVP_MD_CTX_new());\n\tMEM(hmac_pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, allzero, sizeof(allzero)));\n\n\tswitch (grp_num) { /* from IANA registry for IKE D-H groups */\n\tcase 19:\n\t\tnid = NID_X9_62_prime256v1;\n\t\tbreak;\n\n\tcase 20:\n\t\tnid = NID_secp384r1;\n\t\tbreak;\n\n\tcase 21:\n\t\tnid = NID_secp521r1;\n\t\tbreak;\n\n\tcase 25:\n\t\tnid = NID_X9_62_prime192v1;\n\t\tbreak;\n\n\tcase 26:\n\t\tnid = NID_secp224r1;\n\t\tbreak;\n\n\tdefault:\n\t\tDEBUG(\"unknown group %d\", grp_num);\n\t\tgoto fail;\n\t}\n\n\tsession->pwe = NULL;\n\tsession->order = NULL;\n\tsession->prime = NULL;\n\n\tif ((session->group = EC_GROUP_new_by_curve_name(nid)) == NULL) {\n\t\tDEBUG(\"unable to create EC_GROUP\");\n\t\tgoto fail;\n\t}\n\n\tif (((rnd = consttime_BN()) == NULL) ||\n\t    ((session->pwe = EC_POINT_new(session->group)) == NULL) ||\n\t    ((session->order = consttime_BN()) == NULL) ||\n\t    ((session->prime = consttime_BN()) == NULL) ||\n\t    ((qr = consttime_BN()) == NULL) ||\n\t    ((qnr = consttime_BN()) == NULL) ||\n\t    ((x_candidate = consttime_BN()) == NULL) ||\n\t    ((y_sqrd = consttime_BN()) == NULL) ||\n\t    ((y1 = consttime_BN()) == NULL) ||\n\t    ((y2 = consttime_BN()) == NULL) ||\n\t    ((y = consttime_BN()) == NULL) ||\n        ((exp = consttime_BN()) == NULL)) {\n\t\tDEBUG(\"unable to create bignums\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_curve(session->group, session->prime, NULL, NULL, NULL)) {\n\t\tDEBUG(\"unable to get prime for GFp curve\");\n\t\tgoto fail;\n\t}\n\n\tif (!EC_GROUP_get_order(session->group, session->order, NULL)) {\n\t\tDEBUG(\"unable to get order for curve\");\n\t\tgoto fail;\n\t}\n\n\tprimebitlen = BN_num_bits(session->prime);\n\tprimebytelen = BN_num_bytes(session->prime);\n\tif ((prfbuf = talloc_zero_array(session, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for prf buffer\");\n\t\tgoto fail;\n\t}\n\tif ((xbuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for x buffer\");\n\t\tgoto fail;\n\t}\n\tif ((pm1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for pm1 buffer\");\n\t\tgoto fail;\n\t}\n\tif ((y1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for y1 buffer\");\n\t\tgoto fail;\n\t}\n\tif ((y2buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for y2 buffer\");\n\t\tgoto fail;\n\t}\n\tif ((ybuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n\t\tDEBUG(\"unable to alloc space for y buffer\");\n\t\tgoto fail;\n\t}\n\n\n\t/*\n\t* derive random quadradic residue and quadratic non-residue\n\t*/\n\tdo {\n\t\tBN_rand_range(qr, session->prime);\n\t} while (legendre(qr, session->prime, session->bnctx) != 1);\n\n\tdo {\n\t\tBN_rand_range(qnr, session->prime);\n\t} while (legendre(qnr, session->prime, session->bnctx) != -1);\n\n\tif (!BN_sub(rnd, session->prime, BN_value_one())) {\n\t\tgoto fail;\n\t}\n\tBN_bn2bin(rnd, pm1buf);\n\n\tsave_is_odd = 0;\n\tfound = 0;\n\tmemset(xbuf, 0, primebytelen);\n\tctr = 0;\n\twhile (ctr < 40) {\n\t\tctr++;\n\n\t\t/*\n\t\t * compute counter-mode password value and stretch to prime\n\t\t *\tpwd-seed = H(token | peer-id | server-id | password |\n\t\t *\t\t     counter)\n\t\t */\n\t\tEVP_DigestSignInit(hmac_ctx, NULL, EVP_sha256(), NULL, hmac_pkey);\n\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t *)token, sizeof(*token));\n\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_peer, id_peer_len);\n\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_server, id_server_len);\n\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)password, password_len);\n\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t *)&ctr, sizeof(ctr));\n\n\t\t{\n\t\t\tsize_t mdlen = SHA256_DIGEST_LENGTH;\n\n\t\t\tEVP_DigestSignFinal(hmac_ctx, pwe_digest, &mdlen);\n\t\t\tEVP_MD_CTX_reset(hmac_ctx);\n\t\t}\n\n\t\tBN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd);\n\t\teap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, \"EAP-pwd Hunting And Pecking\",\n\t\t\t    strlen(\"EAP-pwd Hunting And Pecking\"), prfbuf, primebitlen);\n\n\t\t/*\n\t\t * eap_pwd_kdf() returns a string of bits 0..primebitlen but\n\t\t * BN_bin2bn will treat that string of bits as a big endian\n\t\t * number. If the primebitlen is not an even multiple of 8\n\t\t * then excessive bits-- those _after_ primebitlen-- so now\n\t\t * we have to shift right the amount we masked off.\n\t\t */\n\t\tif (primebitlen % 8) {\n\t\t\trbits = 8 - (primebitlen % 8);\n\t\t\tfor (i = primebytelen - 1; i > 0; i--) {\n\t\t\t\tprfbuf[i] = (prfbuf[i - 1] << (8 - rbits)) | (prfbuf[i] >> rbits);\n\t\t\t}\n\t\t\tprfbuf[0] >>= rbits;\n\t\t}\n\t\tBN_bin2bn(prfbuf, primebytelen, x_candidate);\n\n\t\t/*\n\t\t* it would've been better if the spec reduced the candidate\n\t\t* modulo the prime but it didn't. So if the candidate >= prime\n\t\t* we need to skip it but still run through the operations below\n\t\t*/\n\t\tcmp = const_time_memcmp(pm1buf, prfbuf, primebytelen);\n\t\tskip = const_time_fill_msb((unsigned int)cmp);\n\n\t\t/*\n\t\t* need to unambiguously identify the solution, if there is\n\t\t* one..\n\t\t*/\n\t\tis_odd = BN_is_odd(rnd);\n\n\t\t/*\n\t\t* check whether x^3 + a*x + b is a quadratic residue\n\t\t*\n\t\t* save the first quadratic residue we find in the loop but do\n\t\t* it in constant time.\n\t\t*/\n\t\tdo_equation(session->group, y_sqrd, x_candidate, session->bnctx);\n\t\tqr_or_qnr = is_quadratic_residue(y_sqrd, session->prime, qr, qnr, session->bnctx);\n\n\t\t/*\n\t\t* if the candidate >= prime then we want to skip it\n\t\t*/\n\t\tqr_or_qnr = const_time_select(skip, 0, qr_or_qnr);\n\n\t\t/*\n\t\t* if we haven't found PWE yet (found = 0) then mask will be true,\n\t\t* if we have found PWE then mask will be false\n\t\t*/\n\t\tmask = const_time_select(found, 0, -1);\n\n\t\t/*\n\t\t* save will be 1 if we want to save this value-- i.e. we haven't\n\t\t* found PWE yet and this is a quadratic residue-- and 0 otherwise\n\t\t*/\n\t\tsave = const_time_select(mask, qr_or_qnr, 0);\n\n\t\t/*\n\t\t* mask will be true (-1) if we want to save this and false (0)\n\t\t* otherwise\n\t\t*/\n\t\tmask = const_time_eq(save, 1);\n\n\t\tconst_time_select_bin(mask, prfbuf, xbuf, primebytelen, xbuf);\n\t\tsave_is_odd = const_time_select(mask, is_odd, save_is_odd);\n\t\tfound = const_time_select(mask, -1, found);\n\t}\n\n\t/*\n\t* now we can savely construct PWE\n\t*/\n\tBN_bin2bn(xbuf, primebytelen, x_candidate);\n\tdo_equation(session->group, y_sqrd, x_candidate, session->bnctx);\n\tif ( !BN_add(exp, session->prime, BN_value_one()) ||\n\t\t !BN_rshift(exp, exp, 2) ||\n\t\t !BN_mod_exp_mont_consttime(y1, y_sqrd, exp, session->prime, session->bnctx, NULL) ||\n\t\t !BN_sub(y2, session->prime, y1) ||\n\t\t !BN_bn2bin(y1, y1buf) ||\n\t\t !BN_bn2bin(y2, y2buf)) {\n\t\tDEBUG(\"unable to compute y\");\n\t\tgoto fail;\n\t}\n\tmask = const_time_eq(save_is_odd, BN_is_odd(y1));\n\tconst_time_select_bin(mask, y1buf, y2buf, primebytelen, ybuf);\n\tif (BN_bin2bn(ybuf, primebytelen, y) == NULL ||\n\t\t!EC_POINT_set_affine_coordinates(session->group, session->pwe, x_candidate, y, session->bnctx)) {\n\t\tDEBUG(\"unable to set point coordinate\");\n\t\tgoto fail;\n\t}\n\n\tsession->group_num = grp_num;\n\tif (0) {\n\t\tfail:\t\t/* DON'T free session, it's in handler->opaque */\n\t\tret = -1;\n\t}\n\n\t/* cleanliness and order.... */\n\tBN_clear_free(x_candidate);\n\tBN_clear_free(y_sqrd);\n\tBN_clear_free(qr);\n\tBN_clear_free(qnr);\n\tBN_clear_free(rnd);\n\tBN_clear_free(y1);\n\tBN_clear_free(y2);\n\tBN_clear_free(y);\n\tBN_clear_free(exp);\n\n\tif (prfbuf) talloc_free(prfbuf);\n\tif (xbuf) talloc_free(xbuf);\n\tif (pm1buf) talloc_free(pm1buf);\n\tif (y1buf) talloc_free(y1buf);\n\tif (y2buf) talloc_free(y2buf);\n\tif (ybuf) talloc_free(ybuf);\n\n\tEVP_MD_CTX_free(hmac_ctx);\n\tEVP_PKEY_free(hmac_pkey);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,18 +4,16 @@\n \t\t\t      char const *id_peer, int id_peer_len,\n \t\t\t      uint32_t *token)\n {\n-\tBIGNUM *x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL;\n-\tHMAC_CTX *ctx = NULL;\n-\tuint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, ctr;\n-\tint nid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;\n-\tint save, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;\n-\tunsigned int skip;\n-\n-\tctx = HMAC_CTX_new();\n-\tif (ctx == NULL) {\n-\t\tDEBUG(\"failed allocating HMAC context\");\n-\t\tgoto fail;\n-\t}\n+\tBIGNUM\t\t*x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL, *y1 = NULL, *y2 = NULL, *y = NULL, *exp = NULL;\n+\tEVP_MD_CTX\t*hmac_ctx;\n+\tEVP_PKEY\t*hmac_pkey;\n+\tuint8_t\t\tpwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, *y1buf = NULL, *y2buf = NULL, *ybuf = NULL, ctr;\n+\tint\t\tnid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;\n+\tint\t\tsave, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;\n+\tunsigned int\tskip;\n+\n+\tMEM(hmac_ctx = EVP_MD_CTX_new());\n+\tMEM(hmac_pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, allzero, sizeof(allzero)));\n \n \tswitch (grp_num) { /* from IANA registry for IKE D-H groups */\n \tcase 19:\n@@ -59,7 +57,11 @@\n \t    ((qr = consttime_BN()) == NULL) ||\n \t    ((qnr = consttime_BN()) == NULL) ||\n \t    ((x_candidate = consttime_BN()) == NULL) ||\n-\t    ((y_sqrd = consttime_BN()) == NULL)) {\n+\t    ((y_sqrd = consttime_BN()) == NULL) ||\n+\t    ((y1 = consttime_BN()) == NULL) ||\n+\t    ((y2 = consttime_BN()) == NULL) ||\n+\t    ((y = consttime_BN()) == NULL) ||\n+        ((exp = consttime_BN()) == NULL)) {\n \t\tDEBUG(\"unable to create bignums\");\n \t\tgoto fail;\n \t}\n@@ -88,6 +90,19 @@\n \t\tDEBUG(\"unable to alloc space for pm1 buffer\");\n \t\tgoto fail;\n \t}\n+\tif ((y1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n+\t\tDEBUG(\"unable to alloc space for y1 buffer\");\n+\t\tgoto fail;\n+\t}\n+\tif ((y2buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n+\t\tDEBUG(\"unable to alloc space for y2 buffer\");\n+\t\tgoto fail;\n+\t}\n+\tif ((ybuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {\n+\t\tDEBUG(\"unable to alloc space for y buffer\");\n+\t\tgoto fail;\n+\t}\n+\n \n \t/*\n \t* derive random quadradic residue and quadratic non-residue\n@@ -117,13 +132,19 @@\n \t\t *\tpwd-seed = H(token | peer-id | server-id | password |\n \t\t *\t\t     counter)\n \t\t */\n-\t\tHMAC_Init_ex(ctx, allzero, SHA256_DIGEST_LENGTH, EVP_sha256(),NULL);\n-\t\tHMAC_Update(ctx, (uint8_t *)token, sizeof(*token));\n-\t\tHMAC_Update(ctx, (uint8_t const *)id_peer, id_peer_len);\n-\t\tHMAC_Update(ctx, (uint8_t const *)id_server, id_server_len);\n-\t\tHMAC_Update(ctx, (uint8_t const *)password, password_len);\n-\t\tHMAC_Update(ctx, (uint8_t *)&ctr, sizeof(ctr));\n-\t\tpwd_hmac_final(ctx, pwe_digest);\n+\t\tEVP_DigestSignInit(hmac_ctx, NULL, EVP_sha256(), NULL, hmac_pkey);\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t *)token, sizeof(*token));\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_peer, id_peer_len);\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_server, id_server_len);\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)password, password_len);\n+\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t *)&ctr, sizeof(ctr));\n+\n+\t\t{\n+\t\t\tsize_t mdlen = SHA256_DIGEST_LENGTH;\n+\n+\t\t\tEVP_DigestSignFinal(hmac_ctx, pwe_digest, &mdlen);\n+\t\t\tEVP_MD_CTX_reset(hmac_ctx);\n+\t\t}\n \n \t\tBN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd);\n \t\teap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, \"EAP-pwd Hunting And Pecking\",\n@@ -157,7 +178,7 @@\n \t\t* need to unambiguously identify the solution, if there is\n \t\t* one..\n \t\t*/\n-\t\tis_odd = BN_is_odd(rnd) ? 1 : 0;\n+\t\tis_odd = BN_is_odd(rnd);\n \n \t\t/*\n \t\t* check whether x^3 + a*x + b is a quadratic residue\n@@ -200,8 +221,21 @@\n \t* now we can savely construct PWE\n \t*/\n \tBN_bin2bn(xbuf, primebytelen, x_candidate);\n-\tif (!EC_POINT_set_compressed_coordinates(session->group, session->pwe,\n-\t\t\t\t\t\t     x_candidate, save_is_odd, NULL)) {\n+\tdo_equation(session->group, y_sqrd, x_candidate, session->bnctx);\n+\tif ( !BN_add(exp, session->prime, BN_value_one()) ||\n+\t\t !BN_rshift(exp, exp, 2) ||\n+\t\t !BN_mod_exp_mont_consttime(y1, y_sqrd, exp, session->prime, session->bnctx, NULL) ||\n+\t\t !BN_sub(y2, session->prime, y1) ||\n+\t\t !BN_bn2bin(y1, y1buf) ||\n+\t\t !BN_bn2bin(y2, y2buf)) {\n+\t\tDEBUG(\"unable to compute y\");\n+\t\tgoto fail;\n+\t}\n+\tmask = const_time_eq(save_is_odd, BN_is_odd(y1));\n+\tconst_time_select_bin(mask, y1buf, y2buf, primebytelen, ybuf);\n+\tif (BN_bin2bn(ybuf, primebytelen, y) == NULL ||\n+\t\t!EC_POINT_set_affine_coordinates(session->group, session->pwe, x_candidate, y, session->bnctx)) {\n+\t\tDEBUG(\"unable to set point coordinate\");\n \t\tgoto fail;\n \t}\n \n@@ -217,12 +251,20 @@\n \tBN_clear_free(qr);\n \tBN_clear_free(qnr);\n \tBN_clear_free(rnd);\n+\tBN_clear_free(y1);\n+\tBN_clear_free(y2);\n+\tBN_clear_free(y);\n+\tBN_clear_free(exp);\n \n \tif (prfbuf) talloc_free(prfbuf);\n \tif (xbuf) talloc_free(xbuf);\n \tif (pm1buf) talloc_free(pm1buf);\n-\n-\tHMAC_CTX_free(ctx);\n+\tif (y1buf) talloc_free(y1buf);\n+\tif (y2buf) talloc_free(y2buf);\n+\tif (ybuf) talloc_free(ybuf);\n+\n+\tEVP_MD_CTX_free(hmac_ctx);\n+\tEVP_PKEY_free(hmac_pkey);\n \n \treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tBIGNUM *x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL;",
                "\tHMAC_CTX *ctx = NULL;",
                "\tuint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, ctr;",
                "\tint nid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;",
                "\tint save, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;",
                "\tunsigned int skip;",
                "",
                "\tctx = HMAC_CTX_new();",
                "\tif (ctx == NULL) {",
                "\t\tDEBUG(\"failed allocating HMAC context\");",
                "\t\tgoto fail;",
                "\t}",
                "\t    ((y_sqrd = consttime_BN()) == NULL)) {",
                "\t\tHMAC_Init_ex(ctx, allzero, SHA256_DIGEST_LENGTH, EVP_sha256(),NULL);",
                "\t\tHMAC_Update(ctx, (uint8_t *)token, sizeof(*token));",
                "\t\tHMAC_Update(ctx, (uint8_t const *)id_peer, id_peer_len);",
                "\t\tHMAC_Update(ctx, (uint8_t const *)id_server, id_server_len);",
                "\t\tHMAC_Update(ctx, (uint8_t const *)password, password_len);",
                "\t\tHMAC_Update(ctx, (uint8_t *)&ctr, sizeof(ctr));",
                "\t\tpwd_hmac_final(ctx, pwe_digest);",
                "\t\tis_odd = BN_is_odd(rnd) ? 1 : 0;",
                "\tif (!EC_POINT_set_compressed_coordinates(session->group, session->pwe,",
                "\t\t\t\t\t\t     x_candidate, save_is_odd, NULL)) {",
                "",
                "\tHMAC_CTX_free(ctx);"
            ],
            "added_lines": [
                "\tBIGNUM\t\t*x_candidate = NULL, *rnd = NULL, *y_sqrd = NULL, *qr = NULL, *qnr = NULL, *y1 = NULL, *y2 = NULL, *y = NULL, *exp = NULL;",
                "\tEVP_MD_CTX\t*hmac_ctx;",
                "\tEVP_PKEY\t*hmac_pkey;",
                "\tuint8_t\t\tpwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, *xbuf = NULL, *pm1buf = NULL, *y1buf = NULL, *y2buf = NULL, *ybuf = NULL, ctr;",
                "\tint\t\tnid, is_odd, primebitlen, primebytelen, ret = 0, found = 0, mask;",
                "\tint\t\tsave, i, rbits, qr_or_qnr, save_is_odd = 0, cmp;",
                "\tunsigned int\tskip;",
                "",
                "\tMEM(hmac_ctx = EVP_MD_CTX_new());",
                "\tMEM(hmac_pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, allzero, sizeof(allzero)));",
                "\t    ((y_sqrd = consttime_BN()) == NULL) ||",
                "\t    ((y1 = consttime_BN()) == NULL) ||",
                "\t    ((y2 = consttime_BN()) == NULL) ||",
                "\t    ((y = consttime_BN()) == NULL) ||",
                "        ((exp = consttime_BN()) == NULL)) {",
                "\tif ((y1buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {",
                "\t\tDEBUG(\"unable to alloc space for y1 buffer\");",
                "\t\tgoto fail;",
                "\t}",
                "\tif ((y2buf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {",
                "\t\tDEBUG(\"unable to alloc space for y2 buffer\");",
                "\t\tgoto fail;",
                "\t}",
                "\tif ((ybuf = talloc_zero_array(request, uint8_t, primebytelen)) == NULL) {",
                "\t\tDEBUG(\"unable to alloc space for y buffer\");",
                "\t\tgoto fail;",
                "\t}",
                "",
                "\t\tEVP_DigestSignInit(hmac_ctx, NULL, EVP_sha256(), NULL, hmac_pkey);",
                "\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t *)token, sizeof(*token));",
                "\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_peer, id_peer_len);",
                "\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)id_server, id_server_len);",
                "\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t const *)password, password_len);",
                "\t\tEVP_DigestSignUpdate(hmac_ctx, (uint8_t *)&ctr, sizeof(ctr));",
                "",
                "\t\t{",
                "\t\t\tsize_t mdlen = SHA256_DIGEST_LENGTH;",
                "",
                "\t\t\tEVP_DigestSignFinal(hmac_ctx, pwe_digest, &mdlen);",
                "\t\t\tEVP_MD_CTX_reset(hmac_ctx);",
                "\t\t}",
                "\t\tis_odd = BN_is_odd(rnd);",
                "\tdo_equation(session->group, y_sqrd, x_candidate, session->bnctx);",
                "\tif ( !BN_add(exp, session->prime, BN_value_one()) ||",
                "\t\t !BN_rshift(exp, exp, 2) ||",
                "\t\t !BN_mod_exp_mont_consttime(y1, y_sqrd, exp, session->prime, session->bnctx, NULL) ||",
                "\t\t !BN_sub(y2, session->prime, y1) ||",
                "\t\t !BN_bn2bin(y1, y1buf) ||",
                "\t\t !BN_bn2bin(y2, y2buf)) {",
                "\t\tDEBUG(\"unable to compute y\");",
                "\t\tgoto fail;",
                "\t}",
                "\tmask = const_time_eq(save_is_odd, BN_is_odd(y1));",
                "\tconst_time_select_bin(mask, y1buf, y2buf, primebytelen, ybuf);",
                "\tif (BN_bin2bn(ybuf, primebytelen, y) == NULL ||",
                "\t\t!EC_POINT_set_affine_coordinates(session->group, session->pwe, x_candidate, y, session->bnctx)) {",
                "\t\tDEBUG(\"unable to set point coordinate\");",
                "\tBN_clear_free(y1);",
                "\tBN_clear_free(y2);",
                "\tBN_clear_free(y);",
                "\tBN_clear_free(exp);",
                "\tif (y1buf) talloc_free(y1buf);",
                "\tif (y2buf) talloc_free(y2buf);",
                "\tif (ybuf) talloc_free(ybuf);",
                "",
                "\tEVP_MD_CTX_free(hmac_ctx);",
                "\tEVP_PKEY_free(hmac_pkey);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-5260",
        "func_name": "git/credential_write_item",
        "description": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that contain an encoded newline can inject unintended values into the credential helper protocol stream, causing the credential helper to retrieve the password for one server (e.g., good.example.com) for an HTTP request being made to another server (e.g., evil.example.com), resulting in credentials for the former being sent to the latter. There are no restrictions on the relationship between the two, meaning that an attacker can craft a URL that will present stored credentials for any host to a host of their choosing. The vulnerability can be triggered by feeding a malicious URL to git clone. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The problem has been patched in the versions published on April 14th, 2020, going back to v2.17.x. Anyone wishing to backport the change further can do so by applying commit 9a6bbee (the full release includes extra checks for git fsck, but that commit is sufficient to protect clients against the vulnerability). The patched versions are: 2.17.4, 2.18.3, 2.19.4, 2.20.3, 2.21.2, 2.22.3, 2.23.2, 2.24.2, 2.25.3, 2.26.1.",
        "git_url": "https://github.com/git/git/commit/9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b",
        "commit_title": "credential: avoid writing values with newlines",
        "commit_text": " The credential protocol that we use to speak to helpers can't represent values with newlines in them. This was an intentional design choice to keep the protocol simple, since none of the values we pass should generally have newlines.  However, if we _do_ encounter a newline in a value, we blindly transmit it in credential_write(). Such values may break the protocol syntax, or worse, inject new valid lines into the protocol stream.  The most likely way for a newline to end up in a credential struct is by decoding a URL with a percent-encoded newline. However, since the bug occurs at the moment we write the value to the protocol, we'll catch it there. That should leave no possibility of accidentally missing a code path that can trigger the problem.  At this level of the code we have little choice but to die(). However, since we'd not ever expect to see this case outside of a malicious URL, that's an acceptable outcome. ",
        "func_before": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}",
        "func": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\"credential value for %s contains newline\", key);\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,7 @@\n {\n \tif (!value)\n \t\treturn;\n+\tif (strchr(value, '\\n'))\n+\t\tdie(\"credential value for %s contains newline\", key);\n \tfprintf(fp, \"%s=%s\\n\", key, value);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (strchr(value, '\\n'))",
                "\t\tdie(\"credential value for %s contains newline\", key);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11008",
        "func_name": "git/credential_from_url_gently",
        "description": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. This bug is similar to CVE-2020-5260(GHSA-qm7j-c969-7j4q). The fix for that bug still left the door open for an exploit where _some_ credential is leaked (but the attacker cannot control which one). Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that are considered illegal as of the recently published Git versions can cause Git to send a \"blank\" pattern to helpers, missing hostname and protocol fields. Many helpers will interpret this as matching _any_ URL, and will return some unspecified stored password, leaking the password to an attacker's server. The vulnerability can be triggered by feeding a malicious URL to `git clone`. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The root of the problem is in Git itself, which should not be feeding blank input to helpers. However, the ability to exploit the vulnerability in practice depends on which helpers are in use. Credential helpers which are known to trigger the vulnerability: - Git's \"store\" helper - Git's \"cache\" helper - the \"osxkeychain\" helper that ships in Git's \"contrib\" directory Credential helpers which are known to be safe even with vulnerable versions of Git: - Git Credential Manager for Windows Any helper not in this list should be assumed to trigger the vulnerability.",
        "git_url": "https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282",
        "commit_title": "credential: treat URL without scheme as invalid",
        "commit_text": " libcurl permits making requests without a URL scheme specified.  In this case, it guesses the URL from the hostname, so I can run  \tgit ls-remote http::ftp.example.com/path/to/repo  and it would make an FTP request.  Any user intentionally using such a URL is likely to have made a typo. Unfortunately, credential_from_url is not able to determine the host and protocol in order to determine appropriate credentials to send, and until \"credential: refuse to operate when missing host or protocol\", this resulted in another host's credentials being leaked to the named host.  Teach credential_from_url_gently to consider such a URL to be invalid so that fsck can detect and block gitmodules files with such URLs, allowing server operators to avoid serving them to downstream users running older versions of Git.  This also means that when such URLs are passed on the command line, Git will print a clearer error so affected users can switch to the simpler URL that explicitly specifies the host and protocol they intend.  One subtlety: .gitmodules files can contain relative URLs, representing a URL relative to the URL they were cloned from.  The relative URL resolver used for .gitmodules can follow \"..\" components out of the path part and past the host part of a URL, meaning that such a relative URL can be used to traverse from a https://foo.example.com/innocent superproject to a https::attacker.example.com/exploit submodule. Fortunately a leading ':' in the first path component after a series of leading './' and '../' components is unlikely to show up in other contexts, so we can catch this by detecting that pattern. ",
        "func_before": "int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
        "func": "int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!proto_end) {\n\t\tif (!quiet)\n\t\t\twarning(_(\"url has no scheme: %s\"), url);\n\t\treturn -1;\n\t}\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,11 @@\n \t *   (3) proto://<user>:<pass>@<host>/...\n \t */\n \tproto_end = strstr(url, \"://\");\n-\tif (!proto_end)\n-\t\treturn 0;\n+\tif (!proto_end) {\n+\t\tif (!quiet)\n+\t\t\twarning(_(\"url has no scheme: %s\"), url);\n+\t\treturn -1;\n+\t}\n \tcp = proto_end + 3;\n \tat = strchr(cp, '@');\n \tcolon = strchr(cp, ':');",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!proto_end)",
                "\t\treturn 0;"
            ],
            "added_lines": [
                "\tif (!proto_end) {",
                "\t\tif (!quiet)",
                "\t\t\twarning(_(\"url has no scheme: %s\"), url);",
                "\t\treturn -1;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11008",
        "func_name": "git/check_submodule_url",
        "description": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. This bug is similar to CVE-2020-5260(GHSA-qm7j-c969-7j4q). The fix for that bug still left the door open for an exploit where _some_ credential is leaked (but the attacker cannot control which one). Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that are considered illegal as of the recently published Git versions can cause Git to send a \"blank\" pattern to helpers, missing hostname and protocol fields. Many helpers will interpret this as matching _any_ URL, and will return some unspecified stored password, leaking the password to an attacker's server. The vulnerability can be triggered by feeding a malicious URL to `git clone`. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The root of the problem is in Git itself, which should not be feeding blank input to helpers. However, the ability to exploit the vulnerability in practice depends on which helpers are in use. Credential helpers which are known to trigger the vulnerability: - Git's \"store\" helper - Git's \"cache\" helper - the \"osxkeychain\" helper that ships in Git's \"contrib\" directory Credential helpers which are known to be safe even with vulnerable versions of Git: - Git Credential Manager for Windows Any helper not in this list should be assumed to trigger the vulnerability.",
        "git_url": "https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282",
        "commit_title": "credential: treat URL without scheme as invalid",
        "commit_text": " libcurl permits making requests without a URL scheme specified.  In this case, it guesses the URL from the hostname, so I can run  \tgit ls-remote http::ftp.example.com/path/to/repo  and it would make an FTP request.  Any user intentionally using such a URL is likely to have made a typo. Unfortunately, credential_from_url is not able to determine the host and protocol in order to determine appropriate credentials to send, and until \"credential: refuse to operate when missing host or protocol\", this resulted in another host's credentials being leaked to the named host.  Teach credential_from_url_gently to consider such a URL to be invalid so that fsck can detect and block gitmodules files with such URLs, allowing server operators to avoid serving them to downstream users running older versions of Git.  This also means that when such URLs are passed on the command line, Git will print a clearer error so affected users can switch to the simpler URL that explicitly specifies the host and protocol they intend.  One subtlety: .gitmodules files can contain relative URLs, representing a URL relative to the URL they were cloned from.  The relative URL resolver used for .gitmodules can follow \"..\" components out of the path part and past the host part of a URL, meaning that such a relative URL can be used to traverse from a https://foo.example.com/innocent superproject to a https::attacker.example.com/exploit submodule. Fortunately a leading ':' in the first path component after a series of leading './' and '../' components is unlikely to show up in other contexts, so we can catch this by detecting that pattern. ",
        "func_before": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "func": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded;\n\t\tconst char *next;\n\t\tint has_nl;\n\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tdecoded = url_decode(url);\n\t\thas_nl = !!strchr(decoded, '\\n');\n\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * URLs which escape their root via \"../\" can overwrite\n\t\t * the host field and previous components, resolving to\n\t\t * URLs like https::example.com/submodule.git that were\n\t\t * susceptible to CVE-2020-11008.\n\t\t */\n\t\tif (count_leading_dotdots(url, &next) > 0 &&\n\t\t    *next == ':')\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,14 +6,29 @@\n \t\treturn -1;\n \n \tif (submodule_url_is_relative(url)) {\n+\t\tchar *decoded;\n+\t\tconst char *next;\n+\t\tint has_nl;\n+\n \t\t/*\n \t\t * This could be appended to an http URL and url-decoded;\n \t\t * check for malicious characters.\n \t\t */\n-\t\tchar *decoded = url_decode(url);\n-\t\tint has_nl = !!strchr(decoded, '\\n');\n+\t\tdecoded = url_decode(url);\n+\t\thas_nl = !!strchr(decoded, '\\n');\n+\n \t\tfree(decoded);\n \t\tif (has_nl)\n+\t\t\treturn -1;\n+\n+\t\t/*\n+\t\t * URLs which escape their root via \"../\" can overwrite\n+\t\t * the host field and previous components, resolving to\n+\t\t * URLs like https::example.com/submodule.git that were\n+\t\t * susceptible to CVE-2020-11008.\n+\t\t */\n+\t\tif (count_leading_dotdots(url, &next) > 0 &&\n+\t\t    *next == ':')\n \t\t\treturn -1;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tchar *decoded = url_decode(url);",
                "\t\tint has_nl = !!strchr(decoded, '\\n');"
            ],
            "added_lines": [
                "\t\tchar *decoded;",
                "\t\tconst char *next;",
                "\t\tint has_nl;",
                "",
                "\t\tdecoded = url_decode(url);",
                "\t\thas_nl = !!strchr(decoded, '\\n');",
                "",
                "\t\t\treturn -1;",
                "",
                "\t\t/*",
                "\t\t * URLs which escape their root via \"../\" can overwrite",
                "\t\t * the host field and previous components, resolving to",
                "\t\t * URLs like https::example.com/submodule.git that were",
                "\t\t * susceptible to CVE-2020-11008.",
                "\t\t */",
                "\t\tif (count_leading_dotdots(url, &next) > 0 &&",
                "\t\t    *next == ':')"
            ]
        }
    }
]